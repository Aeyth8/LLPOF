#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DeceiveInc

#include "Basic.hpp"

#include "DeceiveInc_classes.hpp"
#include "DeceiveInc_parameters.hpp"


namespace SDK
{

// Function DeceiveInc.BotActionInteract.OnLocaInteractionCompleted
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotActionInteract::OnLocaInteractionCompleted(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotActionInteract", "OnLocaInteractionCompleted");

	Params::BotActionInteract_OnLocaInteractionCompleted Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BotActionInteract.OnReceiveMoveCompleted
// (Final, Native, Protected)
// Parameters:
// struct FAIRequestID                     RequestId                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPathFollowingResult                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotActionInteract::OnReceiveMoveCompleted(const struct FAIRequestID& RequestId, EPathFollowingResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotActionInteract", "OnReceiveMoveCompleted");

	Params::BotActionInteract_OnReceiveMoveCompleted Parms{};

	Parms.RequestId = std::move(RequestId);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BotActionMoveTo.OnReceiveMoveCompleted
// (Final, Native, Protected)
// Parameters:
// struct FAIRequestID                     RequestId                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPathFollowingResult                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotActionMoveTo::OnReceiveMoveCompleted(const struct FAIRequestID& RequestId, EPathFollowingResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotActionMoveTo", "OnReceiveMoveCompleted");

	Params::BotActionMoveTo_OnReceiveMoveCompleted Parms{};

	Parms.RequestId = std::move(RequestId);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncCheatManager.CheatEndGame
// (Final, Exec, Native, Public)

void UDeceiveIncCheatManager::CheatEndGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncCheatManager", "CheatEndGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncCheatManager.CheatEndGameSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void UDeceiveIncCheatManager::CheatEndGameSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncCheatManager", "CheatEndGameSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncCheatManager.CheatIgnorePrivateLobbyMinimumPlayerCount
// (Final, Exec, Native, Public)

void UDeceiveIncCheatManager::CheatIgnorePrivateLobbyMinimumPlayerCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncCheatManager", "CheatIgnorePrivateLobbyMinimumPlayerCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncCheatManager.CheatMenuCatalogueTogglePageLock
// (Final, Exec, Native, Public)

void UDeceiveIncCheatManager::CheatMenuCatalogueTogglePageLock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncCheatManager", "CheatMenuCatalogueTogglePageLock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncCheatManager.CheatMenuEnableFreeLootBundle
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   ItemId0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemId1                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemId2                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDeceiveIncCheatManager::CheatMenuEnableFreeLootBundle(int32 ItemId0, int32 ItemId1, int32 ItemId2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncCheatManager", "CheatMenuEnableFreeLootBundle");

	Params::DeceiveIncCheatManager_CheatMenuEnableFreeLootBundle Parms{};

	Parms.ItemId0 = ItemId0;
	Parms.ItemId1 = ItemId1;
	Parms.ItemId2 = ItemId2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncCheatManager.CheatMenuEnableInventory
// (Final, Exec, Native, Public)

void UDeceiveIncCheatManager::CheatMenuEnableInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncCheatManager", "CheatMenuEnableInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncCheatManager.CheatMenuGiveFakeLootBundles
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDeceiveIncCheatManager::CheatMenuGiveFakeLootBundles(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncCheatManager", "CheatMenuGiveFakeLootBundles");

	Params::DeceiveIncCheatManager_CheatMenuGiveFakeLootBundles Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncCheatManager.CheatSetXpTypeLvlAndXp
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           XpType                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Lvl                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   XpAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EXpProgressionType                      ProgressionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDeceiveIncCheatManager::CheatSetXpTypeLvlAndXp(const class FString& XpType, int32 Lvl, int32 XpAmount, EXpProgressionType ProgressionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncCheatManager", "CheatSetXpTypeLvlAndXp");

	Params::DeceiveIncCheatManager_CheatSetXpTypeLvlAndXp Parms{};

	Parms.XpType = std::move(XpType);
	Parms.Lvl = Lvl;
	Parms.XpAmount = XpAmount;
	Parms.ProgressionType = ProgressionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncCheatManager.CheatShowcollisionPatch
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDeceiveIncCheatManager::CheatShowcollisionPatch(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncCheatManager", "CheatShowcollisionPatch");

	Params::DeceiveIncCheatManager_CheatShowcollisionPatch Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncCheatManager.CheatTestSpawnPlayers
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   NbTeams                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NbPlayersPerTeam                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDeceiveIncCheatManager::CheatTestSpawnPlayers(int32 NbTeams, int32 NbPlayersPerTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncCheatManager", "CheatTestSpawnPlayers");

	Params::DeceiveIncCheatManager_CheatTestSpawnPlayers Parms{};

	Parms.NbTeams = NbTeams;
	Parms.NbPlayersPerTeam = NbPlayersPerTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncCheatManager.CheatToggleDebugInputAccelerator
// (Final, Exec, Native, Public)

void UDeceiveIncCheatManager::CheatToggleDebugInputAccelerator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncCheatManager", "CheatToggleDebugInputAccelerator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncCheatManager.CheatToggleDebugWidgetScale
// (Final, Exec, Native, Public)

void UDeceiveIncCheatManager::CheatToggleDebugWidgetScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncCheatManager", "CheatToggleDebugWidgetScale");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncCheatManager.CheatTriggerShaderPrecompile
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bShowMenu                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDeceiveIncCheatManager::CheatTriggerShaderPrecompile(bool bShowMenu)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncCheatManager", "CheatTriggerShaderPrecompile");

	Params::DeceiveIncCheatManager_CheatTriggerShaderPrecompile Parms{};

	Parms.bShowMenu = bShowMenu;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.AddActorToIgnoreList
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::AddActorToIgnoreList(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "AddActorToIgnoreList");

	Params::BaseSpyTool_AddActorToIgnoreList Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.AnimSwitchToPoudrier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFirstPerson                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseSpyTool::AnimSwitchToPoudrier(bool bFirstPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "AnimSwitchToPoudrier");

	Params::BaseSpyTool_AnimSwitchToPoudrier Parms{};

	Parms.bFirstPerson = bFirstPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.ApplyNewBalancingTableAndUpdateStats
// (Native, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                       NewTable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NewBalancingName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::ApplyNewBalancingTableAndUpdateStats(class UDataTable* NewTable, class FName NewBalancingName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "ApplyNewBalancingTableAndUpdateStats");

	Params::BaseSpyTool_ApplyNewBalancingTableAndUpdateStats Parms{};

	Parms.NewTable = NewTable;
	Parms.NewBalancingName = NewBalancingName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.ApplyWrapToComponent
// (Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   TargetComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ApplyToChildrens                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::ApplyWrapToComponent(class UMeshComponent* TargetComponent, bool ApplyToChildrens)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "ApplyWrapToComponent");

	Params::BaseSpyTool_ApplyWrapToComponent Parms{};

	Parms.TargetComponent = TargetComponent;
	Parms.ApplyToChildrens = ApplyToChildrens;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.AttachToNewPreferredAttachSocket
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Parent                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         LocationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         RotationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         ScaleRule                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWeldSimulatedBodies                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NewPreferredAttachSocket                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::AttachToNewPreferredAttachSocket(class USceneComponent* Parent, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies, class FName NewPreferredAttachSocket)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "AttachToNewPreferredAttachSocket");

	Params::BaseSpyTool_AttachToNewPreferredAttachSocket Parms{};

	Parms.Parent = Parent;
	Parms.LocationRule = LocationRule;
	Parms.RotationRule = RotationRule;
	Parms.ScaleRule = ScaleRule;
	Parms.bWeldSimulatedBodies = bWeldSimulatedBodies;
	Parms.NewPreferredAttachSocket = NewPreferredAttachSocket;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.BP_HideToolFromAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldAffectSecondaryTool                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::BP_HideToolFromAnim(bool bShouldAffectSecondaryTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "BP_HideToolFromAnim");

	Params::BaseSpyTool_BP_HideToolFromAnim Parms{};

	Parms.bShouldAffectSecondaryTool = bShouldAffectSecondaryTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.BP_OnGameRulesetChanged
// (Event, Public, BlueprintEvent)

void ABaseSpyTool::BP_OnGameRulesetChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "BP_OnGameRulesetChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.BaseSpyTool.BP_OnOperatorRelease
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           ReleasingOperator                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::BP_OnOperatorRelease(class AActor* ReleasingOperator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "BP_OnOperatorRelease");

	Params::BaseSpyTool_BP_OnOperatorRelease Parms{};

	Parms.ReleasingOperator = ReleasingOperator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseSpyTool.BP_OnOwnerSet
// (Event, Public, BlueprintEvent)
// Parameters:
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::BP_OnOwnerSet(class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "BP_OnOwnerSet");

	Params::BaseSpyTool_BP_OnOwnerSet Parms{};

	Parms.SpyTool = SpyTool;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseSpyTool.BP_OnPrimaryBegin
// (Event, Public, BlueprintEvent)
// Parameters:
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::BP_OnPrimaryBegin(class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "BP_OnPrimaryBegin");

	Params::BaseSpyTool_BP_OnPrimaryBegin Parms{};

	Parms.SpyTool = SpyTool;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseSpyTool.BP_OnPrimaryEnd
// (Event, Public, BlueprintEvent)
// Parameters:
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::BP_OnPrimaryEnd(class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "BP_OnPrimaryEnd");

	Params::BaseSpyTool_BP_OnPrimaryEnd Parms{};

	Parms.SpyTool = SpyTool;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseSpyTool.BP_OnPrimaryFailed
// (Event, Public, BlueprintEvent)
// Parameters:
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::BP_OnPrimaryFailed(class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "BP_OnPrimaryFailed");

	Params::BaseSpyTool_BP_OnPrimaryFailed Parms{};

	Parms.SpyTool = SpyTool;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseSpyTool.BP_OnRecycleBegin
// (Event, Public, BlueprintEvent)
// Parameters:
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::BP_OnRecycleBegin(class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "BP_OnRecycleBegin");

	Params::BaseSpyTool_BP_OnRecycleBegin Parms{};

	Parms.SpyTool = SpyTool;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseSpyTool.BP_OnRecycleEnd
// (Event, Public, BlueprintEvent)
// Parameters:
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::BP_OnRecycleEnd(class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "BP_OnRecycleEnd");

	Params::BaseSpyTool_BP_OnRecycleEnd Parms{};

	Parms.SpyTool = SpyTool;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseSpyTool.BP_OnSecondaryBegin
// (Event, Public, BlueprintEvent)
// Parameters:
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::BP_OnSecondaryBegin(class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "BP_OnSecondaryBegin");

	Params::BaseSpyTool_BP_OnSecondaryBegin Parms{};

	Parms.SpyTool = SpyTool;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseSpyTool.BP_OnSecondaryEnd
// (Event, Public, BlueprintEvent)
// Parameters:
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::BP_OnSecondaryEnd(class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "BP_OnSecondaryEnd");

	Params::BaseSpyTool_BP_OnSecondaryEnd Parms{};

	Parms.SpyTool = SpyTool;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseSpyTool.BP_OnSecondaryFailed
// (Event, Public, BlueprintEvent)
// Parameters:
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::BP_OnSecondaryFailed(class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "BP_OnSecondaryFailed");

	Params::BaseSpyTool_BP_OnSecondaryFailed Parms{};

	Parms.SpyTool = SpyTool;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseSpyTool.BP_OnSetupResource
// (Event, Public, BlueprintEvent)
// Parameters:
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::BP_OnSetupResource(class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "BP_OnSetupResource");

	Params::BaseSpyTool_BP_OnSetupResource Parms{};

	Parms.SpyTool = SpyTool;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseSpyTool.BP_OnSpyToolEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// ESpyToolEvent                           Event                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::BP_OnSpyToolEvent(ESpyToolEvent Event, class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "BP_OnSpyToolEvent");

	Params::BaseSpyTool_BP_OnSpyToolEvent Parms{};

	Parms.Event = Event;
	Parms.SpyTool = SpyTool;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseSpyTool.BP_OnSwitchAwayFrom
// (Event, Public, BlueprintEvent)
// Parameters:
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::BP_OnSwitchAwayFrom(class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "BP_OnSwitchAwayFrom");

	Params::BaseSpyTool_BP_OnSwitchAwayFrom Parms{};

	Parms.SpyTool = SpyTool;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseSpyTool.BP_OnSwitchTo
// (Event, Public, BlueprintEvent)
// Parameters:
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::BP_OnSwitchTo(class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "BP_OnSwitchTo");

	Params::BaseSpyTool_BP_OnSwitchTo Parms{};

	Parms.SpyTool = SpyTool;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseSpyTool.BP_ShowToolFromAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldAffectSecondaryTool                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::BP_ShowToolFromAnim(bool bShouldAffectSecondaryTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "BP_ShowToolFromAnim");

	Params::BaseSpyTool_BP_ShowToolFromAnim Parms{};

	Parms.bShouldAffectSecondaryTool = bShouldAffectSecondaryTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.BP_ShowToolFromSecondaryVisibilityFromAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldAffectSecondaryTool                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::BP_ShowToolFromSecondaryVisibilityFromAnim(bool bShouldAffectSecondaryTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "BP_ShowToolFromSecondaryVisibilityFromAnim");

	Params::BaseSpyTool_BP_ShowToolFromSecondaryVisibilityFromAnim Parms{};

	Parms.bShouldAffectSecondaryTool = bShouldAffectSecondaryTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.BP_ShowToolHUD
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             HUDName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowIn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::BP_ShowToolHUD(class FName HUDName, bool bShowIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "BP_ShowToolHUD");

	Params::BaseSpyTool_BP_ShowToolHUD Parms{};

	Parms.HUDName = HUDName;
	Parms.bShowIn = bShowIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.CreateAnimationProp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             NameID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorToCreate                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachSocket                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFirstPerson                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ABaseSpyTool::CreateAnimationProp(class FName NameID, TSubclassOf<class AActor> ActorToCreate, class FName AttachSocket, bool bFirstPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "CreateAnimationProp");

	Params::BaseSpyTool_CreateAnimationProp Parms{};

	Parms.NameID = NameID;
	Parms.ActorToCreate = ActorToCreate;
	Parms.AttachSocket = AttachSocket;
	Parms.bFirstPerson = bFirstPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.DestroyAllAnimationProps
// (Final, Native, Public, BlueprintCallable)

void ABaseSpyTool::DestroyAllAnimationProps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "DestroyAllAnimationProps");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.DestroyAnimationProp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             NameID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFirstPerson                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::DestroyAnimationProp(class FName NameID, bool bFirstPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "DestroyAnimationProp");

	Params::BaseSpyTool_DestroyAnimationProp Parms{};

	Parms.NameID = NameID;
	Parms.bFirstPerson = bFirstPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.FireEvent
// (Native, Public, BlueprintCallable)
// Parameters:
// ESpyToolEvent                           Event                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::FireEvent(ESpyToolEvent Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "FireEvent");

	Params::BaseSpyTool_FireEvent Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.GetAnimationProp
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             NameID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFirstPerson                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ABaseSpyTool::GetAnimationProp(class FName NameID, bool bFirstPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetAnimationProp");

	Params::BaseSpyTool_GetAnimationProp Parms{};

	Parms.NameID = NameID;
	Parms.bFirstPerson = bFirstPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetCurrentVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EVisibilityMode                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EVisibilityMode ABaseSpyTool::GetCurrentVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetCurrentVisibility");

	Params::BaseSpyTool_GetCurrentVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetToolActionsData
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FToolActionTextData              PrimaryActionData                                      (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FToolActionTextData              SecondaryActionData                                    (Parm, OutParm, NativeAccessSpecifierPublic)

void ABaseSpyTool::GetToolActionsData(struct FToolActionTextData* PrimaryActionData, struct FToolActionTextData* SecondaryActionData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetToolActionsData");

	Params::BaseSpyTool_GetToolActionsData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PrimaryActionData != nullptr)
		*PrimaryActionData = std::move(Parms.PrimaryActionData);

	if (SecondaryActionData != nullptr)
		*SecondaryActionData = std::move(Parms.SecondaryActionData);
}


// Function DeceiveInc.BaseSpyTool.HandleEMPIsAffectedChanged
// (Native, Protected)
// Parameters:
// bool                                    bIsAffected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AffectedActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::HandleEMPIsAffectedChanged(bool bIsAffected, class AActor* AffectedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "HandleEMPIsAffectedChanged");

	Params::BaseSpyTool_HandleEMPIsAffectedChanged Parms{};

	Parms.bIsAffected = bIsAffected;
	Parms.AffectedActor = AffectedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.HandleGameRulesChanged
// (Native, Protected)
// Parameters:
// EDIGameRuleset                          NewRuleset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::HandleGameRulesChanged(EDIGameRuleset NewRuleset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "HandleGameRulesChanged");

	Params::BaseSpyTool_HandleGameRulesChanged Parms{};

	Parms.NewRuleset = NewRuleset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.HandleLoadoutSpawnComplete
// (Native, Protected)
// Parameters:
// class UToolLoadoutComponent*            ToolLoadout                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::HandleLoadoutSpawnComplete(class UToolLoadoutComponent* ToolLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "HandleLoadoutSpawnComplete");

	Params::BaseSpyTool_HandleLoadoutSpawnComplete Parms{};

	Parms.ToolLoadout = ToolLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.HandleScramblerIsAffectedChanged
// (Native, Protected)
// Parameters:
// bool                                    bIsAffected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AffectedActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::HandleScramblerIsAffectedChanged(bool bIsAffected, class AActor* AffectedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "HandleScramblerIsAffectedChanged");

	Params::BaseSpyTool_HandleScramblerIsAffectedChanged Parms{};

	Parms.bIsAffected = bIsAffected;
	Parms.AffectedActor = AffectedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.HandleToolCooldownChange
// (Native, Protected)
// Parameters:
// bool                                    bOnCooldown                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::HandleToolCooldownChange(bool bOnCooldown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "HandleToolCooldownChange");

	Params::BaseSpyTool_HandleToolCooldownChange Parms{};

	Parms.bOnCooldown = bOnCooldown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.IsAllowingMelee
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseSpyTool::IsAllowingMelee()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "IsAllowingMelee");

	Params::BaseSpyTool_IsAllowingMelee Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.NetMulticast_NotifyPrimaryGadgetUse
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// bool                                    bStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::NetMulticast_NotifyPrimaryGadgetUse(bool bStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "NetMulticast_NotifyPrimaryGadgetUse");

	Params::BaseSpyTool_NetMulticast_NotifyPrimaryGadgetUse Parms{};

	Parms.bStart = bStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.NetMulticast_NotifySecondaryGadgetUse
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// bool                                    bStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::NetMulticast_NotifySecondaryGadgetUse(bool bStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "NetMulticast_NotifySecondaryGadgetUse");

	Params::BaseSpyTool_NetMulticast_NotifySecondaryGadgetUse Parms{};

	Parms.bStart = bStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.OnAnyHandToolShowed
// (Native, Protected)
// Parameters:
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELoadoutSlot                            HandToolSlot                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::OnAnyHandToolShowed(class ABaseSpyTool* SpyTool, ELoadoutSlot HandToolSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "OnAnyHandToolShowed");

	Params::BaseSpyTool_OnAnyHandToolShowed Parms{};

	Parms.SpyTool = SpyTool;
	Parms.HandToolSlot = HandToolSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.OnPlayerHUDVisibilityChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::OnPlayerHUDVisibilityChange(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "OnPlayerHUDVisibilityChange");

	Params::BaseSpyTool_OnPlayerHUDVisibilityChange Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.OnRep_NewToolAssetsId
// (Native, Protected)

void ABaseSpyTool::OnRep_NewToolAssetsId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "OnRep_NewToolAssetsId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.OnSpyDeath
// (Native, Protected)
// Parameters:
// class AActor*                           DeadActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::OnSpyDeath(class AActor* DeadActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "OnSpyDeath");

	Params::BaseSpyTool_OnSpyDeath Parms{};

	Parms.DeadActor = DeadActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.PrimaryBegin
// (Native, Public, BlueprintCallable)

void ABaseSpyTool::PrimaryBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "PrimaryBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.PrimaryEnd
// (Native, Public, BlueprintCallable)

void ABaseSpyTool::PrimaryEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "PrimaryEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.PrimaryFailed
// (Native, Public, BlueprintCallable)

void ABaseSpyTool::PrimaryFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "PrimaryFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.RecycleBegin
// (Native, Public, BlueprintCallable)

void ABaseSpyTool::RecycleBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "RecycleBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.RecycleEnd
// (Native, Public, BlueprintCallable)

void ABaseSpyTool::RecycleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "RecycleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.RemoveActorFromIgnoreList
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::RemoveActorFromIgnoreList(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "RemoveActorFromIgnoreList");

	Params::BaseSpyTool_RemoveActorFromIgnoreList Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.SecondaryBegin
// (Native, Public, BlueprintCallable)

void ABaseSpyTool::SecondaryBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "SecondaryBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.SecondaryEnd
// (Native, Public, BlueprintCallable)

void ABaseSpyTool::SecondaryEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "SecondaryEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.SecondaryFailed
// (Native, Public, BlueprintCallable)

void ABaseSpyTool::SecondaryFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "SecondaryFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.Server_NotifyPrimaryGadgetUse
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    bStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::Server_NotifyPrimaryGadgetUse(bool bStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "Server_NotifyPrimaryGadgetUse");

	Params::BaseSpyTool_Server_NotifyPrimaryGadgetUse Parms{};

	Parms.bStart = bStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.Server_NotifySecondaryGadgetUse
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    bStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::Server_NotifySecondaryGadgetUse(bool bStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "Server_NotifySecondaryGadgetUse");

	Params::BaseSpyTool_Server_NotifySecondaryGadgetUse Parms{};

	Parms.bStart = bStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.SetLocalVisibility
// (Native, Public, BlueprintCallable)
// Parameters:
// EVisibilityMode                         InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCanShowPoudrier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EToolVisibilityChangeReason             InReason                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::SetLocalVisibility(EVisibilityMode InMode, bool bCanShowPoudrier, EToolVisibilityChangeReason InReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "SetLocalVisibility");

	Params::BaseSpyTool_SetLocalVisibility Parms{};

	Parms.InMode = InMode;
	Parms.bCanShowPoudrier = bCanShowPoudrier;
	Parms.InReason = InReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.SetVisibility
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyTool::SetVisibility(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "SetVisibility");

	Params::BaseSpyTool_SetVisibility Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.ShouldShowPoudrierMesh
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseSpyTool::ShouldShowPoudrierMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "ShouldShowPoudrierMesh");

	Params::BaseSpyTool_ShouldShowPoudrierMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.SwitchAwayFrom
// (Native, Public, BlueprintCallable)

void ABaseSpyTool::SwitchAwayFrom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "SwitchAwayFrom");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.SwitchTo
// (Native, Public, BlueprintCallable)

void ABaseSpyTool::SwitchTo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "SwitchTo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.UpdateActionTextData
// (Native, Public, BlueprintCallable)

void ABaseSpyTool::UpdateActionTextData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "UpdateActionTextData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.UpdateStatsFromBalancingTable
// (Native, Public, BlueprintCallable)

void ABaseSpyTool::UpdateStatsFromBalancingTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "UpdateStatsFromBalancingTable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyTool.CanBeUse
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseSpyTool::CanBeUse() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "CanBeUse");

	Params::BaseSpyTool_CanBeUse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.CanRecycle
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseSpyTool::CanRecycle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "CanRecycle");

	Params::BaseSpyTool_CanRecycle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetAimAssistConfiguration
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USBAimAssistConfigDataAsset*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USBAimAssistConfigDataAsset* ABaseSpyTool::GetAimAssistConfiguration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetAimAssistConfiguration");

	Params::BaseSpyTool_GetAimAssistConfiguration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetAnim1PClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UAnimInstance>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UAnimInstance> ABaseSpyTool::GetAnim1PClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetAnim1PClass");

	Params::BaseSpyTool_GetAnim1PClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetAnim3PClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UAnimInstance>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UAnimInstance> ABaseSpyTool::GetAnim3PClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetAnim3PClass");

	Params::BaseSpyTool_GetAnim3PClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetComittedResourceNum
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ABaseSpyTool::GetComittedResourceNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetComittedResourceNum");

	Params::BaseSpyTool_GetComittedResourceNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetCurrentActiveMesh
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ABaseSpyTool::GetCurrentActiveMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetCurrentActiveMesh");

	Params::BaseSpyTool_GetCurrentActiveMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetIgnoredActors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TSet<class AActor*>               ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TSet<class AActor*> ABaseSpyTool::GetIgnoredActors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetIgnoredActors");

	Params::BaseSpyTool_GetIgnoredActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetInitChargeCount
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ABaseSpyTool::GetInitChargeCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetInitChargeCount");

	Params::BaseSpyTool_GetInitChargeCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetMaxResourceNum
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ABaseSpyTool::GetMaxResourceNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetMaxResourceNum");

	Params::BaseSpyTool_GetMaxResourceNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetMeshComponent1P
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ABaseSpyTool::GetMeshComponent1P() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetMeshComponent1P");

	Params::BaseSpyTool_GetMeshComponent1P Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetMeshComponent3P
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ABaseSpyTool::GetMeshComponent3P() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetMeshComponent3P");

	Params::BaseSpyTool_GetMeshComponent3P Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetOperatingController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AController*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AController* ABaseSpyTool::GetOperatingController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetOperatingController");

	Params::BaseSpyTool_GetOperatingController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetPositionerBeamLocation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ABaseSpyTool::GetPositionerBeamLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetPositionerBeamLocation");

	Params::BaseSpyTool_GetPositionerBeamLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetPreferredAttachSocket
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ABaseSpyTool::GetPreferredAttachSocket() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetPreferredAttachSocket");

	Params::BaseSpyTool_GetPreferredAttachSocket Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetRechargeDuration
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ABaseSpyTool::GetRechargeDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetRechargeDuration");

	Params::BaseSpyTool_GetRechargeDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetRecycleRatio
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ABaseSpyTool::GetRecycleRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetRecycleRatio");

	Params::BaseSpyTool_GetRecycleRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetResourceNum
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ABaseSpyTool::GetResourceNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetResourceNum");

	Params::BaseSpyTool_GetResourceNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetSecondaryTool
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABaseSpyTool*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABaseSpyTool* ABaseSpyTool::GetSecondaryTool() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetSecondaryTool");

	Params::BaseSpyTool_GetSecondaryTool Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetSpyToolType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ESpyToolType                      ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const ESpyToolType ABaseSpyTool::GetSpyToolType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetSpyToolType");

	Params::BaseSpyTool_GetSpyToolType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetToolCooldownComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCooldownComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCooldownComponent* ABaseSpyTool::GetToolCooldownComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetToolCooldownComponent");

	Params::BaseSpyTool_GetToolCooldownComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetToolCooldownRatio
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ABaseSpyTool::GetToolCooldownRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetToolCooldownRatio");

	Params::BaseSpyTool_GetToolCooldownRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetToolIconSlateBrush
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USlateBrushAsset*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USlateBrushAsset* ABaseSpyTool::GetToolIconSlateBrush() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetToolIconSlateBrush");

	Params::BaseSpyTool_GetToolIconSlateBrush Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetToolResourceType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EGameplayResourcesType            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const EGameplayResourcesType ABaseSpyTool::GetToolResourceType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetToolResourceType");

	Params::BaseSpyTool_GetToolResourceType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetToolWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   WidgetIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* ABaseSpyTool::GetToolWidget(int32 WidgetIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetToolWidget");

	Params::BaseSpyTool_GetToolWidget Parms{};

	Parms.WidgetIndex = WidgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetToolWidgetByName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             WidgetName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* ABaseSpyTool::GetToolWidgetByName(class FName WidgetName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetToolWidgetByName");

	Params::BaseSpyTool_GetToolWidgetByName Parms{};

	Parms.WidgetName = WidgetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.GetUncomittedResourceNum
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ABaseSpyTool::GetUncomittedResourceNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "GetUncomittedResourceNum");

	Params::BaseSpyTool_GetUncomittedResourceNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.IsActorInIgnoreList
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseSpyTool::IsActorInIgnoreList(class AActor* TargetActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "IsActorInIgnoreList");

	Params::BaseSpyTool_IsActorInIgnoreList Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.IsKillcamViewTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseSpyTool::IsKillcamViewTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "IsKillcamViewTarget");

	Params::BaseSpyTool_IsKillcamViewTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.IsLocallyControlled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseSpyTool::IsLocallyControlled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "IsLocallyControlled");

	Params::BaseSpyTool_IsLocallyControlled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.IsOnCooldown
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseSpyTool::IsOnCooldown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "IsOnCooldown");

	Params::BaseSpyTool_IsOnCooldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.IsOwnedByBot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseSpyTool::IsOwnedByBot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "IsOwnedByBot");

	Params::BaseSpyTool_IsOwnedByBot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.IsPrimaryActive
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseSpyTool::IsPrimaryActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "IsPrimaryActive");

	Params::BaseSpyTool_IsPrimaryActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.IsPrimaryAvailable
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseSpyTool::IsPrimaryAvailable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "IsPrimaryAvailable");

	Params::BaseSpyTool_IsPrimaryAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.IsRecycleActive
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseSpyTool::IsRecycleActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "IsRecycleActive");

	Params::BaseSpyTool_IsRecycleActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.IsRecycleRequested
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseSpyTool::IsRecycleRequested() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "IsRecycleRequested");

	Params::BaseSpyTool_IsRecycleRequested Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.IsSecondaryActive
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseSpyTool::IsSecondaryActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "IsSecondaryActive");

	Params::BaseSpyTool_IsSecondaryActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.IsSecondaryAvailable
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseSpyTool::IsSecondaryAvailable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "IsSecondaryAvailable");

	Params::BaseSpyTool_IsSecondaryAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.IsToolActive
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseSpyTool::IsToolActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "IsToolActive");

	Params::BaseSpyTool_IsToolActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.IsToolDisabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseSpyTool::IsToolDisabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "IsToolDisabled");

	Params::BaseSpyTool_IsToolDisabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.IsToolSelected
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseSpyTool::IsToolSelected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "IsToolSelected");

	Params::BaseSpyTool_IsToolSelected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyTool.IsUserViewIn1P
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseSpyTool::IsUserViewIn1P() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyTool", "IsUserViewIn1P");

	Params::BaseSpyTool_IsUserViewIn1P Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyActiveAbility.BP_OnActiveBegin
// (Event, Protected, BlueprintEvent)

void ABaseSpyActiveAbility::BP_OnActiveBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyActiveAbility", "BP_OnActiveBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.BaseSpyActiveAbility.BP_OnActiveBeginLocal
// (Event, Protected, BlueprintEvent)

void ABaseSpyActiveAbility::BP_OnActiveBeginLocal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyActiveAbility", "BP_OnActiveBeginLocal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.BaseSpyActiveAbility.BP_OnActiveBeginReplicated
// (Event, Protected, BlueprintEvent)

void ABaseSpyActiveAbility::BP_OnActiveBeginReplicated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyActiveAbility", "BP_OnActiveBeginReplicated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.BaseSpyActiveAbility.BP_OnActiveEnd
// (Event, Protected, BlueprintEvent)

void ABaseSpyActiveAbility::BP_OnActiveEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyActiveAbility", "BP_OnActiveEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.BaseSpyActiveAbility.BP_OnActiveEndLocal
// (Event, Protected, BlueprintEvent)

void ABaseSpyActiveAbility::BP_OnActiveEndLocal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyActiveAbility", "BP_OnActiveEndLocal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.BaseSpyActiveAbility.BP_OnActiveEndReplicated
// (Event, Protected, BlueprintEvent)

void ABaseSpyActiveAbility::BP_OnActiveEndReplicated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyActiveAbility", "BP_OnActiveEndReplicated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.BaseSpyActiveAbility.GetActivePowerRatio
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ABaseSpyActiveAbility::GetActivePowerRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyActiveAbility", "GetActivePowerRatio");

	Params::BaseSpyActiveAbility_GetActivePowerRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyActiveAbility.OnSetToStartCooldownTimerEnd
// (Final, Native, Public)

void ABaseSpyActiveAbility::OnSetToStartCooldownTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyActiveAbility", "OnSetToStartCooldownTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyActiveAbility.OnSwitchBackToWeaponTimerEnd
// (Final, Native, Public)

void ABaseSpyActiveAbility::OnSwitchBackToWeaponTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyActiveAbility", "OnSwitchBackToWeaponTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyActiveAbility.OnVaultLockedPhaseStart
// (Final, Native, Protected)
// Parameters:
// class UVaultLockedPhaseInfo*            PhaseInfo                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyActiveAbility::OnVaultLockedPhaseStart(class UVaultLockedPhaseInfo* PhaseInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyActiveAbility", "OnVaultLockedPhaseStart");

	Params::BaseSpyActiveAbility_OnVaultLockedPhaseStart Parms{};

	Parms.PhaseInfo = PhaseInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyActiveAbility.OwnerTrigerActiveFailed
// (Net, NetReliable, Native, Event, Public, NetClient)

void ABaseSpyActiveAbility::OwnerTrigerActiveFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyActiveAbility", "OwnerTrigerActiveFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyActiveAbility.ResetPendingActiveAbilityOutAnimation
// (Final, Native, Protected, BlueprintCallable)

void ABaseSpyActiveAbility::ResetPendingActiveAbilityOutAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyActiveAbility", "ResetPendingActiveAbilityOutAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyActiveAbility.Server_CancelActivePower
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bRefundActive                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSpyActiveAbility::Server_CancelActivePower(bool bRefundActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyActiveAbility", "Server_CancelActivePower");

	Params::BaseSpyActiveAbility_Server_CancelActivePower Parms{};

	Parms.bRefundActive = bRefundActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyActiveAbility.TriggerActivePower
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ABaseSpyActiveAbility::TriggerActivePower()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyActiveAbility", "TriggerActivePower");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyActiveAbility.TriggerActivePowerNetMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ABaseSpyActiveAbility::TriggerActivePowerNetMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyActiveAbility", "TriggerActivePowerNetMulticast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyActiveAbility.TriggerDeactivatePowerNetMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ABaseSpyActiveAbility::TriggerDeactivatePowerNetMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyActiveAbility", "TriggerDeactivatePowerNetMulticast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyActiveAbility.TriggerUnhandledActivePressedMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ABaseSpyActiveAbility::TriggerUnhandledActivePressedMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyActiveAbility", "TriggerUnhandledActivePressedMulticast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyActiveAbility.UnhandledActivePressed
// (Net, NetReliable, Native, Event, Public, NetServer)

void ABaseSpyActiveAbility::UnhandledActivePressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyActiveAbility", "UnhandledActivePressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseSpyActiveAbility.BP_IsActiveInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseSpyActiveAbility::BP_IsActiveInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyActiveAbility", "BP_IsActiveInProgress");

	Params::BaseSpyActiveAbility_BP_IsActiveInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyActiveAbility.GetActiveTimeLeft
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ABaseSpyActiveAbility::GetActiveTimeLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyActiveAbility", "GetActiveTimeLeft");

	Params::BaseSpyActiveAbility_GetActiveTimeLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyActiveAbility.HasPendingActiveAbilityOutAnimation
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseSpyActiveAbility::HasPendingActiveAbilityOutAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyActiveAbility", "HasPendingActiveAbilityOutAnimation");

	Params::BaseSpyActiveAbility_HasPendingActiveAbilityOutAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseSpyActiveAbility.IsActive
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseSpyActiveAbility::IsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSpyActiveAbility", "IsActive");

	Params::BaseSpyActiveAbility_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ChavezActiveAbilityMod2_1.BP_DoorBumped
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ABaseDoorActor*                   Door                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChavezActiveAbilityMod2_1::BP_DoorBumped(class ABaseDoorActor* Door)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChavezActiveAbilityMod2_1", "BP_DoorBumped");

	Params::ChavezActiveAbilityMod2_1_BP_DoorBumped Parms{};

	Parms.Door = Door;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.ChavezActiveAbilityMod2_1.MulticastBumpActor
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           BumpedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChavezActiveAbilityMod2_1::MulticastBumpActor(class AActor* BumpedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChavezActiveAbilityMod2_1", "MulticastBumpActor");

	Params::ChavezActiveAbilityMod2_1_MulticastBumpActor Parms{};

	Parms.BumpedActor = BumpedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChavezActiveAbilityMod2_1.OnTriggerDelayTimer
// (Native, Protected)

void AChavezActiveAbilityMod2_1::OnTriggerDelayTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChavezActiveAbilityMod2_1", "OnTriggerDelayTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChavezActiveAbilityMod2_1.TryBumpActor
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           ToBump                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChavezActiveAbilityMod2_1::TryBumpActor(class AActor* ToBump)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChavezActiveAbilityMod2_1", "TryBumpActor");

	Params::ChavezActiveAbilityMod2_1_TryBumpActor Parms{};

	Parms.ToBump = ToBump;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISessionSubsystem.GetCurrencyTypeAmount
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  CurrencyType                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDISessionSubsystem::GetCurrencyTypeAmount(const struct FPrimaryAssetId& CurrencyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "GetCurrencyTypeAmount");

	Params::DISessionSubsystem_GetCurrencyTypeAmount Parms{};

	Parms.CurrencyType = std::move(CurrencyType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.GetDIITemCostForCurrency
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDIItem*                          ItemToCheck                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDICurrencyItem*                  Currency                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDISessionSubsystem::GetDIITemCostForCurrency(const class UDIItem* ItemToCheck, class UDICurrencyItem* Currency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "GetDIITemCostForCurrency");

	Params::DISessionSubsystem_GetDIITemCostForCurrency Parms{};

	Parms.ItemToCheck = ItemToCheck;
	Parms.Currency = Currency;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.GetItemUnlockInfo
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  AssetId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FItemUnlockLevelArray            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FItemUnlockLevelArray UDISessionSubsystem::GetItemUnlockInfo(const struct FPrimaryAssetId& AssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "GetItemUnlockInfo");

	Params::DISessionSubsystem_GetItemUnlockInfo Parms{};

	Parms.AssetId = std::move(AssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.GetXPBoosterActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDISessionSubsystem::GetXPBoosterActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "GetXPBoosterActive");

	Params::DISessionSubsystem_GetXPBoosterActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.GetXPBoosterAmmount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDISessionSubsystem::GetXPBoosterAmmount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "GetXPBoosterAmmount");

	Params::DISessionSubsystem_GetXPBoosterAmmount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.GetXPBoosterTimeLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDISessionSubsystem::GetXPBoosterTimeLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "GetXPBoosterTimeLeft");

	Params::DISessionSubsystem_GetXPBoosterTimeLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.GetXPBoosterTimeLeftFormat
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDISessionSubsystem::GetXPBoosterTimeLeftFormat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "GetXPBoosterTimeLeftFormat");

	Params::DISessionSubsystem_GetXPBoosterTimeLeftFormat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.IsAgentAvailable
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  AssetId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsPurchased                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UDISessionSubsystem::IsAgentAvailable(const struct FPrimaryAssetId& AssetId, bool* bIsPurchased)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "IsAgentAvailable");

	Params::DISessionSubsystem_IsAgentAvailable Parms{};

	Parms.AssetId = std::move(AssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bIsPurchased != nullptr)
		*bIsPurchased = Parms.bIsPurchased;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.IsOwnedItemAccelByteID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           AccelByteItemId                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UDISessionSubsystem::IsOwnedItemAccelByteID(const class FString& AccelByteItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "IsOwnedItemAccelByteID");

	Params::DISessionSubsystem_IsOwnedItemAccelByteID Parms{};

	Parms.AccelByteItemId = std::move(AccelByteItemId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.IsOwnedStringItemID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ItemId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UDISessionSubsystem::IsOwnedStringItemID(const class FString& ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "IsOwnedStringItemID");

	Params::DISessionSubsystem_IsOwnedStringItemID Parms{};

	Parms.ItemId = std::move(ItemId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.IsSelectedAgentValid
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UDISessionSubsystem::IsSelectedAgentValid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "IsSelectedAgentValid");

	Params::DISessionSubsystem_IsSelectedAgentValid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.QuantityOwned
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  AssetId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UDISessionSubsystem::QuantityOwned(const struct FPrimaryAssetId& AssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "QuantityOwned");

	Params::DISessionSubsystem_QuantityOwned Parms{};

	Parms.AssetId = std::move(AssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.CanAssetBePurchased
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPrimaryAssetId                  AssetId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDISessionSubsystem::CanAssetBePurchased(const struct FPrimaryAssetId& AssetId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "CanAssetBePurchased");

	Params::DISessionSubsystem_CanAssetBePurchased Parms{};

	Parms.AssetId = std::move(AssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.CanDIItemBePurchased
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIItem*                          ItemToCheck                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDISessionSubsystem::CanDIItemBePurchased(const class UDIItem* ItemToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "CanDIItemBePurchased");

	Params::DISessionSubsystem_CanDIItemBePurchased Parms{};

	Parms.ItemToCheck = ItemToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.CanPurchaseItemWithCurrency
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIItem*                          ItemToCheck                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CurrencyId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDISessionSubsystem::CanPurchaseItemWithCurrency(const class UDIItem* ItemToCheck, const class FString& CurrencyId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "CanPurchaseItemWithCurrency");

	Params::DISessionSubsystem_CanPurchaseItemWithCurrency Parms{};

	Parms.ItemToCheck = ItemToCheck;
	Parms.CurrencyId = std::move(CurrencyId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.CanPurchaseStringItemWithCurrency
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ItemToCheck                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CurrencyId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDISessionSubsystem::CanPurchaseStringItemWithCurrency(const class FString& ItemToCheck, const class FString& CurrencyId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "CanPurchaseStringItemWithCurrency");

	Params::DISessionSubsystem_CanPurchaseStringItemWithCurrency Parms{};

	Parms.ItemToCheck = std::move(ItemToCheck);
	Parms.CurrencyId = std::move(CurrencyId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.CanShowAssetInMenu
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPrimaryAssetId                  AssetId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDISessionSubsystem::CanShowAssetInMenu(const struct FPrimaryAssetId& AssetId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "CanShowAssetInMenu");

	Params::DISessionSubsystem_CanShowAssetInMenu Parms{};

	Parms.AssetId = std::move(AssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.DIITemIsOwned
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIItem*                          ItemToCheck                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UDISessionSubsystem::DIITemIsOwned(const class UDIItem* ItemToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "DIITemIsOwned");

	Params::DISessionSubsystem_DIITemIsOwned Parms{};

	Parms.ItemToCheck = ItemToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.GetCheatFreeLootAmount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDISessionSubsystem::GetCheatFreeLootAmount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "GetCheatFreeLootAmount");

	Params::DISessionSubsystem_GetCheatFreeLootAmount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.GetPlayerTotalMasteries
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDISessionSubsystem::GetPlayerTotalMasteries() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "GetPlayerTotalMasteries");

	Params::DISessionSubsystem_GetPlayerTotalMasteries Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.IsAvailableForUse
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPrimaryAssetId                  AssetId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UDISessionSubsystem::IsAvailableForUse(const struct FPrimaryAssetId& AssetId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "IsAvailableForUse");

	Params::DISessionSubsystem_IsAvailableForUse Parms{};

	Parms.AssetId = std::move(AssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.IsCheatFreeLootBundle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDISessionSubsystem::IsCheatFreeLootBundle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "IsCheatFreeLootBundle");

	Params::DISessionSubsystem_IsCheatFreeLootBundle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.IsConsumableDIItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIItem*                          ItemToCheck                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDISessionSubsystem::IsConsumableDIItem(const class UDIItem* ItemToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "IsConsumableDIItem");

	Params::DISessionSubsystem_IsConsumableDIItem Parms{};

	Parms.ItemToCheck = ItemToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.IsConsumableItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ItemToCheck                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDISessionSubsystem::IsConsumableItem(const class FString& ItemToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "IsConsumableItem");

	Params::DISessionSubsystem_IsConsumableItem Parms{};

	Parms.ItemToCheck = std::move(ItemToCheck);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.IsGameplayAsset
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPrimaryAssetId                  AssetId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDISessionSubsystem::IsGameplayAsset(const struct FPrimaryAssetId& AssetId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "IsGameplayAsset");

	Params::DISessionSubsystem_IsGameplayAsset Parms{};

	Parms.AssetId = std::move(AssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.IsInPlayerInventory
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPrimaryAssetId                  AssetId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UDISessionSubsystem::IsInPlayerInventory(const struct FPrimaryAssetId& AssetId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "IsInPlayerInventory");

	Params::DISessionSubsystem_IsInPlayerInventory Parms{};

	Parms.AssetId = std::move(AssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.IsLocalUserToxic
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDISessionSubsystem::IsLocalUserToxic() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "IsLocalUserToxic");

	Params::DISessionSubsystem_IsLocalUserToxic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.IsOwned
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPrimaryAssetId                  AssetId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UDISessionSubsystem::IsOwned(const struct FPrimaryAssetId& AssetId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "IsOwned");

	Params::DISessionSubsystem_IsOwned Parms{};

	Parms.AssetId = std::move(AssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.IsOwnedItemID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ItemId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UDISessionSubsystem::IsOwnedItemID(int32 ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "IsOwnedItemID");

	Params::DISessionSubsystem_IsOwnedItemID Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSubsystem.QuantityOwnedStringItemID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ItemId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UDISessionSubsystem::QuantityOwnedStringItemID(const class FString& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSubsystem", "QuantityOwnedStringItemID");

	Params::DISessionSubsystem_QuantityOwnedStringItemID Parms{};

	Parms.ItemId = std::move(ItemId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.AceActiveAbility.GetTimeRemainingBeforeLastHitTargetReset
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AAceActiveAbility::GetTimeRemainingBeforeLastHitTargetReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceActiveAbility", "GetTimeRemainingBeforeLastHitTargetReset");

	Params::AceActiveAbility_GetTimeRemainingBeforeLastHitTargetReset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.AceActiveAbility.MarkByAceActive
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class AActor*                           MarkedTarget                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAceActiveAbility::MarkByAceActive(class AActor* MarkedTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceActiveAbility", "MarkByAceActive");

	Params::AceActiveAbility_MarkByAceActive Parms{};

	Parms.MarkedTarget = MarkedTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AceActiveAbility.NetMulticast_MarkByAceActive
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           MarkedTarget                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAceActiveAbility::NetMulticast_MarkByAceActive(class AActor* MarkedTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceActiveAbility", "NetMulticast_MarkByAceActive");

	Params::AceActiveAbility_NetMulticast_MarkByAceActive Parms{};

	Parms.MarkedTarget = MarkedTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AceActiveAbility.NetMulticast_OnActiveEndAnnouncement
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ASpy*                             SpyTarget                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAceActiveAbility::NetMulticast_OnActiveEndAnnouncement(class ASpy* SpyTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceActiveAbility", "NetMulticast_OnActiveEndAnnouncement");

	Params::AceActiveAbility_NetMulticast_OnActiveEndAnnouncement Parms{};

	Parms.SpyTarget = SpyTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AceActiveAbility.NetMulticast_OnActiveStartAnnouncement
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ASpy*                             SpyTarget                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAceActiveAbility::NetMulticast_OnActiveStartAnnouncement(class ASpy* SpyTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceActiveAbility", "NetMulticast_OnActiveStartAnnouncement");

	Params::AceActiveAbility_NetMulticast_OnActiveStartAnnouncement Parms{};

	Parms.SpyTarget = SpyTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AceActiveAbility.OnConfirmedDamageDealt
// (Final, Native, Public)
// Parameters:
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAceActiveAbility::OnConfirmedDamageDealt(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceActiveAbility", "OnConfirmedDamageDealt");

	Params::AceActiveAbility_OnConfirmedDamageDealt Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.Damage = Damage;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AceActiveAbility.OnConfirmedTargetDeath
// (Final, Native, Public)
// Parameters:
// class AActor*                           DeadActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAceActiveAbility::OnConfirmedTargetDeath(class AActor* DeadActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceActiveAbility", "OnConfirmedTargetDeath");

	Params::AceActiveAbility_OnConfirmedTargetDeath Parms{};

	Parms.DeadActor = DeadActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AceActiveAbility.OnLastHitTargetDeath
// (Final, Native, Public)
// Parameters:
// class AActor*                           DeadActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAceActiveAbility::OnLastHitTargetDeath(class AActor* DeadActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceActiveAbility", "OnLastHitTargetDeath");

	Params::AceActiveAbility_OnLastHitTargetDeath Parms{};

	Parms.DeadActor = DeadActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AceActiveAbility.OnLastHitTargetIsOnCooldownChange
// (Final, Native, Public)
// Parameters:
// bool                                    OnCooldown                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAceActiveAbility::OnLastHitTargetIsOnCooldownChange(bool OnCooldown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceActiveAbility", "OnLastHitTargetIsOnCooldownChange");

	Params::AceActiveAbility_OnLastHitTargetIsOnCooldownChange Parms{};

	Parms.OnCooldown = OnCooldown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AceActiveAbility.OnRep_ConfirmedTarget
// (Final, Native, Public)
// Parameters:
// class AActor*                           PrevConfirmedTarget                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAceActiveAbility::OnRep_ConfirmedTarget(class AActor* PrevConfirmedTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceActiveAbility", "OnRep_ConfirmedTarget");

	Params::AceActiveAbility_OnRep_ConfirmedTarget Parms{};

	Parms.PrevConfirmedTarget = PrevConfirmedTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AceActiveAbility.HasValidLastHitTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAceActiveAbility::HasValidLastHitTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceActiveAbility", "HasValidLastHitTarget");

	Params::AceActiveAbility_HasValidLastHitTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.AceActiveAbilityHeatVision.HandleSpyHeatChanged
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewHeatValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HeatDelta                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAceActiveAbilityHeatVision::HandleSpyHeatChanged(class ASpy* Spy, int32 NewHeatValue, int32 HeatDelta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceActiveAbilityHeatVision", "HandleSpyHeatChanged");

	Params::AceActiveAbilityHeatVision_HandleSpyHeatChanged Parms{};

	Parms.Spy = Spy;
	Parms.NewHeatValue = NewHeatValue;
	Parms.HeatDelta = HeatDelta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AceActiveAbilityHeatVision.NetMulticast_OnVictimEffectStart
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAceActiveAbilityHeatVision::NetMulticast_OnVictimEffectStart(class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceActiveAbilityHeatVision", "NetMulticast_OnVictimEffectStart");

	Params::AceActiveAbilityHeatVision_NetMulticast_OnVictimEffectStart Parms{};

	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AceActiveAbilityHeatVision.NetMulticast_SpyAffectedByZoneChange
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ASpy*                             AffectedSpyIn                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAffectedIn                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAceActiveAbilityHeatVision::NetMulticast_SpyAffectedByZoneChange(class ASpy* AffectedSpyIn, bool bAffectedIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceActiveAbilityHeatVision", "NetMulticast_SpyAffectedByZoneChange");

	Params::AceActiveAbilityHeatVision_NetMulticast_SpyAffectedByZoneChange Parms{};

	Parms.AffectedSpyIn = AffectedSpyIn;
	Parms.bAffectedIn = bAffectedIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPrimaryDataAsset.BP_GetPrimaryAssetId
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UDIPrimaryDataAsset::BP_GetPrimaryAssetId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPrimaryDataAsset", "BP_GetPrimaryAssetId");

	Params::DIPrimaryDataAsset_BP_GetPrimaryAssetId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPrimaryDataAsset.GetIdentifierString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDIPrimaryDataAsset::GetIdentifierString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPrimaryDataAsset", "GetIdentifierString");

	Params::DIPrimaryDataAsset_GetIdentifierString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.AceActiveAbilityMod2.HandleMiscToolSpawned
// (Final, Native, Protected)
// Parameters:
// class AActor*                           SpawnedTool                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAceActiveAbilityMod2::HandleMiscToolSpawned(class AActor* SpawnedTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceActiveAbilityMod2", "HandleMiscToolSpawned");

	Params::AceActiveAbilityMod2_HandleMiscToolSpawned Parms{};

	Parms.SpawnedTool = SpawnedTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AceActiveAbilityMod2.OnSpawnRetriggerDelayTimerEnd
// (Final, Native, Protected)

void AAceActiveAbilityMod2::OnSpawnRetriggerDelayTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceActiveAbilityMod2", "OnSpawnRetriggerDelayTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiActivitySubsystem.HandleMenuEvent
// (Final, Native, Private)
// Parameters:
// class FString                           EventName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AnswerValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiActivitySubsystem::HandleMenuEvent(const class FString& EventName, bool AnswerValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiActivitySubsystem", "HandleMenuEvent");

	Params::DiActivitySubsystem_HandleMenuEvent Parms{};

	Parms.EventName = std::move(EventName);
	Parms.AnswerValue = AnswerValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiActivitySubsystem.HandleStateChanged
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FName                             CurrentState                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiActivitySubsystem::HandleStateChanged(const class FName& CurrentState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiActivitySubsystem", "HandleStateChanged");

	Params::DiActivitySubsystem_HandleStateChanged Parms{};

	Parms.CurrentState = CurrentState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiActivitySubsystem.OnPostLoadMap
// (Final, Native, Public)
// Parameters:
// class UWorld*                           LoadedWorld                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiActivitySubsystem::OnPostLoadMap(class UWorld* LoadedWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiActivitySubsystem", "OnPostLoadMap");

	Params::DiActivitySubsystem_OnPostLoadMap Parms{};

	Parms.LoadedWorld = LoadedWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiActivitySubsystem.OnWorldCleanup
// (Final, Native, Public)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSessionEnded                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCleanupResources                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiActivitySubsystem::OnWorldCleanup(class UWorld* World, bool bSessionEnded, bool bCleanupResources)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiActivitySubsystem", "OnWorldCleanup");

	Params::DiActivitySubsystem_OnWorldCleanup Parms{};

	Parms.World = World;
	Parms.bSessionEnded = bSessionEnded;
	Parms.bCleanupResources = bCleanupResources;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AceHeatVisionZone.BP_OnZoneRadiusScaleFactorChange
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   NewScaleFactor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAceHeatVisionZone::BP_OnZoneRadiusScaleFactorChange(float NewScaleFactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceHeatVisionZone", "BP_OnZoneRadiusScaleFactorChange");

	Params::AceHeatVisionZone_BP_OnZoneRadiusScaleFactorChange Parms{};

	Parms.NewScaleFactor = NewScaleFactor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.AceHeatVisionZone.HandleComponentOverlapEnd
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAceHeatVisionZone::HandleComponentOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceHeatVisionZone", "HandleComponentOverlapEnd");

	Params::AceHeatVisionZone_HandleComponentOverlapEnd Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AceHeatVisionZone.HandleComponentOverlapStart
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AAceHeatVisionZone::HandleComponentOverlapStart(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceHeatVisionZone", "HandleComponentOverlapStart");

	Params::AceHeatVisionZone_HandleComponentOverlapStart Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AceHeatVisionZone.SetCollisionMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             CollisionMeshIn                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAceHeatVisionZone::SetCollisionMesh(class UStaticMeshComponent* CollisionMeshIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceHeatVisionZone", "SetCollisionMesh");

	Params::AceHeatVisionZone_SetCollisionMesh Parms{};

	Parms.CollisionMeshIn = CollisionMeshIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AceHeatVisionZone.SetDefaultRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAceHeatVisionZone::SetDefaultRadius(float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceHeatVisionZone", "SetDefaultRadius");

	Params::AceHeatVisionZone_SetDefaultRadius Parms{};

	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AceHeatVisionZone.GetDefaultRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AAceHeatVisionZone::GetDefaultRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceHeatVisionZone", "GetDefaultRadius");

	Params::AceHeatVisionZone_GetDefaultRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.AceHeatVisionZone.GetZoneRadiusScaleFactor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AAceHeatVisionZone::GetZoneRadiusScaleFactor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceHeatVisionZone", "GetZoneRadiusScaleFactor");

	Params::AceHeatVisionZone_GetZoneRadiusScaleFactor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.AcePassiveAbility.HandleHitConfirmed
// (Final, Native, Protected)
// Parameters:
// struct FHitConfirmData                  HitConfirmData                                         (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AAcePassiveAbility::HandleHitConfirmed(const struct FHitConfirmData& HitConfirmData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AcePassiveAbility", "HandleHitConfirmed");

	Params::AcePassiveAbility_HandleHitConfirmed Parms{};

	Parms.HitConfirmData = std::move(HitConfirmData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AcePassiveAbility.HandleShotFired
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// struct FVector                          ShotEndPoint                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AProjectileWeapon*                Weapon_0                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAcePassiveAbility::HandleShotFired(const struct FVector& ShotEndPoint, class AProjectileWeapon* Weapon_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AcePassiveAbility", "HandleShotFired");

	Params::AcePassiveAbility_HandleShotFired Parms{};

	Parms.ShotEndPoint = std::move(ShotEndPoint);
	Parms.Weapon_0 = Weapon_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AcePassiveAbility.OnChargeCanceledClient
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// bool                                    bShotFired                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAcePassiveAbility::OnChargeCanceledClient(bool bShotFired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AcePassiveAbility", "OnChargeCanceledClient");

	Params::AcePassiveAbility_OnChargeCanceledClient Parms{};

	Parms.bShotFired = bShotFired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AcePassiveAbility.OnChargeReadyClient
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void AAcePassiveAbility::OnChargeReadyClient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AcePassiveAbility", "OnChargeReadyClient");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AcePassiveAbility.GetChargeRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AAcePassiveAbility::GetChargeRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AcePassiveAbility", "GetChargeRatio");

	Params::AcePassiveAbility_GetChargeRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BasePlaceable.OnDeath
// (Native, Protected)
// Parameters:
// class AActor*                           DeadActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABasePlaceable::OnDeath(class AActor* DeadActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePlaceable", "OnDeath");

	Params::BasePlaceable_OnDeath Parms{};

	Parms.DeadActor = DeadActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BasePlaceable.OnRep_WrapData
// (Final, Native, Protected)

void ABasePlaceable::OnRep_WrapData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePlaceable", "OnRep_WrapData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BasePlaceable.IsLocallyOwned
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABasePlaceable::IsLocallyOwned() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePlaceable", "IsLocallyOwned");

	Params::BasePlaceable_IsLocallyOwned Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BasePlaceable.IsOwnerFriendlyWith
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ToCheck                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABasePlaceable::IsOwnerFriendlyWith(const class AActor* ToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePlaceable", "IsOwnerFriendlyWith");

	Params::BasePlaceable_IsOwnerFriendlyWith Parms{};

	Parms.ToCheck = ToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BasePickablePlaceable.BP_SetCanBePing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCanBePingIn                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABasePickablePlaceable::BP_SetCanBePing(bool bCanBePingIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePickablePlaceable", "BP_SetCanBePing");

	Params::BasePickablePlaceable_BP_SetCanBePing Parms{};

	Parms.bCanBePingIn = bCanBePingIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BasePickablePlaceable.HandleDropDone
// (Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           ActorDropped                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndPos                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         EndRotation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ABasePickablePlaceable::HandleDropDone(class AActor* ActorDropped, const struct FVector& EndPos, const struct FRotator& EndRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePickablePlaceable", "HandleDropDone");

	Params::BasePickablePlaceable_HandleDropDone Parms{};

	Parms.ActorDropped = ActorDropped;
	Parms.EndPos = std::move(EndPos);
	Parms.EndRotation = std::move(EndRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BasePickablePlaceable.HandleEMPIsAffectedChanged
// (Native, Protected)
// Parameters:
// bool                                    bIsAffected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AffectedActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABasePickablePlaceable::HandleEMPIsAffectedChanged(bool bIsAffected, class AActor* AffectedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePickablePlaceable", "HandleEMPIsAffectedChanged");

	Params::BasePickablePlaceable_HandleEMPIsAffectedChanged Parms{};

	Parms.bIsAffected = bIsAffected;
	Parms.AffectedActor = AffectedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BasePickablePlaceable.HandleScramblerIsAffectedChanged
// (Native, Protected)
// Parameters:
// bool                                    bIsAffected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AffectedActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABasePickablePlaceable::HandleScramblerIsAffectedChanged(bool bIsAffected, class AActor* AffectedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePickablePlaceable", "HandleScramblerIsAffectedChanged");

	Params::BasePickablePlaceable_HandleScramblerIsAffectedChanged Parms{};

	Parms.bIsAffected = bIsAffected;
	Parms.AffectedActor = AffectedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BouncingMat.MulticastNPCImpulse
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FVector_NetQuantize              Impulse                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              VelocityIn                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANPCCharacter*                    ImpulsedNPC                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABouncingMat::MulticastNPCImpulse(const struct FVector_NetQuantize& Impulse, const struct FVector_NetQuantize& VelocityIn, class ANPCCharacter* ImpulsedNPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BouncingMat", "MulticastNPCImpulse");

	Params::BouncingMat_MulticastNPCImpulse Parms{};

	Parms.Impulse = std::move(Impulse);
	Parms.VelocityIn = std::move(VelocityIn);
	Parms.ImpulsedNPC = ImpulsedNPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BouncingMat.OnBouncingMatOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ABouncingMat::OnBouncingMatOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BouncingMat", "OnBouncingMatOverlap");

	Params::BouncingMat_OnBouncingMatOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BouncingMat.OnRep_NewInflatedValue
// (Final, Native, Protected)

void ABouncingMat::OnRep_NewInflatedValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BouncingMat", "OnRep_NewInflatedValue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BouncingMat.ServerSetInflate
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    bInflated                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABouncingMat::ServerSetInflate(bool bInflated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BouncingMat", "ServerSetInflate");

	Params::BouncingMat_ServerSetInflate Parms{};

	Parms.bInflated = bInflated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BouncingMat.ServerSpyBouncedLocalImpulse
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class ASpy*                             BouncedSpyIn                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              Impulse                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              VelocityIn                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABouncingMat::ServerSpyBouncedLocalImpulse(class ASpy* BouncedSpyIn, const struct FVector_NetQuantize& Impulse, const struct FVector_NetQuantize& VelocityIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BouncingMat", "ServerSpyBouncedLocalImpulse");

	Params::BouncingMat_ServerSpyBouncedLocalImpulse Parms{};

	Parms.BouncedSpyIn = BouncedSpyIn;
	Parms.Impulse = std::move(Impulse);
	Parms.VelocityIn = std::move(VelocityIn);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseConditionComponent.IsConditionMet
// (Native, Public, BlueprintCallable)
// Parameters:
// class UInteracterComponent*             InteracterComp                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           PlayerActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseConditionComponent::IsConditionMet(const class UInteracterComponent* InteracterComp, class AActor* PlayerActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseConditionComponent", "IsConditionMet");

	Params::BaseConditionComponent_IsConditionMet Parms{};

	Parms.InteracterComp = InteracterComp;
	Parms.PlayerActor = PlayerActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseConditionComponent.GetConditionType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EConditionType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EConditionType UBaseConditionComponent::GetConditionType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseConditionComponent", "GetConditionType");

	Params::BaseConditionComponent_GetConditionType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ValidateExtractionComponent.HandleInteractionComplete
// (Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UValidateExtractionComponent::HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ValidateExtractionComponent", "HandleInteractionComplete");

	Params::ValidateExtractionComponent_HandleInteractionComplete Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AceTrailActiveAbility.BP_OnUpdateAceActiveTrail
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<struct FVector>                  TrailPoints                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AAceTrailActiveAbility::BP_OnUpdateAceActiveTrail(const TArray<struct FVector>& TrailPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AceTrailActiveAbility", "BP_OnUpdateAceActiveTrail");

	Params::AceTrailActiveAbility_BP_OnUpdateAceActiveTrail Parms{};

	Parms.TrailPoints = std::move(TrailPoints);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.AchievementSubsystem.BP_ResetAchievements
// (Final, Native, Public, BlueprintCallable)

void UAchievementSubsystem::BP_ResetAchievements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementSubsystem", "BP_ResetAchievements");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AchievementSubsystem.BP_UpdateAchievementProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           AchievementID                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Increment                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAchievementSubsystem::BP_UpdateAchievementProgress(const class FString& AchievementID, float Progress, bool Increment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementSubsystem", "BP_UpdateAchievementProgress");

	Params::AchievementSubsystem_BP_UpdateAchievementProgress Parms{};

	Parms.AchievementID = std::move(AchievementID);
	Parms.Progress = Progress;
	Parms.Increment = Increment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISpectatorPawn.CheatSpectateFreeMove
// (Final, Exec, Native, Protected)

void ADISpectatorPawn::CheatSpectateFreeMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISpectatorPawn", "CheatSpectateFreeMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISpectatorPawn.CheatSpectateFreeMoveSrv
// (Net, NetReliable, Native, Event, Protected, NetServer)

void ADISpectatorPawn::CheatSpectateFreeMoveSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISpectatorPawn", "CheatSpectateFreeMoveSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISpectatorPawn.CheatSpectateReviveSpy
// (Final, Exec, Native, Protected)

void ADISpectatorPawn::CheatSpectateReviveSpy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISpectatorPawn", "CheatSpectateReviveSpy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISpectatorPawn.GetSpectatingPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADIPlayerState*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADIPlayerState* ADISpectatorPawn::GetSpectatingPlayerState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISpectatorPawn", "GetSpectatingPlayerState");

	Params::DISpectatorPawn_GetSpectatingPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISpectatorPawn.HandleBooleanPlayerSettingChange
// (Final, Native, Protected)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADISpectatorPawn::HandleBooleanPlayerSettingChange(EPlayerSettingsType SettingType, bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISpectatorPawn", "HandleBooleanPlayerSettingChange");

	Params::DISpectatorPawn_HandleBooleanPlayerSettingChange Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISpectatorPawn.HandleFloatPlayerSettingChange
// (Final, Native, Protected)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADISpectatorPawn::HandleFloatPlayerSettingChange(EPlayerSettingsType SettingType, float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISpectatorPawn", "HandleFloatPlayerSettingChange");

	Params::DISpectatorPawn_HandleFloatPlayerSettingChange Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISpectatorPawn.HandlePhaseChanged
// (Final, Native, Protected)
// Parameters:
// ESpyGamePhase                           NewGamePhase                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADISpectatorPawn::HandlePhaseChanged(ESpyGamePhase NewGamePhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISpectatorPawn", "HandlePhaseChanged");

	Params::DISpectatorPawn_HandlePhaseChanged Parms{};

	Parms.NewGamePhase = NewGamePhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISpectatorPawn.LookHorizontal
// (Final, Native, Protected)
// Parameters:
// float                                   AxisValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADISpectatorPawn::LookHorizontal(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISpectatorPawn", "LookHorizontal");

	Params::DISpectatorPawn_LookHorizontal Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISpectatorPawn.LookHorizontalRate
// (Final, Native, Protected)
// Parameters:
// float                                   AxisValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADISpectatorPawn::LookHorizontalRate(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISpectatorPawn", "LookHorizontalRate");

	Params::DISpectatorPawn_LookHorizontalRate Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISpectatorPawn.LookVertical
// (Final, Native, Protected)
// Parameters:
// float                                   AxisValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADISpectatorPawn::LookVertical(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISpectatorPawn", "LookVertical");

	Params::DISpectatorPawn_LookVertical Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISpectatorPawn.LookVerticalRate
// (Final, Native, Protected)
// Parameters:
// float                                   AxisValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADISpectatorPawn::LookVerticalRate(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISpectatorPawn", "LookVerticalRate");

	Params::DISpectatorPawn_LookVerticalRate Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISpectatorPawn.OnAutoSpectatingChange
// (Final, Native, Protected)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoSpectatingIn                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADISpectatorPawn::OnAutoSpectatingChange(class ADeceiveIncPlayerController* PlayerController, bool bAutoSpectatingIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISpectatorPawn", "OnAutoSpectatingChange");

	Params::DISpectatorPawn_OnAutoSpectatingChange Parms{};

	Parms.PlayerController = PlayerController;
	Parms.bAutoSpectatingIn = bAutoSpectatingIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISpectatorPawn.OnSpectateNextInput
// (Final, Native, Protected)

void ADISpectatorPawn::OnSpectateNextInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISpectatorPawn", "OnSpectateNextInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISpectatorPawn.OnSpectatePrevInput
// (Final, Native, Protected)

void ADISpectatorPawn::OnSpectatePrevInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISpectatorPawn", "OnSpectatePrevInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISpectatorPawn.OnSpectateRevivePingInput
// (Final, Native, Protected, BlueprintCallable)

void ADISpectatorPawn::OnSpectateRevivePingInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISpectatorPawn", "OnSpectateRevivePingInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISpectatorPawn.OnToggleAutoSpectateInput
// (Final, Native, Protected)

void ADISpectatorPawn::OnToggleAutoSpectateInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISpectatorPawn", "OnToggleAutoSpectateInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISpectatorPawn.ShowUserInterface
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADISpectatorPawn::ShowUserInterface(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISpectatorPawn", "ShowUserInterface");

	Params::DISpectatorPawn_ShowUserInterface Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISpectatorPawn.GetIsDedicatedSpectator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADISpectatorPawn::GetIsDedicatedSpectator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISpectatorPawn", "GetIsDedicatedSpectator");

	Params::DISpectatorPawn_GetIsDedicatedSpectator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISpectatorPawn.GetRevivePingCooldownRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADISpectatorPawn::GetRevivePingCooldownRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISpectatorPawn", "GetRevivePingCooldownRatio");

	Params::DISpectatorPawn_GetRevivePingCooldownRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISpectatorPawn.GetSpectatingActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ADISpectatorPawn::GetSpectatingActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISpectatorPawn", "GetSpectatingActor");

	Params::DISpectatorPawn_GetSpectatingActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ChavezActiveAbility.HandleTakePointDamage
// (Final, Native, Protected, HasDefaults)
// Parameters:
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              FHitComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ShotFromDirection                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChavezActiveAbility::HandleTakePointDamage(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& ShotFromDirection, const class UDamageType* DamageType, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChavezActiveAbility", "HandleTakePointDamage");

	Params::ChavezActiveAbility_HandleTakePointDamage Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.Damage = Damage;
	Parms.InstigatedBy = InstigatedBy;
	Parms.HitLocation = std::move(HitLocation);
	Parms.FHitComponent = FHitComponent;
	Parms.BoneName = BoneName;
	Parms.ShotFromDirection = std::move(ShotFromDirection);
	Parms.DamageType = DamageType;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChavezActiveAbility.MulticastShieldHit
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FVector_NetQuantize              HitPos                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChavezActiveAbility::MulticastShieldHit(const struct FVector_NetQuantize& HitPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChavezActiveAbility", "MulticastShieldHit");

	Params::ChavezActiveAbility_MulticastShieldHit Parms{};

	Parms.HitPos = std::move(HitPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChavezActiveAbility.OnPostTriggerDeactivatePower
// (Final, Native, Public)

void AChavezActiveAbility::OnPostTriggerDeactivatePower()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChavezActiveAbility", "OnPostTriggerDeactivatePower");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChavezActiveAbilityMod1.HandleTakeAnyDamage
// (Final, Native, Private)
// Parameters:
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChavezActiveAbilityMod1::HandleTakeAnyDamage(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChavezActiveAbilityMod1", "HandleTakeAnyDamage");

	Params::ChavezActiveAbilityMod1_HandleTakeAnyDamage Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.Damage = Damage;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChavezActiveAbilityMod1.HandleWeaponReloaded
// (Final, Native, Private)
// Parameters:
// ESpyToolEvent                           EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChavezActiveAbilityMod1::HandleWeaponReloaded(ESpyToolEvent EventType, class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChavezActiveAbilityMod1", "HandleWeaponReloaded");

	Params::ChavezActiveAbilityMod1_HandleWeaponReloaded Parms{};

	Parms.EventType = EventType;
	Parms.SpyTool = SpyTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChavezActiveAbilityMod1.OnRep_CurrentWeaponBuff
// (Final, Native, Protected)

void AChavezActiveAbilityMod1::OnRep_CurrentWeaponBuff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChavezActiveAbilityMod1", "OnRep_CurrentWeaponBuff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetDataminingSubsystem.IsRecording
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetDataminingSubsystem::IsRecording() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetDataminingSubsystem", "IsRecording");

	Params::SweetDataminingSubsystem_IsRecording Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ActorAffectedComponent.GetAffectedType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EActorAffectedType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EActorAffectedType UActorAffectedComponent::GetAffectedType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorAffectedComponent", "GetAffectedType");

	Params::ActorAffectedComponent_GetAffectedType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ActorAffectedComponent.OnRep_Sources
// (Final, Native, Protected)
// Parameters:
// TArray<class AActor*>                   OldSources                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UActorAffectedComponent::OnRep_Sources(const TArray<class AActor*>& OldSources)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorAffectedComponent", "OnRep_Sources");

	Params::ActorAffectedComponent_OnRep_Sources Parms{};

	Parms.OldSources = std::move(OldSources);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ActorAffectedComponent.RegisterAffectingSource
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AffectingSource                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorAffectedComponent::RegisterAffectingSource(class AActor* AffectingSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorAffectedComponent", "RegisterAffectingSource");

	Params::ActorAffectedComponent_RegisterAffectingSource Parms{};

	Parms.AffectingSource = AffectingSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ActorAffectedComponent.UnregisterAffectingSource
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AffectingSource                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorAffectedComponent::UnregisterAffectingSource(class AActor* AffectingSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorAffectedComponent", "UnregisterAffectingSource");

	Params::ActorAffectedComponent_UnregisterAffectingSource Parms{};

	Parms.AffectingSource = AffectingSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ActorAffectedComponent.IsAffected
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorAffectedComponent::IsAffected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorAffectedComponent", "IsAffected");

	Params::ActorAffectedComponent_IsAffected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ActorAffectedComponent.IsAffectedForFaction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ToCompare                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorAffectedComponent::IsAffectedForFaction(class AActor* ToCompare) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorAffectedComponent", "IsAffectedForFaction");

	Params::ActorAffectedComponent_IsAffectedForFaction Parms{};

	Parms.ToCompare = ToCompare;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ActorAffectedComponent.IsDisabledByEffect
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorAffectedComponent::IsDisabledByEffect() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorAffectedComponent", "IsDisabledByEffect");

	Params::ActorAffectedComponent_IsDisabledByEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.HansPassiveAbilityMod2.HandleVictimEffectApplied
// (Final, Native, Public)
// Parameters:
// class ASpy*                             Victim                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVictimEffect*                    Effect                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHansPassiveAbilityMod2::HandleVictimEffectApplied(class ASpy* Victim, class AVictimEffect* Effect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansPassiveAbilityMod2", "HandleVictimEffectApplied");

	Params::HansPassiveAbilityMod2_HandleVictimEffectApplied Parms{};

	Parms.Victim = Victim;
	Parms.Effect = Effect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiPawnInterface.DisableDIPawnInput
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Requester                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IDiPawnInterface::DisableDIPawnInput(class AActor* Requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPawnInterface", "DisableDIPawnInput");

	Params::DiPawnInterface_DisableDIPawnInput Parms{};

	Parms.Requester = Requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiPawnInterface.EnableDIPawnInput
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Requester                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IDiPawnInterface::EnableDIPawnInput(class AActor* Requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPawnInterface", "EnableDIPawnInput");

	Params::DiPawnInterface_EnableDIPawnInput Parms{};

	Parms.Requester = Requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseGamePhaseInfo.GetPhaseTimerTxt
// (Native, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UBaseGamePhaseInfo::GetPhaseTimerTxt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseGamePhaseInfo", "GetPhaseTimerTxt");

	Params::BaseGamePhaseInfo_GetPhaseTimerTxt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SpyGamePhaseInfo.GetCriticalTimeAnnoucementDuration
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USpyGamePhaseInfo::GetCriticalTimeAnnoucementDuration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyGamePhaseInfo", "GetCriticalTimeAnnoucementDuration");

	Params::SpyGamePhaseInfo_GetCriticalTimeAnnoucementDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SpyGamePhaseInfo.GetCriticalTimeAnnoucementPriority
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USpyGamePhaseInfo::GetCriticalTimeAnnoucementPriority()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyGamePhaseInfo", "GetCriticalTimeAnnoucementPriority");

	Params::SpyGamePhaseInfo_GetCriticalTimeAnnoucementPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SpyGamePhaseInfo.GetCriticalTimeAnnoucementText
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText USpyGamePhaseInfo::GetCriticalTimeAnnoucementText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyGamePhaseInfo", "GetCriticalTimeAnnoucementText");

	Params::SpyGamePhaseInfo_GetCriticalTimeAnnoucementText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SpyGamePhaseInfo.GetCriticalTimeAnnoucementType
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EAnnouncementType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAnnouncementType USpyGamePhaseInfo::GetCriticalTimeAnnoucementType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyGamePhaseInfo", "GetCriticalTimeAnnoucementType");

	Params::SpyGamePhaseInfo_GetCriticalTimeAnnoucementType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SpyGamePhaseInfo.GetCriticalTimeLeft
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USpyGamePhaseInfo::GetCriticalTimeLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyGamePhaseInfo", "GetCriticalTimeLeft");

	Params::SpyGamePhaseInfo_GetCriticalTimeLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SpyGamePhaseInfo.GetGamePhase
// (Native, Public, BlueprintCallable)
// Parameters:
// ESpyGamePhase                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESpyGamePhase USpyGamePhaseInfo::GetGamePhase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyGamePhaseInfo", "GetGamePhase");

	Params::SpyGamePhaseInfo_GetGamePhase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SpyGamePhaseInfo.HasCriticalTime
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpyGamePhaseInfo::HasCriticalTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyGamePhaseInfo", "HasCriticalTime");

	Params::SpyGamePhaseInfo_HasCriticalTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.AgentData.ShouldShowAgent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAgentData::ShouldShowAgent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgentData", "ShouldShowAgent");

	Params::AgentData_ShouldShowAgent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIBalancingManagerSubsytem.HandleAssetLoadCompleted
// (Final, Native, Private)

void UDIBalancingManagerSubsytem::HandleAssetLoadCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIBalancingManagerSubsytem", "HandleAssetLoadCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AgentSkinData.GetAgentName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAgentSkinData::GetAgentName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgentSkinData", "GetAgentName");

	Params::AgentSkinData_GetAgentName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.AgentSkinData.GetAgentTagline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAgentSkinData::GetAgentTagline() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgentSkinData", "GetAgentTagline");

	Params::AgentSkinData_GetAgentTagline Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.AgentSkinData.GetDefaultIntroPoseForSkin
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAgentIntroPoseDataAsset*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAgentIntroPoseDataAsset* UAgentSkinData::GetDefaultIntroPoseForSkin() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgentSkinData", "GetDefaultIntroPoseForSkin");

	Params::AgentSkinData_GetDefaultIntroPoseForSkin Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.HansPassiveAbility.BP_OnHansPassiveTrigger
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class ASpy*                             TriggeredSpy                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ASpy*>                     TriggeredSpies                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AHansPassiveAbility::BP_OnHansPassiveTrigger(class ASpy* TriggeredSpy, const TArray<class ASpy*>& TriggeredSpies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansPassiveAbility", "BP_OnHansPassiveTrigger");

	Params::HansPassiveAbility_BP_OnHansPassiveTrigger Parms{};

	Parms.TriggeredSpy = TriggeredSpy;
	Parms.TriggeredSpies = std::move(TriggeredSpies);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.HansPassiveAbility.MulticastNotifyTriggerHansPassive
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ASpy*                             AffectedSpy                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ASpy*>                     TriggeredSpies                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AHansPassiveAbility::MulticastNotifyTriggerHansPassive(class ASpy* AffectedSpy, const TArray<class ASpy*>& TriggeredSpies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansPassiveAbility", "MulticastNotifyTriggerHansPassive");

	Params::HansPassiveAbility_MulticastNotifyTriggerHansPassive Parms{};

	Parms.AffectedSpy = AffectedSpy;
	Parms.TriggeredSpies = std::move(TriggeredSpies);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HansPassiveAbility.OnUndercoverChange
// (Final, Native, Protected)
// Parameters:
// bool                                    Undercover                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHansPassiveAbility::OnUndercoverChange(bool Undercover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansPassiveAbility", "OnUndercoverChange");

	Params::HansPassiveAbility_OnUndercoverChange Parms{};

	Parms.Undercover = Undercover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HansPassiveAbilityMod1.HandleCoverBlownEvent
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHansPassiveAbilityMod1::HandleCoverBlownEvent(class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansPassiveAbilityMod1", "HandleCoverBlownEvent");

	Params::HansPassiveAbilityMod1_HandleCoverBlownEvent Parms{};

	Parms.Spy = Spy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AgonesDedicatedServerManager.AgonesErrorHandler
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FAgonesError                     Error                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAgonesDedicatedServerManager::AgonesErrorHandler(const struct FAgonesError& Error)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgonesDedicatedServerManager", "AgonesErrorHandler");

	Params::AgonesDedicatedServerManager_AgonesErrorHandler Parms{};

	Parms.Error = std::move(Error);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AgonesDedicatedServerManager.ReadySuccessHandler
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FEmptyResponse                   Response                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UAgonesDedicatedServerManager::ReadySuccessHandler(const struct FEmptyResponse& Response)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgonesDedicatedServerManager", "ReadySuccessHandler");

	Params::AgonesDedicatedServerManager_ReadySuccessHandler Parms{};

	Parms.Response = std::move(Response);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AgonesDedicatedServerManager.ShutdownSuccessHandler
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FEmptyResponse                   Response                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UAgonesDedicatedServerManager::ShutdownSuccessHandler(const struct FEmptyResponse& Response)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgonesDedicatedServerManager", "ShutdownSuccessHandler");

	Params::AgonesDedicatedServerManager_ShutdownSuccessHandler Parms{};

	Parms.Response = std::move(Response);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameStateBase.AddTimeToPhase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SecondsToAdd                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncGameStateBase::AddTimeToPhase(int32 SecondsToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "AddTimeToPhase");

	Params::DeceiveIncGameStateBase_AddTimeToPhase Parms{};

	Parms.SecondsToAdd = SecondsToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameStateBase.CanGiveXpEvent
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncGameStateBase::CanGiveXpEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "CanGiveXpEvent");

	Params::DeceiveIncGameStateBase_CanGiveXpEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameStateBase.CheatSkipCurrentPhase
// (Native, Public, BlueprintCallable)

void ADeceiveIncGameStateBase::CheatSkipCurrentPhase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "CheatSkipCurrentPhase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameStateBase.GetAllXpEventDisplayInfoForPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADIPlayerState*                   DIPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FXpTypeEventGroupDisplayInfo>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FXpTypeEventGroupDisplayInfo> ADeceiveIncGameStateBase::GetAllXpEventDisplayInfoForPlayer(class ADIPlayerState* DIPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "GetAllXpEventDisplayInfoForPlayer");

	Params::DeceiveIncGameStateBase_GetAllXpEventDisplayInfoForPlayer Parms{};

	Parms.DIPlayerState = DIPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameStateBase.GetCommunityTrackerFromKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ADeceiveIncGameStateBase::GetCommunityTrackerFromKey(const class FString& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "GetCommunityTrackerFromKey");

	Params::DeceiveIncGameStateBase_GetCommunityTrackerFromKey Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameStateBase.GetCurrentMapData
// (Native, Public, BlueprintCallable)
// Parameters:
// class UMapData*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMapData* ADeceiveIncGameStateBase::GetCurrentMapData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "GetCurrentMapData");

	Params::DeceiveIncGameStateBase_GetCurrentMapData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameStateBase.GetCurrentPhaseInfo
// (Native, Public, BlueprintCallable)
// Parameters:
// class UBaseGamePhaseInfo*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBaseGamePhaseInfo* ADeceiveIncGameStateBase::GetCurrentPhaseInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "GetCurrentPhaseInfo");

	Params::DeceiveIncGameStateBase_GetCurrentPhaseInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameStateBase.GetDisplayNameForXPEvent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EDIXPEvent                              XPEventType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ADeceiveIncGameStateBase::GetDisplayNameForXPEvent(EDIXPEvent XPEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "GetDisplayNameForXPEvent");

	Params::DeceiveIncGameStateBase_GetDisplayNameForXPEvent Parms{};

	Parms.XPEventType = XPEventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameStateBase.GetEventSpecificXpTypeToAffect
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EDIXPEvent                              XPEventType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> ADeceiveIncGameStateBase::GetEventSpecificXpTypeToAffect(EDIXPEvent XPEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "GetEventSpecificXpTypeToAffect");

	Params::DeceiveIncGameStateBase_GetEventSpecificXpTypeToAffect Parms{};

	Parms.XPEventType = XPEventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameStateBase.GetLevelForXpValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   CurrentLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   XPTotal                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EXpProgressionType                      ProgressionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADeceiveIncGameStateBase::GetLevelForXpValue(int32 CurrentLevel, int32 XPTotal, EXpProgressionType ProgressionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "GetLevelForXpValue");

	Params::DeceiveIncGameStateBase_GetLevelForXpValue Parms{};

	Parms.CurrentLevel = CurrentLevel;
	Parms.XPTotal = XPTotal;
	Parms.ProgressionType = ProgressionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameStateBase.GetMultiplicatorEventSpecificXpTypeToAffect
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EDIXPEvent                              XPEventType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> ADeceiveIncGameStateBase::GetMultiplicatorEventSpecificXpTypeToAffect(EDIXPEvent XPEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "GetMultiplicatorEventSpecificXpTypeToAffect");

	Params::DeceiveIncGameStateBase_GetMultiplicatorEventSpecificXpTypeToAffect Parms{};

	Parms.XPEventType = XPEventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameStateBase.GetNextMapName
// (Native, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ADeceiveIncGameStateBase::GetNextMapName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "GetNextMapName");

	Params::DeceiveIncGameStateBase_GetNextMapName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameStateBase.GetProgressionMaxLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EXpProgressionType                      ProgressionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADeceiveIncGameStateBase::GetProgressionMaxLevel(EXpProgressionType ProgressionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "GetProgressionMaxLevel");

	Params::DeceiveIncGameStateBase_GetProgressionMaxLevel Parms{};

	Parms.ProgressionType = ProgressionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameStateBase.GetProgressionPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   CurrentLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   XPTotal                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EXpProgressionType                      ProgressionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADeceiveIncGameStateBase::GetProgressionPercent(int32 CurrentLevel, int32 XPTotal, EXpProgressionType ProgressionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "GetProgressionPercent");

	Params::DeceiveIncGameStateBase_GetProgressionPercent Parms{};

	Parms.CurrentLevel = CurrentLevel;
	Parms.XPTotal = XPTotal;
	Parms.ProgressionType = ProgressionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameStateBase.GetRequiredXPForLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EXpProgressionType                      ProgressionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADeceiveIncGameStateBase::GetRequiredXPForLevel(int32 Level, EXpProgressionType ProgressionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "GetRequiredXPForLevel");

	Params::DeceiveIncGameStateBase_GetRequiredXPForLevel Parms{};

	Parms.Level = Level;
	Parms.ProgressionType = ProgressionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameStateBase.GetXpEventDisplayInfoForPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADIPlayerState*                   DIPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FString, struct FXpEventGroupDisplayInfo>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FString, struct FXpEventGroupDisplayInfo> ADeceiveIncGameStateBase::GetXpEventDisplayInfoForPlayer(class ADIPlayerState* DIPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "GetXpEventDisplayInfoForPlayer");

	Params::DeceiveIncGameStateBase_GetXpEventDisplayInfoForPlayer Parms{};

	Parms.DIPlayerState = DIPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameStateBase.GetXpMultiplicatorEventDisplayInfoForPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADIPlayerState*                   DIPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FString, struct FXpEventGroupDisplayInfo>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FString, struct FXpEventGroupDisplayInfo> ADeceiveIncGameStateBase::GetXpMultiplicatorEventDisplayInfoForPlayer(class ADIPlayerState* DIPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "GetXpMultiplicatorEventDisplayInfoForPlayer");

	Params::DeceiveIncGameStateBase_GetXpMultiplicatorEventDisplayInfoForPlayer Parms{};

	Parms.DIPlayerState = DIPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameStateBase.GetXpMultiplicatorValueForEvent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EDIXPEvent                              XPEventType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADeceiveIncGameStateBase::GetXpMultiplicatorValueForEvent(EDIXPEvent XPEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "GetXpMultiplicatorValueForEvent");

	Params::DeceiveIncGameStateBase_GetXpMultiplicatorValueForEvent Parms{};

	Parms.XPEventType = XPEventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameStateBase.GetXpValueForEvent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EDIXPEvent                              XPEventType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADeceiveIncGameStateBase::GetXpValueForEvent(EDIXPEvent XPEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "GetXpValueForEvent");

	Params::DeceiveIncGameStateBase_GetXpValueForEvent Parms{};

	Parms.XPEventType = XPEventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameStateBase.HandleCommunityTrackerEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDICommunityTrackerEvent                CommunityTrackerEventType                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EventAmount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncGameStateBase::HandleCommunityTrackerEvent(EDICommunityTrackerEvent CommunityTrackerEventType, int32 EventAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "HandleCommunityTrackerEvent");

	Params::DeceiveIncGameStateBase_HandleCommunityTrackerEvent Parms{};

	Parms.CommunityTrackerEventType = CommunityTrackerEventType;
	Parms.EventAmount = EventAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameStateBase.HandleSpyDespawnedEvent
// (Final, Native, Public)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncGameStateBase::HandleSpyDespawnedEvent(class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "HandleSpyDespawnedEvent");

	Params::DeceiveIncGameStateBase_HandleSpyDespawnedEvent Parms{};

	Parms.Spy = Spy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameStateBase.HandleSpySpawnedEvent
// (Final, Native, Public)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncGameStateBase::HandleSpySpawnedEvent(class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "HandleSpySpawnedEvent");

	Params::DeceiveIncGameStateBase_HandleSpySpawnedEvent Parms{};

	Parms.Spy = Spy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameStateBase.HandleVaultTerminalDeactivation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADIPlayerState*                   DIPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncGameStateBase::HandleVaultTerminalDeactivation(class ADIPlayerState* DIPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "HandleVaultTerminalDeactivation");

	Params::DeceiveIncGameStateBase_HandleVaultTerminalDeactivation Parms{};

	Parms.DIPlayerState = DIPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameStateBase.HandleXPEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADIPlayerState*                   DIPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDIXPEvent                              XPEventType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EventAmount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncGameStateBase::HandleXPEvent(class ADIPlayerState* DIPlayerState, EDIXPEvent XPEventType, int32 EventAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "HandleXPEvent");

	Params::DeceiveIncGameStateBase_HandleXPEvent Parms{};

	Parms.DIPlayerState = DIPlayerState;
	Parms.XPEventType = XPEventType;
	Parms.EventAmount = EventAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameStateBase.IncrementVaultDeactivationCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADIPlayerState*                   DIPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncGameStateBase::IncrementVaultDeactivationCount(class ADIPlayerState* DIPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "IncrementVaultDeactivationCount");

	Params::DeceiveIncGameStateBase_IncrementVaultDeactivationCount Parms{};

	Parms.DIPlayerState = DIPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameStateBase.IsPrivateLobbyMatch
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncGameStateBase::IsPrivateLobbyMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "IsPrivateLobbyMatch");

	Params::DeceiveIncGameStateBase_IsPrivateLobbyMatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameStateBase.IsXpEventAffectingRegularXpType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EDIXPEvent                              XPEventType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncGameStateBase::IsXpEventAffectingRegularXpType(EDIXPEvent XPEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "IsXpEventAffectingRegularXpType");

	Params::DeceiveIncGameStateBase_IsXpEventAffectingRegularXpType Parms{};

	Parms.XPEventType = XPEventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameStateBase.IsXpEventSharedToFaction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EDIXPEvent                              XPEventType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncGameStateBase::IsXpEventSharedToFaction(EDIXPEvent XPEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "IsXpEventSharedToFaction");

	Params::DeceiveIncGameStateBase_IsXpEventSharedToFaction Parms{};

	Parms.XPEventType = XPEventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameStateBase.IsXpMultiplicatorEventAffectingRegularXpType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EDIXPEvent                              XPEventType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncGameStateBase::IsXpMultiplicatorEventAffectingRegularXpType(EDIXPEvent XPEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "IsXpMultiplicatorEventAffectingRegularXpType");

	Params::DeceiveIncGameStateBase_IsXpMultiplicatorEventAffectingRegularXpType Parms{};

	Parms.XPEventType = XPEventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameStateBase.LockPlayerControlsMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// bool                                    bLock                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncGameStateBase::LockPlayerControlsMulticast(bool bLock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "LockPlayerControlsMulticast");

	Params::DeceiveIncGameStateBase_LockPlayerControlsMulticast Parms{};

	Parms.bLock = bLock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameStateBase.NetMulticast_SignalGlobalEventToClients
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// EGameStateClientEventType               ClientEvent                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncGameStateBase::NetMulticast_SignalGlobalEventToClients(EGameStateClientEventType ClientEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "NetMulticast_SignalGlobalEventToClients");

	Params::DeceiveIncGameStateBase_NetMulticast_SignalGlobalEventToClients Parms{};

	Parms.ClientEvent = ClientEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameStateBase.NetMulticast_SignalVaultTerminalDeactivationToClient
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ADIPlayerState*                   PlayerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FactionID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncGameStateBase::NetMulticast_SignalVaultTerminalDeactivationToClient(class ADIPlayerState* PlayerState, int32 FactionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "NetMulticast_SignalVaultTerminalDeactivationToClient");

	Params::DeceiveIncGameStateBase_NetMulticast_SignalVaultTerminalDeactivationToClient Parms{};

	Parms.PlayerState = PlayerState;
	Parms.FactionID = FactionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameStateBase.OnRep_CurrentGameModeType
// (Native, Protected)

void ADeceiveIncGameStateBase::OnRep_CurrentGameModeType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "OnRep_CurrentGameModeType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameStateBase.OnRep_CurrentPhaseElapsedTime
// (Native, Protected)
// Parameters:
// int32                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncGameStateBase::OnRep_CurrentPhaseElapsedTime(int32 OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "OnRep_CurrentPhaseElapsedTime");

	Params::DeceiveIncGameStateBase_OnRep_CurrentPhaseElapsedTime Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameStateBase.OnRep_CurrentRuleset
// (Native, Protected)

void ADeceiveIncGameStateBase::OnRep_CurrentRuleset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "OnRep_CurrentRuleset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameStateBase.OnRep_FactionData
// (Final, Native, Public)

void ADeceiveIncGameStateBase::OnRep_FactionData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "OnRep_FactionData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameStateBase.OnRep_PS5MatchId
// (Final, Native, Public)

void ADeceiveIncGameStateBase::OnRep_PS5MatchId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "OnRep_PS5MatchId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameStateBase.OnRep_PS5MatchResponsiblePlayer
// (Final, Native, Public)

void ADeceiveIncGameStateBase::OnRep_PS5MatchResponsiblePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "OnRep_PS5MatchResponsiblePlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameStateBase.SetCurrentPhaseTimeLeftInSeconds
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SecondsLeft                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncGameStateBase::SetCurrentPhaseTimeLeftInSeconds(int32 SecondsLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "SetCurrentPhaseTimeLeftInSeconds");

	Params::DeceiveIncGameStateBase_SetCurrentPhaseTimeLeftInSeconds Parms{};

	Parms.SecondsLeft = SecondsLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameStateBase.SetPauseTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bPause                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncGameStateBase::SetPauseTimer(bool bPause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "SetPauseTimer");

	Params::DeceiveIncGameStateBase_SetPauseTimer Parms{};

	Parms.bPause = bPause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameStateBase.GetCurrentLimitedEventId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ADeceiveIncGameStateBase::GetCurrentLimitedEventId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "GetCurrentLimitedEventId");

	Params::DeceiveIncGameStateBase_GetCurrentLimitedEventId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameStateBase.GetCurrentPhaseTimeLeftInSeconds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADeceiveIncGameStateBase::GetCurrentPhaseTimeLeftInSeconds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "GetCurrentPhaseTimeLeftInSeconds");

	Params::DeceiveIncGameStateBase_GetCurrentPhaseTimeLeftInSeconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameStateBase.GetMaximumPlayerCountForCurrentMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADeceiveIncGameStateBase::GetMaximumPlayerCountForCurrentMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameStateBase", "GetMaximumPlayerCountForCurrentMode");

	Params::DeceiveIncGameStateBase_GetMaximumPlayerCountForCurrentMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncMatchGameState.AdvancePhase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bViaTimer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncMatchGameState::AdvancePhase(bool bViaTimer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "AdvancePhase");

	Params::DeceiveIncMatchGameState_AdvancePhase Parms{};

	Parms.bViaTimer = bViaTimer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncMatchGameState.GetGameMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EDIGameMode                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDIGameMode ADeceiveIncMatchGameState::GetGameMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "GetGameMode");

	Params::DeceiveIncMatchGameState_GetGameMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncMatchGameState.HandleNewSpyLoadoutCompleted
// (Final, Native, Protected)
// Parameters:
// class UToolLoadoutComponent*            ToolLoadout                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncMatchGameState::HandleNewSpyLoadoutCompleted(class UToolLoadoutComponent* ToolLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "HandleNewSpyLoadoutCompleted");

	Params::DeceiveIncMatchGameState_HandleNewSpyLoadoutCompleted Parms{};

	Parms.ToolLoadout = ToolLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncMatchGameState.IsInPregamePhase
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncMatchGameState::IsInPregamePhase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "IsInPregamePhase");

	Params::DeceiveIncMatchGameState_IsInPregamePhase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncMatchGameState.OnExtractionArrivedMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ADeceiveIncMatchGameState::OnExtractionArrivedMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "OnExtractionArrivedMulticast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncMatchGameState.OnExtractionOnTheWayMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ADeceiveIncMatchGameState::OnExtractionOnTheWayMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "OnExtractionOnTheWayMulticast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncMatchGameState.OnRep_ColPatches
// (Final, Native, Protected)

void ADeceiveIncMatchGameState::OnRep_ColPatches()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "OnRep_ColPatches");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncMatchGameState.OnRep_Extraction
// (Final, Native, Protected)

void ADeceiveIncMatchGameState::OnRep_Extraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "OnRep_Extraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncMatchGameState.OnRep_MatchResult
// (Final, Native, Protected)
// Parameters:
// EMatchResult                            PreviousResult                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncMatchGameState::OnRep_MatchResult(EMatchResult PreviousResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "OnRep_MatchResult");

	Params::DeceiveIncMatchGameState_OnRep_MatchResult Parms{};

	Parms.PreviousResult = PreviousResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncMatchGameState.OnRep_ObjectiveCarrier
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             OldValue                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncMatchGameState::OnRep_ObjectiveCarrier(class ASpy* OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "OnRep_ObjectiveCarrier");

	Params::DeceiveIncMatchGameState_OnRep_ObjectiveCarrier Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncMatchGameState.OnRep_PregameLobbySessionInfo
// (Native, Protected)

void ADeceiveIncMatchGameState::OnRep_PregameLobbySessionInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "OnRep_PregameLobbySessionInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncMatchGameState.OnRep_SpyGamePhase
// (Native, Protected)

void ADeceiveIncMatchGameState::OnRep_SpyGamePhase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "OnRep_SpyGamePhase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncMatchGameState.OnRep_SpyGameSessionInfo
// (Native, Protected)

void ADeceiveIncMatchGameState::OnRep_SpyGameSessionInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "OnRep_SpyGameSessionInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncMatchGameState.SetVaultTerminalUnlockedCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncMatchGameState::SetVaultTerminalUnlockedCount(int32 NewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "SetVaultTerminalUnlockedCount");

	Params::DeceiveIncMatchGameState_SetVaultTerminalUnlockedCount Parms{};

	Parms.NewCount = NewCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncMatchGameState.SetVaultTerminalUnlockedRequirementCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncMatchGameState::SetVaultTerminalUnlockedRequirementCount(int32 NewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "SetVaultTerminalUnlockedRequirementCount");

	Params::DeceiveIncMatchGameState_SetVaultTerminalUnlockedRequirementCount Parms{};

	Parms.NewCount = NewCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncMatchGameState.ShouldShowTimer
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncMatchGameState::ShouldShowTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "ShouldShowTimer");

	Params::DeceiveIncMatchGameState_ShouldShowTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncMatchGameState.GetCurrentGamePhaseTimeLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADeceiveIncMatchGameState::GetCurrentGamePhaseTimeLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "GetCurrentGamePhaseTimeLeft");

	Params::DeceiveIncMatchGameState_GetCurrentGamePhaseTimeLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncMatchGameState.GetPlayerExtracted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADIPlayerState*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADIPlayerState* ADeceiveIncMatchGameState::GetPlayerExtracted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "GetPlayerExtracted");

	Params::DeceiveIncMatchGameState_GetPlayerExtracted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncMatchGameState.GetTimeLeftforHUD
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADeceiveIncMatchGameState::GetTimeLeftforHUD() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "GetTimeLeftforHUD");

	Params::DeceiveIncMatchGameState_GetTimeLeftforHUD Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncMatchGameState.GetVaultTerminalUnlockedCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADeceiveIncMatchGameState::GetVaultTerminalUnlockedCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "GetVaultTerminalUnlockedCount");

	Params::DeceiveIncMatchGameState_GetVaultTerminalUnlockedCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncMatchGameState.GetVaultTerminalUnlockedRequirementCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADeceiveIncMatchGameState::GetVaultTerminalUnlockedRequirementCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "GetVaultTerminalUnlockedRequirementCount");

	Params::DeceiveIncMatchGameState_GetVaultTerminalUnlockedRequirementCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncMatchGameState.HasReachedVaultTerminalUnlockedRequirement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncMatchGameState::HasReachedVaultTerminalUnlockedRequirement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "HasReachedVaultTerminalUnlockedRequirement");

	Params::DeceiveIncMatchGameState_HasReachedVaultTerminalUnlockedRequirement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncMatchGameState.IsMatchFinished
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncMatchGameState::IsMatchFinished() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "IsMatchFinished");

	Params::DeceiveIncMatchGameState_IsMatchFinished Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncMatchGameState.IsMatchOnGoing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncMatchGameState::IsMatchOnGoing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "IsMatchOnGoing");

	Params::DeceiveIncMatchGameState_IsMatchOnGoing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncMatchGameState.IsOnlyBotsAreAlive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncMatchGameState::IsOnlyBotsAreAlive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "IsOnlyBotsAreAlive");

	Params::DeceiveIncMatchGameState_IsOnlyBotsAreAlive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncMatchGameState.IsSandboxGame
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncMatchGameState::IsSandboxGame() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMatchGameState", "IsSandboxGame");

	Params::DeceiveIncMatchGameState_IsSandboxGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncBotController.OnSpyDeath
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncBotController::OnSpyDeath(class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncBotController", "OnSpyDeath");

	Params::DeceiveIncBotController_OnSpyDeath Parms{};

	Parms.Spy = Spy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncBotController.ScriptedAggroLocalPlayer
// (Final, Native, Public, BlueprintCallable)

void ADeceiveIncBotController::ScriptedAggroLocalPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncBotController", "ScriptedAggroLocalPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncBotController.ScriptedMoveTo
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          MovePosition                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBotAction*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBotAction* ADeceiveIncBotController::ScriptedMoveTo(const struct FVector& MovePosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncBotController", "ScriptedMoveTo");

	Params::DeceiveIncBotController_ScriptedMoveTo Parms{};

	Parms.MovePosition = std::move(MovePosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncBotController.ScriptedTriggerActiveAbility
// (Final, Native, Public, BlueprintCallable)

void ADeceiveIncBotController::ScriptedTriggerActiveAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncBotController", "ScriptedTriggerActiveAbility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AnalogCursorSubsystem.Global_DisableVirtualCursor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PC                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnalogCursorSubsystem::Global_DisableVirtualCursor(class APlayerController* PC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnalogCursorSubsystem", "Global_DisableVirtualCursor");

	Params::AnalogCursorSubsystem_Global_DisableVirtualCursor Parms{};

	Parms.PC = PC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AnalogCursorSubsystem.Global_EnableVirtualCursor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PC                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnalogCursorSubsystem::Global_EnableVirtualCursor(class APlayerController* PC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnalogCursorSubsystem", "Global_EnableVirtualCursor");

	Params::AnalogCursorSubsystem_Global_EnableVirtualCursor Parms{};

	Parms.PC = PC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AnalogCursorSubsystem.Global_IsCursorOverInteractableWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                PC                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnalogCursorSubsystem::Global_IsCursorOverInteractableWidget(class APlayerController* PC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnalogCursorSubsystem", "Global_IsCursorOverInteractableWidget");

	Params::AnalogCursorSubsystem_Global_IsCursorOverInteractableWidget Parms{};

	Parms.PC = PC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.AnalogCursorSubsystem.DisableAnalogCursor
// (Final, Native, Public)

void UAnalogCursorSubsystem::DisableAnalogCursor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnalogCursorSubsystem", "DisableAnalogCursor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AnalogCursorSubsystem.EnableAnalogCursor
// (Final, Native, Public)

void UAnalogCursorSubsystem::EnableAnalogCursor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnalogCursorSubsystem", "EnableAnalogCursor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AnalogCursorSubsystem.ContainsGamepadCursorInputProcessor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnalogCursorSubsystem::ContainsGamepadCursorInputProcessor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnalogCursorSubsystem", "ContainsGamepadCursorInputProcessor");

	Params::AnalogCursorSubsystem_ContainsGamepadCursorInputProcessor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.AnalogCursorSubsystem.IsCursorOverInteractableWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnalogCursorSubsystem::IsCursorOverInteractableWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnalogCursorSubsystem", "IsCursorOverInteractableWidget");

	Params::AnalogCursorSubsystem_IsCursorOverInteractableWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.AnalogCursorSubsystem.IsCursorValid
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnalogCursorSubsystem::IsCursorValid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnalogCursorSubsystem", "IsCursorValid");

	Params::AnalogCursorSubsystem_IsCursorValid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.AnnouncementInstance.OnHideTimerEnd
// (Final, Native, Public)

void UAnnouncementInstance::OnHideTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnnouncementInstance", "OnHideTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AnnouncementInstance.OnTimerEnd
// (Final, Native, Public)

void UAnnouncementInstance::OnTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnnouncementInstance", "OnTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AnnouncementSubsystem.ClearAnnouncementGroup
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CallerActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnnouncementGroup                      Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnnouncementSubsystem::ClearAnnouncementGroup(class AActor* CallerActor, EAnnouncementGroup Group)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnnouncementSubsystem", "ClearAnnouncementGroup");

	Params::AnnouncementSubsystem_ClearAnnouncementGroup Parms{};

	Parms.CallerActor = CallerActor;
	Parms.Group = Group;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AnnouncementSubsystem.ConfirmAnnouncementHidden
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CallerActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AnnouncementInstanceID                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnnouncementSubsystem::ConfirmAnnouncementHidden(class AActor* CallerActor, int32 AnnouncementInstanceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnnouncementSubsystem", "ConfirmAnnouncementHidden");

	Params::AnnouncementSubsystem_ConfirmAnnouncementHidden Parms{};

	Parms.CallerActor = CallerActor;
	Parms.AnnouncementInstanceID = AnnouncementInstanceID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AnnouncementSubsystem.ShowAnnouncement
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CallerActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             TextToDisplay                                          (Parm, NativeAccessSpecifierPublic)
// EAnnouncementType                       AnnouncementType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnnouncementGroup                      Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCanBeQueued                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnnouncementSubsystem::ShowAnnouncement(class AActor* CallerActor, const class FText& TextToDisplay, EAnnouncementType AnnouncementType, EAnnouncementGroup Group, int32 Priority, float Duration, bool bCanBeQueued)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnnouncementSubsystem", "ShowAnnouncement");

	Params::AnnouncementSubsystem_ShowAnnouncement Parms{};

	Parms.CallerActor = CallerActor;
	Parms.TextToDisplay = std::move(TextToDisplay);
	Parms.AnnouncementType = AnnouncementType;
	Parms.Group = Group;
	Parms.Priority = Priority;
	Parms.Duration = Duration;
	Parms.bCanBeQueued = bCanBeQueued;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AnnouncementSubsystem.ShowAnnouncementWithSubText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CallerActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             TextToDisplay                                          (Parm, NativeAccessSpecifierPublic)
// class FText                             SubTextToDisplay                                       (Parm, NativeAccessSpecifierPublic)
// EAnnouncementType                       AnnouncementType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnnouncementGroup                      Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCanBeQueued                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnnouncementSubsystem::ShowAnnouncementWithSubText(class AActor* CallerActor, const class FText& TextToDisplay, const class FText& SubTextToDisplay, EAnnouncementType AnnouncementType, EAnnouncementGroup Group, int32 Priority, float Duration, bool bCanBeQueued)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnnouncementSubsystem", "ShowAnnouncementWithSubText");

	Params::AnnouncementSubsystem_ShowAnnouncementWithSubText Parms{};

	Parms.CallerActor = CallerActor;
	Parms.TextToDisplay = std::move(TextToDisplay);
	Parms.SubTextToDisplay = std::move(SubTextToDisplay);
	Parms.AnnouncementType = AnnouncementType;
	Parms.Group = Group;
	Parms.Priority = Priority;
	Parms.Duration = Duration;
	Parms.bCanBeQueued = bCanBeQueued;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction DeceiveInc.AnnouncementSubsystem.OnClearAnnouncementGroupDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// int32                                   DisplayedAnnouncementInstanceID                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           QueuedAnnouncementInstanceID                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EAnnouncementGroup                      Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnnouncementSubsystem::OnClearAnnouncementGroupDelegate__DelegateSignature(int32 DisplayedAnnouncementInstanceID, const TArray<int32>& QueuedAnnouncementInstanceID, EAnnouncementGroup Group)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnnouncementSubsystem", "OnClearAnnouncementGroupDelegate__DelegateSignature");

	Params::AnnouncementSubsystem_OnClearAnnouncementGroupDelegate__DelegateSignature Parms{};

	Parms.DisplayedAnnouncementInstanceID = DisplayedAnnouncementInstanceID;
	Parms.QueuedAnnouncementInstanceID = std::move(QueuedAnnouncementInstanceID);
	Parms.Group = Group;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.AnnouncementSubsystem.OnHideAnnouncementDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// int32                                   AnnouncementInstanceID                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnnouncementType                       AnnouncementType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnnouncementGroup                      Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnnouncementSubsystem::OnHideAnnouncementDelegate__DelegateSignature(int32 AnnouncementInstanceID, EAnnouncementType AnnouncementType, EAnnouncementGroup Group)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnnouncementSubsystem", "OnHideAnnouncementDelegate__DelegateSignature");

	Params::AnnouncementSubsystem_OnHideAnnouncementDelegate__DelegateSignature Parms{};

	Parms.AnnouncementInstanceID = AnnouncementInstanceID;
	Parms.AnnouncementType = AnnouncementType;
	Parms.Group = Group;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.AnnouncementSubsystem.OnShowAnnouncementDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// int32                                   AnnouncementInstanceID                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             TextToDisplay                                          (Parm, NativeAccessSpecifierPublic)
// class FText                             SubTextToDisplay                                       (Parm, NativeAccessSpecifierPublic)
// EAnnouncementType                       AnnouncementType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnnouncementGroup                      Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnnouncementSubsystem::OnShowAnnouncementDelegate__DelegateSignature(int32 AnnouncementInstanceID, const class FText& TextToDisplay, const class FText& SubTextToDisplay, EAnnouncementType AnnouncementType, EAnnouncementGroup Group, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnnouncementSubsystem", "OnShowAnnouncementDelegate__DelegateSignature");

	Params::AnnouncementSubsystem_OnShowAnnouncementDelegate__DelegateSignature Parms{};

	Parms.AnnouncementInstanceID = AnnouncementInstanceID;
	Parms.TextToDisplay = std::move(TextToDisplay);
	Parms.SubTextToDisplay = std::move(SubTextToDisplay);
	Parms.AnnouncementType = AnnouncementType;
	Parms.Group = Group;
	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.DiMenuPageUserWidget.BP_OnGotoMenuCommand
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class FString>                   CommandParams                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDiMenuPageUserWidget::BP_OnGotoMenuCommand(const TArray<class FString>& CommandParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiMenuPageUserWidget", "BP_OnGotoMenuCommand");

	Params::DiMenuPageUserWidget_BP_OnGotoMenuCommand Parms{};

	Parms.CommandParams = std::move(CommandParams);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.DiMenuPageUserWidget.BP_OnMenuPageUserWidgetClosed
// (Event, Public, BlueprintEvent)

void UDiMenuPageUserWidget::BP_OnMenuPageUserWidgetClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiMenuPageUserWidget", "BP_OnMenuPageUserWidgetClosed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.DiMenuPageUserWidget.GetDefaultFocusWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UDiMenuPageUserWidget::GetDefaultFocusWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiMenuPageUserWidget", "GetDefaultFocusWidget");

	Params::DiMenuPageUserWidget_GetDefaultFocusWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiMenuPageUserWidget.HandleGOTOMENUCommandAction
// (Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FString>                   CommandParams                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDiMenuPageUserWidget::HandleGOTOMENUCommandAction(const TArray<class FString>& CommandParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiMenuPageUserWidget", "HandleGOTOMENUCommandAction");

	Params::DiMenuPageUserWidget_HandleGOTOMENUCommandAction Parms{};

	Parms.CommandParams = std::move(CommandParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiMenuPageUserWidget.SetAsDefaultFocusWidget
// (Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          DefaultFocus                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiMenuPageUserWidget::SetAsDefaultFocusWidget(class UWidget* DefaultFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiMenuPageUserWidget", "SetAsDefaultFocusWidget");

	Params::DiMenuPageUserWidget_SetAsDefaultFocusWidget Parms{};

	Parms.DefaultFocus = DefaultFocus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiCharacterMenuPageUserWidget.BP_OnSelectCharacterRequest
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UAgentData*                       AgentToSelect                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiCharacterMenuPageUserWidget::BP_OnSelectCharacterRequest(const class UAgentData* AgentToSelect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiCharacterMenuPageUserWidget", "BP_OnSelectCharacterRequest");

	Params::DiCharacterMenuPageUserWidget_BP_OnSelectCharacterRequest Parms{};

	Parms.AgentToSelect = AgentToSelect;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.AOEWeaponComponent.HandleWeaponProjectileImpact
// (Final, Native, Protected)
// Parameters:
// struct FWeaponImpactData                WeaponImpactData                                       (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAOEWeaponComponent::HandleWeaponProjectileImpact(const struct FWeaponImpactData& WeaponImpactData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AOEWeaponComponent", "HandleWeaponProjectileImpact");

	Params::AOEWeaponComponent_HandleWeaponProjectileImpact Parms{};

	Parms.WeaponImpactData = std::move(WeaponImpactData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AOEWeaponComponent.Server_AOEDamage
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// struct FWeaponImpactData                WeaponImpactData                                       (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAOEWeaponComponent::Server_AOEDamage(const struct FWeaponImpactData& WeaponImpactData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AOEWeaponComponent", "Server_AOEDamage");

	Params::AOEWeaponComponent_Server_AOEDamage Parms{};

	Parms.WeaponImpactData = std::move(WeaponImpactData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AttachToSpyComponent.HandleCoverChanged
// (Final, Native, Protected)
// Parameters:
// class ANPCCharacter*                    Disguise                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttachToSpyComponent::HandleCoverChanged(class ANPCCharacter* Disguise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttachToSpyComponent", "HandleCoverChanged");

	Params::AttachToSpyComponent_HandleCoverChanged Parms{};

	Parms.Disguise = Disguise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AttachToSpyComponent.HandleMimicChanged
// (Final, Native, Protected)
// Parameters:
// class ABaseMimicScannableActor*         NewMimic                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttachToSpyComponent::HandleMimicChanged(class ABaseMimicScannableActor* NewMimic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttachToSpyComponent", "HandleMimicChanged");

	Params::AttachToSpyComponent_HandleMimicChanged Parms{};

	Parms.NewMimic = NewMimic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AttachToSpyComponent.HandleResourceChanged
// (Final, Native, Protected)
// Parameters:
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ResourceDisplayName                                    (Parm, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttachToSpyComponent::HandleResourceChanged(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttachToSpyComponent", "HandleResourceChanged");

	Params::AttachToSpyComponent_HandleResourceChanged Parms{};

	Parms.ResourceType = ResourceType;
	Parms.ResourceDisplayName = std::move(ResourceDisplayName);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AttachToSpyComponent.HandleUnderCoverChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    IsUndercover                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttachToSpyComponent::HandleUnderCoverChanged(bool IsUndercover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttachToSpyComponent", "HandleUnderCoverChanged");

	Params::AttachToSpyComponent_HandleUnderCoverChanged Parms{};

	Parms.IsUndercover = IsUndercover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AttachToSpyComponent.HandleVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bIs1P                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttachToSpyComponent::HandleVisibilityChanged(bool bIs1P)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttachToSpyComponent", "HandleVisibilityChanged");

	Params::AttachToSpyComponent_HandleVisibilityChanged Parms{};

	Parms.bIs1P = bIs1P;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteractionIconComponent.GetTooltipText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UInteractionIconComponent::GetTooltipText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionIconComponent", "GetTooltipText");

	Params::InteractionIconComponent_GetTooltipText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteractionIconComponent.OnCompleteEnd
// (Final, Native, Public, BlueprintCallable)

void UInteractionIconComponent::OnCompleteEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionIconComponent", "OnCompleteEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteractionIconComponent.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionIconComponent::SetEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionIconComponent", "SetEnabled");

	Params::InteractionIconComponent_SetEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteractionIconComponent.SetEnabledLocal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionIconComponent::SetEnabledLocal(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionIconComponent", "SetEnabledLocal");

	Params::InteractionIconComponent_SetEnabledLocal Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteractionIconComponent.SetToolTipText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             NewText                                                (Parm, NativeAccessSpecifierPublic)

void UInteractionIconComponent::SetToolTipText(const class FText& NewText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionIconComponent", "SetToolTipText");

	Params::InteractionIconComponent_SetToolTipText Parms{};

	Parms.NewText = std::move(NewText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteractionIconComponent.StartInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   PercentToSet                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UProgressBar*                     ProgressBar                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionIconComponent::StartInteraction(float PercentToSet, class UProgressBar* ProgressBar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionIconComponent", "StartInteraction");

	Params::InteractionIconComponent_StartInteraction Parms{};

	Parms.PercentToSet = PercentToSet;
	Parms.ProgressBar = ProgressBar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteractionIconComponent.StopInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   PercentToSet                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionIconComponent::StopInteraction(float PercentToSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionIconComponent", "StopInteraction");

	Params::InteractionIconComponent_StopInteraction Parms{};

	Parms.PercentToSet = PercentToSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteractionIconComponent.GetInteractionIconState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInteractionIconState                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInteractionIconState UInteractionIconComponent::GetInteractionIconState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionIconComponent", "GetInteractionIconState");

	Params::InteractionIconComponent_GetInteractionIconState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteractionIconComponent.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionIconComponent::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionIconComponent", "IsEnabled");

	Params::InteractionIconComponent_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuUserWidget.BP_OnBackActionTriggered
// (Event, Public, BlueprintEvent)

void UDIMenuUserWidget::BP_OnBackActionTriggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuUserWidget", "BP_OnBackActionTriggered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.DIMenuUserWidget.BP_OnCustomActionTriggered
// (Event, Public, BlueprintEvent)
// Parameters:
// class UInputAction*                     TriggeredAction                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuUserWidget::BP_OnCustomActionTriggered(const class UInputAction* TriggeredAction, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuUserWidget", "BP_OnCustomActionTriggered");

	Params::DIMenuUserWidget_BP_OnCustomActionTriggered Parms{};

	Parms.TriggeredAction = TriggeredAction;
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.DIMenuUserWidget.BP_OnGotoMenuCommand
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class FString>                   CommandParams                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDIMenuUserWidget::BP_OnGotoMenuCommand(const TArray<class FString>& CommandParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuUserWidget", "BP_OnGotoMenuCommand");

	Params::DIMenuUserWidget_BP_OnGotoMenuCommand Parms{};

	Parms.CommandParams = std::move(CommandParams);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.DIMenuUserWidget.BP_OnMenuRemoved
// (Event, Public, BlueprintEvent)

void UDIMenuUserWidget::BP_OnMenuRemoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuUserWidget", "BP_OnMenuRemoved");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.DIMenuUserWidget.BP_OnMenuShown
// (Event, Public, BlueprintEvent)

void UDIMenuUserWidget::BP_OnMenuShown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuUserWidget", "BP_OnMenuShown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.DIMenuUserWidget.DisplayMenuPage
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PageIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuUserWidget::DisplayMenuPage(int32 PageIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuUserWidget", "DisplayMenuPage");

	Params::DIMenuUserWidget_DisplayMenuPage Parms{};

	Parms.PageIndex = PageIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuUserWidget.GetMenuPageNavigation
// (Native, Public, BlueprintCallable)
// Parameters:
// class UDiMenuPageNavigationWidget*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDiMenuPageNavigationWidget* UDIMenuUserWidget::GetMenuPageNavigation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuUserWidget", "GetMenuPageNavigation");

	Params::DIMenuUserWidget_GetMenuPageNavigation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuUserWidget.GetMenuSwitcher
// (Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetSwitcher*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetSwitcher* UDIMenuUserWidget::GetMenuSwitcher()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuUserWidget", "GetMenuSwitcher");

	Params::DIMenuUserWidget_GetMenuSwitcher Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuUserWidget.HandleGOTOMENUCommandAction
// (Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FString>                   CommandParams                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDIMenuUserWidget::HandleGOTOMENUCommandAction(const TArray<class FString>& CommandParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuUserWidget", "HandleGOTOMENUCommandAction");

	Params::DIMenuUserWidget_HandleGOTOMENUCommandAction Parms{};

	Parms.CommandParams = std::move(CommandParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuUserWidget.HandlePhaseTick
// (Final, Native, Protected)
// Parameters:
// int32                                   TimeRemainingInSeconds                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuUserWidget::HandlePhaseTick(int32 TimeRemainingInSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuUserWidget", "HandlePhaseTick");

	Params::DIMenuUserWidget_HandlePhaseTick Parms{};

	Parms.TimeRemainingInSeconds = TimeRemainingInSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuUserWidget.RemoveThisMenuFromScreen
// (Native, Public, BlueprintCallable)

void UDIMenuUserWidget::RemoveThisMenuFromScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuUserWidget", "RemoveThisMenuFromScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuUserWidget.SetMenuName
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InMenuName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuUserWidget::SetMenuName(class FName InMenuName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuUserWidget", "SetMenuName");

	Params::DIMenuUserWidget_SetMenuName Parms{};

	Parms.InMenuName = InMenuName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuUserWidget.SignalInputHandled
// (Native, Public, BlueprintCallable)

void UDIMenuUserWidget::SignalInputHandled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuUserWidget", "SignalInputHandled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuUserWidget.GetMenuName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UDIMenuUserWidget::GetMenuName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuUserWidget", "GetMenuName");

	Params::DIMenuUserWidget_GetMenuName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuUserWidget.IsMenuShown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIMenuUserWidget::IsMenuShown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuUserWidget", "IsMenuShown");

	Params::DIMenuUserWidget_IsMenuShown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuStoreShowcaseWidget.BP_ShowItemInMenu
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UDIItem*                          NewItem                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuStoreShowcaseWidget::BP_ShowItemInMenu(class UDIItem* NewItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuStoreShowcaseWidget", "BP_ShowItemInMenu");

	Params::DIMenuStoreShowcaseWidget_BP_ShowItemInMenu Parms{};

	Parms.NewItem = NewItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.DIMenuStoreShowcaseWidget.PrepareItemShowcase
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UDIItem*                          ShowcaseItem                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuStoreShowcaseWidget::PrepareItemShowcase(class UDIItem* ShowcaseItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuStoreShowcaseWidget", "PrepareItemShowcase");

	Params::DIMenuStoreShowcaseWidget_PrepareItemShowcase Parms{};

	Parms.ShowcaseItem = ShowcaseItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuStoreShowcaseWidget.ShowNextItem
// (Final, Native, Protected, BlueprintCallable)

void UDIMenuStoreShowcaseWidget::ShowNextItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuStoreShowcaseWidget", "ShowNextItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuStoreShowcaseWidget.ShowNextVariation
// (Final, Native, Protected, BlueprintCallable)

void UDIMenuStoreShowcaseWidget::ShowNextVariation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuStoreShowcaseWidget", "ShowNextVariation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuStoreShowcaseWidget.ShowPreviousItem
// (Final, Native, Protected, BlueprintCallable)

void UDIMenuStoreShowcaseWidget::ShowPreviousItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuStoreShowcaseWidget", "ShowPreviousItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuStoreShowcaseWidget.ShowPreviousVariation
// (Final, Native, Protected, BlueprintCallable)

void UDIMenuStoreShowcaseWidget::ShowPreviousVariation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuStoreShowcaseWidget", "ShowPreviousVariation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AwsPingHandler.DoPing
// (Final, Native, Private)

void UAwsPingHandler::DoPing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AwsPingHandler", "DoPing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AYumiPassiveAbilityMod1_2.HandleHitConfirmed
// (Final, Native, Protected)
// Parameters:
// struct FHitConfirmData                  HitConfirmData                                         (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AAYumiPassiveAbilityMod1_2::HandleHitConfirmed(const struct FHitConfirmData& HitConfirmData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AYumiPassiveAbilityMod1_2", "HandleHitConfirmed");

	Params::AYumiPassiveAbilityMod1_2_HandleHitConfirmed Parms{};

	Parms.HitConfirmData = std::move(HitConfirmData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AYumiPassiveAbilityMod1_2.HandleMeleeDamageConfirmed
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactPoint                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ChargeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageDone                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ResultingHealthPercentage                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHitType                                HitType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMeleeHitConfirmedData           HitConfirmedData                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AAYumiPassiveAbilityMod1_2::HandleMeleeDamageConfirmed(class AActor* Victim, const struct FVector& ImpactPoint, int32 ChargeLevel, float DamageDone, float ResultingHealthPercentage, EHitType HitType, const struct FMeleeHitConfirmedData& HitConfirmedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AYumiPassiveAbilityMod1_2", "HandleMeleeDamageConfirmed");

	Params::AYumiPassiveAbilityMod1_2_HandleMeleeDamageConfirmed Parms{};

	Parms.Victim = Victim;
	Parms.ImpactPoint = std::move(ImpactPoint);
	Parms.ChargeLevel = ChargeLevel;
	Parms.DamageDone = DamageDone;
	Parms.ResultingHealthPercentage = ResultingHealthPercentage;
	Parms.HitType = HitType;
	Parms.HitConfirmedData = std::move(HitConfirmedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.AYumiPassiveAbilityMod1_2.HandleSpyToolLoadComplete
// (Final, Native, Protected)
// Parameters:
// class UToolLoadoutComponent*            ToolLoadout                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAYumiPassiveAbilityMod1_2::HandleSpyToolLoadComplete(class UToolLoadoutComponent* ToolLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AYumiPassiveAbilityMod1_2", "HandleSpyToolLoadComplete");

	Params::AYumiPassiveAbilityMod1_2_HandleSpyToolLoadComplete Parms{};

	Parms.ToolLoadout = ToolLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseAoEActor.BP_OnAoEUpdateInterval
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   AddedActors                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   RemovedActors                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ABaseAoEActor::BP_OnAoEUpdateInterval(const TArray<class AActor*>& AddedActors, const TArray<class AActor*>& RemovedActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAoEActor", "BP_OnAoEUpdateInterval");

	Params::BaseAoEActor_BP_OnAoEUpdateInterval Parms{};

	Parms.AddedActors = std::move(AddedActors);
	Parms.RemovedActors = std::move(RemovedActors);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseAoEActor.BP_OnDestroyedAfterApplyingEffect
// (Event, Public, BlueprintEvent)

void ABaseAoEActor::BP_OnDestroyedAfterApplyingEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAoEActor", "BP_OnDestroyedAfterApplyingEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.BaseAoEActor.EnableAoE
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnableIn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseAoEActor::EnableAoE(bool bEnableIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAoEActor", "EnableAoE");

	Params::BaseAoEActor_EnableAoE Parms{};

	Parms.bEnableIn = bEnableIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseBreadcrumbsActor.BP_OnBreacrumbEnd
// (Event, Protected, BlueprintEvent)

void ABaseBreadcrumbsActor::BP_OnBreacrumbEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseBreadcrumbsActor", "BP_OnBreacrumbEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.BaseBreadcrumbsActor.BP_OnBreacrumbStart
// (Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// float                                   Lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewPosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseBreadcrumbsActor::BP_OnBreacrumbStart(float Lifetime, const struct FVector& NewPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseBreadcrumbsActor", "BP_OnBreacrumbStart");

	Params::BaseBreadcrumbsActor_BP_OnBreacrumbStart Parms{};

	Parms.Lifetime = Lifetime;
	Parms.NewPosition = std::move(NewPosition);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseBreadcrumbsActor.HandleLifetimeDone
// (Final, Native, Protected)

void ABaseBreadcrumbsActor::HandleLifetimeDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseBreadcrumbsActor", "HandleLifetimeDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseBreadcrumbsActor.IsUsable
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseBreadcrumbsActor::IsUsable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseBreadcrumbsActor", "IsUsable");

	Params::BaseBreadcrumbsActor_IsUsable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseBreadcrumbsActor.OnRep_Data
// (Final, Native, Protected)

void ABaseBreadcrumbsActor::OnRep_Data()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseBreadcrumbsActor", "OnRep_Data");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseBreadcrumbsActor.SetupForCavaliere
// (Final, Native, Public, BlueprintCallable)

void ABaseBreadcrumbsActor::SetupForCavaliere()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseBreadcrumbsActor", "SetupForCavaliere");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseBreadcrumbsActor.GetInteractableType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInteractableType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInteractableType ABaseBreadcrumbsActor::GetInteractableType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseBreadcrumbsActor", "GetInteractableType");

	Params::BaseBreadcrumbsActor_GetInteractableType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.CheckRuleApply_Base.IsActiveForCurrentRules
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCheckRuleApply_Base::IsActiveForCurrentRules()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheckRuleApply_Base", "IsActiveForCurrentRules");

	Params::CheckRuleApply_Base_IsActiveForCurrentRules Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseInteractableActor.BP_OnHiddenInContainerChange
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bNowHidden                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseInteractableActor::BP_OnHiddenInContainerChange(bool bNowHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseInteractableActor", "BP_OnHiddenInContainerChange");

	Params::BaseInteractableActor_BP_OnHiddenInContainerChange Parms{};

	Parms.bNowHidden = bNowHidden;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseInteractableActor.BP_OnInteractionComplete
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseInteractableActor::BP_OnInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseInteractableActor", "BP_OnInteractionComplete");

	Params::BaseInteractableActor_BP_OnInteractionComplete Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseInteractableActor.BP_SetCanBePing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCanBePingIn                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseInteractableActor::BP_SetCanBePing(bool bCanBePingIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseInteractableActor", "BP_SetCanBePing");

	Params::BaseInteractableActor_BP_SetCanBePing Parms{};

	Parms.bCanBePingIn = bCanBePingIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseInteractableActor.HandleInteractionComplete
// (Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseInteractableActor::HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseInteractableActor", "HandleInteractionComplete");

	Params::BaseInteractableActor_HandleInteractionComplete Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseInteractableActor.IsUsable
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseInteractableActor::IsUsable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseInteractableActor", "IsUsable");

	Params::BaseInteractableActor_IsUsable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseInteractableActor.OnRep_HiddenInContainer
// (Native, Protected)

void ABaseInteractableActor::OnRep_HiddenInContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseInteractableActor", "OnRep_HiddenInContainer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseInteractableActor.SetHiddenInContainer
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InHidden                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseInteractableActor::SetHiddenInContainer(bool InHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseInteractableActor", "SetHiddenInContainer");

	Params::BaseInteractableActor_SetHiddenInContainer Parms{};

	Parms.InHidden = InHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseInteractableActor.GetInteractableComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractableComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractableComponent* ABaseInteractableActor::GetInteractableComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseInteractableActor", "GetInteractableComponent");

	Params::BaseInteractableActor_GetInteractableComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseInteractableActor.GetInteractableType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInteractableType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInteractableType ABaseInteractableActor::GetInteractableType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseInteractableActor", "GetInteractableType");

	Params::BaseInteractableActor_GetInteractableType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteractionAuthorityComponent.NetMulticastCancelInteraction
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionAuthorityComponent::NetMulticastCancelInteraction(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionAuthorityComponent", "NetMulticastCancelInteraction");

	Params::InteractionAuthorityComponent_NetMulticastCancelInteraction Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteractionAuthorityComponent.NetMulticastCompleteInteraction
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionAuthorityComponent::NetMulticastCompleteInteraction(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionAuthorityComponent", "NetMulticastCompleteInteraction");

	Params::InteractionAuthorityComponent_NetMulticastCompleteInteraction Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteractionAuthorityComponent.NetMulticastStartInteraction
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionAuthorityComponent::NetMulticastStartInteraction(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionAuthorityComponent", "NetMulticastStartInteraction");

	Params::InteractionAuthorityComponent_NetMulticastStartInteraction Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseContainerActor.BP_OnContainerClosing
// (Event, Protected, BlueprintEvent)

void ABaseContainerActor::BP_OnContainerClosing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseContainerActor", "BP_OnContainerClosing");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.BaseContainerActor.BP_OnContainerOpening
// (Event, Protected, BlueprintEvent)

void ABaseContainerActor::BP_OnContainerOpening()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseContainerActor", "BP_OnContainerOpening");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.BaseContainerActor.OnPostInitRooms
// (Final, Native, Protected)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseContainerActor::OnPostInitRooms(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseContainerActor", "OnPostInitRooms");

	Params::BaseContainerActor_OnPostInitRooms Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseContainerActor.OnRep_ContainerState
// (Final, Native, Protected)
// Parameters:
// EContainerState                         PreviousState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseContainerActor::OnRep_ContainerState(EContainerState PreviousState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseContainerActor", "OnRep_ContainerState");

	Params::BaseContainerActor_OnRep_ContainerState Parms{};

	Parms.PreviousState = PreviousState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseContainerActor.OnTimeToEnableInteract
// (Final, Native, Protected)

void ABaseContainerActor::OnTimeToEnableInteract()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseContainerActor", "OnTimeToEnableInteract");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.LarcinActiveMod1Ability.BP_OnLarcinActiveEffectBegin
// (Event, Protected, BlueprintEvent)

void ALarcinActiveMod1Ability::BP_OnLarcinActiveEffectBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinActiveMod1Ability", "BP_OnLarcinActiveEffectBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.LarcinActiveMod1Ability.BP_OnLarcinActiveEffectBeginLocal
// (Event, Protected, BlueprintEvent)

void ALarcinActiveMod1Ability::BP_OnLarcinActiveEffectBeginLocal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinActiveMod1Ability", "BP_OnLarcinActiveEffectBeginLocal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.LarcinActiveMod1Ability.BP_OnLarcinActiveEffectBeginReplicated
// (Event, Protected, BlueprintEvent)

void ALarcinActiveMod1Ability::BP_OnLarcinActiveEffectBeginReplicated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinActiveMod1Ability", "BP_OnLarcinActiveEffectBeginReplicated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.LarcinActiveMod1Ability.OnSmokeBombTimerEnd
// (Native, Protected)

void ALarcinActiveMod1Ability::OnSmokeBombTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinActiveMod1Ability", "OnSmokeBombTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.LarcinActiveMod1Ability.OnTriggerDelayTimer
// (Native, Protected)

void ALarcinActiveMod1Ability::OnTriggerDelayTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinActiveMod1Ability", "OnTriggerDelayTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.LarcinActiveMod1Ability.TriggerAbilityEffectNetMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ALarcinActiveMod1Ability::TriggerAbilityEffectNetMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinActiveMod1Ability", "TriggerAbilityEffectNetMulticast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HansActiveAbilityMod2.OnTriggerDelayTimer
// (Native, Protected)

void AHansActiveAbilityMod2::OnTriggerDelayTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansActiveAbilityMod2", "OnTriggerDelayTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseDispenserActor.BP_OnLocalDispenserJammed
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsJammed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseDispenserActor::BP_OnLocalDispenserJammed(bool bIsJammed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseDispenserActor", "BP_OnLocalDispenserJammed");

	Params::BaseDispenserActor_BP_OnLocalDispenserJammed Parms{};

	Parms.bIsJammed = bIsJammed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseDoorActor.BP_IsDoorJammedForActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseDoorActor::BP_IsDoorJammedForActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseDoorActor", "BP_IsDoorJammedForActor");

	Params::BaseDoorActor_BP_IsDoorJammedForActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseDoorActor.BP_OnDoorClosing
// (Event, Protected, BlueprintEvent)

void ABaseDoorActor::BP_OnDoorClosing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseDoorActor", "BP_OnDoorClosing");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.BaseDoorActor.BP_OnDoorClosingFromBack
// (Event, Protected, BlueprintEvent)

void ABaseDoorActor::BP_OnDoorClosingFromBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseDoorActor", "BP_OnDoorClosingFromBack");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.BaseDoorActor.BP_OnDoorClosingFromFront
// (Event, Protected, BlueprintEvent)

void ABaseDoorActor::BP_OnDoorClosingFromFront()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseDoorActor", "BP_OnDoorClosingFromFront");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.BaseDoorActor.BP_OnDoorLocked
// (Event, Protected, BlueprintEvent)

void ABaseDoorActor::BP_OnDoorLocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseDoorActor", "BP_OnDoorLocked");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.BaseDoorActor.BP_OnDoorOpening
// (Event, Protected, BlueprintEvent)

void ABaseDoorActor::BP_OnDoorOpening()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseDoorActor", "BP_OnDoorOpening");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.BaseDoorActor.BP_OnDoorOpeningFromBack
// (Event, Protected, BlueprintEvent)

void ABaseDoorActor::BP_OnDoorOpeningFromBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseDoorActor", "BP_OnDoorOpeningFromBack");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.BaseDoorActor.BP_OnDoorOpeningFromFront
// (Event, Protected, BlueprintEvent)

void ABaseDoorActor::BP_OnDoorOpeningFromFront()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseDoorActor", "BP_OnDoorOpeningFromFront");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.BaseDoorActor.BP_OnDoorUnlocked
// (Event, Protected, BlueprintEvent)

void ABaseDoorActor::BP_OnDoorUnlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseDoorActor", "BP_OnDoorUnlocked");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.BaseDoorActor.BP_OnLocalDoorJammed
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsJammed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseDoorActor::BP_OnLocalDoorJammed(bool bIsJammed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseDoorActor", "BP_OnLocalDoorJammed");

	Params::BaseDoorActor_BP_OnLocalDoorJammed Parms{};

	Parms.bIsJammed = bIsJammed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseDoorActor.BP_OpenDoor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorOpening                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bValidate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   KeepOpenDuration                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseDoorActor::BP_OpenDoor(class AActor* ActorOpening, bool bValidate, float KeepOpenDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseDoorActor", "BP_OpenDoor");

	Params::BaseDoorActor_BP_OpenDoor Parms{};

	Parms.ActorOpening = ActorOpening;
	Parms.bValidate = bValidate;
	Parms.KeepOpenDuration = KeepOpenDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseDoorActor.DoDoorStuckChecks
// (Final, Native, Protected, BlueprintCallable)

void ABaseDoorActor::DoDoorStuckChecks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseDoorActor", "DoDoorStuckChecks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseDoorActor.HandleDoorUnlocked
// (Final, Native, Protected)
// Parameters:
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseDoorActor::HandleDoorUnlocked(int32 PlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseDoorActor", "HandleDoorUnlocked");

	Params::BaseDoorActor_HandleDoorUnlocked Parms{};

	Parms.PlayerIndex = PlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseDoorActor.HandleLocalSpyResourcesNewAmount
// (Final, Native, Protected)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayResourcesType                  AffectedResource                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewResourceCount                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseDoorActor::HandleLocalSpyResourcesNewAmount(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, EGameplayResourcesType AffectedResource, int32 NewResourceCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseDoorActor", "HandleLocalSpyResourcesNewAmount");

	Params::BaseDoorActor_HandleLocalSpyResourcesNewAmount Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;
	Parms.AffectedResource = AffectedResource;
	Parms.NewResourceCount = NewResourceCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseDoorActor.HandleResourceSpent
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseDoorActor::HandleResourceSpent(class UInteracterComponent* Interacter, EGameplayResourcesType ResourceType, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseDoorActor", "HandleResourceSpent");

	Params::BaseDoorActor_HandleResourceSpent Parms{};

	Parms.Interacter = Interacter;
	Parms.ResourceType = ResourceType;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseDoorActor.OnRep_DoorState
// (Final, Native, Protected)
// Parameters:
// EDoorState                              PreviousState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseDoorActor::OnRep_DoorState(EDoorState PreviousState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseDoorActor", "OnRep_DoorState");

	Params::BaseDoorActor_OnRep_DoorState Parms{};

	Parms.PreviousState = PreviousState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseDoorActor.OnTimeToTryClose
// (Final, Native, Protected)

void ABaseDoorActor::OnTimeToTryClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseDoorActor", "OnTimeToTryClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseDoorActor.GetSecurityLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESecurityLevel                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESecurityLevel ABaseDoorActor::GetSecurityLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseDoorActor", "GetSecurityLevel");

	Params::BaseDoorActor_GetSecurityLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseDoorActor.IsActorBehindDoor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseDoorActor::IsActorBehindDoor(class AActor* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseDoorActor", "IsActorBehindDoor");

	Params::BaseDoorActor_IsActorBehindDoor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.YumiPassiveAbility.OnSpyToolLoadComplete
// (Final, Native, Protected)
// Parameters:
// class UToolLoadoutComponent*            ToolLoadout                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AYumiPassiveAbility::OnSpyToolLoadComplete(class UToolLoadoutComponent* ToolLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YumiPassiveAbility", "OnSpyToolLoadComplete");

	Params::YumiPassiveAbility_OnSpyToolLoadComplete Parms{};

	Parms.ToolLoadout = ToolLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseIntelActor.BP_IsJammedForActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseIntelActor::BP_IsJammedForActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseIntelActor", "BP_IsJammedForActor");

	Params::BaseIntelActor_BP_IsJammedForActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseIntelActor.BP_OnIntelEffectedByDrainChange
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bEffectedByDrain                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEffectedByEnemy                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseIntelActor::BP_OnIntelEffectedByDrainChange(bool bEffectedByDrain, bool bEffectedByEnemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseIntelActor", "BP_OnIntelEffectedByDrainChange");

	Params::BaseIntelActor_BP_OnIntelEffectedByDrainChange Parms{};

	Parms.bEffectedByDrain = bEffectedByDrain;
	Parms.bEffectedByEnemy = bEffectedByEnemy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseIntelActor.BP_OnIntelRebooted
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Instigater                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseIntelActor::BP_OnIntelRebooted(class AActor* Instigater)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseIntelActor", "BP_OnIntelRebooted");

	Params::BaseIntelActor_BP_OnIntelRebooted Parms{};

	Parms.Instigater = Instigater;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseIntelActor.BP_OnLocalActorJammed
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsJammed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseIntelActor::BP_OnLocalActorJammed(bool bIsJammed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseIntelActor", "BP_OnLocalActorJammed");

	Params::BaseIntelActor_BP_OnLocalActorJammed Parms{};

	Parms.bIsJammed = bIsJammed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseIntelActor.IsDisabledByExternalSourceForActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseIntelActor::IsDisabledByExternalSourceForActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseIntelActor", "IsDisabledByExternalSourceForActor");

	Params::BaseIntelActor_IsDisabledByExternalSourceForActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseIntelActor.IsDisabledByExternalSourceForLocalPlayer
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseIntelActor::IsDisabledByExternalSourceForLocalPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseIntelActor", "IsDisabledByExternalSourceForLocalPlayer");

	Params::BaseIntelActor_IsDisabledByExternalSourceForLocalPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseIntelActor.IsJammedForLocalPlayer
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseIntelActor::IsJammedForLocalPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseIntelActor", "IsJammedForLocalPlayer");

	Params::BaseIntelActor_IsJammedForLocalPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseIntelActor.GetResourceCountToGive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ABaseIntelActor::GetResourceCountToGive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseIntelActor", "GetResourceCountToGive");

	Params::BaseIntelActor_GetResourceCountToGive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseIntelActor.GetResourceTypeToGive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGameplayResourcesType                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameplayResourcesType ABaseIntelActor::GetResourceTypeToGive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseIntelActor", "GetResourceTypeToGive");

	Params::BaseIntelActor_GetResourceTypeToGive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ExtractionArrivingPhaseInfo.GetObjectiveDescCarrier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UExtractionArrivingPhaseInfo::GetObjectiveDescCarrier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionArrivingPhaseInfo", "GetObjectiveDescCarrier");

	Params::ExtractionArrivingPhaseInfo_GetObjectiveDescCarrier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ExtractionArrivingPhaseInfo.GetObjectiveDescNonCarrier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UExtractionArrivingPhaseInfo::GetObjectiveDescNonCarrier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionArrivingPhaseInfo", "GetObjectiveDescNonCarrier");

	Params::ExtractionArrivingPhaseInfo_GetObjectiveDescNonCarrier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ExtractionArrivingPhaseInfo.GetObjectiveDescNonCarrierTeammate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UExtractionArrivingPhaseInfo::GetObjectiveDescNonCarrierTeammate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionArrivingPhaseInfo", "GetObjectiveDescNonCarrierTeammate");

	Params::ExtractionArrivingPhaseInfo_GetObjectiveDescNonCarrierTeammate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseGenericChestActor.BP_CloseDoor
// (Event, Protected, BlueprintEvent)

void ABaseGenericChestActor::BP_CloseDoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseGenericChestActor", "BP_CloseDoor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.BaseGenericChestActor.HandleResourceSpent
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseGenericChestActor::HandleResourceSpent(class UInteracterComponent* Interacter, EGameplayResourcesType ResourceType, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseGenericChestActor", "HandleResourceSpent");

	Params::BaseGenericChestActor_HandleResourceSpent Parms{};

	Parms.Interacter = Interacter;
	Parms.ResourceType = ResourceType;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseGenericChestActor.HandleSpawnSetupedComplete
// (Final, Native, Protected)

void ABaseGenericChestActor::HandleSpawnSetupedComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseGenericChestActor", "HandleSpawnSetupedComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseGenericChestActor.Multicast_CloseDoor
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ABaseGenericChestActor::Multicast_CloseDoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseGenericChestActor", "Multicast_CloseDoor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseMeleeAttack.GetWeaponBalancingDataForClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UClass*                           WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseDamage_0                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseMeleeAttack::GetWeaponBalancingDataForClass(class UClass* WeaponClass, float* BaseDamage_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BaseMeleeAttack", "GetWeaponBalancingDataForClass");

	Params::BaseMeleeAttack_GetWeaponBalancingDataForClass Parms{};

	Parms.WeaponClass = WeaponClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (BaseDamage_0 != nullptr)
		*BaseDamage_0 = Parms.BaseDamage_0;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseMeleeAttack.BP_OnChargeLevelChange
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   NewChargeLevel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseMeleeAttack::BP_OnChargeLevelChange(int32 NewChargeLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "BP_OnChargeLevelChange");

	Params::BaseMeleeAttack_BP_OnChargeLevelChange Parms{};

	Parms.NewChargeLevel = NewChargeLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseMeleeAttack.BP_OnMeleeAttack
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   ChargeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseMeleeAttack::BP_OnMeleeAttack(int32 ChargeLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "BP_OnMeleeAttack");

	Params::BaseMeleeAttack_BP_OnMeleeAttack Parms{};

	Parms.ChargeLevel = ChargeLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseMeleeAttack.BP_OnMeleeAttackHit
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactPoint                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ChargeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ResultingHealthPercentage                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHitType                                HitType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMeleeHitConfirmedData           HitConfirmedData                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ABaseMeleeAttack::BP_OnMeleeAttackHit(class AActor* Victim, const struct FVector& ImpactPoint, int32 ChargeLevel, float Damage, float ResultingHealthPercentage, EHitType HitType, const struct FMeleeHitConfirmedData& HitConfirmedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "BP_OnMeleeAttackHit");

	Params::BaseMeleeAttack_BP_OnMeleeAttackHit Parms{};

	Parms.Victim = Victim;
	Parms.ImpactPoint = std::move(ImpactPoint);
	Parms.ChargeLevel = ChargeLevel;
	Parms.Damage = Damage;
	Parms.ResultingHealthPercentage = ResultingHealthPercentage;
	Parms.HitType = HitType;
	Parms.HitConfirmedData = std::move(HitConfirmedData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BaseMeleeAttack.BP_OnMeleeCancel
// (Event, Protected, BlueprintEvent)

void ABaseMeleeAttack::BP_OnMeleeCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "BP_OnMeleeCancel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.BaseMeleeAttack.Multicast_CancelMelee
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ABaseMeleeAttack::Multicast_CancelMelee()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "Multicast_CancelMelee");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseMeleeAttack.Multicast_DoImpulseMelee
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FVector_NetQuantize              OriginPos                                              (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              DestinationPos                                         (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int8                                    ChargeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               ActorHit                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ABaseMeleeAttack::Multicast_DoImpulseMelee(const struct FVector_NetQuantize& OriginPos, const struct FVector_NetQuantize& DestinationPos, int8 ChargeLevel, const TArray<struct FHitResult>& ActorHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "Multicast_DoImpulseMelee");

	Params::BaseMeleeAttack_Multicast_DoImpulseMelee Parms{};

	Parms.OriginPos = std::move(OriginPos);
	Parms.DestinationPos = std::move(DestinationPos);
	Parms.ChargeLevel = ChargeLevel;
	Parms.ActorHit = std::move(ActorHit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseMeleeAttack.Multicast_DoStrike
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FVector_NetQuantize              DestinationPos                                         (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int8                                    ChargeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseMeleeAttack::Multicast_DoStrike(const struct FVector_NetQuantize& DestinationPos, int8 ChargeLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "Multicast_DoStrike");

	Params::BaseMeleeAttack_Multicast_DoStrike Parms{};

	Parms.DestinationPos = std::move(DestinationPos);
	Parms.ChargeLevel = ChargeLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseMeleeAttack.Multicast_EnvHit
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FMeleeHitConfirmedData           HitConfirmedData                                       (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ABaseMeleeAttack::Multicast_EnvHit(const struct FMeleeHitConfirmedData& HitConfirmedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "Multicast_EnvHit");

	Params::BaseMeleeAttack_Multicast_EnvHit Parms{};

	Parms.HitConfirmedData = std::move(HitConfirmedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseMeleeAttack.Multicast_HitConfirmed
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FMeleeHitConfirmedData           HitConfirmedData                                       (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ABaseMeleeAttack::Multicast_HitConfirmed(const struct FMeleeHitConfirmedData& HitConfirmedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "Multicast_HitConfirmed");

	Params::BaseMeleeAttack_Multicast_HitConfirmed Parms{};

	Parms.HitConfirmedData = std::move(HitConfirmedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseMeleeAttack.NetMulticast_SetupTargetInfo
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bImpulse                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseMeleeAttack::NetMulticast_SetupTargetInfo(class AActor* Target, bool bImpulse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "NetMulticast_SetupTargetInfo");

	Params::BaseMeleeAttack_NetMulticast_SetupTargetInfo Parms{};

	Parms.Target = Target;
	Parms.bImpulse = bImpulse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseMeleeAttack.OnCooldownTimerComplete
// (Final, Native, Protected)

void ABaseMeleeAttack::OnCooldownTimerComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "OnCooldownTimerComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseMeleeAttack.OnDisableWeaponTimerComplete
// (Final, Native, Protected)

void ABaseMeleeAttack::OnDisableWeaponTimerComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "OnDisableWeaponTimerComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseMeleeAttack.OnImpulseCooldownTimerComplete
// (Final, Native, Protected)

void ABaseMeleeAttack::OnImpulseCooldownTimerComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "OnImpulseCooldownTimerComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseMeleeAttack.OnRep_CurrentChargeLevel
// (Final, Native, Protected)
// Parameters:
// int8                                    OldChargeLevel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseMeleeAttack::OnRep_CurrentChargeLevel(int8 OldChargeLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "OnRep_CurrentChargeLevel");

	Params::BaseMeleeAttack_OnRep_CurrentChargeLevel Parms{};

	Parms.OldChargeLevel = OldChargeLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseMeleeAttack.Server_BeginCharge
// (Net, NetReliable, Native, Event, Protected, NetServer)

void ABaseMeleeAttack::Server_BeginCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "Server_BeginCharge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseMeleeAttack.Server_DoImpulseMelee
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// struct FVector_NetQuantize              OriginPos                                              (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              DestinationPos                                         (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               HitTargets                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int8                                    ChargeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseMeleeAttack::Server_DoImpulseMelee(const struct FVector_NetQuantize& OriginPos, const struct FVector_NetQuantize& DestinationPos, const TArray<struct FHitResult>& HitTargets, int8 ChargeLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "Server_DoImpulseMelee");

	Params::BaseMeleeAttack_Server_DoImpulseMelee Parms{};

	Parms.OriginPos = std::move(OriginPos);
	Parms.DestinationPos = std::move(DestinationPos);
	Parms.HitTargets = std::move(HitTargets);
	Parms.ChargeLevel = ChargeLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseMeleeAttack.Server_DoStrike
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// struct FVector_NetQuantize              OriginPos                                              (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              DestinationPos                                         (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               HitTargets                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int8                                    ChargeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseMeleeAttack::Server_DoStrike(const struct FVector_NetQuantize& OriginPos, const struct FVector_NetQuantize& DestinationPos, const TArray<struct FHitResult>& HitTargets, int8 ChargeLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "Server_DoStrike");

	Params::BaseMeleeAttack_Server_DoStrike Parms{};

	Parms.OriginPos = std::move(OriginPos);
	Parms.DestinationPos = std::move(DestinationPos);
	Parms.HitTargets = std::move(HitTargets);
	Parms.ChargeLevel = ChargeLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseMeleeAttack.Server_ExternalSetOnCooldown
// (Net, NetReliable, Native, Event, Public, NetServer)

void ABaseMeleeAttack::Server_ExternalSetOnCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "Server_ExternalSetOnCooldown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseMeleeAttack.Server_ResetCharge
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    bIsCancel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseMeleeAttack::Server_ResetCharge(bool bIsCancel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "Server_ResetCharge");

	Params::BaseMeleeAttack_Server_ResetCharge Parms{};

	Parms.bIsCancel = bIsCancel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseMeleeAttack.Server_SetupTargetInfo
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bImpulse                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseMeleeAttack::Server_SetupTargetInfo(class AActor* Target, bool bImpulse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "Server_SetupTargetInfo");

	Params::BaseMeleeAttack_Server_SetupTargetInfo Parms{};

	Parms.Target = Target;
	Parms.bImpulse = bImpulse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseMeleeAttack.GetChargeLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ABaseMeleeAttack::GetChargeLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "GetChargeLevel");

	Params::BaseMeleeAttack_GetChargeLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseMeleeAttack.GetCooldownBeforeShooting
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ChargeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ABaseMeleeAttack::GetCooldownBeforeShooting(int32 ChargeLevel) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "GetCooldownBeforeShooting");

	Params::BaseMeleeAttack_GetCooldownBeforeShooting Parms{};

	Parms.ChargeLevel = ChargeLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseMeleeAttack.GetCooldownBetweenStrikes
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ChargeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ABaseMeleeAttack::GetCooldownBetweenStrikes(int32 ChargeLevel) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "GetCooldownBetweenStrikes");

	Params::BaseMeleeAttack_GetCooldownBetweenStrikes Parms{};

	Parms.ChargeLevel = ChargeLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseMeleeAttack.GetLastAttackCooldownBetweenStrikes
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ABaseMeleeAttack::GetLastAttackCooldownBetweenStrikes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "GetLastAttackCooldownBetweenStrikes");

	Params::BaseMeleeAttack_GetLastAttackCooldownBetweenStrikes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseMeleeAttack.GetLastAttckChargeLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ABaseMeleeAttack::GetLastAttckChargeLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "GetLastAttckChargeLevel");

	Params::BaseMeleeAttack_GetLastAttckChargeLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseMeleeAttack.GetMaxChargeTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ABaseMeleeAttack::GetMaxChargeTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "GetMaxChargeTime");

	Params::BaseMeleeAttack_GetMaxChargeTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseMeleeAttack.GetMeleeCogOffset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ABaseMeleeAttack::GetMeleeCogOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "GetMeleeCogOffset");

	Params::BaseMeleeAttack_GetMeleeCogOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseMeleeAttack.IsCanCancelMelee
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseMeleeAttack::IsCanCancelMelee() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "IsCanCancelMelee");

	Params::BaseMeleeAttack_IsCanCancelMelee Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseMeleeAttack.IsCharging
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseMeleeAttack::IsCharging() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "IsCharging");

	Params::BaseMeleeAttack_IsCharging Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseMeleeAttack.IsFullyCharge
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseMeleeAttack::IsFullyCharge() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMeleeAttack", "IsFullyCharge");

	Params::BaseMeleeAttack_IsFullyCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseMimicScannableActor.HandleLocalSpyMovingChanged
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMoving                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseMimicScannableActor::HandleLocalSpyMovingChanged(class ASpy* Spy, bool bMoving)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMimicScannableActor", "HandleLocalSpyMovingChanged");

	Params::BaseMimicScannableActor_HandleLocalSpyMovingChanged Parms{};

	Parms.Spy = Spy;
	Parms.bMoving = bMoving;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseMimicScannableActor.HandleSpectatingPlayerChangeEvent
// (Final, Native, Protected)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SpectatingActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADIPlayerState*                   SpectatingPlayerState                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseMimicScannableActor::HandleSpectatingPlayerChangeEvent(class ADeceiveIncPlayerController* PlayerController, class AActor* SpectatingActor, class ADIPlayerState* SpectatingPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMimicScannableActor", "HandleSpectatingPlayerChangeEvent");

	Params::BaseMimicScannableActor_HandleSpectatingPlayerChangeEvent Parms{};

	Parms.PlayerController = PlayerController;
	Parms.SpectatingActor = SpectatingActor;
	Parms.SpectatingPlayerState = SpectatingPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseMimicScannableActor.NetMulticast_EnableInteract
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseMimicScannableActor::NetMulticast_EnableInteract(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMimicScannableActor", "NetMulticast_EnableInteract");

	Params::BaseMimicScannableActor_NetMulticast_EnableInteract Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseMimicScannableActor.Server_EnableInteract
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseMimicScannableActor::Server_EnableInteract(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMimicScannableActor", "Server_EnableInteract");

	Params::BaseMimicScannableActor_Server_EnableInteract Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.LarcinActiveAbility.BP_OnLarcinActiveEffectBegin
// (Event, Protected, BlueprintEvent)

void ALarcinActiveAbility::BP_OnLarcinActiveEffectBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinActiveAbility", "BP_OnLarcinActiveEffectBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.LarcinActiveAbility.BP_OnLarcinActiveEffectBeginLocal
// (Event, Protected, BlueprintEvent)

void ALarcinActiveAbility::BP_OnLarcinActiveEffectBeginLocal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinActiveAbility", "BP_OnLarcinActiveEffectBeginLocal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.LarcinActiveAbility.BP_OnLarcinActiveEffectBeginReplicated
// (Event, Protected, BlueprintEvent)

void ALarcinActiveAbility::BP_OnLarcinActiveEffectBeginReplicated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinActiveAbility", "BP_OnLarcinActiveEffectBeginReplicated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.LarcinActiveAbility.OnTriggerDelayTimer
// (Native, Protected)

void ALarcinActiveAbility::OnTriggerDelayTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinActiveAbility", "OnTriggerDelayTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.LarcinActiveAbility.TriggerAbilityEffectNetMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ALarcinActiveAbility::TriggerAbilityEffectNetMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinActiveAbility", "TriggerAbilityEffectNetMulticast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.LarcinActiveAbility.BP_IsLarcinActiveTriggered
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALarcinActiveAbility::BP_IsLarcinActiveTriggered() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinActiveAbility", "BP_IsLarcinActiveTriggered");

	Params::LarcinActiveAbility_BP_IsLarcinActiveTriggered Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BasePickableActor.HandleMaxUseChanged
// (Final, Native, Protected)

void ABasePickableActor::HandleMaxUseChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePickableActor", "HandleMaxUseChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BasePickableActor.OnRep_Collected
// (Final, Native, Protected)
// Parameters:
// bool                                    PreviousCollected                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABasePickableActor::OnRep_Collected(bool PreviousCollected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePickableActor", "OnRep_Collected");

	Params::BasePickableActor_OnRep_Collected Parms{};

	Parms.PreviousCollected = PreviousCollected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BasePickableActor.BP_OverrideGivenRessource
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class AActor*                           Interacter                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayResourcesType                  OverrideRessourceType                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OverrideRessourceCount                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABasePickableActor::BP_OverrideGivenRessource(class AActor* Interacter, EGameplayResourcesType* OverrideRessourceType, int32* OverrideRessourceCount) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePickableActor", "BP_OverrideGivenRessource");

	Params::BasePickableActor_BP_OverrideGivenRessource Parms{};

	Parms.Interacter = Interacter;

	UObject::ProcessEvent(Func, &Parms);

	if (OverrideRessourceType != nullptr)
		*OverrideRessourceType = Parms.OverrideRessourceType;

	if (OverrideRessourceCount != nullptr)
		*OverrideRessourceCount = Parms.OverrideRessourceCount;
}


// Function DeceiveInc.BasePickableActor.GetResourceCountToGive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Interacter                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ABasePickableActor::GetResourceCountToGive(class AActor* Interacter) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePickableActor", "GetResourceCountToGive");

	Params::BasePickableActor_GetResourceCountToGive Parms{};

	Parms.Interacter = Interacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BasePickableActor.GetResourceTypeToGive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Interacter                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayResourcesType                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameplayResourcesType ABasePickableActor::GetResourceTypeToGive(class AActor* Interacter) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePickableActor", "GetResourceTypeToGive");

	Params::BasePickableActor_GetResourceTypeToGive Parms{};

	Parms.Interacter = Interacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BasePickableToolActor.OnRep_Collected
// (Final, Native, Protected)
// Parameters:
// bool                                    PreviousCollected                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABasePickableToolActor::OnRep_Collected(bool PreviousCollected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePickableToolActor", "OnRep_Collected");

	Params::BasePickableToolActor_OnRep_Collected Parms{};

	Parms.PreviousCollected = PreviousCollected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteracterComponent.BlockAllInteractableTypes
// (Native, Public, BlueprintCallable)
// Parameters:
// TArray<EInteractableType>               TypesToNotBlock                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AActor*                           Requester                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteracterComponent::BlockAllInteractableTypes(const TArray<EInteractableType>& TypesToNotBlock, class AActor* Requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "BlockAllInteractableTypes");

	Params::InteracterComponent_BlockAllInteractableTypes Parms{};

	Parms.TypesToNotBlock = std::move(TypesToNotBlock);
	Parms.Requester = Requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteracterComponent.BlockInteractableTypes
// (Native, Public, BlueprintCallable)
// Parameters:
// TArray<EInteractableType>               TypesToBlock                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AActor*                           Requester                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteracterComponent::BlockInteractableTypes(const TArray<EInteractableType>& TypesToBlock, class AActor* Requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "BlockInteractableTypes");

	Params::InteracterComponent_BlockInteractableTypes Parms{};

	Parms.TypesToBlock = std::move(TypesToBlock);
	Parms.Requester = Requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteracterComponent.EnableInteracter
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Requester                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteracterComponent::EnableInteracter(bool bEnable, class AActor* Requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "EnableInteracter");

	Params::InteracterComponent_EnableInteracter Parms{};

	Parms.bEnable = bEnable;
	Parms.Requester = Requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteracterComponent.ExternalServerCompleteInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractableComponent*           InteractableComp                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteracterComponent::ExternalServerCompleteInteraction(class UInteractableComponent* InteractableComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "ExternalServerCompleteInteraction");

	Params::InteracterComponent_ExternalServerCompleteInteraction Parms{};

	Parms.InteractableComp = InteractableComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteracterComponent.HandleBooleanPlayerSettingChange
// (Final, Native, Protected)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteracterComponent::HandleBooleanPlayerSettingChange(EPlayerSettingsType SettingType, bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "HandleBooleanPlayerSettingChange");

	Params::InteracterComponent_HandleBooleanPlayerSettingChange Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteracterComponent.HandleInteractCancelEvent
// (Final, Native, Protected)
// Parameters:
// class ADeceiveIncPlayerController*      Spy                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInteractCancelType                     InteractCancelType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteracterComponent::HandleInteractCancelEvent(class ADeceiveIncPlayerController* Spy, EInteractCancelType InteractCancelType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "HandleInteractCancelEvent");

	Params::InteracterComponent_HandleInteractCancelEvent Parms{};

	Parms.Spy = Spy;
	Parms.InteractCancelType = InteractCancelType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteracterComponent.ServerCancelInteraction
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class UInteractableComponent*           InteractableComp                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteracterComponent::ServerCancelInteraction(class UInteractableComponent* InteractableComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "ServerCancelInteraction");

	Params::InteracterComponent_ServerCancelInteraction Parms{};

	Parms.InteractableComp = InteractableComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteracterComponent.ServerCompleteInteraction
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class UInteractableComponent*           InteractableComp                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EConditionType                          ConditionType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteracterComponent::ServerCompleteInteraction(class UInteractableComponent* InteractableComp, EConditionType ConditionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "ServerCompleteInteraction");

	Params::InteracterComponent_ServerCompleteInteraction Parms{};

	Parms.InteractableComp = InteractableComp;
	Parms.ConditionType = ConditionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteracterComponent.ServerStartInteraction
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class UInteractableComponent*           InteractableComp                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteracterComponent::ServerStartInteraction(class UInteractableComponent* InteractableComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "ServerStartInteraction");

	Params::InteracterComponent_ServerStartInteraction Parms{};

	Parms.InteractableComp = InteractableComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteracterComponent.UnblockAllInteractableTypesForRequester
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Requester                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteracterComponent::UnblockAllInteractableTypesForRequester(class AActor* Requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "UnblockAllInteractableTypesForRequester");

	Params::InteracterComponent_UnblockAllInteractableTypesForRequester Parms{};

	Parms.Requester = Requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteracterComponent.UnblockInteractableTypesForRequester
// (Native, Public, BlueprintCallable)
// Parameters:
// TArray<EInteractableType>               TypesToUnblock                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AActor*                           Requester                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteracterComponent::UnblockInteractableTypesForRequester(const TArray<EInteractableType>& TypesToUnblock, class AActor* Requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "UnblockInteractableTypesForRequester");

	Params::InteracterComponent_UnblockInteractableTypesForRequester Parms{};

	Parms.TypesToUnblock = std::move(TypesToUnblock);
	Parms.Requester = Requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteracterComponent.GetCurrentInteractionDuration
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteracterComponent::GetCurrentInteractionDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "GetCurrentInteractionDuration");

	Params::InteracterComponent_GetCurrentInteractionDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteracterComponent.GetCustomInteractionDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteracterComponent::GetCustomInteractionDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "GetCustomInteractionDuration");

	Params::InteracterComponent_GetCustomInteractionDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteracterComponent.GetInRangeInteractableList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UInteractableComponent*>   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UInteractableComponent*> UInteracterComponent::GetInRangeInteractableList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "GetInRangeInteractableList");

	Params::InteracterComponent_GetInRangeInteractableList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteracterComponent.GetInteractableList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FInteractableState>       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<struct FInteractableState> UInteracterComponent::GetInteractableList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "GetInteractableList");

	Params::InteracterComponent_GetInteractableList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteracterComponent.GetInteractionDistance
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteracterComponent::GetInteractionDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "GetInteractionDistance");

	Params::InteracterComponent_GetInteractionDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteracterComponent.GetInteractionDuration
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractableComponent*           InteractableComp                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteracterComponent::GetInteractionDuration(class UInteractableComponent* InteractableComp) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "GetInteractionDuration");

	Params::InteracterComponent_GetInteractionDuration Parms{};

	Parms.InteractableComp = InteractableComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteracterComponent.GetInteractionDurationWithReduction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InteractableDuration                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowPowerupReduction                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteracterComponent::GetInteractionDurationWithReduction(float InteractableDuration, bool AllowPowerupReduction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "GetInteractionDurationWithReduction");

	Params::InteracterComponent_GetInteractionDurationWithReduction Parms{};

	Parms.InteractableDuration = InteractableDuration;
	Parms.AllowPowerupReduction = AllowPowerupReduction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteracterComponent.GetInteractionTimePercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteracterComponent::GetInteractionTimePercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "GetInteractionTimePercent");

	Params::InteracterComponent_GetInteractionTimePercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteracterComponent.GetSpyActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UInteracterComponent::GetSpyActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "GetSpyActor");

	Params::InteracterComponent_GetSpyActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteracterComponent.GetSpyOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UInteracterComponent::GetSpyOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "GetSpyOwner");

	Params::InteracterComponent_GetSpyOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteracterComponent.GetSpyOwnerPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADIPlayerState*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADIPlayerState* UInteracterComponent::GetSpyOwnerPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "GetSpyOwnerPlayerState");

	Params::InteracterComponent_GetSpyOwnerPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteracterComponent.IsBot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteracterComponent::IsBot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "IsBot");

	Params::InteracterComponent_IsBot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteracterComponent.IsInteracting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteracterComponent::IsInteracting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "IsInteracting");

	Params::InteracterComponent_IsInteracting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteracterComponent.IsInteractTypeBlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractableComponent*           InteractableComp                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteracterComponent::IsInteractTypeBlocked(class UInteractableComponent* InteractableComp) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "IsInteractTypeBlocked");

	Params::InteracterComponent_IsInteractTypeBlocked Parms{};

	Parms.InteractableComp = InteractableComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteracterComponent.IsLocalInteracter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteracterComponent::IsLocalInteracter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "IsLocalInteracter");

	Params::InteracterComponent_IsLocalInteracter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteracterComponent.IsValidInteractCancelType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInteractCancelType                     InteractCancelType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteracterComponent::IsValidInteractCancelType(EInteractCancelType InteractCancelType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "IsValidInteractCancelType");

	Params::InteracterComponent_IsValidInteractCancelType Parms{};

	Parms.InteractCancelType = InteractCancelType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteracterComponent.IsValidInteractType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractableComponent*           InteractableComp                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheckIfBlocked                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteracterComponent::IsValidInteractType(class UInteractableComponent* InteractableComp, bool bCheckIfBlocked) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteracterComponent", "IsValidInteractType");

	Params::InteracterComponent_IsValidInteractType Parms{};

	Parms.InteractableComp = InteractableComp;
	Parms.bCheckIfBlocked = bCheckIfBlocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.RangeInteracterComponent.HandleComponentBeginOverlap
// (Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URangeInteracterComponent::HandleComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangeInteracterComponent", "HandleComponentBeginOverlap");

	Params::RangeInteracterComponent_HandleComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.RangeInteracterComponent.HandleComponentEndOverlap
// (Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URangeInteracterComponent::HandleComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangeInteracterComponent", "HandleComponentEndOverlap");

	Params::RangeInteracterComponent_HandleComponentEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BasePlaceableSpyTool.Client_OnDeployedToolDestroyed
// (Net, Native, Event, Protected, NetClient)
// Parameters:
// bool                                    bRecycled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABasePlaceableSpyTool::Client_OnDeployedToolDestroyed(bool bRecycled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePlaceableSpyTool", "Client_OnDeployedToolDestroyed");

	Params::BasePlaceableSpyTool_Client_OnDeployedToolDestroyed Parms{};

	Parms.bRecycled = bRecycled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BasePlaceableSpyTool.GetPlaceableActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class ABasePlaceable*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ABasePlaceable*> ABasePlaceableSpyTool::GetPlaceableActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePlaceableSpyTool", "GetPlaceableActor");

	Params::BasePlaceableSpyTool_GetPlaceableActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BasePlaceableSpyTool.HandleChargeAmountChange
// (Native, Protected)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABasePlaceableSpyTool::HandleChargeAmountChange(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePlaceableSpyTool", "HandleChargeAmountChange");

	Params::BasePlaceableSpyTool_HandleChargeAmountChange Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BasePlaceableSpyTool.HandleIsEnableChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bIsEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABasePlaceableSpyTool::HandleIsEnableChanged(bool bIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePlaceableSpyTool", "HandleIsEnableChanged");

	Params::BasePlaceableSpyTool_HandleIsEnableChanged Parms{};

	Parms.bIsEnabled = bIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BasePlaceableSpyTool.OnCooldownChange
// (Native, Protected)
// Parameters:
// bool                                    bOnCooldown                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABasePlaceableSpyTool::OnCooldownChange(bool bOnCooldown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePlaceableSpyTool", "OnCooldownChange");

	Params::BasePlaceableSpyTool_OnCooldownChange Parms{};

	Parms.bOnCooldown = bOnCooldown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BasePlaceableSpyTool.OnPlaceableActorDestroyed
// (Native, Protected)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABasePlaceableSpyTool::OnPlaceableActorDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePlaceableSpyTool", "OnPlaceableActorDestroyed");

	Params::BasePlaceableSpyTool_OnPlaceableActorDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BasePlaceableSpyTool.OnPlaceableSpawned
// (Native, Protected)
// Parameters:
// class ABasePlaceable*                   NewPlaceable                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABasePlaceableSpyTool::OnPlaceableSpawned(class ABasePlaceable* NewPlaceable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePlaceableSpyTool", "OnPlaceableSpawned");

	Params::BasePlaceableSpyTool_OnPlaceableSpawned Parms{};

	Parms.NewPlaceable = NewPlaceable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BasePlaceableSpyTool.OnRecycleTimerEnd
// (Native, Protected)

void ABasePlaceableSpyTool::OnRecycleTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePlaceableSpyTool", "OnRecycleTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BasePlaceableSpyTool.OnRep_NewPlaceableAssetsId
// (Native, Protected)

void ABasePlaceableSpyTool::OnRep_NewPlaceableAssetsId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePlaceableSpyTool", "OnRep_NewPlaceableAssetsId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BasePlaceableSpyTool.OnThrowDelayTimerEnd
// (Native, Protected)

void ABasePlaceableSpyTool::OnThrowDelayTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePlaceableSpyTool", "OnThrowDelayTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BasePlaceableSpyTool.OnThrowTimerEnd
// (Native, Protected)

void ABasePlaceableSpyTool::OnThrowTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePlaceableSpyTool", "OnThrowTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BasePlaceableSpyTool.Server_OnRecycleTimerEnd
// (Net, NetReliable, Native, Event, Protected, NetServer)

void ABasePlaceableSpyTool::Server_OnRecycleTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePlaceableSpyTool", "Server_OnRecycleTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BasePlaceableSpyTool.IsToolOrPlaceableEnable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABasePlaceableSpyTool::IsToolOrPlaceableEnable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePlaceableSpyTool", "IsToolOrPlaceableEnable");

	Params::BasePlaceableSpyTool_IsToolOrPlaceableEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SquirePassiveAbilityMod1.HandlePingDurationCooldownChange
// (Final, Native, Protected)
// Parameters:
// bool                                    OnCooldown                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASquirePassiveAbilityMod1::HandlePingDurationCooldownChange(bool OnCooldown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquirePassiveAbilityMod1", "HandlePingDurationCooldownChange");

	Params::SquirePassiveAbilityMod1_HandlePingDurationCooldownChange Parms{};

	Parms.OnCooldown = OnCooldown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SquirePassiveAbilityMod1.HandleUnderCoverChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bUndercover                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASquirePassiveAbilityMod1::HandleUnderCoverChanged(bool bUndercover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquirePassiveAbilityMod1", "HandleUnderCoverChanged");

	Params::SquirePassiveAbilityMod1_HandleUnderCoverChanged Parms{};

	Parms.bUndercover = bUndercover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BasePositionerComponent.BP_OnPositioningActorSpawned
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           ActorSpawned                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBasePositionerComponent::BP_OnPositioningActorSpawned(class AActor* ActorSpawned)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePositionerComponent", "BP_OnPositioningActorSpawned");

	Params::BasePositionerComponent_BP_OnPositioningActorSpawned Parms{};

	Parms.ActorSpawned = ActorSpawned;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BasePositionerComponent.IsPositioningActorVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBasePositionerComponent::IsPositioningActorVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePositionerComponent", "IsPositioningActorVisible");

	Params::BasePositionerComponent_IsPositioningActorVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BasePowerupChestActor.BP_OnChestOpen
// (Event, Protected, BlueprintEvent)

void ABasePowerupChestActor::BP_OnChestOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePowerupChestActor", "BP_OnChestOpen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.BasePowerupChestActor.HandleResourceSpent
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABasePowerupChestActor::HandleResourceSpent(class UInteracterComponent* Interacter, EGameplayResourcesType ResourceType, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePowerupChestActor", "HandleResourceSpent");

	Params::BasePowerupChestActor_HandleResourceSpent Parms{};

	Parms.Interacter = Interacter;
	Parms.ResourceType = ResourceType;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BasePowerupChestActor.HandleSpawnSetupedComplete
// (Final, Native, Protected)

void ABasePowerupChestActor::HandleSpawnSetupedComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePowerupChestActor", "HandleSpawnSetupedComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BasePowerupChestActor.OnRep_OpenChest
// (Final, Native, Protected)

void ABasePowerupChestActor::OnRep_OpenChest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePowerupChestActor", "OnRep_OpenChest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseScannerTool.Server_CompleteScan
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class UScannableComponent*              Scannable                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseScannerTool::Server_CompleteScan(class UScannableComponent* Scannable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseScannerTool", "Server_CompleteScan");

	Params::BaseScannerTool_Server_CompleteScan Parms{};

	Parms.Scannable = Scannable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BaseScannerTool.GetScanDistance
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ABaseScannerTool::GetScanDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseScannerTool", "GetScanDistance");

	Params::BaseScannerTool_GetScanDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BaseScannerTool.GetScanDuration
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ABaseScannerTool::GetScanDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseScannerTool", "GetScanDuration");

	Params::BaseScannerTool_GetScanDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiCharacterSelectCheckBox.GetAgentAvailabilityState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECharacterSelectAgentAvailability       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECharacterSelectAgentAvailability UDiCharacterSelectCheckBox::GetAgentAvailabilityState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiCharacterSelectCheckBox", "GetAgentAvailabilityState");

	Params::DiCharacterSelectCheckBox_GetAgentAvailabilityState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiCharacterSelectCheckBox.SetAgentData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAgentData*                       InAgentData                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiCharacterSelectCheckBox::SetAgentData(class UAgentData* InAgentData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiCharacterSelectCheckBox", "SetAgentData");

	Params::DiCharacterSelectCheckBox_SetAgentData Parms{};

	Parms.InAgentData = InAgentData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiCharacterSelectCheckBox.GetAgentData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAgentData*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAgentData* UDiCharacterSelectCheckBox::GetAgentData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiCharacterSelectCheckBox", "GetAgentData");

	Params::DiCharacterSelectCheckBox_GetAgentData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.CHEATGetHideFriendlyGadgetOverlay
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetBPLibrary::CHEATGetHideFriendlyGadgetOverlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "CHEATGetHideFriendlyGadgetOverlay");

	Params::SweetBPLibrary_CHEATGetHideFriendlyGadgetOverlay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.DisableParticleSystemNom
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFXSystemComponent*               ParticleSystem                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetBPLibrary::DisableParticleSystemNom(class UFXSystemComponent* ParticleSystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "DisableParticleSystemNom");

	Params::SweetBPLibrary_DisableParticleSystemNom Parms{};

	Parms.ParticleSystem = ParticleSystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetBPLibrary.EnableDrawActorMeshCollisions
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableDraw                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetBPLibrary::EnableDrawActorMeshCollisions(class AActor* TargetActor, bool bEnableDraw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "EnableDrawActorMeshCollisions");

	Params::SweetBPLibrary_EnableDrawActorMeshCollisions Parms{};

	Parms.TargetActor = TargetActor;
	Parms.bEnableDraw = bEnableDraw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetBPLibrary.EnumToIETFTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELocalizationLanguage                   LocEnum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USweetBPLibrary::EnumToIETFTag(ELocalizationLanguage LocEnum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "EnumToIETFTag");

	Params::SweetBPLibrary_EnumToIETFTag Parms{};

	Parms.LocEnum = LocEnum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.GetCurrentMapData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMapData*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMapData* USweetBPLibrary::GetCurrentMapData(class UObject* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "GetCurrentMapData");

	Params::SweetBPLibrary_GetCurrentMapData Parms{};

	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.GetCurrentMapName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USweetBPLibrary::GetCurrentMapName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "GetCurrentMapName");

	Params::SweetBPLibrary_GetCurrentMapName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.GetCustomGamesAvailableMaps
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class UMapData*>                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UMapData*> USweetBPLibrary::GetCustomGamesAvailableMaps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "GetCustomGamesAvailableMaps");

	Params::SweetBPLibrary_GetCustomGamesAvailableMaps Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.GetDeceiveIncGameState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ContextActor                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGameStateBase*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGameStateBase* USweetBPLibrary::GetDeceiveIncGameState(const class AActor* ContextActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "GetDeceiveIncGameState");

	Params::SweetBPLibrary_GetDeceiveIncGameState Parms{};

	Parms.ContextActor = ContextActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.GetDIPlayerControllerFromState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADIPlayerState*                   PlayerState                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADeceiveIncPlayerController*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADeceiveIncPlayerController* USweetBPLibrary::GetDIPlayerControllerFromState(const class ADIPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "GetDIPlayerControllerFromState");

	Params::SweetBPLibrary_GetDIPlayerControllerFromState Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.GetEditorDecryptedGUID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           GuidToDecrypt                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USweetBPLibrary::GetEditorDecryptedGUID(const class FString& GuidToDecrypt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "GetEditorDecryptedGUID");

	Params::SweetBPLibrary_GetEditorDecryptedGUID Parms{};

	Parms.GuidToDecrypt = std::move(GuidToDecrypt);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.GetEditorEncryptedGUID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           GuidToEncrypt                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USweetBPLibrary::GetEditorEncryptedGUID(const class FString& GuidToEncrypt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "GetEditorEncryptedGUID");

	Params::SweetBPLibrary_GetEditorEncryptedGUID Parms{};

	Parms.GuidToEncrypt = std::move(GuidToEncrypt);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.GetFirstLocalDIPlayerController
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADeceiveIncPlayerController*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADeceiveIncPlayerController* USweetBPLibrary::GetFirstLocalDIPlayerController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "GetFirstLocalDIPlayerController");

	Params::SweetBPLibrary_GetFirstLocalDIPlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.GetKeysForAction
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UInputAction*                     Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AxisScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FKey>                     Bindings                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// EInputDeviceType                        DeviceType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetBPLibrary::GetKeysForAction(class UInputAction* Action, float AxisScale, TArray<struct FKey>* Bindings, EInputDeviceType DeviceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "GetKeysForAction");

	Params::SweetBPLibrary_GetKeysForAction Parms{};

	Parms.Action = Action;
	Parms.AxisScale = AxisScale;
	Parms.DeviceType = DeviceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Bindings != nullptr)
		*Bindings = std::move(Parms.Bindings);
}


// Function DeceiveInc.SweetBPLibrary.GetKeysForActionName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AxisScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FKey>                     Bindings                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// EInputDeviceType                        DeviceType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetBPLibrary::GetKeysForActionName(class FName ActionName, float AxisScale, TArray<struct FKey>* Bindings, EInputDeviceType DeviceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "GetKeysForActionName");

	Params::SweetBPLibrary_GetKeysForActionName Parms{};

	Parms.ActionName = ActionName;
	Parms.AxisScale = AxisScale;
	Parms.DeviceType = DeviceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Bindings != nullptr)
		*Bindings = std::move(Parms.Bindings);
}


// Function DeceiveInc.SweetBPLibrary.GetLastUsedInputDeviceType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EInputDeviceType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInputDeviceType USweetBPLibrary::GetLastUsedInputDeviceType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "GetLastUsedInputDeviceType");

	Params::SweetBPLibrary_GetLastUsedInputDeviceType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.GetLocalDIPlayerController
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADeceiveIncPlayerController*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADeceiveIncPlayerController* USweetBPLibrary::GetLocalDIPlayerController(class UObject* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "GetLocalDIPlayerController");

	Params::SweetBPLibrary_GetLocalDIPlayerController Parms{};

	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.GetLocalisedValueInEnumMap
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<ELocalizationLanguage, class FText>LocalisedMap                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText USweetBPLibrary::GetLocalisedValueInEnumMap(const TMap<ELocalizationLanguage, class FText>& LocalisedMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "GetLocalisedValueInEnumMap");

	Params::SweetBPLibrary_GetLocalisedValueInEnumMap Parms{};

	Parms.LocalisedMap = std::move(LocalisedMap);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.GetLocalisedValueInMap
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<class FString, class FString>      LocalisedMap                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText USweetBPLibrary::GetLocalisedValueInMap(const TMap<class FString, class FString>& LocalisedMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "GetLocalisedValueInMap");

	Params::SweetBPLibrary_GetLocalisedValueInMap Parms{};

	Parms.LocalisedMap = std::move(LocalisedMap);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.GetNameOfKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FKey                             TheKey                                                 (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USweetBPLibrary::GetNameOfKey(const struct FKey& TheKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "GetNameOfKey");

	Params::SweetBPLibrary_GetNameOfKey Parms{};

	Parms.TheKey = std::move(TheKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.GetRandomlyGeneratedUserName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USweetBPLibrary::GetRandomlyGeneratedUserName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "GetRandomlyGeneratedUserName");

	Params::SweetBPLibrary_GetRandomlyGeneratedUserName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.GetUtcNowInSeconds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 USweetBPLibrary::GetUtcNowInSeconds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "GetUtcNowInSeconds");

	Params::SweetBPLibrary_GetUtcNowInSeconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.GoToMainMenu
// (Final, Native, Static, Public, BlueprintCallable)

void USweetBPLibrary::GoToMainMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "GoToMainMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetBPLibrary.IETFTagToEnum
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           IETFTag                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELocalizationLanguage                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELocalizationLanguage USweetBPLibrary::IETFTagToEnum(const class FString& IETFTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "IETFTagToEnum");

	Params::SweetBPLibrary_IETFTagToEnum Parms{};

	Parms.IETFTag = std::move(IETFTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.IsAllowingCheats
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetBPLibrary::IsAllowingCheats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "IsAllowingCheats");

	Params::SweetBPLibrary_IsAllowingCheats Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.IsBodyHit
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// EHitType                                HitType                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetBPLibrary::IsBodyHit(const EHitType& HitType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "IsBodyHit");

	Params::SweetBPLibrary_IsBodyHit Parms{};

	Parms.HitType = HitType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.IsConsoleBuild
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetBPLibrary::IsConsoleBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "IsConsoleBuild");

	Params::SweetBPLibrary_IsConsoleBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.IsCriticalHit
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// EHitType                                HitType                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetBPLibrary::IsCriticalHit(const EHitType& HitType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "IsCriticalHit");

	Params::SweetBPLibrary_IsCriticalHit Parms{};

	Parms.HitType = HitType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.IsDebugBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetBPLibrary::IsDebugBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "IsDebugBuild");

	Params::SweetBPLibrary_IsDebugBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.IsEditorBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetBPLibrary::IsEditorBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "IsEditorBuild");

	Params::SweetBPLibrary_IsEditorBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.IsInKillcamReplay
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetBPLibrary::IsInKillcamReplay(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "IsInKillcamReplay");

	Params::SweetBPLibrary_IsInKillcamReplay Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.IsInMainMenuLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetBPLibrary::IsInMainMenuLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "IsInMainMenuLevel");

	Params::SweetBPLibrary_IsInMainMenuLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.IsLimbHit
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// EHitType                                HitType                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetBPLibrary::IsLimbHit(const EHitType& HitType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "IsLimbHit");

	Params::SweetBPLibrary_IsLimbHit Parms{};

	Parms.HitType = HitType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.IsLockheartConsole
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetBPLibrary::IsLockheartConsole()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "IsLockheartConsole");

	Params::SweetBPLibrary_IsLockheartConsole Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.IsMapDisabledForPrivateLobby
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           MapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetBPLibrary::IsMapDisabledForPrivateLobby(const class FString& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "IsMapDisabledForPrivateLobby");

	Params::SweetBPLibrary_IsMapDisabledForPrivateLobby Parms{};

	Parms.MapName = std::move(MapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.IsOfflineBuild
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetBPLibrary::IsOfflineBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "IsOfflineBuild");

	Params::SweetBPLibrary_IsOfflineBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.IsShippingBuild
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetBPLibrary::IsShippingBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "IsShippingBuild");

	Params::SweetBPLibrary_IsShippingBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.MinimizeWindow
// (Final, Native, Static, Public, BlueprintCallable)

void USweetBPLibrary::MinimizeWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "MinimizeWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetBPLibrary.SB_ApplyZoomFactorToFOV
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   BaseFOV                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ZoomFactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USweetBPLibrary::SB_ApplyZoomFactorToFOV(float BaseFOV, float ZoomFactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "SB_ApplyZoomFactorToFOV");

	Params::SweetBPLibrary_SB_ApplyZoomFactorToFOV Parms{};

	Parms.BaseFOV = BaseFOV;
	Parms.ZoomFactor = ZoomFactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.SB_AttachActorBoneToBone
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  ToAttach                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ToAttachActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Socket                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Parent                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParentSocket                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         ScaleRule                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWeldSimulatedBodies                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetBPLibrary::SB_AttachActorBoneToBone(class USceneComponent* ToAttach, class AActor* ToAttachActor, class FName Socket, class USceneComponent* Parent, class FName ParentSocket, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "SB_AttachActorBoneToBone");

	Params::SweetBPLibrary_SB_AttachActorBoneToBone Parms{};

	Parms.ToAttach = ToAttach;
	Parms.ToAttachActor = ToAttachActor;
	Parms.Socket = Socket;
	Parms.Parent = Parent;
	Parms.ParentSocket = ParentSocket;
	Parms.ScaleRule = ScaleRule;
	Parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetBPLibrary.SB_AttachToActorValidateSocket
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ToAttach                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ParentActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         LocationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         RotationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         ScaleRule                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWeldSimulatedBodies                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetBPLibrary::SB_AttachToActorValidateSocket(class AActor* ToAttach, class AActor* ParentActor, class FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "SB_AttachToActorValidateSocket");

	Params::SweetBPLibrary_SB_AttachToActorValidateSocket Parms{};

	Parms.ToAttach = ToAttach;
	Parms.ParentActor = ParentActor;
	Parms.SocketName = SocketName;
	Parms.LocationRule = LocationRule;
	Parms.RotationRule = RotationRule;
	Parms.ScaleRule = ScaleRule;
	Parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetBPLibrary.SB_FindScreenEdgeLocationForWorldLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                InPlayerController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EdgePercent                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ViewportCenterLoc                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        OutScreenPosition                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutRotationAngleDegrees                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsOnScreen                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetBPLibrary::SB_FindScreenEdgeLocationForWorldLocation(class UObject* WorldContextObject, const struct FVector& InLocation, class APlayerController* InPlayerController, const float EdgePercent, const struct FVector2D& ViewportCenterLoc, struct FVector2D* OutScreenPosition, float* OutRotationAngleDegrees, bool* bIsOnScreen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "SB_FindScreenEdgeLocationForWorldLocation");

	Params::SweetBPLibrary_SB_FindScreenEdgeLocationForWorldLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InLocation = std::move(InLocation);
	Parms.InPlayerController = InPlayerController;
	Parms.EdgePercent = EdgePercent;
	Parms.ViewportCenterLoc = std::move(ViewportCenterLoc);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutScreenPosition != nullptr)
		*OutScreenPosition = std::move(Parms.OutScreenPosition);

	if (OutRotationAngleDegrees != nullptr)
		*OutRotationAngleDegrees = Parms.OutRotationAngleDegrees;

	if (bIsOnScreen != nullptr)
		*bIsOnScreen = Parms.bIsOnScreen;
}


// Function DeceiveInc.SweetBPLibrary.SB_IsInPregame
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetBPLibrary::SB_IsInPregame(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "SB_IsInPregame");

	Params::SweetBPLibrary_SB_IsInPregame Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetBPLibrary.SB_SpawnProjectilesInSpray
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       ProjectileTransform                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           OwnerActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SpawnerWeapon                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ProjectileClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWeaponSprayDataAsset*            SprayData                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SprayPlaneDepth                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SprayPlaneWidth                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SprayPlaneHeight                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsSimulated                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetBPLibrary::SB_SpawnProjectilesInSpray(const struct FTransform& ProjectileTransform, class AActor* OwnerActor, class AActor* SpawnerWeapon, class UClass* ProjectileClass, class UWeaponSprayDataAsset* SprayData, float SprayPlaneDepth, float SprayPlaneWidth, float SprayPlaneHeight, bool bIsSimulated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "SB_SpawnProjectilesInSpray");

	Params::SweetBPLibrary_SB_SpawnProjectilesInSpray Parms{};

	Parms.ProjectileTransform = std::move(ProjectileTransform);
	Parms.OwnerActor = OwnerActor;
	Parms.SpawnerWeapon = SpawnerWeapon;
	Parms.ProjectileClass = ProjectileClass;
	Parms.SprayData = SprayData;
	Parms.SprayPlaneDepth = SprayPlaneDepth;
	Parms.SprayPlaneWidth = SprayPlaneWidth;
	Parms.SprayPlaneHeight = SprayPlaneHeight;
	Parms.bIsSimulated = bIsSimulated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetBPLibrary.SBDevPrint
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetBPLibrary::SBDevPrint(const class FString& InString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "SBDevPrint");

	Params::SweetBPLibrary_SBDevPrint Parms{};

	Parms.InString = std::move(InString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetBPLibrary.SBPerfBookmark
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetBPLibrary::SBPerfBookmark(const class FString& InString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "SBPerfBookmark");

	Params::SweetBPLibrary_SBPerfBookmark Parms{};

	Parms.InString = std::move(InString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetBPLibrary.SetMontageDefaultLength
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetBPLibrary::SetMontageDefaultLength(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "SetMontageDefaultLength");

	Params::SweetBPLibrary_SetMontageDefaultLength Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetBPLibrary.SetupPostProcessSystem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPostProcessComponent*            PPComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetBPLibrary::SetupPostProcessSystem(class UPostProcessComponent* PPComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetBPLibrary", "SetupPostProcessSystem");

	Params::SweetBPLibrary_SetupPostProcessSystem Parms{};

	Parms.PPComponent = PPComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncMenuGameModeBase.HostCustomMatch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           LevelToPlay                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncMenuGameModeBase::HostCustomMatch(const class FString& LevelToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMenuGameModeBase", "HostCustomMatch");

	Params::DeceiveIncMenuGameModeBase_HostCustomMatch Parms{};

	Parms.LevelToPlay = std::move(LevelToPlay);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncMenuGameModeBase.JoinCustomMatch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           HostUrl                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncMenuGameModeBase::JoinCustomMatch(const class FString& HostUrl)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncMenuGameModeBase", "JoinCustomMatch");

	Params::DeceiveIncMenuGameModeBase_JoinCustomMatch Parms{};

	Parms.HostUrl = std::move(HostUrl);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BotActionChangeCover.OnLocaInteractionCompleted
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotActionChangeCover::OnLocaInteractionCompleted(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotActionChangeCover", "OnLocaInteractionCompleted");

	Params::BotActionChangeCover_OnLocaInteractionCompleted Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BotActionChangeCover.OnReceiveMoveCompleted
// (Final, Native, Protected)
// Parameters:
// struct FAIRequestID                     RequestId                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPathFollowingResult                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotActionChangeCover::OnReceiveMoveCompleted(const struct FAIRequestID& RequestId, EPathFollowingResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotActionChangeCover", "OnReceiveMoveCompleted");

	Params::BotActionChangeCover_OnReceiveMoveCompleted Parms{};

	Parms.RequestId = std::move(RequestId);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiAnimInstance.ApplyMotionSet
// (Native, Public, BlueprintCallable)
// Parameters:
// class UDiAnimationMotionSet*            MotionSet                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiAnimInstance::ApplyMotionSet(const class UDiAnimationMotionSet* MotionSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiAnimInstance", "ApplyMotionSet");

	Params::DiAnimInstance_ApplyMotionSet Parms{};

	Parms.MotionSet = MotionSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiAnimInstance.BP_OnApplyMotionSet
// (Event, Public, BlueprintEvent)
// Parameters:
// class UDiAnimationMotionSet*            MotionSet                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiAnimInstance::BP_OnApplyMotionSet(const class UDiAnimationMotionSet* MotionSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiAnimInstance", "BP_OnApplyMotionSet");

	Params::DiAnimInstance_BP_OnApplyMotionSet Parms{};

	Parms.MotionSet = MotionSet;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.DiAnimInstance.GetAnimMotionBlendspace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             MotionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBlendSpaceBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlendSpaceBase* UDiAnimInstance::GetAnimMotionBlendspace(class FName MotionName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiAnimInstance", "GetAnimMotionBlendspace");

	Params::DiAnimInstance_GetAnimMotionBlendspace Parms{};

	Parms.MotionName = MotionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiAnimInstance.GetAnimMotionSequence
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             MotionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequence* UDiAnimInstance::GetAnimMotionSequence(class FName MotionName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiAnimInstance", "GetAnimMotionSequence");

	Params::DiAnimInstance_GetAnimMotionSequence Parms{};

	Parms.MotionName = MotionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiAnimInstance.HasAnimMotion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             MotionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiAnimInstance::HasAnimMotion(class FName MotionName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiAnimInstance", "HasAnimMotion");

	Params::DiAnimInstance_HasAnimMotion Parms{};

	Parms.MotionName = MotionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BotBrain.OnObjectivePing
// (Native, Protected)
// Parameters:
// class ASpy*                             PingingSpy                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotBrain::OnObjectivePing(class ASpy* PingingSpy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotBrain", "OnObjectivePing");

	Params::BotBrain_OnObjectivePing Parms{};

	Parms.PingingSpy = PingingSpy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.TargetPracticeDummy.HandleTakePointDamage
// (Final, Native, Protected, HasDefaults)
// Parameters:
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              FHitComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ShotFromDirection                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATargetPracticeDummy::HandleTakePointDamage(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& ShotFromDirection, const class UDamageType* DamageType, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetPracticeDummy", "HandleTakePointDamage");

	Params::TargetPracticeDummy_HandleTakePointDamage Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.Damage = Damage;
	Parms.InstigatedBy = InstigatedBy;
	Parms.HitLocation = std::move(HitLocation);
	Parms.FHitComponent = FHitComponent;
	Parms.BoneName = BoneName;
	Parms.ShotFromDirection = std::move(ShotFromDirection);
	Parms.DamageType = DamageType;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.TargetPracticeDummy.MulticastTakeDamage
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATargetPracticeDummy::MulticastTakeDamage(float Damage, const struct FVector& HitLocation, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetPracticeDummy", "MulticastTakeDamage");

	Params::TargetPracticeDummy_MulticastTakeDamage Parms{};

	Parms.Damage = Damage;
	Parms.HitLocation = std::move(HitLocation);
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CavalierePassiveAbilityMod1.HandleMeleeAttackDamageDoneServer
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactPoint                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ChargeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageDone                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ResultingHealthPercentage                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHitType                                HitType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMeleeHitConfirmedData           HitConfirmedData                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACavalierePassiveAbilityMod1::HandleMeleeAttackDamageDoneServer(class AActor* Victim, const struct FVector& ImpactPoint, int32 ChargeLevel, float DamageDone, float ResultingHealthPercentage, EHitType HitType, const struct FMeleeHitConfirmedData& HitConfirmedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavalierePassiveAbilityMod1", "HandleMeleeAttackDamageDoneServer");

	Params::CavalierePassiveAbilityMod1_HandleMeleeAttackDamageDoneServer Parms{};

	Parms.Victim = Victim;
	Parms.ImpactPoint = std::move(ImpactPoint);
	Parms.ChargeLevel = ChargeLevel;
	Parms.DamageDone = DamageDone;
	Parms.ResultingHealthPercentage = ResultingHealthPercentage;
	Parms.HitType = HitType;
	Parms.HitConfirmedData = std::move(HitConfirmedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CavalierePassiveAbilityMod1.HandleMeleeAttackLoadComplete
// (Final, Native, Protected)
// Parameters:
// class UToolLoadoutComponent*            LoadoutComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACavalierePassiveAbilityMod1::HandleMeleeAttackLoadComplete(class UToolLoadoutComponent* LoadoutComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavalierePassiveAbilityMod1", "HandleMeleeAttackLoadComplete");

	Params::CavalierePassiveAbilityMod1_HandleMeleeAttackLoadComplete Parms{};

	Parms.LoadoutComponent = LoadoutComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CavalierePassiveAbilityMod1.NetMulticast_OnFillUpMagazine
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AProjectileWeapon*                Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACavalierePassiveAbilityMod1::NetMulticast_OnFillUpMagazine(class AProjectileWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavalierePassiveAbilityMod1", "NetMulticast_OnFillUpMagazine");

	Params::CavalierePassiveAbilityMod1_NetMulticast_OnFillUpMagazine Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.TrainingBotBrain.OnFightTargetLost
// (Final, Native, Protected)
// Parameters:
// class UBotPlanFight*                    BotPlanFight                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             LostTarget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTrainingBotBrain::OnFightTargetLost(class UBotPlanFight* BotPlanFight, class ASpy* LostTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrainingBotBrain", "OnFightTargetLost");

	Params::TrainingBotBrain_OnFightTargetLost Parms{};

	Parms.BotPlanFight = BotPlanFight;
	Parms.LostTarget = LostTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.TrainingBotBrain.OnUndercoverChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bUndercover                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTrainingBotBrain::OnUndercoverChange(bool bUndercover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrainingBotBrain", "OnUndercoverChange");

	Params::TrainingBotBrain_OnUndercoverChange Parms{};

	Parms.bUndercover = bUndercover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIAnimationBlueprintLibrary.GetAnimationNotifyTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NotifyName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnAnimationDurationOnNotifyNotFound                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDIAnimationBlueprintLibrary::GetAnimationNotifyTime(const class UAnimSequence* AnimationSequence, class FName NotifyName, bool ReturnAnimationDurationOnNotifyNotFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIAnimationBlueprintLibrary", "GetAnimationNotifyTime");

	Params::DIAnimationBlueprintLibrary_GetAnimationNotifyTime Parms{};

	Parms.AnimationSequence = AnimationSequence;
	Parms.NotifyName = NotifyName;
	Parms.ReturnAnimationDurationOnNotifyNotFound = ReturnAnimationDurationOnNotifyNotFound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.OutOfBoundsEntity.OnOutOfBoundsActorBeginOverlap
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InOutOfBoundsActor                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IOutOfBoundsEntity::OnOutOfBoundsActorBeginOverlap(class AActor* InOutOfBoundsActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OutOfBoundsEntity", "OnOutOfBoundsActorBeginOverlap");

	Params::OutOfBoundsEntity_OnOutOfBoundsActorBeginOverlap Parms{};

	Parms.InOutOfBoundsActor = InOutOfBoundsActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.OutOfBoundsEntity.OnOutOfBoundsActorEndOverlap
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InOutOfBoundsActor                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IOutOfBoundsEntity::OnOutOfBoundsActorEndOverlap(class AActor* InOutOfBoundsActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OutOfBoundsEntity", "OnOutOfBoundsActorEndOverlap");

	Params::OutOfBoundsEntity_OnOutOfBoundsActorEndOverlap Parms{};

	Parms.InOutOfBoundsActor = InOutOfBoundsActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.OctoBaseActiveAbility.BP_OnOctoEffectStart
// (Event, Protected, BlueprintEvent)

void AOctoBaseActiveAbility::BP_OnOctoEffectStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoBaseActiveAbility", "BP_OnOctoEffectStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.OctoBaseActiveAbility.BP_OnOctoEffectStartLocal
// (Event, Protected, BlueprintEvent)

void AOctoBaseActiveAbility::BP_OnOctoEffectStartLocal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoBaseActiveAbility", "BP_OnOctoEffectStartLocal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.OctoBaseActiveAbility.BP_OnTriggerLocalDetection
// (Event, Public, BlueprintEvent)

void AOctoBaseActiveAbility::BP_OnTriggerLocalDetection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoBaseActiveAbility", "BP_OnTriggerLocalDetection");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.OctoBaseActiveAbility.OnEffectDelayTimerEnd
// (Final, Native, Protected)

void AOctoBaseActiveAbility::OnEffectDelayTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoBaseActiveAbility", "OnEffectDelayTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.OctoActiveAbility.BP_OnActiveFeedbackEnd
// (Event, Public, BlueprintEvent)

void AOctoActiveAbility::BP_OnActiveFeedbackEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoActiveAbility", "BP_OnActiveFeedbackEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.OctoActiveAbility.BP_OnActiveFeedbackEndLocal
// (Event, Public, BlueprintEvent)

void AOctoActiveAbility::BP_OnActiveFeedbackEndLocal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoActiveAbility", "BP_OnActiveFeedbackEndLocal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.OctoActiveAbility.BP_OnHackableHacked
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           InteractableActor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInteractableType                       InteractableType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   StencilValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOctoActiveAbility::BP_OnHackableHacked(class AActor* InteractableActor, EInteractableType InteractableType, uint8 StencilValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoActiveAbility", "BP_OnHackableHacked");

	Params::OctoActiveAbility_BP_OnHackableHacked Parms{};

	Parms.InteractableActor = InteractableActor;
	Parms.InteractableType = InteractableType;
	Parms.StencilValue = StencilValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.OctoActiveAbility.BP_OnHackableRebooted
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           InteractableActor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInteractableType                       InteractableType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   StencilValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOctoActiveAbility::BP_OnHackableRebooted(class AActor* InteractableActor, EInteractableType InteractableType, uint8 StencilValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoActiveAbility", "BP_OnHackableRebooted");

	Params::OctoActiveAbility_BP_OnHackableRebooted Parms{};

	Parms.InteractableActor = InteractableActor;
	Parms.InteractableType = InteractableType;
	Parms.StencilValue = StencilValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.OctoActiveAbility.MulticastActiveResult
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FOctoActiveAbilityResultReplicationInteractableComp                                       (Parm, NativeAccessSpecifierPublic)

void AOctoActiveAbility::MulticastActiveResult(const struct FOctoActiveAbilityResultReplication& InteractableComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoActiveAbility", "MulticastActiveResult");

	Params::OctoActiveAbility_MulticastActiveResult Parms{};

	Parms.InteractableComp = std::move(InteractableComp);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.OctoActiveAbility.OnActiveFeedbackEndTimerEnd
// (Final, Native, Protected)

void AOctoActiveAbility::OnActiveFeedbackEndTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoActiveAbility", "OnActiveFeedbackEndTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.OctoActiveAbility.ServerActiveResult
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// struct FOctoActiveAbilityResultReplicationInteractableComp                                       (Parm, NativeAccessSpecifierPublic)

void AOctoActiveAbility::ServerActiveResult(const struct FOctoActiveAbilityResultReplication& InteractableComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoActiveAbility", "ServerActiveResult");

	Params::OctoActiveAbility_ServerActiveResult Parms{};

	Parms.InteractableComp = std::move(InteractableComp);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BotPlanFight.OnInstantLoseAggroFromBots
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotPlanFight::OnInstantLoseAggroFromBots(class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotPlanFight", "OnInstantLoseAggroFromBots");

	Params::BotPlanFight_OnInstantLoseAggroFromBots Parms{};

	Parms.Spy = Spy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BotPlanFight.OnMoveActionEnd
// (Final, Native, Protected)
// Parameters:
// class UBotAction*                       ActionEnding                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBotActionResult                        ActionResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotPlanFight::OnMoveActionEnd(class UBotAction* ActionEnding, EBotActionResult ActionResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotPlanFight", "OnMoveActionEnd");

	Params::BotPlanFight_OnMoveActionEnd Parms{};

	Parms.ActionEnding = ActionEnding;
	Parms.ActionResult = ActionResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.OctoPassiveAbilityLuckBased.BP_LuckEventResult
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   IntelChangeAmount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSucesssful                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOctoPassiveAbilityLuckBased::BP_LuckEventResult(int32 IntelChangeAmount, bool bSucesssful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoPassiveAbilityLuckBased", "BP_LuckEventResult");

	Params::OctoPassiveAbilityLuckBased_BP_LuckEventResult Parms{};

	Parms.IntelChangeAmount = IntelChangeAmount;
	Parms.bSucesssful = bSucesssful;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.OctoPassiveAbilityLuckBased.BP_StartLuckEvent
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   IntelChangeAmount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOctoPassiveAbilityLuckBased::BP_StartLuckEvent(int32 IntelChangeAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoPassiveAbilityLuckBased", "BP_StartLuckEvent");

	Params::OctoPassiveAbilityLuckBased_BP_StartLuckEvent Parms{};

	Parms.IntelChangeAmount = IntelChangeAmount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.OctoPassiveAbilityLuckBased.BP_StopLuckEvent
// (Event, Protected, BlueprintEvent)

void AOctoPassiveAbilityLuckBased::BP_StopLuckEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoPassiveAbilityLuckBased", "BP_StopLuckEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.OctoPassiveAbilityLuckBased.NetMulticast_OctoLuckEventResult
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// bool                                    bSuccessful                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AmountIn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOctoPassiveAbilityLuckBased::NetMulticast_OctoLuckEventResult(bool bSuccessful, int32 AmountIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoPassiveAbilityLuckBased", "NetMulticast_OctoLuckEventResult");

	Params::OctoPassiveAbilityLuckBased_NetMulticast_OctoLuckEventResult Parms{};

	Parms.bSuccessful = bSuccessful;
	Parms.AmountIn = AmountIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.OctoPassiveAbilityLuckBased.OnLuckEventConfirmationTimerEnd
// (Final, Native, Protected)

void AOctoPassiveAbilityLuckBased::OnLuckEventConfirmationTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoPassiveAbilityLuckBased", "OnLuckEventConfirmationTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.OctoPassiveAbilityLuckBased.OnLuckEventInProgressTimerEnd
// (Final, Native, Protected)

void AOctoPassiveAbilityLuckBased::OnLuckEventInProgressTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoPassiveAbilityLuckBased", "OnLuckEventInProgressTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.OctoPassiveAbilityLuckBased.OnLuckEventStopTimerEnd
// (Final, Native, Protected)

void AOctoPassiveAbilityLuckBased::OnLuckEventStopTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoPassiveAbilityLuckBased", "OnLuckEventStopTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.OctoPassiveAbilityLuckBased.OnResourceChange
// (Final, Native, Protected)
// Parameters:
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ResourceDisplayName                                    (Parm, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOctoPassiveAbilityLuckBased::OnResourceChange(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoPassiveAbilityLuckBased", "OnResourceChange");

	Params::OctoPassiveAbilityLuckBased_OnResourceChange Parms{};

	Parms.ResourceType = ResourceType;
	Parms.ResourceDisplayName = std::move(ResourceDisplayName);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BotPlanProgressFlow.OnCurrentGoalChanged
// (Final, Native, Protected)
// Parameters:
// class UBotObjective*                    PrevGoal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBotObjective*                    NewGoal                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotPlanProgressFlow::OnCurrentGoalChanged(class UBotObjective* PrevGoal, class UBotObjective* NewGoal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotPlanProgressFlow", "OnCurrentGoalChanged");

	Params::BotPlanProgressFlow_OnCurrentGoalChanged Parms{};

	Parms.PrevGoal = PrevGoal;
	Parms.NewGoal = NewGoal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BotPlanProgressFlow.OnDelayedFindNewActionTimerEnd
// (Final, Native, Protected)

void UBotPlanProgressFlow::OnDelayedFindNewActionTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotPlanProgressFlow", "OnDelayedFindNewActionTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BotPlanProgressFlow.OnDontMoveTimerEnd
// (Final, Native, Protected)

void UBotPlanProgressFlow::OnDontMoveTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotPlanProgressFlow", "OnDontMoveTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BotPlanProgressFlow.OnExtractionArrived
// (Final, Native, Protected)

void UBotPlanProgressFlow::OnExtractionArrived()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotPlanProgressFlow", "OnExtractionArrived");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BotPlanProgressFlow.OnExtractionOnTheWay
// (Final, Native, Protected)

void UBotPlanProgressFlow::OnExtractionOnTheWay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotPlanProgressFlow", "OnExtractionOnTheWay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BotPlanProgressFlow.OnGamePhaseChange
// (Final, Native, Protected)
// Parameters:
// ESpyGamePhase                           NewGamePhase                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotPlanProgressFlow::OnGamePhaseChange(ESpyGamePhase NewGamePhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotPlanProgressFlow", "OnGamePhaseChange");

	Params::BotPlanProgressFlow_OnGamePhaseChange Parms{};

	Parms.NewGamePhase = NewGamePhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BotPlanProgressFlow.OnMoveActionEnd
// (Final, Native, Protected)
// Parameters:
// class UBotAction*                       ActionEnding                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBotActionResult                        ActionResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotPlanProgressFlow::OnMoveActionEnd(class UBotAction* ActionEnding, EBotActionResult ActionResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotPlanProgressFlow", "OnMoveActionEnd");

	Params::BotPlanProgressFlow_OnMoveActionEnd Parms{};

	Parms.ActionEnding = ActionEnding;
	Parms.ActionResult = ActionResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PlayerInfoWidget.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADIPlayerState*                   InPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoWidget::Init(class ADIPlayerState* InPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoWidget", "Init");

	Params::PlayerInfoWidget_Init Parms{};

	Parms.InPlayerState = InPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PlayerInfoWidget.InitWithPartyMemberInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDIOnlinePartyMemberInfo*         OnlinePartyMemberInfo                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoWidget::InitWithPartyMemberInfo(class UDIOnlinePartyMemberInfo* OnlinePartyMemberInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoWidget", "InitWithPartyMemberInfo");

	Params::PlayerInfoWidget_InitWithPartyMemberInfo Parms{};

	Parms.OnlinePartyMemberInfo = OnlinePartyMemberInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PlayerInfoWidget.InitWithSpy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoWidget::InitWithSpy(class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoWidget", "InitWithSpy");

	Params::PlayerInfoWidget_InitWithSpy Parms{};

	Parms.Spy = Spy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PlayerInfoWidget.OnPlayerInfoUpdated
// (Event, Public, BlueprintEvent)

void UPlayerInfoWidget::OnPlayerInfoUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoWidget", "OnPlayerInfoUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.PlayerInfoWidget.GetPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADIPlayerState*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADIPlayerState* UPlayerInfoWidget::GetPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoWidget", "GetPlayerState");

	Params::PlayerInfoWidget_GetPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PlayerInfoWidget.GetUserName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UPlayerInfoWidget::GetUserName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoWidget", "GetUserName");

	Params::PlayerInfoWidget_GetUserName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PlayerInfoWidget.GetUserPlatform
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlatformType                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlatformType UPlayerInfoWidget::GetUserPlatform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoWidget", "GetUserPlatform");

	Params::PlayerInfoWidget_GetUserPlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PlayerInfoWidget.IsInitialized
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerInfoWidget::IsInitialized() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoWidget", "IsInitialized");

	Params::PlayerInfoWidget_IsInitialized Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BotSpawner.DespawnLastSpawnedBot
// (Final, Native, Public, BlueprintCallable)

void ABotSpawner::DespawnLastSpawnedBot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotSpawner", "DespawnLastSpawnedBot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BotSpawner.SpawnBot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADeceiveIncBotController*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADeceiveIncBotController* ABotSpawner::SpawnBot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotSpawner", "SpawnBot");

	Params::BotSpawner_SpawnBot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BotSpawner.GetLastSpawnedBot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADeceiveIncBotController*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADeceiveIncBotController* ABotSpawner::GetLastSpawnedBot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotSpawner", "GetLastSpawnedBot");

	Params::BotSpawner_GetLastSpawnedBot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PingInGameUserWidget.SelectPingIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPingInGameUserWidget::SelectPingIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PingInGameUserWidget", "SelectPingIndex");

	Params::PingInGameUserWidget_SelectPingIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.OctoPassiveAbility.HandleResourceChange
// (Final, Native, Protected)
// Parameters:
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ResourceDisplayName                                    (Parm, NativeAccessSpecifierPublic)
// int32                                   DeltaAmount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOctoPassiveAbility::HandleResourceChange(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 DeltaAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoPassiveAbility", "HandleResourceChange");

	Params::OctoPassiveAbility_HandleResourceChange Parms{};

	Parms.ResourceType = ResourceType;
	Parms.ResourceDisplayName = std::move(ResourceDisplayName);
	Parms.DeltaAmount = DeltaAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BouncingMatTool.HandleNotifyDeflate
// (Final, Native, Protected)
// Parameters:
// class ABouncingMat*                     DeflatingBounceMat                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABouncingMatTool::HandleNotifyDeflate(class ABouncingMat* DeflatingBounceMat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BouncingMatTool", "HandleNotifyDeflate");

	Params::BouncingMatTool_HandleNotifyDeflate Parms{};

	Parms.DeflatingBounceMat = DeflatingBounceMat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BriefcaseLoot.BP_OnLootClaimError
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           ErrorMessage                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABriefcaseLoot::BP_OnLootClaimError(const class FString& ErrorMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BriefcaseLoot", "BP_OnLootClaimError");

	Params::BriefcaseLoot_BP_OnLootClaimError Parms{};

	Parms.ErrorMessage = std::move(ErrorMessage);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BriefcaseLoot.BP_OnLootClaimResponseSet
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FLootClaimResponse               NewLootClaimResponse                                   (Parm, NativeAccessSpecifierPublic)

void ABriefcaseLoot::BP_OnLootClaimResponseSet(const struct FLootClaimResponse& NewLootClaimResponse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BriefcaseLoot", "BP_OnLootClaimResponseSet");

	Params::BriefcaseLoot_BP_OnLootClaimResponseSet Parms{};

	Parms.NewLootClaimResponse = std::move(NewLootClaimResponse);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BriefcaseLoot.BP_OnPedestalsSpawned
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class ALootItemShowcase*>        SpawnedPedestals                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ABriefcaseLoot::BP_OnPedestalsSpawned(const TArray<class ALootItemShowcase*>& SpawnedPedestals)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BriefcaseLoot", "BP_OnPedestalsSpawned");

	Params::BriefcaseLoot_BP_OnPedestalsSpawned Parms{};

	Parms.SpawnedPedestals = std::move(SpawnedPedestals);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.BriefcaseLoot.BriefcaseLootSpawnPedestals
// (Final, Native, Public, BlueprintCallable)

void ABriefcaseLoot::BriefcaseLootSpawnPedestals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BriefcaseLoot", "BriefcaseLootSpawnPedestals");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BriefcaseLoot.BringBackFromDespawn
// (Final, Native, Public, BlueprintCallable)

void ABriefcaseLoot::BringBackFromDespawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BriefcaseLoot", "BringBackFromDespawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BriefcaseLoot.DestroyPedestals
// (Final, Native, Public, BlueprintCallable)

void ABriefcaseLoot::DestroyPedestals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BriefcaseLoot", "DestroyPedestals");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BriefcaseLoot.GetPedestals
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ALootItemShowcase*>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ALootItemShowcase*> ABriefcaseLoot::GetPedestals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BriefcaseLoot", "GetPedestals");

	Params::BriefcaseLoot_GetPedestals Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BriefcaseLoot.OnClaimLootBundleResponse
// (Final, Native, Protected)
// Parameters:
// class FString                           LootBundleId                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLootClaimResponse               Response                                               (Parm, NativeAccessSpecifierPublic)
// class FString                           Error                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABriefcaseLoot::OnClaimLootBundleResponse(const class FString& LootBundleId, const struct FLootClaimResponse& Response, const class FString& Error, bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BriefcaseLoot", "OnClaimLootBundleResponse");

	Params::BriefcaseLoot_OnClaimLootBundleResponse Parms{};

	Parms.LootBundleId = std::move(LootBundleId);
	Parms.Response = std::move(Response);
	Parms.Error = std::move(Error);
	Parms.bSuccess = bSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BriefcaseLoot.ShowcaseItemsOnPedestals
// (Final, Native, Public, BlueprintCallable)

void ABriefcaseLoot::ShowcaseItemsOnPedestals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BriefcaseLoot", "ShowcaseItemsOnPedestals");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BriefcaseLoot.StartDespawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DespawnDurationIn                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABriefcaseLoot::StartDespawn(float DespawnDurationIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BriefcaseLoot", "StartDespawn");

	Params::BriefcaseLoot_StartDespawn Parms{};

	Parms.DespawnDurationIn = DespawnDurationIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BriefcaseLoot.GetLootClaimResponse
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLootClaimResponse               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FLootClaimResponse ABriefcaseLoot::GetLootClaimResponse() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BriefcaseLoot", "GetLootClaimResponse");

	Params::BriefcaseLoot_GetLootClaimResponse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PlayerBotsSubsystem.OnGamePhaseChanged
// (Final, Native, Protected)
// Parameters:
// ESpyGamePhase                           NewGamePhase                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerBotsSubsystem::OnGamePhaseChanged(ESpyGamePhase NewGamePhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBotsSubsystem", "OnGamePhaseChanged");

	Params::PlayerBotsSubsystem_OnGamePhaseChanged Parms{};

	Parms.NewGamePhase = NewGamePhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PlayerBotsSubsystem.OnSpyBotDeath
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerBotsSubsystem::OnSpyBotDeath(class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBotsSubsystem", "OnSpyBotDeath");

	Params::PlayerBotsSubsystem_OnSpyBotDeath Parms{};

	Parms.Spy = Spy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.BuildMetadataSubsystem.GetFilteredReleaseNoteLines
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bRemoveBuildNumberLines                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveHashtagRN                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UBuildMetadataSubsystem::GetFilteredReleaseNoteLines(bool bRemoveBuildNumberLines, bool bRemoveHashtagRN) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuildMetadataSubsystem", "GetFilteredReleaseNoteLines");

	Params::BuildMetadataSubsystem_GetFilteredReleaseNoteLines Parms{};

	Parms.bRemoveBuildNumberLines = bRemoveBuildNumberLines;
	Parms.bRemoveHashtagRN = bRemoveHashtagRN;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BuildMetadataSubsystem.GetFilteredReleaseNoteLinesForBuild
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   buildChangelist                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveBuildNumberLines                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveHashtagRN                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UBuildMetadataSubsystem::GetFilteredReleaseNoteLinesForBuild(int32 buildChangelist, bool bRemoveBuildNumberLines, bool bRemoveHashtagRN) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuildMetadataSubsystem", "GetFilteredReleaseNoteLinesForBuild");

	Params::BuildMetadataSubsystem_GetFilteredReleaseNoteLinesForBuild Parms{};

	Parms.buildChangelist = buildChangelist;
	Parms.bRemoveBuildNumberLines = bRemoveBuildNumberLines;
	Parms.bRemoveHashtagRN = bRemoveHashtagRN;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BuildMetadataSubsystem.GetRawReleaseNoteLines
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UBuildMetadataSubsystem::GetRawReleaseNoteLines() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuildMetadataSubsystem", "GetRawReleaseNoteLines");

	Params::BuildMetadataSubsystem_GetRawReleaseNoteLines Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.BuildMetadataSubsystem.GetReleaseNoteBuildChangelistNumbers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UBuildMetadataSubsystem::GetReleaseNoteBuildChangelistNumbers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuildMetadataSubsystem", "GetReleaseNoteBuildChangelistNumbers");

	Params::BuildMetadataSubsystem_GetReleaseNoteBuildChangelistNumbers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.CallingCardInGameUserWidget.SelectCallingcard
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECallingCardPosition                    CardPosition                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCallingCardInGameUserWidget::SelectCallingcard(ECallingCardPosition CardPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CallingCardInGameUserWidget", "SelectCallingcard");

	Params::CallingCardInGameUserWidget_SelectCallingcard Parms{};

	Parms.CardPosition = CardPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CallingCardInGameUserWidget.SelectCallingcardIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCallingCardInGameUserWidget::SelectCallingcardIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CallingCardInGameUserWidget", "SelectCallingcardIndex");

	Params::CallingCardInGameUserWidget_SelectCallingcardIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PlatformDataAsset.GetCurrentPlatformName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UPlatformDataAsset::GetCurrentPlatformName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformDataAsset", "GetCurrentPlatformName");

	Params::PlatformDataAsset_GetCurrentPlatformName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PlatformDataAsset.GetCurrentPlatformType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPlatformType                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlatformType UPlatformDataAsset::GetCurrentPlatformType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformDataAsset", "GetCurrentPlatformType");

	Params::PlatformDataAsset_GetCurrentPlatformType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PlatformDataAsset.GetPlatformType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           PlateformName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlatformType                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlatformType UPlatformDataAsset::GetPlatformType(const class FString& PlateformName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformDataAsset", "GetPlatformType");

	Params::PlatformDataAsset_GetPlatformType Parms{};

	Parms.PlateformName = std::move(PlateformName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.CallingCardPlaceableTool.HandleOnNewDropActorDropped
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           ServerActorToDrop                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           LocalActorToDrop                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         EndRotation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ACallingCardPlaceableTool::HandleOnNewDropActorDropped(class AActor* ServerActorToDrop, class AActor* LocalActorToDrop, const struct FVector& EndLocation, const struct FRotator& EndRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CallingCardPlaceableTool", "HandleOnNewDropActorDropped");

	Params::CallingCardPlaceableTool_HandleOnNewDropActorDropped Parms{};

	Parms.ServerActorToDrop = ServerActorToDrop;
	Parms.LocalActorToDrop = LocalActorToDrop;
	Parms.EndLocation = std::move(EndLocation);
	Parms.EndRotation = std::move(EndRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CallingCardPlaceableTool.NetMulticast_OnNewSelectedCallingCard
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// int32                                   NewSelectedCallingCard                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACallingCardPlaceableTool::NetMulticast_OnNewSelectedCallingCard(int32 NewSelectedCallingCard)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CallingCardPlaceableTool", "NetMulticast_OnNewSelectedCallingCard");

	Params::CallingCardPlaceableTool_NetMulticast_OnNewSelectedCallingCard Parms{};

	Parms.NewSelectedCallingCard = NewSelectedCallingCard;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CallingCardPlaceableTool.NetMulticast_ThrowCard
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ACallingCardPlaceableTool::NetMulticast_ThrowCard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CallingCardPlaceableTool", "NetMulticast_ThrowCard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CallingCardPlaceableTool.OnThrowDelayTimerEnd
// (Native, Protected)

void ACallingCardPlaceableTool::OnThrowDelayTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CallingCardPlaceableTool", "OnThrowDelayTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CallingCardPlaceableTool.OnThrowTimerEnd
// (Native, Protected)

void ACallingCardPlaceableTool::OnThrowTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CallingCardPlaceableTool", "OnThrowTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CallingCardPlaceableTool.Server_OnNewSelectedCallingCard
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// int32                                   NewSelectedCallingCard                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACallingCardPlaceableTool::Server_OnNewSelectedCallingCard(int32 NewSelectedCallingCard)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CallingCardPlaceableTool", "Server_OnNewSelectedCallingCard");

	Params::CallingCardPlaceableTool_Server_OnNewSelectedCallingCard Parms{};

	Parms.NewSelectedCallingCard = NewSelectedCallingCard;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CallingCardPlaceableTool.Server_ThrowCard
// (Net, NetReliable, Native, Event, Protected, NetServer)

void ACallingCardPlaceableTool::Server_ThrowCard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CallingCardPlaceableTool", "Server_ThrowCard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CallingCardPlaceableTool.IsThrowingCard
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACallingCardPlaceableTool::IsThrowingCard() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CallingCardPlaceableTool", "IsThrowingCard");

	Params::CallingCardPlaceableTool_IsThrowingCard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PoisonAoEActor.HandleLoadoutSpawnComplete
// (Final, Native, Protected)
// Parameters:
// class UToolLoadoutComponent*            ToolLoadout                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APoisonAoEActor::HandleLoadoutSpawnComplete(class UToolLoadoutComponent* ToolLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoisonAoEActor", "HandleLoadoutSpawnComplete");

	Params::PoisonAoEActor_HandleLoadoutSpawnComplete Parms{};

	Parms.ToolLoadout = ToolLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CavaliereActiveAbility.HandleCavActiveInteractionCancel
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACavaliereActiveAbility::HandleCavActiveInteractionCancel(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavaliereActiveAbility", "HandleCavActiveInteractionCancel");

	Params::CavaliereActiveAbility_HandleCavActiveInteractionCancel Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CavaliereActiveAbility.HandleCavActiveInteractionComplete
// (Final, Native, Protected)
// Parameters:
// struct FInteractableData                InteractableData                                       (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACavaliereActiveAbility::HandleCavActiveInteractionComplete(const struct FInteractableData& InteractableData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavaliereActiveAbility", "HandleCavActiveInteractionComplete");

	Params::CavaliereActiveAbility_HandleCavActiveInteractionComplete Parms{};

	Parms.InteractableData = std::move(InteractableData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CavaliereActiveAbility.HandleCavActiveInteractionStart
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACavaliereActiveAbility::HandleCavActiveInteractionStart(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavaliereActiveAbility", "HandleCavActiveInteractionStart");

	Params::CavaliereActiveAbility_HandleCavActiveInteractionStart Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CavaliereActiveAbility.HandleCavActiveRegisterInteractable
// (Final, Native, Protected)
// Parameters:
// struct FInteractableData                InteractableData                                       (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACavaliereActiveAbility::HandleCavActiveRegisterInteractable(const struct FInteractableData& InteractableData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavaliereActiveAbility", "HandleCavActiveRegisterInteractable");

	Params::CavaliereActiveAbility_HandleCavActiveRegisterInteractable Parms{};

	Parms.InteractableData = std::move(InteractableData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CavaliereActiveAbility.HandleNewFocusedInteractable
// (Final, Native, Protected)
// Parameters:
// class UInteractableComponent*           NewFocusedInteractable                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACavaliereActiveAbility::HandleNewFocusedInteractable(class UInteractableComponent* NewFocusedInteractable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavaliereActiveAbility", "HandleNewFocusedInteractable");

	Params::CavaliereActiveAbility_HandleNewFocusedInteractable Parms{};

	Parms.NewFocusedInteractable = NewFocusedInteractable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CavaliereActiveAbility.NetMulticast_OnChasingEnd
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACavaliereActiveAbility::NetMulticast_OnChasingEnd(class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavaliereActiveAbility", "NetMulticast_OnChasingEnd");

	Params::CavaliereActiveAbility_NetMulticast_OnChasingEnd Parms{};

	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CavaliereActiveAbility.NetMulticast_OnChasingStart
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACavaliereActiveAbility::NetMulticast_OnChasingStart(class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavaliereActiveAbility", "NetMulticast_OnChasingStart");

	Params::CavaliereActiveAbility_NetMulticast_OnChasingStart Parms{};

	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CavaliereActiveAbility.OnChasingEnd
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACavaliereActiveAbility::OnChasingEnd(class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavaliereActiveAbility", "OnChasingEnd");

	Params::CavaliereActiveAbility_OnChasingEnd Parms{};

	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CavaliereActiveAbility.Server_OnCavActiveInteractionCancel
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACavaliereActiveAbility::Server_OnCavActiveInteractionCancel(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavaliereActiveAbility", "Server_OnCavActiveInteractionCancel");

	Params::CavaliereActiveAbility_Server_OnCavActiveInteractionCancel Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CavaliereActiveAbility.Server_OnCavActiveInteractionComplete
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   TimeOfRequest                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACavaliereActiveAbility::Server_OnCavActiveInteractionComplete(class UInteractableComponent* Interactable, int64 TimeOfRequest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavaliereActiveAbility", "Server_OnCavActiveInteractionComplete");

	Params::CavaliereActiveAbility_Server_OnCavActiveInteractionComplete Parms{};

	Parms.Interactable = Interactable;
	Parms.TimeOfRequest = TimeOfRequest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CavaliereActiveAbility.Server_OnCavActiveInteractionStart
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACavaliereActiveAbility::Server_OnCavActiveInteractionStart(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavaliereActiveAbility", "Server_OnCavActiveInteractionStart");

	Params::CavaliereActiveAbility_Server_OnCavActiveInteractionStart Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CavaliereActiveAbility.SetInteractionProgressBar
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UProgressBar*                     ProgressBar                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACavaliereActiveAbility::SetInteractionProgressBar(class UProgressBar* ProgressBar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavaliereActiveAbility", "SetInteractionProgressBar");

	Params::CavaliereActiveAbility_SetInteractionProgressBar Parms{};

	Parms.ProgressBar = ProgressBar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PointOfInterestComponent.EnablePOI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnableIn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPointOfInterestComponent::EnablePOI(bool bEnableIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PointOfInterestComponent", "EnablePOI");

	Params::PointOfInterestComponent_EnablePOI Parms{};

	Parms.bEnableIn = bEnableIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PointOfInterestComponent.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPointOfInterestComponent::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PointOfInterestComponent", "IsEnabled");

	Params::PointOfInterestComponent_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.CavaliereActiveAbilityMod2.Client_OnSpyTrapped
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// class AActor*                           TrappedSpy                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACavaliereActiveAbilityMod2::Client_OnSpyTrapped(class AActor* TrappedSpy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavaliereActiveAbilityMod2", "Client_OnSpyTrapped");

	Params::CavaliereActiveAbilityMod2_Client_OnSpyTrapped Parms{};

	Parms.TrappedSpy = TrappedSpy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CavaliereActiveAbilityMod2.HandleMiscToolSpawned
// (Final, Native, Protected)
// Parameters:
// class AActor*                           SpawnedTool                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACavaliereActiveAbilityMod2::HandleMiscToolSpawned(class AActor* SpawnedTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavaliereActiveAbilityMod2", "HandleMiscToolSpawned");

	Params::CavaliereActiveAbilityMod2_HandleMiscToolSpawned Parms{};

	Parms.SpawnedTool = SpawnedTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CavaliereActiveAbilityMod2.HandleTrappedSpy
// (Final, Native, Protected)
// Parameters:
// class AActor*                           TrappedSpy                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACavaliereActiveAbilityMod2::HandleTrappedSpy(class AActor* TrappedSpy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavaliereActiveAbilityMod2", "HandleTrappedSpy");

	Params::CavaliereActiveAbilityMod2_HandleTrappedSpy Parms{};

	Parms.TrappedSpy = TrappedSpy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CavalierePassiveAbility.BP_OnMeleeAttackEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// ESpyMeleeAttackEvent                    EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseMeleeAttack*                 MeleeAttack                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACavalierePassiveAbility::BP_OnMeleeAttackEvent(ESpyMeleeAttackEvent EventType, class ABaseMeleeAttack* MeleeAttack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavalierePassiveAbility", "BP_OnMeleeAttackEvent");

	Params::CavalierePassiveAbility_BP_OnMeleeAttackEvent Parms{};

	Parms.EventType = EventType;
	Parms.MeleeAttack = MeleeAttack;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.CavalierePassiveAbility.HandleMeleeAttackEvent
// (Final, Native, Protected)
// Parameters:
// ESpyMeleeAttackEvent                    EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseMeleeAttack*                 MeleeAttack                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACavalierePassiveAbility::HandleMeleeAttackEvent(ESpyMeleeAttackEvent EventType, class ABaseMeleeAttack* MeleeAttack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavalierePassiveAbility", "HandleMeleeAttackEvent");

	Params::CavalierePassiveAbility_HandleMeleeAttackEvent Parms{};

	Parms.EventType = EventType;
	Parms.MeleeAttack = MeleeAttack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CavalierePassiveAbility.HandleMeleeAttackLoadComplete
// (Final, Native, Protected)
// Parameters:
// class UToolLoadoutComponent*            LoadoutComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACavalierePassiveAbility::HandleMeleeAttackLoadComplete(class UToolLoadoutComponent* LoadoutComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavalierePassiveAbility", "HandleMeleeAttackLoadComplete");

	Params::CavalierePassiveAbility_HandleMeleeAttackLoadComplete Parms{};

	Parms.LoadoutComponent = LoadoutComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CavalierePassiveAbility.NonLocalClientHandleMeleeAttackEvent
// (Final, Native, Protected)
// Parameters:
// ESpyMeleeAttackEvent                    EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseMeleeAttack*                 MeleeAttack                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACavalierePassiveAbility::NonLocalClientHandleMeleeAttackEvent(ESpyMeleeAttackEvent EventType, class ABaseMeleeAttack* MeleeAttack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavalierePassiveAbility", "NonLocalClientHandleMeleeAttackEvent");

	Params::CavalierePassiveAbility_NonLocalClientHandleMeleeAttackEvent Parms{};

	Parms.EventType = EventType;
	Parms.MeleeAttack = MeleeAttack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CavalierePassiveAbilityMod2.HandleMeleeAttackDamageDoneServer
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactPoint                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ChargeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageDone                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ResultingHealthPercentage                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHitType                                HitType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMeleeHitConfirmedData           HitConfirmedData                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACavalierePassiveAbilityMod2::HandleMeleeAttackDamageDoneServer(class AActor* Victim, const struct FVector& ImpactPoint, int32 ChargeLevel, float DamageDone, float ResultingHealthPercentage, EHitType HitType, const struct FMeleeHitConfirmedData& HitConfirmedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavalierePassiveAbilityMod2", "HandleMeleeAttackDamageDoneServer");

	Params::CavalierePassiveAbilityMod2_HandleMeleeAttackDamageDoneServer Parms{};

	Parms.Victim = Victim;
	Parms.ImpactPoint = std::move(ImpactPoint);
	Parms.ChargeLevel = ChargeLevel;
	Parms.DamageDone = DamageDone;
	Parms.ResultingHealthPercentage = ResultingHealthPercentage;
	Parms.HitType = HitType;
	Parms.HitConfirmedData = std::move(HitConfirmedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CavalierePassiveAbilityMod2.HandleMeleeAttackLoadComplete
// (Final, Native, Protected)
// Parameters:
// class UToolLoadoutComponent*            LoadoutComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACavalierePassiveAbilityMod2::HandleMeleeAttackLoadComplete(class UToolLoadoutComponent* LoadoutComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CavalierePassiveAbilityMod2", "HandleMeleeAttackLoadComplete");

	Params::CavalierePassiveAbilityMod2_HandleMeleeAttackLoadComplete Parms{};

	Parms.LoadoutComponent = LoadoutComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChangePhaseComponent.HandleInteractionComplete
// (Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChangePhaseComponent::HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChangePhaseComponent", "HandleInteractionComplete");

	Params::ChangePhaseComponent_HandleInteractionComplete Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChargeLevelsWeaponComponent.GetCurrentChargeLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UChargeLevelsWeaponComponent::GetCurrentChargeLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeLevelsWeaponComponent", "GetCurrentChargeLevel");

	Params::ChargeLevelsWeaponComponent_GetCurrentChargeLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ChargeLevelsWeaponComponent.HandleWeaponProjectileImpact
// (Final, Native, Protected)
// Parameters:
// struct FWeaponImpactData                WeaponImpactData                                       (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UChargeLevelsWeaponComponent::HandleWeaponProjectileImpact(const struct FWeaponImpactData& WeaponImpactData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeLevelsWeaponComponent", "HandleWeaponProjectileImpact");

	Params::ChargeLevelsWeaponComponent_HandleWeaponProjectileImpact Parms{};

	Parms.WeaponImpactData = std::move(WeaponImpactData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChargeLevelsWeaponComponent.OnChargeChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bIsCharging                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AChargeSpawnerWeapon*             ChargeWeapon                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeLevelsWeaponComponent::OnChargeChanged(bool bIsCharging, class AChargeSpawnerWeapon* ChargeWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeLevelsWeaponComponent", "OnChargeChanged");

	Params::ChargeLevelsWeaponComponent_OnChargeChanged Parms{};

	Parms.bIsCharging = bIsCharging;
	Parms.ChargeWeapon = ChargeWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChargeLevelsWeaponComponent.OnLoadoutSpawnComplete
// (Final, Native, Protected)
// Parameters:
// class UToolLoadoutComponent*            ToolLoadout                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeLevelsWeaponComponent::OnLoadoutSpawnComplete(class UToolLoadoutComponent* ToolLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeLevelsWeaponComponent", "OnLoadoutSpawnComplete");

	Params::ChargeLevelsWeaponComponent_OnLoadoutSpawnComplete Parms{};

	Parms.ToolLoadout = ToolLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChargeLevelsWeaponComponent.OnProjectilesReleased
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// struct FVector                          AimedPosition                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeLevelsWeaponComponent::OnProjectilesReleased(const struct FVector& AimedPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeLevelsWeaponComponent", "OnProjectilesReleased");

	Params::ChargeLevelsWeaponComponent_OnProjectilesReleased Parms{};

	Parms.AimedPosition = std::move(AimedPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChargeLevelsWeaponComponent.OnRep_ChargeLevel
// (Final, Native, Private)
// Parameters:
// int32                                   PrevChargeLevel                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeLevelsWeaponComponent::OnRep_ChargeLevel(int32 PrevChargeLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeLevelsWeaponComponent", "OnRep_ChargeLevel");

	Params::ChargeLevelsWeaponComponent_OnRep_ChargeLevel Parms{};

	Parms.PrevChargeLevel = PrevChargeLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChargeLevelsWeaponComponent.Server_AOEDamage
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// struct FWeaponImpactData                WeaponImpactData                                       (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   ChargeLevelIn                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeLevelsWeaponComponent::Server_AOEDamage(const struct FWeaponImpactData& WeaponImpactData, int32 ChargeLevelIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeLevelsWeaponComponent", "Server_AOEDamage");

	Params::ChargeLevelsWeaponComponent_Server_AOEDamage Parms{};

	Parms.WeaponImpactData = std::move(WeaponImpactData);
	Parms.ChargeLevelIn = ChargeLevelIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChargeLevelsWeaponComponent.GetChargeLevelData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ChargeLevelDataIn                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FChargeLevelWeaponData     ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FChargeLevelWeaponData UChargeLevelsWeaponComponent::GetChargeLevelData(int32 ChargeLevelDataIn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeLevelsWeaponComponent", "GetChargeLevelData");

	Params::ChargeLevelsWeaponComponent_GetChargeLevelData Parms{};

	Parms.ChargeLevelDataIn = ChargeLevelDataIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ChargeLevelsWeaponComponent.GetCurrentChargeLevelData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FChargeLevelWeaponData     ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FChargeLevelWeaponData UChargeLevelsWeaponComponent::GetCurrentChargeLevelData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeLevelsWeaponComponent", "GetCurrentChargeLevelData");

	Params::ChargeLevelsWeaponComponent_GetCurrentChargeLevelData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ChargeLevelsWeaponComponent.GetProjectileChargeLevelData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASpawnerWeaponRound*              RoundIn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FChargeLevelWeaponData     ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FChargeLevelWeaponData UChargeLevelsWeaponComponent::GetProjectileChargeLevelData(class ASpawnerWeaponRound* RoundIn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeLevelsWeaponComponent", "GetProjectileChargeLevelData");

	Params::ChargeLevelsWeaponComponent_GetProjectileChargeLevelData Parms{};

	Parms.RoundIn = RoundIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ProjectileWeapon.GetBurstInfoForWeaponClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UClass*                           WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BurstPerShot                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BurstShotDelay                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AProjectileWeapon::GetBurstInfoForWeaponClass(class UClass* WeaponClass, int32* BurstPerShot, float* BurstShotDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileWeapon", "GetBurstInfoForWeaponClass");

	Params::ProjectileWeapon_GetBurstInfoForWeaponClass Parms{};

	Parms.WeaponClass = WeaponClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (BurstPerShot != nullptr)
		*BurstPerShot = Parms.BurstPerShot;

	if (BurstShotDelay != nullptr)
		*BurstShotDelay = Parms.BurstShotDelay;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ProjectileWeapon.GetWeaponBalancingDataForClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UClass*                           WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FProjectileWeaponBalancingData   Result                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AProjectileWeapon::GetWeaponBalancingDataForClass(class UClass* WeaponClass, struct FProjectileWeaponBalancingData* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileWeapon", "GetWeaponBalancingDataForClass");

	Params::ProjectileWeapon_GetWeaponBalancingDataForClass Parms{};

	Parms.WeaponClass = WeaponClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function DeceiveInc.ProjectileWeapon.AddOrReplaceDamageBehavior
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BehaviorName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageBehavior                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDamageBehavior AProjectileWeapon::AddOrReplaceDamageBehavior(class FName BehaviorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "AddOrReplaceDamageBehavior");

	Params::ProjectileWeapon_AddOrReplaceDamageBehavior Parms{};

	Parms.BehaviorName = BehaviorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ProjectileWeapon.BP_OnADSBegin
// (Event, Public, BlueprintEvent)

void AProjectileWeapon::BP_OnADSBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "BP_OnADSBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.ProjectileWeapon.BP_OnADSEnd
// (Event, Public, BlueprintEvent)

void AProjectileWeapon::BP_OnADSEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "BP_OnADSEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.ProjectileWeapon.BP_OnADSReached
// (Event, Public, BlueprintEvent)

void AProjectileWeapon::BP_OnADSReached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "BP_OnADSReached");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.ProjectileWeapon.BP_OnBurstFirstShot
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          ShotEndPoint                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AProjectileWeapon*                Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileWeapon::BP_OnBurstFirstShot(const struct FVector& ShotEndPoint, class AProjectileWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "BP_OnBurstFirstShot");

	Params::ProjectileWeapon_BP_OnBurstFirstShot Parms{};

	Parms.ShotEndPoint = std::move(ShotEndPoint);
	Parms.Weapon = Weapon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.ProjectileWeapon.BP_OnDryShotCycleBegin
// (Event, Public, BlueprintEvent)

void AProjectileWeapon::BP_OnDryShotCycleBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "BP_OnDryShotCycleBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.ProjectileWeapon.BP_OnDryShotCycleEnd
// (Event, Public, BlueprintEvent)

void AProjectileWeapon::BP_OnDryShotCycleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "BP_OnDryShotCycleEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.ProjectileWeapon.BP_OnHitConfirmed
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FHitConfirmData                  HitConfirmedData                                       (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AProjectileWeapon::BP_OnHitConfirmed(const struct FHitConfirmData& HitConfirmedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "BP_OnHitConfirmed");

	Params::ProjectileWeapon_BP_OnHitConfirmed Parms{};

	Parms.HitConfirmedData = std::move(HitConfirmedData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.ProjectileWeapon.BP_OnLocalInstantReload
// (Event, Public, BlueprintEvent)

void AProjectileWeapon::BP_OnLocalInstantReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "BP_OnLocalInstantReload");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.ProjectileWeapon.BP_OnProjectileImpact
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FWeaponImpactData                WeaponImpactData                                       (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AProjectileWeapon::BP_OnProjectileImpact(const struct FWeaponImpactData& WeaponImpactData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "BP_OnProjectileImpact");

	Params::ProjectileWeapon_BP_OnProjectileImpact Parms{};

	Parms.WeaponImpactData = std::move(WeaponImpactData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.ProjectileWeapon.BP_OnShotCycleBegin
// (Event, Public, BlueprintEvent)

void AProjectileWeapon::BP_OnShotCycleBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "BP_OnShotCycleBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.ProjectileWeapon.BP_OnShotCycleEnd
// (Event, Public, BlueprintEvent)

void AProjectileWeapon::BP_OnShotCycleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "BP_OnShotCycleEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.ProjectileWeapon.BP_OnShotFired
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          ShotEndPoint                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AProjectileWeapon*                Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileWeapon::BP_OnShotFired(const struct FVector& ShotEndPoint, class AProjectileWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "BP_OnShotFired");

	Params::ProjectileWeapon_BP_OnShotFired Parms{};

	Parms.ShotEndPoint = std::move(ShotEndPoint);
	Parms.Weapon = Weapon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.ProjectileWeapon.GetDelayBetweenShots
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProjectileWeapon::GetDelayBetweenShots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "GetDelayBetweenShots");

	Params::ProjectileWeapon_GetDelayBetweenShots Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ProjectileWeapon.HandleBooleanPlayerSettingChange
// (Final, Native, Protected)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileWeapon::HandleBooleanPlayerSettingChange(EPlayerSettingsType SettingType, bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "HandleBooleanPlayerSettingChange");

	Params::ProjectileWeapon_HandleBooleanPlayerSettingChange Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.HideADSMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bHideIn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileWeapon::HideADSMesh(bool bHideIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "HideADSMesh");

	Params::ProjectileWeapon_HideADSMesh Parms{};

	Parms.bHideIn = bHideIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.Multicast_HitConfirmed
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FHitConfirmData                  HitConfirmedData                                       (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AProjectileWeapon::Multicast_HitConfirmed(const struct FHitConfirmData& HitConfirmedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "Multicast_HitConfirmed");

	Params::ProjectileWeapon_Multicast_HitConfirmed Parms{};

	Parms.HitConfirmedData = std::move(HitConfirmedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.MulticastFireMissingShot
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FVector_NetQuantize              DestinationPos                                         (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileWeapon::MulticastFireMissingShot(const struct FVector_NetQuantize& DestinationPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "MulticastFireMissingShot");

	Params::ProjectileWeapon_MulticastFireMissingShot Parms{};

	Parms.DestinationPos = std::move(DestinationPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.MulticastFireShot
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FVector_NetQuantize              DestinationPos                                         (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileWeapon::MulticastFireShot(const struct FVector_NetQuantize& DestinationPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "MulticastFireShot");

	Params::ProjectileWeapon_MulticastFireShot Parms{};

	Parms.DestinationPos = std::move(DestinationPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.MulticastReleaseTrigger
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FVector_NetQuantize              OriginPos                                              (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              DestinationPos                                         (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileWeapon::MulticastReleaseTrigger(const struct FVector_NetQuantize& OriginPos, const struct FVector_NetQuantize& DestinationPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "MulticastReleaseTrigger");

	Params::ProjectileWeapon_MulticastReleaseTrigger Parms{};

	Parms.OriginPos = std::move(OriginPos);
	Parms.DestinationPos = std::move(DestinationPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.MulticastReload
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void AProjectileWeapon::MulticastReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "MulticastReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.NetMulticast_FillUpMagazine
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void AProjectileWeapon::NetMulticast_FillUpMagazine()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "NetMulticast_FillUpMagazine");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.OnAutoReloadTimerEnd
// (Final, Native, Protected)

void AProjectileWeapon::OnAutoReloadTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "OnAutoReloadTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.OnBlockADSTimerEnd
// (Final, Native, Protected)

void AProjectileWeapon::OnBlockADSTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "OnBlockADSTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.OnBlockLeftHandWhileShootingTimerEnd
// (Final, Native, Protected)

void AProjectileWeapon::OnBlockLeftHandWhileShootingTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "OnBlockLeftHandWhileShootingTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.OnBlockShotsBySecondaryTimerEnd
// (Native, Protected)

void AProjectileWeapon::OnBlockShotsBySecondaryTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "OnBlockShotsBySecondaryTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.OnConsumedAmmoRecentlyTimerEnd
// (Final, Native, Protected)

void AProjectileWeapon::OnConsumedAmmoRecentlyTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "OnConsumedAmmoRecentlyTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.OnDisabledForADurationTimerEnd
// (Native, Protected)

void AProjectileWeapon::OnDisabledForADurationTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "OnDisabledForADurationTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.OnDisarmedChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bDisarmed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileWeapon::OnDisarmedChange(bool bDisarmed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "OnDisarmedChange");

	Params::ProjectileWeapon_OnDisarmedChange Parms{};

	Parms.bDisarmed = bDisarmed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.OnKillCamDelayedADSTimerEnd
// (Final, Native, Protected)

void AProjectileWeapon::OnKillCamDelayedADSTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "OnKillCamDelayedADSTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.OnRep_ADSPressed
// (Final, Native, Protected)
// Parameters:
// bool                                    PrevADSPressed                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileWeapon::OnRep_ADSPressed(bool PrevADSPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "OnRep_ADSPressed");

	Params::ProjectileWeapon_OnRep_ADSPressed Parms{};

	Parms.PrevADSPressed = PrevADSPressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.OnRep_ClientAmmoCount
// (Final, Native, Protected)

void AProjectileWeapon::OnRep_ClientAmmoCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "OnRep_ClientAmmoCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.OnResourceChange
// (Final, Native, Protected)
// Parameters:
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ResourceDisplayName                                    (Parm, NativeAccessSpecifierPublic)
// int32                                   DeltaAmount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileWeapon::OnResourceChange(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 DeltaAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "OnResourceChange");

	Params::ProjectileWeapon_OnResourceChange Parms{};

	Parms.ResourceType = ResourceType;
	Parms.ResourceDisplayName = std::move(ResourceDisplayName);
	Parms.DeltaAmount = DeltaAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.OnResourceNewMaxAmount
// (Final, Native, Protected)
// Parameters:
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ResourceDisplayName                                    (Parm, NativeAccessSpecifierPublic)
// int32                                   MaxAmount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileWeapon::OnResourceNewMaxAmount(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 MaxAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "OnResourceNewMaxAmount");

	Params::ProjectileWeapon_OnResourceNewMaxAmount Parms{};

	Parms.ResourceType = ResourceType;
	Parms.ResourceDisplayName = std::move(ResourceDisplayName);
	Parms.MaxAmount = MaxAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.OnResrouceNewAmount
// (Final, Native, Protected)
// Parameters:
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ResourceDisplayName                                    (Parm, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileWeapon::OnResrouceNewAmount(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "OnResrouceNewAmount");

	Params::ProjectileWeapon_OnResrouceNewAmount Parms{};

	Parms.ResourceType = ResourceType;
	Parms.ResourceDisplayName = std::move(ResourceDisplayName);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.OnSpyOwnerRevived
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             SpyIn                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileWeapon::OnSpyOwnerRevived(class ASpy* SpyIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "OnSpyOwnerRevived");

	Params::ProjectileWeapon_OnSpyOwnerRevived Parms{};

	Parms.SpyIn = SpyIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.Server_ADSInputChange
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    bADSPressedIn                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileWeapon::Server_ADSInputChange(bool bADSPressedIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "Server_ADSInputChange");

	Params::ProjectileWeapon_Server_ADSInputChange Parms{};

	Parms.bADSPressedIn = bADSPressedIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.ServerFireShot
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// struct FVector_NetQuantize              OriginPos                                              (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              DestinationPos                                         (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileWeapon::ServerFireShot(const struct FVector_NetQuantize& OriginPos, const struct FVector_NetQuantize& DestinationPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "ServerFireShot");

	Params::ProjectileWeapon_ServerFireShot Parms{};

	Parms.OriginPos = std::move(OriginPos);
	Parms.DestinationPos = std::move(DestinationPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.ServerInformOfDirectHit
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// struct FVector_NetQuantize              OriginPos                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHitType                                HitType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageContextData               DamageContext                                          (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// class ASpawnerWeaponRound*              HittingProjectile                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileWeapon::ServerInformOfDirectHit(const struct FVector_NetQuantize& OriginPos, const struct FHitResult& Hit, float Damage, EHitType HitType, const struct FDamageContextData& DamageContext, class ASpawnerWeaponRound* HittingProjectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "ServerInformOfDirectHit");

	Params::ProjectileWeapon_ServerInformOfDirectHit Parms{};

	Parms.OriginPos = std::move(OriginPos);
	Parms.Hit = std::move(Hit);
	Parms.Damage = Damage;
	Parms.HitType = HitType;
	Parms.DamageContext = std::move(DamageContext);
	Parms.HittingProjectile = HittingProjectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.ServerReleaseTrigger
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// struct FVector_NetQuantize              OriginPos                                              (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              DestinationPos                                         (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileWeapon::ServerReleaseTrigger(const struct FVector_NetQuantize& OriginPos, const struct FVector_NetQuantize& DestinationPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "ServerReleaseTrigger");

	Params::ProjectileWeapon_ServerReleaseTrigger Parms{};

	Parms.OriginPos = std::move(OriginPos);
	Parms.DestinationPos = std::move(DestinationPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.ServerReload
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void AProjectileWeapon::ServerReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "ServerReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.SetDefaultDamageBehaviorName
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BehaviorName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileWeapon::SetDefaultDamageBehaviorName(class FName BehaviorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "SetDefaultDamageBehaviorName");

	Params::ProjectileWeapon_SetDefaultDamageBehaviorName Parms{};

	Parms.BehaviorName = BehaviorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.SetWeaponBuffs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReloadBuff                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ROFBuff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileWeapon::SetWeaponBuffs(float ReloadBuff, float ROFBuff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "SetWeaponBuffs");

	Params::ProjectileWeapon_SetWeaponBuffs Parms{};

	Parms.ReloadBuff = ReloadBuff;
	Parms.ROFBuff = ROFBuff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.UpdateRoF
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewRoF                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileWeapon::UpdateRoF(float NewRoF)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "UpdateRoF");

	Params::ProjectileWeapon_UpdateRoF Parms{};

	Parms.NewRoF = NewRoF;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ProjectileWeapon.GetAimedPosition
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AProjectileWeapon::GetAimedPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "GetAimedPosition");

	Params::ProjectileWeapon_GetAimedPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ProjectileWeapon.GetBulletsInCurrentMagazine
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AProjectileWeapon::GetBulletsInCurrentMagazine() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "GetBulletsInCurrentMagazine");

	Params::ProjectileWeapon_GetBulletsInCurrentMagazine Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ProjectileWeapon.GetCooldownBeforeMelee
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProjectileWeapon::GetCooldownBeforeMelee() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "GetCooldownBeforeMelee");

	Params::ProjectileWeapon_GetCooldownBeforeMelee Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ProjectileWeapon.GetDefaultDamageBehaviorName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AProjectileWeapon::GetDefaultDamageBehaviorName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "GetDefaultDamageBehaviorName");

	Params::ProjectileWeapon_GetDefaultDamageBehaviorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ProjectileWeapon.GetMuzzlePosition
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AProjectileWeapon::GetMuzzlePosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "GetMuzzlePosition");

	Params::ProjectileWeapon_GetMuzzlePosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ProjectileWeapon.GetResourcesAtMaximumAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AProjectileWeapon::GetResourcesAtMaximumAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "GetResourcesAtMaximumAmmo");

	Params::ProjectileWeapon_GetResourcesAtMaximumAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ProjectileWeapon.GetResourcesPerDispenserAmmoPack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AProjectileWeapon::GetResourcesPerDispenserAmmoPack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "GetResourcesPerDispenserAmmoPack");

	Params::ProjectileWeapon_GetResourcesPerDispenserAmmoPack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ProjectileWeapon.GetResourcesPerFullAmmoPack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AProjectileWeapon::GetResourcesPerFullAmmoPack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "GetResourcesPerFullAmmoPack");

	Params::ProjectileWeapon_GetResourcesPerFullAmmoPack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ProjectileWeapon.GetWeaponBalancingData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FProjectileWeaponBalancingData   Result                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AProjectileWeapon::GetWeaponBalancingData(struct FProjectileWeaponBalancingData* Result) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "GetWeaponBalancingData");

	Params::ProjectileWeapon_GetWeaponBalancingData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function DeceiveInc.ProjectileWeapon.HasDamageBehavior
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BehaviorName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AProjectileWeapon::HasDamageBehavior(class FName BehaviorName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "HasDamageBehavior");

	Params::ProjectileWeapon_HasDamageBehavior Parms{};

	Parms.BehaviorName = BehaviorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ProjectileWeapon.IsClipEmpty
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AProjectileWeapon::IsClipEmpty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "IsClipEmpty");

	Params::ProjectileWeapon_IsClipEmpty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ProjectileWeapon.IsInADS
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AProjectileWeapon::IsInADS() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileWeapon", "IsInADS");

	Params::ProjectileWeapon_IsInADS Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PosingSpy.ClearAnimationProps
// (Final, Native, Public, BlueprintCallable)

void APosingSpy::ClearAnimationProps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpy", "ClearAnimationProps");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpy.CreateAnimationProp
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimationPropData               PropIn                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bLooping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APosingSpy::CreateAnimationProp(const struct FAnimationPropData& PropIn, bool bLooping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpy", "CreateAnimationProp");

	Params::PosingSpy_CreateAnimationProp Parms{};

	Parms.PropIn = std::move(PropIn);
	Parms.bLooping = bLooping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpy.CreateAnimationProps
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FAnimationPropData>       PropsIn                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bLooping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APosingSpy::CreateAnimationProps(const TArray<struct FAnimationPropData>& PropsIn, bool bLooping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpy", "CreateAnimationProps");

	Params::PosingSpy_CreateAnimationProps Parms{};

	Parms.PropsIn = std::move(PropsIn);
	Parms.bLooping = bLooping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpy.DestroyAnimationProp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             NameID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APosingSpy::DestroyAnimationProp(class FName NameID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpy", "DestroyAnimationProp");

	Params::PosingSpy_DestroyAnimationProp Parms{};

	Parms.NameID = NameID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpy.NotifyCharacterSelected
// (Event, Public, BlueprintEvent)

void APosingSpy::NotifyCharacterSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpy", "NotifyCharacterSelected");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.PosingSpy.NotifyHideWeaponWraps
// (Event, Public, BlueprintEvent)

void APosingSpy::NotifyHideWeaponWraps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpy", "NotifyHideWeaponWraps");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.PosingSpy.NotifyIntroPoseAnimationLooped
// (Event, Public, BlueprintEvent)

void APosingSpy::NotifyIntroPoseAnimationLooped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpy", "NotifyIntroPoseAnimationLooped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.PosingSpy.NotifyIntroPoseAnimationStart
// (Event, Public, BlueprintEvent)
// Parameters:
// class UAgentIntroPoseDataAsset*         IntroPose                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APosingSpy::NotifyIntroPoseAnimationStart(class UAgentIntroPoseDataAsset* IntroPose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpy", "NotifyIntroPoseAnimationStart");

	Params::PosingSpy_NotifyIntroPoseAnimationStart Parms{};

	Parms.IntroPose = IntroPose;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.PosingSpy.NotifyShowWeaponWraps
// (Event, Public, BlueprintEvent)

void APosingSpy::NotifyShowWeaponWraps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpy", "NotifyShowWeaponWraps");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.PosingSpy.OnCharacterSelected
// (Native, Public, BlueprintCallable)

void APosingSpy::OnCharacterSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpy", "OnCharacterSelected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpy.OnHideWeaponWraps
// (Native, Public, BlueprintCallable)

void APosingSpy::OnHideWeaponWraps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpy", "OnHideWeaponWraps");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpy.OnShowWeaponWraps
// (Native, Public, BlueprintCallable)

void APosingSpy::OnShowWeaponWraps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpy", "OnShowWeaponWraps");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpy.ShowWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APosingSpy::ShowWeapon(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpy", "ShowWeapon");

	Params::PosingSpy_ShowWeapon Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpawnerWeapon.NetMulticast_SwitchRound
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class UClass*                           NewFireShotClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayResourcesType                  NewRoundResource                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpawnerWeapon::NetMulticast_SwitchRound(class UClass* NewFireShotClass, EGameplayResourcesType NewRoundResource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeapon", "NetMulticast_SwitchRound");

	Params::SpawnerWeapon_NetMulticast_SwitchRound Parms{};

	Parms.NewFireShotClass = NewFireShotClass;
	Parms.NewRoundResource = NewRoundResource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpawnerWeapon.OnCheckBreadcrumbTickTimerEnd
// (Final, Native, Protected)

void ASpawnerWeapon::OnCheckBreadcrumbTickTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeapon", "OnCheckBreadcrumbTickTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpawnerWeapon.OnISTTimerEnd
// (Final, Native, Protected)

void ASpawnerWeapon::OnISTTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeapon", "OnISTTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpawnerWeapon.OnRetrySPACOTimerEnd
// (Final, Native, Protected, HasDefaults)
// Parameters:
// struct FVector                          Pos                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpawnerWeapon::OnRetrySPACOTimerEnd(const struct FVector& Pos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeapon", "OnRetrySPACOTimerEnd");

	Params::SpawnerWeapon_OnRetrySPACOTimerEnd Parms{};

	Parms.Pos = std::move(Pos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpawnerWeapon.Server_NotifyProjectileReleased
// (Net, NetReliable, Native, Event, Protected, NetServer)

void ASpawnerWeapon::Server_NotifyProjectileReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeapon", "Server_NotifyProjectileReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpawnerWeapon.Server_SpawnOnHitActor
// (Net, NetReliable, Native, Event, Protected, NetServer, HasDefaults, NetValidate)
// Parameters:
// class UClass*                           ActorToSpawnClass                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          HitDirection                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpawnerWeapon::Server_SpawnOnHitActor(class UClass* ActorToSpawnClass, const struct FHitResult& HitResult, const struct FVector& HitDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeapon", "Server_SpawnOnHitActor");

	Params::SpawnerWeapon_Server_SpawnOnHitActor Parms{};

	Parms.ActorToSpawnClass = ActorToSpawnClass;
	Parms.HitResult = std::move(HitResult);
	Parms.HitDirection = std::move(HitDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpawnerWeapon.Server_SwitchRound
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class UClass*                           NewFireShotClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayResourcesType                  NewRoundResource                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpawnerWeapon::Server_SwitchRound(class UClass* NewFireShotClass, EGameplayResourcesType NewRoundResource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeapon", "Server_SwitchRound");

	Params::SpawnerWeapon_Server_SwitchRound Parms{};

	Parms.NewFireShotClass = NewFireShotClass;
	Parms.NewRoundResource = NewRoundResource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpawnerWeapon.ShowProjectile
// (Native, Public, BlueprintCallable)

void ASpawnerWeapon::ShowProjectile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeapon", "ShowProjectile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpawnerWeapon.GetHeldProjectile
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASpawnerWeaponRound*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASpawnerWeaponRound* ASpawnerWeapon::GetHeldProjectile() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeapon", "GetHeldProjectile");

	Params::SpawnerWeapon_GetHeldProjectile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SpawnerWeapon.HasHeldProjectile
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpawnerWeapon::HasHeldProjectile() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeapon", "HasHeldProjectile");

	Params::SpawnerWeapon_HasHeldProjectile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ChargeSpawnerWeapon.GetChargedSpawnerWeaponBalancingDataForClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UClass*                           WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSpawnerWeaponBalancingData      Result                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AChargeSpawnerWeapon::GetChargedSpawnerWeaponBalancingDataForClass(class UClass* WeaponClass, struct FSpawnerWeaponBalancingData* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ChargeSpawnerWeapon", "GetChargedSpawnerWeaponBalancingDataForClass");

	Params::ChargeSpawnerWeapon_GetChargedSpawnerWeaponBalancingDataForClass Parms{};

	Parms.WeaponClass = WeaponClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function DeceiveInc.ChargeSpawnerWeapon.GetChargeRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AChargeSpawnerWeapon::GetChargeRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeSpawnerWeapon", "GetChargeRatio");

	Params::ChargeSpawnerWeapon_GetChargeRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ChargeSpawnerWeapon.IsFullyCharged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AChargeSpawnerWeapon::IsFullyCharged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeSpawnerWeapon", "IsFullyCharged");

	Params::ChargeSpawnerWeapon_IsFullyCharged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ChargeSpawnerWeapon.OnBlockChargingTimerEnd
// (Final, Native, Protected)

void AChargeSpawnerWeapon::OnBlockChargingTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeSpawnerWeapon", "OnBlockChargingTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChargeSpawnerWeapon.OnKillCamDelayedChargingTimerEnd
// (Final, Native, Protected)

void AChargeSpawnerWeapon::OnKillCamDelayedChargingTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeSpawnerWeapon", "OnKillCamDelayedChargingTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChargeSpawnerWeapon.OnMainWeaponADSChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bInADS                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChargeSpawnerWeapon::OnMainWeaponADSChanged(bool bInADS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeSpawnerWeapon", "OnMainWeaponADSChanged");

	Params::ChargeSpawnerWeapon_OnMainWeaponADSChanged Parms{};

	Parms.bInADS = bInADS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChargeSpawnerWeapon.OnRep_IsCharging
// (Final, Native, Protected)
// Parameters:
// struct FChargeStateInfo                 PrevInfo                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AChargeSpawnerWeapon::OnRep_IsCharging(const struct FChargeStateInfo& PrevInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeSpawnerWeapon", "OnRep_IsCharging");

	Params::ChargeSpawnerWeapon_OnRep_IsCharging Parms{};

	Parms.PrevInfo = std::move(PrevInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChargeSpawnerWeapon.OnRep_IsFullyCharged
// (Final, Native, Protected)
// Parameters:
// bool                                    bPrevIsCharging                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChargeSpawnerWeapon::OnRep_IsFullyCharged(bool bPrevIsCharging)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeSpawnerWeapon", "OnRep_IsFullyCharged");

	Params::ChargeSpawnerWeapon_OnRep_IsFullyCharged Parms{};

	Parms.bPrevIsCharging = bPrevIsCharging;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChargeSpawnerWeapon.Server_StartCharging
// (Net, NetReliable, Native, Event, Protected, NetServer)

void AChargeSpawnerWeapon::Server_StartCharging()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeSpawnerWeapon", "Server_StartCharging");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChargeSpawnerWeapon.Server_StopCharging
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    bIsCancel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChargeSpawnerWeapon::Server_StopCharging(bool bIsCancel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeSpawnerWeapon", "Server_StopCharging");

	Params::ChargeSpawnerWeapon_Server_StopCharging Parms{};

	Parms.bIsCancel = bIsCancel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChargeSpawnerWeapon.GetChargedSpawnerWeaponBalancingData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSpawnerWeaponBalancingData      Result                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AChargeSpawnerWeapon::GetChargedSpawnerWeaponBalancingData(struct FSpawnerWeaponBalancingData* Result) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeSpawnerWeapon", "GetChargedSpawnerWeaponBalancingData");

	Params::ChargeSpawnerWeapon_GetChargedSpawnerWeaponBalancingData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function DeceiveInc.ChargeSpawnerWeapon.IsCharging
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AChargeSpawnerWeapon::IsCharging() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeSpawnerWeapon", "IsCharging");

	Params::ChargeSpawnerWeapon_IsCharging Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ChargeSpawnerWeapon.TimeLeftToFullyCharged
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AChargeSpawnerWeapon::TimeLeftToFullyCharged() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeSpawnerWeapon", "TimeLeftToFullyCharged");

	Params::ChargeSpawnerWeapon_TimeLeftToFullyCharged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.RewardBundleDataAsset.GetBundleForAssetData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDIPrimaryDataAsset*              DataAsset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRewardBundleInfo                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRewardBundleInfo URewardBundleDataAsset::GetBundleForAssetData(class UDIPrimaryDataAsset* DataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RewardBundleDataAsset", "GetBundleForAssetData");

	Params::RewardBundleDataAsset_GetBundleForAssetData Parms{};

	Parms.DataAsset = DataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ChavezActiveAbilityMod2.OnTriggerDelayTimer
// (Native, Protected)

void AChavezActiveAbilityMod2::OnTriggerDelayTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChavezActiveAbilityMod2", "OnTriggerDelayTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.RemoteTurretAIComponent.BP_OnShotCycleBegin
// (Event, Public, BlueprintEvent)

void URemoteTurretAIComponent::BP_OnShotCycleBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RemoteTurretAIComponent", "BP_OnShotCycleBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.RemoteTurretAIComponent.BP_OnShotCycleEnd
// (Event, Public, BlueprintEvent)

void URemoteTurretAIComponent::BP_OnShotCycleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RemoteTurretAIComponent", "BP_OnShotCycleEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.RemoteTurretAIComponent.OnRep_NewTurretAState
// (Final, Native, Protected)
// Parameters:
// ERemoteTurretAIState                    OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URemoteTurretAIComponent::OnRep_NewTurretAState(ERemoteTurretAIState OldState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RemoteTurretAIComponent", "OnRep_NewTurretAState");

	Params::RemoteTurretAIComponent_OnRep_NewTurretAState Parms{};

	Parms.OldState = OldState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.RemoteTurretAIComponent.OnRep_Target
// (Final, Native, Protected)

void URemoteTurretAIComponent::OnRep_Target()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RemoteTurretAIComponent", "OnRep_Target");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChavezPassiveAbility.MulticastDamageTaken
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChavezPassiveAbility::MulticastDamageTaken(class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChavezPassiveAbility", "MulticastDamageTaken");

	Params::ChavezPassiveAbility_MulticastDamageTaken Parms{};

	Parms.Spy = Spy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChavezPassiveAbility.MulticastRegenCompleted
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChavezPassiveAbility::MulticastRegenCompleted(class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChavezPassiveAbility", "MulticastRegenCompleted");

	Params::ChavezPassiveAbility_MulticastRegenCompleted Parms{};

	Parms.Spy = Spy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChavezPassiveAbility.MulticastRegenStarted
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChavezPassiveAbility::MulticastRegenStarted(class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChavezPassiveAbility", "MulticastRegenStarted");

	Params::ChavezPassiveAbility_MulticastRegenStarted Parms{};

	Parms.Spy = Spy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChavezPassiveAbility.OnHealthChanged
// (Final, Native, Public)
// Parameters:
// class UHealthComponent*                 OwningHealthComp                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Health                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HealthDelta                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RawDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChavezPassiveAbility::OnHealthChanged(class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, float RawDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChavezPassiveAbility", "OnHealthChanged");

	Params::ChavezPassiveAbility_OnHealthChanged Parms{};

	Parms.OwningHealthComp = OwningHealthComp;
	Parms.Health = Health;
	Parms.HealthDelta = HealthDelta;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.RawDamage = RawDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PrivateLobbySubsystem.AutoselectBestServerRegion
// (Final, Native, Public, BlueprintCallable)

void UPrivateLobbySubsystem::AutoselectBestServerRegion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "AutoselectBestServerRegion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PrivateLobbySubsystem.CancelPrivateLobbyMatchmaking
// (Final, Native, Public, BlueprintCallable)

void UPrivateLobbySubsystem::CancelPrivateLobbyMatchmaking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "CancelPrivateLobbyMatchmaking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PrivateLobbySubsystem.GetLatencyForRegion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Region                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPrivateLobbySubsystem::GetLatencyForRegion(const class FString& Region)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "GetLatencyForRegion");

	Params::PrivateLobbySubsystem_GetLatencyForRegion Parms{};

	Parms.Region = std::move(Region);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PrivateLobbySubsystem.GetLatencyForRegionIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   RegionIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPrivateLobbySubsystem::GetLatencyForRegionIndex(int32 RegionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "GetLatencyForRegionIndex");

	Params::PrivateLobbySubsystem_GetLatencyForRegionIndex Parms{};

	Parms.RegionIndex = RegionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PrivateLobbySubsystem.HandlePartyCreatedOrJoined
// (Final, Native, Public)

void UPrivateLobbySubsystem::HandlePartyCreatedOrJoined()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "HandlePartyCreatedOrJoined");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PrivateLobbySubsystem.HandlePartyUpdated
// (Final, Native, Public)

void UPrivateLobbySubsystem::HandlePartyUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "HandlePartyUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PrivateLobbySubsystem.HandlePlayerSettingChange
// (Final, Native, Public)
// Parameters:
// EPlayerSettingsType                     SettingChanged                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrivateLobbySubsystem::HandlePlayerSettingChange(EPlayerSettingsType SettingChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "HandlePlayerSettingChange");

	Params::PrivateLobbySubsystem_HandlePlayerSettingChange Parms{};

	Parms.SettingChanged = SettingChanged;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PrivateLobbySubsystem.OnLobbyPartyDataUpdateRequested
// (Final, Native, Protected)

void UPrivateLobbySubsystem::OnLobbyPartyDataUpdateRequested()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "OnLobbyPartyDataUpdateRequested");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PrivateLobbySubsystem.RandomizeTeams
// (Final, Native, Public, BlueprintCallable)

void UPrivateLobbySubsystem::RandomizeTeams()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "RandomizeTeams");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PrivateLobbySubsystem.SetAllObjectsToSpawnCount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FObjectToSpawnCount>      ObjectsToSpawnCount                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UPrivateLobbySubsystem::SetAllObjectsToSpawnCount(const TArray<struct FObjectToSpawnCount>& ObjectsToSpawnCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "SetAllObjectsToSpawnCount");

	Params::PrivateLobbySubsystem_SetAllObjectsToSpawnCount Parms{};

	Parms.ObjectsToSpawnCount = std::move(ObjectsToSpawnCount);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PrivateLobbySubsystem.SetLobbyBotsAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   BotsAmount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrivateLobbySubsystem::SetLobbyBotsAmount(int32 BotsAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "SetLobbyBotsAmount");

	Params::PrivateLobbySubsystem_SetLobbyBotsAmount Parms{};

	Parms.BotsAmount = BotsAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PrivateLobbySubsystem.SetLobbyBotsDifficulty
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EBotsDifficulty                         BotsDifficulty                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrivateLobbySubsystem::SetLobbyBotsDifficulty(EBotsDifficulty BotsDifficulty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "SetLobbyBotsDifficulty");

	Params::PrivateLobbySubsystem_SetLobbyBotsDifficulty Parms{};

	Parms.BotsDifficulty = BotsDifficulty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PrivateLobbySubsystem.SetLobbyFillWithBots
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFillWithBots                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrivateLobbySubsystem::SetLobbyFillWithBots(bool bFillWithBots)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "SetLobbyFillWithBots");

	Params::PrivateLobbySubsystem_SetLobbyFillWithBots Parms{};

	Parms.bFillWithBots = bFillWithBots;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PrivateLobbySubsystem.SetLobbyGameMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDIGameMode                             NewGameMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrivateLobbySubsystem::SetLobbyGameMode(EDIGameMode NewGameMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "SetLobbyGameMode");

	Params::PrivateLobbySubsystem_SetLobbyGameMode Parms{};

	Parms.NewGameMode = NewGameMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PrivateLobbySubsystem.SetLobbyHeatSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FHeatSetupData                   HeatSettings                                           (Parm, NativeAccessSpecifierPublic)

void UPrivateLobbySubsystem::SetLobbyHeatSettings(const struct FHeatSetupData& HeatSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "SetLobbyHeatSettings");

	Params::PrivateLobbySubsystem_SetLobbyHeatSettings Parms{};

	Parms.HeatSettings = std::move(HeatSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PrivateLobbySubsystem.SetLobbyOperationMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMapData*                         NewOperationMapData                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrivateLobbySubsystem::SetLobbyOperationMap(class UMapData* NewOperationMapData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "SetLobbyOperationMap");

	Params::PrivateLobbySubsystem_SetLobbyOperationMap Parms{};

	Parms.NewOperationMapData = NewOperationMapData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PrivateLobbySubsystem.SetLobbySandboxMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSandboxMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrivateLobbySubsystem::SetLobbySandboxMode(bool bSandboxMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "SetLobbySandboxMode");

	Params::PrivateLobbySubsystem_SetLobbySandboxMode Parms{};

	Parms.bSandboxMode = bSandboxMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PrivateLobbySubsystem.SetNPCPopulation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           NPCPopulation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UPrivateLobbySubsystem::SetNPCPopulation(const TArray<int32>& NPCPopulation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "SetNPCPopulation");

	Params::PrivateLobbySubsystem_SetNPCPopulation Parms{};

	Parms.NPCPopulation = std::move(NPCPopulation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PrivateLobbySubsystem.SetNPCPopulationByPool
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NPCPool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NPCAmount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrivateLobbySubsystem::SetNPCPopulationByPool(int32 NPCPool, int32 NPCAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "SetNPCPopulationByPool");

	Params::PrivateLobbySubsystem_SetNPCPopulationByPool Parms{};

	Parms.NPCPool = NPCPool;
	Parms.NPCAmount = NPCAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PrivateLobbySubsystem.SetObjectsToSpawnCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FObjectToSpawnCount              ObjectsToSpawnCount                                    (Parm, NativeAccessSpecifierPublic)

void UPrivateLobbySubsystem::SetObjectsToSpawnCount(const struct FObjectToSpawnCount& ObjectsToSpawnCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "SetObjectsToSpawnCount");

	Params::PrivateLobbySubsystem_SetObjectsToSpawnCount Parms{};

	Parms.ObjectsToSpawnCount = std::move(ObjectsToSpawnCount);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PrivateLobbySubsystem.SetSelectedRegionIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewSelectedRegion                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrivateLobbySubsystem::SetSelectedRegionIndex(int32 NewSelectedRegion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "SetSelectedRegionIndex");

	Params::PrivateLobbySubsystem_SetSelectedRegionIndex Parms{};

	Parms.NewSelectedRegion = NewSelectedRegion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PrivateLobbySubsystem.StartPrivateLobbyMatchmaking
// (Final, Native, Public, BlueprintCallable)

void UPrivateLobbySubsystem::StartPrivateLobbyMatchmaking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "StartPrivateLobbyMatchmaking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PrivateLobbySubsystem.TrySetTeamForLocaPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TeamIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrivateLobbySubsystem::TrySetTeamForLocaPlayer(int32 TeamIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "TrySetTeamForLocaPlayer");

	Params::PrivateLobbySubsystem_TrySetTeamForLocaPlayer Parms{};

	Parms.TeamIndex = TeamIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PrivateLobbySubsystem.TrySetTeamForPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDIOnlinePartyMemberInfo*         Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TeamIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrivateLobbySubsystem::TrySetTeamForPlayer(class UDIOnlinePartyMemberInfo* Player, int32 TeamIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "TrySetTeamForPlayer");

	Params::PrivateLobbySubsystem_TrySetTeamForPlayer Parms{};

	Parms.Player = Player;
	Parms.TeamIndex = TeamIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PrivateLobbySubsystem.CanLocalPlayerEditLobbyData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrivateLobbySubsystem::CanLocalPlayerEditLobbyData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "CanLocalPlayerEditLobbyData");

	Params::PrivateLobbySubsystem_CanLocalPlayerEditLobbyData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PrivateLobbySubsystem.GetAssignedMembers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UDIOnlinePartyMemberInfo*> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UDIOnlinePartyMemberInfo*> UPrivateLobbySubsystem::GetAssignedMembers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "GetAssignedMembers");

	Params::PrivateLobbySubsystem_GetAssignedMembers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PrivateLobbySubsystem.GetAvailableOperationMaps
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UMapData*>                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UMapData*> UPrivateLobbySubsystem::GetAvailableOperationMaps() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "GetAvailableOperationMaps");

	Params::PrivateLobbySubsystem_GetAvailableOperationMaps Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PrivateLobbySubsystem.GetAvailableRegions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UPrivateLobbySubsystem::GetAvailableRegions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "GetAvailableRegions");

	Params::PrivateLobbySubsystem_GetAvailableRegions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PrivateLobbySubsystem.GetHeatSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FHeatSetupData                   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FHeatSetupData UPrivateLobbySubsystem::GetHeatSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "GetHeatSettings");

	Params::PrivateLobbySubsystem_GetHeatSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PrivateLobbySubsystem.GetLobbyGameMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDIGameMode                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDIGameMode UPrivateLobbySubsystem::GetLobbyGameMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "GetLobbyGameMode");

	Params::PrivateLobbySubsystem_GetLobbyGameMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PrivateLobbySubsystem.GetLobbyOperationMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMapData*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMapData* UPrivateLobbySubsystem::GetLobbyOperationMap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "GetLobbyOperationMap");

	Params::PrivateLobbySubsystem_GetLobbyOperationMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PrivateLobbySubsystem.GetNPCPopulation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UPrivateLobbySubsystem::GetNPCPopulation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "GetNPCPopulation");

	Params::PrivateLobbySubsystem_GetNPCPopulation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PrivateLobbySubsystem.GetNPCPopulationByType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   NPCPool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPrivateLobbySubsystem::GetNPCPopulationByType(int32 NPCPool) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "GetNPCPopulationByType");

	Params::PrivateLobbySubsystem_GetNPCPopulationByType Parms{};

	Parms.NPCPool = NPCPool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PrivateLobbySubsystem.GetObjectsToSpawnCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FObjectToSpawnCount>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FObjectToSpawnCount> UPrivateLobbySubsystem::GetObjectsToSpawnCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "GetObjectsToSpawnCount");

	Params::PrivateLobbySubsystem_GetObjectsToSpawnCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PrivateLobbySubsystem.GetObjectsToSpawnCountByObjectType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ObjectType                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FObjectToSpawnCount              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FObjectToSpawnCount UPrivateLobbySubsystem::GetObjectsToSpawnCountByObjectType(const class FString& ObjectType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "GetObjectsToSpawnCountByObjectType");

	Params::PrivateLobbySubsystem_GetObjectsToSpawnCountByObjectType Parms{};

	Parms.ObjectType = std::move(ObjectType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PrivateLobbySubsystem.GetPartyMembers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UDIOnlinePartyMemberInfo*> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UDIOnlinePartyMemberInfo*> UPrivateLobbySubsystem::GetPartyMembers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "GetPartyMembers");

	Params::PrivateLobbySubsystem_GetPartyMembers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PrivateLobbySubsystem.GetPartyMembersForTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   TeamIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UDIOnlinePartyMemberInfo*> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UDIOnlinePartyMemberInfo*> UPrivateLobbySubsystem::GetPartyMembersForTeam(int32 TeamIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "GetPartyMembersForTeam");

	Params::PrivateLobbySubsystem_GetPartyMembersForTeam Parms{};

	Parms.TeamIndex = TeamIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PrivateLobbySubsystem.GetSelectedRegion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UPrivateLobbySubsystem::GetSelectedRegion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "GetSelectedRegion");

	Params::PrivateLobbySubsystem_GetSelectedRegion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PrivateLobbySubsystem.GetSelectedRegionIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPrivateLobbySubsystem::GetSelectedRegionIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "GetSelectedRegionIndex");

	Params::PrivateLobbySubsystem_GetSelectedRegionIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PrivateLobbySubsystem.GetSpectatingMembers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UDIOnlinePartyMemberInfo*> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UDIOnlinePartyMemberInfo*> UPrivateLobbySubsystem::GetSpectatingMembers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "GetSpectatingMembers");

	Params::PrivateLobbySubsystem_GetSpectatingMembers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PrivateLobbySubsystem.GetTeamForPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIOnlinePartyMemberInfo*         Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPrivateLobbySubsystem::GetTeamForPlayer(class UDIOnlinePartyMemberInfo* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "GetTeamForPlayer");

	Params::PrivateLobbySubsystem_GetTeamForPlayer Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PrivateLobbySubsystem.GetUnassignedMembers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UDIOnlinePartyMemberInfo*> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UDIOnlinePartyMemberInfo*> UPrivateLobbySubsystem::GetUnassignedMembers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrivateLobbySubsystem", "GetUnassignedMembers");

	Params::PrivateLobbySubsystem_GetUnassignedMembers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ChavezPassiveAbilityMod2.HandleConfirmedDamageDealt
// (Final, Native, Protected)
// Parameters:
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChavezPassiveAbilityMod2::HandleConfirmedDamageDealt(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChavezPassiveAbilityMod2", "HandleConfirmedDamageDealt");

	Params::ChavezPassiveAbilityMod2_HandleConfirmedDamageDealt Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.Damage = Damage;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChavezPassiveAbilityMod2.HandleHealthChanged
// (Final, Native, Protected)
// Parameters:
// class UHealthComponent*                 OwningHealthComp                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Health                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HealthDelta                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RawDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChavezPassiveAbilityMod2::HandleHealthChanged(class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, float RawDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChavezPassiveAbilityMod2", "HandleHealthChanged");

	Params::ChavezPassiveAbilityMod2_HandleHealthChanged Parms{};

	Parms.OwningHealthComp = OwningHealthComp;
	Parms.Health = Health;
	Parms.HealthDelta = HealthDelta;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.RawDamage = RawDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChavezPassiveAbilityMod2.MulticastDamageTaken
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChavezPassiveAbilityMod2::MulticastDamageTaken(class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChavezPassiveAbilityMod2", "MulticastDamageTaken");

	Params::ChavezPassiveAbilityMod2_MulticastDamageTaken Parms{};

	Parms.Spy = Spy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChavezPassiveAbilityMod2.MulticastHeal
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// float                                   HealAmount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChavezPassiveAbilityMod2::MulticastHeal(float HealAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChavezPassiveAbilityMod2", "MulticastHeal");

	Params::ChavezPassiveAbilityMod2_MulticastHeal Parms{};

	Parms.HealAmount = HealAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.RevivePartyComponent.GetFailureCause
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ERevivePartyFailedCause                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERevivePartyFailedCause URevivePartyComponent::GetFailureCause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RevivePartyComponent", "GetFailureCause");

	Params::RevivePartyComponent_GetFailureCause Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.RevivePartyComponent.HandleInteractionBegin
// (Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URevivePartyComponent::HandleInteractionBegin(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RevivePartyComponent", "HandleInteractionBegin");

	Params::RevivePartyComponent_HandleInteractionBegin Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.RevivePartyComponent.HandleInteractionCancel
// (Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URevivePartyComponent::HandleInteractionCancel(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RevivePartyComponent", "HandleInteractionCancel");

	Params::RevivePartyComponent_HandleInteractionCancel Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.RevivePartyComponent.HandleInteractionComplete
// (Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URevivePartyComponent::HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RevivePartyComponent", "HandleInteractionComplete");

	Params::RevivePartyComponent_HandleInteractionComplete Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChromaticFeedbackSubsystem.AddEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           EffectNameToPlay                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EChromaticFeedbackPriority              Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoop                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHighlightMappedKeys                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChromaticFeedbackSubsystem::AddEffect(const class FString& EffectNameToPlay, EChromaticFeedbackPriority Priority, bool bLoop, bool bHighlightMappedKeys)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChromaticFeedbackSubsystem", "AddEffect");

	Params::ChromaticFeedbackSubsystem_AddEffect Parms{};

	Parms.EffectNameToPlay = std::move(EffectNameToPlay);
	Parms.Priority = Priority;
	Parms.bLoop = bLoop;
	Parms.bHighlightMappedKeys = bHighlightMappedKeys;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChromaticFeedbackSubsystem.EnableChromaticFeedback
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChromaticFeedbackSubsystem::EnableChromaticFeedback(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChromaticFeedbackSubsystem", "EnableChromaticFeedback");

	Params::ChromaticFeedbackSubsystem_EnableChromaticFeedback Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChromaticFeedbackSubsystem.HandleAnimationStop
// (Final, Native, Protected)

void UChromaticFeedbackSubsystem::HandleAnimationStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChromaticFeedbackSubsystem", "HandleAnimationStop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChromaticFeedbackSubsystem.HandleBooleanPlayerSettingChange
// (Final, Native, Protected)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChromaticFeedbackSubsystem::HandleBooleanPlayerSettingChange(EPlayerSettingsType SettingType, bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChromaticFeedbackSubsystem", "HandleBooleanPlayerSettingChange");

	Params::ChromaticFeedbackSubsystem_HandleBooleanPlayerSettingChange Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChromaticFeedbackSubsystem.RemoveEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           EffectNameToRemove                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EChromaticFeedbackPriority              Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChromaticFeedbackSubsystem::RemoveEffect(const class FString& EffectNameToRemove, EChromaticFeedbackPriority Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChromaticFeedbackSubsystem", "RemoveEffect");

	Params::ChromaticFeedbackSubsystem_RemoveEffect Parms{};

	Parms.EffectNameToRemove = std::move(EffectNameToRemove);
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChromaticFeedbackSubsystem.RemoveEffectAtPriority
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EChromaticFeedbackPriority              Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChromaticFeedbackSubsystem::RemoveEffectAtPriority(EChromaticFeedbackPriority Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChromaticFeedbackSubsystem", "RemoveEffectAtPriority");

	Params::ChromaticFeedbackSubsystem_RemoveEffectAtPriority Parms{};

	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChromaticFeedbackSubsystem.StartEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EChromaFeedbackEventType                EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChromaticFeedbackSubsystem::StartEvent(EChromaFeedbackEventType EventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChromaticFeedbackSubsystem", "StartEvent");

	Params::ChromaticFeedbackSubsystem_StartEvent Parms{};

	Parms.EventType = EventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ChromaticFeedbackSubsystem.StopEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EChromaFeedbackEventType                EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChromaticFeedbackSubsystem::StopEvent(EChromaFeedbackEventType EventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChromaticFeedbackSubsystem", "StopEvent");

	Params::ChromaticFeedbackSubsystem_StopEvent Parms{};

	Parms.EventType = EventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ClientInformation.GetBuildChangelist
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UClientInformation::GetBuildChangelist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ClientInformation", "GetBuildChangelist");

	Params::ClientInformation_GetBuildChangelist Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ClientInformation.GetBuildClientBranch
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UClientInformation::GetBuildClientBranch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ClientInformation", "GetBuildClientBranch");

	Params::ClientInformation_GetBuildClientBranch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ClientInformation.GetBuildVersion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UClientInformation::GetBuildVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ClientInformation", "GetBuildVersion");

	Params::ClientInformation_GetBuildVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.CooldownComponent.CancelCooldownMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void UCooldownComponent::CancelCooldownMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CooldownComponent", "CancelCooldownMulticast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CooldownComponent.OnRep_CooldownRefunded
// (Final, Native, Protected)

void UCooldownComponent::OnRep_CooldownRefunded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CooldownComponent", "OnRep_CooldownRefunded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CooldownComponent.OnRep_ServerCooldownEndTime
// (Final, Native, Protected)
// Parameters:
// float                                   PreviousServerCooldownEndTime                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCooldownComponent::OnRep_ServerCooldownEndTime(float PreviousServerCooldownEndTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CooldownComponent", "OnRep_ServerCooldownEndTime");

	Params::CooldownComponent_OnRep_ServerCooldownEndTime Parms{};

	Parms.PreviousServerCooldownEndTime = PreviousServerCooldownEndTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.CooldownComponent.GetCooldownDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCooldownComponent::GetCooldownDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CooldownComponent", "GetCooldownDuration");

	Params::CooldownComponent_GetCooldownDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.CooldownComponent.GetCooldownRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCooldownComponent::GetCooldownRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CooldownComponent", "GetCooldownRatio");

	Params::CooldownComponent_GetCooldownRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.CooldownComponent.GetCooldownTimeLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCooldownComponent::GetCooldownTimeLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CooldownComponent", "GetCooldownTimeLeft");

	Params::CooldownComponent_GetCooldownTimeLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.CooldownComponent.IsOnCooldown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCooldownComponent::IsOnCooldown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CooldownComponent", "IsOnCooldown");

	Params::CooldownComponent_IsOnCooldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ReplicatedDebugDraws.NetMulticast_DrawDebugAACross
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// struct FVector                          CrossCenter                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CrossSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           Color                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPersistentLines                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   DepthPriority                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReplicatedDebugDraws::NetMulticast_DrawDebugAACross(const struct FVector& CrossCenter, float CrossSize, const struct FColor& Color, bool bPersistentLines, float Lifetime, uint8 DepthPriority, float Thickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReplicatedDebugDraws", "NetMulticast_DrawDebugAACross");

	Params::ReplicatedDebugDraws_NetMulticast_DrawDebugAACross Parms{};

	Parms.CrossCenter = std::move(CrossCenter);
	Parms.CrossSize = CrossSize;
	Parms.Color = std::move(Color);
	Parms.bPersistentLines = bPersistentLines;
	Parms.Lifetime = Lifetime;
	Parms.DepthPriority = DepthPriority;
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ReplicatedDebugDraws.NetMulticast_DrawDebugLine
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// struct FVector                          LineStart                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LineEnd                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           Color                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPersistentLines                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   DepthPriority                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReplicatedDebugDraws::NetMulticast_DrawDebugLine(const struct FVector& LineStart, const struct FVector& LineEnd, const struct FColor& Color, bool bPersistentLines, float Lifetime, uint8 DepthPriority, float Thickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReplicatedDebugDraws", "NetMulticast_DrawDebugLine");

	Params::ReplicatedDebugDraws_NetMulticast_DrawDebugLine Parms{};

	Parms.LineStart = std::move(LineStart);
	Parms.LineEnd = std::move(LineEnd);
	Parms.Color = std::move(Color);
	Parms.bPersistentLines = bPersistentLines;
	Parms.Lifetime = Lifetime;
	Parms.DepthPriority = DepthPriority;
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DamageAoEActor.BP_OnDoDamageToActor
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           ActorToDamage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADamageAoEActor::BP_OnDoDamageToActor(class AActor* ActorToDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageAoEActor", "BP_OnDoDamageToActor");

	Params::DamageAoEActor_BP_OnDoDamageToActor Parms{};

	Parms.ActorToDamage = ActorToDamage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.DamageAoEActor.NetMulticast_OnDoDamage
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           ActorToDamage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADamageAoEActor::NetMulticast_OnDoDamage(class AActor* ActorToDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageAoEActor", "NetMulticast_OnDoDamage");

	Params::DamageAoEActor_NetMulticast_OnDoDamage Parms{};

	Parms.ActorToDamage = ActorToDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.OctoDrainingActiveAbility.BP_OnLocalAlliedOctoPlayerDrainedAnotherPlayer
// (Event, Public, BlueprintEvent)

void AOctoDrainingActiveAbility::BP_OnLocalAlliedOctoPlayerDrainedAnotherPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoDrainingActiveAbility", "BP_OnLocalAlliedOctoPlayerDrainedAnotherPlayer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.OctoDrainingActiveAbility.BP_OnLocalAlliedPlayerDrainingChange
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bDraining                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOctoDrainingActiveAbility::BP_OnLocalAlliedPlayerDrainingChange(bool bDraining)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoDrainingActiveAbility", "BP_OnLocalAlliedPlayerDrainingChange");

	Params::OctoDrainingActiveAbility_BP_OnLocalAlliedPlayerDrainingChange Parms{};

	Parms.bDraining = bDraining;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.OctoDrainingActiveAbility.BP_OnLocalOctoPlayerDrainedAnotherPlayer
// (Event, Public, BlueprintEvent)

void AOctoDrainingActiveAbility::BP_OnLocalOctoPlayerDrainedAnotherPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoDrainingActiveAbility", "BP_OnLocalOctoPlayerDrainedAnotherPlayer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.OctoDrainingActiveAbility.BP_OnLocalPlayerDrainingChange
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bDraining                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOctoDrainingActiveAbility::BP_OnLocalPlayerDrainingChange(bool bDraining)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoDrainingActiveAbility", "BP_OnLocalPlayerDrainingChange");

	Params::OctoDrainingActiveAbility_BP_OnLocalPlayerDrainingChange Parms{};

	Parms.bDraining = bDraining;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.OctoDrainingActiveAbility.BP_OnLocalVictimPlayerBeingDrainedChange
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bDrained                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseIntelActor*                  BeingDrainedByHackableIntel                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOctoDrainingActiveAbility::BP_OnLocalVictimPlayerBeingDrainedChange(bool bDrained, class ABaseIntelActor* BeingDrainedByHackableIntel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoDrainingActiveAbility", "BP_OnLocalVictimPlayerBeingDrainedChange");

	Params::OctoDrainingActiveAbility_BP_OnLocalVictimPlayerBeingDrainedChange Parms{};

	Parms.bDrained = bDrained;
	Parms.BeingDrainedByHackableIntel = BeingDrainedByHackableIntel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.OctoDrainingActiveAbility.BP_OnLocalVictimPlayerDrained
// (Event, Public, BlueprintEvent)
// Parameters:
// class ABaseIntelActor*                  DrainedByHackableIntel                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOctoDrainingActiveAbility::BP_OnLocalVictimPlayerDrained(class ABaseIntelActor* DrainedByHackableIntel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoDrainingActiveAbility", "BP_OnLocalVictimPlayerDrained");

	Params::OctoDrainingActiveAbility_BP_OnLocalVictimPlayerDrained Parms{};

	Parms.DrainedByHackableIntel = DrainedByHackableIntel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.OctoDrainingActiveAbility.NetMulticast_NotifyPlayerBeingDrained
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ASpy*                             PlayerBeingDrained                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseIntelActor*                  DrainedByHackableIntel                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDrained                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOctoDrainingActiveAbility::NetMulticast_NotifyPlayerBeingDrained(class ASpy* PlayerBeingDrained, class ABaseIntelActor* DrainedByHackableIntel, bool bDrained)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoDrainingActiveAbility", "NetMulticast_NotifyPlayerBeingDrained");

	Params::OctoDrainingActiveAbility_NetMulticast_NotifyPlayerBeingDrained Parms{};

	Parms.PlayerBeingDrained = PlayerBeingDrained;
	Parms.DrainedByHackableIntel = DrainedByHackableIntel;
	Parms.bDrained = bDrained;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.OctoDrainingActiveAbility.NetMulticast_NotifyPlayerDrained
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ASpy*                             PlayerDrained                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseIntelActor*                  DrainedByHackableIntel                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOctoDrainingActiveAbility::NetMulticast_NotifyPlayerDrained(class ASpy* PlayerDrained, class ABaseIntelActor* DrainedByHackableIntel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoDrainingActiveAbility", "NetMulticast_NotifyPlayerDrained");

	Params::OctoDrainingActiveAbility_NetMulticast_NotifyPlayerDrained Parms{};

	Parms.PlayerDrained = PlayerDrained;
	Parms.DrainedByHackableIntel = DrainedByHackableIntel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.OctoDrainingActiveAbility.OnDrainTimerEnd
// (Final, Native, Protected)

void AOctoDrainingActiveAbility::OnDrainTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoDrainingActiveAbility", "OnDrainTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.OctoDrainingActiveAbility.OnRep_DrainingSomeone
// (Final, Native, Protected)

void AOctoDrainingActiveAbility::OnRep_DrainingSomeone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoDrainingActiveAbility", "OnRep_DrainingSomeone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.OctoActiveAbilityMod1.OnAffectedHackableHacked
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseIntelActor*                  IntelActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ResourceAmount                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOctoActiveAbilityMod1::OnAffectedHackableHacked(class ASpy* Spy, class ABaseIntelActor* IntelActor, EGameplayResourcesType ResourceType, int32 ResourceAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoActiveAbilityMod1", "OnAffectedHackableHacked");

	Params::OctoActiveAbilityMod1_OnAffectedHackableHacked Parms{};

	Parms.Spy = Spy;
	Parms.IntelActor = IntelActor;
	Parms.ResourceType = ResourceType;
	Parms.ResourceAmount = ResourceAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.OctoActiveAbilityMod1.OnHackedIntel
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseIntelActor*                  IntelActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ResourceAmount                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOctoActiveAbilityMod1::OnHackedIntel(class ASpy* Spy, class ABaseIntelActor* IntelActor, EGameplayResourcesType ResourceType, int32 ResourceAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoActiveAbilityMod1", "OnHackedIntel");

	Params::OctoActiveAbilityMod1_OnHackedIntel Parms{};

	Parms.Spy = Spy;
	Parms.IntelActor = IntelActor;
	Parms.ResourceType = ResourceType;
	Parms.ResourceAmount = ResourceAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.OctoActiveAbilityMod1.GetCurrentHackingZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AOctoHackingZone*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOctoHackingZone* AOctoActiveAbilityMod1::GetCurrentHackingZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoActiveAbilityMod1", "GetCurrentHackingZone");

	Params::OctoActiveAbilityMod1_GetCurrentHackingZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DebugFreezeSubsystem.OnNextFrameTimerEnd
// (Final, Native, Public)

void UDebugFreezeSubsystem::OnNextFrameTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugFreezeSubsystem", "OnNextFrameTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SasoriBaseActiveAbility.HandleInteractionComplete
// (Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASasoriBaseActiveAbility::HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SasoriBaseActiveAbility", "HandleInteractionComplete");

	Params::SasoriBaseActiveAbility_HandleInteractionComplete Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SasoriActiveAbilityMod1.HandleProjectileEndPlay
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndPlayReason                          EndPlayReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASasoriActiveAbilityMod1::HandleProjectileEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SasoriActiveAbilityMod1", "HandleProjectileEndPlay");

	Params::SasoriActiveAbilityMod1_HandleProjectileEndPlay Parms{};

	Parms.Actor = Actor;
	Parms.EndPlayReason = EndPlayReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SasoriActiveAbilityMod1.HandleShootDelayEnd
// (Final, Native, Protected)

void ASasoriActiveAbilityMod1::HandleShootDelayEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SasoriActiveAbilityMod1", "HandleShootDelayEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SasoriActiveAbilityMod1.MulticastFireShot
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FVector_NetQuantize              DestinationPos                                         (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASasoriActiveAbilityMod1::MulticastFireShot(const struct FVector_NetQuantize& DestinationPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SasoriActiveAbilityMod1", "MulticastFireShot");

	Params::SasoriActiveAbilityMod1_MulticastFireShot Parms{};

	Parms.DestinationPos = std::move(DestinationPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SasoriActiveAbilityMod1.NotifyAnimSwitchAwayFrom
// (Final, Native, Public, BlueprintCallable)

void ASasoriActiveAbilityMod1::NotifyAnimSwitchAwayFrom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SasoriActiveAbilityMod1", "NotifyAnimSwitchAwayFrom");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SasoriActiveAbilityMod1.ShootVialServer
// (Net, NetReliable, Native, Event, Protected, NetServer)

void ASasoriActiveAbilityMod1::ShootVialServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SasoriActiveAbilityMod1", "ShootVialServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VaultLockedPhaseInfo.GetObjectiveDesc
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UVaultLockedPhaseInfo::GetObjectiveDesc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultLockedPhaseInfo", "GetObjectiveDesc");

	Params::VaultLockedPhaseInfo_GetObjectiveDesc Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VaultUnlockedPhaseInfo.GetObjectiveDescInsideVault
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UVaultUnlockedPhaseInfo::GetObjectiveDescInsideVault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultUnlockedPhaseInfo", "GetObjectiveDescInsideVault");

	Params::VaultUnlockedPhaseInfo_GetObjectiveDescInsideVault Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VaultUnlockedPhaseInfo.GetObjectiveDescOutsideVault
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UVaultUnlockedPhaseInfo::GetObjectiveDescOutsideVault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultUnlockedPhaseInfo", "GetObjectiveDescOutsideVault");

	Params::VaultUnlockedPhaseInfo_GetObjectiveDescOutsideVault Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ExtractionArrivedPhaseInfo.GetObjectiveDescCarrier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UExtractionArrivedPhaseInfo::GetObjectiveDescCarrier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionArrivedPhaseInfo", "GetObjectiveDescCarrier");

	Params::ExtractionArrivedPhaseInfo_GetObjectiveDescCarrier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ExtractionArrivedPhaseInfo.GetObjectiveDescNonCarrier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UExtractionArrivedPhaseInfo::GetObjectiveDescNonCarrier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionArrivedPhaseInfo", "GetObjectiveDescNonCarrier");

	Params::ExtractionArrivedPhaseInfo_GetObjectiveDescNonCarrier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ExtractionArrivedPhaseInfo.GetObjectiveDescNonCarrierTeammate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UExtractionArrivedPhaseInfo::GetObjectiveDescNonCarrierTeammate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionArrivedPhaseInfo", "GetObjectiveDescNonCarrierTeammate");

	Params::ExtractionArrivedPhaseInfo_GetObjectiveDescNonCarrierTeammate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameModeBase.ClearPS5MatchId
// (Final, Exec, Native, Public)

void ADeceiveIncGameModeBase::ClearPS5MatchId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameModeBase", "ClearPS5MatchId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameModeBase.ClearPS5MatchResponsiblePlayer
// (Final, Exec, Native, Public)

void ADeceiveIncGameModeBase::ClearPS5MatchResponsiblePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameModeBase", "ClearPS5MatchResponsiblePlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameModeBase.EAC_Heartbeat
// (Final, Native, Public)

void ADeceiveIncGameModeBase::EAC_Heartbeat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameModeBase", "EAC_Heartbeat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameModeBase.OnSpawnBotPlayerTimerEnd
// (Final, Native, Protected)

void ADeceiveIncGameModeBase::OnSpawnBotPlayerTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameModeBase", "OnSpawnBotPlayerTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameModeBase.SetGeneralVoicechatEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncGameModeBase::SetGeneralVoicechatEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameModeBase", "SetGeneralVoicechatEnabled");

	Params::DeceiveIncGameModeBase_SetGeneralVoicechatEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameModeBase.SetPS5MatchId
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           NewPS5MatchId                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncGameModeBase::SetPS5MatchId(const class FString& NewPS5MatchId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameModeBase", "SetPS5MatchId");

	Params::DeceiveIncGameModeBase_SetPS5MatchId Parms{};

	Parms.NewPS5MatchId = std::move(NewPS5MatchId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameModeBase.SetPS5MatchResponsiblePlayer
// (Final, Exec, Native, Public)
// Parameters:
// class ADIPlayerState*                   NewPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncGameModeBase::SetPS5MatchResponsiblePlayer(class ADIPlayerState* NewPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameModeBase", "SetPS5MatchResponsiblePlayer");

	Params::DeceiveIncGameModeBase_SetPS5MatchResponsiblePlayer Parms{};

	Parms.NewPlayerState = NewPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameModeBase.SetSpawningRule
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESpawningRule                           NewRule                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncGameModeBase::SetSpawningRule(ESpawningRule NewRule)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameModeBase", "SetSpawningRule");

	Params::DeceiveIncGameModeBase_SetSpawningRule Parms{};

	Parms.NewRule = NewRule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameModeBase.UpdatePS5MatchResponsibility
// (Final, Exec, Native, Public)
// Parameters:
// class APlayerController*                ExcludePlayer                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncGameModeBase::UpdatePS5MatchResponsibility(class APlayerController* ExcludePlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameModeBase", "UpdatePS5MatchResponsibility");

	Params::DeceiveIncGameModeBase_UpdatePS5MatchResponsibility Parms{};

	Parms.ExcludePlayer = ExcludePlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncGameModeBase.GetAllActiveSpies
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ASpy*>                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class ASpy*> ADeceiveIncGameModeBase::GetAllActiveSpies() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameModeBase", "GetAllActiveSpies");

	Params::DeceiveIncGameModeBase_GetAllActiveSpies Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameModeBase.GetSpawningRule
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESpawningRule                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESpawningRule ADeceiveIncGameModeBase::GetSpawningRule() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameModeBase", "GetSpawningRule");

	Params::DeceiveIncGameModeBase_GetSpawningRule Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncGameModeBase.IsGeneralVoicechatEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncGameModeBase::IsGeneralVoicechatEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncGameModeBase", "IsGeneralVoicechatEnabled");

	Params::DeceiveIncGameModeBase_IsGeneralVoicechatEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerController.Client_AgentSelectionFailed
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// ESelectionValidationResult              Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  RecommendedAgentId                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::Client_AgentSelectionFailed(ESelectionValidationResult Reason, const struct FPrimaryAssetId& RecommendedAgentId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "Client_AgentSelectionFailed");

	Params::DeceiveIncPlayerController_Client_AgentSelectionFailed Parms{};

	Parms.Reason = Reason;
	Parms.RecommendedAgentId = std::move(RecommendedAgentId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.Client_IncomingEACMessage
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// TArray<uint8>                           Data                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           SourceId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           TargetId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::Client_IncomingEACMessage(const TArray<uint8>& Data, const class FString& SourceId, const class FString& TargetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "Client_IncomingEACMessage");

	Params::DeceiveIncPlayerController_Client_IncomingEACMessage Parms{};

	Parms.Data = std::move(Data);
	Parms.SourceId = std::move(SourceId);
	Parms.TargetId = std::move(TargetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.Client_JoinVoiceChannel
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           ChannelName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ChannelCredentials                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::Client_JoinVoiceChannel(const class FString& ChannelName, const class FString& ChannelCredentials)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "Client_JoinVoiceChannel");

	Params::DeceiveIncPlayerController_Client_JoinVoiceChannel Parms{};

	Parms.ChannelName = std::move(ChannelName);
	Parms.ChannelCredentials = std::move(ChannelCredentials);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.ClientAttemptSetupKillcam
// (Net, NetReliable, Native, Event, Public, NetClient)

void ADeceiveIncPlayerController::ClientAttemptSetupKillcam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "ClientAttemptSetupKillcam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.ClientKillcamTimeout
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    bTriggerSetup                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::ClientKillcamTimeout(bool bTriggerSetup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "ClientKillcamTimeout");

	Params::DeceiveIncPlayerController_ClientKillcamTimeout Parms{};

	Parms.bTriggerSetup = bTriggerSetup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.ClientRecordKillcamFocusData
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                     InPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::ClientRecordKillcamFocusData(class AActor* InActor, class APlayerState* InPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "ClientRecordKillcamFocusData");

	Params::DeceiveIncPlayerController_ClientRecordKillcamFocusData Parms{};

	Parms.InActor = InActor;
	Parms.InPlayerState = InPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.ClientReportServerTime
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// float                                   RequestWorldTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ServerTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::ClientReportServerTime(float RequestWorldTime, float ServerTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "ClientReportServerTime");

	Params::DeceiveIncPlayerController_ClientReportServerTime Parms{};

	Parms.RequestWorldTime = RequestWorldTime;
	Parms.ServerTime = ServerTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.ClientStartKillcam
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// float                                   TimeToRewind                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ServerTimestamp                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::ClientStartKillcam(float TimeToRewind, float ServerTimestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "ClientStartKillcam");

	Params::DeceiveIncPlayerController_ClientStartKillcam Parms{};

	Parms.TimeToRewind = TimeToRewind;
	Parms.ServerTimestamp = ServerTimestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.DEBUG_Randomize_CallingCardSelection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCommitSelectionToSavegame                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::DEBUG_Randomize_CallingCardSelection(bool bCommitSelectionToSavegame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "DEBUG_Randomize_CallingCardSelection");

	Params::DeceiveIncPlayerController_DEBUG_Randomize_CallingCardSelection Parms{};

	Parms.bCommitSelectionToSavegame = bCommitSelectionToSavegame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.DEBUG_Randomize_CharacterSelection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCommitSelectionToSavegame                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::DEBUG_Randomize_CharacterSelection(bool bCommitSelectionToSavegame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "DEBUG_Randomize_CharacterSelection");

	Params::DeceiveIncPlayerController_DEBUG_Randomize_CharacterSelection Parms{};

	Parms.bCommitSelectionToSavegame = bCommitSelectionToSavegame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.DEBUG_Randomize_GadgetSelection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCommitSelectionToSavegame                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::DEBUG_Randomize_GadgetSelection(bool bCommitSelectionToSavegame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "DEBUG_Randomize_GadgetSelection");

	Params::DeceiveIncPlayerController_DEBUG_Randomize_GadgetSelection Parms{};

	Parms.bCommitSelectionToSavegame = bCommitSelectionToSavegame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.DEBUG_Randomize_Powerups
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCommitSelectionToSavegame                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::DEBUG_Randomize_Powerups(bool bCommitSelectionToSavegame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "DEBUG_Randomize_Powerups");

	Params::DeceiveIncPlayerController_DEBUG_Randomize_Powerups Parms{};

	Parms.bCommitSelectionToSavegame = bCommitSelectionToSavegame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.DEBUG_Randomize_ProfileSelection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCommitSelectionToSavegame                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::DEBUG_Randomize_ProfileSelection(bool bCommitSelectionToSavegame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "DEBUG_Randomize_ProfileSelection");

	Params::DeceiveIncPlayerController_DEBUG_Randomize_ProfileSelection Parms{};

	Parms.bCommitSelectionToSavegame = bCommitSelectionToSavegame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.ForceKillcam
// (Final, Exec, Native, Public)

void ADeceiveIncPlayerController::ForceKillcam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "ForceKillcam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.ForceKillcamFlow
// (Final, Exec, Native, Public)

void ADeceiveIncPlayerController::ForceKillcamFlow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "ForceKillcamFlow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.GetAgentId
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId ADeceiveIncPlayerController::GetAgentId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "GetAgentId");

	Params::DeceiveIncPlayerController_GetAgentId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerController.GetAliveTeammates
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class ADIPlayerState*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADIPlayerState*> ADeceiveIncPlayerController::GetAliveTeammates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "GetAliveTeammates");

	Params::DeceiveIncPlayerController_GetAliveTeammates Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerController.GetKillcamViewTargetInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADIPlayerState*                   DIPlayerState                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           KillingActor                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncPlayerController::GetKillcamViewTargetInfo(class ADIPlayerState** DIPlayerState, class AActor** KillingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "GetKillcamViewTargetInfo");

	Params::DeceiveIncPlayerController_GetKillcamViewTargetInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DIPlayerState != nullptr)
		*DIPlayerState = Parms.DIPlayerState;

	if (KillingActor != nullptr)
		*KillingActor = Parms.KillingActor;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerController.GetOwnedSpyPawn
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ASpy*                             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASpy* ADeceiveIncPlayerController::GetOwnedSpyPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "GetOwnedSpyPawn");

	Params::DeceiveIncPlayerController_GetOwnedSpyPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerController.GetPlaceableWrapMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELoadoutSlot                            ToolSlot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSoftObjectPtr<class UMaterialInstance>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSoftObjectPtr<class UMaterialInstance>> ADeceiveIncPlayerController::GetPlaceableWrapMaterial(ELoadoutSlot ToolSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "GetPlaceableWrapMaterial");

	Params::DeceiveIncPlayerController_GetPlaceableWrapMaterial Parms{};

	Parms.ToolSlot = ToolSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerController.GetToolWrapMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELoadoutSlot                            ToolSlot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSoftObjectPtr<class UMaterialInstance>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSoftObjectPtr<class UMaterialInstance>> ADeceiveIncPlayerController::GetToolWrapMaterial(ELoadoutSlot ToolSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "GetToolWrapMaterial");

	Params::DeceiveIncPlayerController_GetToolWrapMaterial Parms{};

	Parms.ToolSlot = ToolSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerController.GoToMainMenu
// (Final, Native, Public, BlueprintCallable)

void ADeceiveIncPlayerController::GoToMainMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "GoToMainMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.HandleBooleanPlayerSettingChange
// (Final, Native, Protected)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::HandleBooleanPlayerSettingChange(EPlayerSettingsType SettingType, bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "HandleBooleanPlayerSettingChange");

	Params::DeceiveIncPlayerController_HandleBooleanPlayerSettingChange Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.HandleGamePhaseChange
// (Final, Native, Protected)
// Parameters:
// ESpyGamePhase                           NewPhase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADeceiveIncMatchGameState*        GameState                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::HandleGamePhaseChange(ESpyGamePhase NewPhase, const class ADeceiveIncMatchGameState* GameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "HandleGamePhaseChange");

	Params::DeceiveIncPlayerController_HandleGamePhaseChange Parms{};

	Parms.NewPhase = NewPhase;
	Parms.GameState = GameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.HandleInputMappingChanged
// (Final, Native, Protected)

void ADeceiveIncPlayerController::HandleInputMappingChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "HandleInputMappingChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.HandleIntegerPlayerSettingChange
// (Final, Native, Protected)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::HandleIntegerPlayerSettingChange(EPlayerSettingsType SettingType, int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "HandleIntegerPlayerSettingChange");

	Params::DeceiveIncPlayerController_HandleIntegerPlayerSettingChange Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.IsKillcamPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncPlayerController::IsKillcamPlaying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "IsKillcamPlaying");

	Params::DeceiveIncPlayerController_IsKillcamPlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerController.IsKillcamStartingUp
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncPlayerController::IsKillcamStartingUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "IsKillcamStartingUp");

	Params::DeceiveIncPlayerController_IsKillcamStartingUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerController.IsTeamAlive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncPlayerController::IsTeamAlive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "IsTeamAlive");

	Params::DeceiveIncPlayerController_IsTeamAlive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerController.OnKillcamFadeStart
// (Final, Native, Public)

void ADeceiveIncPlayerController::OnKillcamFadeStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "OnKillcamFadeStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.OnKillcamStartCompleted
// (Final, Native, Public)
// Parameters:
// bool                                    bSuccessful                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::OnKillcamStartCompleted(bool bSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "OnKillcamStartCompleted");

	Params::DeceiveIncPlayerController_OnKillcamStartCompleted Parms{};

	Parms.bSuccessful = bSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.OnKillcamStopCompleted
// (Final, Native, Public)
// Parameters:
// bool                                    bTriggerSetup                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::OnKillcamStopCompleted(bool bTriggerSetup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "OnKillcamStopCompleted");

	Params::DeceiveIncPlayerController_OnKillcamStopCompleted Parms{};

	Parms.bTriggerSetup = bTriggerSetup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.OnRep_IsAutoSpectating
// (Final, Native, Public)

void ADeceiveIncPlayerController::OnRep_IsAutoSpectating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "OnRep_IsAutoSpectating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.OnSessionSelectionsModified
// (Final, Native, Protected)
// Parameters:
// class UDISessionSelections*             SessionSelection                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::OnSessionSelectionsModified(const class UDISessionSelections* SessionSelection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "OnSessionSelectionsModified");

	Params::DeceiveIncPlayerController_OnSessionSelectionsModified Parms{};

	Parms.SessionSelection = SessionSelection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.OnStabilizeServerTimeOffset
// (Final, Native, Protected)

void ADeceiveIncPlayerController::OnStabilizeServerTimeOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "OnStabilizeServerTimeOffset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.PlayerReadyForSpawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForceSpawn                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::PlayerReadyForSpawn(bool bForceSpawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "PlayerReadyForSpawn");

	Params::DeceiveIncPlayerController_PlayerReadyForSpawn Parms{};

	Parms.bForceSpawn = bForceSpawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.RequestJoinTeamVoicechat
// (Final, Native, Public, BlueprintCallable)

void ADeceiveIncPlayerController::RequestJoinTeamVoicechat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "RequestJoinTeamVoicechat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.RequestLeaveTeamVoicechat
// (Final, Native, Public, BlueprintCallable)

void ADeceiveIncPlayerController::RequestLeaveTeamVoicechat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "RequestLeaveTeamVoicechat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.RPC_ClientInformOfEvent
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// EClientEvent                            ClientEvent                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::RPC_ClientInformOfEvent(EClientEvent ClientEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "RPC_ClientInformOfEvent");

	Params::DeceiveIncPlayerController_RPC_ClientInformOfEvent Parms{};

	Parms.ClientEvent = ClientEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.RPC_SpectateActor
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class AActor*                           ActorToSpectate                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADIPlayerState*                   PlayerStateToSpectate                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::RPC_SpectateActor(class AActor* ActorToSpectate, class ADIPlayerState* PlayerStateToSpectate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "RPC_SpectateActor");

	Params::DeceiveIncPlayerController_RPC_SpectateActor Parms{};

	Parms.ActorToSpectate = ActorToSpectate;
	Parms.PlayerStateToSpectate = PlayerStateToSpectate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.Server_AskForNextSpectatedActor
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bNext                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::Server_AskForNextSpectatedActor(bool bNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "Server_AskForNextSpectatedActor");

	Params::DeceiveIncPlayerController_Server_AskForNextSpectatedActor Parms{};

	Parms.bNext = bNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.Server_ClientIsReady
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FString                           Payload                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::Server_ClientIsReady(const class FString& Payload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "Server_ClientIsReady");

	Params::DeceiveIncPlayerController_Server_ClientIsReady Parms{};

	Parms.Payload = std::move(Payload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.Server_DEBUGToggleFreecam
// (Net, NetReliable, Native, Event, Protected, NetServer)

void ADeceiveIncPlayerController::Server_DEBUGToggleFreecam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "Server_DEBUGToggleFreecam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.Server_IncomingEACMessage
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// TArray<uint8>                           Data                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           SourceId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           TargetId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::Server_IncomingEACMessage(const TArray<uint8>& Data, const class FString& SourceId, const class FString& TargetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "Server_IncomingEACMessage");

	Params::DeceiveIncPlayerController_Server_IncomingEACMessage Parms{};

	Parms.Data = std::move(Data);
	Parms.SourceId = std::move(SourceId);
	Parms.TargetId = std::move(TargetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.Server_RequestJoinTeamVoiceChannel
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADeceiveIncPlayerController::Server_RequestJoinTeamVoiceChannel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "Server_RequestJoinTeamVoiceChannel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.Server_SetKillcamIsPlaying
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bIsPlaying                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::Server_SetKillcamIsPlaying(bool bIsPlaying)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "Server_SetKillcamIsPlaying");

	Params::DeceiveIncPlayerController_Server_SetKillcamIsPlaying Parms{};

	Parms.bIsPlaying = bIsPlaying;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.Server_SetPlayerName
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class FString                           Username                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::Server_SetPlayerName(const class FString& Username)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "Server_SetPlayerName");

	Params::DeceiveIncPlayerController_Server_SetPlayerName Parms{};

	Parms.Username = std::move(Username);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.Server_ToggleAutoSpectate
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADeceiveIncPlayerController::Server_ToggleAutoSpectate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "Server_ToggleAutoSpectate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.ServerClearPS5MatchId
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADeceiveIncPlayerController::ServerClearPS5MatchId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "ServerClearPS5MatchId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.ServerForceKillcam
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bReviveAfterKillcamIn                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::ServerForceKillcam(bool bReviveAfterKillcamIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "ServerForceKillcam");

	Params::DeceiveIncPlayerController_ServerForceKillcam Parms{};

	Parms.bReviveAfterKillcamIn = bReviveAfterKillcamIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.ServerInitAccelByte
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// struct FAccelByteUniqueIdComposite      UniqueNetId                                            (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           InMatchId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::ServerInitAccelByte(const struct FAccelByteUniqueIdComposite& UniqueNetId, const class FString& InMatchId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "ServerInitAccelByte");

	Params::DeceiveIncPlayerController_ServerInitAccelByte Parms{};

	Parms.UniqueNetId = std::move(UniqueNetId);
	Parms.InMatchId = std::move(InMatchId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.ServerInitPlayerInfos
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FString                           BanditIdIn                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           GameLiftPlayerSessionIdIn                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlayerAgentSelectionInfo        AgentSelectionIn                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FDISerializedAccessories         AccessoriesIn                                          (Parm, NativeAccessSpecifierPublic)
// struct FDISerializedDeckEntry           DeckIn                                                 (Parm, NativeAccessSpecifierPublic)
// EPlatformType                           PlateformType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UDIOnlinePartyMemberInfo*> PartyMembers                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::ServerInitPlayerInfos(const class FString& BanditIdIn, const class FString& GameLiftPlayerSessionIdIn, const struct FPlayerAgentSelectionInfo& AgentSelectionIn, const struct FDISerializedAccessories& AccessoriesIn, const struct FDISerializedDeckEntry& DeckIn, EPlatformType PlateformType, const TArray<class UDIOnlinePartyMemberInfo*>& PartyMembers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "ServerInitPlayerInfos");

	Params::DeceiveIncPlayerController_ServerInitPlayerInfos Parms{};

	Parms.BanditIdIn = std::move(BanditIdIn);
	Parms.GameLiftPlayerSessionIdIn = std::move(GameLiftPlayerSessionIdIn);
	Parms.AgentSelectionIn = std::move(AgentSelectionIn);
	Parms.AccessoriesIn = std::move(AccessoriesIn);
	Parms.DeckIn = std::move(DeckIn);
	Parms.PlateformType = PlateformType;
	Parms.PartyMembers = std::move(PartyMembers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.ServerRequestServerTime
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// float                                   RequestWorldTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::ServerRequestServerTime(float RequestWorldTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "ServerRequestServerTime");

	Params::DeceiveIncPlayerController_ServerRequestServerTime Parms{};

	Parms.RequestWorldTime = RequestWorldTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.ServerSelectAgent
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// struct FPlayerAgentSelectionInfo        AgentSelectionIn                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FDISerializedAccessories         AccessoriesIn                                          (Parm, NativeAccessSpecifierPublic)
// struct FDISerializedDeckEntry           NewDeck                                                (Parm, NativeAccessSpecifierPublic)
// bool                                    bForceSpawn                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::ServerSelectAgent(const struct FPlayerAgentSelectionInfo& AgentSelectionIn, const struct FDISerializedAccessories& AccessoriesIn, const struct FDISerializedDeckEntry& NewDeck, bool bForceSpawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "ServerSelectAgent");

	Params::DeceiveIncPlayerController_ServerSelectAgent Parms{};

	Parms.AgentSelectionIn = std::move(AgentSelectionIn);
	Parms.AccessoriesIn = std::move(AccessoriesIn);
	Parms.NewDeck = std::move(NewDeck);
	Parms.bForceSpawn = bForceSpawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.ServerSetPS5MatchId
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FString                           NewPS5MatchId                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerController::ServerSetPS5MatchId(const class FString& NewPS5MatchId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "ServerSetPS5MatchId");

	Params::DeceiveIncPlayerController_ServerSetPS5MatchId Parms{};

	Parms.NewPS5MatchId = std::move(NewPS5MatchId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerController.TryTogglePauseMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncPlayerController::TryTogglePauseMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "TryTogglePauseMenu");

	Params::DeceiveIncPlayerController_TryTogglePauseMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerController.WantsToPlayKillcam
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncPlayerController::WantsToPlayKillcam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "WantsToPlayKillcam");

	Params::DeceiveIncPlayerController_WantsToPlayKillcam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerController.IsInTeamVoicechat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncPlayerController::IsInTeamVoicechat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "IsInTeamVoicechat");

	Params::DeceiveIncPlayerController_IsInTeamVoicechat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerController.IsJoiningTeamVoicechat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncPlayerController::IsJoiningTeamVoicechat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerController", "IsJoiningTeamVoicechat");

	Params::DeceiveIncPlayerController_IsJoiningTeamVoicechat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.JoinVoiceChannel
// (Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ChannelName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ChannelCredentials                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncPlayerVoiceChat::JoinVoiceChannel(const class FString& ChannelName, const class FString& ChannelCredentials)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "JoinVoiceChannel");

	Params::DeceiveIncPlayerVoiceChat_JoinVoiceChannel Parms{};

	Parms.ChannelName = std::move(ChannelName);
	Parms.ChannelCredentials = std::move(ChannelCredentials);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.LeaveAllVoiceChannels
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncPlayerVoiceChat::LeaveAllVoiceChannels()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "LeaveAllVoiceChannels");

	Params::DeceiveIncPlayerVoiceChat_LeaveAllVoiceChannels Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.LeaveVoiceChannel
// (Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ChannelName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncPlayerVoiceChat::LeaveVoiceChannel(const class FString& ChannelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "LeaveVoiceChannel");

	Params::DeceiveIncPlayerVoiceChat_LeaveVoiceChannel Parms{};

	Parms.ChannelName = std::move(ChannelName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.SetInputMuted
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bMuted                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerVoiceChat::SetInputMuted(bool bMuted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "SetInputMuted");

	Params::DeceiveIncPlayerVoiceChat_SetInputMuted Parms{};

	Parms.bMuted = bMuted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.SetInputVolume
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   Volume                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerVoiceChat::SetInputVolume(const float& Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "SetInputVolume");

	Params::DeceiveIncPlayerVoiceChat_SetInputVolume Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.SetLocalVoiceActivationThreshold
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   FNormalizedThreshold                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerVoiceChat::SetLocalVoiceActivationThreshold(float FNormalizedThreshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "SetLocalVoiceActivationThreshold");

	Params::DeceiveIncPlayerVoiceChat_SetLocalVoiceActivationThreshold Parms{};

	Parms.FNormalizedThreshold = FNormalizedThreshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.SetOutputMuted
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bMuted                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerVoiceChat::SetOutputMuted(bool bMuted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "SetOutputMuted");

	Params::DeceiveIncPlayerVoiceChat_SetOutputMuted Parms{};

	Parms.bMuted = bMuted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.SetOutputVolume
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   Volume                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerVoiceChat::SetOutputVolume(const float& Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "SetOutputVolume");

	Params::DeceiveIncPlayerVoiceChat_SetOutputVolume Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.SetPlayerMuted
// (Native, Public, BlueprintCallable)
// Parameters:
// class FString                           PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAudioMuted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerVoiceChat::SetPlayerMuted(const class FString& PlayerName, bool bAudioMuted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "SetPlayerMuted");

	Params::DeceiveIncPlayerVoiceChat_SetPlayerMuted Parms{};

	Parms.PlayerName = std::move(PlayerName);
	Parms.bAudioMuted = bAudioMuted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.SetPlayerVolume
// (Native, Public, BlueprintCallable)
// Parameters:
// class FString                           PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerVoiceChat::SetPlayerVolume(const class FString& PlayerName, float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "SetPlayerVolume");

	Params::DeceiveIncPlayerVoiceChat_SetPlayerVolume Parms{};

	Parms.PlayerName = std::move(PlayerName);
	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.SetTransmitMode
// (Native, Public, BlueprintCallable)
// Parameters:
// EPlayerVoiceChatTransmitMode            TransmitMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeceiveIncPlayerVoiceChat::SetTransmitMode(EPlayerVoiceChatTransmitMode TransmitMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "SetTransmitMode");

	Params::DeceiveIncPlayerVoiceChat_SetTransmitMode Parms{};

	Parms.TransmitMode = TransmitMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.GetInputMuted
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncPlayerVoiceChat::GetInputMuted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "GetInputMuted");

	Params::DeceiveIncPlayerVoiceChat_GetInputMuted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.GetInputVolume
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADeceiveIncPlayerVoiceChat::GetInputVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "GetInputVolume");

	Params::DeceiveIncPlayerVoiceChat_GetInputVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.GetJoinedChannels
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> ADeceiveIncPlayerVoiceChat::GetJoinedChannels() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "GetJoinedChannels");

	Params::DeceiveIncPlayerVoiceChat_GetJoinedChannels Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.GetLocalVoiceActivationThreshold
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADeceiveIncPlayerVoiceChat::GetLocalVoiceActivationThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "GetLocalVoiceActivationThreshold");

	Params::DeceiveIncPlayerVoiceChat_GetLocalVoiceActivationThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.GetLoggedInPlayerName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ADeceiveIncPlayerVoiceChat::GetLoggedInPlayerName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "GetLoggedInPlayerName");

	Params::DeceiveIncPlayerVoiceChat_GetLoggedInPlayerName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.GetOutputMuted
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncPlayerVoiceChat::GetOutputMuted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "GetOutputMuted");

	Params::DeceiveIncPlayerVoiceChat_GetOutputMuted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.GetOutputVolume
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADeceiveIncPlayerVoiceChat::GetOutputVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "GetOutputVolume");

	Params::DeceiveIncPlayerVoiceChat_GetOutputVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.GetPlayersInChannel
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ChannelName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> ADeceiveIncPlayerVoiceChat::GetPlayersInChannel(const class FString& ChannelName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "GetPlayersInChannel");

	Params::DeceiveIncPlayerVoiceChat_GetPlayersInChannel Parms{};

	Parms.ChannelName = std::move(ChannelName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.GetPlayerVolume
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADeceiveIncPlayerVoiceChat::GetPlayerVolume(const class FString& PlayerName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "GetPlayerVolume");

	Params::DeceiveIncPlayerVoiceChat_GetPlayerVolume Parms{};

	Parms.PlayerName = std::move(PlayerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.GetTransmitMode
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerVoiceChatTransmitMode            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerVoiceChatTransmitMode ADeceiveIncPlayerVoiceChat::GetTransmitMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "GetTransmitMode");

	Params::DeceiveIncPlayerVoiceChat_GetTransmitMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.IsLocalPlayerTalking
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncPlayerVoiceChat::IsLocalPlayerTalking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "IsLocalPlayerTalking");

	Params::DeceiveIncPlayerVoiceChat_IsLocalPlayerTalking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.IsPlayerMuted
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncPlayerVoiceChat::IsPlayerMuted(const class FString& PlayerName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "IsPlayerMuted");

	Params::DeceiveIncPlayerVoiceChat_IsPlayerMuted Parms{};

	Parms.PlayerName = std::move(PlayerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeceiveIncPlayerVoiceChat.IsPlayerTalking
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeceiveIncPlayerVoiceChat::IsPlayerTalking(const class FString& PlayerName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeceiveIncPlayerVoiceChat", "IsPlayerTalking");

	Params::DeceiveIncPlayerVoiceChat_IsPlayerTalking Parms{};

	Parms.PlayerName = std::move(PlayerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DedicatedServerLiveOpsConfig.ReadCommandLineArgs
// (Final, Native, Public)

void UDedicatedServerLiveOpsConfig::ReadCommandLineArgs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DedicatedServerLiveOpsConfig", "ReadCommandLineArgs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeployedShieldbrella.BP_OnShieldActivate
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeployedShieldbrella::BP_OnShieldActivate(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeployedShieldbrella", "BP_OnShieldActivate");

	Params::DeployedShieldbrella_BP_OnShieldActivate Parms{};

	Parms.bActive = bActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.DeployedShieldbrella.IsShieldActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADeployedShieldbrella::IsShieldActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeployedShieldbrella", "IsShieldActive");

	Params::DeployedShieldbrella_IsShieldActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DeployedShieldbrella.NetMulticast_EnableShield
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeployedShieldbrella::NetMulticast_EnableShield(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeployedShieldbrella", "NetMulticast_EnableShield");

	Params::DeployedShieldbrella_NetMulticast_EnableShield Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeployedShieldbrella.OnEMPIsAffectedChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bIsAffected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AffectedActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeployedShieldbrella::OnEMPIsAffectedChanged(bool bIsAffected, class AActor* AffectedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeployedShieldbrella", "OnEMPIsAffectedChanged");

	Params::DeployedShieldbrella_OnEMPIsAffectedChanged Parms{};

	Parms.bIsAffected = bIsAffected;
	Parms.AffectedActor = AffectedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeployedShieldbrella.OnLifeTimerEnd
// (Final, Native, Protected)

void ADeployedShieldbrella::OnLifeTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeployedShieldbrella", "OnLifeTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeployedShieldbrella.OnScramblerIsAffectedChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bIsAffected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AffectedActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeployedShieldbrella::OnScramblerIsAffectedChanged(bool bIsAffected, class AActor* AffectedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeployedShieldbrella", "OnScramblerIsAffectedChanged");

	Params::DeployedShieldbrella_OnScramblerIsAffectedChanged Parms{};

	Parms.bIsAffected = bIsAffected;
	Parms.AffectedActor = AffectedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DeployedShieldbrella.Server_EnableShield
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADeployedShieldbrella::Server_EnableShield(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeployedShieldbrella", "Server_EnableShield");

	Params::DeployedShieldbrella_Server_EnableShield Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIAllowedGameModesHandler.GetAllowedGameModes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FDescribeAllowedGameModesResponseReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDescribeAllowedGameModesResponse UDIAllowedGameModesHandler::GetAllowedGameModes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIAllowedGameModesHandler", "GetAllowedGameModes");

	Params::DIAllowedGameModesHandler_GetAllowedGameModes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiAnimationMotionSet.GetAnimMotionAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             MotionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimationAsset*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimationAsset* UDiAnimationMotionSet::GetAnimMotionAsset(class FName MotionName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiAnimationMotionSet", "GetAnimMotionAsset");

	Params::DiAnimationMotionSet_GetAnimMotionAsset Parms{};

	Parms.MotionName = MotionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiAnimationMotionSet.HasAnimMotion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             MotionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiAnimationMotionSet::HasAnimMotion(class FName MotionName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiAnimationMotionSet", "HasAnimMotion");

	Params::DiAnimationMotionSet_HasAnimMotion Parms{};

	Parms.MotionName = MotionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiAnimationMotionSet.TryGetAnimMotionBlendSpace
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             MotionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBlendSpaceBase*                  Destination                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiAnimationMotionSet::TryGetAnimMotionBlendSpace(class FName MotionName, class UBlendSpaceBase** Destination) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiAnimationMotionSet", "TryGetAnimMotionBlendSpace");

	Params::DiAnimationMotionSet_TryGetAnimMotionBlendSpace Parms{};

	Parms.MotionName = MotionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Destination != nullptr)
		*Destination = Parms.Destination;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiAnimationMotionSet.TryGetAnimMotionSequence
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             MotionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    Destination                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiAnimationMotionSet::TryGetAnimMotionSequence(class FName MotionName, class UAnimSequence** Destination) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiAnimationMotionSet", "TryGetAnimMotionSequence");

	Params::DiAnimationMotionSet_TryGetAnimMotionSequence Parms{};

	Parms.MotionName = MotionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Destination != nullptr)
		*Destination = Parms.Destination;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIAssetManager.GetLimitedEventItemsDataAsset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULimitedEventItemsDataAsset*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULimitedEventItemsDataAsset* UDIAssetManager::GetLimitedEventItemsDataAsset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIAssetManager", "GetLimitedEventItemsDataAsset");

	Params::DIAssetManager_GetLimitedEventItemsDataAsset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIAssetManager.GetLimitedEventProgression
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULimitedEventXpProgressionData*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULimitedEventXpProgressionData* UDIAssetManager::GetLimitedEventProgression()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIAssetManager", "GetLimitedEventProgression");

	Params::DIAssetManager_GetLimitedEventProgression Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIAssetManager.GetPingSystemDataAsset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPingSystemDataAsset*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPingSystemDataAsset* UDIAssetManager::GetPingSystemDataAsset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIAssetManager", "GetPingSystemDataAsset");

	Params::DIAssetManager_GetPingSystemDataAsset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIAssetManager.GetProgressionRewardByXpType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           XpType                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UProgressionRewardData*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UProgressionRewardData* UDIAssetManager::GetProgressionRewardByXpType(const class FString& XpType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIAssetManager", "GetProgressionRewardByXpType");

	Params::DIAssetManager_GetProgressionRewardByXpType Parms{};

	Parms.XpType = std::move(XpType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIAssetManager.HandleActorEndPlay
// (Final, Native, Protected)
// Parameters:
// class AActor*                           EndingActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndPlayReason                          EndPlayReason                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIAssetManager::HandleActorEndPlay(class AActor* EndingActor, const EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIAssetManager", "HandleActorEndPlay");

	Params::DIAssetManager_HandleActorEndPlay Parms{};

	Parms.EndingActor = EndingActor;
	Parms.EndPlayReason = EndPlayReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIAssetManager.NecessaryAssetLoadCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIAssetManager::NecessaryAssetLoadCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIAssetManager", "NecessaryAssetLoadCompleted");

	Params::DIAssetManager_NecessaryAssetLoadCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DICameraSubsystem.GetCameraLense
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWorld*                           WorldIn                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADICameraLense*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADICameraLense* UDICameraSubsystem::GetCameraLense(const class UWorld* WorldIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DICameraSubsystem", "GetCameraLense");

	Params::DICameraSubsystem_GetCameraLense Parms{};

	Parms.WorldIn = WorldIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DICameraSubsystem.SB_RegisterCamera
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          CameraRefIn                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECameraPriority                         PriorityIn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDICameraSubsystem::SB_RegisterCamera(class UObject* WorldContextObject, class UObject* CameraRefIn, ECameraPriority PriorityIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DICameraSubsystem", "SB_RegisterCamera");

	Params::DICameraSubsystem_SB_RegisterCamera Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CameraRefIn = CameraRefIn;
	Parms.PriorityIn = PriorityIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DICameraSubsystem.SB_RegisterCameraWithTransition
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          CameraRefIn                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECameraPriority                         PriorityIn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TransitionDuration                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpolationExp                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDICameraSubsystem::SB_RegisterCameraWithTransition(class UObject* WorldContextObject, class UObject* CameraRefIn, ECameraPriority PriorityIn, float TransitionDuration, float InterpolationExp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DICameraSubsystem", "SB_RegisterCameraWithTransition");

	Params::DICameraSubsystem_SB_RegisterCameraWithTransition Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CameraRefIn = CameraRefIn;
	Parms.PriorityIn = PriorityIn;
	Parms.TransitionDuration = TransitionDuration;
	Parms.InterpolationExp = InterpolationExp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DICameraSubsystem.SB_UnregisterCamera
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          CameraRefIn                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECameraPriority                         PriorityIn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDICameraSubsystem::SB_UnregisterCamera(class UObject* WorldContextObject, class UObject* CameraRefIn, ECameraPriority PriorityIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DICameraSubsystem", "SB_UnregisterCamera");

	Params::DICameraSubsystem_SB_UnregisterCamera Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CameraRefIn = CameraRefIn;
	Parms.PriorityIn = PriorityIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DICameraSubsystem.SB_UnregisterCameraWithTransition
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          CameraRefIn                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECameraPriority                         PriorityIn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TransitionDuration                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpolationExp                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDICameraSubsystem::SB_UnregisterCameraWithTransition(class UObject* WorldContextObject, class UObject* CameraRefIn, ECameraPriority PriorityIn, float TransitionDuration, float InterpolationExp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DICameraSubsystem", "SB_UnregisterCameraWithTransition");

	Params::DICameraSubsystem_SB_UnregisterCameraWithTransition Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CameraRefIn = CameraRefIn;
	Parms.PriorityIn = PriorityIn;
	Parms.TransitionDuration = TransitionDuration;
	Parms.InterpolationExp = InterpolationExp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction DeceiveInc.DICameraSubsystem.OnCameraChangeEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class UObject*                          NewActiveCamera                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECameraPriority                         NewCameraPriority                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDICameraSubsystem::OnCameraChangeEvent__DelegateSignature(class UObject* NewActiveCamera, ECameraPriority NewCameraPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DICameraSubsystem", "OnCameraChangeEvent__DelegateSignature");

	Params::DICameraSubsystem_OnCameraChangeEvent__DelegateSignature Parms{};

	Parms.NewActiveCamera = NewActiveCamera;
	Parms.NewCameraPriority = NewCameraPriority;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.DiCharacterAnimInstance.TryGetCharacterOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UDiCharacterAnimInstance::TryGetCharacterOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiCharacterAnimInstance", "TryGetCharacterOwner");

	Params::DiCharacterAnimInstance_TryGetCharacterOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DICharacterMovementComponent.AddImpulse
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Impulse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVelocityChange                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDICharacterMovementComponent::AddImpulse(const struct FVector& Impulse, bool bVelocityChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DICharacterMovementComponent", "AddImpulse");

	Params::DICharacterMovementComponent_AddImpulse Parms{};

	Parms.Impulse = std::move(Impulse);
	Parms.bVelocityChange = bVelocityChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DICharacterMovementComponent.AddSlowSource
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewSlowSource                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewSlowPercent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDICharacterMovementComponent::AddSlowSource(class AActor* NewSlowSource, float NewSlowPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DICharacterMovementComponent", "AddSlowSource");

	Params::DICharacterMovementComponent_AddSlowSource Parms{};

	Parms.NewSlowSource = NewSlowSource;
	Parms.NewSlowPercent = NewSlowPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DICharacterMovementComponent.CalcVelocity
// (Native, Protected, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Friction                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFluid                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BrakingDeceleration                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDICharacterMovementComponent::CalcVelocity(float DeltaTime, float Friction, bool bFluid, float BrakingDeceleration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DICharacterMovementComponent", "CalcVelocity");

	Params::DICharacterMovementComponent_CalcVelocity Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.Friction = Friction;
	Parms.bFluid = bFluid;
	Parms.BrakingDeceleration = BrakingDeceleration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DICharacterMovementComponent.CapsuleTouched
// (Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDICharacterMovementComponent::CapsuleTouched(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DICharacterMovementComponent", "CapsuleTouched");

	Params::DICharacterMovementComponent_CapsuleTouched Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DICharacterMovementComponent.ClearAccumulatedForces
// (Native, Public, BlueprintCallable)

void UDICharacterMovementComponent::ClearAccumulatedForces()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DICharacterMovementComponent", "ClearAccumulatedForces");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DICharacterMovementComponent.ClearVelocityAndAccumulatedForces
// (Native, Public, BlueprintCallable)

void UDICharacterMovementComponent::ClearVelocityAndAccumulatedForces()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DICharacterMovementComponent", "ClearVelocityAndAccumulatedForces");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DICharacterMovementComponent.RemoveSlowSource
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           SlowSourceToRemove                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDICharacterMovementComponent::RemoveSlowSource(class AActor* SlowSourceToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DICharacterMovementComponent", "RemoveSlowSource");

	Params::DICharacterMovementComponent_RemoveSlowSource Parms{};

	Parms.SlowSourceToRemove = SlowSourceToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DICharacterMovementComponent.SetWalkableFloorAngle
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   InWalkableFloorAngle                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDICharacterMovementComponent::SetWalkableFloorAngle(float InWalkableFloorAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DICharacterMovementComponent", "SetWalkableFloorAngle");

	Params::DICharacterMovementComponent_SetWalkableFloorAngle Parms{};

	Parms.InWalkableFloorAngle = InWalkableFloorAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DICharacterMovementComponent.SetWalkableFloorZ
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   InWalkableFloorZ                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDICharacterMovementComponent::SetWalkableFloorZ(float InWalkableFloorZ)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DICharacterMovementComponent", "SetWalkableFloorZ");

	Params::DICharacterMovementComponent_SetWalkableFloorZ Parms{};

	Parms.InWalkableFloorZ = InWalkableFloorZ;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DICharacterMovementComponent.GetImpartedMovementBaseVelocity
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDICharacterMovementComponent::GetImpartedMovementBaseVelocity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DICharacterMovementComponent", "GetImpartedMovementBaseVelocity");

	Params::DICharacterMovementComponent_GetImpartedMovementBaseVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DICharacterMovementComponent.GetMaxAcceleration
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDICharacterMovementComponent::GetMaxAcceleration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DICharacterMovementComponent", "GetMaxAcceleration");

	Params::DICharacterMovementComponent_GetMaxAcceleration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DICharacterMovementComponent.GetMaxBrakingDeceleration
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDICharacterMovementComponent::GetMaxBrakingDeceleration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DICharacterMovementComponent", "GetMaxBrakingDeceleration");

	Params::DICharacterMovementComponent_GetMaxBrakingDeceleration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DICharacterMovementComponent.GetPerchRadiusThreshold
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDICharacterMovementComponent::GetPerchRadiusThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DICharacterMovementComponent", "GetPerchRadiusThreshold");

	Params::DICharacterMovementComponent_GetPerchRadiusThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DICharacterMovementComponent.GetValidPerchRadius
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDICharacterMovementComponent::GetValidPerchRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DICharacterMovementComponent", "GetValidPerchRadius");

	Params::DICharacterMovementComponent_GetValidPerchRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DICharacterMovementComponent.IsWalkable
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDICharacterMovementComponent::IsWalkable(const struct FHitResult& Hit) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DICharacterMovementComponent", "IsWalkable");

	Params::DICharacterMovementComponent_IsWalkable Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIClientWebServiceSession.IsErrorStatus
// (Final, Native, Static, Private)
// Parameters:
// EDescribeMatchmakingStatus              StatusToCheck                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIClientWebServiceSession::IsErrorStatus(EDescribeMatchmakingStatus StatusToCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIClientWebServiceSession", "IsErrorStatus");

	Params::DIClientWebServiceSession_IsErrorStatus Parms{};

	Parms.StatusToCheck = StatusToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIClientWebServiceSession.IsSearchEndedStatus
// (Final, Native, Static, Private)
// Parameters:
// EDescribeMatchmakingStatus              StatusToCheck                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIClientWebServiceSession::IsSearchEndedStatus(EDescribeMatchmakingStatus StatusToCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIClientWebServiceSession", "IsSearchEndedStatus");

	Params::DIClientWebServiceSession_IsSearchEndedStatus Parms{};

	Parms.StatusToCheck = StatusToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIClientWebServiceSession.IsSearchingStatus
// (Final, Native, Static, Private)
// Parameters:
// EDescribeMatchmakingStatus              StatusToCheck                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIClientWebServiceSession::IsSearchingStatus(EDescribeMatchmakingStatus StatusToCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIClientWebServiceSession", "IsSearchingStatus");

	Params::DIClientWebServiceSession_IsSearchingStatus Parms{};

	Parms.StatusToCheck = StatusToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIClientWebServiceSession.BuyItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ItemId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CurrencyId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIClientWebServiceSession::BuyItem(const class FString& ItemId, const class FString& CurrencyId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "BuyItem");

	Params::DIClientWebServiceSession_BuyItem Parms{};

	Parms.ItemId = std::move(ItemId);
	Parms.CurrencyId = std::move(CurrencyId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.BuyItemNoConf
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ItemId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CurrencyId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIClientWebServiceSession::BuyItemNoConf(const class FString& ItemId, const class FString& CurrencyId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "BuyItemNoConf");

	Params::DIClientWebServiceSession_BuyItemNoConf Parms{};

	Parms.ItemId = std::move(ItemId);
	Parms.CurrencyId = std::move(CurrencyId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.CheatClaimFakeLootBundle
// (Final, Native, Public, BlueprintCallable)

void UDIClientWebServiceSession::CheatClaimFakeLootBundle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "CheatClaimFakeLootBundle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.ClaimLootBundle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           LootBundleId                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIClientWebServiceSession::ClaimLootBundle(const class FString& LootBundleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "ClaimLootBundle");

	Params::DIClientWebServiceSession_ClaimLootBundle Parms{};

	Parms.LootBundleId = std::move(LootBundleId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.ConsumeItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ItemId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIClientWebServiceSession::ConsumeItem(const class FString& ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "ConsumeItem");

	Params::DIClientWebServiceSession_ConsumeItem Parms{};

	Parms.ItemId = std::move(ItemId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.ConsumeXPBooster
// (Final, Native, Public, BlueprintCallable)

void UDIClientWebServiceSession::ConsumeXPBooster()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "ConsumeXPBooster");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.DoFetchAgreement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           AgreementName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIClientWebServiceSession::DoFetchAgreement(const class FString& AgreementName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "DoFetchAgreement");

	Params::DIClientWebServiceSession_DoFetchAgreement Parms{};

	Parms.AgreementName = std::move(AgreementName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.DoRefresh
// (Final, Native, Public, BlueprintCallable)

void UDIClientWebServiceSession::DoRefresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "DoRefresh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.DoSignAgreement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           AgreementName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIClientWebServiceSession::DoSignAgreement(const class FString& AgreementName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "DoSignAgreement");

	Params::DIClientWebServiceSession_DoSignAgreement Parms{};

	Parms.AgreementName = std::move(AgreementName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.FetchBalancingData
// (Final, Native, Public, BlueprintCallable)

void UDIClientWebServiceSession::FetchBalancingData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "FetchBalancingData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.FetchClientConfig
// (Final, Native, Public, BlueprintCallable)

void UDIClientWebServiceSession::FetchClientConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "FetchClientConfig");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.FetchClock
// (Final, Native, Public, BlueprintCallable)

void UDIClientWebServiceSession::FetchClock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "FetchClock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.FetchItemsConfig
// (Final, Native, Public, BlueprintCallable)

void UDIClientWebServiceSession::FetchItemsConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "FetchItemsConfig");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.FetchShopConfig
// (Final, Native, Public, BlueprintCallable)

void UDIClientWebServiceSession::FetchShopConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "FetchShopConfig");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.GetCurrentItemToBuy
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FBuyItemInfo                     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FBuyItemInfo UDIClientWebServiceSession::GetCurrentItemToBuy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "GetCurrentItemToBuy");

	Params::DIClientWebServiceSession_GetCurrentItemToBuy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIClientWebServiceSession.GetPlatformPurchaseItemMap
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlatformPurchaseMapping         OutResult                                              (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIClientWebServiceSession::GetPlatformPurchaseItemMap(const class FString& Key, struct FPlatformPurchaseMapping* OutResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "GetPlatformPurchaseItemMap");

	Params::DIClientWebServiceSession_GetPlatformPurchaseItemMap Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = std::move(Parms.OutResult);

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIClientWebServiceSession.GetSesssionId
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDIClientWebServiceSession::GetSesssionId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "GetSesssionId");

	Params::DIClientWebServiceSession_GetSesssionId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIClientWebServiceSession.HandleBooleanPlayerSettingChange
// (Final, Native, Private)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIClientWebServiceSession::HandleBooleanPlayerSettingChange(EPlayerSettingsType SettingType, bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "HandleBooleanPlayerSettingChange");

	Params::DIClientWebServiceSession_HandleBooleanPlayerSettingChange Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.HandleIntegerPlayerSettingChange
// (Final, Native, Private)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIClientWebServiceSession::HandleIntegerPlayerSettingChange(EPlayerSettingsType SettingType, int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "HandleIntegerPlayerSettingChange");

	Params::DIClientWebServiceSession_HandleIntegerPlayerSettingChange Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.HandleMatchmakingStatusChanged
// (Final, Native, Private)
// Parameters:
// EDescribeMatchmakingStatus              NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIClientWebServiceSession::HandleMatchmakingStatusChanged(EDescribeMatchmakingStatus NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "HandleMatchmakingStatusChanged");

	Params::DIClientWebServiceSession_HandleMatchmakingStatusChanged Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.HandleMenuEvent
// (Final, Native, Private)
// Parameters:
// class FString                           EventName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AnswerValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIClientWebServiceSession::HandleMenuEvent(const class FString& EventName, bool AnswerValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "HandleMenuEvent");

	Params::DIClientWebServiceSession_HandleMenuEvent Parms{};

	Parms.EventName = std::move(EventName);
	Parms.AnswerValue = AnswerValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.IsClientSessionValid
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIClientWebServiceSession::IsClientSessionValid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "IsClientSessionValid");

	Params::DIClientWebServiceSession_IsClientSessionValid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIClientWebServiceSession.OnMatchmakingFailed
// (Final, Native, Private)
// Parameters:
// EMatchmakingError                       MatchmakingError                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIClientWebServiceSession::OnMatchmakingFailed(EMatchmakingError MatchmakingError)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "OnMatchmakingFailed");

	Params::DIClientWebServiceSession_OnMatchmakingFailed Parms{};

	Parms.MatchmakingError = MatchmakingError;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.OnMatchmakingSuccess
// (Final, Native, Private)
// Parameters:
// struct FDescribeMatchmakingResponse     MatchDescription                                       (Parm, NativeAccessSpecifierPublic)

void UDIClientWebServiceSession::OnMatchmakingSuccess(const struct FDescribeMatchmakingResponse& MatchDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "OnMatchmakingSuccess");

	Params::DIClientWebServiceSession_OnMatchmakingSuccess Parms{};

	Parms.MatchDescription = std::move(MatchDescription);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.OnMatchmakingTokenChanged
// (Final, Native, Private)
// Parameters:
// class FString                           MatchmakingToken                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIClientWebServiceSession::OnMatchmakingTokenChanged(const class FString& MatchmakingToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "OnMatchmakingTokenChanged");

	Params::DIClientWebServiceSession_OnMatchmakingTokenChanged Parms{};

	Parms.MatchmakingToken = std::move(MatchmakingToken);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.OnPartyMatchmakingTicketReceived
// (Final, Native, Private)
// Parameters:
// class FString                           MatchmakingTicketId                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIClientWebServiceSession::OnPartyMatchmakingTicketReceived(const class FString& MatchmakingTicketId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "OnPartyMatchmakingTicketReceived");

	Params::DIClientWebServiceSession_OnPartyMatchmakingTicketReceived Parms{};

	Parms.MatchmakingTicketId = std::move(MatchmakingTicketId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.OnPartyMembersChanged
// (Final, Native, Private)

void UDIClientWebServiceSession::OnPartyMembersChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "OnPartyMembersChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.OnSessionLogin
// (Final, Native, Public)
// Parameters:
// struct FLoginResponse                   LoginResponse                                          (Parm, NativeAccessSpecifierPublic)

void UDIClientWebServiceSession::OnSessionLogin(const struct FLoginResponse& LoginResponse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "OnSessionLogin");

	Params::DIClientWebServiceSession_OnSessionLogin Parms{};

	Parms.LoginResponse = std::move(LoginResponse);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.OnSessionRefresh
// (Final, Native, Public)
// Parameters:
// struct FSessionRefreshResponse          SessionRefreshResponse                                 (Parm, NativeAccessSpecifierPublic)

void UDIClientWebServiceSession::OnSessionRefresh(const struct FSessionRefreshResponse& SessionRefreshResponse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "OnSessionRefresh");

	Params::DIClientWebServiceSession_OnSessionRefresh Parms{};

	Parms.SessionRefreshResponse = std::move(SessionRefreshResponse);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.PostLoadMapDelegate
// (Final, Native, Private)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIClientWebServiceSession::PostLoadMapDelegate(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "PostLoadMapDelegate");

	Params::DIClientWebServiceSession_PostLoadMapDelegate Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.SendReport
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Reporter                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReporteeAccelbyteId                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MatchId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIClientWebServiceSession::SendReport(const class FString& Reporter, const class FString& ReporteeAccelbyteId, const class FString& Message, const class FString& MatchId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "SendReport");

	Params::DIClientWebServiceSession_SendReport Parms{};

	Parms.Reporter = std::move(Reporter);
	Parms.ReporteeAccelbyteId = std::move(ReporteeAccelbyteId);
	Parms.Message = std::move(Message);
	Parms.MatchId = std::move(MatchId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.StartPlatformTransaction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           KeyMap                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIClientWebServiceSession::StartPlatformTransaction(const class FString& KeyMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "StartPlatformTransaction");

	Params::DIClientWebServiceSession_StartPlatformTransaction Parms{};

	Parms.KeyMap = std::move(KeyMap);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.StartSteamTransaction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SteamShopItemId                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIClientWebServiceSession::StartSteamTransaction(int32 SteamShopItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "StartSteamTransaction");

	Params::DIClientWebServiceSession_StartSteamTransaction Parms{};

	Parms.SteamShopItemId = SteamShopItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.StartTwitchOauthFlow
// (Final, Native, Public, BlueprintCallable)

void UDIClientWebServiceSession::StartTwitchOauthFlow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "StartTwitchOauthFlow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIClientWebServiceSession.UnlinkTwitchAccount
// (Final, Native, Public, BlueprintCallable)

void UDIClientWebServiceSession::UnlinkTwitchAccount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIClientWebServiceSession", "UnlinkTwitchAccount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetAccountXpType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDIDataStoreBlueprintLibrary::GetAccountXpType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIDataStoreBlueprintLibrary", "GetAccountXpType");

	Params::DIDataStoreBlueprintLibrary_GetAccountXpType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetActorPingInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           PingedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPingInfo                        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPingInfo UDIDataStoreBlueprintLibrary::GetActorPingInfo(class AActor* PingedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIDataStoreBlueprintLibrary", "GetActorPingInfo");

	Params::DIDataStoreBlueprintLibrary_GetActorPingInfo Parms{};

	Parms.PingedActor = PingedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetAgentDataById
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  PrimaryAssetId                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAgentData*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAgentData* UDIDataStoreBlueprintLibrary::GetAgentDataById(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIDataStoreBlueprintLibrary", "GetAgentDataById");

	Params::DIDataStoreBlueprintLibrary_GetAgentDataById Parms{};

	Parms.PrimaryAssetId = std::move(PrimaryAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetAgentDataByPrimaryAssetName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           PrimaryAssetName                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAgentData*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAgentData* UDIDataStoreBlueprintLibrary::GetAgentDataByPrimaryAssetName(const class FString& PrimaryAssetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIDataStoreBlueprintLibrary", "GetAgentDataByPrimaryAssetName");

	Params::DIDataStoreBlueprintLibrary_GetAgentDataByPrimaryAssetName Parms{};

	Parms.PrimaryAssetName = std::move(PrimaryAssetName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetAgentIntroPoseDataById
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  PrimaryAssetId                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAgentIntroPoseDataAsset*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAgentIntroPoseDataAsset* UDIDataStoreBlueprintLibrary::GetAgentIntroPoseDataById(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIDataStoreBlueprintLibrary", "GetAgentIntroPoseDataById");

	Params::DIDataStoreBlueprintLibrary_GetAgentIntroPoseDataById Parms{};

	Parms.PrimaryAssetId = std::move(PrimaryAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetAgentSkinDataById
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  PrimaryAssetId                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAgentSkinData*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAgentSkinData* UDIDataStoreBlueprintLibrary::GetAgentSkinDataById(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIDataStoreBlueprintLibrary", "GetAgentSkinDataById");

	Params::DIDataStoreBlueprintLibrary_GetAgentSkinDataById Parms{};

	Parms.PrimaryAssetId = std::move(PrimaryAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetAllAgentData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class UAgentData*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UAgentData*> UDIDataStoreBlueprintLibrary::GetAllAgentData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIDataStoreBlueprintLibrary", "GetAllAgentData");

	Params::DIDataStoreBlueprintLibrary_GetAllAgentData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetAvatarDataById
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  PrimaryAssetId                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAvatarDataAsset*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAvatarDataAsset* UDIDataStoreBlueprintLibrary::GetAvatarDataById(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIDataStoreBlueprintLibrary", "GetAvatarDataById");

	Params::DIDataStoreBlueprintLibrary_GetAvatarDataById Parms{};

	Parms.PrimaryAssetId = std::move(PrimaryAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetCatalogueXpType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDIDataStoreBlueprintLibrary::GetCatalogueXpType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIDataStoreBlueprintLibrary", "GetCatalogueXpType");

	Params::DIDataStoreBlueprintLibrary_GetCatalogueXpType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetCoverAffectingSourceData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UCoverAffectingSourceDataAsset*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCoverAffectingSourceDataAsset* UDIDataStoreBlueprintLibrary::GetCoverAffectingSourceData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIDataStoreBlueprintLibrary", "GetCoverAffectingSourceData");

	Params::DIDataStoreBlueprintLibrary_GetCoverAffectingSourceData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetCurrencyData
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  PrimaryAssetId                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDICurrencyType*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDICurrencyType* UDIDataStoreBlueprintLibrary::GetCurrencyData(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIDataStoreBlueprintLibrary", "GetCurrencyData");

	Params::DIDataStoreBlueprintLibrary_GetCurrencyData Parms{};

	Parms.PrimaryAssetId = std::move(PrimaryAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetExpertiseSkillDataById
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  PrimaryAssetId                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAgentExpertiseSkillData*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAgentExpertiseSkillData* UDIDataStoreBlueprintLibrary::GetExpertiseSkillDataById(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIDataStoreBlueprintLibrary", "GetExpertiseSkillDataById");

	Params::DIDataStoreBlueprintLibrary_GetExpertiseSkillDataById Parms{};

	Parms.PrimaryAssetId = std::move(PrimaryAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetGadgetDataById
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  PrimaryAssetId                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGadgetData*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGadgetData* UDIDataStoreBlueprintLibrary::GetGadgetDataById(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIDataStoreBlueprintLibrary", "GetGadgetDataById");

	Params::DIDataStoreBlueprintLibrary_GetGadgetDataById Parms{};

	Parms.PrimaryAssetId = std::move(PrimaryAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetLevelInventoryData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULevelInventoryData*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelInventoryData* UDIDataStoreBlueprintLibrary::GetLevelInventoryData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIDataStoreBlueprintLibrary", "GetLevelInventoryData");

	Params::DIDataStoreBlueprintLibrary_GetLevelInventoryData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetPassiveSkillDataById
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  PrimaryAssetId                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAgentPassiveSkillData*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAgentPassiveSkillData* UDIDataStoreBlueprintLibrary::GetPassiveSkillDataById(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIDataStoreBlueprintLibrary", "GetPassiveSkillDataById");

	Params::DIDataStoreBlueprintLibrary_GetPassiveSkillDataById Parms{};

	Parms.PrimaryAssetId = std::move(PrimaryAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetPlatformData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPlatformDataAsset*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlatformDataAsset* UDIDataStoreBlueprintLibrary::GetPlatformData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIDataStoreBlueprintLibrary", "GetPlatformData");

	Params::DIDataStoreBlueprintLibrary_GetPlatformData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetRadialPingInfoByIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPingInfo                        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPingInfo UDIDataStoreBlueprintLibrary::GetRadialPingInfoByIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIDataStoreBlueprintLibrary", "GetRadialPingInfoByIndex");

	Params::DIDataStoreBlueprintLibrary_GetRadialPingInfoByIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetSecurityLevelColor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// ESecurityLevel                          SecurityLevel                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor UDIDataStoreBlueprintLibrary::GetSecurityLevelColor(const ESecurityLevel& SecurityLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIDataStoreBlueprintLibrary", "GetSecurityLevelColor");

	Params::DIDataStoreBlueprintLibrary_GetSecurityLevelColor Parms{};

	Parms.SecurityLevel = SecurityLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetTeamData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTeamDataAsset*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTeamDataAsset* UDIDataStoreBlueprintLibrary::GetTeamData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIDataStoreBlueprintLibrary", "GetTeamData");

	Params::DIDataStoreBlueprintLibrary_GetTeamData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetTitleDataById
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  PrimaryAssetId                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTitleDataAsset*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTitleDataAsset* UDIDataStoreBlueprintLibrary::GetTitleDataById(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIDataStoreBlueprintLibrary", "GetTitleDataById");

	Params::DIDataStoreBlueprintLibrary_GetTitleDataById Parms{};

	Parms.PrimaryAssetId = std::move(PrimaryAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetWeaponDataById
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  PrimaryAssetId                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAgentWeaponData*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAgentWeaponData* UDIDataStoreBlueprintLibrary::GetWeaponDataById(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIDataStoreBlueprintLibrary", "GetWeaponDataById");

	Params::DIDataStoreBlueprintLibrary_GetWeaponDataById Parms{};

	Parms.PrimaryAssetId = std::move(PrimaryAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetXpEventData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDIXpEventDataAsset*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDIXpEventDataAsset* UDIDataStoreBlueprintLibrary::GetXpEventData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIDataStoreBlueprintLibrary", "GetXpEventData");

	Params::DIDataStoreBlueprintLibrary_GetXpEventData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetXpProgressionData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EXpProgressionType                      ProgressionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UXpProgressionData*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UXpProgressionData* UDIDataStoreBlueprintLibrary::GetXpProgressionData(EXpProgressionType ProgressionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIDataStoreBlueprintLibrary", "GetXpProgressionData");

	Params::DIDataStoreBlueprintLibrary_GetXpProgressionData Parms{};

	Parms.ProgressionType = ProgressionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.EMPSphere.HandleActorDamaged
// (Final, Native, Protected)
// Parameters:
// class UHealthComponent*                 OwningHealthComp                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Health                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HealthDelta                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RawDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEMPSphere::HandleActorDamaged(class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, float RawDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EMPSphere", "HandleActorDamaged");

	Params::EMPSphere_HandleActorDamaged Parms{};

	Parms.OwningHealthComp = OwningHealthComp;
	Parms.Health = Health;
	Parms.HealthDelta = HealthDelta;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.RawDamage = RawDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.EMPSphere.NetMulticast_OnAttachToVictim
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEMPSphere::NetMulticast_OnAttachToVictim(class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EMPSphere", "NetMulticast_OnAttachToVictim");

	Params::EMPSphere_NetMulticast_OnAttachToVictim Parms{};

	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.EMPSphere.OnEMPSphereBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AEMPSphere::OnEMPSphereBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EMPSphere", "OnEMPSphereBeginOverlap");

	Params::EMPSphere_OnEMPSphereBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.EMPSphere.OnEMPSphereEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEMPSphere::OnEMPSphereEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EMPSphere", "OnEMPSphereEndOverlap");

	Params::EMPSphere_OnEMPSphereEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.EMPSphere.SetVictim
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewOwner                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEMPSphere::SetVictim(class AActor* NewOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EMPSphere", "SetVictim");

	Params::EMPSphere_SetVictim Parms{};

	Parms.NewOwner = NewOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIEndScreenMenuUserWidget.TriggerCarExfil
// (Final, Native, Protected, BlueprintCallable)

void UDIEndScreenMenuUserWidget::TriggerCarExfil()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIEndScreenMenuUserWidget", "TriggerCarExfil");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIFactionsManager.BP_IsFreeForAll
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIFactionsManager::BP_IsFreeForAll(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIFactionsManager", "BP_IsFreeForAll");

	Params::DIFactionsManager_BP_IsFreeForAll Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIFactionsManager.GetFactionId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ToCheck                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDIFactionsManager::GetFactionId(const class AActor* ToCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIFactionsManager", "GetFactionId");

	Params::DIFactionsManager_GetFactionId Parms{};

	Parms.ToCheck = ToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIFactionsManager.GetFactionMembers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   FactionID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADIPlayerState*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADIPlayerState*> UDIFactionsManager::GetFactionMembers(uint8 FactionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIFactionsManager", "GetFactionMembers");

	Params::DIFactionsManager_GetFactionMembers Parms{};

	Parms.FactionID = FactionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIFactionsManager.GetFactionMembersIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADIPlayerState*                   Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDIFactionsManager::GetFactionMembersIndex(class ADIPlayerState* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIFactionsManager", "GetFactionMembersIndex");

	Params::DIFactionsManager_GetFactionMembersIndex Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIFactionsManager.GetFactionSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UDIFactionsManager::GetFactionSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIFactionsManager", "GetFactionSize");

	Params::DIFactionsManager_GetFactionSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIFactionsManager.GetPlayerFactionMembers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADIPlayerState*                   Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADIPlayerState*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADIPlayerState*> UDIFactionsManager::GetPlayerFactionMembers(class ADIPlayerState* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIFactionsManager", "GetPlayerFactionMembers");

	Params::DIFactionsManager_GetPlayerFactionMembers Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIFactionsManager.HandleNameChange
// (Final, Native, Public)
// Parameters:
// class AController*                      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIFactionsManager::HandleNameChange(class AController* PlayerController, const class FString& PlayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIFactionsManager", "HandleNameChange");

	Params::DIFactionsManager_HandleNameChange Parms{};

	Parms.PlayerController = PlayerController;
	Parms.PlayerName = std::move(PlayerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIFactionsManager.HasAliveTeammates
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADIPlayerState*                   Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIFactionsManager::HasAliveTeammates(class ADIPlayerState* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIFactionsManager", "HasAliveTeammates");

	Params::DIFactionsManager_HasAliveTeammates Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIUserWidget.HandleHideLocalWidget
// (Final, Native, Protected)
// Parameters:
// bool                                    bHideHuds                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIUserWidget::HandleHideLocalWidget(bool bHideHuds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIUserWidget", "HandleHideLocalWidget");

	Params::DIUserWidget_HandleHideLocalWidget Parms{};

	Parms.bHideHuds = bHideHuds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIUserWidget.SetActorToFollow
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIUserWidget::SetActorToFollow(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIUserWidget", "SetActorToFollow");

	Params::DIUserWidget_SetActorToFollow Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIUserWidget.SetOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewOfsset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIUserWidget::SetOffset(const struct FVector& NewOfsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIUserWidget", "SetOffset");

	Params::DIUserWidget_SetOffset Parms{};

	Parms.NewOfsset = std::move(NewOfsset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIUserWidget.SetPosToFollow
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIUserWidget::SetPosToFollow(const struct FVector& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIUserWidget", "SetPosToFollow");

	Params::DIUserWidget_SetPosToFollow Parms{};

	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIUserWidget.GetCurrentWidgetFade
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDIUserWidget::GetCurrentWidgetFade() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIUserWidget", "GetCurrentWidgetFade");

	Params::DIUserWidget_GetCurrentWidgetFade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NavigationUserWidget.GetOwnerActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UNavigationUserWidget::GetOwnerActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationUserWidget", "GetOwnerActor");

	Params::NavigationUserWidget_GetOwnerActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NavigationUserWidget.OnNewDistance
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNavigationUserWidget::OnNewDistance(float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationUserWidget", "OnNewDistance");

	Params::NavigationUserWidget_OnNewDistance Parms{};

	Parms.Distance = Distance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.NavigationUserWidget.OnNewOwnerActor
// (Event, Public, BlueprintEvent)

void UNavigationUserWidget::OnNewOwnerActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationUserWidget", "OnNewOwnerActor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.NavigationUserWidget.SetOwnerActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewOwner                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNavigationUserWidget::SetOwnerActor(class AActor* NewOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationUserWidget", "SetOwnerActor");

	Params::NavigationUserWidget_SetOwnerActor Parms{};

	Parms.NewOwner = NewOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.FacingUserWidget.OnNewOwner
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           NewOwner                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFacingUserWidget::OnNewOwner(class AActor* NewOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FacingUserWidget", "OnNewOwner");

	Params::FacingUserWidget_OnNewOwner Parms{};

	Parms.NewOwner = NewOwner;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.GetCameraComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCameraComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraComponent* UDIFreecamSettingsMenuUserWidget::GetCameraComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIFreecamSettingsMenuUserWidget", "GetCameraComponent");

	Params::DIFreecamSettingsMenuUserWidget_GetCameraComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.SetAcceleration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIFreecamSettingsMenuUserWidget::SetAcceleration(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIFreecamSettingsMenuUserWidget", "SetAcceleration");

	Params::DIFreecamSettingsMenuUserWidget_SetAcceleration Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.SetCollisionsEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIFreecamSettingsMenuUserWidget::SetCollisionsEnabled(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIFreecamSettingsMenuUserWidget", "SetCollisionsEnabled");

	Params::DIFreecamSettingsMenuUserWidget_SetCollisionsEnabled Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.SetDeceleration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIFreecamSettingsMenuUserWidget::SetDeceleration(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIFreecamSettingsMenuUserWidget", "SetDeceleration");

	Params::DIFreecamSettingsMenuUserWidget_SetDeceleration Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.SetElevationLock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIFreecamSettingsMenuUserWidget::SetElevationLock(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIFreecamSettingsMenuUserWidget", "SetElevationLock");

	Params::DIFreecamSettingsMenuUserWidget_SetElevationLock Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.SetFOV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIFreecamSettingsMenuUserWidget::SetFOV(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIFreecamSettingsMenuUserWidget", "SetFOV");

	Params::DIFreecamSettingsMenuUserWidget_SetFOV Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.SetMaxSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIFreecamSettingsMenuUserWidget::SetMaxSpeed(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIFreecamSettingsMenuUserWidget", "SetMaxSpeed");

	Params::DIFreecamSettingsMenuUserWidget_SetMaxSpeed Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.GetAcceleration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDIFreecamSettingsMenuUserWidget::GetAcceleration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIFreecamSettingsMenuUserWidget", "GetAcceleration");

	Params::DIFreecamSettingsMenuUserWidget_GetAcceleration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.GetAccelerationLimit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDIFreecamSettingsMenuUserWidget::GetAccelerationLimit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIFreecamSettingsMenuUserWidget", "GetAccelerationLimit");

	Params::DIFreecamSettingsMenuUserWidget_GetAccelerationLimit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.GetDeceleration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDIFreecamSettingsMenuUserWidget::GetDeceleration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIFreecamSettingsMenuUserWidget", "GetDeceleration");

	Params::DIFreecamSettingsMenuUserWidget_GetDeceleration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.GetDecelerationLimit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDIFreecamSettingsMenuUserWidget::GetDecelerationLimit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIFreecamSettingsMenuUserWidget", "GetDecelerationLimit");

	Params::DIFreecamSettingsMenuUserWidget_GetDecelerationLimit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.GetElevationLock
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIFreecamSettingsMenuUserWidget::GetElevationLock() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIFreecamSettingsMenuUserWidget", "GetElevationLock");

	Params::DIFreecamSettingsMenuUserWidget_GetElevationLock Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.GetFOV
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDIFreecamSettingsMenuUserWidget::GetFOV() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIFreecamSettingsMenuUserWidget", "GetFOV");

	Params::DIFreecamSettingsMenuUserWidget_GetFOV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.GetMaxSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDIFreecamSettingsMenuUserWidget::GetMaxSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIFreecamSettingsMenuUserWidget", "GetMaxSpeed");

	Params::DIFreecamSettingsMenuUserWidget_GetMaxSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.GetMaxSpeedLimit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDIFreecamSettingsMenuUserWidget::GetMaxSpeedLimit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIFreecamSettingsMenuUserWidget", "GetMaxSpeedLimit");

	Params::DIFreecamSettingsMenuUserWidget_GetMaxSpeedLimit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.IsCollisionEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIFreecamSettingsMenuUserWidget::IsCollisionEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIFreecamSettingsMenuUserWidget", "IsCollisionEnabled");

	Params::DIFreecamSettingsMenuUserWidget_IsCollisionEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIFreeSpectator.ServerReturnToPlayer
// (Net, NetReliable, Native, Event, Protected, NetServer)

void ADIFreeSpectator::ServerReturnToPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIFreeSpectator", "ServerReturnToPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameInstanceBase.GetClientInformation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UClientInformation*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClientInformation* UDIGameInstanceBase::GetClientInformation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIGameInstanceBase", "GetClientInformation");

	Params::DIGameInstanceBase_GetClientInformation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameInstanceBase.GetGameplayEventBus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayEventBus*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayEventBus* UDIGameInstanceBase::GetGameplayEventBus(const class AActor* Requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIGameInstanceBase", "GetGameplayEventBus");

	Params::DIGameInstanceBase_GetGameplayEventBus Parms{};

	Parms.Requester = Requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameInstanceBase.GetLocalSpyEventBus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULocalSpyEventBus*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULocalSpyEventBus* UDIGameInstanceBase::GetLocalSpyEventBus(const class AActor* Requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIGameInstanceBase", "GetLocalSpyEventBus");

	Params::DIGameInstanceBase_GetLocalSpyEventBus Parms{};

	Parms.Requester = Requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameInstanceBase.IsCertTestingMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIGameInstanceBase::IsCertTestingMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIGameInstanceBase", "IsCertTestingMode");

	Params::DIGameInstanceBase_IsCertTestingMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameInstanceBase.IsDedicatedServerInstance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIGameInstanceBase::IsDedicatedServerInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIGameInstanceBase", "IsDedicatedServerInstance");

	Params::DIGameInstanceBase_IsDedicatedServerInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameInstanceBase.IsPlaytestBuild
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIGameInstanceBase::IsPlaytestBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIGameInstanceBase", "IsPlaytestBuild");

	Params::DIGameInstanceBase_IsPlaytestBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameInstanceBase.IsTrialApp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIGameInstanceBase::IsTrialApp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIGameInstanceBase", "IsTrialApp");

	Params::DIGameInstanceBase_IsTrialApp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameInstanceBase.DebugAddNativePlayer
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ABId                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIGameInstanceBase::DebugAddNativePlayer(const class FString& ABId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "DebugAddNativePlayer");

	Params::DIGameInstanceBase_DebugAddNativePlayer Parms{};

	Parms.ABId = std::move(ABId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameInstanceBase.DebugDoEOSConnect
// (Final, Exec, Native, Public)

void UDIGameInstanceBase::DebugDoEOSConnect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "DebugDoEOSConnect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameInstanceBase.DebugGetPUID
// (Final, Exec, Native, Public)

void UDIGameInstanceBase::DebugGetPUID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "DebugGetPUID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameInstanceBase.DebugStartProtectedSession
// (Final, Exec, Native, Public)

void UDIGameInstanceBase::DebugStartProtectedSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "DebugStartProtectedSession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameInstanceBase.DoClientStartup
// (Final, Native, Public, BlueprintCallable)

void UDIGameInstanceBase::DoClientStartup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "DoClientStartup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameInstanceBase.FlagLegalScreenShown
// (Final, Native, Public, BlueprintCallable)

void UDIGameInstanceBase::FlagLegalScreenShown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "FlagLegalScreenShown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameInstanceBase.FlashTaskbarIcon
// (Final, Native, Public, BlueprintCallable)

void UDIGameInstanceBase::FlashTaskbarIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "FlashTaskbarIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameInstanceBase.GetEULAAgreementText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             AgreementText                                          (Parm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDIGameInstanceBase::GetEULAAgreementText(const class FText& AgreementText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "GetEULAAgreementText");

	Params::DIGameInstanceBase_GetEULAAgreementText Parms{};

	Parms.AgreementText = std::move(AgreementText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameInstanceBase.GetPlayerNickname
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDIGameInstanceBase::GetPlayerNickname()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "GetPlayerNickname");

	Params::DIGameInstanceBase_GetPlayerNickname Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameInstanceBase.HandleDoFetchAgreementResponse
// (Final, Native, Protected)
// Parameters:
// class FString                           AgreementName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAgreementResponse               Response                                               (Parm, NativeAccessSpecifierPublic)
// class FString                           Error                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWasAlreadySigned                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIGameInstanceBase::HandleDoFetchAgreementResponse(const class FString& AgreementName, const struct FAgreementResponse& Response, const class FString& Error, bool bWasAlreadySigned)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "HandleDoFetchAgreementResponse");

	Params::DIGameInstanceBase_HandleDoFetchAgreementResponse Parms{};

	Parms.AgreementName = std::move(AgreementName);
	Parms.Response = std::move(Response);
	Parms.Error = std::move(Error);
	Parms.bWasAlreadySigned = bWasAlreadySigned;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameInstanceBase.HandleDoSignAgreementResponse
// (Final, Native, Protected)
// Parameters:
// class FString                           AgreementName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAgreementResponse               Response                                               (Parm, NativeAccessSpecifierPublic)
// class FString                           Error                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasBeenSigned                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIGameInstanceBase::HandleDoSignAgreementResponse(const class FString& AgreementName, const struct FAgreementResponse& Response, const class FString& Error, bool bHasBeenSigned)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "HandleDoSignAgreementResponse");

	Params::DIGameInstanceBase_HandleDoSignAgreementResponse Parms{};

	Parms.AgreementName = std::move(AgreementName);
	Parms.Response = std::move(Response);
	Parms.Error = std::move(Error);
	Parms.bHasBeenSigned = bHasBeenSigned;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameInstanceBase.HandleMenuEvent
// (Final, Native, Protected)
// Parameters:
// class FString                           EventName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AnswerValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIGameInstanceBase::HandleMenuEvent(const class FString& EventName, bool AnswerValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "HandleMenuEvent");

	Params::DIGameInstanceBase_HandleMenuEvent Parms{};

	Parms.EventName = std::move(EventName);
	Parms.AnswerValue = AnswerValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameInstanceBase.IsAppOwned
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIGameInstanceBase::IsAppOwned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "IsAppOwned");

	Params::DIGameInstanceBase_IsAppOwned Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameInstanceBase.IsInLoginState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EClientLoginStateFlags                  LoginState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIGameInstanceBase::IsInLoginState(EClientLoginStateFlags LoginState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "IsInLoginState");

	Params::DIGameInstanceBase_IsInLoginState Parms{};

	Parms.LoginState = LoginState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameInstanceBase.IsInMainMenuMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIGameInstanceBase::IsInMainMenuMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "IsInMainMenuMap");

	Params::DIGameInstanceBase_IsInMainMenuMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameInstanceBase.IsInPlayableMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIGameInstanceBase::IsInPlayableMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "IsInPlayableMap");

	Params::DIGameInstanceBase_IsInPlayableMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameInstanceBase.IsLinuxCL
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIGameInstanceBase::IsLinuxCL()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "IsLinuxCL");

	Params::DIGameInstanceBase_IsLinuxCL Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameInstanceBase.LogoutFromOnlineServices
// (Final, Native, Public, BlueprintCallable)

void UDIGameInstanceBase::LogoutFromOnlineServices()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "LogoutFromOnlineServices");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameInstanceBase.OnDIWebServiceLoginCompleted
// (Final, Native, Protected)
// Parameters:
// struct FLoginResponse                   LoginResponse                                          (Parm, NativeAccessSpecifierPublic)

void UDIGameInstanceBase::OnDIWebServiceLoginCompleted(const struct FLoginResponse& LoginResponse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "OnDIWebServiceLoginCompleted");

	Params::DIGameInstanceBase_OnDIWebServiceLoginCompleted Parms{};

	Parms.LoginResponse = std::move(LoginResponse);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameInstanceBase.QuitGame
// (Final, Native, Public, BlueprintCallable)

void UDIGameInstanceBase::QuitGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "QuitGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameInstanceBase.SetCurrentState
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             NewState                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIGameInstanceBase::SetCurrentState(const class FName& NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "SetCurrentState");

	Params::DIGameInstanceBase_SetCurrentState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameInstanceBase.ShowPlatformSpecificPlayerDetails
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDIOnlineFriendInfo*              Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIGameInstanceBase::ShowPlatformSpecificPlayerDetails(class UDIOnlineFriendInfo* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "ShowPlatformSpecificPlayerDetails");

	Params::DIGameInstanceBase_ShowPlatformSpecificPlayerDetails Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameInstanceBase.ShowPlatformSpecificPlayerDetailsForPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADIPlayerState*                   Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIGameInstanceBase::ShowPlatformSpecificPlayerDetailsForPlayer(class ADIPlayerState* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "ShowPlatformSpecificPlayerDetailsForPlayer");

	Params::DIGameInstanceBase_ShowPlatformSpecificPlayerDetailsForPlayer Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameInstanceBase.StartAccelByteServiceLogin
// (Final, Native, Public, BlueprintCallable)

void UDIGameInstanceBase::StartAccelByteServiceLogin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "StartAccelByteServiceLogin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameInstanceBase.StartClientOnlineServicesLogin
// (Final, Native, Public, BlueprintCallable)

void UDIGameInstanceBase::StartClientOnlineServicesLogin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "StartClientOnlineServicesLogin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameInstanceBase.TestTrophyEvents
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           TrophyId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIGameInstanceBase::TestTrophyEvents(const class FString& TrophyId, int32 Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "TestTrophyEvents");

	Params::DIGameInstanceBase_TestTrophyEvents Parms{};

	Parms.TrophyId = std::move(TrophyId);
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameInstanceBase.TryRefreshClientSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIGameInstanceBase::TryRefreshClientSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "TryRefreshClientSettings");

	Params::DIGameInstanceBase_TryRefreshClientSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameInstanceBase.TryUpsellFullGame
// (Final, Native, Public, BlueprintCallable)

void UDIGameInstanceBase::TryUpsellFullGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "TryUpsellFullGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameInstanceBase.UnlinkEOSConnect
// (Final, Exec, Native, Public)

void UDIGameInstanceBase::UnlinkEOSConnect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "UnlinkEOSConnect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameInstanceBase.GetAvailablePrivateLobbyRegions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UDIGameInstanceBase::GetAvailablePrivateLobbyRegions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "GetAvailablePrivateLobbyRegions");

	Params::DIGameInstanceBase_GetAvailablePrivateLobbyRegions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameInstanceBase.GetCurrentFeatureLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAvaliableFeatureLevel                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAvaliableFeatureLevel UDIGameInstanceBase::GetCurrentFeatureLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "GetCurrentFeatureLevel");

	Params::DIGameInstanceBase_GetCurrentFeatureLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameInstanceBase.GetCurrentState
// (Final, Native, Public, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UDIGameInstanceBase::GetCurrentState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "GetCurrentState");

	Params::DIGameInstanceBase_GetCurrentState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameInstanceBase.GetMaximumXPBoosterCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDIGameInstanceBase::GetMaximumXPBoosterCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "GetMaximumXPBoosterCount");

	Params::DIGameInstanceBase_GetMaximumXPBoosterCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameInstanceBase.GetNetInfoClientSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDINetInfoClientSettings   ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FDINetInfoClientSettings UDIGameInstanceBase::GetNetInfoClientSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "GetNetInfoClientSettings");

	Params::DIGameInstanceBase_GetNetInfoClientSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameInstanceBase.GetVersionnedClientConfigSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDIVersionedClientConfigSettingsReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FDIVersionedClientConfigSettings UDIGameInstanceBase::GetVersionnedClientConfigSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "GetVersionnedClientConfigSettings");

	Params::DIGameInstanceBase_GetVersionnedClientConfigSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameInstanceBase.IsFeatureLevelAvailable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAvaliableFeatureLevel                  InFeatureLevel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIGameInstanceBase::IsFeatureLevelAvailable(EAvaliableFeatureLevel InFeatureLevel) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "IsFeatureLevelAvailable");

	Params::DIGameInstanceBase_IsFeatureLevelAvailable Parms{};

	Parms.InFeatureLevel = InFeatureLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameInstanceBase.IsGameModeAvailable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EModeAvaliability                       InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIGameInstanceBase::IsGameModeAvailable(EModeAvaliability InMode) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "IsGameModeAvailable");

	Params::DIGameInstanceBase_IsGameModeAvailable Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameInstanceBase.WasLegalScreenShown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIGameInstanceBase::WasLegalScreenShown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameInstanceBase", "WasLegalScreenShown");

	Params::DIGameInstanceBase_WasLegalScreenShown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DropAtComponent.OnDropAtTimerEnd
// (Final, Native, Protected, HasDefaults)
// Parameters:
// struct FVector                          EndPos                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         EndRotation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UDropAtComponent::OnDropAtTimerEnd(const struct FVector& EndPos, const struct FRotator& EndRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DropAtComponent", "OnDropAtTimerEnd");

	Params::DropAtComponent_OnDropAtTimerEnd Parms{};

	Parms.EndPos = std::move(EndPos);
	Parms.EndRotation = std::move(EndRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DropAtComponent.OnRep_DropData
// (Final, Native, Protected)

void UDropAtComponent::OnRep_DropData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DropAtComponent", "OnRep_DropData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameRulesSubsystem.SetActiveRuleset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDIGameRuleset                          InNewRuleset                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBroadcastChange                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIGameRulesSubsystem::SetActiveRuleset(EDIGameRuleset InNewRuleset, bool bBroadcastChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameRulesSubsystem", "SetActiveRuleset");

	Params::DIGameRulesSubsystem_SetActiveRuleset Parms{};

	Parms.InNewRuleset = InNewRuleset;
	Parms.bBroadcastChange = bBroadcastChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIGameRulesSubsystem.GetActiveRuleset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDIGameRuleset                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDIGameRuleset UDIGameRulesSubsystem::GetActiveRuleset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameRulesSubsystem", "GetActiveRuleset");

	Params::DIGameRulesSubsystem_GetActiveRuleset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameRulesSubsystem.GetCorrespondingDataAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataAsset*                       InDataAsset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDIGameRuleset                          InRuleset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataAsset*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataAsset* UDIGameRulesSubsystem::GetCorrespondingDataAsset(class UDataAsset* InDataAsset, EDIGameRuleset InRuleset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameRulesSubsystem", "GetCorrespondingDataAsset");

	Params::DIGameRulesSubsystem_GetCorrespondingDataAsset Parms{};

	Parms.InDataAsset = InDataAsset;
	Parms.InRuleset = InRuleset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameRulesSubsystem.GetCorrespondingDataTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       InDataTable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDIGameRuleset                          InRuleset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UDIGameRulesSubsystem::GetCorrespondingDataTable(class UDataTable* InDataTable, EDIGameRuleset InRuleset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameRulesSubsystem", "GetCorrespondingDataTable");

	Params::DIGameRulesSubsystem_GetCorrespondingDataTable Parms{};

	Parms.InDataTable = InDataTable;
	Parms.InRuleset = InRuleset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameRulesSubsystem.GetCorrespondingObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDIGameRuleset                          InRuleset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UDIGameRulesSubsystem::GetCorrespondingObject(class UObject* InObject, EDIGameRuleset InRuleset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameRulesSubsystem", "GetCorrespondingObject");

	Params::DIGameRulesSubsystem_GetCorrespondingObject Parms{};

	Parms.InObject = InObject;
	Parms.InRuleset = InRuleset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameRulesSubsystem.IsAtLeastOneSpecialRuleInUse
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDISpecialRules                         InSpecialRule                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIGameRulesSubsystem::IsAtLeastOneSpecialRuleInUse(EDISpecialRules InSpecialRule) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameRulesSubsystem", "IsAtLeastOneSpecialRuleInUse");

	Params::DIGameRulesSubsystem_IsAtLeastOneSpecialRuleInUse Parms{};

	Parms.InSpecialRule = InSpecialRule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameRulesSubsystem.IsSpecialRuleInUse
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDISpecialRules                         InSpecialRule                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIGameRulesSubsystem::IsSpecialRuleInUse(EDISpecialRules InSpecialRule) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameRulesSubsystem", "IsSpecialRuleInUse");

	Params::DIGameRulesSubsystem_IsSpecialRuleInUse Parms{};

	Parms.InSpecialRule = InSpecialRule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIGameServerWebServiceSession.SendReport
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Reporter                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Reportee                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MatchId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIGameServerWebServiceSession::SendReport(const class FString& Reporter, const class FString& Reportee, const class FString& Message, const class FString& MatchId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIGameServerWebServiceSession", "SendReport");

	Params::DIGameServerWebServiceSession_SendReport Parms{};

	Parms.Reporter = std::move(Reporter);
	Parms.Reportee = std::move(Reportee);
	Parms.Message = std::move(Message);
	Parms.MatchId = std::move(MatchId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiKeybindActionEntryWidget.ListenForKeyBinding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   KeySlot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiKeybindActionEntryWidget::ListenForKeyBinding(int32 KeySlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiKeybindActionEntryWidget", "ListenForKeyBinding");

	Params::DiKeybindActionEntryWidget_ListenForKeyBinding Parms{};

	Parms.KeySlot = KeySlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiKeybindActionEntryWidget.Redraw
// (Final, Native, Public, BlueprintCallable)

void UDiKeybindActionEntryWidget::Redraw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiKeybindActionEntryWidget", "Redraw");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiKeybindActionEntryWidget.SetFromBindableKeyEntry
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FBindableKeyEntry                Src                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDiKeybindActionEntryWidget::SetFromBindableKeyEntry(const struct FBindableKeyEntry& Src)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiKeybindActionEntryWidget", "SetFromBindableKeyEntry");

	Params::DiKeybindActionEntryWidget_SetFromBindableKeyEntry Parms{};

	Parms.Src = std::move(Src);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiKeybindActionEntryWidget.SetInputDeviceType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EInputDeviceType                        InInputDevice                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiKeybindActionEntryWidget::SetInputDeviceType(EInputDeviceType InInputDevice)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiKeybindActionEntryWidget", "SetInputDeviceType");

	Params::DiKeybindActionEntryWidget_SetInputDeviceType Parms{};

	Parms.InInputDevice = InInputDevice;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiKeybindActionEntryWidget.UnbindKeys
// (Final, Native, Public, BlueprintCallable)

void UDiKeybindActionEntryWidget::UnbindKeys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiKeybindActionEntryWidget", "UnbindKeys");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiKeybindActionEntryWidget.GetActionName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDiKeybindActionEntryWidget::GetActionName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiKeybindActionEntryWidget", "GetActionName");

	Params::DiKeybindActionEntryWidget_GetActionName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiKeybindActionEntryWidget.GetCategory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EKeybindContext                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EKeybindContext UDiKeybindActionEntryWidget::GetCategory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiKeybindActionEntryWidget", "GetCategory");

	Params::DiKeybindActionEntryWidget_GetCategory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiKeybindActionEntryWidget.GetDisplayName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDiKeybindActionEntryWidget::GetDisplayName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiKeybindActionEntryWidget", "GetDisplayName");

	Params::DiKeybindActionEntryWidget_GetDisplayName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiKeybindActionEntryWidget.GetScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDiKeybindActionEntryWidget::GetScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiKeybindActionEntryWidget", "GetScale");

	Params::DiKeybindActionEntryWidget_GetScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiKeybindActionEntryWidget.IsTapAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiKeybindActionEntryWidget::IsTapAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiKeybindActionEntryWidget", "IsTapAction");

	Params::DiKeybindActionEntryWidget_IsTapAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.FakeMovementComponent.OnRep_FinalPos
// (Final, Native, Private)

void UFakeMovementComponent::OnRep_FinalPos()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FakeMovementComponent", "OnRep_FinalPos");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.FakeMovementComponent.OnRep_MovementEnabled
// (Final, Native, Private)

void UFakeMovementComponent::OnRep_MovementEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FakeMovementComponent", "OnRep_MovementEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiKeybindActionWidget.ListenForKeyBinding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   KeySlot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiKeybindActionWidget::ListenForKeyBinding(int32 KeySlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiKeybindActionWidget", "ListenForKeyBinding");

	Params::DiKeybindActionWidget_ListenForKeyBinding Parms{};

	Parms.KeySlot = KeySlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiKeybindActionWidget.Redraw
// (Final, Native, Public, BlueprintCallable)

void UDiKeybindActionWidget::Redraw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiKeybindActionWidget", "Redraw");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiKeybindActionWidget.SetFromBindableKeyEntry
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FBindableKeyEntry                Src                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDiKeybindActionWidget::SetFromBindableKeyEntry(const struct FBindableKeyEntry& Src)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiKeybindActionWidget", "SetFromBindableKeyEntry");

	Params::DiKeybindActionWidget_SetFromBindableKeyEntry Parms{};

	Parms.Src = std::move(Src);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiKeybindActionWidget.SetFromDiKeybindActionWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDiKeybindActionWidget*           Src                                                    (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiKeybindActionWidget::SetFromDiKeybindActionWidget(const class UDiKeybindActionWidget* Src)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiKeybindActionWidget", "SetFromDiKeybindActionWidget");

	Params::DiKeybindActionWidget_SetFromDiKeybindActionWidget Parms{};

	Parms.Src = Src;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIKillcamPlaybackManager.OnKillcamPlaybackComplete
// (Final, Native, Public)
// Parameters:
// class UWorld*                           PlaybackWorld                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIKillcamPlaybackManager::OnKillcamPlaybackComplete(class UWorld* PlaybackWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIKillcamPlaybackManager", "OnKillcamPlaybackComplete");

	Params::DIKillcamPlaybackManager_OnKillcamPlaybackComplete Parms{};

	Parms.PlaybackWorld = PlaybackWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIKillcamPlaybackManager.OnTimerFadeInCamera
// (Final, Native, Private)

void UDIKillcamPlaybackManager::OnTimerFadeInCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIKillcamPlaybackManager", "OnTimerFadeInCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DILoadingScreenWidget.BP_RemoveMapTexture
// (Event, Public, BlueprintEvent)

void UDILoadingScreenWidget::BP_RemoveMapTexture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DILoadingScreenWidget", "BP_RemoveMapTexture");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.DILoadingScreenWidget.BP_SetMapFlavor
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             FlavorText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDILoadingScreenWidget::BP_SetMapFlavor(const class FText& FlavorText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DILoadingScreenWidget", "BP_SetMapFlavor");

	Params::DILoadingScreenWidget_BP_SetMapFlavor Parms{};

	Parms.FlavorText = std::move(FlavorText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.DILoadingScreenWidget.BP_SetMapName
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             Name_0                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDILoadingScreenWidget::BP_SetMapName(const class FText& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DILoadingScreenWidget", "BP_SetMapName");

	Params::DILoadingScreenWidget_BP_SetMapName Parms{};

	Parms.Name_0 = std::move(Name_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.DILoadingScreenWidget.BP_SetMapSubtext
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             Subtext                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDILoadingScreenWidget::BP_SetMapSubtext(const class FText& Subtext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DILoadingScreenWidget", "BP_SetMapSubtext");

	Params::DILoadingScreenWidget_BP_SetMapSubtext Parms{};

	Parms.Subtext = std::move(Subtext);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.DILoadingScreenWidget.BP_SetMapTexture
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class UTexture2D>        MapTexture                                             (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDILoadingScreenWidget::BP_SetMapTexture(const TSoftObjectPtr<class UTexture2D>& MapTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DILoadingScreenWidget", "BP_SetMapTexture");

	Params::DILoadingScreenWidget_BP_SetMapTexture Parms{};

	Parms.MapTexture = MapTexture;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.DILoadingScreenWidget.BP_SetMapTexture2
// (Event, Public, BlueprintEvent)
// Parameters:
// class UTexture2D*                       MapTexture                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDILoadingScreenWidget::BP_SetMapTexture2(const class UTexture2D* MapTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DILoadingScreenWidget", "BP_SetMapTexture2");

	Params::DILoadingScreenWidget_BP_SetMapTexture2 Parms{};

	Parms.MapTexture = MapTexture;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.DILoadSubsystem.BP_HideLoadingScreen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDILoadSubsystem::BP_HideLoadingScreen(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DILoadSubsystem", "BP_HideLoadingScreen");

	Params::DILoadSubsystem_BP_HideLoadingScreen Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DILoadSubsystem.BP_ShowLoadingScreen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDILoadSubsystem::BP_ShowLoadingScreen(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DILoadSubsystem", "BP_ShowLoadingScreen");

	Params::DILoadSubsystem_BP_ShowLoadingScreen Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DILoadSubsystem.HideLoadingSreen
// (Final, Native, Public)

void UDILoadSubsystem::HideLoadingSreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DILoadSubsystem", "HideLoadingSreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DILoadSubsystem.PrepareLoading
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMapData*                         MapData                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDILoadSubsystem::PrepareLoading(const class UMapData* MapData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DILoadSubsystem", "PrepareLoading");

	Params::DILoadSubsystem_PrepareLoading Parms{};

	Parms.MapData = MapData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DILoadSubsystem.PrepareMovieLoadscreen
// (Final, Native, Protected)

void UDILoadSubsystem::PrepareMovieLoadscreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DILoadSubsystem", "PrepareMovieLoadscreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DILoadSubsystem.ShowLoadingSreen
// (Final, Native, Public)

void UDILoadSubsystem::ShowLoadingSreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DILoadSubsystem", "ShowLoadingSreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DILocalPlayer.IsInKillcam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDILocalPlayer::IsInKillcam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DILocalPlayer", "IsInKillcam");

	Params::DILocalPlayer_IsInKillcam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.GooPod.BP_OnToggleGoo
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGooPod::BP_OnToggleGoo(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GooPod", "BP_OnToggleGoo");

	Params::GooPod_BP_OnToggleGoo Parms{};

	Parms.bActive = bActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.GooPod.HandleCollisionBoxBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AGooPod::HandleCollisionBoxBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GooPod", "HandleCollisionBoxBeginOverlap");

	Params::GooPod_HandleCollisionBoxBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GooPod.HandleCollisionBoxEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGooPod::HandleCollisionBoxEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GooPod", "HandleCollisionBoxEndOverlap");

	Params::GooPod_HandleCollisionBoxEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GooPod.IsGooActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGooPod::IsGooActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GooPod", "IsGooActive");

	Params::GooPod_IsGooActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.GooPod.NetMulticast_ToggleGoo
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGooPod::NetMulticast_ToggleGoo(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GooPod", "NetMulticast_ToggleGoo");

	Params::GooPod_NetMulticast_ToggleGoo Parms{};

	Parms.bActive = bActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GooPod.OnPreDropConfirmation
// (Final, Native, Protected, HasOutParams)
// Parameters:
// bool                                    CanDropOut                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGooPod::OnPreDropConfirmation(bool* CanDropOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GooPod", "OnPreDropConfirmation");

	Params::GooPod_OnPreDropConfirmation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CanDropOut != nullptr)
		*CanDropOut = Parms.CanDropOut;
}


// Function DeceiveInc.GooPod.OnRep_GooWantsToBeActive
// (Final, Native, Protected)

void AGooPod::OnRep_GooWantsToBeActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GooPod", "OnRep_GooWantsToBeActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMainMenuUserWidget.DisplayMenuPageByEnum
// (Native, Public, BlueprintCallable)
// Parameters:
// EMainMenuPages                          MenuPage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMainMenuUserWidget::DisplayMenuPageByEnum(EMainMenuPages MenuPage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMainMenuUserWidget", "DisplayMenuPageByEnum");

	Params::DIMainMenuUserWidget_DisplayMenuPageByEnum Parms{};

	Parms.MenuPage = MenuPage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMainMenuUserWidget.GetIrisSubtitleWidget
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UDIMainMenuUserWidget::GetIrisSubtitleWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMainMenuUserWidget", "GetIrisSubtitleWidget");

	Params::DIMainMenuUserWidget_GetIrisSubtitleWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMainMenuUserWidget.GetOpenedMenuPage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMainMenuPages                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMainMenuPages UDIMainMenuUserWidget::GetOpenedMenuPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMainMenuUserWidget", "GetOpenedMenuPage");

	Params::DIMainMenuUserWidget_GetOpenedMenuPage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMainMenuUserWidget.GetSubtitleWidget
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UDIMainMenuUserWidget::GetSubtitleWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMainMenuUserWidget", "GetSubtitleWidget");

	Params::DIMainMenuUserWidget_GetSubtitleWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMatchesSubsystem.MatchUpdate
// (Final, Native, Protected)
// Parameters:
// bool                                    bForceMatchEnded                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMatchesSubsystem::MatchUpdate(bool bForceMatchEnded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMatchesSubsystem", "MatchUpdate");

	Params::DIMatchesSubsystem_MatchUpdate Parms{};

	Parms.bForceMatchEnded = bForceMatchEnded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMatchesSubsystem.MatchUpdateTimer
// (Final, Native, Protected)

void UDIMatchesSubsystem::MatchUpdateTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMatchesSubsystem", "MatchUpdateTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMatchesSubsystem.OnGameStateSetEvent
// (Final, Native, Protected)
// Parameters:
// class AGameStateBase*                   GameState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMatchesSubsystem::OnGameStateSetEvent(class AGameStateBase* GameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMatchesSubsystem", "OnGameStateSetEvent");

	Params::DIMatchesSubsystem_OnGameStateSetEvent Parms{};

	Parms.GameState = GameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMatchesSubsystem.OnMatchResultsPosted
// (Final, Native, Protected)

void UDIMatchesSubsystem::OnMatchResultsPosted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMatchesSubsystem", "OnMatchResultsPosted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMatchesSubsystem.OnMatchStateChanged
// (Final, Native, Protected)
// Parameters:
// class FName                             NewMatchState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMatchesSubsystem::OnMatchStateChanged(class FName NewMatchState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMatchesSubsystem", "OnMatchStateChanged");

	Params::DIMatchesSubsystem_OnMatchStateChanged Parms{};

	Parms.NewMatchState = NewMatchState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMatchesSubsystem.OnPostLoadMap
// (Final, Native, Protected)
// Parameters:
// class UWorld*                           LoadedWorld                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMatchesSubsystem::OnPostLoadMap(class UWorld* LoadedWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMatchesSubsystem", "OnPostLoadMap");

	Params::DIMatchesSubsystem_OnPostLoadMap Parms{};

	Parms.LoadedWorld = LoadedWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMatchesSubsystem.OnPreLoadMap
// (Final, Native, Protected)
// Parameters:
// class FString                           MapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMatchesSubsystem::OnPreLoadMap(const class FString& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMatchesSubsystem", "OnPreLoadMap");

	Params::DIMatchesSubsystem_OnPreLoadMap Parms{};

	Parms.MapName = std::move(MapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMatchesSubsystem.OnPS5MatchIdChanged
// (Final, Native, Protected)
// Parameters:
// class FString                           MatchId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMatchesSubsystem::OnPS5MatchIdChanged(const class FString& MatchId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMatchesSubsystem", "OnPS5MatchIdChanged");

	Params::DIMatchesSubsystem_OnPS5MatchIdChanged Parms{};

	Parms.MatchId = std::move(MatchId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMatchesSubsystem.OnPS5MatchResponsiblePlayerUpdated
// (Final, Native, Protected)
// Parameters:
// struct FUniqueNetIdRepl                 Player                                                 (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMatchesSubsystem::OnPS5MatchResponsiblePlayerUpdated(const struct FUniqueNetIdRepl& Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMatchesSubsystem", "OnPS5MatchResponsiblePlayerUpdated");

	Params::DIMatchesSubsystem_OnPS5MatchResponsiblePlayerUpdated Parms{};

	Parms.Player = std::move(Player);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMatchmakingRequestHandler.GetMatchmakingGameMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDIMenuGameModes                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDIMenuGameModes UDIMatchmakingRequestHandler::GetMatchmakingGameMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMatchmakingRequestHandler", "GetMatchmakingGameMode");

	Params::DIMatchmakingRequestHandler_GetMatchmakingGameMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMatchmakingRequestHandler.LeaveMatchmaking
// (Final, Native, Public, BlueprintCallable)

void UDIMatchmakingRequestHandler::LeaveMatchmaking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMatchmakingRequestHandler", "LeaveMatchmaking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMatchmakingTokenHandler.OnPingHandlerStabilized
// (Final, Native, Private)

void UDIMatchmakingTokenHandler::OnPingHandlerStabilized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMatchmakingTokenHandler", "OnPingHandlerStabilized");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.GetMenuName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMenuType                               Menu                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UDIMenuSubsystem::GetMenuName(EMenuType Menu)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIMenuSubsystem", "GetMenuName");

	Params::DIMenuSubsystem_GetMenuName Parms{};

	Parms.Menu = Menu;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.GetMenuTypeFromName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           MenuName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMenuType                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMenuType UDIMenuSubsystem::GetMenuTypeFromName(const class FString& MenuName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIMenuSubsystem", "GetMenuTypeFromName");

	Params::DIMenuSubsystem_GetMenuTypeFromName Parms{};

	Parms.MenuName = std::move(MenuName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.AddNewMenuToScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UDIMenuUserWidget>    MenuClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MenuName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDIMenuUserWidget*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDIMenuUserWidget* UDIMenuSubsystem::AddNewMenuToScreen(TSubclassOf<class UDIMenuUserWidget> MenuClass, class FName MenuName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "AddNewMenuToScreen");

	Params::DIMenuSubsystem_AddNewMenuToScreen Parms{};

	Parms.MenuClass = MenuClass;
	Parms.MenuName = MenuName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.AppHasFocus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIMenuSubsystem::AppHasFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "AppHasFocus");

	Params::DIMenuSubsystem_AppHasFocus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.ClearDisplayedAgent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   DisplayedIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuSubsystem::ClearDisplayedAgent(int32 DisplayedIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "ClearDisplayedAgent");

	Params::DIMenuSubsystem_ClearDisplayedAgent Parms{};

	Parms.DisplayedIndex = DisplayedIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.ClearDisplayedWrap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   DisplayedIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuSubsystem::ClearDisplayedWrap(int32 DisplayedIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "ClearDisplayedWrap");

	Params::DIMenuSubsystem_ClearDisplayedWrap Parms{};

	Parms.DisplayedIndex = DisplayedIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.DisplayAgentSelectionMenu
// (Final, Native, Public, BlueprintCallable)

void UDIMenuSubsystem::DisplayAgentSelectionMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "DisplayAgentSelectionMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.DisplayGamepadKeybindingsMenu
// (Final, Native, Public, BlueprintCallable)

void UDIMenuSubsystem::DisplayGamepadKeybindingsMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "DisplayGamepadKeybindingsMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.DisplayKeybindingsMenu
// (Final, Native, Public, BlueprintCallable)

void UDIMenuSubsystem::DisplayKeybindingsMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "DisplayKeybindingsMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.DisplayLegalMenu
// (Final, Native, Public, BlueprintCallable)

void UDIMenuSubsystem::DisplayLegalMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "DisplayLegalMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.DisplayLoginMenu
// (Final, Native, Public, BlueprintCallable)

void UDIMenuSubsystem::DisplayLoginMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "DisplayLoginMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.DisplayMainMenu
// (Final, Native, Public, BlueprintCallable)

void UDIMenuSubsystem::DisplayMainMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "DisplayMainMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.DisplayMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMenuType                               MenuToDisplay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuSubsystem::DisplayMenu(EMenuType MenuToDisplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "DisplayMenu");

	Params::DIMenuSubsystem_DisplayMenu Parms{};

	Parms.MenuToDisplay = MenuToDisplay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.DisplayPauseMenu
// (Final, Native, Public, BlueprintCallable)

void UDIMenuSubsystem::DisplayPauseMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "DisplayPauseMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.DisplayPhaseMenu
// (Final, Native, Public, BlueprintCallable)

void UDIMenuSubsystem::DisplayPhaseMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "DisplayPhaseMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.DisplayPopup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             TextToDisplay                                          (Parm, NativeAccessSpecifierPublic)
// class FString                           EventName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPopupType                              PopupType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDIPopupUserWidget*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDIPopupUserWidget* UDIMenuSubsystem::DisplayPopup(const class FText& TextToDisplay, const class FString& EventName, EPopupType PopupType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "DisplayPopup");

	Params::DIMenuSubsystem_DisplayPopup Parms{};

	Parms.TextToDisplay = std::move(TextToDisplay);
	Parms.EventName = std::move(EventName);
	Parms.PopupType = PopupType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.DisplayPopupInternal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             TitleToDisplay                                         (Parm, NativeAccessSpecifierPublic)
// class FText                             TextToDisplay                                          (Parm, NativeAccessSpecifierPublic)
// class FString                           EventName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPopupType                              PopupType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDIPopupUserWidget*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDIPopupUserWidget* UDIMenuSubsystem::DisplayPopupInternal(const class FText& TitleToDisplay, const class FText& TextToDisplay, const class FString& EventName, EPopupType PopupType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "DisplayPopupInternal");

	Params::DIMenuSubsystem_DisplayPopupInternal Parms{};

	Parms.TitleToDisplay = std::move(TitleToDisplay);
	Parms.TextToDisplay = std::move(TextToDisplay);
	Parms.EventName = std::move(EventName);
	Parms.PopupType = PopupType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.DisplaySettingsMenu
// (Final, Native, Public, BlueprintCallable)

void UDIMenuSubsystem::DisplaySettingsMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "DisplaySettingsMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.DisplaySpectatorMenu
// (Final, Native, Public, BlueprintCallable)

void UDIMenuSubsystem::DisplaySpectatorMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "DisplaySpectatorMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.DisplaySubMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESubMenuPages                           MenuPage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuSubsystem::DisplaySubMenu(ESubMenuPages MenuPage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "DisplaySubMenu");

	Params::DIMenuSubsystem_DisplaySubMenu Parms{};

	Parms.MenuPage = MenuPage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.GetCurrentGameMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDIMenuGameModes                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDIMenuGameModes UDIMenuSubsystem::GetCurrentGameMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "GetCurrentGameMode");

	Params::DIMenuSubsystem_GetCurrentGameMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.GetDisplayedAgent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   DisplayedIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UDIMenuSubsystem::GetDisplayedAgent(int32 DisplayedIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "GetDisplayedAgent");

	Params::DIMenuSubsystem_GetDisplayedAgent Parms{};

	Parms.DisplayedIndex = DisplayedIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.GetDisplayedAvatar
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   DisplayedIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UDIMenuSubsystem::GetDisplayedAvatar(int32 DisplayedIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "GetDisplayedAvatar");

	Params::DIMenuSubsystem_GetDisplayedAvatar Parms{};

	Parms.DisplayedIndex = DisplayedIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.GetDisplayedTitle
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   DisplayedIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UDIMenuSubsystem::GetDisplayedTitle(int32 DisplayedIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "GetDisplayedTitle");

	Params::DIMenuSubsystem_GetDisplayedTitle Parms{};

	Parms.DisplayedIndex = DisplayedIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.GetDisplayedWrap
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  WeaponId                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  WeaponWrapId                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DisplayedIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuSubsystem::GetDisplayedWrap(struct FPrimaryAssetId* WeaponId, struct FPrimaryAssetId* WeaponWrapId, int32 DisplayedIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "GetDisplayedWrap");

	Params::DIMenuSubsystem_GetDisplayedWrap Parms{};

	Parms.DisplayedIndex = DisplayedIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (WeaponId != nullptr)
		*WeaponId = std::move(Parms.WeaponId);

	if (WeaponWrapId != nullptr)
		*WeaponWrapId = std::move(Parms.WeaponWrapId);
}


// Function DeceiveInc.DIMenuSubsystem.GetLocalPosingSpy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APosingSpy*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APosingSpy* UDIMenuSubsystem::GetLocalPosingSpy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "GetLocalPosingSpy");

	Params::DIMenuSubsystem_GetLocalPosingSpy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.GetOrderedGadgetList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UGadgetData*>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UGadgetData*> UDIMenuSubsystem::GetOrderedGadgetList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "GetOrderedGadgetList");

	Params::DIMenuSubsystem_GetOrderedGadgetList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.GetOwningMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      UserWidget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDIMenuUserWidget*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDIMenuUserWidget* UDIMenuSubsystem::GetOwningMenu(class UUserWidget* UserWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "GetOwningMenu");

	Params::DIMenuSubsystem_GetOwningMenu Parms{};

	Parms.UserWidget = UserWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.GetWrapData
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  WrapId                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMenuWrapData*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuWrapData* UDIMenuSubsystem::GetWrapData(const struct FPrimaryAssetId& WrapId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "GetWrapData");

	Params::DIMenuSubsystem_GetWrapData Parms{};

	Parms.WrapId = std::move(WrapId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.GoToMainMenu
// (Final, Native, Public, BlueprintCallable)

void UDIMenuSubsystem::GoToMainMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "GoToMainMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.GoToMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MenuName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDIMenuUserWidget*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDIMenuUserWidget* UDIMenuSubsystem::GoToMenu(class FName MenuName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "GoToMenu");

	Params::DIMenuSubsystem_GoToMenu Parms{};

	Parms.MenuName = MenuName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.HandleMatchmakingStarted
// (Final, Native, Private)

void UDIMenuSubsystem::HandleMatchmakingStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "HandleMatchmakingStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.HandleMenuEvent
// (Final, Native, Public)
// Parameters:
// class FString                           EventName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AnswerValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuSubsystem::HandleMenuEvent(const class FString& EventName, bool AnswerValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "HandleMenuEvent");

	Params::DIMenuSubsystem_HandleMenuEvent Parms{};

	Parms.EventName = std::move(EventName);
	Parms.AnswerValue = AnswerValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.HandlePopupAnswered
// (Final, Native, Protected)
// Parameters:
// class FString                           EventName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AnswerValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuSubsystem::HandlePopupAnswered(const class FString& EventName, bool AnswerValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "HandlePopupAnswered");

	Params::DIMenuSubsystem_HandlePopupAnswered Parms{};

	Parms.EventName = std::move(EventName);
	Parms.AnswerValue = AnswerValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.HideCursor
// (Final, Native, Public, BlueprintCallable)

void UDIMenuSubsystem::HideCursor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "HideCursor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.IsCursorShown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIMenuSubsystem::IsCursorShown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "IsCursorShown");

	Params::DIMenuSubsystem_IsCursorShown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.IsGameModeSelectable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDIMenuGameModes                        GameMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIMenuSubsystem::IsGameModeSelectable(EDIMenuGameModes GameMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "IsGameModeSelectable");

	Params::DIMenuSubsystem_IsGameModeSelectable Parms{};

	Parms.GameMode = GameMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.IsMenuGameModeOffered
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDIMenuGameModes                        GameMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIMenuSubsystem::IsMenuGameModeOffered(EDIMenuGameModes GameMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "IsMenuGameModeOffered");

	Params::DIMenuSubsystem_IsMenuGameModeOffered Parms{};

	Parms.GameMode = GameMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.OnPartyMembersUpdated
// (Final, Native, Private)

void UDIMenuSubsystem::OnPartyMembersUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "OnPartyMembersUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.PlayDefaultMenuAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   DisplayedIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuSubsystem::PlayDefaultMenuAnim(int32 DisplayedIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "PlayDefaultMenuAnim");

	Params::DIMenuSubsystem_PlayDefaultMenuAnim Parms{};

	Parms.DisplayedIndex = DisplayedIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.PopSpecialAnnouncements
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIMenuSubsystem::PopSpecialAnnouncements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "PopSpecialAnnouncements");

	Params::DIMenuSubsystem_PopSpecialAnnouncements Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.RemoveAgentSelectionMenu
// (Final, Native, Public, BlueprintCallable)

void UDIMenuSubsystem::RemoveAgentSelectionMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "RemoveAgentSelectionMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.RemoveAllMenusFromScreen
// (Final, Native, Public, BlueprintCallable)

void UDIMenuSubsystem::RemoveAllMenusFromScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "RemoveAllMenusFromScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.RemoveAllPopupOfEventName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           EventName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuSubsystem::RemoveAllPopupOfEventName(const class FString& EventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "RemoveAllPopupOfEventName");

	Params::DIMenuSubsystem_RemoveAllPopupOfEventName Parms{};

	Parms.EventName = std::move(EventName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.RemoveAllPopupOfType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPopupType                              PopupType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuSubsystem::RemoveAllPopupOfType(EPopupType PopupType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "RemoveAllPopupOfType");

	Params::DIMenuSubsystem_RemoveAllPopupOfType Parms{};

	Parms.PopupType = PopupType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.RemoveGamepadKeybindingsMenu
// (Final, Native, Public, BlueprintCallable)

void UDIMenuSubsystem::RemoveGamepadKeybindingsMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "RemoveGamepadKeybindingsMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.RemoveKeybindingsMenu
// (Final, Native, Public, BlueprintCallable)

void UDIMenuSubsystem::RemoveKeybindingsMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "RemoveKeybindingsMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.RemoveLegalMenu
// (Final, Native, Public, BlueprintCallable)

void UDIMenuSubsystem::RemoveLegalMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "RemoveLegalMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.RemoveLoginMenu
// (Final, Native, Public, BlueprintCallable)

void UDIMenuSubsystem::RemoveLoginMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "RemoveLoginMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.RemoveMainMenu
// (Final, Native, Public, BlueprintCallable)

void UDIMenuSubsystem::RemoveMainMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "RemoveMainMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.RemoveMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMenuType                               MenuToRemove                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuSubsystem::RemoveMenu(EMenuType MenuToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "RemoveMenu");

	Params::DIMenuSubsystem_RemoveMenu Parms{};

	Parms.MenuToRemove = MenuToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.RemoveMenuFromScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MenuName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIMenuSubsystem::RemoveMenuFromScreen(class FName MenuName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "RemoveMenuFromScreen");

	Params::DIMenuSubsystem_RemoveMenuFromScreen Parms{};

	Parms.MenuName = MenuName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.RemoveMenuInstanceFromScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDIMenuUserWidget*                Menu                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIMenuSubsystem::RemoveMenuInstanceFromScreen(class UDIMenuUserWidget* Menu)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "RemoveMenuInstanceFromScreen");

	Params::DIMenuSubsystem_RemoveMenuInstanceFromScreen Parms{};

	Parms.Menu = Menu;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.RemovePauseMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIMenuSubsystem::RemovePauseMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "RemovePauseMenu");

	Params::DIMenuSubsystem_RemovePauseMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.RemovePhaseMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIMenuSubsystem::RemovePhaseMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "RemovePhaseMenu");

	Params::DIMenuSubsystem_RemovePhaseMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.RemoveSettingsMenu
// (Final, Native, Public, BlueprintCallable)

void UDIMenuSubsystem::RemoveSettingsMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "RemoveSettingsMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.RemoveSpectatorMenu
// (Final, Native, Public, BlueprintCallable)

void UDIMenuSubsystem::RemoveSpectatorMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "RemoveSpectatorMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.SetDisplayedAgent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  AgentSkinId                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DisplayedIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuSubsystem::SetDisplayedAgent(const struct FPrimaryAssetId& AgentSkinId, int32 DisplayedIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "SetDisplayedAgent");

	Params::DIMenuSubsystem_SetDisplayedAgent Parms{};

	Parms.AgentSkinId = std::move(AgentSkinId);
	Parms.DisplayedIndex = DisplayedIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.SetDisplayedAvatar
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  AvatarId                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DisplayedIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuSubsystem::SetDisplayedAvatar(const struct FPrimaryAssetId& AvatarId, int32 DisplayedIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "SetDisplayedAvatar");

	Params::DIMenuSubsystem_SetDisplayedAvatar Parms{};

	Parms.AvatarId = std::move(AvatarId);
	Parms.DisplayedIndex = DisplayedIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.SetDisplayedIntroPose
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  IntroPoseId                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DisplayedIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuSubsystem::SetDisplayedIntroPose(const struct FPrimaryAssetId& IntroPoseId, int32 DisplayedIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "SetDisplayedIntroPose");

	Params::DIMenuSubsystem_SetDisplayedIntroPose Parms{};

	Parms.IntroPoseId = std::move(IntroPoseId);
	Parms.DisplayedIndex = DisplayedIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.SetDisplayedIntroPoseToDefault
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   DisplayedIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuSubsystem::SetDisplayedIntroPoseToDefault(int32 DisplayedIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "SetDisplayedIntroPoseToDefault");

	Params::DIMenuSubsystem_SetDisplayedIntroPoseToDefault Parms{};

	Parms.DisplayedIndex = DisplayedIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.SetDisplayedTitle
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  TitleId                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DisplayedIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuSubsystem::SetDisplayedTitle(const struct FPrimaryAssetId& TitleId, int32 DisplayedIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "SetDisplayedTitle");

	Params::DIMenuSubsystem_SetDisplayedTitle Parms{};

	Parms.TitleId = std::move(TitleId);
	Parms.DisplayedIndex = DisplayedIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.SetDisplayedWrap
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  WeaponId                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  WrapId                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DisplayedIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuSubsystem::SetDisplayedWrap(const struct FPrimaryAssetId& WeaponId, const struct FPrimaryAssetId& WrapId, int32 DisplayedIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "SetDisplayedWrap");

	Params::DIMenuSubsystem_SetDisplayedWrap Parms{};

	Parms.WeaponId = std::move(WeaponId);
	Parms.WrapId = std::move(WrapId);
	Parms.DisplayedIndex = DisplayedIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.SetMenuGameMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDIMenuGameModes                        NewGameMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuSubsystem::SetMenuGameMode(EDIMenuGameModes NewGameMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "SetMenuGameMode");

	Params::DIMenuSubsystem_SetMenuGameMode Parms{};

	Parms.NewGameMode = NewGameMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.ShouldButtonPromptsBeDisplayed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIMenuSubsystem::ShouldButtonPromptsBeDisplayed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "ShouldButtonPromptsBeDisplayed");

	Params::DIMenuSubsystem_ShouldButtonPromptsBeDisplayed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.ShowCursor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDIMenuUserWidget*                UserWidget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIMenuSubsystem::ShowCursor(class UDIMenuUserWidget* UserWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "ShowCursor");

	Params::DIMenuSubsystem_ShowCursor Parms{};

	Parms.UserWidget = UserWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.StartPlayGameMode
// (Final, Native, Public, BlueprintCallable)

void UDIMenuSubsystem::StartPlayGameMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "StartPlayGameMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIMenuSubsystem.TogglePauseMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIMenuSubsystem::TogglePauseMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "TogglePauseMenu");

	Params::DIMenuSubsystem_TogglePauseMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.TogglePhaseMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIMenuSubsystem::TogglePhaseMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "TogglePhaseMenu");

	Params::DIMenuSubsystem_TogglePhaseMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.GetDataAssetDisplayDesc
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIPrimaryDataAsset*              DataAsset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDIMenuSubsystem::GetDataAssetDisplayDesc(class UDIPrimaryDataAsset* DataAsset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "GetDataAssetDisplayDesc");

	Params::DIMenuSubsystem_GetDataAssetDisplayDesc Parms{};

	Parms.DataAsset = DataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.GetDataAssetDisplayIcon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIPrimaryDataAsset*              DataAsset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UDIMenuSubsystem::GetDataAssetDisplayIcon(class UDIPrimaryDataAsset* DataAsset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "GetDataAssetDisplayIcon");

	Params::DIMenuSubsystem_GetDataAssetDisplayIcon Parms{};

	Parms.DataAsset = DataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.GetDataAssetDisplayName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIPrimaryDataAsset*              DataAsset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDIMenuSubsystem::GetDataAssetDisplayName(class UDIPrimaryDataAsset* DataAsset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "GetDataAssetDisplayName");

	Params::DIMenuSubsystem_GetDataAssetDisplayName Parms{};

	Parms.DataAsset = DataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.GetDataAssetRewardDesc
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIPrimaryDataAsset*              DataAsset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDIMenuSubsystem::GetDataAssetRewardDesc(class UDIPrimaryDataAsset* DataAsset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "GetDataAssetRewardDesc");

	Params::DIMenuSubsystem_GetDataAssetRewardDesc Parms{};

	Parms.DataAsset = DataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.GetDataAssetRewardIcon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIPrimaryDataAsset*              DataAsset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UDIMenuSubsystem::GetDataAssetRewardIcon(class UDIPrimaryDataAsset* DataAsset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "GetDataAssetRewardIcon");

	Params::DIMenuSubsystem_GetDataAssetRewardIcon Parms{};

	Parms.DataAsset = DataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.GetDataAssetRewardName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIPrimaryDataAsset*              DataAsset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDIMenuSubsystem::GetDataAssetRewardName(class UDIPrimaryDataAsset* DataAsset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "GetDataAssetRewardName");

	Params::DIMenuSubsystem_GetDataAssetRewardName Parms{};

	Parms.DataAsset = DataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.GetMenuFromName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDIMenuUserWidget*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDIMenuUserWidget* UDIMenuSubsystem::GetMenuFromName(class FName InName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "GetMenuFromName");

	Params::DIMenuSubsystem_GetMenuFromName Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.GetMOTDWidgets
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UMessageUserWidget*>       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UMessageUserWidget*> UDIMenuSubsystem::GetMOTDWidgets() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "GetMOTDWidgets");

	Params::DIMenuSubsystem_GetMOTDWidgets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.GetTopmostMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIMenuUserWidget*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDIMenuUserWidget* UDIMenuSubsystem::GetTopmostMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "GetTopmostMenu");

	Params::DIMenuSubsystem_GetTopmostMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.GetTopmostMenuName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UDIMenuSubsystem::GetTopmostMenuName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "GetTopmostMenuName");

	Params::DIMenuSubsystem_GetTopmostMenuName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.HasActiveMenus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIMenuSubsystem::HasActiveMenus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "HasActiveMenus");

	Params::DIMenuSubsystem_HasActiveMenus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.HasActiveMenusOrPopup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIMenuSubsystem::HasActiveMenusOrPopup() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "HasActiveMenusOrPopup");

	Params::DIMenuSubsystem_HasActiveMenusOrPopup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.IsGamepadUsableForMenus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIMenuSubsystem::IsGamepadUsableForMenus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "IsGamepadUsableForMenus");

	Params::DIMenuSubsystem_IsGamepadUsableForMenus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.IsInActiveMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIMenuSubsystem::IsInActiveMenu(class FName InName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "IsInActiveMenu");

	Params::DIMenuSubsystem_IsInActiveMenu Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.IsInActiveMenuInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIMenuUserWidget*                InMenu                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIMenuSubsystem::IsInActiveMenuInstance(class UDIMenuUserWidget* InMenu) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "IsInActiveMenuInstance");

	Params::DIMenuSubsystem_IsInActiveMenuInstance Parms{};

	Parms.InMenu = InMenu;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIMenuSubsystem.IsMenuBackKeyHeld
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIMenuSubsystem::IsMenuBackKeyHeld() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIMenuSubsystem", "IsMenuBackKeyHeld");

	Params::DIMenuSubsystem_IsMenuBackKeyHeld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.HansActiveAbilityMod1.BP_OnHansActiveProjectileHit
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactPoint                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactNormal                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHansActiveAbilityMod1::BP_OnHansActiveProjectileHit(class AActor* Victim, const struct FVector& ImpactPoint, const struct FVector& ImpactNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansActiveAbilityMod1", "BP_OnHansActiveProjectileHit");

	Params::HansActiveAbilityMod1_BP_OnHansActiveProjectileHit Parms{};

	Parms.Victim = Victim;
	Parms.ImpactPoint = std::move(ImpactPoint);
	Parms.ImpactNormal = std::move(ImpactNormal);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.HansActiveAbilityMod1.BP_OnHansTargetInfected
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           LastInfectedVictim                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewInfectedVictim                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHansActiveAbilityMod1::BP_OnHansTargetInfected(class AActor* LastInfectedVictim, class AActor* NewInfectedVictim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansActiveAbilityMod1", "BP_OnHansTargetInfected");

	Params::HansActiveAbilityMod1_BP_OnHansTargetInfected Parms{};

	Parms.LastInfectedVictim = LastInfectedVictim;
	Parms.NewInfectedVictim = NewInfectedVictim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.HansActiveAbilityMod1.BP_OnLocalHansActiveEnd
// (Event, Protected, BlueprintEvent)

void AHansActiveAbilityMod1::BP_OnLocalHansActiveEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansActiveAbilityMod1", "BP_OnLocalHansActiveEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.HansActiveAbilityMod1.BP_OnLocalHansActiveStart
// (Event, Protected, BlueprintEvent)

void AHansActiveAbilityMod1::BP_OnLocalHansActiveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansActiveAbilityMod1", "BP_OnLocalHansActiveStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.HansActiveAbilityMod1.HandleDelayedSpreadInfection
// (Final, Native, Protected)

void AHansActiveAbilityMod1::HandleDelayedSpreadInfection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansActiveAbilityMod1", "HandleDelayedSpreadInfection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HansActiveAbilityMod1.MulticastFireShot
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FVector_NetQuantize              DestinationPos                                         (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHansActiveAbilityMod1::MulticastFireShot(const struct FVector_NetQuantize& DestinationPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansActiveAbilityMod1", "MulticastFireShot");

	Params::HansActiveAbilityMod1_MulticastFireShot Parms{};

	Parms.DestinationPos = std::move(DestinationPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HansActiveAbilityMod1.MulticastNewInfectedVictim
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           LastInfectedVictim                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewInfectedVictim                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHansActiveAbilityMod1::MulticastNewInfectedVictim(class AActor* LastInfectedVictim, class AActor* NewInfectedVictim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansActiveAbilityMod1", "MulticastNewInfectedVictim");

	Params::HansActiveAbilityMod1_MulticastNewInfectedVictim Parms{};

	Parms.LastInfectedVictim = LastInfectedVictim;
	Parms.NewInfectedVictim = NewInfectedVictim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HansActiveAbilityMod1.MulticastProjectileHit
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              ImpactPos                                              (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ImpactNormal                                           (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHansActiveAbilityMod1::MulticastProjectileHit(class AActor* Victim, const struct FVector_NetQuantize& ImpactPos, const struct FVector_NetQuantizeNormal& ImpactNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansActiveAbilityMod1", "MulticastProjectileHit");

	Params::HansActiveAbilityMod1_MulticastProjectileHit Parms{};

	Parms.Victim = Victim;
	Parms.ImpactPos = std::move(ImpactPos);
	Parms.ImpactNormal = std::move(ImpactNormal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HansActiveAbilityMod1.OnAfterShotTimerEnd
// (Final, Native, Protected)

void AHansActiveAbilityMod1::OnAfterShotTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansActiveAbilityMod1", "OnAfterShotTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HansActiveAbilityMod1.OnServerHansActiveEnd
// (Final, Native, Protected)

void AHansActiveAbilityMod1::OnServerHansActiveEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansActiveAbilityMod1", "OnServerHansActiveEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HansActiveAbilityMod1.Server_StartHansActive
// (Net, NetReliable, Native, Event, Protected, NetServer)

void AHansActiveAbilityMod1::Server_StartHansActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansActiveAbilityMod1", "Server_StartHansActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HansActiveAbilityMod1.GetMuzzlePosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AHansActiveAbilityMod1::GetMuzzlePosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansActiveAbilityMod1", "GetMuzzlePosition");

	Params::HansActiveAbilityMod1_GetMuzzlePosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.GetMaxPartySizeForGameMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDIGameMode                             NewMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDIPartySubsystem::GetMaxPartySizeForGameMode(EDIGameMode NewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIPartySubsystem", "GetMaxPartySizeForGameMode");

	Params::DIPartySubsystem_GetMaxPartySizeForGameMode Parms{};

	Parms.NewMode = NewMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.GetMinPartySizeForGameMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDIGameMode                             NewMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDIPartySubsystem::GetMinPartySizeForGameMode(EDIGameMode NewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DIPartySubsystem", "GetMinPartySizeForGameMode");

	Params::DIPartySubsystem_GetMinPartySizeForGameMode Parms{};

	Parms.NewMode = NewMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.AcceptPartyInviteFrom
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           InviteSourceName                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIPartySubsystem::AcceptPartyInviteFrom(const class FString& InviteSourceName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "AcceptPartyInviteFrom");

	Params::DIPartySubsystem_AcceptPartyInviteFrom Parms{};

	Parms.InviteSourceName = std::move(InviteSourceName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPartySubsystem.CanInviteToParty
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIPartySubsystem::CanInviteToParty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "CanInviteToParty");

	Params::DIPartySubsystem_CanInviteToParty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.CanStartMatchmaking
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIPartySubsystem::CanStartMatchmaking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "CanStartMatchmaking");

	Params::DIPartySubsystem_CanStartMatchmaking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.CreateParty
// (Final, Native, Public, BlueprintCallable)

void UDIPartySubsystem::CreateParty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "CreateParty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPartySubsystem.EnsurePartyAndGameModeCompatibility
// (Final, Native, Public, BlueprintCallable)

void UDIPartySubsystem::EnsurePartyAndGameModeCompatibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "EnsurePartyAndGameModeCompatibility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPartySubsystem.GetInviteeName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDIPartySubsystem::GetInviteeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "GetInviteeName");

	Params::DIPartySubsystem_GetInviteeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.GetNbrPendingInvites
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDIPartySubsystem::GetNbrPendingInvites()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "GetNbrPendingInvites");

	Params::DIPartySubsystem_GetNbrPendingInvites Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.GetPartyMemberByDisplayIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   DisplayIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDIOnlinePartyMemberInfo*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDIOnlinePartyMemberInfo* UDIPartySubsystem::GetPartyMemberByDisplayIndex(int32 DisplayIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "GetPartyMemberByDisplayIndex");

	Params::DIPartySubsystem_GetPartyMemberByDisplayIndex Parms{};

	Parms.DisplayIndex = DisplayIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.InviteFriend
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDIOnlineFriendInfo*              FriendInfo                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIPartySubsystem::InviteFriend(const class UDIOnlineFriendInfo* FriendInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "InviteFriend");

	Params::DIPartySubsystem_InviteFriend Parms{};

	Parms.FriendInfo = FriendInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPartySubsystem.InvitePlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           PlayerUId                                              (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIPartySubsystem::InvitePlayer(const class FString& PlayerUId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "InvitePlayer");

	Params::DIPartySubsystem_InvitePlayer Parms{};

	Parms.PlayerUId = std::move(PlayerUId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPartySubsystem.IsAllowedCrossplay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIPartySubsystem::IsAllowedCrossplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "IsAllowedCrossplay");

	Params::DIPartySubsystem_IsAllowedCrossplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.IsGameCompatibleWithCurrentParty
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDIGameMode                             GameMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIPartySubsystem::IsGameCompatibleWithCurrentParty(EDIGameMode GameMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "IsGameCompatibleWithCurrentParty");

	Params::DIPartySubsystem_IsGameCompatibleWithCurrentParty Parms{};

	Parms.GameMode = GameMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.IsGameModeSelectable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDIGameMode                             GameMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIPartySubsystem::IsGameModeSelectable(EDIGameMode GameMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "IsGameModeSelectable");

	Params::DIPartySubsystem_IsGameModeSelectable Parms{};

	Parms.GameMode = GameMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.IsInSoloPartyOrNotInParty
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIPartySubsystem::IsInSoloPartyOrNotInParty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "IsInSoloPartyOrNotInParty");

	Params::DIPartySubsystem_IsInSoloPartyOrNotInParty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.IsPartyMemberLeader
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDIOnlinePartyMemberInfo*         PartyMember                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIPartySubsystem::IsPartyMemberLeader(class UDIOnlinePartyMemberInfo* PartyMember)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "IsPartyMemberLeader");

	Params::DIPartySubsystem_IsPartyMemberLeader Parms{};

	Parms.PartyMember = PartyMember;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.KickMember
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDIOnlinePartyMemberInfo*         PartyMember                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIPartySubsystem::KickMember(class UDIOnlinePartyMemberInfo* PartyMember)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "KickMember");

	Params::DIPartySubsystem_KickMember Parms{};

	Parms.PartyMember = PartyMember;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPartySubsystem.LeaveParty
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSynchronized                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIPartySubsystem::LeaveParty(bool bSynchronized)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "LeaveParty");

	Params::DIPartySubsystem_LeaveParty Parms{};

	Parms.bSynchronized = bSynchronized;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPartySubsystem.RejectPartyInviteFrom
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           InviteSourceName                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIPartySubsystem::RejectPartyInviteFrom(const class FString& InviteSourceName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "RejectPartyInviteFrom");

	Params::DIPartySubsystem_RejectPartyInviteFrom Parms{};

	Parms.InviteSourceName = std::move(InviteSourceName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPartySubsystem.TrySetCurrentGameMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDIGameMode                             NewMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDIGameMode                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDIGameMode UDIPartySubsystem::TrySetCurrentGameMode(EDIGameMode NewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "TrySetCurrentGameMode");

	Params::DIPartySubsystem_TrySetCurrentGameMode Parms{};

	Parms.NewMode = NewMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.TryStartMatchmaking
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIPartySubsystem::TryStartMatchmaking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "TryStartMatchmaking");

	Params::DIPartySubsystem_TryStartMatchmaking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.WritePartyData
// (Final, Native, Protected, BlueprintCallable)

void UDIPartySubsystem::WritePartyData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "WritePartyData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPartySubsystem.GetCurrentGameMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDIGameMode                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDIGameMode UDIPartySubsystem::GetCurrentGameMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "GetCurrentGameMode");

	Params::DIPartySubsystem_GetCurrentGameMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.GetInvitationForDIOnlineFriend
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIOnlineFriendInfo*              FriendInfo                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDIOnlinePartyInvite*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDIOnlinePartyInvite* UDIPartySubsystem::GetInvitationForDIOnlineFriend(const class UDIOnlineFriendInfo* FriendInfo) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "GetInvitationForDIOnlineFriend");

	Params::DIPartySubsystem_GetInvitationForDIOnlineFriend Parms{};

	Parms.FriendInfo = FriendInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.GetLocalPartyMember
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIOnlinePartyMemberInfo*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDIOnlinePartyMemberInfo* UDIPartySubsystem::GetLocalPartyMember() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "GetLocalPartyMember");

	Params::DIPartySubsystem_GetLocalPartyMember Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.GetMatchmakingAvailabilityForCurrentMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMatchmakingAvailability                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMatchmakingAvailability UDIPartySubsystem::GetMatchmakingAvailabilityForCurrentMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "GetMatchmakingAvailabilityForCurrentMode");

	Params::DIPartySubsystem_GetMatchmakingAvailabilityForCurrentMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.GetMatchmakingAvailabilityForMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDIGameMode                             GameMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMatchmakingAvailability                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMatchmakingAvailability UDIPartySubsystem::GetMatchmakingAvailabilityForMode(EDIGameMode GameMode) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "GetMatchmakingAvailabilityForMode");

	Params::DIPartySubsystem_GetMatchmakingAvailabilityForMode Parms{};

	Parms.GameMode = GameMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.GetNumberOfPlayersInPartyIncludingSelf
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDIPartySubsystem::GetNumberOfPlayersInPartyIncludingSelf() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "GetNumberOfPlayersInPartyIncludingSelf");

	Params::DIPartySubsystem_GetNumberOfPlayersInPartyIncludingSelf Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.IsAllPartyMembersReady
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIPartySubsystem::IsAllPartyMembersReady() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "IsAllPartyMembersReady");

	Params::DIPartySubsystem_IsAllPartyMembersReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.IsBeginnerProtectionEnabledForCurrentGameMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIPartySubsystem::IsBeginnerProtectionEnabledForCurrentGameMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "IsBeginnerProtectionEnabledForCurrentGameMode");

	Params::DIPartySubsystem_IsBeginnerProtectionEnabledForCurrentGameMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.IsGameModeOffered
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDIGameMode                             GameMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIPartySubsystem::IsGameModeOffered(EDIGameMode GameMode) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "IsGameModeOffered");

	Params::DIPartySubsystem_IsGameModeOffered Parms{};

	Parms.GameMode = GameMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.IsInParty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIPartySubsystem::IsInParty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "IsInParty");

	Params::DIPartySubsystem_IsInParty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.IsLocalPartyMember
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIOnlinePartyMemberInfo*         Member                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIPartySubsystem::IsLocalPartyMember(class UDIOnlinePartyMemberInfo* Member) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "IsLocalPartyMember");

	Params::DIPartySubsystem_IsLocalPartyMember Parms{};

	Parms.Member = Member;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPartySubsystem.IsPartyLeader
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIPartySubsystem::IsPartyLeader() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPartySubsystem", "IsPartyLeader");

	Params::DIPartySubsystem_IsPartyLeader Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.HackTrapScannerTool.NetMulticast_OnNewAnnouncement
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHackTrapScannerTool::NetMulticast_OnNewAnnouncement(class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HackTrapScannerTool", "NetMulticast_OnNewAnnouncement");

	Params::HackTrapScannerTool_NetMulticast_OnNewAnnouncement Parms{};

	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HackTrapScannerTool.NetMulticast_OnTrapTrigger
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class UHackTrapScannableComponent*      Trap                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHackTrapScannerTool::NetMulticast_OnTrapTrigger(class UHackTrapScannableComponent* Trap, class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HackTrapScannerTool", "NetMulticast_OnTrapTrigger");

	Params::HackTrapScannerTool_NetMulticast_OnTrapTrigger Parms{};

	Parms.Trap = Trap;
	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HackTrapScannerTool.OnAnnouncementTimerEnd
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHackTrapScannerTool::OnAnnouncementTimerEnd(class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HackTrapScannerTool", "OnAnnouncementTimerEnd");

	Params::HackTrapScannerTool_OnAnnouncementTimerEnd Parms{};

	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HackTrapScannerTool.OnCooldownChange
// (Native, Protected)
// Parameters:
// bool                                    bOnCooldown                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHackTrapScannerTool::OnCooldownChange(bool bOnCooldown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HackTrapScannerTool", "OnCooldownChange");

	Params::HackTrapScannerTool_OnCooldownChange Parms{};

	Parms.bOnCooldown = bOnCooldown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPingWidget.BP_SetupPingData
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FPingData                        PingData                                               (Parm, NativeAccessSpecifierPublic)

void UDIPingWidget::BP_SetupPingData(const struct FPingData& PingData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPingWidget", "BP_SetupPingData");

	Params::DIPingWidget_BP_SetupPingData Parms{};

	Parms.PingData = std::move(PingData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.DIPingWidget.BP_SetupTeamIndex
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   TeamIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIPingWidget::BP_SetupTeamIndex(int32 TeamIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPingWidget", "BP_SetupTeamIndex");

	Params::DIPingWidget_BP_SetupTeamIndex Parms{};

	Parms.TeamIndex = TeamIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.IsDX12Enabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiPlayerSettingsSubsystem::IsDX12Enabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DiPlayerSettingsSubsystem", "IsDX12Enabled");

	Params::DiPlayerSettingsSubsystem_IsDX12Enabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.AddKeyForEnhancedAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInputAction*                     InputAction                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             Binding                                                (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EKeybindContext                         Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AxisScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputDeviceType                        DeviceType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiPlayerSettingsSubsystem::AddKeyForEnhancedAction(const class UInputAction* InputAction, const struct FKey& Binding, EKeybindContext Context, float AxisScale, EInputDeviceType DeviceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "AddKeyForEnhancedAction");

	Params::DiPlayerSettingsSubsystem_AddKeyForEnhancedAction Parms{};

	Parms.InputAction = InputAction;
	Parms.Binding = std::move(Binding);
	Parms.Context = Context;
	Parms.AxisScale = AxisScale;
	Parms.DeviceType = DeviceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.ApplyDefaultInputMappings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EInputDeviceType                        DeviceType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiPlayerSettingsSubsystem::ApplyDefaultInputMappings(EInputDeviceType DeviceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "ApplyDefaultInputMappings");

	Params::DiPlayerSettingsSubsystem_ApplyDefaultInputMappings Parms{};

	Parms.DeviceType = DeviceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.CallSettingAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiPlayerSettingsSubsystem::CallSettingAction(EPlayerSettingsType SettingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "CallSettingAction");

	Params::DiPlayerSettingsSubsystem_CallSettingAction Parms{};

	Parms.SettingType = SettingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.CommitKeybindingChanges
// (Final, Native, Public, BlueprintCallable)

void UDiPlayerSettingsSubsystem::CommitKeybindingChanges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "CommitKeybindingChanges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetActionsForCategory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EKeybindContext                         Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FBindableKeyEntry>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FBindableKeyEntry> UDiPlayerSettingsSubsystem::GetActionsForCategory(EKeybindContext Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetActionsForCategory");

	Params::DiPlayerSettingsSubsystem_GetActionsForCategory Parms{};

	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetAxesForCategory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EKeybindContext                         Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FBindableKeyEntry>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FBindableKeyEntry> UDiPlayerSettingsSubsystem::GetAxesForCategory(EKeybindContext Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetAxesForCategory");

	Params::DiPlayerSettingsSubsystem_GetAxesForCategory Parms{};

	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetBindableActions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FBindableKeyEntry>  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<struct FBindableKeyEntry> UDiPlayerSettingsSubsystem::GetBindableActions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetBindableActions");

	Params::DiPlayerSettingsSubsystem_GetBindableActions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetBindingCategories
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<EKeybindContext>                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<EKeybindContext> UDiPlayerSettingsSubsystem::GetBindingCategories()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetBindingCategories");

	Params::DiPlayerSettingsSubsystem_GetBindingCategories Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetDefaultKeysForEnhancedAction
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UInputAction*                     InputAction                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FKey>                     OutBindings                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// EKeybindContext                         Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AxisScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputDeviceType                        DeviceType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiPlayerSettingsSubsystem::GetDefaultKeysForEnhancedAction(const class UInputAction* InputAction, TArray<struct FKey>* OutBindings, EKeybindContext Context, float AxisScale, EInputDeviceType DeviceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetDefaultKeysForEnhancedAction");

	Params::DiPlayerSettingsSubsystem_GetDefaultKeysForEnhancedAction Parms{};

	Parms.InputAction = InputAction;
	Parms.Context = Context;
	Parms.AxisScale = AxisScale;
	Parms.DeviceType = DeviceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBindings != nullptr)
		*OutBindings = std::move(Parms.OutBindings);
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetFirstMappingContext
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EKeybindContext                         Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputDeviceType                        DeviceType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInputMappingContext*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInputMappingContext* UDiPlayerSettingsSubsystem::GetFirstMappingContext(EKeybindContext Context, EInputDeviceType DeviceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetFirstMappingContext");

	Params::DiPlayerSettingsSubsystem_GetFirstMappingContext Parms{};

	Parms.Context = Context;
	Parms.DeviceType = DeviceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetKeysForEnhancedAction
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UInputAction*                     InputAction                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FKey>                     OutBindings                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// EKeybindContext                         Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AxisScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputDeviceType                        DeviceType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiPlayerSettingsSubsystem::GetKeysForEnhancedAction(const class UInputAction* InputAction, TArray<struct FKey>* OutBindings, EKeybindContext Context, float AxisScale, EInputDeviceType DeviceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetKeysForEnhancedAction");

	Params::DiPlayerSettingsSubsystem_GetKeysForEnhancedAction Parms{};

	Parms.InputAction = InputAction;
	Parms.Context = Context;
	Parms.AxisScale = AxisScale;
	Parms.DeviceType = DeviceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBindings != nullptr)
		*OutBindings = std::move(Parms.OutBindings);
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetMappingContexts
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EKeybindContext                         Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputDeviceType                        DeviceType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UInputMappingContext*>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UInputMappingContext*> UDiPlayerSettingsSubsystem::GetMappingContexts(EKeybindContext Context, EInputDeviceType DeviceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetMappingContexts");

	Params::DiPlayerSettingsSubsystem_GetMappingContexts Parms{};

	Parms.Context = Context;
	Parms.DeviceType = DeviceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.RemoveKeyFromEnhancedAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInputAction*                     InputAction                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             Binding                                                (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EKeybindContext                         Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AxisScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputDeviceType                        DeviceType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiPlayerSettingsSubsystem::RemoveKeyFromEnhancedAction(const class UInputAction* InputAction, const struct FKey& Binding, EKeybindContext Context, float AxisScale, EInputDeviceType DeviceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "RemoveKeyFromEnhancedAction");

	Params::DiPlayerSettingsSubsystem_RemoveKeyFromEnhancedAction Parms{};

	Parms.InputAction = InputAction;
	Parms.Binding = std::move(Binding);
	Parms.Context = Context;
	Parms.AxisScale = AxisScale;
	Parms.DeviceType = DeviceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.ResetToDefaultKeysForEnhancedAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInputAction*                     InputAction                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EKeybindContext                         Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputDeviceType                        DeviceType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiPlayerSettingsSubsystem::ResetToDefaultKeysForEnhancedAction(const class UInputAction* InputAction, EKeybindContext Context, EInputDeviceType DeviceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "ResetToDefaultKeysForEnhancedAction");

	Params::DiPlayerSettingsSubsystem_ResetToDefaultKeysForEnhancedAction Parms{};

	Parms.InputAction = InputAction;
	Parms.Context = Context;
	Parms.DeviceType = DeviceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.SetContextuallyDisabledSetting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDisabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiPlayerSettingsSubsystem::SetContextuallyDisabledSetting(EPlayerSettingsType SettingType, bool bDisabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "SetContextuallyDisabledSetting");

	Params::DiPlayerSettingsSubsystem_SetContextuallyDisabledSetting Parms{};

	Parms.SettingType = SettingType;
	Parms.bDisabled = bDisabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.SetSettingCurrentValue_Boolean
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiPlayerSettingsSubsystem::SetSettingCurrentValue_Boolean(EPlayerSettingsType SettingType, bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "SetSettingCurrentValue_Boolean");

	Params::DiPlayerSettingsSubsystem_SetSettingCurrentValue_Boolean Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.SetSettingCurrentValue_Float
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiPlayerSettingsSubsystem::SetSettingCurrentValue_Float(EPlayerSettingsType SettingType, float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "SetSettingCurrentValue_Float");

	Params::DiPlayerSettingsSubsystem_SetSettingCurrentValue_Float Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.SetSettingCurrentValue_Integer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiPlayerSettingsSubsystem::SetSettingCurrentValue_Integer(EPlayerSettingsType SettingType, int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "SetSettingCurrentValue_Integer");

	Params::DiPlayerSettingsSubsystem_SetSettingCurrentValue_Integer Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.SetSettingCurrentValue_String
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NewValue                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiPlayerSettingsSubsystem::SetSettingCurrentValue_String(EPlayerSettingsType SettingType, const class FString& NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "SetSettingCurrentValue_String");

	Params::DiPlayerSettingsSubsystem_SetSettingCurrentValue_String Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = std::move(NewValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingCurrentValue_Boolean
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiPlayerSettingsSubsystem::GetSettingCurrentValue_Boolean(EPlayerSettingsType SettingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetSettingCurrentValue_Boolean");

	Params::DiPlayerSettingsSubsystem_GetSettingCurrentValue_Boolean Parms{};

	Parms.SettingType = SettingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingCurrentValue_Float
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDiPlayerSettingsSubsystem::GetSettingCurrentValue_Float(EPlayerSettingsType SettingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetSettingCurrentValue_Float");

	Params::DiPlayerSettingsSubsystem_GetSettingCurrentValue_Float Parms{};

	Parms.SettingType = SettingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingCurrentValue_Integer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDiPlayerSettingsSubsystem::GetSettingCurrentValue_Integer(EPlayerSettingsType SettingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetSettingCurrentValue_Integer");

	Params::DiPlayerSettingsSubsystem_GetSettingCurrentValue_Integer Parms{};

	Parms.SettingType = SettingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingCurrentValue_String
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDiPlayerSettingsSubsystem::GetSettingCurrentValue_String(EPlayerSettingsType SettingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetSettingCurrentValue_String");

	Params::DiPlayerSettingsSubsystem_GetSettingCurrentValue_String Parms{};

	Parms.SettingType = SettingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingDisabledReasonTooltip
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDiPlayerSettingsSubsystem::GetSettingDisabledReasonTooltip(EPlayerSettingsType SettingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetSettingDisabledReasonTooltip");

	Params::DiPlayerSettingsSubsystem_GetSettingDisabledReasonTooltip Parms{};

	Parms.SettingType = SettingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingLongDescription
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDiPlayerSettingsSubsystem::GetSettingLongDescription(EPlayerSettingsType SettingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetSettingLongDescription");

	Params::DiPlayerSettingsSubsystem_GetSettingLongDescription Parms{};

	Parms.SettingType = SettingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingMaxLength_String
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDiPlayerSettingsSubsystem::GetSettingMaxLength_String(EPlayerSettingsType SettingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetSettingMaxLength_String");

	Params::DiPlayerSettingsSubsystem_GetSettingMaxLength_String Parms{};

	Parms.SettingType = SettingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingMaxValue_Float
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDiPlayerSettingsSubsystem::GetSettingMaxValue_Float(EPlayerSettingsType SettingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetSettingMaxValue_Float");

	Params::DiPlayerSettingsSubsystem_GetSettingMaxValue_Float Parms{};

	Parms.SettingType = SettingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingMaxValue_Integer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDiPlayerSettingsSubsystem::GetSettingMaxValue_Integer(EPlayerSettingsType SettingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetSettingMaxValue_Integer");

	Params::DiPlayerSettingsSubsystem_GetSettingMaxValue_Integer Parms{};

	Parms.SettingType = SettingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingMinLength_String
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDiPlayerSettingsSubsystem::GetSettingMinLength_String(EPlayerSettingsType SettingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetSettingMinLength_String");

	Params::DiPlayerSettingsSubsystem_GetSettingMinLength_String Parms{};

	Parms.SettingType = SettingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingMinValue_Float
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDiPlayerSettingsSubsystem::GetSettingMinValue_Float(EPlayerSettingsType SettingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetSettingMinValue_Float");

	Params::DiPlayerSettingsSubsystem_GetSettingMinValue_Float Parms{};

	Parms.SettingType = SettingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingMinValue_Integer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDiPlayerSettingsSubsystem::GetSettingMinValue_Integer(EPlayerSettingsType SettingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetSettingMinValue_Integer");

	Params::DiPlayerSettingsSubsystem_GetSettingMinValue_Integer Parms{};

	Parms.SettingType = SettingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingPossibleValues_String
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UDiPlayerSettingsSubsystem::GetSettingPossibleValues_String(EPlayerSettingsType SettingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetSettingPossibleValues_String");

	Params::DiPlayerSettingsSubsystem_GetSettingPossibleValues_String Parms{};

	Parms.SettingType = SettingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingPossibleValues_Text
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UDiPlayerSettingsSubsystem::GetSettingPossibleValues_Text(EPlayerSettingsType SettingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetSettingPossibleValues_Text");

	Params::DiPlayerSettingsSubsystem_GetSettingPossibleValues_Text Parms{};

	Parms.SettingType = SettingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingShortDescription
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDiPlayerSettingsSubsystem::GetSettingShortDescription(EPlayerSettingsType SettingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetSettingShortDescription");

	Params::DiPlayerSettingsSubsystem_GetSettingShortDescription Parms{};

	Parms.SettingType = SettingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingTooltipDecription
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDiPlayerSettingsSubsystem::GetSettingTooltipDecription(EPlayerSettingsType SettingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "GetSettingTooltipDecription");

	Params::DiPlayerSettingsSubsystem_GetSettingTooltipDecription Parms{};

	Parms.SettingType = SettingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.IsContextuallyDisabledSetting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiPlayerSettingsSubsystem::IsContextuallyDisabledSetting(EPlayerSettingsType SettingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "IsContextuallyDisabledSetting");

	Params::DiPlayerSettingsSubsystem_IsContextuallyDisabledSetting Parms{};

	Parms.SettingType = SettingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.IsGameplayTipsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiPlayerSettingsSubsystem::IsGameplayTipsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "IsGameplayTipsEnabled");

	Params::DiPlayerSettingsSubsystem_IsGameplayTipsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.IsSeparatorSetting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiPlayerSettingsSubsystem::IsSeparatorSetting(EPlayerSettingsType SettingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "IsSeparatorSetting");

	Params::DiPlayerSettingsSubsystem_IsSeparatorSetting Parms{};

	Parms.SettingType = SettingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.IsSettingAllowedOnThisPlatform
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiPlayerSettingsSubsystem::IsSettingAllowedOnThisPlatform(EPlayerSettingsType SettingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "IsSettingAllowedOnThisPlatform");

	Params::DiPlayerSettingsSubsystem_IsSettingAllowedOnThisPlatform Parms{};

	Parms.SettingType = SettingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.IsSettingEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiPlayerSettingsSubsystem::IsSettingEnabled(EPlayerSettingsType SettingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "IsSettingEnabled");

	Params::DiPlayerSettingsSubsystem_IsSettingEnabled Parms{};

	Parms.SettingType = SettingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiPlayerSettingsSubsystem.IsSettingTooltipAvailable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiPlayerSettingsSubsystem::IsSettingTooltipAvailable(EPlayerSettingsType SettingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiPlayerSettingsSubsystem", "IsSettingTooltipAvailable");

	Params::DiPlayerSettingsSubsystem_IsSettingTooltipAvailable Parms{};

	Parms.SettingType = SettingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerStart.BP_OnSpySpawnedOnStartPoint
// (Event, Public, BlueprintEvent)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADIPlayerStart::BP_OnSpySpawnedOnStartPoint(class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerStart", "BP_OnSpySpawnedOnStartPoint");

	Params::DIPlayerStart_BP_OnSpySpawnedOnStartPoint Parms{};

	Parms.Spy = Spy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.DIPlayerState.Client_AddWinGamesAchievementProgress
// (Net, NetReliable, Native, Event, Public, NetClient)

void ADIPlayerState::Client_AddWinGamesAchievementProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "Client_AddWinGamesAchievementProgress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPlayerState.Client_ReceivedXPEvent
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// EDIXPEvent                              XPEventType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AddedXP                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADIPlayerState::Client_ReceivedXPEvent(EDIXPEvent XPEventType, int32 AddedXP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "Client_ReceivedXPEvent");

	Params::DIPlayerState_Client_ReceivedXPEvent Parms{};

	Parms.XPEventType = XPEventType;
	Parms.AddedXP = AddedXP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPlayerState.Client_UpdateAchievement
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           AchievementName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Increment                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADIPlayerState::Client_UpdateAchievement(const class FString& AchievementName, float Progress, bool Increment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "Client_UpdateAchievement");

	Params::DIPlayerState_Client_UpdateAchievement Parms{};

	Parms.AchievementName = std::move(AchievementName);
	Parms.Progress = Progress;
	Parms.Increment = Increment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPlayerState.GetAliveTeammates
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class ADIPlayerState*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADIPlayerState*> ADIPlayerState::GetAliveTeammates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetAliveTeammates");

	Params::DIPlayerState_GetAliveTeammates Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.GetAllXpDataEventInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FPlayerXpTypeEventInfo>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FPlayerXpTypeEventInfo> ADIPlayerState::GetAllXpDataEventInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetAllXpDataEventInfo");

	Params::DIPlayerState_GetAllXpDataEventInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.GetMatchGainedCurrency
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADIPlayerState::GetMatchGainedCurrency()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetMatchGainedCurrency");

	Params::DIPlayerState_GetMatchGainedCurrency Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.IncrementMatchCountAchievements
// (Final, Native, Public, BlueprintCallable)

void ADIPlayerState::IncrementMatchCountAchievements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "IncrementMatchCountAchievements");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPlayerState.IsTeamAlive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADIPlayerState::IsTeamAlive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "IsTeamAlive");

	Params::DIPlayerState_IsTeamAlive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.NetMulticast_TriggerSpectateRevivePing
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ADIPlayerState::NetMulticast_TriggerSpectateRevivePing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "NetMulticast_TriggerSpectateRevivePing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPlayerState.OnRep_AccessoriesSelection
// (Final, Native, Protected)
// Parameters:
// struct FDISerializedAccessories         OldVal                                                 (Parm, NativeAccessSpecifierPublic)

void ADIPlayerState::OnRep_AccessoriesSelection(const struct FDISerializedAccessories& OldVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "OnRep_AccessoriesSelection");

	Params::DIPlayerState_OnRep_AccessoriesSelection Parms{};

	Parms.OldVal = std::move(OldVal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPlayerState.OnRep_AgentSelection
// (Final, Native, Protected)
// Parameters:
// struct FPlayerAgentSelectionInfo        OldVal                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ADIPlayerState::OnRep_AgentSelection(const struct FPlayerAgentSelectionInfo& OldVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "OnRep_AgentSelection");

	Params::DIPlayerState_OnRep_AgentSelection Parms{};

	Parms.OldVal = std::move(OldVal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPlayerState.OnRep_EquippedDeck
// (Final, Native, Protected)
// Parameters:
// struct FDISerializedDeckEntry           OldVal                                                 (Parm, NativeAccessSpecifierPublic)

void ADIPlayerState::OnRep_EquippedDeck(const struct FDISerializedDeckEntry& OldVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "OnRep_EquippedDeck");

	Params::DIPlayerState_OnRep_EquippedDeck Parms{};

	Parms.OldVal = std::move(OldVal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPlayerState.OnRep_FactionEliminated
// (Final, Native, Public)
// Parameters:
// bool                                    OldVal                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADIPlayerState::OnRep_FactionEliminated(bool OldVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "OnRep_FactionEliminated");

	Params::DIPlayerState_OnRep_FactionEliminated Parms{};

	Parms.OldVal = OldVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPlayerState.OnRep_FactionID
// (Final, Native, Public)
// Parameters:
// uint8                                   OldVal                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADIPlayerState::OnRep_FactionID(uint8 OldVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "OnRep_FactionID");

	Params::DIPlayerState_OnRep_FactionID Parms{};

	Parms.OldVal = OldVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPlayerState.OnRep_LastLevelInfo
// (Final, Native, Protected)

void ADIPlayerState::OnRep_LastLevelInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "OnRep_LastLevelInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPlayerState.OnRep_XpData
// (Final, Native, Protected)
// Parameters:
// struct FXpHolder                        OldXpData                                              (Parm, NativeAccessSpecifierPublic)

void ADIPlayerState::OnRep_XpData(const struct FXpHolder& OldXpData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "OnRep_XpData");

	Params::DIPlayerState_OnRep_XpData Parms{};

	Parms.OldXpData = std::move(OldXpData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPlayerState.ReviveSpy_Srv
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADIPlayerState::ReviveSpy_Srv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "ReviveSpy_Srv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPlayerState.Server_SetHidePlayerName
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// EAnonymizePlayerNameType                InHidePlayerName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADIPlayerState::Server_SetHidePlayerName(EAnonymizePlayerNameType InHidePlayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "Server_SetHidePlayerName");

	Params::DIPlayerState_Server_SetHidePlayerName Parms{};

	Parms.InHidePlayerName = InHidePlayerName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPlayerState.Server_SetIsSpySelected
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bIsSpySelectedIn                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADIPlayerState::Server_SetIsSpySelected(bool bIsSpySelectedIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "Server_SetIsSpySelected");

	Params::DIPlayerState_Server_SetIsSpySelected Parms{};

	Parms.bIsSpySelectedIn = bIsSpySelectedIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPlayerState.Server_TriggerSpectateRevivePing
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADIPlayerState::Server_TriggerSpectateRevivePing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "Server_TriggerSpectateRevivePing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPlayerState.SetupAsDedicatedSpectator
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADIPlayerState::SetupAsDedicatedSpectator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "SetupAsDedicatedSpectator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPlayerState.GetActiveID
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId ADIPlayerState::GetActiveID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetActiveID");

	Params::DIPlayerState_GetActiveID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.GetAgentExpertiseSkillId
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId ADIPlayerState::GetAgentExpertiseSkillId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetAgentExpertiseSkillId");

	Params::DIPlayerState_GetAgentExpertiseSkillId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.GetAgentGadget1Id
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId ADIPlayerState::GetAgentGadget1Id() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetAgentGadget1Id");

	Params::DIPlayerState_GetAgentGadget1Id Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.GetAgentGadget2Id
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId ADIPlayerState::GetAgentGadget2Id() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetAgentGadget2Id");

	Params::DIPlayerState_GetAgentGadget2Id Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.GetAgentId
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId ADIPlayerState::GetAgentId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetAgentId");

	Params::DIPlayerState_GetAgentId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.GetAgentPassiveSkillId
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId ADIPlayerState::GetAgentPassiveSkillId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetAgentPassiveSkillId");

	Params::DIPlayerState_GetAgentPassiveSkillId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.GetAgentSkinId
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId ADIPlayerState::GetAgentSkinId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetAgentSkinId");

	Params::DIPlayerState_GetAgentSkinId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.GetAgentWeaponId
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId ADIPlayerState::GetAgentWeaponId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetAgentWeaponId");

	Params::DIPlayerState_GetAgentWeaponId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.GetAvatarId
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId ADIPlayerState::GetAvatarId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetAvatarId");

	Params::DIPlayerState_GetAvatarId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.GetDataAssetDisplayName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIPrimaryDataAsset*              DataAsset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ADIPlayerState::GetDataAssetDisplayName(class UDIPrimaryDataAsset* DataAsset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetDataAssetDisplayName");

	Params::DIPlayerState_GetDataAssetDisplayName Parms{};

	Parms.DataAsset = DataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.GetDataAssetRewardIcon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIPrimaryDataAsset*              DataAsset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* ADIPlayerState::GetDataAssetRewardIcon(class UDIPrimaryDataAsset* DataAsset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetDataAssetRewardIcon");

	Params::DIPlayerState_GetDataAssetRewardIcon Parms{};

	Parms.DataAsset = DataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.GetEquippedPowerupDeck
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDISerializedDeckEntry           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDISerializedDeckEntry ADIPlayerState::GetEquippedPowerupDeck() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetEquippedPowerupDeck");

	Params::DIPlayerState_GetEquippedPowerupDeck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.GetIntroPoseId
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId ADIPlayerState::GetIntroPoseId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetIntroPoseId");

	Params::DIPlayerState_GetIntroPoseId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.GetMatchGainedXP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADIPlayerState::GetMatchGainedXP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetMatchGainedXP");

	Params::DIPlayerState_GetMatchGainedXP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.GetMatchGainedXPForSpecificXpType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           XpType                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADIPlayerState::GetMatchGainedXPForSpecificXpType(const class FString& XpType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetMatchGainedXPForSpecificXpType");

	Params::DIPlayerState_GetMatchGainedXPForSpecificXpType Parms{};

	Parms.XpType = std::move(XpType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.GetMatchStartCatalogueToken
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADIPlayerState::GetMatchStartCatalogueToken() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetMatchStartCatalogueToken");

	Params::DIPlayerState_GetMatchStartCatalogueToken Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.GetPassiveID
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId ADIPlayerState::GetPassiveID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetPassiveID");

	Params::DIPlayerState_GetPassiveID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.GetPlatformType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlatformType                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlatformType ADIPlayerState::GetPlatformType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetPlatformType");

	Params::DIPlayerState_GetPlatformType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.GetPlayerDisplayName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ADIPlayerState::GetPlayerDisplayName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetPlayerDisplayName");

	Params::DIPlayerState_GetPlayerDisplayName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.GetPlayerProgression
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPlayerProgression               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPlayerProgression ADIPlayerState::GetPlayerProgression() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetPlayerProgression");

	Params::DIPlayerState_GetPlayerProgression Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.GetTitleId
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId ADIPlayerState::GetTitleId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetTitleId");

	Params::DIPlayerState_GetTitleId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.GetWeaponWrapID
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId ADIPlayerState::GetWeaponWrapID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "GetWeaponWrapID");

	Params::DIPlayerState_GetWeaponWrapID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.IsSameFactionAsLocalPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADIPlayerState::IsSameFactionAsLocalPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "IsSameFactionAsLocalPlayer");

	Params::DIPlayerState_IsSameFactionAsLocalPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPlayerState.ShouldShowRealNameToLocalPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADIPlayerState::ShouldShowRealNameToLocalPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPlayerState", "ShouldShowRealNameToLocalPlayer");

	Params::DIPlayerState_ShouldShowRealNameToLocalPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.HealTeamComponent.HandleInteractionComplete
// (Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealTeamComponent::HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealTeamComponent", "HandleInteractionComplete");

	Params::HealTeamComponent_HandleInteractionComplete Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPopupUserWidget.OnNewTextToDisplay
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             TextToDisplay                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDIPopupUserWidget::OnNewTextToDisplay(const class FText& TextToDisplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPopupUserWidget", "OnNewTextToDisplay");

	Params::DIPopupUserWidget_OnNewTextToDisplay Parms{};

	Parms.TextToDisplay = std::move(TextToDisplay);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.DIPopupUserWidget.OnNewTitleToDisplay
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             TitleToDisplay                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDIPopupUserWidget::OnNewTitleToDisplay(const class FText& TitleToDisplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPopupUserWidget", "OnNewTitleToDisplay");

	Params::DIPopupUserWidget_OnNewTitleToDisplay Parms{};

	Parms.TitleToDisplay = std::move(TitleToDisplay);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.DIPopupUserWidget.OnPopupAnswered
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAnswerValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIPopupUserWidget::OnPopupAnswered(bool bAnswerValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPopupUserWidget", "OnPopupAnswered");

	Params::DIPopupUserWidget_OnPopupAnswered Parms{};

	Parms.bAnswerValue = bAnswerValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPopupAnnouncementUserWidget.OnNewImageToDisplay
// (Event, Public, BlueprintEvent)
// Parameters:
// class UTexture*                         NewImage                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIPopupAnnouncementUserWidget::OnNewImageToDisplay(const class UTexture* NewImage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPopupAnnouncementUserWidget", "OnNewImageToDisplay");

	Params::DIPopupAnnouncementUserWidget_OnNewImageToDisplay Parms{};

	Parms.NewImage = NewImage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.DIPopupAnnouncementUserWidget.Redraw
// (Final, Native, Public, BlueprintCallable)

void UDIPopupAnnouncementUserWidget::Redraw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPopupAnnouncementUserWidget", "Redraw");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPopupAnnouncementUserWidget.SetImageToDisplay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UTexture>          NewImage                                               (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIPopupAnnouncementUserWidget::SetImageToDisplay(const TSoftObjectPtr<class UTexture> NewImage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPopupAnnouncementUserWidget", "SetImageToDisplay");

	Params::DIPopupAnnouncementUserWidget_SetImageToDisplay Parms{};

	Parms.NewImage = NewImage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPopupAnnouncementUserWidget.SetShouldStayOnScreenWhenAnswered
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InShouldStayOnScreenWhenAnswered                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIPopupAnnouncementUserWidget::SetShouldStayOnScreenWhenAnswered(bool InShouldStayOnScreenWhenAnswered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPopupAnnouncementUserWidget", "SetShouldStayOnScreenWhenAnswered");

	Params::DIPopupAnnouncementUserWidget_SetShouldStayOnScreenWhenAnswered Parms{};

	Parms.InShouldStayOnScreenWhenAnswered = InShouldStayOnScreenWhenAnswered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPopupAnnouncementUserWidget.SetSpecialAnnouncmentSettings
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDISpecialAnnouncmentSettings    InMessageSettings                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDIPopupAnnouncementUserWidget::SetSpecialAnnouncmentSettings(const struct FDISpecialAnnouncmentSettings& InMessageSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPopupAnnouncementUserWidget", "SetSpecialAnnouncmentSettings");

	Params::DIPopupAnnouncementUserWidget_SetSpecialAnnouncmentSettings Parms{};

	Parms.InMessageSettings = std::move(InMessageSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPopupAnnouncementUserWidget.GetImageAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftObjectPtr<class UTexture>          ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UTexture> UDIPopupAnnouncementUserWidget::GetImageAsset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPopupAnnouncementUserWidget", "GetImageAsset");

	Params::DIPopupAnnouncementUserWidget_GetImageAsset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPopupAnnouncementUserWidget.GetText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDIPopupAnnouncementUserWidget::GetText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPopupAnnouncementUserWidget", "GetText");

	Params::DIPopupAnnouncementUserWidget_GetText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPopupAnnouncementUserWidget.GetTitle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDIPopupAnnouncementUserWidget::GetTitle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPopupAnnouncementUserWidget", "GetTitle");

	Params::DIPopupAnnouncementUserWidget_GetTitle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPopupAnnouncementUserWidget.IsShouldStayOnScreenWhenAnswered
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIPopupAnnouncementUserWidget::IsShouldStayOnScreenWhenAnswered() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPopupAnnouncementUserWidget", "IsShouldStayOnScreenWhenAnswered");

	Params::DIPopupAnnouncementUserWidget_IsShouldStayOnScreenWhenAnswered Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPrivateLobbyMenuUserWidget.BP_OnPlayerSelectionChange
// (Event, Public, BlueprintEvent)

void UDIPrivateLobbyMenuUserWidget::BP_OnPlayerSelectionChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPrivateLobbyMenuUserWidget", "BP_OnPlayerSelectionChange");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.DIPrivateLobbyMenuUserWidget.ClearPlayerSelection
// (Final, Native, Public, BlueprintCallable)

void UDIPrivateLobbyMenuUserWidget::ClearPlayerSelection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPrivateLobbyMenuUserWidget", "ClearPlayerSelection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIPrivateLobbyMenuUserWidget.GetSelectedPlayers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UDIOnlinePartyMemberInfo*> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UDIOnlinePartyMemberInfo*> UDIPrivateLobbyMenuUserWidget::GetSelectedPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPrivateLobbyMenuUserWidget", "GetSelectedPlayers");

	Params::DIPrivateLobbyMenuUserWidget_GetSelectedPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPrivateLobbyMenuUserWidget.IsSelectedPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDIOnlinePartyMemberInfo*         Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIPrivateLobbyMenuUserWidget::IsSelectedPlayer(class UDIOnlinePartyMemberInfo* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPrivateLobbyMenuUserWidget", "IsSelectedPlayer");

	Params::DIPrivateLobbyMenuUserWidget_IsSelectedPlayer Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIPrivateLobbyMenuUserWidget.SetSelectedPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDIOnlinePartyMemberInfo*         Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Selected                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIPrivateLobbyMenuUserWidget::SetSelectedPlayer(class UDIOnlinePartyMemberInfo* Player, bool Selected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIPrivateLobbyMenuUserWidget", "SetSelectedPlayer");

	Params::DIPrivateLobbyMenuUserWidget_SetSelectedPlayer Parms{};

	Parms.Player = Player;
	Parms.Selected = Selected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DirectionalDamageIndicatorWidget.BP_OnAddedToScreen
// (Event, Public, BlueprintEvent)

void UDirectionalDamageIndicatorWidget::BP_OnAddedToScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionalDamageIndicatorWidget", "BP_OnAddedToScreen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.KeycardPrinterActor.BP_OnScrambleStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bScrambled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKeycardPrinterActor::BP_OnScrambleStateChanged(bool bScrambled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeycardPrinterActor", "BP_OnScrambleStateChanged");

	Params::KeycardPrinterActor_BP_OnScrambleStateChanged Parms{};

	Parms.bScrambled = bScrambled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.KeycardPrinterActor.GetPrintedKeycard
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AKeycardPrinterActor::GetPrintedKeycard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeycardPrinterActor", "GetPrintedKeycard");

	Params::KeycardPrinterActor_GetPrintedKeycard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.KeycardPrinterActor.HandleScramblerIsAffectedChanged
// (Native, Public)
// Parameters:
// bool                                    bIsAffected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AffectedActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKeycardPrinterActor::HandleScramblerIsAffectedChanged(bool bIsAffected, class AActor* AffectedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeycardPrinterActor", "HandleScramblerIsAffectedChanged");

	Params::KeycardPrinterActor_HandleScramblerIsAffectedChanged Parms{};

	Parms.bIsAffected = bIsAffected;
	Parms.AffectedActor = AffectedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.KeycardPrinterActor.SetPrintedKeycard
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           PrintedKeycardIn                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKeycardPrinterActor::SetPrintedKeycard(class AActor* PrintedKeycardIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeycardPrinterActor", "SetPrintedKeycard");

	Params::KeycardPrinterActor_SetPrintedKeycard Parms{};

	Parms.PrintedKeycardIn = PrintedKeycardIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIResultScreenMenuUserWidget.GetSubtitleWidget
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UDIResultScreenMenuUserWidget::GetSubtitleWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIResultScreenMenuUserWidget", "GetSubtitleWidget");

	Params::DIResultScreenMenuUserWidget_GetSubtitleWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISaveGameSubsystem.SetTutorialToCompleted
// (Final, Native, Public, BlueprintCallable)

void UDISaveGameSubsystem::SetTutorialToCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISaveGameSubsystem", "SetTutorialToCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ObjectiveProximitySubsystem.HandleExtractionArrivedEvent
// (Final, Native, Protected)
// Parameters:
// class UExtractionArrivedPhaseInfo*      PhaseInfo                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectiveProximitySubsystem::HandleExtractionArrivedEvent(class UExtractionArrivedPhaseInfo* PhaseInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveProximitySubsystem", "HandleExtractionArrivedEvent");

	Params::ObjectiveProximitySubsystem_HandleExtractionArrivedEvent Parms{};

	Parms.PhaseInfo = PhaseInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ObjectiveProximitySubsystem.HandleExtractionArrivingEvent
// (Final, Native, Protected)
// Parameters:
// class UExtractionArrivingPhaseInfo*     PhaseInfo                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectiveProximitySubsystem::HandleExtractionArrivingEvent(class UExtractionArrivingPhaseInfo* PhaseInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveProximitySubsystem", "HandleExtractionArrivingEvent");

	Params::ObjectiveProximitySubsystem_HandleExtractionArrivingEvent Parms{};

	Parms.PhaseInfo = PhaseInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ObjectiveProximitySubsystem.HandleExtractionPointSetEvent
// (Final, Native, Protected)

void UObjectiveProximitySubsystem::HandleExtractionPointSetEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveProximitySubsystem", "HandleExtractionPointSetEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ObjectiveProximitySubsystem.HandleProximityCheckTimeTick
// (Final, Native, Protected)

void UObjectiveProximitySubsystem::HandleProximityCheckTimeTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveProximitySubsystem", "HandleProximityCheckTimeTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISessionProgression.GetAgentLevelByXpType
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  XpType                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlayerXpTypeDefinition          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPlayerXpTypeDefinition UDISessionProgression::GetAgentLevelByXpType(const struct FPrimaryAssetId& XpType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionProgression", "GetAgentLevelByXpType");

	Params::DISessionProgression_GetAgentLevelByXpType Parms{};

	Parms.XpType = std::move(XpType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionProgression.GetAgentMasteryByXpType
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  XpType                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlayerXpTypeDefinition          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPlayerXpTypeDefinition UDISessionProgression::GetAgentMasteryByXpType(const struct FPrimaryAssetId& XpType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionProgression", "GetAgentMasteryByXpType");

	Params::DISessionProgression_GetAgentMasteryByXpType Parms{};

	Parms.XpType = std::move(XpType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionProgression.GetXpInfoByXpType
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  XpType                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlayerXpTypeDefinition          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPlayerXpTypeDefinition UDISessionProgression::GetXpInfoByXpType(const struct FPrimaryAssetId& XpType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionProgression", "GetXpInfoByXpType");

	Params::DISessionProgression_GetXpInfoByXpType Parms{};

	Parms.XpType = std::move(XpType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionProgression.GetAgentLevelByString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           XpType                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlayerXpTypeDefinition          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPlayerXpTypeDefinition UDISessionProgression::GetAgentLevelByString(const class FString& XpType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionProgression", "GetAgentLevelByString");

	Params::DISessionProgression_GetAgentLevelByString Parms{};

	Parms.XpType = std::move(XpType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionProgression.GetAgentMasteryByString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           XpType                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlayerXpTypeDefinition          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPlayerXpTypeDefinition UDISessionProgression::GetAgentMasteryByString(const class FString& XpType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionProgression", "GetAgentMasteryByString");

	Params::DISessionProgression_GetAgentMasteryByString Parms{};

	Parms.XpType = std::move(XpType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionProgression.GetXpInfoByString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           XpType                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlayerXpTypeDefinition          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPlayerXpTypeDefinition UDISessionProgression::GetXpInfoByString(const class FString& XpType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionProgression", "GetXpInfoByString");

	Params::DISessionProgression_GetXpInfoByString Parms{};

	Parms.XpType = std::move(XpType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SessionAccessoriesSelectionInfo.GetSelectedCallingCards
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UCallingCardDataAsset*>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UCallingCardDataAsset*> USessionAccessoriesSelectionInfo::GetSelectedCallingCards() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SessionAccessoriesSelectionInfo", "GetSelectedCallingCards");

	Params::SessionAccessoriesSelectionInfo_GetSelectedCallingCards Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSelections.DEBUG_GetAllAgentSkinDatasByAgentSkinData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAgentSkinData*                   AgentSkinData                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentIndex                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UAgentSkinData*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UAgentSkinData*> UDISessionSelections::DEBUG_GetAllAgentSkinDatasByAgentSkinData(const class UAgentSkinData* AgentSkinData, int32* CurrentIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "DEBUG_GetAllAgentSkinDatasByAgentSkinData");

	Params::DISessionSelections_DEBUG_GetAllAgentSkinDatasByAgentSkinData Parms{};

	Parms.AgentSkinData = AgentSkinData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CurrentIndex != nullptr)
		*CurrentIndex = Parms.CurrentIndex;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSelections.GetAgentIntroPoseDatasByAgentData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAgentData*                       AgentData                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UAgentIntroPoseDataAsset*> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UAgentIntroPoseDataAsset*> UDISessionSelections::GetAgentIntroPoseDatasByAgentData(const class UAgentData* AgentData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "GetAgentIntroPoseDatasByAgentData");

	Params::DISessionSelections_GetAgentIntroPoseDatasByAgentData Parms{};

	Parms.AgentData = AgentData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSelections.GetAgentSkinDatasByAgentData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAgentData*                       AgentData                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UAgentSkinData*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UAgentSkinData*> UDISessionSelections::GetAgentSkinDatasByAgentData(const class UAgentData* AgentData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "GetAgentSkinDatasByAgentData");

	Params::DISessionSelections_GetAgentSkinDatasByAgentData Parms{};

	Parms.AgentData = AgentData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSelections.GetAvatarSelection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UAvatarDataAsset*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UAvatarDataAsset*> UDISessionSelections::GetAvatarSelection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "GetAvatarSelection");

	Params::DISessionSelections_GetAvatarSelection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSelections.GetCallingCardSelection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UCallingCardDataAsset*>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UCallingCardDataAsset*> UDISessionSelections::GetCallingCardSelection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "GetCallingCardSelection");

	Params::DISessionSelections_GetCallingCardSelection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSelections.GetDeckName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   DeckIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DeckName                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISessionSelections::GetDeckName(int32 DeckIndex, class FString* DeckName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "GetDeckName");

	Params::DISessionSelections_GetDeckName Parms{};

	Parms.DeckIndex = DeckIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DeckName != nullptr)
		*DeckName = std::move(Parms.DeckName);
}


// Function DeceiveInc.DISessionSelections.GetEquippedDeckName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           DeckName                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISessionSelections::GetEquippedDeckName(class FString* DeckName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "GetEquippedDeckName");

	Params::DISessionSelections_GetEquippedDeckName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DeckName != nullptr)
		*DeckName = std::move(Parms.DeckName);
}


// Function DeceiveInc.DISessionSelections.GetSavedPowerupDecksInfos
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDISerializedDecks               PlayerDecks                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UDISessionSelections::GetSavedPowerupDecksInfos(struct FDISerializedDecks* PlayerDecks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "GetSavedPowerupDecksInfos");

	Params::DISessionSelections_GetSavedPowerupDecksInfos Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PlayerDecks != nullptr)
		*PlayerDecks = std::move(Parms.PlayerDecks);
}


// Function DeceiveInc.DISessionSelections.GetTitleSelection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UTitleDataAsset*>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UTitleDataAsset*> UDISessionSelections::GetTitleSelection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "GetTitleSelection");

	Params::DISessionSelections_GetTitleSelection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSelections.GetToolMenuWrapSelection
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  ToolAssetId                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMenuWrapData*>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UMenuWrapData*> UDISessionSelections::GetToolMenuWrapSelection(const struct FPrimaryAssetId& ToolAssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "GetToolMenuWrapSelection");

	Params::DISessionSelections_GetToolMenuWrapSelection Parms{};

	Parms.ToolAssetId = std::move(ToolAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSelections.GetToolSelectedWrap
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  ToolAssetId                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMenuWrapData*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuWrapData* UDISessionSelections::GetToolSelectedWrap(const struct FPrimaryAssetId& ToolAssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "GetToolSelectedWrap");

	Params::DISessionSelections_GetToolSelectedWrap Parms{};

	Parms.ToolAssetId = std::move(ToolAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSelections.IsAgentSelectable
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  AgentId                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDISessionSelections::IsAgentSelectable(const struct FPrimaryAssetId& AgentId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "IsAgentSelectable");

	Params::DISessionSelections_IsAgentSelectable Parms{};

	Parms.AgentId = std::move(AgentId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSelections.IsAgentSkinSelectable
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  AgentSkinId                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDISessionSelections::IsAgentSkinSelectable(const struct FPrimaryAssetId& AgentSkinId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "IsAgentSkinSelectable");

	Params::DISessionSelections_IsAgentSkinSelectable Parms{};

	Parms.AgentSkinId = std::move(AgentSkinId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSelections.SetAgentIntroPoseIdByAgentId
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  AgentId                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  IntroPoseId                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISessionSelections::SetAgentIntroPoseIdByAgentId(const struct FPrimaryAssetId& AgentId, const struct FPrimaryAssetId& IntroPoseId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "SetAgentIntroPoseIdByAgentId");

	Params::DISessionSelections_SetAgentIntroPoseIdByAgentId Parms{};

	Parms.AgentId = std::move(AgentId);
	Parms.IntroPoseId = std::move(IntroPoseId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISessionSelections.SetAgentSkinIdByAgentId
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  AgentId                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  SkinId                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISessionSelections::SetAgentSkinIdByAgentId(const struct FPrimaryAssetId& AgentId, const struct FPrimaryAssetId& SkinId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "SetAgentSkinIdByAgentId");

	Params::DISessionSelections_SetAgentSkinIdByAgentId Parms{};

	Parms.AgentId = std::move(AgentId);
	Parms.SkinId = std::move(SkinId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISessionSelections.SetCallingCard
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  CallingCardId                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECallingCardPosition                    CalingCardPosition                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISessionSelections::SetCallingCard(const struct FPrimaryAssetId& CallingCardId, ECallingCardPosition CalingCardPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "SetCallingCard");

	Params::DISessionSelections_SetCallingCard Parms{};

	Parms.CallingCardId = std::move(CallingCardId);
	Parms.CalingCardPosition = CalingCardPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISessionSelections.SetDeckName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   DeckIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NewDeckName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISessionSelections::SetDeckName(int32 DeckIndex, const class FString& NewDeckName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "SetDeckName");

	Params::DISessionSelections_SetDeckName Parms{};

	Parms.DeckIndex = DeckIndex;
	Parms.NewDeckName = std::move(NewDeckName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISessionSelections.SetDeckPowerupToSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PowerupUpIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISessionSelections::SetDeckPowerupToSlot(int32 SlotIndex, int32 PowerupUpIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "SetDeckPowerupToSlot");

	Params::DISessionSelections_SetDeckPowerupToSlot Parms{};

	Parms.SlotIndex = SlotIndex;
	Parms.PowerupUpIndex = PowerupUpIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISessionSelections.SetPowerupDeckToEquip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewDeckIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISessionSelections::SetPowerupDeckToEquip(int32 NewDeckIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "SetPowerupDeckToEquip");

	Params::DISessionSelections_SetPowerupDeckToEquip Parms{};

	Parms.NewDeckIndex = NewDeckIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISessionSelections.SetSelectedAgent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  AgentId                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSaveToStorage                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISessionSelections::SetSelectedAgent(const struct FPrimaryAssetId& AgentId, bool bSaveToStorage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "SetSelectedAgent");

	Params::DISessionSelections_SetSelectedAgent Parms{};

	Parms.AgentId = std::move(AgentId);
	Parms.bSaveToStorage = bSaveToStorage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISessionSelections.SetSelectedAgentSkin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAgentSkinData*                   AgentSkinData                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISessionSelections::SetSelectedAgentSkin(class UAgentSkinData* AgentSkinData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "SetSelectedAgentSkin");

	Params::DISessionSelections_SetSelectedAgentSkin Parms{};

	Parms.AgentSkinData = AgentSkinData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISessionSelections.SetSelectedAvatar
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  AvatarId                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISessionSelections::SetSelectedAvatar(const struct FPrimaryAssetId& AvatarId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "SetSelectedAvatar");

	Params::DISessionSelections_SetSelectedAvatar Parms{};

	Parms.AvatarId = std::move(AvatarId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISessionSelections.SetSelectedExpertiseSkillOnSelectedAgent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  ExpertiseSkillId                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISessionSelections::SetSelectedExpertiseSkillOnSelectedAgent(const struct FPrimaryAssetId& ExpertiseSkillId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "SetSelectedExpertiseSkillOnSelectedAgent");

	Params::DISessionSelections_SetSelectedExpertiseSkillOnSelectedAgent Parms{};

	Parms.ExpertiseSkillId = std::move(ExpertiseSkillId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISessionSelections.SetSelectedGadgetOnSelectedAgent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  GadgetId                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GadgetIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISessionSelections::SetSelectedGadgetOnSelectedAgent(const struct FPrimaryAssetId& GadgetId, int32 GadgetIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "SetSelectedGadgetOnSelectedAgent");

	Params::DISessionSelections_SetSelectedGadgetOnSelectedAgent Parms{};

	Parms.GadgetId = std::move(GadgetId);
	Parms.GadgetIndex = GadgetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISessionSelections.SetSelectedPassiveSkillOnSelectedAgent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  PassiveSkillId                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISessionSelections::SetSelectedPassiveSkillOnSelectedAgent(const struct FPrimaryAssetId& PassiveSkillId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "SetSelectedPassiveSkillOnSelectedAgent");

	Params::DISessionSelections_SetSelectedPassiveSkillOnSelectedAgent Parms{};

	Parms.PassiveSkillId = std::move(PassiveSkillId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISessionSelections.SetSelectedTitle
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  TitleId                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISessionSelections::SetSelectedTitle(const struct FPrimaryAssetId& TitleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "SetSelectedTitle");

	Params::DISessionSelections_SetSelectedTitle Parms{};

	Parms.TitleId = std::move(TitleId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISessionSelections.SetSelectedWeaponOnSelectedAgent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  WeaponId                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISessionSelections::SetSelectedWeaponOnSelectedAgent(const struct FPrimaryAssetId& WeaponId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "SetSelectedWeaponOnSelectedAgent");

	Params::DISessionSelections_SetSelectedWeaponOnSelectedAgent Parms{};

	Parms.WeaponId = std::move(WeaponId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISessionSelections.SetSelectedWrapOnTool
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UMenuWrapData*                    WrapId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  ToolAssetId                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISessionSelections::SetSelectedWrapOnTool(class UMenuWrapData* WrapId, const struct FPrimaryAssetId& ToolAssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "SetSelectedWrapOnTool");

	Params::DISessionSelections_SetSelectedWrapOnTool Parms{};

	Parms.WrapId = WrapId;
	Parms.ToolAssetId = std::move(ToolAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISessionSelections.GetAccessoriesInfos
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USessionAccessoriesSelectionInfo* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USessionAccessoriesSelectionInfo* UDISessionSelections::GetAccessoriesInfos() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "GetAccessoriesInfos");

	Params::DISessionSelections_GetAccessoriesInfos Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSelections.GetAgentSelectionInfosByAgentId
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPrimaryAssetId                  AgentId                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USessionAgentSelectionInfo*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USessionAgentSelectionInfo* UDISessionSelections::GetAgentSelectionInfosByAgentId(const struct FPrimaryAssetId& AgentId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "GetAgentSelectionInfosByAgentId");

	Params::DISessionSelections_GetAgentSelectionInfosByAgentId Parms{};

	Parms.AgentId = std::move(AgentId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSelections.GetEquippedDeck
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDISerializedDeckEntry           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDISerializedDeckEntry UDISessionSelections::GetEquippedDeck() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "GetEquippedDeck");

	Params::DISessionSelections_GetEquippedDeck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSelections.GetEquippedDeckIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDISessionSelections::GetEquippedDeckIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "GetEquippedDeckIndex");

	Params::DISessionSelections_GetEquippedDeckIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionSelections.GetSelectedAgentSelectionInfos
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USessionAgentSelectionInfo*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USessionAgentSelectionInfo* UDISessionSelections::GetSelectedAgentSelectionInfos() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionSelections", "GetSelectedAgentSelectionInfos");

	Params::DISessionSelections_GetSelectedAgentSelectionInfos Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VictimEffect.ActivateEffect
// (Final, Native, Public, BlueprintCallable)

void AVictimEffect::ActivateEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "ActivateEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffect.BP_InitializeDamageModifier
// (Event, Public, BlueprintEvent)
// Parameters:
// class UDamageModifier*                  DamageModifier                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVictimEffect::BP_InitializeDamageModifier(class UDamageModifier* DamageModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "BP_InitializeDamageModifier");

	Params::VictimEffect_BP_InitializeDamageModifier Parms{};

	Parms.DamageModifier = DamageModifier;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.VictimEffect.BP_InitializeTickEffect
// (Event, Public, BlueprintEvent)
// Parameters:
// class UVictimEffectTickBehavior*        TickEffect                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVictimEffect::BP_InitializeTickEffect(class UVictimEffectTickBehavior* TickEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "BP_InitializeTickEffect");

	Params::VictimEffect_BP_InitializeTickEffect Parms{};

	Parms.TickEffect = TickEffect;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.VictimEffect.BP_OnAnnouncementRefresh
// (Event, Public, BlueprintEvent)

void AVictimEffect::BP_OnAnnouncementRefresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "BP_OnAnnouncementRefresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.VictimEffect.BP_OnDurationChanged
// (Event, Public, BlueprintEvent)

void AVictimEffect::BP_OnDurationChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "BP_OnDurationChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.VictimEffect.BP_OnEffectEnd
// (Event, Public, BlueprintEvent)
// Parameters:
// class AVictimEffect*                    Effect                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVictimEffect::BP_OnEffectEnd(class AVictimEffect* Effect, class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "BP_OnEffectEnd");

	Params::VictimEffect_BP_OnEffectEnd Parms{};

	Parms.Effect = Effect;
	Parms.Victim = Victim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.VictimEffect.BP_OnEffectFadeOutEnd
// (Event, Public, BlueprintEvent)
// Parameters:
// class AVictimEffect*                    Effect                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVictimEffect::BP_OnEffectFadeOutEnd(class AVictimEffect* Effect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "BP_OnEffectFadeOutEnd");

	Params::VictimEffect_BP_OnEffectFadeOutEnd Parms{};

	Parms.Effect = Effect;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.VictimEffect.BP_OnEffectFadeOutStart
// (Event, Public, BlueprintEvent)
// Parameters:
// class AVictimEffect*                    Effect                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVictimEffect::BP_OnEffectFadeOutStart(class AVictimEffect* Effect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "BP_OnEffectFadeOutStart");

	Params::VictimEffect_BP_OnEffectFadeOutStart Parms{};

	Parms.Effect = Effect;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.VictimEffect.BP_OnEffectStart
// (Event, Public, BlueprintEvent)
// Parameters:
// class AVictimEffect*                    Effect                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVictimEffect::BP_OnEffectStart(class AVictimEffect* Effect, class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "BP_OnEffectStart");

	Params::VictimEffect_BP_OnEffectStart Parms{};

	Parms.Effect = Effect;
	Parms.Victim = Victim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.VictimEffect.BP_OnEffectTick
// (Event, Public, BlueprintEvent)
// Parameters:
// class AVictimEffect*                    Effect                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVictimEffect::BP_OnEffectTick(class AVictimEffect* Effect, class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "BP_OnEffectTick");

	Params::VictimEffect_BP_OnEffectTick Parms{};

	Parms.Effect = Effect;
	Parms.Victim = Victim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.VictimEffect.BP_OnEffectTriggered
// (Event, Public, BlueprintEvent)
// Parameters:
// class AVictimEffect*                    Effect                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVictimEffect::BP_OnEffectTriggered(class AVictimEffect* Effect, class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "BP_OnEffectTriggered");

	Params::VictimEffect_BP_OnEffectTriggered Parms{};

	Parms.Effect = Effect;
	Parms.Victim = Victim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.VictimEffect.BP_OnNewEffectInstigator
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           NewEffectInstigator                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVictimEffect::BP_OnNewEffectInstigator(class AActor* NewEffectInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "BP_OnNewEffectInstigator");

	Params::VictimEffect_BP_OnNewEffectInstigator Parms{};

	Parms.NewEffectInstigator = NewEffectInstigator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.VictimEffect.BP_OnVictimChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           NewVictim                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVictimEffect::BP_OnVictimChanged(class AActor* NewVictim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "BP_OnVictimChanged");

	Params::VictimEffect_BP_OnVictimChanged Parms{};

	Parms.NewVictim = NewVictim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.VictimEffect.BP_OnWidgetReady
// (Event, Public, BlueprintEvent)
// Parameters:
// class UVictimEffectUserWidget*          NewWidget                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVictimEffect::BP_OnWidgetReady(class UVictimEffectUserWidget* NewWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "BP_OnWidgetReady");

	Params::VictimEffect_BP_OnWidgetReady Parms{};

	Parms.NewWidget = NewWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.VictimEffect.CanBeCleansed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVictimEffect::CanBeCleansed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "CanBeCleansed");

	Params::VictimEffect_CanBeCleansed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VictimEffect.DeactivateEffect
// (Final, Native, Public, BlueprintCallable)

void AVictimEffect::DeactivateEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "DeactivateEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffect.DoEffectTickOnVictim
// (Final, Native, Protected)

void AVictimEffect::DoEffectTickOnVictim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "DoEffectTickOnVictim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffect.FadeAndDeactivateEffect
// (Final, Native, Public, BlueprintCallable)

void AVictimEffect::FadeAndDeactivateEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "FadeAndDeactivateEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffect.GetEffectInstigator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AVictimEffect::GetEffectInstigator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "GetEffectInstigator");

	Params::VictimEffect_GetEffectInstigator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VictimEffect.GetEffectTickLeftPercentage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AVictimEffect::GetEffectTickLeftPercentage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "GetEffectTickLeftPercentage");

	Params::VictimEffect_GetEffectTickLeftPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VictimEffect.GetEffectTimeLeftPercentage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AVictimEffect::GetEffectTimeLeftPercentage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "GetEffectTimeLeftPercentage");

	Params::VictimEffect_GetEffectTimeLeftPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VictimEffect.GetLifetime
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AVictimEffect::GetLifetime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "GetLifetime");

	Params::VictimEffect_GetLifetime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VictimEffect.GetVariantData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ID                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AVictimEffect::GetVariantData(const class FString& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "GetVariantData");

	Params::VictimEffect_GetVariantData Parms{};

	Parms.ID = std::move(ID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VictimEffect.HandleVictimCoverChange
// (Native, Protected)
// Parameters:
// bool                                    CoverState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVictimEffect::HandleVictimCoverChange(bool CoverState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "HandleVictimCoverChange");

	Params::VictimEffect_HandleVictimCoverChange Parms{};

	Parms.CoverState = CoverState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffect.HandleVictimCoverSwitch
// (Native, Protected)
// Parameters:
// class ANPCCharacter*                    NewCover                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVictimEffect::HandleVictimCoverSwitch(class ANPCCharacter* NewCover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "HandleVictimCoverSwitch");

	Params::VictimEffect_HandleVictimCoverSwitch Parms{};

	Parms.NewCover = NewCover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffect.IsPositiveEffect
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVictimEffect::IsPositiveEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "IsPositiveEffect");

	Params::VictimEffect_IsPositiveEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VictimEffect.NetMulticast_DoAnnouncementRefresh
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void AVictimEffect::NetMulticast_DoAnnouncementRefresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "NetMulticast_DoAnnouncementRefresh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffect.OnRep_EffectInfo
// (Final, Native, Protected)
// Parameters:
// struct FEffectInfo                      OldEffectInfo                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AVictimEffect::OnRep_EffectInfo(const struct FEffectInfo& OldEffectInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "OnRep_EffectInfo");

	Params::VictimEffect_OnRep_EffectInfo Parms{};

	Parms.OldEffectInfo = std::move(OldEffectInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffect.OnRep_Lifetime
// (Final, Native, Protected)

void AVictimEffect::OnRep_Lifetime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "OnRep_Lifetime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffect.PauseTickEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bPause                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVictimEffect::PauseTickEffect(bool bPause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "PauseTickEffect");

	Params::VictimEffect_PauseTickEffect Parms{};

	Parms.bPause = bPause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffect.SetEffectDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewEffectDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVictimEffect::SetEffectDuration(float NewEffectDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "SetEffectDuration");

	Params::VictimEffect_SetEffectDuration Parms{};

	Parms.NewEffectDuration = NewEffectDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffect.SetEffectPositioningType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVictimEffectPositioningType            PositioningType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVictimEffect::SetEffectPositioningType(EVictimEffectPositioningType PositioningType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "SetEffectPositioningType");

	Params::VictimEffect_SetEffectPositioningType Parms{};

	Parms.PositioningType = PositioningType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffect.SetEffectPositioningTypeWithSocket
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVictimEffectPositioningType            PositioningType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVictimEffect::SetEffectPositioningTypeWithSocket(EVictimEffectPositioningType PositioningType, class FName SocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "SetEffectPositioningTypeWithSocket");

	Params::VictimEffect_SetEffectPositioningTypeWithSocket Parms{};

	Parms.PositioningType = PositioningType;
	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffect.SetInstigator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CausingActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVictimEffect::SetInstigator(class AActor* CausingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "SetInstigator");

	Params::VictimEffect_SetInstigator Parms{};

	Parms.CausingActor = CausingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffect.SetTickEffectEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVictimEffect::SetTickEffectEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "SetTickEffectEnabled");

	Params::VictimEffect_SetTickEffectEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffect.SetupEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewVictim                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewInstigator                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStartEffect                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewDuration                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVictimEffect::SetupEffect(class AActor* NewVictim, class AActor* NewInstigator, bool bStartEffect, float NewDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "SetupEffect");

	Params::VictimEffect_SetupEffect Parms{};

	Parms.NewVictim = NewVictim;
	Parms.NewInstigator = NewInstigator;
	Parms.bStartEffect = bStartEffect;
	Parms.NewDuration = NewDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffect.SetVariantData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ID                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVictimEffect::SetVariantData(const class FString& ID, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "SetVariantData");

	Params::VictimEffect_SetVariantData Parms{};

	Parms.ID = std::move(ID);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffect.SetVictim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVictimEffect::SetVictim(class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "SetVictim");

	Params::VictimEffect_SetVictim Parms{};

	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffect.GetEffectTimeLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AVictimEffect::GetEffectTimeLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "GetEffectTimeLeft");

	Params::VictimEffect_GetEffectTimeLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VictimEffect.IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVictimEffect::IsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "IsActive");

	Params::VictimEffect_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VictimEffect.IsSameFactionFromInstigator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVictimEffect::IsSameFactionFromInstigator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "IsSameFactionFromInstigator");

	Params::VictimEffect_IsSameFactionFromInstigator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VictimEffect.IsSameFactionFromInstigatorPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            PawnToCheck                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVictimEffect::IsSameFactionFromInstigatorPawn(class APawn* PawnToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "IsSameFactionFromInstigatorPawn");

	Params::VictimEffect_IsSameFactionFromInstigatorPawn Parms{};

	Parms.PawnToCheck = PawnToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VictimEffect.ShouldShowFollowEffectHud
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVictimEffect::ShouldShowFollowEffectHud() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffect", "ShouldShowFollowEffectHud");

	Params::VictimEffect_ShouldShowFollowEffectHud Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ObjectiveCarrierVictimEffect.BP_DoPingEffect
// (Event, Protected, BlueprintEvent)

void AObjectiveCarrierVictimEffect::BP_DoPingEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveCarrierVictimEffect", "BP_DoPingEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.ObjectiveCarrierVictimEffect.BP_HidePingEffect
// (Event, Protected, BlueprintEvent)

void AObjectiveCarrierVictimEffect::BP_HidePingEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveCarrierVictimEffect", "BP_HidePingEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.ObjectiveCarrierVictimEffect.GetPingRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AObjectiveCarrierVictimEffect::GetPingRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveCarrierVictimEffect", "GetPingRatio");

	Params::ObjectiveCarrierVictimEffect_GetPingRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ObjectiveCarrierVictimEffect.IsInCooldown
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AObjectiveCarrierVictimEffect::IsInCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveCarrierVictimEffect", "IsInCooldown");

	Params::ObjectiveCarrierVictimEffect_IsInCooldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ObjectiveCarrierVictimEffect.NotifyPingMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void AObjectiveCarrierVictimEffect::NotifyPingMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveCarrierVictimEffect", "NotifyPingMulticast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISessionStats.ClassPlayTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FClassPlayTimeDefinition> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FClassPlayTimeDefinition> UDISessionStats::ClassPlayTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionStats", "ClassPlayTime");

	Params::DISessionStats_ClassPlayTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionStats.DeathsSolo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDISessionStats::DeathsSolo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionStats", "DeathsSolo");

	Params::DISessionStats_DeathsSolo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionStats.DeathsTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDISessionStats::DeathsTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionStats", "DeathsTeam");

	Params::DISessionStats_DeathsTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionStats.KillsSolo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDISessionStats::KillsSolo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionStats", "KillsSolo");

	Params::DISessionStats_KillsSolo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionStats.KillsTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDISessionStats::KillsTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionStats", "KillsTeam");

	Params::DISessionStats_KillsTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionStats.MatchesPlayedDuo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDISessionStats::MatchesPlayedDuo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionStats", "MatchesPlayedDuo");

	Params::DISessionStats_MatchesPlayedDuo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionStats.MatchesPlayedSolo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDISessionStats::MatchesPlayedSolo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionStats", "MatchesPlayedSolo");

	Params::DISessionStats_MatchesPlayedSolo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionStats.MatchesPlayedTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDISessionStats::MatchesPlayedTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionStats", "MatchesPlayedTeam");

	Params::DISessionStats_MatchesPlayedTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionStats.MatchesWonDuo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDISessionStats::MatchesWonDuo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionStats", "MatchesWonDuo");

	Params::DISessionStats_MatchesWonDuo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionStats.MatchesWonSolo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDISessionStats::MatchesWonSolo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionStats", "MatchesWonSolo");

	Params::DISessionStats_MatchesWonSolo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionStats.MatchesWonTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDISessionStats::MatchesWonTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionStats", "MatchesWonTeam");

	Params::DISessionStats_MatchesWonTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionStats.TopPlayedAgents
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FAgentPlayTimeDefinition> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FAgentPlayTimeDefinition> UDISessionStats::TopPlayedAgents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionStats", "TopPlayedAgents");

	Params::DISessionStats_TopPlayedAgents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionStats.TotalGames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDISessionStats::TotalGames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionStats", "TotalGames");

	Params::DISessionStats_TotalGames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionStats.TotalPlayTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDISessionStats::TotalPlayTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionStats", "TotalPlayTime");

	Params::DISessionStats_TotalPlayTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISessionStats.VictoryPercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDISessionStats::VictoryPercentage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISessionStats", "VictoryPercentage");

	Params::DISessionStats_VictoryPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DisguiseShieldComponent.HandleCoverChange
// (Final, Native, Protected)
// Parameters:
// bool                                    Undercover                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDisguiseShieldComponent::HandleCoverChange(bool Undercover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisguiseShieldComponent", "HandleCoverChange");

	Params::DisguiseShieldComponent_HandleCoverChange Parms{};

	Parms.Undercover = Undercover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DisguiseShieldComponent.HandleNewDisguise
// (Final, Native, Protected)
// Parameters:
// class ANPCCharacter*                    Disguise                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDisguiseShieldComponent::HandleNewDisguise(class ANPCCharacter* Disguise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisguiseShieldComponent", "HandleNewDisguise");

	Params::DisguiseShieldComponent_HandleNewDisguise Parms{};

	Parms.Disguise = Disguise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DisguiseShieldComponent.HandleRemoveDisguise
// (Final, Native, Protected)
// Parameters:
// class ANPCCharacter*                    Disguise                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDisguiseShieldComponent::HandleRemoveDisguise(class ANPCCharacter* Disguise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisguiseShieldComponent", "HandleRemoveDisguise");

	Params::DisguiseShieldComponent_HandleRemoveDisguise Parms{};

	Parms.Disguise = Disguise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIOnlineFriendInfo.GetSubsystemName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FString                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FString UDIOnlineFriendInfo::GetSubsystemName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIOnlineFriendInfo", "GetSubsystemName");

	Params::DIOnlineFriendInfo_GetSubsystemName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIOnlineFriendInfo.GetUserIdString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FString                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FString UDIOnlineFriendInfo::GetUserIdString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIOnlineFriendInfo", "GetUserIdString");

	Params::DIOnlineFriendInfo_GetUserIdString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.LarcinPassiveMod1Ability.HandleLoadoutSpawnCompleteEvent
// (Final, Native, Protected)
// Parameters:
// class UToolLoadoutComponent*            LoadoutComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALarcinPassiveMod1Ability::HandleLoadoutSpawnCompleteEvent(class UToolLoadoutComponent* LoadoutComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinPassiveMod1Ability", "HandleLoadoutSpawnCompleteEvent");

	Params::LarcinPassiveMod1Ability_HandleLoadoutSpawnCompleteEvent Parms{};

	Parms.LoadoutComponent = LoadoutComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.LarcinPassiveMod1Ability.HandleMeleeAttackImpactEvent
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactPoint                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ChargeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ResultingHealthPercentage                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHitType                                HitType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMeleeHitConfirmedData           HitConfirmedData                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALarcinPassiveMod1Ability::HandleMeleeAttackImpactEvent(class AActor* Victim, const struct FVector& ImpactPoint, int32 ChargeLevel, float Damage, float ResultingHealthPercentage, EHitType HitType, const struct FMeleeHitConfirmedData& HitConfirmedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinPassiveMod1Ability", "HandleMeleeAttackImpactEvent");

	Params::LarcinPassiveMod1Ability_HandleMeleeAttackImpactEvent Parms{};

	Parms.Victim = Victim;
	Parms.ImpactPoint = std::move(ImpactPoint);
	Parms.ChargeLevel = ChargeLevel;
	Parms.Damage = Damage;
	Parms.ResultingHealthPercentage = ResultingHealthPercentage;
	Parms.HitType = HitType;
	Parms.HitConfirmedData = std::move(HitConfirmedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISocialSubsystem.AcceptFriendRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDIOnlineFriendInfo*              FriendInfo                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISocialSubsystem::AcceptFriendRequest(class UDIOnlineFriendInfo* FriendInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISocialSubsystem", "AcceptFriendRequest");

	Params::DISocialSubsystem_AcceptFriendRequest Parms{};

	Parms.FriendInfo = FriendInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISocialSubsystem.ApplyReportFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ShouldAdd                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ApplyBitmask                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentBitmask                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDISocialSubsystem::ApplyReportFlag(bool ShouldAdd, int32 ApplyBitmask, int32 CurrentBitmask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISocialSubsystem", "ApplyReportFlag");

	Params::DISocialSubsystem_ApplyReportFlag Parms{};

	Parms.ShouldAdd = ShouldAdd;
	Parms.ApplyBitmask = ApplyBitmask;
	Parms.CurrentBitmask = CurrentBitmask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISocialSubsystem.BlockPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDIOnlineFriendInfo*              FriendInfo                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISocialSubsystem::BlockPlayer(class UDIOnlineFriendInfo* FriendInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISocialSubsystem", "BlockPlayer");

	Params::DISocialSubsystem_BlockPlayer Parms{};

	Parms.FriendInfo = FriendInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISocialSubsystem.CancelFriendRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDIOnlineFriendInfo*              FriendInfo                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISocialSubsystem::CancelFriendRequest(class UDIOnlineFriendInfo* FriendInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISocialSubsystem", "CancelFriendRequest");

	Params::DISocialSubsystem_CancelFriendRequest Parms{};

	Parms.FriendInfo = FriendInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISocialSubsystem.OnDIWebServiceLoginCompleted
// (Final, Native, Protected)
// Parameters:
// struct FLoginResponse                   LoginResponse                                          (Parm, NativeAccessSpecifierPublic)

void UDISocialSubsystem::OnDIWebServiceLoginCompleted(const struct FLoginResponse& LoginResponse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISocialSubsystem", "OnDIWebServiceLoginCompleted");

	Params::DISocialSubsystem_OnDIWebServiceLoginCompleted Parms{};

	Parms.LoginResponse = std::move(LoginResponse);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISocialSubsystem.OnMapChange
// (Final, Native, Protected)
// Parameters:
// class UWorld*                           LoadedWorld                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISocialSubsystem::OnMapChange(class UWorld* LoadedWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISocialSubsystem", "OnMapChange");

	Params::DISocialSubsystem_OnMapChange Parms{};

	Parms.LoadedWorld = LoadedWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISocialSubsystem.OnReadFriendsListComplete
// (Final, Native, Protected)
// Parameters:
// int32                                   LocalUserNum                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ListName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ErrorStr                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISocialSubsystem::OnReadFriendsListComplete(int32 LocalUserNum, bool bWasSuccessful, const class FString& ListName, const class FString& ErrorStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISocialSubsystem", "OnReadFriendsListComplete");

	Params::DISocialSubsystem_OnReadFriendsListComplete Parms{};

	Parms.LocalUserNum = LocalUserNum;
	Parms.bWasSuccessful = bWasSuccessful;
	Parms.ListName = std::move(ListName);
	Parms.ErrorStr = std::move(ErrorStr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISocialSubsystem.RejectFriendRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDIOnlineFriendInfo*              FriendInfo                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISocialSubsystem::RejectFriendRequest(class UDIOnlineFriendInfo* FriendInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISocialSubsystem", "RejectFriendRequest");

	Params::DISocialSubsystem_RejectFriendRequest Parms{};

	Parms.FriendInfo = FriendInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISocialSubsystem.RemoveFriend
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDIOnlineFriendInfo*              FriendInfo                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISocialSubsystem::RemoveFriend(class UDIOnlineFriendInfo* FriendInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISocialSubsystem", "RemoveFriend");

	Params::DISocialSubsystem_RemoveFriend Parms{};

	Parms.FriendInfo = FriendInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISocialSubsystem.SearchFriendByDisplayName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           SearchDisplayName                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISocialSubsystem::SearchFriendByDisplayName(const class FString& SearchDisplayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISocialSubsystem", "SearchFriendByDisplayName");

	Params::DISocialSubsystem_SearchFriendByDisplayName Parms{};

	Parms.SearchDisplayName = std::move(SearchDisplayName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISocialSubsystem.SendFriendRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDIOnlineFriendInfo*              FriendInfo                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISocialSubsystem::SendFriendRequest(class UDIOnlineFriendInfo* FriendInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISocialSubsystem", "SendFriendRequest");

	Params::DISocialSubsystem_SendFriendRequest Parms{};

	Parms.FriendInfo = FriendInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISocialSubsystem.SendPlayerReport
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDIOnlineFriendInfo*              FriendInfo                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CategoryId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SessionID                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISocialSubsystem::SendPlayerReport(class UDIOnlineFriendInfo* FriendInfo, int32 CategoryId, const class FString& SessionID, const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISocialSubsystem", "SendPlayerReport");

	Params::DISocialSubsystem_SendPlayerReport Parms{};

	Parms.FriendInfo = FriendInfo;
	Parms.CategoryId = CategoryId;
	Parms.SessionID = std::move(SessionID);
	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISocialSubsystem.SendPlayerReportPlayerState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADIPlayerState*                   PlayerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CategoryId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SessionID                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISocialSubsystem::SendPlayerReportPlayerState(class ADIPlayerState* PlayerState, int32 CategoryId, const class FString& SessionID, const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISocialSubsystem", "SendPlayerReportPlayerState");

	Params::DISocialSubsystem_SendPlayerReportPlayerState Parms{};

	Parms.PlayerState = PlayerState;
	Parms.CategoryId = CategoryId;
	Parms.SessionID = std::move(SessionID);
	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISocialSubsystem.StartPollingFriendsList
// (Final, Native, Public, BlueprintCallable)

void UDISocialSubsystem::StartPollingFriendsList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISocialSubsystem", "StartPollingFriendsList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISocialSubsystem.StopPollingFriendsList
// (Final, Native, Public, BlueprintCallable)

void UDISocialSubsystem::StopPollingFriendsList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISocialSubsystem", "StopPollingFriendsList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISocialSubsystem.TriggerFriendsListOpenChanged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bOpen                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISocialSubsystem::TriggerFriendsListOpenChanged(bool bOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISocialSubsystem", "TriggerFriendsListOpenChanged");

	Params::DISocialSubsystem_TriggerFriendsListOpenChanged Parms{};

	Parms.bOpen = bOpen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISocialSubsystem.UnblockPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDIOnlineFriendInfo*              FriendInfo                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDISocialSubsystem::UnblockPlayer(class UDIOnlineFriendInfo* FriendInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISocialSubsystem", "UnblockPlayer");

	Params::DISocialSubsystem_UnblockPlayer Parms{};

	Parms.FriendInfo = FriendInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DISocialSubsystem.GetBlockedPlayersList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UDIOnlineFriendInfo*>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UDIOnlineFriendInfo*> UDISocialSubsystem::GetBlockedPlayersList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISocialSubsystem", "GetBlockedPlayersList");

	Params::DISocialSubsystem_GetBlockedPlayersList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISocialSubsystem.GetFriendInbounds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UDIOnlineFriendInfo*>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UDIOnlineFriendInfo*> UDISocialSubsystem::GetFriendInbounds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISocialSubsystem", "GetFriendInbounds");

	Params::DISocialSubsystem_GetFriendInbounds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISocialSubsystem.GetFriendOutbounds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UDIOnlineFriendInfo*>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UDIOnlineFriendInfo*> UDISocialSubsystem::GetFriendOutbounds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISocialSubsystem", "GetFriendOutbounds");

	Params::DISocialSubsystem_GetFriendOutbounds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DISocialSubsystem.GetSortedFriendList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UDIOnlineFriendInfo*>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UDIOnlineFriendInfo*> UDISocialSubsystem::GetSortedFriendList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DISocialSubsystem", "GetSortedFriendList");

	Params::DISocialSubsystem_GetSortedFriendList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VictimEffectTickBehavior.ApplyEffectToVictim
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVictimEffectTickBehavior::ApplyEffectToVictim(class AActor* Victim, class AActor* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffectTickBehavior", "ApplyEffectToVictim");

	Params::VictimEffectTickBehavior_ApplyEffectToVictim Parms{};

	Parms.Victim = Victim;
	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffectTickBehavior.BP_OnEffectTick
// (Event, Public, BlueprintEvent)
// Parameters:
// class UVictimEffectTickBehavior*        EffectTick                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVictimEffectTickBehavior::BP_OnEffectTick(class UVictimEffectTickBehavior* EffectTick, class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffectTickBehavior", "BP_OnEffectTick");

	Params::VictimEffectTickBehavior_BP_OnEffectTick Parms{};

	Parms.EffectTick = EffectTick;
	Parms.Victim = Victim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.VictimEffectTickBehavior.IsPositiveEffect
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVictimEffectTickBehavior::IsPositiveEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffectTickBehavior", "IsPositiveEffect");

	Params::VictimEffectTickBehavior_IsPositiveEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VictimEffectTickBehavior.SetParentVictimEffect
// (Native, Public, BlueprintCallable)
// Parameters:
// class AVictimEffect*                    InParentVictimEffect                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVictimEffectTickBehavior::SetParentVictimEffect(class AVictimEffect* InParentVictimEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffectTickBehavior", "SetParentVictimEffect");

	Params::VictimEffectTickBehavior_SetParentVictimEffect Parms{};

	Parms.InParentVictimEffect = InParentVictimEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffectTickBehavior.StopEffect
// (Native, Public, BlueprintCallable)

void UVictimEffectTickBehavior::StopEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffectTickBehavior", "StopEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffectTickBehavior.GetEffectType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EVictimEffectType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EVictimEffectType UVictimEffectTickBehavior::GetEffectType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffectTickBehavior", "GetEffectType");

	Params::VictimEffectTickBehavior_GetEffectType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VictimEffectTickBehavior.GetParentVictimEffect
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AVictimEffect*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AVictimEffect* UVictimEffectTickBehavior::GetParentVictimEffect() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffectTickBehavior", "GetParentVictimEffect");

	Params::VictimEffectTickBehavior_GetParentVictimEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiSpyAnimInstance1P.TryGetSpyOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASpy*                             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASpy* UDiSpyAnimInstance1P::TryGetSpyOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiSpyAnimInstance1P", "TryGetSpyOwner");

	Params::DiSpyAnimInstance1P_TryGetSpyOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiSpyAnimInstance3P.SwapTo3PDefaultMovementSet
// (Final, Native, Public, BlueprintCallable)

void UDiSpyAnimInstance3P::SwapTo3PDefaultMovementSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiSpyAnimInstance3P", "SwapTo3PDefaultMovementSet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiSpyAnimInstance3P.SwapTo3PMovementSet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MovementSetName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiSpyAnimInstance3P::SwapTo3PMovementSet(class FName MovementSetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiSpyAnimInstance3P", "SwapTo3PMovementSet");

	Params::DiSpyAnimInstance3P_SwapTo3PMovementSet Parms{};

	Parms.MovementSetName = MovementSetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiSpyAnimInstance3P.TryGetSpyOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASpy*                             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASpy* UDiSpyAnimInstance3P::TryGetSpyOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiSpyAnimInstance3P", "TryGetSpyOwner");

	Params::DiSpyAnimInstance3P_TryGetSpyOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIStoreMenuPageUserWidget.BP_RefreshSchedule
// (Event, Public, BlueprintEvent)

void UDIStoreMenuPageUserWidget::BP_RefreshSchedule()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreMenuPageUserWidget", "BP_RefreshSchedule");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.DIStoreMenuPageUserWidget.GetItemForSlot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReducedPrice                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDIItem*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDIItem* UDIStoreMenuPageUserWidget::GetItemForSlot(int32 SlotIndex, int32* ReducedPrice)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreMenuPageUserWidget", "GetItemForSlot");

	Params::DIStoreMenuPageUserWidget_GetItemForSlot Parms{};

	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ReducedPrice != nullptr)
		*ReducedPrice = Parms.ReducedPrice;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIItem.GetDisplayRarity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDIItem::GetDisplayRarity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIItem", "GetDisplayRarity");

	Params::DIItem_GetDisplayRarity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.XpProgressionData.ClampMatchLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   CurrentLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UXpProgressionData::ClampMatchLevel(int32 CurrentLevel, int32 NewLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XpProgressionData", "ClampMatchLevel");

	Params::XpProgressionData_ClampMatchLevel Parms{};

	Parms.CurrentLevel = CurrentLevel;
	Parms.NewLevel = NewLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.XpProgressionData.GetEchelonForLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   CurrentLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEchelonProgression              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEchelonProgression UXpProgressionData::GetEchelonForLevel(int32 CurrentLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XpProgressionData", "GetEchelonForLevel");

	Params::XpProgressionData_GetEchelonForLevel Parms{};

	Parms.CurrentLevel = CurrentLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.XpProgressionData.GetEchelonMinLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UXpProgressionData::GetEchelonMinLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XpProgressionData", "GetEchelonMinLevel");

	Params::XpProgressionData_GetEchelonMinLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.XpProgressionData.GetLastUnlockEchelon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   CurrentLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEchelonProgression              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEchelonProgression UXpProgressionData::GetLastUnlockEchelon(int32 CurrentLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XpProgressionData", "GetLastUnlockEchelon");

	Params::XpProgressionData_GetLastUnlockEchelon Parms{};

	Parms.CurrentLevel = CurrentLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.XpProgressionData.GetLevelForXpValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   CurrentLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   XPTotal                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UXpProgressionData::GetLevelForXpValue(int32 CurrentLevel, int32 XPTotal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XpProgressionData", "GetLevelForXpValue");

	Params::XpProgressionData_GetLevelForXpValue Parms{};

	Parms.CurrentLevel = CurrentLevel;
	Parms.XPTotal = XPTotal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.XpProgressionData.GetMaxLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UXpProgressionData::GetMaxLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XpProgressionData", "GetMaxLevel");

	Params::XpProgressionData_GetMaxLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.XpProgressionData.GetMaxLevelForMatch
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   CurrentLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UXpProgressionData::GetMaxLevelForMatch(int32 CurrentLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XpProgressionData", "GetMaxLevelForMatch");

	Params::XpProgressionData_GetMaxLevelForMatch Parms{};

	Parms.CurrentLevel = CurrentLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.XpProgressionData.GetProgressionPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   CurrentLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   XPTotal                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UXpProgressionData::GetProgressionPercent(int32 CurrentLevel, int32 XPTotal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XpProgressionData", "GetProgressionPercent");

	Params::XpProgressionData_GetProgressionPercent Parms{};

	Parms.CurrentLevel = CurrentLevel;
	Parms.XPTotal = XPTotal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.XpProgressionData.GetRequiredXPForLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   LevelIn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UXpProgressionData::GetRequiredXPForLevel(int32 LevelIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XpProgressionData", "GetRequiredXPForLevel");

	Params::XpProgressionData_GetRequiredXPForLevel Parms{};

	Parms.LevelIn = LevelIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VaultDoorOverrideCondition.GetCurrentStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EVaultOverrideStatus                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EVaultOverrideStatus UVaultDoorOverrideCondition::GetCurrentStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultDoorOverrideCondition", "GetCurrentStatus");

	Params::VaultDoorOverrideCondition_GetCurrentStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VaultDoorOverrideCondition.HandleInteractionComplete
// (Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVaultDoorOverrideCondition::HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultDoorOverrideCondition", "HandleInteractionComplete");

	Params::VaultDoorOverrideCondition_HandleInteractionComplete Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VaultDoorOverrideCondition.ReduceCost
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Reduction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVaultDoorOverrideCondition::ReduceCost(int32 Reduction, class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultDoorOverrideCondition", "ReduceCost");

	Params::VaultDoorOverrideCondition_ReduceCost Parms{};

	Parms.Reduction = Reduction;
	Parms.Spy = Spy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VaultDoorOverrideCondition.GetRemainingIntelRequired
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UVaultDoorOverrideCondition::GetRemainingIntelRequired() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultDoorOverrideCondition", "GetRemainingIntelRequired");

	Params::VaultDoorOverrideCondition_GetRemainingIntelRequired Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Matchmaker.CancelMatchmaking
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IMatchmaker::CancelMatchmaking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Matchmaker", "CancelMatchmaking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Matchmaker.DoStartMatchmakingRequest
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EDIGameMode                             GameMode                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMatchmaker::DoStartMatchmakingRequest(const EDIGameMode GameMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Matchmaker", "DoStartMatchmakingRequest");

	Params::Matchmaker_DoStartMatchmakingRequest Parms{};

	Parms.GameMode = GameMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Matchmaker.DoStartMatchmakingRequestForPrivateLobby
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EDIGameMode                             GameMode                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDIPrivateLobbyInfo              DIPrivateLobbyInfo                                     (ConstParm, Parm, NativeAccessSpecifierPublic)

void IMatchmaker::DoStartMatchmakingRequestForPrivateLobby(const EDIGameMode GameMode, const struct FDIPrivateLobbyInfo& DIPrivateLobbyInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Matchmaker", "DoStartMatchmakingRequestForPrivateLobby");

	Params::Matchmaker_DoStartMatchmakingRequestForPrivateLobby Parms{};

	Parms.GameMode = GameMode;
	Parms.DIPrivateLobbyInfo = std::move(DIPrivateLobbyInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Matchmaker.IsDelayedMatchmaking
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IMatchmaker::IsDelayedMatchmaking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Matchmaker", "IsDelayedMatchmaking");

	Params::Matchmaker_IsDelayedMatchmaking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Matchmaker.IsMatchmaking
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IMatchmaker::IsMatchmaking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Matchmaker", "IsMatchmaking");

	Params::Matchmaker_IsMatchmaking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ScannableComponent.AreConditionsMet
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Interacter                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScannableComponent::AreConditionsMet(class AActor* Interacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScannableComponent", "AreConditionsMet");

	Params::ScannableComponent_AreConditionsMet Parms{};

	Parms.Interacter = Interacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ScannableComponent.AreRayCastConditionMet
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Interacter                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScannableComponent::AreRayCastConditionMet(class AActor* Interacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScannableComponent", "AreRayCastConditionMet");

	Params::ScannableComponent_AreRayCastConditionMet Parms{};

	Parms.Interacter = Interacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ScannableComponent.OnComponentBeginOverlap
// (Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UScannableComponent::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScannableComponent", "OnComponentBeginOverlap");

	Params::ScannableComponent_OnComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ScannableComponent.OnComponentEndOverlap
// (Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScannableComponent::OnComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScannableComponent", "OnComponentEndOverlap");

	Params::ScannableComponent_OnComponentEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ScannableComponent.SetDetectionCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UShapeComponent*                  CollisionShape                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScannableComponent::SetDetectionCollision(class UShapeComponent* CollisionShape)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScannableComponent", "SetDetectionCollision");

	Params::ScannableComponent_SetDetectionCollision Parms{};

	Parms.CollisionShape = CollisionShape;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ScannableComponent.SetIsScannable
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bScannable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScannableComponent::SetIsScannable(bool bScannable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScannableComponent", "SetIsScannable");

	Params::ScannableComponent_SetIsScannable Parms{};

	Parms.bScannable = bScannable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ScannableComponent.SetScanIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractionIconComponent*        ScanIcon                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScannableComponent::SetScanIcon(class UInteractionIconComponent* ScanIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScannableComponent", "SetScanIcon");

	Params::ScannableComponent_SetScanIcon Parms{};

	Parms.ScanIcon = ScanIcon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ScannableComponent.GetInteractionLocation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UScannableComponent::GetInteractionLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScannableComponent", "GetInteractionLocation");

	Params::ScannableComponent_GetInteractionLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ScannableComponent.GetScanIcon
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionIconComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionIconComponent* UScannableComponent::GetScanIcon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScannableComponent", "GetScanIcon");

	Params::ScannableComponent_GetScanIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.GameplayResourcesComponent.AddMaxAmountPowerup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EGameplayResourcesType                  Ressource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxAmountIncrease                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ResourceToGive                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayResourcesComponent::AddMaxAmountPowerup(EGameplayResourcesType Ressource, int32 MaxAmountIncrease, int32 ResourceToGive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayResourcesComponent", "AddMaxAmountPowerup");

	Params::GameplayResourcesComponent_AddMaxAmountPowerup Parms{};

	Parms.Ressource = Ressource;
	Parms.MaxAmountIncrease = MaxAmountIncrease;
	Parms.ResourceToGive = ResourceToGive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GameplayResourcesComponent.AddResource
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGiveXpForResource                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayResourcesComponent::AddResource(EGameplayResourcesType ResourceType, int32 Amount, bool bGiveXpForResource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayResourcesComponent", "AddResource");

	Params::GameplayResourcesComponent_AddResource Parms{};

	Parms.ResourceType = ResourceType;
	Parms.Amount = Amount;
	Parms.bGiveXpForResource = bGiveXpForResource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GameplayResourcesComponent.GetMaxAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameplayResourcesComponent::GetMaxAmount(EGameplayResourcesType ResourceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayResourcesComponent", "GetMaxAmount");

	Params::GameplayResourcesComponent_GetMaxAmount Parms{};

	Parms.ResourceType = ResourceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.GameplayResourcesComponent.GetResourceAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameplayResourcesComponent::GetResourceAmount(EGameplayResourcesType ResourceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayResourcesComponent", "GetResourceAmount");

	Params::GameplayResourcesComponent_GetResourceAmount Parms{};

	Parms.ResourceType = ResourceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.GameplayResourcesComponent.GetResourceDisplayName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UGameplayResourcesComponent::GetResourceDisplayName(EGameplayResourcesType ResourceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayResourcesComponent", "GetResourceDisplayName");

	Params::GameplayResourcesComponent_GetResourceDisplayName Parms{};

	Parms.ResourceType = ResourceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.GameplayResourcesComponent.HasEnoughResource
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayResourcesComponent::HasEnoughResource(EGameplayResourcesType ResourceType, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayResourcesComponent", "HasEnoughResource");

	Params::GameplayResourcesComponent_HasEnoughResource Parms{};

	Parms.ResourceType = ResourceType;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.GameplayResourcesComponent.OnRep_NewPlayerResourceData
// (Final, Native, Protected)
// Parameters:
// TArray<struct FPlayerResourceData>      OldData                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGameplayResourcesComponent::OnRep_NewPlayerResourceData(const TArray<struct FPlayerResourceData>& OldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayResourcesComponent", "OnRep_NewPlayerResourceData");

	Params::GameplayResourcesComponent_OnRep_NewPlayerResourceData Parms{};

	Parms.OldData = std::move(OldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GameplayResourcesComponent.RemoveMaxAmountPowerup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EGameplayResourcesType                  Ressource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxAmountIncrease                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ResourceToGive                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayResourcesComponent::RemoveMaxAmountPowerup(EGameplayResourcesType Ressource, int32 MaxAmountIncrease, int32 ResourceToGive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayResourcesComponent", "RemoveMaxAmountPowerup");

	Params::GameplayResourcesComponent_RemoveMaxAmountPowerup Parms{};

	Parms.Ressource = Ressource;
	Parms.MaxAmountIncrease = MaxAmountIncrease;
	Parms.ResourceToGive = ResourceToGive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GameplayResourcesComponent.RemoveResource
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayResourcesComponent::RemoveResource(EGameplayResourcesType ResourceType, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayResourcesComponent", "RemoveResource");

	Params::GameplayResourcesComponent_RemoveResource Parms{};

	Parms.ResourceType = ResourceType;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GameplayResourcesComponent.ResetPlayerResources
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UGameplayResourcesComponent::ResetPlayerResources()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayResourcesComponent", "ResetPlayerResources");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GameplayResourcesComponent.SetMaxAmount
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxAmount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayResourcesComponent::SetMaxAmount(EGameplayResourcesType ResourceType, int32 MaxAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayResourcesComponent", "SetMaxAmount");

	Params::GameplayResourcesComponent_SetMaxAmount Parms{};

	Parms.ResourceType = ResourceType;
	Parms.MaxAmount = MaxAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.IsNPCMainAnimationAirborne
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENPCMainAnimation                       CheckMainAnimation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCCharacter::IsNPCMainAnimationAirborne(ENPCMainAnimation CheckMainAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NPCCharacter", "IsNPCMainAnimationAirborne");

	Params::NPCCharacter_IsNPCMainAnimationAirborne Parms{};

	Parms.CheckMainAnimation = CheckMainAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCCharacter.BouncedTimeOutTimerEnd
// (Final, Native, Public)

void ANPCCharacter::BouncedTimeOutTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "BouncedTimeOutTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.BP_OnDeath
// (Event, Public, BlueprintEvent)

void ANPCCharacter::BP_OnDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "BP_OnDeath");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.NPCCharacter.BP_OnGuardLostTargetAnim
// (Event, Public, BlueprintEvent)

void ANPCCharacter::BP_OnGuardLostTargetAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "BP_OnGuardLostTargetAnim");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.NPCCharacter.BP_OnNPCBanter
// (Event, Public, BlueprintEvent)

void ANPCCharacter::BP_OnNPCBanter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "BP_OnNPCBanter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.NPCCharacter.BP_OnNPCJustRevivedAnotherNPC
// (Event, Public, BlueprintEvent)
// Parameters:
// class ANPCCharacter*                    DeadNPC                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Prop                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCCharacter::BP_OnNPCJustRevivedAnotherNPC(class ANPCCharacter* DeadNPC, class AActor* Prop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "BP_OnNPCJustRevivedAnotherNPC");

	Params::NPCCharacter_BP_OnNPCJustRevivedAnotherNPC Parms{};

	Parms.DeadNPC = DeadNPC;
	Parms.Prop = Prop;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.NPCCharacter.BP_OnNPCRevivingAnotherNPC
// (Event, Public, BlueprintEvent)
// Parameters:
// class ANPCCharacter*                    DeadNPC                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCCharacter::BP_OnNPCRevivingAnotherNPC(class ANPCCharacter* DeadNPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "BP_OnNPCRevivingAnotherNPC");

	Params::NPCCharacter_BP_OnNPCRevivingAnotherNPC Parms{};

	Parms.DeadNPC = DeadNPC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.NPCCharacter.BP_OnPlayReplicatedVO
// (Event, Protected, BlueprintEvent)
// Parameters:
// ENPCReplicatedVO                        VOType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCCharacter::BP_OnPlayReplicatedVO(ENPCReplicatedVO VOType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "BP_OnPlayReplicatedVO");

	Params::NPCCharacter_BP_OnPlayReplicatedVO Parms{};

	Parms.VOType = VOType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.NPCCharacter.BP_OnResurrected
// (Event, Public, BlueprintEvent)

void ANPCCharacter::BP_OnResurrected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "BP_OnResurrected");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.NPCCharacter.BP_OnScaredChange
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bScaredIn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCCharacter::BP_OnScaredChange(bool bScaredIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "BP_OnScaredChange");

	Params::NPCCharacter_BP_OnScaredChange Parms{};

	Parms.bScaredIn = bScaredIn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.NPCCharacter.BP_OnScareTriggered
// (Event, Public, BlueprintEvent)
// Parameters:
// ENPCScaredReason                        ScaredReason                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCCharacter::BP_OnScareTriggered(ENPCScaredReason ScaredReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "BP_OnScareTriggered");

	Params::NPCCharacter_BP_OnScareTriggered Parms{};

	Parms.ScaredReason = ScaredReason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.NPCCharacter.BP_OnScoldStart
// (Event, Public, BlueprintEvent)

void ANPCCharacter::BP_OnScoldStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "BP_OnScoldStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.NPCCharacter.BP_OnSpyRelease
// (Event, Public, BlueprintEvent)

void ANPCCharacter::BP_OnSpyRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "BP_OnSpyRelease");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.NPCCharacter.BP_OnXiuDecoyEffect
// (Event, Public, BlueprintEvent)

void ANPCCharacter::BP_OnXiuDecoyEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "BP_OnXiuDecoyEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.NPCCharacter.BP_SignificanceUpdate
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCCharacter::BP_SignificanceUpdate(float OldValue, float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "BP_SignificanceUpdate");

	Params::NPCCharacter_BP_SignificanceUpdate Parms{};

	Parms.OldValue = OldValue;
	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.NPCCharacter.DestroyCurrentProp
// (Final, Native, Public, BlueprintCallable)

void ANPCCharacter::DestroyCurrentProp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "DestroyCurrentProp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.ExternalBounce
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Impulse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           BouncedBy                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCCharacter::ExternalBounce(const struct FVector& Impulse, class AActor* BouncedBy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "ExternalBounce");

	Params::NPCCharacter_ExternalBounce Parms{};

	Parms.Impulse = std::move(Impulse);
	Parms.BouncedBy = BouncedBy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.HandleInteractionComplete
// (Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCCharacter::HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "HandleInteractionComplete");

	Params::NPCCharacter_HandleInteractionComplete Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.HandleTakePointDamage
// (Final, Native, Protected, HasDefaults)
// Parameters:
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              FHitComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ShotFromDirection                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCCharacter::HandleTakePointDamage(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& ShotFromDirection, const class UDamageType* DamageType, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "HandleTakePointDamage");

	Params::NPCCharacter_HandleTakePointDamage Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.Damage = Damage;
	Parms.InstigatedBy = InstigatedBy;
	Parms.HitLocation = std::move(HitLocation);
	Parms.FHitComponent = FHitComponent;
	Parms.BoneName = BoneName;
	Parms.ShotFromDirection = std::move(ShotFromDirection);
	Parms.DamageType = DamageType;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.IsRightFootForward
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCCharacter::IsRightFootForward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "IsRightFootForward");

	Params::NPCCharacter_IsRightFootForward Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCCharacter.Multicast_FellOffMap
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ANPCCharacter::Multicast_FellOffMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "Multicast_FellOffMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.MulticastExternalBounce
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FVector_NetQuantize              Impulse                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           BouncedBy                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCCharacter::MulticastExternalBounce(const struct FVector_NetQuantize& Impulse, class AActor* BouncedBy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "MulticastExternalBounce");

	Params::NPCCharacter_MulticastExternalBounce Parms{};

	Parms.Impulse = std::move(Impulse);
	Parms.BouncedBy = BouncedBy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.NetMulticast_OnResurrected
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ANPCCharacter::NetMulticast_OnResurrected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "NetMulticast_OnResurrected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.NetMulticast_TriggerScared
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// ENPCScaredReason                        ScaredReason                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCCharacter::NetMulticast_TriggerScared(ENPCScaredReason ScaredReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "NetMulticast_TriggerScared");

	Params::NPCCharacter_NetMulticast_TriggerScared Parms{};

	Parms.ScaredReason = ScaredReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.NetMulticast_TriggerXiuDecoyEffect
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ANPCCharacter::NetMulticast_TriggerXiuDecoyEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "NetMulticast_TriggerXiuDecoyEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.OnConversationNewTalkingNPC
// (Final, Native, Protected)
// Parameters:
// class UNPCConversationComponent*        ConversationInteractionComp                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANPCCharacter*                    TalkingNPC                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCCharacter::OnConversationNewTalkingNPC(class UNPCConversationComponent* ConversationInteractionComp, class ANPCCharacter* TalkingNPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "OnConversationNewTalkingNPC");

	Params::NPCCharacter_OnConversationNewTalkingNPC Parms{};

	Parms.ConversationInteractionComp = ConversationInteractionComp;
	Parms.TalkingNPC = TalkingNPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.OnCrouchToResurectDelayTimerEnd
// (Final, Native, Protected)

void ANPCCharacter::OnCrouchToResurectDelayTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "OnCrouchToResurectDelayTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.OnDeath
// (Final, Native, Public)
// Parameters:
// class AActor*                           DeadActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCCharacter::OnDeath(class AActor* DeadActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "OnDeath");

	Params::NPCCharacter_OnDeath Parms{};

	Parms.DeadActor = DeadActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.OnHealthChanged
// (Final, Native, Public)
// Parameters:
// class UHealthComponent*                 OwningHealthComp                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Health                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HealthDelta                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RawDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCCharacter::OnHealthChanged(class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, float RawDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "OnHealthChanged");

	Params::NPCCharacter_OnHealthChanged Parms{};

	Parms.OwningHealthComp = OwningHealthComp;
	Parms.Health = Health;
	Parms.HealthDelta = HealthDelta;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.RawDamage = RawDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.OnRep_Bounced
// (Final, Native, Public)

void ANPCCharacter::OnRep_Bounced()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "OnRep_Bounced");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.OnRep_CachedNPC
// (Final, Native, Public)

void ANPCCharacter::OnRep_CachedNPC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "OnRep_CachedNPC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.OnRep_FollowingVIP
// (Final, Native, Protected)

void ANPCCharacter::OnRep_FollowingVIP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "OnRep_FollowingVIP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.OnRep_IsCrouched
// (Final, Native, Public)

void ANPCCharacter::OnRep_IsCrouched()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "OnRep_IsCrouched");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.OnRep_LookAtData
// (Final, Native, Protected)
// Parameters:
// struct FNPCLookAtReplicationData        PrevLookAtData                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ANPCCharacter::OnRep_LookAtData(const struct FNPCLookAtReplicationData& PrevLookAtData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "OnRep_LookAtData");

	Params::NPCCharacter_OnRep_LookAtData Parms{};

	Parms.PrevLookAtData = std::move(PrevLookAtData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.OnRep_MainAnimation
// (Final, Native, Protected)
// Parameters:
// ENPCMainAnimation                       PrevMainAnimation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCCharacter::OnRep_MainAnimation(ENPCMainAnimation PrevMainAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "OnRep_MainAnimation");

	Params::NPCCharacter_OnRep_MainAnimation Parms{};

	Parms.PrevMainAnimation = PrevMainAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.OnRep_MovementData
// (Final, Native, Protected)
// Parameters:
// struct FNPCMovementReplicationData      PrevMovementData                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ANPCCharacter::OnRep_MovementData(const struct FNPCMovementReplicationData& PrevMovementData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "OnRep_MovementData");

	Params::NPCCharacter_OnRep_MovementData Parms{};

	Parms.PrevMovementData = std::move(PrevMovementData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.OnRep_ReplicatedInteraction
// (Final, Native, Public)
// Parameters:
// class AActor*                           PrevReplicatedInteraction                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCCharacter::OnRep_ReplicatedInteraction(class AActor* PrevReplicatedInteraction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "OnRep_ReplicatedInteraction");

	Params::NPCCharacter_OnRep_ReplicatedInteraction Parms{};

	Parms.PrevReplicatedInteraction = PrevReplicatedInteraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.OnRep_Running
// (Final, Native, Protected)
// Parameters:
// bool                                    PrevRunning                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCCharacter::OnRep_Running(bool PrevRunning)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "OnRep_Running");

	Params::NPCCharacter_OnRep_Running Parms{};

	Parms.PrevRunning = PrevRunning;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.OnRep_Scared
// (Final, Native, Protected)
// Parameters:
// bool                                    PrevScared                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCCharacter::OnRep_Scared(bool PrevScared)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "OnRep_Scared");

	Params::NPCCharacter_OnRep_Scared Parms{};

	Parms.PrevScared = PrevScared;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.OnRep_ScoldState
// (Final, Native, Protected)
// Parameters:
// EScoldState                             PrevScoldState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCCharacter::OnRep_ScoldState(EScoldState PrevScoldState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "OnRep_ScoldState");

	Params::NPCCharacter_OnRep_ScoldState Parms{};

	Parms.PrevScoldState = PrevScoldState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.OnResurrectTimer
// (Final, Native, Public)

void ANPCCharacter::OnResurrectTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "OnResurrectTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.OnRevive
// (Final, Native, Public)
// Parameters:
// class AActor*                           DeadActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCCharacter::OnRevive(class AActor* DeadActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "OnRevive");

	Params::NPCCharacter_OnRevive Parms{};

	Parms.DeadActor = DeadActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.OnScaredEnd
// (Final, Native, Protected)

void ANPCCharacter::OnScaredEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "OnScaredEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.OnScoldGiveUp
// (Final, Native, Protected)

void ANPCCharacter::OnScoldGiveUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "OnScoldGiveUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.PlayReplicatedVO
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// ENPCReplicatedVO                        VOType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCCharacter::PlayReplicatedVO(ENPCReplicatedVO VOType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "PlayReplicatedVO");

	Params::NPCCharacter_PlayReplicatedVO Parms{};

	Parms.VOType = VOType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.ReleasePlayerPossessMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ANPCCharacter::ReleasePlayerPossessMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "ReleasePlayerPossessMulticast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.Resurrect
// (Final, Native, Public, BlueprintCallable)

void ANPCCharacter::Resurrect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "Resurrect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.SetUpperBodyBoneGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENPCUpperBodyBoneGroup                  NewBoneGroup                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCCharacter::SetUpperBodyBoneGroup(ENPCUpperBodyBoneGroup NewBoneGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "SetUpperBodyBoneGroup");

	Params::NPCCharacter_SetUpperBodyBoneGroup Parms{};

	Parms.NewBoneGroup = NewBoneGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.SpawnProp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               ActorClassToSpawn                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneAttachName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ANPCCharacter::SpawnProp(TSubclassOf<class AActor> ActorClassToSpawn, class FName BoneAttachName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "SpawnProp");

	Params::NPCCharacter_SpawnProp Parms{};

	Parms.ActorClassToSpawn = ActorClassToSpawn;
	Parms.BoneAttachName = BoneAttachName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCCharacter.TriggerGuardLostTargetAnimEvent
// (Final, Native, Public, BlueprintCallable)

void ANPCCharacter::TriggerGuardLostTargetAnimEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "TriggerGuardLostTargetAnimEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.TriggerNPCBanterEvent
// (Final, Native, Public, BlueprintCallable)

void ANPCCharacter::TriggerNPCBanterEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "TriggerNPCBanterEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCCharacter.CanEverBeAggroed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCCharacter::CanEverBeAggroed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "CanEverBeAggroed");

	Params::NPCCharacter_CanEverBeAggroed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCCharacter.GetControllingSpy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASpy*                             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASpy* ANPCCharacter::GetControllingSpy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "GetControllingSpy");

	Params::NPCCharacter_GetControllingSpy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCCharacter.GetCurrentProp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ANPCCharacter::GetCurrentProp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "GetCurrentProp");

	Params::NPCCharacter_GetCurrentProp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCCharacter.GetEffectOfClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UClass*                           EffectClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVictimEffect*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AVictimEffect* ANPCCharacter::GetEffectOfClass(class UClass* EffectClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "GetEffectOfClass");

	Params::NPCCharacter_GetEffectOfClass Parms{};

	Parms.EffectClass = EffectClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCCharacter.GetGuardComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UNPCGuardComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNPCGuardComponent* ANPCCharacter::GetGuardComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "GetGuardComponent");

	Params::NPCCharacter_GetGuardComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCCharacter.GetInteractableType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInteractableType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInteractableType ANPCCharacter::GetInteractableType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "GetInteractableType");

	Params::NPCCharacter_GetInteractableType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCCharacter.GetKillerData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLastInteractionData             ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLastInteractionData ANPCCharacter::GetKillerData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "GetKillerData");

	Params::NPCCharacter_GetKillerData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCCharacter.GetNPCPool
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENPCPool                                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENPCPool ANPCCharacter::GetNPCPool() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "GetNPCPool");

	Params::NPCCharacter_GetNPCPool Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCCharacter.GetSecurityLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESecurityLevel                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESecurityLevel ANPCCharacter::GetSecurityLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "GetSecurityLevel");

	Params::NPCCharacter_GetSecurityLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCCharacter.GetUpperBodyBoneGroup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENPCUpperBodyBoneGroup                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENPCUpperBodyBoneGroup ANPCCharacter::GetUpperBodyBoneGroup() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "GetUpperBodyBoneGroup");

	Params::NPCCharacter_GetUpperBodyBoneGroup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCCharacter.GetWalkDirection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENPCWalkDirection                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENPCWalkDirection ANPCCharacter::GetWalkDirection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "GetWalkDirection");

	Params::NPCCharacter_GetWalkDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCCharacter.IsActorFlaggedAsIgnoreHeat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           FlaggedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCCharacter::IsActorFlaggedAsIgnoreHeat(class AActor* FlaggedActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "IsActorFlaggedAsIgnoreHeat");

	Params::NPCCharacter_IsActorFlaggedAsIgnoreHeat Parms{};

	Parms.FlaggedActor = FlaggedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCCharacter.IsAggroed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCCharacter::IsAggroed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "IsAggroed");

	Params::NPCCharacter_IsAggroed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCCharacter.IsControlledBySpy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCCharacter::IsControlledBySpy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "IsControlledBySpy");

	Params::NPCCharacter_IsControlledBySpy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCCharacter.IsDead
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCCharacter::IsDead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "IsDead");

	Params::NPCCharacter_IsDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCCharacter.IsFlaggedAsXiuDecoy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCCharacter::IsFlaggedAsXiuDecoy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "IsFlaggedAsXiuDecoy");

	Params::NPCCharacter_IsFlaggedAsXiuDecoy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCCharacter.IsFollowingVIP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCCharacter::IsFollowingVIP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "IsFollowingVIP");

	Params::NPCCharacter_IsFollowingVIP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCCharacter.IsRunDisabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCCharacter::IsRunDisabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "IsRunDisabled");

	Params::NPCCharacter_IsRunDisabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCCharacter.IsRunning
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCCharacter::IsRunning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "IsRunning");

	Params::NPCCharacter_IsRunning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCCharacter.IsScared
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCCharacter::IsScared() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "IsScared");

	Params::NPCCharacter_IsScared Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCCharacter.IsScolding
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCCharacter::IsScolding() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCharacter", "IsScolding");

	Params::NPCCharacter_IsScolding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCBehaviorInteract.OnFakeInteractTimerEnd
// (Final, Native, Protected)

void UNPCBehaviorInteract::OnFakeInteractTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBehaviorInteract", "OnFakeInteractTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBehaviorInteract.OnFlushNetDormancyIntervalTimerEnd
// (Final, Native, Protected)

void UNPCBehaviorInteract::OnFlushNetDormancyIntervalTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBehaviorInteract", "OnFlushNetDormancyIntervalTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBehaviorInteract.OnGiveUpInteractTimerEnd
// (Final, Native, Protected)

void UNPCBehaviorInteract::OnGiveUpInteractTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBehaviorInteract", "OnGiveUpInteractTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBehaviorInteract.OnOutroTimerEnd
// (Final, Native, Protected)

void UNPCBehaviorInteract::OnOutroTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBehaviorInteract", "OnOutroTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBehaviorInteract.OnReInteractTimerEnd
// (Final, Native, Protected)

void UNPCBehaviorInteract::OnReInteractTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBehaviorInteract", "OnReInteractTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIStoreSubsystem.CatalogueIsItemPremiumLocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UStoreCatalogEntryData*           Catalogue                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDIItem*                          ItemToChheck                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIStoreSubsystem::CatalogueIsItemPremiumLocked(const class UStoreCatalogEntryData* Catalogue, const class UDIItem* ItemToChheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "CatalogueIsItemPremiumLocked");

	Params::DIStoreSubsystem_CatalogueIsItemPremiumLocked Parms{};

	Parms.Catalogue = Catalogue;
	Parms.ItemToChheck = ItemToChheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIStoreSubsystem.GetAllItemsOfType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EDIITemTypeQuery                        ItemType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinRarity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxRarity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShopOnly                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReverse                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UDIItem*>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UDIItem*> UDIStoreSubsystem::GetAllItemsOfType(EDIITemTypeQuery ItemType, int32 MinRarity, int32 MaxRarity, bool bShopOnly, bool bReverse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "GetAllItemsOfType");

	Params::DIStoreSubsystem_GetAllItemsOfType Parms{};

	Parms.ItemType = ItemType;
	Parms.MinRarity = MinRarity;
	Parms.MaxRarity = MaxRarity;
	Parms.bShopOnly = bShopOnly;
	Parms.bReverse = bReverse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIStoreSubsystem.GetCurrencyFromCurrencyId
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           CurrencyId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDICurrencyItem*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDICurrencyItem* UDIStoreSubsystem::GetCurrencyFromCurrencyId(const class FString& CurrencyId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "GetCurrencyFromCurrencyId");

	Params::DIStoreSubsystem_GetCurrencyFromCurrencyId Parms{};

	Parms.CurrencyId = std::move(CurrencyId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIStoreSubsystem.GetIsRotationEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIStoreSubsystem::GetIsRotationEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "GetIsRotationEnabled");

	Params::DIStoreSubsystem_GetIsRotationEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIStoreSubsystem.GetItemFromAssetId
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId                  AssetId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDIItem*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDIItem* UDIStoreSubsystem::GetItemFromAssetId(const struct FPrimaryAssetId& AssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "GetItemFromAssetId");

	Params::DIStoreSubsystem_GetItemFromAssetId Parms{};

	Parms.AssetId = std::move(AssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIStoreSubsystem.GetItemFromItemId
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ItemId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDIItem*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDIItem* UDIStoreSubsystem::GetItemFromItemId(const class FString& ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "GetItemFromItemId");

	Params::DIStoreSubsystem_GetItemFromItemId Parms{};

	Parms.ItemId = std::move(ItemId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIStoreSubsystem.GetTimeUntilRotation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           TimeLeft                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Ratio                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDIStoreSubsystem::GetTimeUntilRotation(class FString* TimeLeft, float* Ratio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "GetTimeUntilRotation");

	Params::DIStoreSubsystem_GetTimeUntilRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TimeLeft != nullptr)
		*TimeLeft = std::move(Parms.TimeLeft);

	if (Ratio != nullptr)
		*Ratio = Parms.Ratio;
}


// Function DeceiveInc.DIStoreSubsystem.GetXPBoosterActiveTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDIStoreSubsystem::GetXPBoosterActiveTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "GetXPBoosterActiveTime");

	Params::DIStoreSubsystem_GetXPBoosterActiveTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIStoreSubsystem.GetXPBoosterID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDIStoreSubsystem::GetXPBoosterID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "GetXPBoosterID");

	Params::DIStoreSubsystem_GetXPBoosterID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction DeceiveInc.DIStoreSubsystem.OnWalletUpdated__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FAccelByteModelsWalletInfo       WalletInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDIStoreSubsystem::OnWalletUpdated__DelegateSignature(const struct FAccelByteModelsWalletInfo& WalletInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "OnWalletUpdated__DelegateSignature");

	Params::DIStoreSubsystem_OnWalletUpdated__DelegateSignature Parms{};

	Parms.WalletInfo = std::move(WalletInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.DIStoreSubsystem.QueryWallet
// (Final, Native, Public, BlueprintCallable)

void UDIStoreSubsystem::QueryWallet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "QueryWallet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DIStoreSubsystem.CanPurchaseItemWithCurrency
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIItem*                          ItemToCheck                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDICurrencyItem*                  CurrencyType                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrencyAmount                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIStoreSubsystem::CanPurchaseItemWithCurrency(const class UDIItem* ItemToCheck, const class UDICurrencyItem* CurrencyType, int32 CurrencyAmount) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "CanPurchaseItemWithCurrency");

	Params::DIStoreSubsystem_CanPurchaseItemWithCurrency Parms{};

	Parms.ItemToCheck = ItemToCheck;
	Parms.CurrencyType = CurrencyType;
	Parms.CurrencyAmount = CurrencyAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIStoreSubsystem.CatalogueCanPurchaseItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIItem*                          ItemToCheck                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIStoreSubsystem::CatalogueCanPurchaseItem(const class UDIItem* ItemToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "CatalogueCanPurchaseItem");

	Params::DIStoreSubsystem_CatalogueCanPurchaseItem Parms{};

	Parms.ItemToCheck = ItemToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIStoreSubsystem.CatalogueCheckPageCompleted
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FStoreCatalogEntryPageData       PageToCheck                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   NbItemsUnlocked                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIStoreSubsystem::CatalogueCheckPageCompleted(const struct FStoreCatalogEntryPageData& PageToCheck, int32* NbItemsUnlocked) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "CatalogueCheckPageCompleted");

	Params::DIStoreSubsystem_CatalogueCheckPageCompleted Parms{};

	Parms.PageToCheck = std::move(PageToCheck);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NbItemsUnlocked != nullptr)
		*NbItemsUnlocked = Parms.NbItemsUnlocked;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIStoreSubsystem.CatalogueGetCurrentPage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStoreCatalogEntryData*           Catalogue                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDIStoreSubsystem::CatalogueGetCurrentPage(const class UStoreCatalogEntryData* Catalogue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "CatalogueGetCurrentPage");

	Params::DIStoreSubsystem_CatalogueGetCurrentPage Parms{};

	Parms.Catalogue = Catalogue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIStoreSubsystem.CatalogueIsCurrentSeason
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStoreCatalogEntryData*           Catalogue                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIStoreSubsystem::CatalogueIsCurrentSeason(const class UStoreCatalogEntryData* Catalogue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "CatalogueIsCurrentSeason");

	Params::DIStoreSubsystem_CatalogueIsCurrentSeason Parms{};

	Parms.Catalogue = Catalogue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIStoreSubsystem.GetBundleContainingItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIItem*                          ToFind                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDIItem*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDIItem* UDIStoreSubsystem::GetBundleContainingItem(const class UDIItem* ToFind) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "GetBundleContainingItem");

	Params::DIStoreSubsystem_GetBundleContainingItem Parms{};

	Parms.ToFind = ToFind;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIStoreSubsystem.GetCatalogForAgent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIItem*                          ItemToCheck                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStoreCatalogEntryData*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStoreCatalogEntryData* UDIStoreSubsystem::GetCatalogForAgent(const class UDIItem* ItemToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "GetCatalogForAgent");

	Params::DIStoreSubsystem_GetCatalogForAgent Parms{};

	Parms.ItemToCheck = ItemToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIStoreSubsystem.GetCatalogForItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIItem*                          ItemToCheck                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStoreCatalogEntryData*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStoreCatalogEntryData* UDIStoreSubsystem::GetCatalogForItem(const class UDIItem* ItemToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "GetCatalogForItem");

	Params::DIStoreSubsystem_GetCatalogForItem Parms{};

	Parms.ItemToCheck = ItemToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIStoreSubsystem.GetCatalogueCurrencyItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDICurrencyItem*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDICurrencyItem* UDIStoreSubsystem::GetCatalogueCurrencyItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "GetCatalogueCurrencyItem");

	Params::DIStoreSubsystem_GetCatalogueCurrencyItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIStoreSubsystem.GetCollectionIconForItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIItem*                          ItemToCheck                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UDIStoreSubsystem::GetCollectionIconForItem(const class UDIItem* ItemToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "GetCollectionIconForItem");

	Params::DIStoreSubsystem_GetCollectionIconForItem Parms{};

	Parms.ItemToCheck = ItemToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIStoreSubsystem.GetHardCurrencyItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDICurrencyItem*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDICurrencyItem* UDIStoreSubsystem::GetHardCurrencyItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "GetHardCurrencyItem");

	Params::DIStoreSubsystem_GetHardCurrencyItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIStoreSubsystem.GetItemCostForCurrency
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIItem*                          ItemToCheck                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDICurrencyItem*                  Currency                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDIStoreSubsystem::GetItemCostForCurrency(const class UDIItem* ItemToCheck, const class UDICurrencyItem* Currency) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "GetItemCostForCurrency");

	Params::DIStoreSubsystem_GetItemCostForCurrency Parms{};

	Parms.ItemToCheck = ItemToCheck;
	Parms.Currency = Currency;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIStoreSubsystem.GetItemFromItemIdNum
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDIItem*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDIItem* UDIStoreSubsystem::GetItemFromItemIdNum(const int32& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "GetItemFromItemIdNum");

	Params::DIStoreSubsystem_GetItemFromItemIdNum Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIStoreSubsystem.GetRebatePercentForItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIItem*                          ItemToCheck                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDIStoreSubsystem::GetRebatePercentForItem(const class UDIItem* ItemToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "GetRebatePercentForItem");

	Params::DIStoreSubsystem_GetRebatePercentForItem Parms{};

	Parms.ItemToCheck = ItemToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIStoreSubsystem.GetSoftCurrencyItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDICurrencyItem*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDICurrencyItem* UDIStoreSubsystem::GetSoftCurrencyItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "GetSoftCurrencyItem");

	Params::DIStoreSubsystem_GetSoftCurrencyItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DIStoreSubsystem.IsItemPurchasable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIItem*                          ItemToCheck                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDIStoreSubsystem::IsItemPurchasable(const class UDIItem* ItemToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DIStoreSubsystem", "IsItemPurchasable");

	Params::DIStoreSubsystem_IsItemPurchasable Parms{};

	Parms.ItemToCheck = ItemToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiUserSettingWidget.BP_OnCollapse
// (Event, Public, BlueprintEvent)

void UDiUserSettingWidget::BP_OnCollapse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserSettingWidget", "BP_OnCollapse");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.DiUserSettingWidget.BP_OnCollapseSubSettings
// (Event, Public, BlueprintEvent)

void UDiUserSettingWidget::BP_OnCollapseSubSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserSettingWidget", "BP_OnCollapseSubSettings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.DiUserSettingWidget.BP_OnExpand
// (Event, Public, BlueprintEvent)

void UDiUserSettingWidget::BP_OnExpand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserSettingWidget", "BP_OnExpand");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.DiUserSettingWidget.BP_OnExpandSubSettings
// (Event, Public, BlueprintEvent)

void UDiUserSettingWidget::BP_OnExpandSubSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserSettingWidget", "BP_OnExpandSubSettings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.DiUserSettingWidget.BP_OnRefresh
// (Event, Public, BlueprintEvent)

void UDiUserSettingWidget::BP_OnRefresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserSettingWidget", "BP_OnRefresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.DiUserSettingWidget.HandleSettingChange
// (Final, Native, Protected)
// Parameters:
// EPlayerSettingsType                     SettingChanged                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiUserSettingWidget::HandleSettingChange(EPlayerSettingsType SettingChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserSettingWidget", "HandleSettingChange");

	Params::DiUserSettingWidget_HandleSettingChange Parms{};

	Parms.SettingChanged = SettingChanged;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiUserSettingWidget.Refresh
// (Native, Public, BlueprintCallable)

void UDiUserSettingWidget::Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserSettingWidget", "Refresh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiUserSettingWidget.SetupForSetting
// (Native, Public, BlueprintCallable)
// Parameters:
// EPlayerSettingsType                     InSettingType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiUserSettingWidget::SetupForSetting(EPlayerSettingsType InSettingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserSettingWidget", "SetupForSetting");

	Params::DiUserSettingWidget_SetupForSetting Parms{};

	Parms.InSettingType = InSettingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiUserSettingWidget.GetDefaultVisibilityState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerSettingsDefaultState             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerSettingsDefaultState UDiUserSettingWidget::GetDefaultVisibilityState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserSettingWidget", "GetDefaultVisibilityState");

	Params::DiUserSettingWidget_GetDefaultVisibilityState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiUserSettingWidget.GetSettingShortDescription
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDiUserSettingWidget::GetSettingShortDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserSettingWidget", "GetSettingShortDescription");

	Params::DiUserSettingWidget_GetSettingShortDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiUserSettingWidget.GetSettingTooltipDecription
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDiUserSettingWidget::GetSettingTooltipDecription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserSettingWidget", "GetSettingTooltipDecription");

	Params::DiUserSettingWidget_GetSettingTooltipDecription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiUserSettingWidget.IsAdvancedSetting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiUserSettingWidget::IsAdvancedSetting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserSettingWidget", "IsAdvancedSetting");

	Params::DiUserSettingWidget_IsAdvancedSetting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiUserSettingWidget.IsAllowedPerAgentSetting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiUserSettingWidget::IsAllowedPerAgentSetting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserSettingWidget", "IsAllowedPerAgentSetting");

	Params::DiUserSettingWidget_IsAllowedPerAgentSetting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiUserSettingWidget.IsAllowedSubSetting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiUserSettingWidget::IsAllowedSubSetting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserSettingWidget", "IsAllowedSubSetting");

	Params::DiUserSettingWidget_IsAllowedSubSetting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiUserSettingWidget.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiUserSettingWidget::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserSettingWidget", "IsEnabled");

	Params::DiUserSettingWidget_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiUserSettingWidget.IsTooltipAvailable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiUserSettingWidget::IsTooltipAvailable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserSettingWidget", "IsTooltipAvailable");

	Params::DiUserSettingWidget_IsTooltipAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCBug.HandleCoverSwitch
// (Final, Native, Protected)
// Parameters:
// class ANPCCharacter*                    Disguise                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBug::HandleCoverSwitch(class ANPCCharacter* Disguise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBug", "HandleCoverSwitch");

	Params::NPCBug_HandleCoverSwitch Parms{};

	Parms.Disguise = Disguise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBug.HandleDeadActor
// (Final, Native, Protected)
// Parameters:
// class AActor*                           DeadActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBug::HandleDeadActor(class AActor* DeadActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBug", "HandleDeadActor");

	Params::NPCBug_HandleDeadActor Parms{};

	Parms.DeadActor = DeadActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBug.HandleNPCFellOffMap
// (Final, Native, Protected)
// Parameters:
// class ANPCCharacter*                    NPCCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBug::HandleNPCFellOffMap(class ANPCCharacter* NPCCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBug", "HandleNPCFellOffMap");

	Params::NPCBug_HandleNPCFellOffMap Parms{};

	Parms.NPCCharacter = NPCCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBug.HandleSpyLookAction
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   YawValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsSpyCameraMovementLock                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBug::HandleSpyLookAction(class ASpy* Spy, float YawValue, float PitchValue, bool bIsSpyCameraMovementLock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBug", "HandleSpyLookAction");

	Params::NPCBug_HandleSpyLookAction Parms{};

	Parms.Spy = Spy;
	Parms.YawValue = YawValue;
	Parms.PitchValue = PitchValue;
	Parms.bIsSpyCameraMovementLock = bIsSpyCameraMovementLock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBug.HandleSpyTransformInMimic
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseMimicScannableActor*         Mimic                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBug::HandleSpyTransformInMimic(class ASpy* Spy, class ABaseMimicScannableActor* Mimic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBug", "HandleSpyTransformInMimic");

	Params::NPCBug_HandleSpyTransformInMimic Parms{};

	Parms.Spy = Spy;
	Parms.Mimic = Mimic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBug.HandleSpyUndercoverChanged
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Undercover                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBug::HandleSpyUndercoverChanged(class ASpy* Spy, bool Undercover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBug", "HandleSpyUndercoverChanged");

	Params::NPCBug_HandleSpyUndercoverChanged Parms{};

	Parms.Spy = Spy;
	Parms.Undercover = Undercover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBug.NetMulticast_SetIsCameraActive
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// bool                                    bInIsCameraActive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBug::NetMulticast_SetIsCameraActive(bool bInIsCameraActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBug", "NetMulticast_SetIsCameraActive");

	Params::NPCBug_NetMulticast_SetIsCameraActive Parms{};

	Parms.bInIsCameraActive = bInIsCameraActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBug.NetMulticast_SetNewRotation
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// struct FRotator                         NewRotation                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ANPCBug::NetMulticast_SetNewRotation(const struct FRotator& NewRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBug", "NetMulticast_SetNewRotation");

	Params::NPCBug_NetMulticast_SetNewRotation Parms{};

	Parms.NewRotation = std::move(NewRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBug.OnFadeOutTimerEnd
// (Final, Native, Protected)

void ANPCBug::OnFadeOutTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBug", "OnFadeOutTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBug.OnRep_SpyVictim
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             OldSpy                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBug::OnRep_SpyVictim(class ASpy* OldSpy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBug", "OnRep_SpyVictim");

	Params::NPCBug_OnRep_SpyVictim Parms{};

	Parms.OldSpy = OldSpy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBug.OnRep_UseCamera3P
// (Final, Native, Protected)

void ANPCBug::OnRep_UseCamera3P()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBug", "OnRep_UseCamera3P");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBug.Server_SetIsCameraActive
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    bInIsCameraActive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBug::Server_SetIsCameraActive(bool bInIsCameraActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBug", "Server_SetIsCameraActive");

	Params::NPCBug_Server_SetIsCameraActive Parms{};

	Parms.bInIsCameraActive = bInIsCameraActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBug.Server_SetNewRotation
// (Net, NetReliable, Native, Event, Protected, NetServer, HasDefaults)
// Parameters:
// struct FRotator                         NewRotation                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ANPCBug::Server_SetNewRotation(const struct FRotator& NewRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBug", "Server_SetNewRotation");

	Params::NPCBug_Server_SetNewRotation Parms{};

	Parms.NewRotation = std::move(NewRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiUserBooleanSettingWidget.ApplyNewSettingValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewSettingValue                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiUserBooleanSettingWidget::ApplyNewSettingValue(bool bNewSettingValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserBooleanSettingWidget", "ApplyNewSettingValue");

	Params::DiUserBooleanSettingWidget_ApplyNewSettingValue Parms{};

	Parms.bNewSettingValue = bNewSettingValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiUserBooleanSettingWidget.GetSettingValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDiUserBooleanSettingWidget::GetSettingValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserBooleanSettingWidget", "GetSettingValue");

	Params::DiUserBooleanSettingWidget_GetSettingValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiUserIntegerSettingWidget.ApplyNewSettingValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewSettingValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiUserIntegerSettingWidget::ApplyNewSettingValue(int32 NewSettingValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserIntegerSettingWidget", "ApplyNewSettingValue");

	Params::DiUserIntegerSettingWidget_ApplyNewSettingValue Parms{};

	Parms.NewSettingValue = NewSettingValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiUserIntegerSettingWidget.GetSettingValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDiUserIntegerSettingWidget::GetSettingValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserIntegerSettingWidget", "GetSettingValue");

	Params::DiUserIntegerSettingWidget_GetSettingValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiUserFloatSettingWidget.ApplyNewSettingValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewSettingValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiUserFloatSettingWidget::ApplyNewSettingValue(float NewSettingValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserFloatSettingWidget", "ApplyNewSettingValue");

	Params::DiUserFloatSettingWidget_ApplyNewSettingValue Parms{};

	Parms.NewSettingValue = NewSettingValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiUserFloatSettingWidget.GetSettingValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDiUserFloatSettingWidget::GetSettingValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserFloatSettingWidget", "GetSettingValue");

	Params::DiUserFloatSettingWidget_GetSettingValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DiUserStringSettingWidget.ApplyNewSettingValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           NewSettingValue                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiUserStringSettingWidget::ApplyNewSettingValue(const class FString& NewSettingValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserStringSettingWidget", "ApplyNewSettingValue");

	Params::DiUserStringSettingWidget_ApplyNewSettingValue Parms{};

	Parms.NewSettingValue = std::move(NewSettingValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DiUserStringSettingWidget.GetSettingValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDiUserStringSettingWidget::GetSettingValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiUserStringSettingWidget", "GetSettingValue");

	Params::DiUserStringSettingWidget_GetSettingValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCInteractionComponent.GetInteractingNPC
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ANPCCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANPCCharacter* UNPCInteractionComponent::GetInteractingNPC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCInteractionComponent", "GetInteractingNPC");

	Params::NPCInteractionComponent_GetInteractingNPC Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCInteractionComponent.GetWatchingPlayerDisguiseAnimationLoop
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequence*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequence* UNPCInteractionComponent::GetWatchingPlayerDisguiseAnimationLoop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCInteractionComponent", "GetWatchingPlayerDisguiseAnimationLoop");

	Params::NPCInteractionComponent_GetWatchingPlayerDisguiseAnimationLoop Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCInteractionComponent.HandleDisableBySpawned
// (Final, Native, Protected)

void UNPCInteractionComponent::HandleDisableBySpawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCInteractionComponent", "HandleDisableBySpawned");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCInteractionComponent.OnMimicPositioned
// (Final, Native, Protected)

void UNPCInteractionComponent::OnMimicPositioned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCInteractionComponent", "OnMimicPositioned");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCInteractionComponent.OnMimicVisibilityChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisibleIn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCInteractionComponent::OnMimicVisibilityChange(bool bVisibleIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCInteractionComponent", "OnMimicVisibilityChange");

	Params::NPCInteractionComponent_OnMimicVisibilityChange Parms{};

	Parms.bVisibleIn = bVisibleIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCInteractionComponent.OnPlayerInteractComplete
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             InteracterIn                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           InteractableIn                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCInteractionComponent::OnPlayerInteractComplete(class UInteracterComponent* InteracterIn, class UInteractableComponent* InteractableIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCInteractionComponent", "OnPlayerInteractComplete");

	Params::NPCInteractionComponent_OnPlayerInteractComplete Parms{};

	Parms.InteracterIn = InteracterIn;
	Parms.InteractableIn = InteractableIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCInteractionComponent.OnPostInitRooms
// (Final, Native, Protected)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCInteractionComponent::OnPostInitRooms(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCInteractionComponent", "OnPostInitRooms");

	Params::NPCInteractionComponent_OnPostInitRooms Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCConversationComponent.OnRep_TalkingNPC
// (Final, Native, Protected)
// Parameters:
// class ANPCCharacter*                    PrevNPC                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCConversationComponent::OnRep_TalkingNPC(class ANPCCharacter* PrevNPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCConversationComponent", "OnRep_TalkingNPC");

	Params::NPCConversationComponent_OnRep_TalkingNPC Parms{};

	Parms.PrevNPC = PrevNPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCConversationComponent.OnTalkingTimerEnd
// (Final, Native, Protected)

void UNPCConversationComponent::OnTalkingTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCConversationComponent", "OnTalkingTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ObjectSpawnComponent.OnRep_SpawnedObject
// (Final, Native, Public)

void UObjectSpawnComponent::OnRep_SpawnedObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectSpawnComponent", "OnRep_SpawnedObject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ObjectSpawnComponent.UpdateConnectedRoomsReference
// (Final, Native, Public)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectSpawnComponent::UpdateConnectedRoomsReference(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectSpawnComponent", "UpdateConnectedRoomsReference");

	Params::ObjectSpawnComponent_UpdateConnectedRoomsReference Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ObjectSpawnComponent.GetSpawnedObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UObjectSpawnComponent::GetSpawnedObject() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectSpawnComponent", "GetSpawnedObject");

	Params::ObjectSpawnComponent_GetSpawnedObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DoubleContainerActor.BP_OnSecondaryContainerClosing
// (Event, Protected, BlueprintEvent)

void ADoubleContainerActor::BP_OnSecondaryContainerClosing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DoubleContainerActor", "BP_OnSecondaryContainerClosing");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.DoubleContainerActor.BP_OnSecondaryContainerOpening
// (Event, Protected, BlueprintEvent)

void ADoubleContainerActor::BP_OnSecondaryContainerOpening()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DoubleContainerActor", "BP_OnSecondaryContainerOpening");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.DoubleContainerActor.HandleSecondaryInteractionComplete
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoubleContainerActor::HandleSecondaryInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DoubleContainerActor", "HandleSecondaryInteractionComplete");

	Params::DoubleContainerActor_HandleSecondaryInteractionComplete Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DoubleContainerActor.OnRep_SecondaryContainerState
// (Final, Native, Protected)
// Parameters:
// EContainerState                         PreviousState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoubleContainerActor::OnRep_SecondaryContainerState(EContainerState PreviousState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DoubleContainerActor", "OnRep_SecondaryContainerState");

	Params::DoubleContainerActor_OnRep_SecondaryContainerState Parms{};

	Parms.PreviousState = PreviousState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DoubleContainerActor.OnTimeToEnableSecondaryInteract
// (Final, Native, Protected)

void ADoubleContainerActor::OnTimeToEnableSecondaryInteract()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DoubleContainerActor", "OnTimeToEnableSecondaryInteract");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCMovementComponent.NotifyAnimationStateJumpInChange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bJumpInStart                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCMovementComponent::NotifyAnimationStateJumpInChange(bool bJumpInStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCMovementComponent", "NotifyAnimationStateJumpInChange");

	Params::NPCMovementComponent_NotifyAnimationStateJumpInChange Parms{};

	Parms.bJumpInStart = bJumpInStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCMovementComponent.OnCollisionBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UNPCMovementComponent::OnCollisionBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCMovementComponent", "OnCollisionBeginOverlap");

	Params::NPCMovementComponent_OnCollisionBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCMovementComponent.OnCollisionEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCMovementComponent::OnCollisionEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCMovementComponent", "OnCollisionEndOverlap");

	Params::NPCMovementComponent_OnCollisionEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCMovementComponent.SetJumpInAnimationSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    JumpInAnim                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCMovementComponent::SetJumpInAnimationSequence(class UAnimSequence* JumpInAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCMovementComponent", "SetJumpInAnimationSequence");

	Params::NPCMovementComponent_SetJumpInAnimationSequence Parms{};

	Parms.JumpInAnim = JumpInAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.DestroyDrone
// (Final, Native, Public, BlueprintCallable)

void ADrone::DestroyDrone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "DestroyDrone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.GetFactionId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ADrone::GetFactionId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "GetFactionId");

	Params::Drone_GetFactionId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Drone.HandleBooleanPlayerSettingChange
// (Final, Native, Public)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADrone::HandleBooleanPlayerSettingChange(EPlayerSettingsType SettingType, bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "HandleBooleanPlayerSettingChange");

	Params::Drone_HandleBooleanPlayerSettingChange Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.HandleDeath
// (Final, Native, Protected)
// Parameters:
// class AActor*                           DeadActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADrone::HandleDeath(class AActor* DeadActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "HandleDeath");

	Params::Drone_HandleDeath Parms{};

	Parms.DeadActor = DeadActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.HandleEMPIsAffectedChanged
// (Final, Native, Public)
// Parameters:
// bool                                    bIsAffected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AffectedActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADrone::HandleEMPIsAffectedChanged(bool bIsAffected, class AActor* AffectedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "HandleEMPIsAffectedChanged");

	Params::Drone_HandleEMPIsAffectedChanged Parms{};

	Parms.bIsAffected = bIsAffected;
	Parms.AffectedActor = AffectedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.HandleFloatPlayerSettingChange
// (Final, Native, Public)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADrone::HandleFloatPlayerSettingChange(EPlayerSettingsType SettingType, float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "HandleFloatPlayerSettingChange");

	Params::Drone_HandleFloatPlayerSettingChange Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.HandleInteractionCompleted
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADrone::HandleInteractionCompleted(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "HandleInteractionCompleted");

	Params::Drone_HandleInteractionCompleted Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.HandleIntPlayerSettingChange
// (Final, Native, Public)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADrone::HandleIntPlayerSettingChange(EPlayerSettingsType SettingType, int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "HandleIntPlayerSettingChange");

	Params::Drone_HandleIntPlayerSettingChange Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.HandleRecycleTimerEnd
// (Final, Native, Public)

void ADrone::HandleRecycleTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "HandleRecycleTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.HandleScramblerIsAffectedChanged
// (Final, Native, Public)
// Parameters:
// bool                                    bIsAffected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AffectedActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADrone::HandleScramblerIsAffectedChanged(bool bIsAffected, class AActor* AffectedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "HandleScramblerIsAffectedChanged");

	Params::Drone_HandleScramblerIsAffectedChanged Parms{};

	Parms.bIsAffected = bIsAffected;
	Parms.AffectedActor = AffectedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.LocalReleaseControl
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// class ASpy*                             OriginalSpy                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADrone::LocalReleaseControl(class ASpy* OriginalSpy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "LocalReleaseControl");

	Params::Drone_LocalReleaseControl Parms{};

	Parms.OriginalSpy = OriginalSpy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.LocalTakeControl
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// class ASpy*                             OriginalSpy                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADrone::LocalTakeControl(class ASpy* OriginalSpy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "LocalTakeControl");

	Params::Drone_LocalTakeControl Parms{};

	Parms.OriginalSpy = OriginalSpy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.MulticastDestroy
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ADrone::MulticastDestroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "MulticastDestroy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.MulticastReleaseControl
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AController*                      Possesor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADrone::MulticastReleaseControl(class AController* Possesor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "MulticastReleaseControl");

	Params::Drone_MulticastReleaseControl Parms{};

	Parms.Possesor = Possesor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.MulticastTakeControl
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AController*                      Possesor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADrone::MulticastTakeControl(class AController* Possesor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "MulticastTakeControl");

	Params::Drone_MulticastTakeControl Parms{};

	Parms.Possesor = Possesor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.NetMulticast_OnDroneDeath
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ADrone::NetMulticast_OnDroneDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "NetMulticast_OnDroneDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.OnRep_FlyingSpeed
// (Final, Native, Protected)

void ADrone::OnRep_FlyingSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "OnRep_FlyingSpeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.OnRep_OriginalBody
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             OldValue                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADrone::OnRep_OriginalBody(class ASpy* OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "OnRep_OriginalBody");

	Params::Drone_OnRep_OriginalBody Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.OnRep_Spawner
// (Final, Native, Protected)
// Parameters:
// class ADroneSpawnerWeapon*              OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADrone::OnRep_Spawner(class ADroneSpawnerWeapon* OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "OnRep_Spawner");

	Params::Drone_OnRep_Spawner Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.OnRep_Weapon
// (Final, Native, Protected)
// Parameters:
// class ADroneSpawnerWeapon*              OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADrone::OnRep_Weapon(class ADroneSpawnerWeapon* OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "OnRep_Weapon");

	Params::Drone_OnRep_Weapon Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.RecycleServer
// (Net, NetReliable, Native, Event, Protected, NetServer)

void ADrone::RecycleServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "RecycleServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.ReleaseControl
// (Final, Native, Public, BlueprintCallable)

void ADrone::ReleaseControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "ReleaseControl");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.Server_SpawnPing
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// struct FVector_NetQuantize              Position                                               (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUrgent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RadialPingIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADrone::Server_SpawnPing(const struct FVector_NetQuantize& Position, class AActor* TargetActor, bool bUrgent, int32 RadialPingIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "Server_SpawnPing");

	Params::Drone_Server_SpawnPing Parms{};

	Parms.Position = std::move(Position);
	Parms.TargetActor = TargetActor;
	Parms.bUrgent = bUrgent;
	Parms.RadialPingIndex = RadialPingIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.ServerDestroyDrone
// (Net, NetReliable, Native, Event, Protected, NetServer)

void ADrone::ServerDestroyDrone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "ServerDestroyDrone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.ServerReleaseControl
// (Net, NetReliable, Native, Event, Protected, NetServer)

void ADrone::ServerReleaseControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "ServerReleaseControl");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Drone.ServerUpdateSpeed
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    bIsSpeeding                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADrone::ServerUpdateSpeed(bool bIsSpeeding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Drone", "ServerUpdateSpeed");

	Params::Drone_ServerUpdateSpeed Parms{};

	Parms.bIsSpeeding = bIsSpeeding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DroneSpawnerWeapon.GetDartCooldownRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADroneSpawnerWeapon::GetDartCooldownRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroneSpawnerWeapon", "GetDartCooldownRatio");

	Params::DroneSpawnerWeapon_GetDartCooldownRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.DroneSpawnerWeapon.HandleDartCooldownChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bOnCooldown                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADroneSpawnerWeapon::HandleDartCooldownChange(bool bOnCooldown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroneSpawnerWeapon", "HandleDartCooldownChange");

	Params::DroneSpawnerWeapon_HandleDartCooldownChange Parms{};

	Parms.bOnCooldown = bOnCooldown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DroneSpawnerWeapon.HandleDroneCooldownChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bOnCooldown                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADroneSpawnerWeapon::HandleDroneCooldownChange(bool bOnCooldown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroneSpawnerWeapon", "HandleDroneCooldownChange");

	Params::DroneSpawnerWeapon_HandleDroneCooldownChange Parms{};

	Parms.bOnCooldown = bOnCooldown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DroneSpawnerWeapon.HandleRecycleTimerEnd
// (Native, Protected)

void ADroneSpawnerWeapon::HandleRecycleTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroneSpawnerWeapon", "HandleRecycleTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DroneSpawnerWeapon.HandleResourceChanged
// (Final, Native, Protected)
// Parameters:
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ResourceDisplayName                                    (Parm, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADroneSpawnerWeapon::HandleResourceChanged(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroneSpawnerWeapon", "HandleResourceChanged");

	Params::DroneSpawnerWeapon_HandleResourceChanged Parms{};

	Parms.ResourceType = ResourceType;
	Parms.ResourceDisplayName = std::move(ResourceDisplayName);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DroneSpawnerWeapon.OnRep_NewSpawnedDrone
// (Final, Native, Protected)

void ADroneSpawnerWeapon::OnRep_NewSpawnedDrone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroneSpawnerWeapon", "OnRep_NewSpawnedDrone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DroneSpawnerWeapon.RecycleServer
// (Net, NetReliable, Native, Event, Protected, NetServer)

void ADroneSpawnerWeapon::RecycleServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroneSpawnerWeapon", "RecycleServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DroneSpawnerWeapon.ServerDestroyDrone
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    bDestroyed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADroneSpawnerWeapon::ServerDestroyDrone(bool bDestroyed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroneSpawnerWeapon", "ServerDestroyDrone");

	Params::DroneSpawnerWeapon_ServerDestroyDrone Parms{};

	Parms.bDestroyed = bDestroyed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DroneSpawnerWeapon.ServerSpawnDrone
// (Net, NetReliable, Native, Event, Protected, NetServer)

void ADroneSpawnerWeapon::ServerSpawnDrone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroneSpawnerWeapon", "ServerSpawnDrone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.DroneSpawnerWeapon.ServerStartDroneRegen
// (Net, NetReliable, Native, Event, Protected, NetServer)

void ADroneSpawnerWeapon::ServerStartDroneRegen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroneSpawnerWeapon", "ServerStartDroneRegen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ExtractionInteractableActor.BP_ExfilDisable
// (Event, Public, BlueprintEvent)

void AExtractionInteractableActor::BP_ExfilDisable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionInteractableActor", "BP_ExfilDisable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.ExtractionInteractableActor.BP_ExfilInitialize
// (Event, Public, BlueprintEvent)

void AExtractionInteractableActor::BP_ExfilInitialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionInteractableActor", "BP_ExfilInitialize");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.ExtractionInteractableActor.BP_PlayerExtractedServer
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AExtractionInteractableActor::BP_PlayerExtractedServer(class AActor* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionInteractableActor", "BP_PlayerExtractedServer");

	Params::ExtractionInteractableActor_BP_PlayerExtractedServer Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.ExtractionInteractableActor.BP_RequestLeave
// (Event, Public, BlueprintEvent)

void AExtractionInteractableActor::BP_RequestLeave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionInteractableActor", "BP_RequestLeave");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.ExtractionInteractableActor.GetExtractionRatio
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AExtractionInteractableActor::GetExtractionRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionInteractableActor", "GetExtractionRatio");

	Params::ExtractionInteractableActor_GetExtractionRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ExtractionInteractableActor.HandleComponentOverlapEnd
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AExtractionInteractableActor::HandleComponentOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionInteractableActor", "HandleComponentOverlapEnd");

	Params::ExtractionInteractableActor_HandleComponentOverlapEnd Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ExtractionInteractableActor.HandleComponentOverlapStart
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AExtractionInteractableActor::HandleComponentOverlapStart(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionInteractableActor", "HandleComponentOverlapStart");

	Params::ExtractionInteractableActor_HandleComponentOverlapStart Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ExtractionInteractableActor.HandleExfilArrivedEvent
// (Final, Native, Protected)
// Parameters:
// class UExtractionArrivedPhaseInfo*      PhaseInfo                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AExtractionInteractableActor::HandleExfilArrivedEvent(class UExtractionArrivedPhaseInfo* PhaseInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionInteractableActor", "HandleExfilArrivedEvent");

	Params::ExtractionInteractableActor_HandleExfilArrivedEvent Parms{};

	Parms.PhaseInfo = PhaseInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ExtractionInteractableActor.HandleExfilArrivingEvent
// (Final, Native, Protected)
// Parameters:
// class UExtractionArrivingPhaseInfo*     PhaseInfo                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AExtractionInteractableActor::HandleExfilArrivingEvent(class UExtractionArrivingPhaseInfo* PhaseInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionInteractableActor", "HandleExfilArrivingEvent");

	Params::ExtractionInteractableActor_HandleExfilArrivingEvent Parms{};

	Parms.PhaseInfo = PhaseInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ExtractionInteractableActor.HandleExfilMovedEvent
// (Final, Native, Protected)

void AExtractionInteractableActor::HandleExfilMovedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionInteractableActor", "HandleExfilMovedEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ExtractionInteractableActor.HandleGamePhaseTick
// (Final, Native, Protected)
// Parameters:
// int32                                   RemainingTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AExtractionInteractableActor::HandleGamePhaseTick(int32 RemainingTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionInteractableActor", "HandleGamePhaseTick");

	Params::ExtractionInteractableActor_HandleGamePhaseTick Parms{};

	Parms.RemainingTime = RemainingTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ExtractionInteractableActor.HandleObjectiveDropped
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             Carrier                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AExtractionInteractableActor::HandleObjectiveDropped(class ASpy* Carrier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionInteractableActor", "HandleObjectiveDropped");

	Params::ExtractionInteractableActor_HandleObjectiveDropped Parms{};

	Parms.Carrier = Carrier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ExtractionInteractableActor.HandleObjectivePickedUp
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             Carrier                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AExtractionInteractableActor::HandleObjectivePickedUp(class ASpy* Carrier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionInteractableActor", "HandleObjectivePickedUp");

	Params::ExtractionInteractableActor_HandleObjectivePickedUp Parms{};

	Parms.Carrier = Carrier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ExtractionInteractableActor.HandleRequestLeave
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void AExtractionInteractableActor::HandleRequestLeave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionInteractableActor", "HandleRequestLeave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ExtractionInteractableActor.OnExfilArrived
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void AExtractionInteractableActor::OnExfilArrived()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionInteractableActor", "OnExfilArrived");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ExtractionInteractableActor.OnExfilArriving
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void AExtractionInteractableActor::OnExfilArriving()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionInteractableActor", "OnExfilArriving");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ExtractionInteractableActor.OnExfilDisable
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void AExtractionInteractableActor::OnExfilDisable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionInteractableActor", "OnExfilDisable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ExtractionInteractableActor.OnExfilInitialize
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// bool                                    bArriveNow                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AExtractionInteractableActor::OnExfilInitialize(bool bArriveNow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionInteractableActor", "OnExfilInitialize");

	Params::ExtractionInteractableActor_OnExfilInitialize Parms{};

	Parms.bArriveNow = bArriveNow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ExtractionInteractableActor.OnRep_CarrierInZone
// (Final, Native, Protected)

void AExtractionInteractableActor::OnRep_CarrierInZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionInteractableActor", "OnRep_CarrierInZone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ExtractionInteractableActor.OnRep_ExtractBlocked
// (Final, Native, Protected)

void AExtractionInteractableActor::OnRep_ExtractBlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionInteractableActor", "OnRep_ExtractBlocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ExtractionInteractableActor.OnRep_ExtractionActorReplicatedState
// (Final, Native, Protected)
// Parameters:
// EExtractionActorReplicatedState         PrevState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AExtractionInteractableActor::OnRep_ExtractionActorReplicatedState(EExtractionActorReplicatedState PrevState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExtractionInteractableActor", "OnRep_ExtractionActorReplicatedState");

	Params::ExtractionInteractableActor_OnRep_ExtractionActorReplicatedState Parms{};

	Parms.PrevState = PrevState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GameplayBotBrain.OnBriefcaseDropped
// (Final, Native, Protected)

void UGameplayBotBrain::OnBriefcaseDropped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayBotBrain", "OnBriefcaseDropped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GameplayBotBrain.OnDoNotAggroOtherBotsTimerEnd
// (Final, Native, Protected)

void UGameplayBotBrain::OnDoNotAggroOtherBotsTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayBotBrain", "OnDoNotAggroOtherBotsTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GameplayBotBrain.OnFightTargetLost
// (Final, Native, Protected)
// Parameters:
// class UBotPlanFight*                    BotPlanFight                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             LostTarget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayBotBrain::OnFightTargetLost(class UBotPlanFight* BotPlanFight, class ASpy* LostTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayBotBrain", "OnFightTargetLost");

	Params::GameplayBotBrain_OnFightTargetLost Parms{};

	Parms.BotPlanFight = BotPlanFight;
	Parms.LostTarget = LostTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GameplayBotBrain.OnGamePhaseChanged
// (Final, Native, Protected)
// Parameters:
// ESpyGamePhase                           NewGamePhase                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayBotBrain::OnGamePhaseChanged(ESpyGamePhase NewGamePhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayBotBrain", "OnGamePhaseChanged");

	Params::GameplayBotBrain_OnGamePhaseChanged Parms{};

	Parms.NewGamePhase = NewGamePhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GameplayBotBrain.OnHealthChanged
// (Final, Native, Protected)
// Parameters:
// class UHealthComponent*                 OwningHealthComp                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Health                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HealthDelta                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RawDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayBotBrain::OnHealthChanged(class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, float RawDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayBotBrain", "OnHealthChanged");

	Params::GameplayBotBrain_OnHealthChanged Parms{};

	Parms.OwningHealthComp = OwningHealthComp;
	Parms.Health = Health;
	Parms.HealthDelta = HealthDelta;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.RawDamage = RawDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GameplayBotBrain.OnLingeringExtractingSpyTimerEnd
// (Final, Native, Protected)

void UGameplayBotBrain::OnLingeringExtractingSpyTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayBotBrain", "OnLingeringExtractingSpyTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GameplayBotBrain.OnPanicCooldownTimerEnd
// (Final, Native, Protected)

void UGameplayBotBrain::OnPanicCooldownTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayBotBrain", "OnPanicCooldownTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GameplayBotBrain.OnRefreshGoalTimerEnd
// (Final, Native, Protected)

void UGameplayBotBrain::OnRefreshGoalTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayBotBrain", "OnRefreshGoalTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GameplayBotBrain.OnResourceChange
// (Final, Native, Protected)
// Parameters:
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ResourceDisplayName                                    (Parm, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayBotBrain::OnResourceChange(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayBotBrain", "OnResourceChange");

	Params::GameplayBotBrain_OnResourceChange Parms{};

	Parms.ResourceType = ResourceType;
	Parms.ResourceDisplayName = std::move(ResourceDisplayName);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GameplayBotBrain.OnSpyExtractingChange
// (Final, Native, Protected)
// Parameters:
// class AExtractionInteractableActor*     ExtractPointIn                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             ExtractingSpyIn                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExtractingIn                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayBotBrain::OnSpyExtractingChange(class AExtractionInteractableActor* ExtractPointIn, class ASpy* ExtractingSpyIn, bool bExtractingIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayBotBrain", "OnSpyExtractingChange");

	Params::GameplayBotBrain_OnSpyExtractingChange Parms{};

	Parms.ExtractPointIn = ExtractPointIn;
	Parms.ExtractingSpyIn = ExtractingSpyIn;
	Parms.bExtractingIn = bExtractingIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GameplayBotBrain.OnStallProgressTimerEnd
// (Final, Native, Protected)

void UGameplayBotBrain::OnStallProgressTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayBotBrain", "OnStallProgressTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GameplayBotBrain.OnUndercoverChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bUndercover                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayBotBrain::OnUndercoverChange(bool bUndercover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayBotBrain", "OnUndercoverChange");

	Params::GameplayBotBrain_OnUndercoverChange Parms{};

	Parms.bUndercover = bUndercover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GameplayBotBrain.OnVaultTerminalUnlockedCountChange
// (Final, Native, Protected)
// Parameters:
// int32                                   VaultTerminalUnlockedCount                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayBotBrain::OnVaultTerminalUnlockedCountChange(int32 VaultTerminalUnlockedCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayBotBrain", "OnVaultTerminalUnlockedCountChange");

	Params::GameplayBotBrain_OnVaultTerminalUnlockedCountChange Parms{};

	Parms.VaultTerminalUnlockedCount = VaultTerminalUnlockedCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GameplayEventBus.FireOnNPCKilledEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANPCCharacter*                    NPC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayEventBus::FireOnNPCKilledEvent(class ASpy* Spy, class ANPCCharacter* NPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayEventBus", "FireOnNPCKilledEvent");

	Params::GameplayEventBus_FireOnNPCKilledEvent Parms{};

	Parms.Spy = Spy;
	Parms.NPC = NPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GameplayEventBus.FireOnSpyHeatChanged
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewHeatValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HeatDelta                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayEventBus::FireOnSpyHeatChanged(class ASpy* Spy, int32 NewHeatValue, int32 HeatDelta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayEventBus", "FireOnSpyHeatChanged");

	Params::GameplayEventBus_FireOnSpyHeatChanged Parms{};

	Parms.Spy = Spy;
	Parms.NewHeatValue = NewHeatValue;
	Parms.HeatDelta = HeatDelta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction DeceiveInc.GameplayEventBus.GameplayEventDelegate_CoverChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANPCCharacter*                    NewCover                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayEventBus::GameplayEventDelegate_CoverChanged__DelegateSignature(class ASpy* Spy, class ANPCCharacter* NewCover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayEventBus", "GameplayEventDelegate_CoverChanged__DelegateSignature");

	Params::GameplayEventBus_GameplayEventDelegate_CoverChanged__DelegateSignature Parms{};

	Parms.Spy = Spy;
	Parms.NewCover = NewCover;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.GameplayEventBus.GameplayEventDelegate_GamePhaseChange__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// ESpyGamePhase                           NewPhase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADeceiveIncMatchGameState*        GameState                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayEventBus::GameplayEventDelegate_GamePhaseChange__DelegateSignature(ESpyGamePhase NewPhase, const class ADeceiveIncMatchGameState* GameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayEventBus", "GameplayEventDelegate_GamePhaseChange__DelegateSignature");

	Params::GameplayEventBus_GameplayEventDelegate_GamePhaseChange__DelegateSignature Parms{};

	Parms.NewPhase = NewPhase;
	Parms.GameState = GameState;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.GameplayEventBus.GameplayEventDelegate_HealthSpecific__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UHealthComponent*                 OwningHealthComp                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Health                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HealthDelta                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayEventBus::GameplayEventDelegate_HealthSpecific__DelegateSignature(class ASpy* Spy, class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayEventBus", "GameplayEventDelegate_HealthSpecific__DelegateSignature");

	Params::GameplayEventBus_GameplayEventDelegate_HealthSpecific__DelegateSignature Parms{};

	Parms.Spy = Spy;
	Parms.OwningHealthComp = OwningHealthComp;
	Parms.Health = Health;
	Parms.HealthDelta = HealthDelta;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.GameplayEventBus.GameplayEventDelegate_NewPlayerState__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADIPlayerState*                   PlayerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayEventBus::GameplayEventDelegate_NewPlayerState__DelegateSignature(class ADIPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayEventBus", "GameplayEventDelegate_NewPlayerState__DelegateSignature");

	Params::GameplayEventBus_GameplayEventDelegate_NewPlayerState__DelegateSignature Parms{};

	Parms.PlayerState = PlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.GameplayEventBus.GameplayEventDelegate_SpyHeatChange__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewHeatValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HeatDelta                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayEventBus::GameplayEventDelegate_SpyHeatChange__DelegateSignature(class ASpy* Spy, int32 NewHeatValue, int32 HeatDelta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayEventBus", "GameplayEventDelegate_SpyHeatChange__DelegateSignature");

	Params::GameplayEventBus_GameplayEventDelegate_SpyHeatChange__DelegateSignature Parms{};

	Parms.Spy = Spy;
	Parms.NewHeatValue = NewHeatValue;
	Parms.HeatDelta = HeatDelta;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.GameplayEventBus.GameplayEventDelegate_SpySecuritySpecific__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpySecurityState                       PreviousState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpySecurityState                       NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayEventBus::GameplayEventDelegate_SpySecuritySpecific__DelegateSignature(class ASpy* Spy, ESpySecurityState PreviousState, ESpySecurityState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayEventBus", "GameplayEventDelegate_SpySecuritySpecific__DelegateSignature");

	Params::GameplayEventBus_GameplayEventDelegate_SpySecuritySpecific__DelegateSignature Parms{};

	Parms.Spy = Spy;
	Parms.PreviousState = PreviousState;
	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.GameplayEventBus.GameplayEventDelegate_SpySpecific__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayEventBus::GameplayEventDelegate_SpySpecific__DelegateSignature(class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayEventBus", "GameplayEventDelegate_SpySpecific__DelegateSignature");

	Params::GameplayEventBus_GameplayEventDelegate_SpySpecific__DelegateSignature Parms{};

	Parms.Spy = Spy;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.GameplayEventBus.GameplayEventDelegate_SpyVictimEffect__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVictimEffect*                    VictimEffect                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayEventBus::GameplayEventDelegate_SpyVictimEffect__DelegateSignature(class ASpy* Spy, class AVictimEffect* VictimEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayEventBus", "GameplayEventDelegate_SpyVictimEffect__DelegateSignature");

	Params::GameplayEventBus_GameplayEventDelegate_SpyVictimEffect__DelegateSignature Parms{};

	Parms.Spy = Spy;
	Parms.VictimEffect = VictimEffect;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.GlobalEBusSubsystem.SignalBlueprintEbusStringEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           StringEvent                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGlobalEBusSubsystem::SignalBlueprintEbusStringEvent(const class FString& StringEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlobalEBusSubsystem", "SignalBlueprintEbusStringEvent");

	Params::GlobalEBusSubsystem_SignalBlueprintEbusStringEvent Parms{};

	Parms.StringEvent = std::move(StringEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GlobalEBusSubsystem.SignalLoadingScreenEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           LoadingEvent                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGlobalEBusSubsystem::SignalLoadingScreenEvent(const class FString& LoadingEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlobalEBusSubsystem", "SignalLoadingScreenEvent");

	Params::GlobalEBusSubsystem_SignalLoadingScreenEvent Parms{};

	Parms.LoadingEvent = std::move(LoadingEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.GooPodTool.Server_ToggleGoo
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    bIsActiveIn                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGooPodTool::Server_ToggleGoo(bool bIsActiveIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GooPodTool", "Server_ToggleGoo");

	Params::GooPodTool_Server_ToggleGoo Parms{};

	Parms.bIsActiveIn = bIsActiveIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HackTrapScannableComponent.BP_OnIsTrappedChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsTrapped                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHackTrapScannableComponent::BP_OnIsTrappedChanged(bool bIsTrapped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HackTrapScannableComponent", "BP_OnIsTrappedChanged");

	Params::HackTrapScannableComponent_BP_OnIsTrappedChanged Parms{};

	Parms.bIsTrapped = bIsTrapped;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.HackTrapScannableComponent.HandleInteractionComplete
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHackTrapScannableComponent::HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HackTrapScannableComponent", "HandleInteractionComplete");

	Params::HackTrapScannableComponent_HandleInteractionComplete Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HackTrapScannableComponent.HandleResourceSpent
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHackTrapScannableComponent::HandleResourceSpent(class UInteracterComponent* Interacter, EGameplayResourcesType ResourceType, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HackTrapScannableComponent", "HandleResourceSpent");

	Params::HackTrapScannableComponent_HandleResourceSpent Parms{};

	Parms.Interacter = Interacter;
	Parms.ResourceType = ResourceType;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HackTrapScannableComponent.HandleSpyToolLoadComplete
// (Final, Native, Protected)
// Parameters:
// class UToolLoadoutComponent*            ToolLoadout                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHackTrapScannableComponent::HandleSpyToolLoadComplete(class UToolLoadoutComponent* ToolLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HackTrapScannableComponent", "HandleSpyToolLoadComplete");

	Params::HackTrapScannableComponent_HandleSpyToolLoadComplete Parms{};

	Parms.ToolLoadout = ToolLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HackTrapScannableComponent.IsTrappedByEnnemyFaction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHackTrapScannableComponent::IsTrappedByEnnemyFaction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HackTrapScannableComponent", "IsTrappedByEnnemyFaction");

	Params::HackTrapScannableComponent_IsTrappedByEnnemyFaction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.HackTrapScannableComponent.NetMulticast_IsDeviceTrappedChanged
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// bool                                    bIsTrapped                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHackTrapScannerTool*             HackTrapScanner                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Interacter                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHackTrapScannableComponent::NetMulticast_IsDeviceTrappedChanged(bool bIsTrapped, class AHackTrapScannerTool* HackTrapScanner, class AActor* Interacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HackTrapScannableComponent", "NetMulticast_IsDeviceTrappedChanged");

	Params::HackTrapScannableComponent_NetMulticast_IsDeviceTrappedChanged Parms{};

	Parms.bIsTrapped = bIsTrapped;
	Parms.HackTrapScanner = HackTrapScanner;
	Parms.Interacter = Interacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HackTrapScannableComponent.OnRep_FactionScramblingDevice
// (Final, Native, Protected, HasOutParams)
// Parameters:
// TArray<int32>                           OldFactionScramblingDevice                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UHackTrapScannableComponent::OnRep_FactionScramblingDevice(const TArray<int32>& OldFactionScramblingDevice)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HackTrapScannableComponent", "OnRep_FactionScramblingDevice");

	Params::HackTrapScannableComponent_OnRep_FactionScramblingDevice Parms{};

	Parms.OldFactionScramblingDevice = std::move(OldFactionScramblingDevice);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HackTrapScannableComponent.OnRep_FactionTrappingDevice
// (Final, Native, Protected, HasOutParams)
// Parameters:
// TArray<int32>                           OldFactionTrappingDevice                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UHackTrapScannableComponent::OnRep_FactionTrappingDevice(const TArray<int32>& OldFactionTrappingDevice)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HackTrapScannableComponent", "OnRep_FactionTrappingDevice");

	Params::HackTrapScannableComponent_OnRep_FactionTrappingDevice Parms{};

	Parms.OldFactionTrappingDevice = std::move(OldFactionTrappingDevice);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HansActiveAbility.BP_OnHansActiveProjectileHit
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactPoint                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactNormal                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHansActiveAbility::BP_OnHansActiveProjectileHit(class AActor* Victim, const struct FVector& ImpactPoint, const struct FVector& ImpactNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansActiveAbility", "BP_OnHansActiveProjectileHit");

	Params::HansActiveAbility_BP_OnHansActiveProjectileHit Parms{};

	Parms.Victim = Victim;
	Parms.ImpactPoint = std::move(ImpactPoint);
	Parms.ImpactNormal = std::move(ImpactNormal);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.HansActiveAbility.BP_OnLocalHansActiveEnd
// (Event, Protected, BlueprintEvent)

void AHansActiveAbility::BP_OnLocalHansActiveEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansActiveAbility", "BP_OnLocalHansActiveEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.HansActiveAbility.BP_OnLocalHansActiveStart
// (Event, Protected, BlueprintEvent)

void AHansActiveAbility::BP_OnLocalHansActiveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansActiveAbility", "BP_OnLocalHansActiveStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.HansActiveAbility.MulticastFireShot
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FVector_NetQuantize              OriginPos                                              (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              DestinationPos                                         (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHansActiveAbility::MulticastFireShot(const struct FVector_NetQuantize& OriginPos, const struct FVector_NetQuantize& DestinationPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansActiveAbility", "MulticastFireShot");

	Params::HansActiveAbility_MulticastFireShot Parms{};

	Parms.OriginPos = std::move(OriginPos);
	Parms.DestinationPos = std::move(DestinationPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HansActiveAbility.MulticastProjectileHit
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              ImpactPos                                              (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ImpactNormal                                           (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHansActiveAbility::MulticastProjectileHit(class AActor* Victim, const struct FVector_NetQuantize& ImpactPos, const struct FVector_NetQuantizeNormal& ImpactNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansActiveAbility", "MulticastProjectileHit");

	Params::HansActiveAbility_MulticastProjectileHit Parms{};

	Parms.Victim = Victim;
	Parms.ImpactPos = std::move(ImpactPos);
	Parms.ImpactNormal = std::move(ImpactNormal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HansActiveAbility.OnAfterShotTimerEnd
// (Final, Native, Protected)

void AHansActiveAbility::OnAfterShotTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansActiveAbility", "OnAfterShotTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HansActiveAbility.OnServerHansActiveEnd
// (Final, Native, Protected)

void AHansActiveAbility::OnServerHansActiveEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansActiveAbility", "OnServerHansActiveEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HansActiveAbility.Server_StartHansActive
// (Net, NetReliable, Native, Event, Protected, NetServer)

void AHansActiveAbility::Server_StartHansActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansActiveAbility", "Server_StartHansActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HansActiveAbility.GetMuzzlePosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AHansActiveAbility::GetMuzzlePosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HansActiveAbility", "GetMuzzlePosition");

	Params::HansActiveAbility_GetMuzzlePosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.HealthComponent.IsFriendly
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ActorA                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorB                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent::IsFriendly(const class AActor* ActorA, const class AActor* ActorB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HealthComponent", "IsFriendly");

	Params::HealthComponent_IsFriendly Parms{};

	Parms.ActorA = ActorA;
	Parms.ActorB = ActorB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.HealthComponent.IsFriendlyOrNeutral
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ActorA                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorB                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent::IsFriendlyOrNeutral(const class AActor* ActorA, const class AActor* ActorB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HealthComponent", "IsFriendlyOrNeutral");

	Params::HealthComponent_IsFriendlyOrNeutral Parms{};

	Parms.ActorA = ActorA;
	Parms.ActorB = ActorB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.HealthComponent.AddDamageModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageModifier*                  Modifier                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::AddDamageModifier(class AActor* Instigator, class UDamageModifier* Modifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "AddDamageModifier");

	Params::HealthComponent_AddDamageModifier Parms{};

	Parms.Instigator = Instigator;
	Parms.Modifier = Modifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HealthComponent.FullHeal
// (Final, Native, Public, BlueprintCallable)

void UHealthComponent::FullHeal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "FullHeal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HealthComponent.HandleTakeAnyDamage
// (Final, Native, Protected)
// Parameters:
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::HandleTakeAnyDamage(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "HandleTakeAnyDamage");

	Params::HealthComponent_HandleTakeAnyDamage Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.Damage = Damage;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HealthComponent.Heal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   HealAmount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::Heal(float HealAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "Heal");

	Params::HealthComponent_Heal Parms{};

	Parms.HealAmount = HealAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HealthComponent.OnRep_Dead
// (Final, Native, Protected)
// Parameters:
// bool                                    OldDead                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::OnRep_Dead(bool OldDead)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "OnRep_Dead");

	Params::HealthComponent_OnRep_Dead Parms{};

	Parms.OldDead = OldDead;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HealthComponent.OnRep_HealthInfo
// (Final, Native, Protected)
// Parameters:
// struct FHealthInfo                      OldHealthInfo                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UHealthComponent::OnRep_HealthInfo(const struct FHealthInfo& OldHealthInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "OnRep_HealthInfo");

	Params::HealthComponent_OnRep_HealthInfo Parms{};

	Parms.OldHealthInfo = std::move(OldHealthInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HealthComponent.OnRep_MaxHealth
// (Final, Native, Protected)
// Parameters:
// float                                   OldMaxHealth                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::OnRep_MaxHealth(float OldMaxHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "OnRep_MaxHealth");

	Params::HealthComponent_OnRep_MaxHealth Parms{};

	Parms.OldMaxHealth = OldMaxHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HealthComponent.RemoveDamageModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDamageModifier*                  Modifier                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::RemoveDamageModifier(class UDamageModifier* Modifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "RemoveDamageModifier");

	Params::HealthComponent_RemoveDamageModifier Parms{};

	Parms.Modifier = Modifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HealthComponent.SetHealth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::SetHealth(float NewHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "SetHealth");

	Params::HealthComponent_SetHealth Parms{};

	Parms.NewHealth = NewHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HealthComponent.SetMaxHealth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewMaxHealth                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::SetMaxHealth(float NewMaxHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "SetMaxHealth");

	Params::HealthComponent_SetMaxHealth Parms{};

	Parms.NewMaxHealth = NewMaxHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HealthComponent.SetOfflineDemiGod
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDemiGod                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::SetOfflineDemiGod(bool bDemiGod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "SetOfflineDemiGod");

	Params::HealthComponent_SetOfflineDemiGod Parms{};

	Parms.bDemiGod = bDemiGod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HealthComponent.GetHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetHealth");

	Params::HealthComponent_GetHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.HealthComponent.GetHealthRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetHealthRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetHealthRatio");

	Params::HealthComponent_GetHealthRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.HealthComponent.GetHealthRatioOnDefault
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetHealthRatioOnDefault() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetHealthRatioOnDefault");

	Params::HealthComponent_GetHealthRatioOnDefault Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.HealthComponent.GetMaxHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetMaxHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetMaxHealth");

	Params::HealthComponent_GetMaxHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.HealthComponent.IsDead
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent::IsDead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "IsDead");

	Params::HealthComponent_IsDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.HeightCheckComponent.ActivateHeightCheck
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bActivate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeightCheckComponent::ActivateHeightCheck(bool bActivate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeightCheckComponent", "ActivateHeightCheck");

	Params::HeightCheckComponent_ActivateHeightCheck Parms{};

	Parms.bActivate = bActivate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.HeightCheckComponent.SetCustomCheckLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          CheckLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeightCheckComponent::SetCustomCheckLocation(const struct FVector& CheckLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeightCheckComponent", "SetCustomCheckLocation");

	Params::HeightCheckComponent_SetCustomCheckLocation Parms{};

	Parms.CheckLocation = std::move(CheckLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ImpulseWeaponComponent.OnSimulateLocalFireShot
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AProjectileWeapon*                Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OriginPos                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DestinationPos                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDoDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMissingShot                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImpulseWeaponComponent::OnSimulateLocalFireShot(class AProjectileWeapon* Weapon, const struct FVector& OriginPos, const struct FVector& DestinationPos, bool bDoDamage, bool bMissingShot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpulseWeaponComponent", "OnSimulateLocalFireShot");

	Params::ImpulseWeaponComponent_OnSimulateLocalFireShot Parms{};

	Parms.Weapon = Weapon;
	Parms.OriginPos = std::move(OriginPos);
	Parms.DestinationPos = std::move(DestinationPos);
	Parms.bDoDamage = bDoDamage;
	Parms.bMissingShot = bMissingShot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteractableComponent.GetContinuousInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractableComponent::GetContinuousInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "GetContinuousInteraction");

	Params::InteractableComponent_GetContinuousInteraction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteractableComponent.HandleActorSpawned
// (Final, Native, Protected)
// Parameters:
// class AActor*                           SpawnedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractableComponent::HandleActorSpawned(class AActor* SpawnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "HandleActorSpawned");

	Params::InteractableComponent_HandleActorSpawned Parms{};

	Parms.SpawnedActor = SpawnedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteractableComponent.HandleSpyDead
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             DeadSpy                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractableComponent::HandleSpyDead(class ASpy* DeadSpy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "HandleSpyDead");

	Params::InteractableComponent_HandleSpyDead Parms{};

	Parms.DeadSpy = DeadSpy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteractableComponent.IsBeingInteractedWith
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractableComponent::IsBeingInteractedWith()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "IsBeingInteractedWith");

	Params::InteractableComponent_IsBeingInteractedWith Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteractableComponent.IsResourceSpend
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteracterComponent*             Interacter                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractableComponent::IsResourceSpend(const class UInteracterComponent* Interacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "IsResourceSpend");

	Params::InteractableComponent_IsResourceSpend Parms{};

	Parms.Interacter = Interacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteractableComponent.OnComponentBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UInteractableComponent::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "OnComponentBeginOverlap");

	Params::InteractableComponent_OnComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteractableComponent.OnComponentEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractableComponent::OnComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "OnComponentEndOverlap");

	Params::InteractableComponent_OnComponentEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteractableComponent.OnGamePhaseChanged
// (Final, Native, Public)
// Parameters:
// ESpyGamePhase                           NewGamePhase                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractableComponent::OnGamePhaseChanged(ESpyGamePhase NewGamePhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "OnGamePhaseChanged");

	Params::InteractableComponent_OnGamePhaseChanged Parms{};

	Parms.NewGamePhase = NewGamePhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteractableComponent.OnRep_IsEnable
// (Final, Native, Private)

void UInteractableComponent::OnRep_IsEnable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "OnRep_IsEnable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteractableComponent.SetEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractableComponent::SetEnable(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "SetEnable");

	Params::InteractableComponent_SetEnable Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InteractableComponent.CanReduceInteractDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteracterComponent*             Interacter                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractableComponent::CanReduceInteractDuration(const class UInteracterComponent* Interacter) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "CanReduceInteractDuration");

	Params::InteractableComponent_CanReduceInteractDuration Parms{};

	Parms.Interacter = Interacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteractableComponent.GetCurrentInteractionData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLastInteractionData             ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLastInteractionData UInteractableComponent::GetCurrentInteractionData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "GetCurrentInteractionData");

	Params::InteractableComponent_GetCurrentInteractionData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteractableComponent.GetInteract1PAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Interacter                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInteract1PAnimation                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInteract1PAnimation UInteractableComponent::GetInteract1PAnimation(class AActor* Interacter) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "GetInteract1PAnimation");

	Params::InteractableComponent_GetInteract1PAnimation Parms{};

	Parms.Interacter = Interacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteractableComponent.GetInteractableState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInteractableState                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInteractableState UInteractableComponent::GetInteractableState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "GetInteractableState");

	Params::InteractableComponent_GetInteractableState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteractableComponent.GetInteractionDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractableComponent::GetInteractionDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "GetInteractionDistance");

	Params::InteractableComponent_GetInteractionDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteractableComponent.GetInteractionDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteracterComponent*             Interacter                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractableComponent::GetInteractionDuration(const class UInteracterComponent* Interacter) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "GetInteractionDuration");

	Params::InteractableComponent_GetInteractionDuration Parms{};

	Parms.Interacter = Interacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteractableComponent.GetInteractionIcon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionIconComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionIconComponent* UInteractableComponent::GetInteractionIcon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "GetInteractionIcon");

	Params::InteractableComponent_GetInteractionIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteractableComponent.IsDisableOnDestroyed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractableComponent::IsDisableOnDestroyed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "IsDisableOnDestroyed");

	Params::InteractableComponent_IsDisableOnDestroyed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteractableComponent.IsInteractCancelOnDamage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractableComponent::IsInteractCancelOnDamage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "IsInteractCancelOnDamage");

	Params::InteractableComponent_IsInteractCancelOnDamage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InteractionIconWidget.OnNewInteractionIconComponent
// (Event, Public, BlueprintEvent)
// Parameters:
// class UInteractionIconComponent*        OldComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionIconComponent*        NewComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionIconWidget::OnNewInteractionIconComponent(class UInteractionIconComponent* OldComponent, class UInteractionIconComponent* NewComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionIconWidget", "OnNewInteractionIconComponent");

	Params::InteractionIconWidget_OnNewInteractionIconComponent Parms{};

	Parms.OldComponent = OldComponent;
	Parms.NewComponent = NewComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.InteractionIconWidget.SetIsRepeatableInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bState                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionIconWidget::SetIsRepeatableInteraction(bool bState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionIconWidget", "SetIsRepeatableInteraction");

	Params::InteractionIconWidget_SetIsRepeatableInteraction Parms{};

	Parms.bState = bState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.IntroFlow.BP_OnShowPosingSpySequenceEnd
// (Event, Protected, BlueprintEvent)

void AIntroFlow::BP_OnShowPosingSpySequenceEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IntroFlow", "BP_OnShowPosingSpySequenceEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.IntroFlow.BP_OnShowPosingSpySequenceStart
// (Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          SpyPosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APosingSpy*                       PosingSpy                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIntroFlow::BP_OnShowPosingSpySequenceStart(const struct FVector& SpyPosition, class APosingSpy* PosingSpy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IntroFlow", "BP_OnShowPosingSpySequenceStart");

	Params::IntroFlow_BP_OnShowPosingSpySequenceStart Parms{};

	Parms.SpyPosition = std::move(SpyPosition);
	Parms.PosingSpy = PosingSpy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.IntroFlow.CleanupIntroShowcase
// (Final, Native, Public, BlueprintCallable)

void AIntroFlow::CleanupIntroShowcase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IntroFlow", "CleanupIntroShowcase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.IntroFlow.InitIntroShowcase
// (Final, Native, Public, BlueprintCallable)

void AIntroFlow::InitIntroShowcase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IntroFlow", "InitIntroShowcase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.IntroFlow.IsKillcamPlaying
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIntroFlow::IsKillcamPlaying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IntroFlow", "IsKillcamPlaying");

	Params::IntroFlow_IsKillcamPlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.IntroFlow.SpawnPosingSpyLightRig
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               LightRigClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalOffset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         LocalRotation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AIntroFlow::SpawnPosingSpyLightRig(TSubclassOf<class AActor> LightRigClass, const struct FVector& LocalOffset, const struct FRotator& LocalRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IntroFlow", "SpawnPosingSpyLightRig");

	Params::IntroFlow_SpawnPosingSpyLightRig Parms{};

	Parms.LightRigClass = LightRigClass;
	Parms.LocalOffset = std::move(LocalOffset);
	Parms.LocalRotation = std::move(LocalRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.IntroFlow.StartShowPosingSpySequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               PosingSpyContainer                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AIntroFlow::StartShowPosingSpySequence(TSubclassOf<class AActor> PosingSpyContainer, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IntroFlow", "StartShowPosingSpySequence");

	Params::IntroFlow_StartShowPosingSpySequence Parms{};

	Parms.PosingSpyContainer = PosingSpyContainer;
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.IntroFlow.IsShowPosingSpySequenceInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIntroFlow::IsShowPosingSpySequenceInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IntroFlow", "IsShowPosingSpySequenceInProgress");

	Params::IntroFlow_IsShowPosingSpySequenceInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.IntroFlow.IsShowPosingSpySuccessful
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIntroFlow::IsShowPosingSpySuccessful() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IntroFlow", "IsShowPosingSpySuccessful");

	Params::IntroFlow_IsShowPosingSpySuccessful Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.InvestigationZoneActor.HandleComponentBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AInvestigationZoneActor::HandleComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationZoneActor", "HandleComponentBeginOverlap");

	Params::InvestigationZoneActor_HandleComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InvestigationZoneActor.HandleComponentEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInvestigationZoneActor::HandleComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationZoneActor", "HandleComponentEndOverlap");

	Params::InvestigationZoneActor_HandleComponentEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InvestigationZoneActor.HandleInteractTrapTriggered
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInvestigationZoneActor::HandleInteractTrapTriggered(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationZoneActor", "HandleInteractTrapTriggered");

	Params::InvestigationZoneActor_HandleInteractTrapTriggered Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.InvestigationZoneActor.HandleTrapTriggered
// (Final, Native, Protected)
// Parameters:
// class UHackTrapScannableComponent*      Trap                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInvestigationZoneActor::HandleTrapTriggered(class UHackTrapScannableComponent* Trap, class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationZoneActor", "HandleTrapTriggered");

	Params::InvestigationZoneActor_HandleTrapTriggered Parms{};

	Parms.Trap = Trap;
	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.LarcinPassiveAbility.BP_OnLocalLarcinStoleResource
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           VictimActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayResourcesType                  InResourceType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALarcinPassiveAbility::BP_OnLocalLarcinStoleResource(class AActor* VictimActor, EGameplayResourcesType InResourceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinPassiveAbility", "BP_OnLocalLarcinStoleResource");

	Params::LarcinPassiveAbility_BP_OnLocalLarcinStoleResource Parms{};

	Parms.VictimActor = VictimActor;
	Parms.InResourceType = InResourceType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.LarcinPassiveAbility.BP_OnLocalVictimOfLarcinSteal
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           StealingLarcinActor                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayResourcesType                  InResourceType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALarcinPassiveAbility::BP_OnLocalVictimOfLarcinSteal(class AActor* StealingLarcinActor, EGameplayResourcesType InResourceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinPassiveAbility", "BP_OnLocalVictimOfLarcinSteal");

	Params::LarcinPassiveAbility_BP_OnLocalVictimOfLarcinSteal Parms{};

	Parms.StealingLarcinActor = StealingLarcinActor;
	Parms.InResourceType = InResourceType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.LarcinPassiveAbility.HandleCoverChange
// (Final, Native, Protected)
// Parameters:
// bool                                    Undercover                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALarcinPassiveAbility::HandleCoverChange(bool Undercover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinPassiveAbility", "HandleCoverChange");

	Params::LarcinPassiveAbility_HandleCoverChange Parms{};

	Parms.Undercover = Undercover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.LarcinPassiveAbility.HandleLoadoutSpawnCompleteEvent
// (Final, Native, Protected)
// Parameters:
// class UToolLoadoutComponent*            LoadoutComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALarcinPassiveAbility::HandleLoadoutSpawnCompleteEvent(class UToolLoadoutComponent* LoadoutComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinPassiveAbility", "HandleLoadoutSpawnCompleteEvent");

	Params::LarcinPassiveAbility_HandleLoadoutSpawnCompleteEvent Parms{};

	Parms.LoadoutComponent = LoadoutComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.LarcinPassiveAbility.HandleMeleeAttackImpactEvent
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactPoint                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ChargeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ResultingHealthPercentage                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHitType                                HitType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMeleeHitConfirmedData           HitConfirmedData                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALarcinPassiveAbility::HandleMeleeAttackImpactEvent(class AActor* Victim, const struct FVector& ImpactPoint, int32 ChargeLevel, float Damage, float ResultingHealthPercentage, EHitType HitType, const struct FMeleeHitConfirmedData& HitConfirmedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinPassiveAbility", "HandleMeleeAttackImpactEvent");

	Params::LarcinPassiveAbility_HandleMeleeAttackImpactEvent Parms{};

	Parms.Victim = Victim;
	Parms.ImpactPoint = std::move(ImpactPoint);
	Parms.ChargeLevel = ChargeLevel;
	Parms.Damage = Damage;
	Parms.ResultingHealthPercentage = ResultingHealthPercentage;
	Parms.HitType = HitType;
	Parms.HitConfirmedData = std::move(HitConfirmedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.LarcinPassiveAbility.NotifyHitNPCMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALarcinPassiveAbility::NotifyHitNPCMulticast(class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinPassiveAbility", "NotifyHitNPCMulticast");

	Params::LarcinPassiveAbility_NotifyHitNPCMulticast Parms{};

	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.LarcinPassiveAbility.NotifySuccessfulStealNetMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           Theft                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayResourcesType                  InResourceType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALarcinPassiveAbility::NotifySuccessfulStealNetMulticast(class AActor* Theft, class AActor* Victim, EGameplayResourcesType InResourceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinPassiveAbility", "NotifySuccessfulStealNetMulticast");

	Params::LarcinPassiveAbility_NotifySuccessfulStealNetMulticast Parms{};

	Parms.Theft = Theft;
	Parms.Victim = Victim;
	Parms.InResourceType = InResourceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.LarcinPassiveMod1_2Ability.BP_OnLocalLarcinStoleResource
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayResourcesType                  InResourceType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALarcinPassiveMod1_2Ability::BP_OnLocalLarcinStoleResource(class AActor* Victim, EGameplayResourcesType InResourceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinPassiveMod1_2Ability", "BP_OnLocalLarcinStoleResource");

	Params::LarcinPassiveMod1_2Ability_BP_OnLocalLarcinStoleResource Parms{};

	Parms.Victim = Victim;
	Parms.InResourceType = InResourceType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.LarcinPassiveMod1_2Ability.BP_OnLocalVictimOfLarcinSteal
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayResourcesType                  InResourceType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALarcinPassiveMod1_2Ability::BP_OnLocalVictimOfLarcinSteal(class AActor* Victim, EGameplayResourcesType InResourceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinPassiveMod1_2Ability", "BP_OnLocalVictimOfLarcinSteal");

	Params::LarcinPassiveMod1_2Ability_BP_OnLocalVictimOfLarcinSteal Parms{};

	Parms.Victim = Victim;
	Parms.InResourceType = InResourceType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.LarcinPassiveMod1_2Ability.HandleCoverBlownEvent
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALarcinPassiveMod1_2Ability::HandleCoverBlownEvent(class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinPassiveMod1_2Ability", "HandleCoverBlownEvent");

	Params::LarcinPassiveMod1_2Ability_HandleCoverBlownEvent Parms{};

	Parms.Spy = Spy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.LarcinPassiveMod1_2Ability.NotifySuccessfulStealNetMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           Larcin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayResourcesType                  InResourceType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALarcinPassiveMod1_2Ability::NotifySuccessfulStealNetMulticast(class AActor* Larcin, class AActor* Victim, EGameplayResourcesType InResourceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcinPassiveMod1_2Ability", "NotifySuccessfulStealNetMulticast");

	Params::LarcinPassiveMod1_2Ability_NotifySuccessfulStealNetMulticast Parms{};

	Parms.Larcin = Larcin;
	Parms.Victim = Victim;
	Parms.InResourceType = InResourceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.LevelArea.GetAreaName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ALevelArea::GetAreaName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelArea", "GetAreaName");

	Params::LevelArea_GetAreaName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.LocalSpyEventBus.BP_FireOnCharmBrokenEvent
// (Final, Native, Public, BlueprintCallable)

void ULocalSpyEventBus::BP_FireOnCharmBrokenEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "BP_FireOnCharmBrokenEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_AutoSpectatingChange__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoSpectating                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_AutoSpectatingChange__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, bool bAutoSpectating)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_AutoSpectatingChange__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_AutoSpectatingChange__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.bAutoSpectating = bAutoSpectating;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_CancelInteract__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInteractCancelType                     InteractCancelType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_CancelInteract__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, EInteractCancelType InteractCancelType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_CancelInteract__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_CancelInteract__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.InteractCancelType = InteractCancelType;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_CharmBroken__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void ULocalSpyEventBus::SpyEventDelegate_CharmBroken__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_CharmBroken__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_CharmedChange__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsCharmed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_CharmedChange__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, bool bIsCharmed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_CharmedChange__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_CharmedChange__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.bIsCharmed = bIsCharmed;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_ConfirmKill__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_ConfirmKill__DelegateSignature(class ASpy* Spy, class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_ConfirmKill__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_ConfirmKill__DelegateSignature Parms{};

	Parms.Spy = Spy;
	Parms.DamagedActor = DamagedActor;
	Parms.Damage = Damage;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_CoverChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANPCCharacter*                    NewDisguise                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsFirstDisguise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_CoverChanged__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, class ANPCCharacter* NewDisguise, bool bIsFirstDisguise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_CoverChanged__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_CoverChanged__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;
	Parms.NewDisguise = NewDisguise;
	Parms.bIsFirstDisguise = bIsFirstDisguise;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_DirectionalDamageReceived__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams, HasDefaults)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ShotFromDirection                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHitType                                HitType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_DirectionalDamageReceived__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, float Damage, const struct FVector& ShotFromDirection, EHitType HitType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_DirectionalDamageReceived__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_DirectionalDamageReceived__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;
	Parms.Damage = Damage;
	Parms.ShotFromDirection = std::move(ShotFromDirection);
	Parms.HitType = HitType;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_FallLand__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FallStep                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FallDamageAmount                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_FallLand__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, int32 FallStep, int32 FallDamageAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_FallLand__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_FallLand__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.FallStep = FallStep;
	Parms.FallDamageAmount = FallDamageAmount;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_Generic__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_Generic__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_Generic__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_Generic__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_HeadingChange__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewHeading                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_HeadingChange__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, float NewHeading)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_HeadingChange__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_HeadingChange__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;
	Parms.NewHeading = NewHeading;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_IntroFlow__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AIntroFlow*                       IntroFlowActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_IntroFlow__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, class AIntroFlow* IntroFlowActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_IntroFlow__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_IntroFlow__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;
	Parms.IntroFlowActor = IntroFlowActor;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_InVaultChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInVault                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_InVaultChanged__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, bool bInVault)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_InVaultChanged__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_InVaultChanged__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;
	Parms.bInVault = bInVault;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_KillcamPlaybackChange__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_KillcamPlaybackChange__DelegateSignature(class ADeceiveIncPlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_KillcamPlaybackChange__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_KillcamPlaybackChange__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_LoadoutSpawnComplete__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UToolLoadoutComponent*            ToolLoadout                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_LoadoutSpawnComplete__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class UToolLoadoutComponent* ToolLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_LoadoutSpawnComplete__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_LoadoutSpawnComplete__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.ToolLoadout = ToolLoadout;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_MeleeImpact__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams, HasDefaults)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactPoint                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ChargeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ResultingHealthPercentage                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHitType                                HitType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_MeleeImpact__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, class AActor* Victim, const struct FVector& ImpactPoint, int32 ChargeLevel, float Damage, float ResultingHealthPercentage, EHitType HitType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_MeleeImpact__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_MeleeImpact__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;
	Parms.Victim = Victim;
	Parms.ImpactPoint = std::move(ImpactPoint);
	Parms.ChargeLevel = ChargeLevel;
	Parms.Damage = Damage;
	Parms.ResultingHealthPercentage = ResultingHealthPercentage;
	Parms.HitType = HitType;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_MovementEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementEventType                      MovementEventType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_MovementEvent__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, EMovementEventType MovementEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_MovementEvent__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_MovementEvent__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;
	Parms.MovementEventType = MovementEventType;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_PlayerNameChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_PlayerNameChanged__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, const class FString& PlayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_PlayerNameChanged__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_PlayerNameChanged__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.PlayerName = std::move(PlayerName);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_PoudrierVisibilityChange__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_PoudrierVisibilityChange__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_PoudrierVisibilityChange__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_PoudrierVisibilityChange__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.bVisible = bVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_ReceivedXPEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDIXPEvent                              XPEventType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AddedXP                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_ReceivedXPEvent__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, EDIXPEvent XPEventType, int32 AddedXP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_ReceivedXPEvent__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_ReceivedXPEvent__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.XPEventType = XPEventType;
	Parms.AddedXP = AddedXP;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_ResourceAmountChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayResourcesType                  AffectedResource                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewResourceCount                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AmountDelta                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_ResourceAmountChanged__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, EGameplayResourcesType AffectedResource, int32 NewResourceCount, int32 AmountDelta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_ResourceAmountChanged__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_ResourceAmountChanged__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;
	Parms.AffectedResource = AffectedResource;
	Parms.NewResourceCount = NewResourceCount;
	Parms.AmountDelta = AmountDelta;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_ResourceNewAmount__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayResourcesType                  AffectedResource                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewResourceCount                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_ResourceNewAmount__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, EGameplayResourcesType AffectedResource, int32 NewResourceCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_ResourceNewAmount__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_ResourceNewAmount__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;
	Parms.AffectedResource = AffectedResource;
	Parms.NewResourceCount = NewResourceCount;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_RoomChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARoomVolume*                      InRoom                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_RoomChanged__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, class ARoomVolume* InRoom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_RoomChanged__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_RoomChanged__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;
	Parms.InRoom = InRoom;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_SpectatingPlayerChange__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SpectatingActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADIPlayerState*                   SpectatingPlayerState                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_SpectatingPlayerChange__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class AActor* SpectatingActor, class ADIPlayerState* SpectatingPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_SpectatingPlayerChange__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_SpectatingPlayerChange__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.SpectatingActor = SpectatingActor;
	Parms.SpectatingPlayerState = SpectatingPlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_WeaponAllowedChange__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AProjectileWeapon*                Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsAllowed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_WeaponAllowedChange__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, class AProjectileWeapon* Weapon, bool bIsAllowed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_WeaponAllowedChange__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_WeaponAllowedChange__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;
	Parms.Weapon = Weapon;
	Parms.bIsAllowed = bIsAllowed;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_WeaponAmmoStateChange__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AProjectileWeapon*                Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWeaponAmmoState                        AmmoState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_WeaponAmmoStateChange__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, class AProjectileWeapon* Weapon, EWeaponAmmoState AmmoState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_WeaponAmmoStateChange__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_WeaponAmmoStateChange__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;
	Parms.Weapon = Weapon;
	Parms.AmmoState = AmmoState;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_WeaponChargeChange__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AProjectileWeapon*                Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsCharging                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxChargingTime                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_WeaponChargeChange__DelegateSignature(class ASpy* Spy, class AProjectileWeapon* Weapon, bool bIsCharging, float MaxChargingTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_WeaponChargeChange__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_WeaponChargeChange__DelegateSignature Parms{};

	Parms.Spy = Spy;
	Parms.Weapon = Weapon;
	Parms.bIsCharging = bIsCharging;
	Parms.MaxChargingTime = MaxChargingTime;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_WeaponHitConfirmedEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitConfirmData                  HitConfirmedData                                       (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_WeaponHitConfirmedEvent__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, const struct FHitConfirmData& HitConfirmedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_WeaponHitConfirmedEvent__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_WeaponHitConfirmedEvent__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;
	Parms.HitConfirmedData = std::move(HitConfirmedData);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_WeaponProjectileImpact__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWeaponImpactData                WeaponImpactData                                       (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_WeaponProjectileImpact__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, const struct FWeaponImpactData& WeaponImpactData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_WeaponProjectileImpact__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_WeaponProjectileImpact__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;
	Parms.WeaponImpactData = std::move(WeaponImpactData);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_WeaponShoot__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams, HasDefaults)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AProjectileWeapon*                Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OriginPos                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DestinationPos                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDelegate_WeaponShoot__DelegateSignature(class ASpy* Spy, class AProjectileWeapon* Weapon, const struct FVector& OriginPos, const struct FVector& DestinationPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDelegate_WeaponShoot__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDelegate_WeaponShoot__DelegateSignature Parms{};

	Parms.Spy = Spy;
	Parms.Weapon = Weapon;
	Parms.OriginPos = std::move(OriginPos);
	Parms.DestinationPos = std::move(DestinationPos);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDeletgate_HealthChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams, HasDefaults)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UHealthComponent*                 SpyHealthComp                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Health                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HealthDelta                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DamageDirection                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalSpyEventBus::SpyEventDeletgate_HealthChanged__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, class UHealthComponent* SpyHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& DamageDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalSpyEventBus", "SpyEventDeletgate_HealthChanged__DelegateSignature");

	Params::LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;
	Parms.SpyHealthComp = SpyHealthComp;
	Parms.Health = Health;
	Parms.HealthDelta = HealthDelta;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.DamageDirection = std::move(DamageDirection);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.LootItemShowcase.BP_OnClaimedItemResponseSet
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FClaimedItemResponse             NewClaimedItemResponse                                 (Parm, NativeAccessSpecifierPublic)
// class UDIItem*                          ItemIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALootItemShowcase::BP_OnClaimedItemResponseSet(const struct FClaimedItemResponse& NewClaimedItemResponse, class UDIItem* ItemIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootItemShowcase", "BP_OnClaimedItemResponseSet");

	Params::LootItemShowcase_BP_OnClaimedItemResponseSet Parms{};

	Parms.NewClaimedItemResponse = std::move(NewClaimedItemResponse);
	Parms.ItemIn = ItemIn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.LootItemShowcase.EnableItemRotation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALootItemShowcase::EnableItemRotation(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootItemShowcase", "EnableItemRotation");

	Params::LootItemShowcase_EnableItemRotation Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.LootItemShowcase.GetAvatarTexture2D
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* ALootItemShowcase::GetAvatarTexture2D() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootItemShowcase", "GetAvatarTexture2D");

	Params::LootItemShowcase_GetAvatarTexture2D Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.LootItemShowcase.GetClaimedItemResponse
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FClaimedItemResponse             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FClaimedItemResponse ALootItemShowcase::GetClaimedItemResponse() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootItemShowcase", "GetClaimedItemResponse");

	Params::LootItemShowcase_GetClaimedItemResponse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.LootItemShowcase.GetFocusCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCameraComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraComponent* ALootItemShowcase::GetFocusCamera() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootItemShowcase", "GetFocusCamera");

	Params::LootItemShowcase_GetFocusCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.LootItemShowcase.GetHoverWidgetRefPos
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ALootItemShowcase::GetHoverWidgetRefPos() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootItemShowcase", "GetHoverWidgetRefPos");

	Params::LootItemShowcase_GetHoverWidgetRefPos Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.LootItemShowcase.GetItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDIItem*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDIItem* ALootItemShowcase::GetItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootItemShowcase", "GetItem");

	Params::LootItemShowcase_GetItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.LootItemShowcase.GetItemDisplayName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ALootItemShowcase::GetItemDisplayName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootItemShowcase", "GetItemDisplayName");

	Params::LootItemShowcase_GetItemDisplayName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.LootItemShowcase.GetItemRarity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALootItemShowcase::GetItemRarity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootItemShowcase", "GetItemRarity");

	Params::LootItemShowcase_GetItemRarity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.LootItemShowcase.GetItemRarityDisplayName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ALootItemShowcase::GetItemRarityDisplayName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootItemShowcase", "GetItemRarityDisplayName");

	Params::LootItemShowcase_GetItemRarityDisplayName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.LootItemShowcase.GetItemTypeDisplayName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ALootItemShowcase::GetItemTypeDisplayName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootItemShowcase", "GetItemTypeDisplayName");

	Params::LootItemShowcase_GetItemTypeDisplayName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.LootItemShowcase.GetItemVisualRepresentation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ALootItemShowcase::GetItemVisualRepresentation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootItemShowcase", "GetItemVisualRepresentation");

	Params::LootItemShowcase_GetItemVisualRepresentation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.MaxUseConditionComponent.OnInteractionComplete
// (Final, Native, Private)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaxUseConditionComponent::OnInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaxUseConditionComponent", "OnInteractionComplete");

	Params::MaxUseConditionComponent_OnInteractionComplete Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.MaxUseConditionComponent.OnRep_PlayerUseLeft
// (Final, Native, Private)

void UMaxUseConditionComponent::OnRep_PlayerUseLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaxUseConditionComponent", "OnRep_PlayerUseLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.MaxUseConditionComponent.Reset
// (Final, Native, Public, BlueprintCallable)

void UMaxUseConditionComponent::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaxUseConditionComponent", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.MaxUseConditionComponent.ResetForPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           PlayerActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaxUseConditionComponent::ResetForPlayer(class AActor* PlayerActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaxUseConditionComponent", "ResetForPlayer");

	Params::MaxUseConditionComponent_ResetForPlayer Parms{};

	Parms.PlayerActor = PlayerActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.MenuData.GetMenuWidgetClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMenuType                               MenuType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UUserWidget>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UUserWidget> UMenuData::GetMenuWidgetClass(EMenuType MenuType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuData", "GetMenuWidgetClass");

	Params::MenuData_GetMenuWidgetClass Parms{};

	Parms.MenuType = MenuType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.MessageUserWidget.CreateMessageWidget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDIMessageSettings               InMessageSettings                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UMessageUserWidget*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMessageUserWidget* UMessageUserWidget::CreateMessageWidget(const struct FDIMessageSettings& InMessageSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUserWidget", "CreateMessageWidget");

	Params::MessageUserWidget_CreateMessageWidget Parms{};

	Parms.InMessageSettings = std::move(InMessageSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.MessageUserWidget.BP_OnRedraw
// (Event, Public, BlueprintEvent)

void UMessageUserWidget::BP_OnRedraw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MessageUserWidget", "BP_OnRedraw");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.MessageUserWidget.DoClickedAction
// (Final, Native, Public, BlueprintCallable)

void UMessageUserWidget::DoClickedAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MessageUserWidget", "DoClickedAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.MessageUserWidget.ImageAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UTexture>          ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UTexture> UMessageUserWidget::ImageAsset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MessageUserWidget", "ImageAsset");

	Params::MessageUserWidget_ImageAsset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.MessageUserWidget.Redraw
// (Final, Native, Public, BlueprintCallable)

void UMessageUserWidget::Redraw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MessageUserWidget", "Redraw");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.MessageUserWidget.SetMessageSettings
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDIMessageSettings               InMessageSettings                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMessageUserWidget::SetMessageSettings(const struct FDIMessageSettings& InMessageSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MessageUserWidget", "SetMessageSettings");

	Params::MessageUserWidget_SetMessageSettings Parms{};

	Parms.InMessageSettings = std::move(InMessageSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.MessageUserWidget.GetExtraData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMessageUserWidget::GetExtraData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MessageUserWidget", "GetExtraData");

	Params::MessageUserWidget_GetExtraData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.MessageUserWidget.GetText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UMessageUserWidget::GetText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MessageUserWidget", "GetText");

	Params::MessageUserWidget_GetText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.MessageUserWidget.GetTitle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UMessageUserWidget::GetTitle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MessageUserWidget", "GetTitle");

	Params::MessageUserWidget_GetTitle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.MimicScannableComponent.OnSpyToolLoadComplete
// (Final, Native, Protected)
// Parameters:
// class UToolLoadoutComponent*            ToolLoadout                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMimicScannableComponent::OnSpyToolLoadComplete(class UToolLoadoutComponent* ToolLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MimicScannableComponent", "OnSpyToolLoadComplete");

	Params::MimicScannableComponent_OnSpyToolLoadComplete Parms{};

	Parms.ToolLoadout = ToolLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.MimicScannerTool.HandleCoverAffectingSourceChange
// (Final, Native, Protected)
// Parameters:
// ECoverAffectingSourceType               NewCoverAffectingType                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAdded                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMimicScannerTool::HandleCoverAffectingSourceChange(ECoverAffectingSourceType NewCoverAffectingType, bool bAdded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MimicScannerTool", "HandleCoverAffectingSourceChange");

	Params::MimicScannerTool_HandleCoverAffectingSourceChange Parms{};

	Parms.NewCoverAffectingType = NewCoverAffectingType;
	Parms.bAdded = bAdded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.MimicScannerTool.HandleOutOfMimic
// (Final, Native, Protected)

void AMimicScannerTool::HandleOutOfMimic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MimicScannerTool", "HandleOutOfMimic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.MimicScannerTool.NetMulticast_ToggleMimicRotation
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// bool                                    bRotate                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMimicScannerTool::NetMulticast_ToggleMimicRotation(bool bRotate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MimicScannerTool", "NetMulticast_ToggleMimicRotation");

	Params::MimicScannerTool_NetMulticast_ToggleMimicRotation Parms{};

	Parms.bRotate = bRotate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.MimicScannerTool.NetMulticast_TransformToMimic
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void AMimicScannerTool::NetMulticast_TransformToMimic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MimicScannerTool", "NetMulticast_TransformToMimic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.MimicScannerTool.OnRep_NewSpawnedMimic
// (Final, Native, Protected)

void AMimicScannerTool::OnRep_NewSpawnedMimic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MimicScannerTool", "OnRep_NewSpawnedMimic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.MimicScannerTool.Server_ToggleMimicRotation
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// bool                                    bRotate                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMimicScannerTool::Server_ToggleMimicRotation(bool bRotate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MimicScannerTool", "Server_ToggleMimicRotation");

	Params::MimicScannerTool_Server_ToggleMimicRotation Parms{};

	Parms.bRotate = bRotate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.MimicScannerTool.Server_TransformToMimic
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void AMimicScannerTool::Server_TransformToMimic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MimicScannerTool", "Server_TransformToMimic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.MimicScannerTool.IsInMimic
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMimicScannerTool::IsInMimic() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MimicScannerTool", "IsInMimic");

	Params::MimicScannerTool_IsInMimic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.MirrorBotBrain.OnLocalMeleeEvent
// (Final, Native, Protected)
// Parameters:
// ESpyToolEvent                           EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMirrorBotBrain::OnLocalMeleeEvent(ESpyToolEvent EventType, class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MirrorBotBrain", "OnLocalMeleeEvent");

	Params::MirrorBotBrain_OnLocalMeleeEvent Parms{};

	Parms.EventType = EventType;
	Parms.SpyTool = SpyTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.MirrorBotBrain.OnLocalPlayerCoverBlown
// (Final, Native, Protected)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMirrorBotBrain::OnLocalPlayerCoverBlown(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MirrorBotBrain", "OnLocalPlayerCoverBlown");

	Params::MirrorBotBrain_OnLocalPlayerCoverBlown Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.MirrorBotBrain.OnLocalPlayerCoverRegainedEvent
// (Final, Native, Protected)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMirrorBotBrain::OnLocalPlayerCoverRegainedEvent(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MirrorBotBrain", "OnLocalPlayerCoverRegainedEvent");

	Params::MirrorBotBrain_OnLocalPlayerCoverRegainedEvent Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.MirrorBotBrain.OnLocalPlayerJump
// (Final, Native, Protected)

void UMirrorBotBrain::OnLocalPlayerJump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MirrorBotBrain", "OnLocalPlayerJump");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.MirrorBotBrain.OnLocalWeaponEvent
// (Final, Native, Protected)
// Parameters:
// ESpyToolEvent                           EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMirrorBotBrain::OnLocalWeaponEvent(ESpyToolEvent EventType, class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MirrorBotBrain", "OnLocalWeaponEvent");

	Params::MirrorBotBrain_OnLocalWeaponEvent Parms{};

	Parms.EventType = EventType;
	Parms.SpyTool = SpyTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.MirrorBotBrain.OnSwitchTool
// (Final, Native, Protected)
// Parameters:
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELoadoutSlot                            Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMirrorBotBrain::OnSwitchTool(class ABaseSpyTool* SpyTool, ELoadoutSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MirrorBotBrain", "OnSwitchTool");

	Params::MirrorBotBrain_OnSwitchTool Parms{};

	Parms.SpyTool = SpyTool;
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NavModeItemComponent.EnableNavModeItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNavModeItemComponent::EnableNavModeItem(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavModeItemComponent", "EnableNavModeItem");

	Params::NavModeItemComponent_EnableNavModeItem Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NavModeItemComponent.HandleGamePhaseChanged
// (Final, Native, Protected)
// Parameters:
// ESpyGamePhase                           NewGamePhase                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNavModeItemComponent::HandleGamePhaseChanged(ESpyGamePhase NewGamePhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavModeItemComponent", "HandleGamePhaseChanged");

	Params::NavModeItemComponent_HandleGamePhaseChanged Parms{};

	Parms.NewGamePhase = NewGamePhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NavModeItemComponent.HandleOnLocalLoadoutSpawnComplete
// (Final, Native, Protected)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UToolLoadoutComponent*            ToolLoadout                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNavModeItemComponent::HandleOnLocalLoadoutSpawnComplete(class ADeceiveIncPlayerController* PlayerController, class UToolLoadoutComponent* ToolLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavModeItemComponent", "HandleOnLocalLoadoutSpawnComplete");

	Params::NavModeItemComponent_HandleOnLocalLoadoutSpawnComplete Parms{};

	Parms.PlayerController = PlayerController;
	Parms.ToolLoadout = ToolLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NavModeItemComponent.SetNavModeItemIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             NewIcon                                                (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNavModeItemComponent::SetNavModeItemIcon(TSoftClassPtr<class UClass> NewIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavModeItemComponent", "SetNavModeItemIcon");

	Params::NavModeItemComponent_SetNavModeItemIcon Parms{};

	Parms.NewIcon = NewIcon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NavModeItemComponent.SetNavModeItemSelected
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bHighlight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNavModeItemComponent::SetNavModeItemSelected(bool bHighlight, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavModeItemComponent", "SetNavModeItemSelected");

	Params::NavModeItemComponent_SetNavModeItemSelected Parms{};

	Parms.bHighlight = bHighlight;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NavModeItemComponent.SetNavModeItemShowed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShowed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNavModeItemComponent::SetNavModeItemShowed(bool bShowed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavModeItemComponent", "SetNavModeItemShowed");

	Params::NavModeItemComponent_SetNavModeItemShowed Parms{};

	Parms.bShowed = bShowed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NavModeItemComponent.GetMinSquaredDistanceToUnselect
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNavModeItemComponent::GetMinSquaredDistanceToUnselect() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavModeItemComponent", "GetMinSquaredDistanceToUnselect");

	Params::NavModeItemComponent_GetMinSquaredDistanceToUnselect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NavModeItemComponent.GetNavModeItemType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENavModeItemType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENavModeItemType UNavModeItemComponent::GetNavModeItemType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavModeItemComponent", "GetNavModeItemType");

	Params::NavModeItemComponent_GetNavModeItemType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NavModeItemComponent.GetRaycastPenetrationThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNavModeItemComponent::GetRaycastPenetrationThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavModeItemComponent", "GetRaycastPenetrationThreshold");

	Params::NavModeItemComponent_GetRaycastPenetrationThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NavModeItemComponent.IsEnable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNavModeItemComponent::IsEnable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavModeItemComponent", "IsEnable");

	Params::NavModeItemComponent_IsEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NavModeItemComponent.IsNavModeItemSelected
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNavModeItemComponent::IsNavModeItemSelected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavModeItemComponent", "IsNavModeItemSelected");

	Params::NavModeItemComponent_IsNavModeItemSelected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NavModeItemComponent.IsNavModeItemShowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNavModeItemComponent::IsNavModeItemShowed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavModeItemComponent", "IsNavModeItemShowed");

	Params::NavModeItemComponent_IsNavModeItemShowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NavModeItemComponent.IsShowedInCurrentPhase
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNavModeItemComponent::IsShowedInCurrentPhase() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavModeItemComponent", "IsShowedInCurrentPhase");

	Params::NavModeItemComponent_IsShowedInCurrentPhase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NavModeTool.HandleLocalSpyDeathEvent
// (Final, Native, Protected)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANavModeTool::HandleLocalSpyDeathEvent(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavModeTool", "HandleLocalSpyDeathEvent");

	Params::NavModeTool_HandleLocalSpyDeathEvent Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NavModeTool.HandleResourceChanged
// (Final, Native, Protected)
// Parameters:
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ResourceDisplayName                                    (Parm, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANavModeTool::HandleResourceChanged(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavModeTool", "HandleResourceChanged");

	Params::NavModeTool_HandleResourceChanged Parms{};

	Parms.ResourceType = ResourceType;
	Parms.ResourceDisplayName = std::move(ResourceDisplayName);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NavModeTool.OnRep_NavModeEnable
// (Final, Native, Protected)

void ANavModeTool::OnRep_NavModeEnable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavModeTool", "OnRep_NavModeEnable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NavModeTool.Server_OnNavModeItemSelected
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class UNavModeItemComponent*            NavModeItem                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANavModeTool::Server_OnNavModeItemSelected(class UNavModeItemComponent* NavModeItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavModeTool", "Server_OnNavModeItemSelected");

	Params::NavModeTool_Server_OnNavModeItemSelected Parms{};

	Parms.NavModeItem = NavModeItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NavModeTool.Server_OnNavModeStateChanged
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANavModeTool::Server_OnNavModeStateChanged(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavModeTool", "Server_OnNavModeStateChanged");

	Params::NavModeTool_Server_OnNavModeStateChanged Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NavModeTool.GetSelectedNavModeItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UNavModeItemComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNavModeItemComponent* ANavModeTool::GetSelectedNavModeItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavModeTool", "GetSelectedNavModeItem");

	Params::NavModeTool_GetSelectedNavModeItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NetworkInfoWidget.BP_OnDataUpdated
// (Event, Public, BlueprintEvent)

void UNetworkInfoWidget::BP_OnDataUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkInfoWidget", "BP_OnDataUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.NetworkInfoWidget.BP_OnDisplayModeChange
// (Event, Public, BlueprintEvent)
// Parameters:
// ENetInfoDisplayMode                     NewDisplayMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNetworkInfoWidget::BP_OnDisplayModeChange(ENetInfoDisplayMode NewDisplayMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkInfoWidget", "BP_OnDisplayModeChange");

	Params::NetworkInfoWidget_BP_OnDisplayModeChange Parms{};

	Parms.NewDisplayMode = NewDisplayMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.NetworkInfoWidget.HandleIntegerPlayerSettingChange
// (Final, Native, Protected)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNetworkInfoWidget::HandleIntegerPlayerSettingChange(EPlayerSettingsType SettingType, int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkInfoWidget", "HandleIntegerPlayerSettingChange");

	Params::NetworkInfoWidget_HandleIntegerPlayerSettingChange Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NetworkInfoWidget.CanBeDisplayed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNetworkInfoWidget::CanBeDisplayed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkInfoWidget", "CanBeDisplayed");

	Params::NetworkInfoWidget_CanBeDisplayed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NetworkInfoWidget.CanDisplayRegion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNetworkInfoWidget::CanDisplayRegion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkInfoWidget", "CanDisplayRegion");

	Params::NetworkInfoWidget_CanDisplayRegion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NetworkInfoWidget.CanDisplayServerFrameTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNetworkInfoWidget::CanDisplayServerFrameTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkInfoWidget", "CanDisplayServerFrameTime");

	Params::NetworkInfoWidget_CanDisplayServerFrameTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NetworkInfoWidget.CanDisplayServerVersion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNetworkInfoWidget::CanDisplayServerVersion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkInfoWidget", "CanDisplayServerVersion");

	Params::NetworkInfoWidget_CanDisplayServerVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NetworkInfoWidget.CanDisplaySessionID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNetworkInfoWidget::CanDisplaySessionID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkInfoWidget", "CanDisplaySessionID");

	Params::NetworkInfoWidget_CanDisplaySessionID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NetworkInfoWidget.GetDisplayMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENetInfoDisplayMode                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENetInfoDisplayMode UNetworkInfoWidget::GetDisplayMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkInfoWidget", "GetDisplayMode");

	Params::NetworkInfoWidget_GetDisplayMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NetworkInfoWidget.GetNetworkInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDINetworkInfoData         ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FDINetworkInfoData UNetworkInfoWidget::GetNetworkInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkInfoWidget", "GetNetworkInfo");

	Params::NetworkInfoWidget_GetNetworkInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NetworkInfoWidget.IsConnexionLagging
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNetworkInfoWidget::IsConnexionLagging() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkInfoWidget", "IsConnexionLagging");

	Params::NetworkInfoWidget_IsConnexionLagging Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NetworkInfoWidget.IsDisconnected
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNetworkInfoWidget::IsDisconnected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkInfoWidget", "IsDisconnected");

	Params::NetworkInfoWidget_IsDisconnected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NetworkInfoWidget.IsPacketLoss
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNetworkInfoWidget::IsPacketLoss() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkInfoWidget", "IsPacketLoss");

	Params::NetworkInfoWidget_IsPacketLoss Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NetworkInfoWidget.IsServerLagging
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNetworkInfoWidget::IsServerLagging() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkInfoWidget", "IsServerLagging");

	Params::NetworkInfoWidget_IsServerLagging Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCAIActor.OnCrouchToResurectDelayTimerEnd
// (Final, Native, Protected)

void ANPCAIActor::OnCrouchToResurectDelayTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIActor", "OnCrouchToResurectDelayTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCAIActor.OnGamePhaseChanged
// (Final, Native, Protected)
// Parameters:
// ESpyGamePhase                           NewGamePhase                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCAIActor::OnGamePhaseChanged(ESpyGamePhase NewGamePhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIActor", "OnGamePhaseChanged");

	Params::NPCAIActor_OnGamePhaseChanged Parms{};

	Parms.NewGamePhase = NewGamePhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCAIActor.OnRunningChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bRunningIn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCAIActor::OnRunningChange(bool bRunningIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIActor", "OnRunningChange");

	Params::NPCAIActor_OnRunningChange Parms{};

	Parms.bRunningIn = bRunningIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCAIActor.OnScaredChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bScaredIn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCAIActor::OnScaredChange(bool bScaredIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIActor", "OnScaredChange");

	Params::NPCAIActor_OnScaredChange Parms{};

	Parms.bScaredIn = bScaredIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCAIActor.OnScoldingChange
// (Final, Native, Protected)
// Parameters:
// EScoldState                             PrevScoldState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EScoldState                             ScoldState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCAIActor::OnScoldingChange(EScoldState PrevScoldState, EScoldState ScoldState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIActor", "OnScoldingChange");

	Params::NPCAIActor_OnScoldingChange Parms{};

	Parms.PrevScoldState = PrevScoldState;
	Parms.ScoldState = ScoldState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCAIActor.OnSlowInterval
// (Final, Native, Protected)

void ANPCAIActor::OnSlowInterval()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIActor", "OnSlowInterval");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCAIActor.OnStandingOnBounceMatDeflated
// (Final, Native, Protected)
// Parameters:
// class ABouncingMat*                     DeflatingBounceMat                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCAIActor::OnStandingOnBounceMatDeflated(class ABouncingMat* DeflatingBounceMat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIActor", "OnStandingOnBounceMatDeflated");

	Params::NPCAIActor_OnStandingOnBounceMatDeflated Parms{};

	Parms.DeflatingBounceMat = DeflatingBounceMat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCAIActor.OnSuspiciousTimeOutTimerEnd
// (Final, Native, Protected)

void ANPCAIActor::OnSuspiciousTimeOutTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIActor", "OnSuspiciousTimeOutTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCAIActor.OnToggleRunDelayTimerEnd
// (Final, Native, Protected)

void ANPCAIActor::OnToggleRunDelayTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIActor", "OnToggleRunDelayTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCAIActor.GetNPCMoveStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENPCMovementStatus                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENPCMovementStatus ANPCAIActor::GetNPCMoveStatus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIActor", "GetNPCMoveStatus");

	Params::NPCAIActor_GetNPCMoveStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCBehaviorFollow.OnFollowingNPCEnteredRoom
// (Final, Native, Protected)
// Parameters:
// class ANPCCharacter*                    FollowingNPC                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARoomVolume*                      EnteredRoom                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCBehaviorFollow::OnFollowingNPCEnteredRoom(class ANPCCharacter* FollowingNPC, class ARoomVolume* EnteredRoom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBehaviorFollow", "OnFollowingNPCEnteredRoom");

	Params::NPCBehaviorFollow_OnFollowingNPCEnteredRoom Parms{};

	Parms.FollowingNPC = FollowingNPC;
	Parms.EnteredRoom = EnteredRoom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBehaviorFollow.OnGiveUpTimerEnd
// (Final, Native, Protected)

void UNPCBehaviorFollow::OnGiveUpTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBehaviorFollow", "OnGiveUpTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBehaviorInvestigate.OnBlockAttackTimerEnd
// (Final, Native, Protected)

void UNPCBehaviorInvestigate::OnBlockAttackTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBehaviorInvestigate", "OnBlockAttackTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBehaviorInvestigate.OnMeleeDelayTimerEnd
// (Final, Native, Protected)

void UNPCBehaviorInvestigate::OnMeleeDelayTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBehaviorInvestigate", "OnMeleeDelayTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBugSpawnerWeapon.HandleCoverSwitch
// (Final, Native, Protected)
// Parameters:
// class ANPCCharacter*                    Disguise                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBugSpawnerWeapon::HandleCoverSwitch(class ANPCCharacter* Disguise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBugSpawnerWeapon", "HandleCoverSwitch");

	Params::NPCBugSpawnerWeapon_HandleCoverSwitch Parms{};

	Parms.Disguise = Disguise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBugSpawnerWeapon.HandleOwnerTookDamage
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UHealthComponent*                 SpyHealthComp                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Health                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HealthDelta                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DamageDirection                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBugSpawnerWeapon::HandleOwnerTookDamage(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, class UHealthComponent* SpyHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& DamageDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBugSpawnerWeapon", "HandleOwnerTookDamage");

	Params::NPCBugSpawnerWeapon_HandleOwnerTookDamage Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;
	Parms.SpyHealthComp = SpyHealthComp;
	Parms.Health = Health;
	Parms.HealthDelta = HealthDelta;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.DamageDirection = std::move(DamageDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBugSpawnerWeapon.HandleProjectileImpact
// (Final, Native, Protected)
// Parameters:
// struct FWeaponImpactData                WeaponInpactData                                       (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ANPCBugSpawnerWeapon::HandleProjectileImpact(const struct FWeaponImpactData& WeaponInpactData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBugSpawnerWeapon", "HandleProjectileImpact");

	Params::NPCBugSpawnerWeapon_HandleProjectileImpact Parms{};

	Parms.WeaponInpactData = std::move(WeaponInpactData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBugSpawnerWeapon.HandleSimulateLocalFireShot
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AProjectileWeapon*                Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OriginPos                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DestinationPos                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDoDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMissingShot                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBugSpawnerWeapon::HandleSimulateLocalFireShot(class AProjectileWeapon* Weapon, const struct FVector& OriginPos, const struct FVector& DestinationPos, bool bDoDamage, bool bMissingShot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBugSpawnerWeapon", "HandleSimulateLocalFireShot");

	Params::NPCBugSpawnerWeapon_HandleSimulateLocalFireShot Parms{};

	Parms.Weapon = Weapon;
	Parms.OriginPos = std::move(OriginPos);
	Parms.DestinationPos = std::move(DestinationPos);
	Parms.bDoDamage = bDoDamage;
	Parms.bMissingShot = bMissingShot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBugSpawnerWeapon.HandleSpyMovementEvent
// (Final, Native, Protected)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementEventType                      MovementEventType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBugSpawnerWeapon::HandleSpyMovementEvent(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, EMovementEventType MovementEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBugSpawnerWeapon", "HandleSpyMovementEvent");

	Params::NPCBugSpawnerWeapon_HandleSpyMovementEvent Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;
	Parms.MovementEventType = MovementEventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBugSpawnerWeapon.HandleSpyToolEvent
// (Final, Native, Protected)
// Parameters:
// ESpyToolEvent                           EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBugSpawnerWeapon::HandleSpyToolEvent(ESpyToolEvent EventType, class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBugSpawnerWeapon", "HandleSpyToolEvent");

	Params::NPCBugSpawnerWeapon_HandleSpyToolEvent Parms{};

	Parms.EventType = EventType;
	Parms.SpyTool = SpyTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBugSpawnerWeapon.OnDelayShootTimerEnd
// (Final, Native, Protected)

void ANPCBugSpawnerWeapon::OnDelayShootTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBugSpawnerWeapon", "OnDelayShootTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBugSpawnerWeapon.OnRefundShotTimerEnd
// (Final, Native, Protected)

void ANPCBugSpawnerWeapon::OnRefundShotTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBugSpawnerWeapon", "OnRefundShotTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBugSpawnerWeapon.OnRep_NewSpawnerWeapon
// (Final, Native, Protected)

void ANPCBugSpawnerWeapon::OnRep_NewSpawnerWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBugSpawnerWeapon", "OnRep_NewSpawnerWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBugSpawnerWeapon.Server_HandleProjectileImpactOnClient
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// struct FWeaponImpactData                WeaponImpactData                                       (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              RelativePosition                                       (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBugSpawnerWeapon::Server_HandleProjectileImpactOnClient(const struct FWeaponImpactData& WeaponImpactData, const struct FVector_NetQuantize& RelativePosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBugSpawnerWeapon", "Server_HandleProjectileImpactOnClient");

	Params::NPCBugSpawnerWeapon_Server_HandleProjectileImpactOnClient Parms{};

	Parms.WeaponImpactData = std::move(WeaponImpactData);
	Parms.RelativePosition = std::move(RelativePosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCBugSpawnerWeapon.ShootFromAnim
// (Final, Native, Public, BlueprintCallable)

void ANPCBugSpawnerWeapon::ShootFromAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBugSpawnerWeapon", "ShootFromAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCGuardComponent.FOnLoSChange
// (Final, Native, Protected)
// Parameters:
// class AActor*                           AffectedActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsSeen                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCGuardComponent::FOnLoSChange(class AActor* AffectedActor, bool bIsSeen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCGuardComponent", "FOnLoSChange");

	Params::NPCGuardComponent_FOnLoSChange Parms{};

	Parms.AffectedActor = AffectedActor;
	Parms.bIsSeen = bIsSeen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCGuardComponent.NetMulticast_OnKillSpy
// (Net, Native, Event, NetMulticast, Protected)
// Parameters:
// class ASpy*                             KilledSpy                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCGuardComponent::NetMulticast_OnKillSpy(class ASpy* KilledSpy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCGuardComponent", "NetMulticast_OnKillSpy");

	Params::NPCGuardComponent_NetMulticast_OnKillSpy Parms{};

	Parms.KilledSpy = KilledSpy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCGuardComponent.OnKillSpyNotify
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             KilledSpy                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCGuardComponent::OnKillSpyNotify(class ASpy* KilledSpy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCGuardComponent", "OnKillSpyNotify");

	Params::NPCGuardComponent_OnKillSpyNotify Parms{};

	Parms.KilledSpy = KilledSpy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCGuardComponent.OnMoveAfterMeleeTimerEnd
// (Final, Native, Public)

void UNPCGuardComponent::OnMoveAfterMeleeTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCGuardComponent", "OnMoveAfterMeleeTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCGuardComponent.OnRep_AggroTargetActor
// (Final, Native, Protected)
// Parameters:
// class AActor*                           PrevAggroTarget                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCGuardComponent::OnRep_AggroTargetActor(class AActor* PrevAggroTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCGuardComponent", "OnRep_AggroTargetActor");

	Params::NPCGuardComponent_OnRep_AggroTargetActor Parms{};

	Parms.PrevAggroTarget = PrevAggroTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCGuardComponent.OnRep_InvestigationState
// (Final, Native, Protected)

void UNPCGuardComponent::OnRep_InvestigationState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCGuardComponent", "OnRep_InvestigationState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCGuardComponent.OnRep_InvestigationType
// (Final, Native, Public)
// Parameters:
// EInvestigationType                      PrevType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCGuardComponent::OnRep_InvestigationType(EInvestigationType PrevType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCGuardComponent", "OnRep_InvestigationType");

	Params::NPCGuardComponent_OnRep_InvestigationType Parms{};

	Parms.PrevType = PrevType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCGuardComponent.OnRep_LookingAtAggroTarget
// (Final, Native, Protected)

void UNPCGuardComponent::OnRep_LookingAtAggroTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCGuardComponent", "OnRep_LookingAtAggroTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCGuardComponent.OnRep_RotationAnimationType
// (Final, Native, Public)
// Parameters:
// ERotationAnimationType                  PrevType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCGuardComponent::OnRep_RotationAnimationType(ERotationAnimationType PrevType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCGuardComponent", "OnRep_RotationAnimationType");

	Params::NPCGuardComponent_OnRep_RotationAnimationType Parms{};

	Parms.PrevType = PrevType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCGuardComponent.OnRep_WeaponChanged
// (Final, Native, Public)
// Parameters:
// class AHitscanWeapon*                   OldWeapon                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCGuardComponent::OnRep_WeaponChanged(class AHitscanWeapon* OldWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCGuardComponent", "OnRep_WeaponChanged");

	Params::NPCGuardComponent_OnRep_WeaponChanged Parms{};

	Parms.OldWeapon = OldWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCGuardComponent.OnRunDelayTimerEnd
// (Final, Native, Public)

void UNPCGuardComponent::OnRunDelayTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCGuardComponent", "OnRunDelayTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCGuardComponent.OnStopIntestigationTimerEnd
// (Final, Native, Public)

void UNPCGuardComponent::OnStopIntestigationTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCGuardComponent", "OnStopIntestigationTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCGuardComponent.OnUpdateWeaponVisibilityTimerEnd
// (Final, Native, Public)

void UNPCGuardComponent::OnUpdateWeaponVisibilityTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCGuardComponent", "OnUpdateWeaponVisibilityTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCGuardComponent.OnVisibilityChanged
// (Final, Native, Public)
// Parameters:
// bool                                    bIsVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCGuardComponent::OnVisibilityChanged(bool bIsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCGuardComponent", "OnVisibilityChanged");

	Params::NPCGuardComponent_OnVisibilityChanged Parms{};

	Parms.bIsVisible = bIsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCGuardComponent.ShowWeaponFromAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCGuardComponent::ShowWeaponFromAnimation(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCGuardComponent", "ShowWeaponFromAnimation");

	Params::NPCGuardComponent_ShowWeaponFromAnimation Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.NPCGuardComponent.GetInvestigationType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInvestigationType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInvestigationType UNPCGuardComponent::GetInvestigationType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCGuardComponent", "GetInvestigationType");

	Params::NPCGuardComponent_GetInvestigationType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.NPCGuardComponent.IsAggroed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNPCGuardComponent::IsAggroed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCGuardComponent", "IsAggroed");

	Params::NPCGuardComponent_IsAggroed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ObjectSpawn.OnRep_SpawnedActor
// (Final, Native, Protected)

void AObjectSpawn::OnRep_SpawnedActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectSpawn", "OnRep_SpawnedActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ObjectSpawn.UpdateConnectedRoomsReference
// (Final, Native, Public)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AObjectSpawn::UpdateConnectedRoomsReference(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectSpawn", "UpdateConnectedRoomsReference");

	Params::ObjectSpawn_UpdateConnectedRoomsReference Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ObjectSpawn.GetSpawnedObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AObjectSpawn::GetSpawnedObject() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectSpawn", "GetSpawnedObject");

	Params::ObjectSpawn_GetSpawnedObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ObjectSpawningManager.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AObjectSpawningManager*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AObjectSpawningManager* AObjectSpawningManager::Get(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ObjectSpawningManager", "Get");

	Params::ObjectSpawningManager_Get Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ObjectSpawningManager.GetObjectSpawnPresetsData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDIObjectSpawnPresetsDataAsset*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDIObjectSpawnPresetsDataAsset* AObjectSpawningManager::GetObjectSpawnPresetsData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectSpawningManager", "GetObjectSpawnPresetsData");

	Params::ObjectSpawningManager_GetObjectSpawnPresetsData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ObjectSpawningManager.GetObjectsToSpawnCountData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDIObjectsToSpawnCountDataAsset*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDIObjectsToSpawnCountDataAsset* AObjectSpawningManager::GetObjectsToSpawnCountData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectSpawningManager", "GetObjectsToSpawnCountData");

	Params::ObjectSpawningManager_GetObjectsToSpawnCountData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ObjectSpawningManager.GetObjectsToSpawnData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDIObjectsToSpawnDataAsset*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDIObjectsToSpawnDataAsset* AObjectSpawningManager::GetObjectsToSpawnData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectSpawningManager", "GetObjectsToSpawnData");

	Params::ObjectSpawningManager_GetObjectsToSpawnData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ObjectSpawningManager.HandleAllRoomsSetup
// (Final, Native, Public)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AObjectSpawningManager::HandleAllRoomsSetup(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectSpawningManager", "HandleAllRoomsSetup");

	Params::ObjectSpawningManager_HandleAllRoomsSetup Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ThrowableWeapon.OnShootDelayTimerEnd
// (Final, Native, Protected)

void UThrowableWeapon::OnShootDelayTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowableWeapon", "OnShootDelayTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ThrowableWeapon.OnSpyToolEvent
// (Final, Native, Protected)
// Parameters:
// ESpyToolEvent                           EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThrowableWeapon::OnSpyToolEvent(ESpyToolEvent EventType, class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowableWeapon", "OnSpyToolEvent");

	Params::ThrowableWeapon_OnSpyToolEvent Parms{};

	Parms.EventType = EventType;
	Parms.SpyTool = SpyTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ThrowableWeapon.ReloadThrowProjectile
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FVector_NetQuantize              DestinationPos                                         (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThrowableWeapon::ReloadThrowProjectile(const struct FVector_NetQuantize& DestinationPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowableWeapon", "ReloadThrowProjectile");

	Params::ThrowableWeapon_ReloadThrowProjectile Parms{};

	Parms.DestinationPos = std::move(DestinationPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ThrowableWeapon.ReloadThrowStart
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void UThrowableWeapon::ReloadThrowStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowableWeapon", "ReloadThrowStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ThrowableWeapon.ShouldReloadThrow
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UThrowableWeapon::ShouldReloadThrow() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowableWeapon", "ShouldReloadThrow");

	Params::ThrowableWeapon_ShouldReloadThrow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.OctoActiveAbilityMod2.OnSeenSpyUndercoverChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bUndercover                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOctoActiveAbilityMod2::OnSeenSpyUndercoverChanged(bool bUndercover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoActiveAbilityMod2", "OnSeenSpyUndercoverChanged");

	Params::OctoActiveAbilityMod2_OnSeenSpyUndercoverChanged Parms{};

	Parms.bUndercover = bUndercover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.OctoActiveAbilityMod2.Server_SpySeenChange
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class ASpy*                             SpyIn                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSeenIn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOctoActiveAbilityMod2::Server_SpySeenChange(class ASpy* SpyIn, bool bSeenIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoActiveAbilityMod2", "Server_SpySeenChange");

	Params::OctoActiveAbilityMod2_Server_SpySeenChange Parms{};

	Parms.SpyIn = SpyIn;
	Parms.bSeenIn = bSeenIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.OctoIntelDrainZoneVisualFeedback.OnRep_FactionsEffectingZone
// (Final, Native, Protected)

void AOctoIntelDrainZoneVisualFeedback::OnRep_FactionsEffectingZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoIntelDrainZoneVisualFeedback", "OnRep_FactionsEffectingZone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.OctoIntelDrainZoneVisualFeedback.OnRep_IntelActor
// (Final, Native, Protected)

void AOctoIntelDrainZoneVisualFeedback::OnRep_IntelActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoIntelDrainZoneVisualFeedback", "OnRep_IntelActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.OctoIntelDrainZoneVisualFeedback.GetIntelActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABaseIntelActor*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABaseIntelActor* AOctoIntelDrainZoneVisualFeedback::GetIntelActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoIntelDrainZoneVisualFeedback", "GetIntelActor");

	Params::OctoIntelDrainZoneVisualFeedback_GetIntelActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.OctoIntelDrainZoneVisualFeedback.GetRefCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOctoIntelDrainZoneVisualFeedback::GetRefCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OctoIntelDrainZoneVisualFeedback", "GetRefCount");

	Params::OctoIntelDrainZoneVisualFeedback_GetRefCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PlayerBPLibrary.GetHUDPlayerSpy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASpy* UPlayerBPLibrary::GetHUDPlayerSpy(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerBPLibrary", "GetHUDPlayerSpy");

	Params::PlayerBPLibrary_GetHUDPlayerSpy Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PlayerBPLibrary.GetWatchingPlayerDisguiseMesh
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMesh* UPlayerBPLibrary::GetWatchingPlayerDisguiseMesh(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerBPLibrary", "GetWatchingPlayerDisguiseMesh");

	Params::PlayerBPLibrary_GetWatchingPlayerDisguiseMesh Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PlayerBPLibrary.GetWatchingPlayerSpy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASpy* UPlayerBPLibrary::GetWatchingPlayerSpy(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerBPLibrary", "GetWatchingPlayerSpy");

	Params::PlayerBPLibrary_GetWatchingPlayerSpy Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PlayerBPLibrary.IsSpectating
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerBPLibrary::IsSpectating(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerBPLibrary", "IsSpectating");

	Params::PlayerBPLibrary_IsSpectating Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PlayerTalkingWidget.BP_OnPlayerChange
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FString                           NewPlayerName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerTalkingWidget::BP_OnPlayerChange(const class FString& NewPlayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerTalkingWidget", "BP_OnPlayerChange");

	Params::PlayerTalkingWidget_BP_OnPlayerChange Parms{};

	Parms.NewPlayerName = std::move(NewPlayerName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.PlayerTalkingWidget.BP_OnPlayerTalkBegin
// (Event, Protected, BlueprintEvent)

void UPlayerTalkingWidget::BP_OnPlayerTalkBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerTalkingWidget", "BP_OnPlayerTalkBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.PlayerTalkingWidget.BP_OnPlayerTalkEnd
// (Event, Protected, BlueprintEvent)

void UPlayerTalkingWidget::BP_OnPlayerTalkEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerTalkingWidget", "BP_OnPlayerTalkEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.PlayerTalkingWidget.HandlePlayerTakingUpdate
// (Final, Native, Protected)
// Parameters:
// bool                                    bTalking                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerTalkingWidget::HandlePlayerTakingUpdate(bool bTalking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerTalkingWidget", "HandlePlayerTakingUpdate");

	Params::PlayerTalkingWidget_HandlePlayerTakingUpdate Parms{};

	Parms.bTalking = bTalking;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PlayerTalkingWidget.GetNormalizedAmplitude
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerTalkingWidget::GetNormalizedAmplitude() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerTalkingWidget", "GetNormalizedAmplitude");

	Params::PlayerTalkingWidget_GetNormalizedAmplitude Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PlayerTalkingWidget.GetPlayerName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UPlayerTalkingWidget::GetPlayerName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerTalkingWidget", "GetPlayerName");

	Params::PlayerTalkingWidget_GetPlayerName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PlayerTalkingWidget.GetPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADIPlayerState*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADIPlayerState* UPlayerTalkingWidget::GetPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerTalkingWidget", "GetPlayerState");

	Params::PlayerTalkingWidget_GetPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PlayerTalkingWidget.IsPlayerTalking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerTalkingWidget::IsPlayerTalking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerTalkingWidget", "IsPlayerTalking");

	Params::PlayerTalkingWidget_IsPlayerTalking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PlayerTalkingWidget.IsValid
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerTalkingWidget::IsValid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerTalkingWidget", "IsValid");

	Params::PlayerTalkingWidget_IsValid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VigilActiveAbility.GetAbilityWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AProjectileWeapon*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AProjectileWeapon* AVigilActiveAbility::GetAbilityWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilActiveAbility", "GetAbilityWeapon");

	Params::VigilActiveAbility_GetAbilityWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VigilActiveAbility.OnRep_ReplicatedAbilityWeapon
// (Final, Native, Protected)
// Parameters:
// class AProjectileWeapon*                PrevWeapon                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVigilActiveAbility::OnRep_ReplicatedAbilityWeapon(class AProjectileWeapon* PrevWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilActiveAbility", "OnRep_ReplicatedAbilityWeapon");

	Params::VigilActiveAbility_OnRep_ReplicatedAbilityWeapon Parms{};

	Parms.PrevWeapon = PrevWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilActiveAbility.OnResourceAmountChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   TotalBulletLeft                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVigilActiveAbility::OnResourceAmountChanged(int32 TotalBulletLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilActiveAbility", "OnResourceAmountChanged");

	Params::VigilActiveAbility_OnResourceAmountChanged Parms{};

	Parms.TotalBulletLeft = TotalBulletLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilActiveAbility.OnUnequipDelayTimerEnd
// (Final, Native, Protected)

void AVigilActiveAbility::OnUnequipDelayTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilActiveAbility", "OnUnequipDelayTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilActiveAbility.OnWeaponEvent
// (Final, Native, Protected)
// Parameters:
// ESpyToolEvent                           EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVigilActiveAbility::OnWeaponEvent(ESpyToolEvent EventType, class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilActiveAbility", "OnWeaponEvent");

	Params::VigilActiveAbility_OnWeaponEvent Parms{};

	Parms.EventType = EventType;
	Parms.SpyTool = SpyTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PopulationManager.BP_TriggerDangerEventAtPos
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           DangerCause                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DangerPos                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APopulationManager::BP_TriggerDangerEventAtPos(class AActor* DangerCause, const struct FVector& DangerPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PopulationManager", "BP_TriggerDangerEventAtPos");

	Params::PopulationManager_BP_TriggerDangerEventAtPos Parms{};

	Parms.DangerCause = DangerCause;
	Parms.DangerPos = std::move(DangerPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PopulationManager.HandleSpySpawnedEvent
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APopulationManager::HandleSpySpawnedEvent(class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PopulationManager", "HandleSpySpawnedEvent");

	Params::PopulationManager_HandleSpySpawnedEvent Parms{};

	Parms.Spy = Spy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PopulationManager.OnGamePhaseChanged
// (Final, Native, Protected)
// Parameters:
// ESpyGamePhase                           NewGamePhase                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APopulationManager::OnGamePhaseChanged(ESpyGamePhase NewGamePhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PopulationManager", "OnGamePhaseChanged");

	Params::PopulationManager_OnGamePhaseChanged Parms{};

	Parms.NewGamePhase = NewGamePhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PopulationManager.OnVaultTerminalUnlockedCountChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   VaultTerminalUnlockedCount                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APopulationManager::OnVaultTerminalUnlockedCountChanged(int32 VaultTerminalUnlockedCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PopulationManager", "OnVaultTerminalUnlockedCountChanged");

	Params::PopulationManager_OnVaultTerminalUnlockedCountChanged Parms{};

	Parms.VaultTerminalUnlockedCount = VaultTerminalUnlockedCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VoicechatMemberContainerWidget.FreeSlotForMemberWidget
// (Event, Public, BlueprintEvent)
// Parameters:
// class UVoicechatMemberWidget*           MemberWidget                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoicechatMemberContainerWidget::FreeSlotForMemberWidget(class UVoicechatMemberWidget* MemberWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoicechatMemberContainerWidget", "FreeSlotForMemberWidget");

	Params::VoicechatMemberContainerWidget_FreeSlotForMemberWidget Parms{};

	Parms.MemberWidget = MemberWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.VoicechatMemberContainerWidget.HandleChatMemberTalkingEvent
// (Final, Native, Protected)
// Parameters:
// class FString                           PlayerChatID                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ChannelName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTalking                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoicechatMemberContainerWidget::HandleChatMemberTalkingEvent(const class FString& PlayerChatID, const class FString& ChannelName, bool bTalking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoicechatMemberContainerWidget", "HandleChatMemberTalkingEvent");

	Params::VoicechatMemberContainerWidget_HandleChatMemberTalkingEvent Parms{};

	Parms.PlayerChatID = std::move(PlayerChatID);
	Parms.ChannelName = std::move(ChannelName);
	Parms.bTalking = bTalking;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VoicechatMemberContainerWidget.HandleVoiceChatPlayerRemovedFromChannel
// (Final, Native, Protected)
// Parameters:
// class FString                           PlayerChatID                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ChannelName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoicechatMemberContainerWidget::HandleVoiceChatPlayerRemovedFromChannel(const class FString& PlayerChatID, const class FString& ChannelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoicechatMemberContainerWidget", "HandleVoiceChatPlayerRemovedFromChannel");

	Params::VoicechatMemberContainerWidget_HandleVoiceChatPlayerRemovedFromChannel Parms{};

	Parms.PlayerChatID = std::move(PlayerChatID);
	Parms.ChannelName = std::move(ChannelName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VoicechatMemberContainerWidget.ReserveSlotForMemberWidget
// (Event, Public, BlueprintEvent)
// Parameters:
// class UVoicechatMemberWidget*           MemberWidget                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoicechatMemberContainerWidget::ReserveSlotForMemberWidget(class UVoicechatMemberWidget* MemberWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoicechatMemberContainerWidget", "ReserveSlotForMemberWidget");

	Params::VoicechatMemberContainerWidget_ReserveSlotForMemberWidget Parms{};

	Parms.MemberWidget = MemberWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.PosingSpyActorContainer.ClearAnimationProps
// (Final, Native, Public, BlueprintCallable)

void UPosingSpyActorContainer::ClearAnimationProps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpyActorContainer", "ClearAnimationProps");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpyActorContainer.CreateAnimationProp
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimationPropData               PropsIn                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bLooping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPosingSpyActorContainer::CreateAnimationProp(const struct FAnimationPropData& PropsIn, bool bLooping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpyActorContainer", "CreateAnimationProp");

	Params::PosingSpyActorContainer_CreateAnimationProp Parms{};

	Parms.PropsIn = std::move(PropsIn);
	Parms.bLooping = bLooping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpyActorContainer.CreateAnimationProps
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FAnimationPropData>       PropIn                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bLooping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPosingSpyActorContainer::CreateAnimationProps(const TArray<struct FAnimationPropData>& PropIn, bool bLooping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpyActorContainer", "CreateAnimationProps");

	Params::PosingSpyActorContainer_CreateAnimationProps Parms{};

	Parms.PropIn = std::move(PropIn);
	Parms.bLooping = bLooping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpyActorContainer.CreateChildren
// (Final, Native, Public, BlueprintCallable)

void UPosingSpyActorContainer::CreateChildren()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpyActorContainer", "CreateChildren");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpyActorContainer.DestroyOwnerChildren
// (Final, Native, Public, BlueprintCallable)

void UPosingSpyActorContainer::DestroyOwnerChildren()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpyActorContainer", "DestroyOwnerChildren");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpyActorContainer.HandleDisplayedWrapChangedDelegate
// (Final, Native, Protected, HasDefaults)
// Parameters:
// struct FPrimaryAssetId                  WeaponId                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  WrapId                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DisplayedWrapIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPosingSpyActorContainer::HandleDisplayedWrapChangedDelegate(const struct FPrimaryAssetId& WeaponId, const struct FPrimaryAssetId& WrapId, int32 DisplayedWrapIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpyActorContainer", "HandleDisplayedWrapChangedDelegate");

	Params::PosingSpyActorContainer_HandleDisplayedWrapChangedDelegate Parms{};

	Parms.WeaponId = std::move(WeaponId);
	Parms.WrapId = std::move(WrapId);
	Parms.DisplayedWrapIndex = DisplayedWrapIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpyActorContainer.HandleLoadoutSpawnComplete
// (Final, Native, Protected)
// Parameters:
// class UToolLoadoutComponent*            ToolLoadout                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPosingSpyActorContainer::HandleLoadoutSpawnComplete(class UToolLoadoutComponent* ToolLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpyActorContainer", "HandleLoadoutSpawnComplete");

	Params::PosingSpyActorContainer_HandleLoadoutSpawnComplete Parms{};

	Parms.ToolLoadout = ToolLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpyActorContainer.HandlePlayerStateModified
// (Final, Native, Protected)

void UPosingSpyActorContainer::HandlePlayerStateModified()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpyActorContainer", "HandlePlayerStateModified");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpyActorContainer.HandleSpySpawnedEvent
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPosingSpyActorContainer::HandleSpySpawnedEvent(class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpyActorContainer", "HandleSpySpawnedEvent");

	Params::PosingSpyActorContainer_HandleSpySpawnedEvent Parms{};

	Parms.Spy = Spy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpyActorContainer.HandleStateArrayModified
// (Final, Native, Protected)

void UPosingSpyActorContainer::HandleStateArrayModified()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpyActorContainer", "HandleStateArrayModified");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpyActorContainer.OnDelayedIntroPoseTimer
// (Final, Native, Protected)

void UPosingSpyActorContainer::OnDelayedIntroPoseTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpyActorContainer", "OnDelayedIntroPoseTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpyActorContainer.OnDisplayedAgentChangedDelegate
// (Final, Native, Protected, HasDefaults)
// Parameters:
// struct FPrimaryAssetId                  AgentSkinId                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DisplayedAgentIndex                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPosingSpyActorContainer::OnDisplayedAgentChangedDelegate(const struct FPrimaryAssetId& AgentSkinId, int32 DisplayedAgentIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpyActorContainer", "OnDisplayedAgentChangedDelegate");

	Params::PosingSpyActorContainer_OnDisplayedAgentChangedDelegate Parms{};

	Parms.AgentSkinId = std::move(AgentSkinId);
	Parms.DisplayedAgentIndex = DisplayedAgentIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpyActorContainer.OnDisplayedIntroPoseChangedDelegate
// (Final, Native, Protected, HasDefaults)
// Parameters:
// struct FPrimaryAssetId                  IntroPoseId                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DisplayedAgentIndex                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPosingSpyActorContainer::OnDisplayedIntroPoseChangedDelegate(const struct FPrimaryAssetId& IntroPoseId, int32 DisplayedAgentIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpyActorContainer", "OnDisplayedIntroPoseChangedDelegate");

	Params::PosingSpyActorContainer_OnDisplayedIntroPoseChangedDelegate Parms{};

	Parms.IntroPoseId = std::move(IntroPoseId);
	Parms.DisplayedAgentIndex = DisplayedAgentIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpyActorContainer.OnIntroPoseLoop
// (Final, Native, Protected)

void UPosingSpyActorContainer::OnIntroPoseLoop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpyActorContainer", "OnIntroPoseLoop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpyActorContainer.PlayIntroPoseAnimation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  IntroPoseId                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStartPaused                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPosingSpyActorContainer::PlayIntroPoseAnimation(const struct FPrimaryAssetId& IntroPoseId, bool bStartPaused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpyActorContainer", "PlayIntroPoseAnimation");

	Params::PosingSpyActorContainer_PlayIntroPoseAnimation Parms{};

	Parms.IntroPoseId = std::move(IntroPoseId);
	Parms.bStartPaused = bStartPaused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpyActorContainer.PlaySelectedIntroPoseAnimation
// (Final, Native, Public, BlueprintCallable)

void UPosingSpyActorContainer::PlaySelectedIntroPoseAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpyActorContainer", "PlaySelectedIntroPoseAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpyActorContainer.SetupFromPlayerState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADIPlayerState*                   DIPlayeState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPosingSpyActorContainer::SetupFromPlayerState(class ADIPlayerState* DIPlayeState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpyActorContainer", "SetupFromPlayerState");

	Params::PosingSpyActorContainer_SetupFromPlayerState Parms{};

	Parms.DIPlayeState = DIPlayeState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.PosingSpyAnimInstance.BP_SetAnimationPaused
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bPaused                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPosingSpyAnimInstance::BP_SetAnimationPaused(bool bPaused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PosingSpyAnimInstance", "BP_SetAnimationPaused");

	Params::PosingSpyAnimInstance_BP_SetAnimationPaused Parms{};

	Parms.bPaused = bPaused;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.PoudrierActor.GetActiveSpyTool
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABaseSpyTool*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABaseSpyTool* APoudrierActor::GetActiveSpyTool() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoudrierActor", "GetActiveSpyTool");

	Params::PoudrierActor_GetActiveSpyTool Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.WebStreamedVisualAsset.LoadAndApplyAssetToCanvas
// (Final, Native, Public, BlueprintCallable)

void AWebStreamedVisualAsset::LoadAndApplyAssetToCanvas()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WebStreamedVisualAsset", "LoadAndApplyAssetToCanvas");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.WebStreamedVisualAsset.SetWebAssetDefinition
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FWebStreamedAssetDefinition      InAssetDefinition                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AWebStreamedVisualAsset::SetWebAssetDefinition(const struct FWebStreamedAssetDefinition& InAssetDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WebStreamedVisualAsset", "SetWebAssetDefinition");

	Params::WebStreamedVisualAsset_SetWebAssetDefinition Parms{};

	Parms.InAssetDefinition = std::move(InAssetDefinition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.WebStreamedVisualAsset.GetWebAssetDefinition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FWebStreamedAssetDefinitionReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FWebStreamedAssetDefinition AWebStreamedVisualAsset::GetWebAssetDefinition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WebStreamedVisualAsset", "GetWebAssetDefinition");

	Params::WebStreamedVisualAsset_GetWebAssetDefinition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PowerupManagerComponent.GetExfiltratorData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FExfiltratorData                 FoodieData                                             (Parm, OutParm, NativeAccessSpecifierPublic)

void UPowerupManagerComponent::GetExfiltratorData(const class UObject* WorldContextObject, struct FExfiltratorData* FoodieData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PowerupManagerComponent", "GetExfiltratorData");

	Params::PowerupManagerComponent_GetExfiltratorData Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FoodieData != nullptr)
		*FoodieData = std::move(Parms.FoodieData);
}


// Function DeceiveInc.PowerupManagerComponent.GetFoodieData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFoodieData                      FoodieData                                             (Parm, OutParm, NativeAccessSpecifierPublic)

void UPowerupManagerComponent::GetFoodieData(const class UObject* WorldContextObject, struct FFoodieData* FoodieData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PowerupManagerComponent", "GetFoodieData");

	Params::PowerupManagerComponent_GetFoodieData Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FoodieData != nullptr)
		*FoodieData = std::move(Parms.FoodieData);
}


// Function DeceiveInc.PowerupManagerComponent.GetPowerupForLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ASpy*                             SpyToCheck                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESecurityLevel                          Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPowerupType                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPowerupType UPowerupManagerComponent::GetPowerupForLevel(class ASpy* SpyToCheck, ESecurityLevel Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PowerupManagerComponent", "GetPowerupForLevel");

	Params::PowerupManagerComponent_GetPowerupForLevel Parms{};

	Parms.SpyToCheck = SpyToCheck;
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.PowerupManagerComponent.GetPowerupInfos
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPowerupType                            PowerupType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPowerupInfo                     PowerupInfo                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UPowerupManagerComponent::GetPowerupInfos(const class UObject* WorldContextObject, EPowerupType PowerupType, struct FPowerupInfo* PowerupInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PowerupManagerComponent", "GetPowerupInfos");

	Params::PowerupManagerComponent_GetPowerupInfos Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PowerupType = PowerupType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PowerupInfo != nullptr)
		*PowerupInfo = std::move(Parms.PowerupInfo);
}


// Function DeceiveInc.PowerupManagerComponent.GetSocialBatteryData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSocialBatteryData               SocialBatteryData                                      (Parm, OutParm, NativeAccessSpecifierPublic)

void UPowerupManagerComponent::GetSocialBatteryData(const class UObject* WorldContextObject, struct FSocialBatteryData* SocialBatteryData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PowerupManagerComponent", "GetSocialBatteryData");

	Params::PowerupManagerComponent_GetSocialBatteryData Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SocialBatteryData != nullptr)
		*SocialBatteryData = std::move(Parms.SocialBatteryData);
}


// Function DeceiveInc.XiuPassiveAbilityMod1.HandleOnNonLocalHealthChangeEvent
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UHealthComponent*                 OwningHealthComp                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Health                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HealthDelta                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AXiuPassiveAbilityMod1::HandleOnNonLocalHealthChangeEvent(class ASpy* Spy, class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuPassiveAbilityMod1", "HandleOnNonLocalHealthChangeEvent");

	Params::XiuPassiveAbilityMod1_HandleOnNonLocalHealthChangeEvent Parms{};

	Parms.Spy = Spy;
	Parms.OwningHealthComp = OwningHealthComp;
	Parms.Health = Health;
	Parms.HealthDelta = HealthDelta;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.RangePlacementComponent.GetRemainingCharges
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URangePlacementComponent::GetRemainingCharges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangePlacementComponent", "GetRemainingCharges");

	Params::RangePlacementComponent_GetRemainingCharges Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.RangePlacementComponent.HandleResourceNewAmount
// (Final, Native, Protected)
// Parameters:
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ResourceDisplayName                                    (Parm, NativeAccessSpecifierPublic)
// int32                                   NewAmount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URangePlacementComponent::HandleResourceNewAmount(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 NewAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangePlacementComponent", "HandleResourceNewAmount");

	Params::RangePlacementComponent_HandleResourceNewAmount Parms{};

	Parms.ResourceType = ResourceType;
	Parms.ResourceDisplayName = std::move(ResourceDisplayName);
	Parms.NewAmount = NewAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.RangePlacementComponent.HasEnoughCharges
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URangePlacementComponent::HasEnoughCharges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangePlacementComponent", "HasEnoughCharges");

	Params::RangePlacementComponent_HasEnoughCharges Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.RangePlacementComponent.ServerSpawnPlaceable
// (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector_NetQuantize              SpawnLocation                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         SpawnRotation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        TargetNormal                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDrop                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnLocalOnly                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URangePlacementComponent::ServerSpawnPlaceable(const struct FVector_NetQuantize& SpawnLocation, const struct FRotator& SpawnRotation, const struct FVector_NetQuantizeNormal& TargetNormal, bool bDrop, bool bSpawnLocalOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangePlacementComponent", "ServerSpawnPlaceable");

	Params::RangePlacementComponent_ServerSpawnPlaceable Parms{};

	Parms.SpawnLocation = std::move(SpawnLocation);
	Parms.SpawnRotation = std::move(SpawnRotation);
	Parms.TargetNormal = std::move(TargetNormal);
	Parms.bDrop = bDrop;
	Parms.bSpawnLocalOnly = bSpawnLocalOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.RangePlacementComponent.SetPositioning
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    _bPositioning                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URangePlacementComponent::SetPositioning(bool _bPositioning)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangePlacementComponent", "SetPositioning");

	Params::RangePlacementComponent_SetPositioning Parms{};

	Parms._bPositioning = _bPositioning;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.RangePlacementComponent.IsPositionerVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URangePlacementComponent::IsPositionerVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangePlacementComponent", "IsPositionerVisible");

	Params::RangePlacementComponent_IsPositionerVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SquirePassiveAbility.BP_OnSquirePassiveGiveSpeedBoost
// (Event, Protected, BlueprintEvent)

void ASquirePassiveAbility::BP_OnSquirePassiveGiveSpeedBoost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquirePassiveAbility", "BP_OnSquirePassiveGiveSpeedBoost");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.SquirePassiveAbility.BP_OnSquirePassiveRevokeSpeedBoost
// (Event, Protected, BlueprintEvent)

void ASquirePassiveAbility::BP_OnSquirePassiveRevokeSpeedBoost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquirePassiveAbility", "BP_OnSquirePassiveRevokeSpeedBoost");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.SquirePassiveAbility.HandleBoostDurationCooldownChange
// (Final, Native, Protected)
// Parameters:
// bool                                    OnCooldown                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASquirePassiveAbility::HandleBoostDurationCooldownChange(bool OnCooldown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquirePassiveAbility", "HandleBoostDurationCooldownChange");

	Params::SquirePassiveAbility_HandleBoostDurationCooldownChange Parms{};

	Parms.OnCooldown = OnCooldown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SquirePassiveAbility.HandleUnderCoverChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bUndercover                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASquirePassiveAbility::HandleUnderCoverChanged(bool bUndercover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquirePassiveAbility", "HandleUnderCoverChanged");

	Params::SquirePassiveAbility_HandleUnderCoverChanged Parms{};

	Parms.bUndercover = bUndercover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.RemoteTurret.HandleAggroTargetChange
// (Final, Native, Protected)
// Parameters:
// class AActor*                           NewTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARemoteTurret::HandleAggroTargetChange(class AActor* NewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RemoteTurret", "HandleAggroTargetChange");

	Params::RemoteTurret_HandleAggroTargetChange Parms{};

	Parms.NewTarget = NewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.RemoteTurret.HandleAggroTargetLost
// (Final, Native, Protected)

void ARemoteTurret::HandleAggroTargetLost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RemoteTurret", "HandleAggroTargetLost");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.RemoteTurret.HandlePhaseChanged
// (Final, Native, Protected)
// Parameters:
// ESpyGamePhase                           NewGamePhase                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARemoteTurret::HandlePhaseChanged(ESpyGamePhase NewGamePhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RemoteTurret", "HandlePhaseChanged");

	Params::RemoteTurret_HandlePhaseChanged Parms{};

	Parms.NewGamePhase = NewGamePhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.RemoteTurret.HandleSpyMovementEvent
// (Final, Native, Protected)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementEventType                      MovementEventType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARemoteTurret::HandleSpyMovementEvent(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, EMovementEventType MovementEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RemoteTurret", "HandleSpyMovementEvent");

	Params::RemoteTurret_HandleSpyMovementEvent Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;
	Parms.MovementEventType = MovementEventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.RemoteTurret.HandleSpyToolEvent
// (Final, Native, Protected)
// Parameters:
// ESpyToolEvent                           EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARemoteTurret::HandleSpyToolEvent(ESpyToolEvent EventType, class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RemoteTurret", "HandleSpyToolEvent");

	Params::RemoteTurret_HandleSpyToolEvent Parms{};

	Parms.EventType = EventType;
	Parms.SpyTool = SpyTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.RemoteTurret.HandleStateChange
// (Final, Native, Protected)
// Parameters:
// ERemoteTurretAIState                    OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERemoteTurretAIState                    NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARemoteTurret::HandleStateChange(ERemoteTurretAIState OldState, ERemoteTurretAIState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RemoteTurret", "HandleStateChange");

	Params::RemoteTurret_HandleStateChange Parms{};

	Parms.OldState = OldState;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.RemoteTurret.OnRep_NewTurretSpawnerWeapon
// (Final, Native, Protected)

void ARemoteTurret::OnRep_NewTurretSpawnerWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RemoteTurret", "OnRep_NewTurretSpawnerWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.RemoteTurretTool.HandleOwnerTookDamage
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UHealthComponent*                 SpyHealthComp                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Health                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HealthDelta                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DamageDirection                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARemoteTurretTool::HandleOwnerTookDamage(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, class UHealthComponent* SpyHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& DamageDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RemoteTurretTool", "HandleOwnerTookDamage");

	Params::RemoteTurretTool_HandleOwnerTookDamage Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;
	Parms.SpyHealthComp = SpyHealthComp;
	Parms.Health = Health;
	Parms.HealthDelta = HealthDelta;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.DamageDirection = std::move(DamageDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Sway1PComponent.OnPitchInputDelta
// (Final, Native, Protected)
// Parameters:
// float                                   PitchDelta                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USway1PComponent::OnPitchInputDelta(float PitchDelta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sway1PComponent", "OnPitchInputDelta");

	Params::Sway1PComponent_OnPitchInputDelta Parms{};

	Parms.PitchDelta = PitchDelta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Sway1PComponent.OnSpyAirborneVerticalAccel
// (Final, Native, Protected)
// Parameters:
// float                                   VerticalAccelIn                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USway1PComponent::OnSpyAirborneVerticalAccel(float VerticalAccelIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sway1PComponent", "OnSpyAirborneVerticalAccel");

	Params::Sway1PComponent_OnSpyAirborneVerticalAccel Parms{};

	Parms.VerticalAccelIn = VerticalAccelIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Sway1PComponent.OnSpyGroundStopGoingForward
// (Final, Native, Protected)

void USway1PComponent::OnSpyGroundStopGoingForward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sway1PComponent", "OnSpyGroundStopGoingForward");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Sway1PComponent.OnSpyOwnerPossessedByController
// (Final, Native, Protected)
// Parameters:
// class AController*                      NewController                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USway1PComponent::OnSpyOwnerPossessedByController(class AController* NewController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sway1PComponent", "OnSpyOwnerPossessedByController");

	Params::Sway1PComponent_OnSpyOwnerPossessedByController Parms{};

	Parms.NewController = NewController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Sway1PComponent.OnYawInputDelta
// (Final, Native, Protected)
// Parameters:
// float                                   YawDelta                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USway1PComponent::OnYawInputDelta(float YawDelta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sway1PComponent", "OnYawInputDelta");

	Params::Sway1PComponent_OnYawInputDelta Parms{};

	Parms.YawDelta = YawDelta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Sway1PComponent.GetFactors
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USway1PComponent::GetFactors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Sway1PComponent", "GetFactors");

	Params::Sway1PComponent_GetFactors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ReviveSpyConditionComponent.OnRep_CurrentReviveCount
// (Final, Native, Public)

void UReviveSpyConditionComponent::OnRep_CurrentReviveCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReviveSpyConditionComponent", "OnRep_CurrentReviveCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ReviveSpyConditionComponent.GetCurrentReviveCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UReviveSpyConditionComponent::GetCurrentReviveCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReviveSpyConditionComponent", "GetCurrentReviveCount");

	Params::ReviveSpyConditionComponent_GetCurrentReviveCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ReviveSpyConditionComponent.IsBurned
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UReviveSpyConditionComponent::IsBurned() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReviveSpyConditionComponent", "IsBurned");

	Params::ReviveSpyConditionComponent_IsBurned Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.RoomVolume.OnGoingFightScareNPCsTimerEnd
// (Final, Native, Protected)

void ARoomVolume::OnGoingFightScareNPCsTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoomVolume", "OnGoingFightScareNPCsTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.RoomVolume.OnGoingFightTimerEnd
// (Final, Native, Protected)

void ARoomVolume::OnGoingFightTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoomVolume", "OnGoingFightTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.RoomVolume.UpdateConnectedRoomsReference
// (Final, Native, Public)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARoomVolume::UpdateConnectedRoomsReference(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoomVolume", "UpdateConnectedRoomsReference");

	Params::RoomVolume_UpdateConnectedRoomsReference Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.RoomVolume.UpdateNotAllowedCharacters
// (Final, Native, Protected)

void ARoomVolume::UpdateNotAllowedCharacters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoomVolume", "UpdateNotAllowedCharacters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.RoomVolume.GetCenterValidPos
// (Final, Native, Public, HasDefaults, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ARoomVolume::GetCenterValidPos() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoomVolume", "GetCenterValidPos");

	Params::RoomVolume_GetCenterValidPos Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.RoomVolume.HasOnGoingFightInRoom
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARoomVolume::HasOnGoingFightInRoom() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoomVolume", "HasOnGoingFightInRoom");

	Params::RoomVolume_HasOnGoingFightInRoom Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.RoomVolume.HasOnGoingFightInRoomFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   FlagIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARoomVolume::HasOnGoingFightInRoomFlag(uint8 FlagIn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoomVolume", "HasOnGoingFightInRoomFlag");

	Params::RoomVolume_HasOnGoingFightInRoomFlag Parms{};

	Parms.FlagIn = FlagIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.RoomVolume.IsPosInRoom
// (Final, Native, Public, HasOutParams, HasDefaults, Const)
// Parameters:
// struct FVector                          TestPos                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SphereRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARoomVolume::IsPosInRoom(const struct FVector& TestPos, float SphereRadius) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoomVolume", "IsPosInRoom");

	Params::RoomVolume_IsPosInRoom Parms{};

	Parms.TestPos = std::move(TestPos);
	Parms.SphereRadius = SphereRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SasoriActiveAbility.HandleMeleeAttackDamageDone
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactPoint                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ChargeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageDone                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ResultingHealthPercentage                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHitType                                HitType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMeleeHitConfirmedData           HitConfirmedData                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASasoriActiveAbility::HandleMeleeAttackDamageDone(class AActor* Victim, const struct FVector& ImpactPoint, int32 ChargeLevel, float DamageDone, float ResultingHealthPercentage, EHitType HitType, const struct FMeleeHitConfirmedData& HitConfirmedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SasoriActiveAbility", "HandleMeleeAttackDamageDone");

	Params::SasoriActiveAbility_HandleMeleeAttackDamageDone Parms{};

	Parms.Victim = Victim;
	Parms.ImpactPoint = std::move(ImpactPoint);
	Parms.ChargeLevel = ChargeLevel;
	Parms.DamageDone = DamageDone;
	Parms.ResultingHealthPercentage = ResultingHealthPercentage;
	Parms.HitType = HitType;
	Parms.HitConfirmedData = std::move(HitConfirmedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SasoriActiveAbility.HandleProjectileSpawnAndActivate
// (Final, Native, Protected)
// Parameters:
// class ASpawnerWeapon*                   Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpawnerWeaponRound*              Projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASasoriActiveAbility::HandleProjectileSpawnAndActivate(class ASpawnerWeapon* Weapon, class ASpawnerWeaponRound* Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SasoriActiveAbility", "HandleProjectileSpawnAndActivate");

	Params::SasoriActiveAbility_HandleProjectileSpawnAndActivate Parms{};

	Parms.Weapon = Weapon;
	Parms.Projectile = Projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SasoriActiveAbility.HandleWeaponSpyToolEvent
// (Final, Native, Protected)
// Parameters:
// ESpyToolEvent                           EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASasoriActiveAbility::HandleWeaponSpyToolEvent(ESpyToolEvent EventType, class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SasoriActiveAbility", "HandleWeaponSpyToolEvent");

	Params::SasoriActiveAbility_HandleWeaponSpyToolEvent Parms{};

	Parms.EventType = EventType;
	Parms.SpyTool = SpyTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SasoriActiveAbility.OnCleanupPoisonTimerComplete
// (Final, Native, Protected)

void ASasoriActiveAbility::OnCleanupPoisonTimerComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SasoriActiveAbility", "OnCleanupPoisonTimerComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SasoriActiveAbility.OnDisableWeaponTimerComplete
// (Final, Native, Protected)

void ASasoriActiveAbility::OnDisableWeaponTimerComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SasoriActiveAbility", "OnDisableWeaponTimerComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SasoriActiveAbilityMod2.OnTriggerDelayTimer
// (Native, Protected)

void ASasoriActiveAbilityMod2::OnTriggerDelayTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SasoriActiveAbilityMod2", "OnTriggerDelayTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SasoriPassiveAbilityMod2.HandleMeleeAttackHit
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactPoint                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ChargeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageDone                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ResultingHealthPercentage                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHitType                                HitType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMeleeHitConfirmedData           HitConfirmedData                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASasoriPassiveAbilityMod2::HandleMeleeAttackHit(class AActor* Victim, const struct FVector& ImpactPoint, int32 ChargeLevel, float DamageDone, float ResultingHealthPercentage, EHitType HitType, const struct FMeleeHitConfirmedData& HitConfirmedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SasoriPassiveAbilityMod2", "HandleMeleeAttackHit");

	Params::SasoriPassiveAbilityMod2_HandleMeleeAttackHit Parms{};

	Parms.Victim = Victim;
	Parms.ImpactPoint = std::move(ImpactPoint);
	Parms.ChargeLevel = ChargeLevel;
	Parms.DamageDone = DamageDone;
	Parms.ResultingHealthPercentage = ResultingHealthPercentage;
	Parms.HitType = HitType;
	Parms.HitConfirmedData = std::move(HitConfirmedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SasoriPassiveAbilityMod2.HandleProjectileHit
// (Final, Native, Protected)
// Parameters:
// struct FHitConfirmData                  HitConfirmData                                         (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASasoriPassiveAbilityMod2::HandleProjectileHit(const struct FHitConfirmData& HitConfirmData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SasoriPassiveAbilityMod2", "HandleProjectileHit");

	Params::SasoriPassiveAbilityMod2_HandleProjectileHit Parms{};

	Parms.HitConfirmData = std::move(HitConfirmData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SBAimAssistComponent.HandleBooleanPlayerSettingChange
// (Final, Native, Public)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USBAimAssistComponent::HandleBooleanPlayerSettingChange(EPlayerSettingsType SettingType, bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBAimAssistComponent", "HandleBooleanPlayerSettingChange");

	Params::SBAimAssistComponent_HandleBooleanPlayerSettingChange Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SBAimAssistComponent.OnTargetDestroyed
// (Final, Native, Protected)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USBAimAssistComponent::OnTargetDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBAimAssistComponent", "OnTargetDestroyed");

	Params::SBAimAssistComponent_OnTargetDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SBAimAssistComponent.SetAimAssistDataAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USBAimAssistConfigDataAsset*      DataAsset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USBAimAssistComponent::SetAimAssistDataAsset(class USBAimAssistConfigDataAsset* DataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBAimAssistComponent", "SetAimAssistDataAsset");

	Params::SBAimAssistComponent_SetAimAssistDataAsset Parms{};

	Parms.DataAsset = DataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SBAimAssistComponent.SetAimAssistFactionID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   NewFactionID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USBAimAssistComponent::SetAimAssistFactionID(uint8 NewFactionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBAimAssistComponent", "SetAimAssistFactionID");

	Params::SBAimAssistComponent_SetAimAssistFactionID Parms{};

	Parms.NewFactionID = NewFactionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SBAimAssistComponent.SetAimAssistInfluenceRatio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Ratio                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USBAimAssistComponent::SetAimAssistInfluenceRatio(float Ratio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBAimAssistComponent", "SetAimAssistInfluenceRatio");

	Params::SBAimAssistComponent_SetAimAssistInfluenceRatio Parms{};

	Parms.Ratio = Ratio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SBAimAssistComponent.SetAssistedControllerRotationSpeeds
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   PitchSpeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   YawSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USBAimAssistComponent::SetAssistedControllerRotationSpeeds(float PitchSpeed, float YawSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBAimAssistComponent", "SetAssistedControllerRotationSpeeds");

	Params::SBAimAssistComponent_SetAssistedControllerRotationSpeeds Parms{};

	Parms.PitchSpeed = PitchSpeed;
	Parms.YawSpeed = YawSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SBAimAssistComponent.SetIgnoredActors
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<class AActor*>                     ActorList                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USBAimAssistComponent::SetIgnoredActors(const TSet<class AActor*>& ActorList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBAimAssistComponent", "SetIgnoredActors");

	Params::SBAimAssistComponent_SetIgnoredActors Parms{};

	Parms.ActorList = std::move(ActorList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SBAimAssistComponent.SetMinimumTargetPriority
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   MinimumPriority                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USBAimAssistComponent::SetMinimumTargetPriority(float MinimumPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBAimAssistComponent", "SetMinimumTargetPriority");

	Params::SBAimAssistComponent_SetMinimumTargetPriority Parms{};

	Parms.MinimumPriority = MinimumPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SBAimAssistComponent.GetCrosshairPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector2D                  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector2D USBAimAssistComponent::GetCrosshairPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBAimAssistComponent", "GetCrosshairPosition");

	Params::SBAimAssistComponent_GetCrosshairPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SBAimAssistComponent.GetCurrentTargetSocketLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USBAimAssistComponent::GetCurrentTargetSocketLocation(struct FVector* OutLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBAimAssistComponent", "GetCurrentTargetSocketLocation");

	Params::SBAimAssistComponent_GetCurrentTargetSocketLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	return Parms.ReturnValue;
}


// Function DeceiveInc.SBAimAssistComponent.GetIgnoredActors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TSet<class AActor*>               ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TSet<class AActor*> USBAimAssistComponent::GetIgnoredActors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBAimAssistComponent", "GetIgnoredActors");

	Params::SBAimAssistComponent_GetIgnoredActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SBAimAssistComponent.GetRotationToCrosshairDirection
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          From                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TraceProfileName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinDistanceToRotateToTarget                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator USBAimAssistComponent::GetRotationToCrosshairDirection(const struct FVector& From, class FName TraceProfileName, float MinDistanceToRotateToTarget, float Distance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBAimAssistComponent", "GetRotationToCrosshairDirection");

	Params::SBAimAssistComponent_GetRotationToCrosshairDirection Parms{};

	Parms.From = std::move(From);
	Parms.TraceProfileName = TraceProfileName;
	Parms.MinDistanceToRotateToTarget = MinDistanceToRotateToTarget;
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SBAimAssistTargetComponent.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   Mesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USBAimAssistTargetComponent::Init(class UMeshComponent* Mesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBAimAssistTargetComponent", "Init");

	Params::SBAimAssistTargetComponent_Init Parms{};

	Parms.Mesh = Mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SBAimAssistTargetComponent.SetTargetPriority
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewPriority                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USBAimAssistTargetComponent::SetTargetPriority(float NewPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBAimAssistTargetComponent", "SetTargetPriority");

	Params::SBAimAssistTargetComponent_SetTargetPriority Parms{};

	Parms.NewPriority = NewPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SBAimAssistTargetComponent.GetTargetActivationRangeFactor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USBAimAssistTargetComponent::GetTargetActivationRangeFactor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBAimAssistTargetComponent", "GetTargetActivationRangeFactor");

	Params::SBAimAssistTargetComponent_GetTargetActivationRangeFactor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SBAimAssistTargetComponent.GetTargetFactionID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 USBAimAssistTargetComponent::GetTargetFactionID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBAimAssistTargetComponent", "GetTargetFactionID");

	Params::SBAimAssistTargetComponent_GetTargetFactionID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SBAimAssistTargetComponent.GetTargetPriority
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USBAimAssistTargetComponent::GetTargetPriority() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBAimAssistTargetComponent", "GetTargetPriority");

	Params::SBAimAssistTargetComponent_GetTargetPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SBCollisionPatch.OnRep_ColScale
// (Final, Native, Protected)

void ASBCollisionPatch::OnRep_ColScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBCollisionPatch", "OnRep_ColScale");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SBShaderPrecompilerSubsytem.GetShaderPrecompileProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USBShaderPrecompilerSubsytem::GetShaderPrecompileProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBShaderPrecompilerSubsytem", "GetShaderPrecompileProgress");

	Params::SBShaderPrecompilerSubsytem_GetShaderPrecompileProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SBShaderPrecompilerSubsytem.MaterialWorkCompleted
// (Final, Native, Public, BlueprintCallable)

void USBShaderPrecompilerSubsytem::MaterialWorkCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBShaderPrecompilerSubsytem", "MaterialWorkCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SBShaderPrecompilerSubsytem.ParticleWorkCompleted
// (Final, Native, Public, BlueprintCallable)

void USBShaderPrecompilerSubsytem::ParticleWorkCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBShaderPrecompilerSubsytem", "ParticleWorkCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SBShaderPrecompilerSubsytem.ShouldPrecompileShaders
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USBShaderPrecompilerSubsytem::ShouldPrecompileShaders()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBShaderPrecompilerSubsytem", "ShouldPrecompileShaders");

	Params::SBShaderPrecompilerSubsytem_ShouldPrecompileShaders Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SBShaderPrecompilerSubsytem.StartShaderPrecompilation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShowMenu                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USBShaderPrecompilerSubsytem::StartShaderPrecompilation(bool bShowMenu)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SBShaderPrecompilerSubsytem", "StartShaderPrecompilation");

	Params::SBShaderPrecompilerSubsytem_StartShaderPrecompilation Parms{};

	Parms.bShowMenu = bShowMenu;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ScanAuthorityComponent.NetMulticastCompleteScan
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ABaseScannerTool*                 Scanner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UScannableComponent*              Scannable                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Interacter                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScanAuthorityComponent::NetMulticastCompleteScan(class ABaseScannerTool* Scanner, class UScannableComponent* Scannable, class AActor* Interacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScanAuthorityComponent", "NetMulticastCompleteScan");

	Params::ScanAuthorityComponent_NetMulticastCompleteScan Parms{};

	Parms.Scanner = Scanner;
	Parms.Scannable = Scannable;
	Parms.Interacter = Interacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Scrambler.BP_OnToggleScrambler
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScrambler::BP_OnToggleScrambler(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Scrambler", "BP_OnToggleScrambler");

	Params::Scrambler_BP_OnToggleScrambler Parms{};

	Parms.bActive = bActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.Scrambler.HandleDetectionCollisionBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AScrambler::HandleDetectionCollisionBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Scrambler", "HandleDetectionCollisionBeginOverlap");

	Params::Scrambler_HandleDetectionCollisionBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Scrambler.HandleDetectionCollisionEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScrambler::HandleDetectionCollisionEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Scrambler", "HandleDetectionCollisionEndOverlap");

	Params::Scrambler_HandleDetectionCollisionEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Scrambler.IsScrambleActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AScrambler::IsScrambleActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Scrambler", "IsScrambleActive");

	Params::Scrambler_IsScrambleActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Scrambler.Multicast_ActivateScrambler
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScrambler::Multicast_ActivateScrambler(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Scrambler", "Multicast_ActivateScrambler");

	Params::Scrambler_Multicast_ActivateScrambler Parms{};

	Parms.bActive = bActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Scrambler.Server_ActivateScrambler
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScrambler::Server_ActivateScrambler(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Scrambler", "Server_ActivateScrambler");

	Params::Scrambler_Server_ActivateScrambler Parms{};

	Parms.bActive = bActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ScramblerTool.BP_OnToggleInHandScrambler
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSendBPEvent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScramblerTool::BP_OnToggleInHandScrambler(bool bActive, bool bSendBPEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScramblerTool", "BP_OnToggleInHandScrambler");

	Params::ScramblerTool_BP_OnToggleInHandScrambler Parms{};

	Parms.bActive = bActive;
	Parms.bSendBPEvent = bSendBPEvent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.ScramblerTool.HandleDetectionCollisionBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AScramblerTool::HandleDetectionCollisionBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScramblerTool", "HandleDetectionCollisionBeginOverlap");

	Params::ScramblerTool_HandleDetectionCollisionBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ScramblerTool.HandleDetectionCollisionEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScramblerTool::HandleDetectionCollisionEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScramblerTool", "HandleDetectionCollisionEndOverlap");

	Params::ScramblerTool_HandleDetectionCollisionEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ScramblerTool.IsScramblerToolActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AScramblerTool::IsScramblerToolActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScramblerTool", "IsScramblerToolActive");

	Params::ScramblerTool_IsScramblerToolActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ScramblerTool.NetMulticast_ToggleInHandScrambler
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScramblerTool::NetMulticast_ToggleInHandScrambler(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScramblerTool", "NetMulticast_ToggleInHandScrambler");

	Params::ScramblerTool_NetMulticast_ToggleInHandScrambler Parms{};

	Parms.bActive = bActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ScramblerTool.Server_ToggleInHandScrambler
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScramblerTool::Server_ToggleInHandScrambler(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScramblerTool", "Server_ToggleInHandScrambler");

	Params::ScramblerTool_Server_ToggleInHandScrambler Parms{};

	Parms.bActive = bActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ScriptedBotBrain.OnFightTargetLost
// (Final, Native, Protected)
// Parameters:
// class UBotPlanFight*                    BotPlanFight                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             LostTarget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScriptedBotBrain::OnFightTargetLost(class UBotPlanFight* BotPlanFight, class ASpy* LostTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptedBotBrain", "OnFightTargetLost");

	Params::ScriptedBotBrain_OnFightTargetLost Parms{};

	Parms.BotPlanFight = BotPlanFight;
	Parms.LostTarget = LostTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ScriptedBotBrain.OnUndercoverChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bUndercover                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScriptedBotBrain::OnUndercoverChange(bool bUndercover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptedBotBrain", "OnUndercoverChange");

	Params::ScriptedBotBrain_OnUndercoverChange Parms{};

	Parms.bUndercover = bUndercover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleChargeAmountChange
// (Final, Native, Protected)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AShieldbrellaSpawnerWeapon::HandleChargeAmountChange(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShieldbrellaSpawnerWeapon", "HandleChargeAmountChange");

	Params::ShieldbrellaSpawnerWeapon_HandleChargeAmountChange Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleCooldownChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bOnCooldown                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AShieldbrellaSpawnerWeapon::HandleCooldownChange(bool bOnCooldown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShieldbrellaSpawnerWeapon", "HandleCooldownChange");

	Params::ShieldbrellaSpawnerWeapon_HandleCooldownChange Parms{};

	Parms.bOnCooldown = bOnCooldown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleDeath
// (Final, Native, Protected)
// Parameters:
// class AActor*                           DeadActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AShieldbrellaSpawnerWeapon::HandleDeath(class AActor* DeadActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShieldbrellaSpawnerWeapon", "HandleDeath");

	Params::ShieldbrellaSpawnerWeapon_HandleDeath Parms{};

	Parms.DeadActor = DeadActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleDeployedShieldActorDestroyed
// (Final, Native, Protected)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AShieldbrellaSpawnerWeapon::HandleDeployedShieldActorDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShieldbrellaSpawnerWeapon", "HandleDeployedShieldActorDestroyed");

	Params::ShieldbrellaSpawnerWeapon_HandleDeployedShieldActorDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleDeployedShieldHealthChange
// (Final, Native, Protected)
// Parameters:
// class UHealthComponent*                 OwningHealthComp                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Health                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HealthDelta                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RawDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AShieldbrellaSpawnerWeapon::HandleDeployedShieldHealthChange(class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, float RawDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShieldbrellaSpawnerWeapon", "HandleDeployedShieldHealthChange");

	Params::ShieldbrellaSpawnerWeapon_HandleDeployedShieldHealthChange Parms{};

	Parms.OwningHealthComp = OwningHealthComp;
	Parms.Health = Health;
	Parms.HealthDelta = HealthDelta;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.RawDamage = RawDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleDeployedShieldInteractionComplete
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AShieldbrellaSpawnerWeapon::HandleDeployedShieldInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShieldbrellaSpawnerWeapon", "HandleDeployedShieldInteractionComplete");

	Params::ShieldbrellaSpawnerWeapon_HandleDeployedShieldInteractionComplete Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleDeployedShieldSpawned
// (Final, Native, Protected)
// Parameters:
// class ABasePlaceable*                   NewPlaceable                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AShieldbrellaSpawnerWeapon::HandleDeployedShieldSpawned(class ABasePlaceable* NewPlaceable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShieldbrellaSpawnerWeapon", "HandleDeployedShieldSpawned");

	Params::ShieldbrellaSpawnerWeapon_HandleDeployedShieldSpawned Parms{};

	Parms.NewPlaceable = NewPlaceable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleHealthChanged
// (Final, Native, Protected)
// Parameters:
// class UHealthComponent*                 OwningHealthComp                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Health                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HealthDelta                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RawDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AShieldbrellaSpawnerWeapon::HandleHealthChanged(class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, float RawDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShieldbrellaSpawnerWeapon", "HandleHealthChanged");

	Params::ShieldbrellaSpawnerWeapon_HandleHealthChanged Parms{};

	Parms.OwningHealthComp = OwningHealthComp;
	Parms.Health = Health;
	Parms.HealthDelta = HealthDelta;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.RawDamage = RawDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleLocalInteractionStart
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AShieldbrellaSpawnerWeapon::HandleLocalInteractionStart(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShieldbrellaSpawnerWeapon", "HandleLocalInteractionStart");

	Params::ShieldbrellaSpawnerWeapon_HandleLocalInteractionStart Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleOpeningDelayAfterShootingTimerEnd
// (Final, Native, Protected)

void AShieldbrellaSpawnerWeapon::HandleOpeningDelayAfterShootingTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShieldbrellaSpawnerWeapon", "HandleOpeningDelayAfterShootingTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleRecycleTimerEnd
// (Native, Protected)

void AShieldbrellaSpawnerWeapon::HandleRecycleTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShieldbrellaSpawnerWeapon", "HandleRecycleTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleRedeployTimerEnd
// (Final, Native, Protected)

void AShieldbrellaSpawnerWeapon::HandleRedeployTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShieldbrellaSpawnerWeapon", "HandleRedeployTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleResourceNewAmount
// (Final, Native, Protected)
// Parameters:
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ResourceDisplayName                                    (Parm, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AShieldbrellaSpawnerWeapon::HandleResourceNewAmount(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShieldbrellaSpawnerWeapon", "HandleResourceNewAmount");

	Params::ShieldbrellaSpawnerWeapon_HandleResourceNewAmount Parms{};

	Parms.ResourceType = ResourceType;
	Parms.ResourceDisplayName = std::move(ResourceDisplayName);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleShootingBlockedTimerEnd
// (Final, Native, Protected)

void AShieldbrellaSpawnerWeapon::HandleShootingBlockedTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShieldbrellaSpawnerWeapon", "HandleShootingBlockedTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleWeaponShot
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AShieldbrellaSpawnerWeapon::HandleWeaponShot(class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShieldbrellaSpawnerWeapon", "HandleWeaponShot");

	Params::ShieldbrellaSpawnerWeapon_HandleWeaponShot Parms{};

	Parms.Spy = Spy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ShieldbrellaSpawnerWeapon.Multicast_Bump
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           BumpActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              BumpImpulse                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AShieldbrellaSpawnerWeapon::Multicast_Bump(class AActor* BumpActor, const struct FVector_NetQuantize& BumpImpulse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShieldbrellaSpawnerWeapon", "Multicast_Bump");

	Params::ShieldbrellaSpawnerWeapon_Multicast_Bump Parms{};

	Parms.BumpActor = BumpActor;
	Parms.BumpImpulse = std::move(BumpImpulse);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ShieldbrellaSpawnerWeapon.OnRep_NewPlaceableAssetsId
// (Native, Protected)

void AShieldbrellaSpawnerWeapon::OnRep_NewPlaceableAssetsId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShieldbrellaSpawnerWeapon", "OnRep_NewPlaceableAssetsId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ShieldbrellaSpawnerWeapon.OnRep_ShieldOpen
// (Final, Native, Protected)

void AShieldbrellaSpawnerWeapon::OnRep_ShieldOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShieldbrellaSpawnerWeapon", "OnRep_ShieldOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ShieldbrellaSpawnerWeapon.RecycleServer
// (Net, NetReliable, Native, Event, Protected, NetServer)

void AShieldbrellaSpawnerWeapon::RecycleServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShieldbrellaSpawnerWeapon", "RecycleServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ShieldbrellaSpawnerWeapon.Server_BumpMecanic
// (Net, NetReliable, Native, Event, Protected, NetServer)

void AShieldbrellaSpawnerWeapon::Server_BumpMecanic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShieldbrellaSpawnerWeapon", "Server_BumpMecanic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ShieldbrellaSpawnerWeapon.Server_ForceDamage
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageEvent                     DamageEvent                                            (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// class AController*                      EventInstigator                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCause                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AShieldbrellaSpawnerWeapon::Server_ForceDamage(float DamageAmount, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShieldbrellaSpawnerWeapon", "Server_ForceDamage");

	Params::ShieldbrellaSpawnerWeapon_Server_ForceDamage Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.DamageEvent = std::move(DamageEvent);
	Parms.EventInstigator = EventInstigator;
	Parms.DamageCause = DamageCause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ShieldbrellaSpawnerWeapon.Server_OnShieldbrellaOpen
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    bIsOpen                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AShieldbrellaSpawnerWeapon::Server_OnShieldbrellaOpen(bool bIsOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShieldbrellaSpawnerWeapon", "Server_OnShieldbrellaOpen");

	Params::ShieldbrellaSpawnerWeapon_Server_OnShieldbrellaOpen Parms{};

	Parms.bIsOpen = bIsOpen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SmokeGrenadeProjectileComponent.OnProjectileHit
// (Final, Native, Protected, HasDefaults)
// Parameters:
// struct FHitResult                       Hit                                                    (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          HitDirection                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USmokeGrenadeProjectileComponent::OnProjectileHit(const struct FHitResult& Hit, const struct FVector& HitDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmokeGrenadeProjectileComponent", "OnProjectileHit");

	Params::SmokeGrenadeProjectileComponent_OnProjectileHit Parms{};

	Parms.Hit = std::move(Hit);
	Parms.HitDirection = std::move(HitDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SmokeZoneActor.HandleSpyUndercoverChanged
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUndercover                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmokeZoneActor::HandleSpyUndercoverChanged(class ASpy* Spy, bool bUndercover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmokeZoneActor", "HandleSpyUndercoverChanged");

	Params::SmokeZoneActor_HandleSpyUndercoverChanged Parms{};

	Parms.Spy = Spy;
	Parms.bUndercover = bUndercover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SmokeZoneActor.OnCollisionBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASmokeZoneActor::OnCollisionBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmokeZoneActor", "OnCollisionBeginOverlap");

	Params::SmokeZoneActor_OnCollisionBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SmokeZoneActor.OnCollisionEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASmokeZoneActor::OnCollisionEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmokeZoneActor", "OnCollisionEndOverlap");

	Params::SmokeZoneActor_OnCollisionEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SmokeZoneActor.OnLifeTimerHandleEnd
// (Final, Native, Protected)

void ASmokeZoneActor::OnLifeTimerHandleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmokeZoneActor", "OnLifeTimerHandleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteActiveAbility.BP_OnLocalSocialiteActiveEnd
// (Event, Protected, BlueprintEvent)

void ASocialiteActiveAbility::BP_OnLocalSocialiteActiveEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbility", "BP_OnLocalSocialiteActiveEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.SocialiteActiveAbility.BP_OnLocalSocialiteActiveStart
// (Event, Protected, BlueprintEvent)

void ASocialiteActiveAbility::BP_OnLocalSocialiteActiveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbility", "BP_OnLocalSocialiteActiveStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.SocialiteActiveAbility.BP_OnSocialiteActiveConeAttack
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          OriginPos                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeLength                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeAngle                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialiteActiveAbility::BP_OnSocialiteActiveConeAttack(const struct FVector& OriginPos, const struct FVector& Normal, float ConeLength, float ConeAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbility", "BP_OnSocialiteActiveConeAttack");

	Params::SocialiteActiveAbility_BP_OnSocialiteActiveConeAttack Parms{};

	Parms.OriginPos = std::move(OriginPos);
	Parms.Normal = std::move(Normal);
	Parms.ConeLength = ConeLength;
	Parms.ConeAngle = ConeAngle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.SocialiteActiveAbility.BP_OnSocialiteActiveConeAttackLocal
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          OriginPos                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeLength                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeAngle                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialiteActiveAbility::BP_OnSocialiteActiveConeAttackLocal(const struct FVector& OriginPos, const struct FVector& Normal, float ConeLength, float ConeAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbility", "BP_OnSocialiteActiveConeAttackLocal");

	Params::SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackLocal Parms{};

	Parms.OriginPos = std::move(OriginPos);
	Parms.Normal = std::move(Normal);
	Parms.ConeLength = ConeLength;
	Parms.ConeAngle = ConeAngle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.SocialiteActiveAbility.BP_OnSocialiteActiveConeAttackReplicated
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          OriginPos                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeLength                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeAngle                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialiteActiveAbility::BP_OnSocialiteActiveConeAttackReplicated(const struct FVector& OriginPos, const struct FVector& Normal, float ConeLength, float ConeAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbility", "BP_OnSocialiteActiveConeAttackReplicated");

	Params::SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackReplicated Parms{};

	Parms.OriginPos = std::move(OriginPos);
	Parms.Normal = std::move(Normal);
	Parms.ConeLength = ConeLength;
	Parms.ConeAngle = ConeAngle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.SocialiteActiveAbility.BP_OnSocialiteActiveEffectHit
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactPoint                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactNormal                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialiteActiveAbility::BP_OnSocialiteActiveEffectHit(class AActor* Victim, const struct FVector& ImpactPoint, const struct FVector& ImpactNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbility", "BP_OnSocialiteActiveEffectHit");

	Params::SocialiteActiveAbility_BP_OnSocialiteActiveEffectHit Parms{};

	Parms.Victim = Victim;
	Parms.ImpactPoint = std::move(ImpactPoint);
	Parms.ImpactNormal = std::move(ImpactNormal);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.SocialiteActiveAbility.MulticastProjectileHit
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              ImpactPos                                              (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ImpactNormal                                           (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialiteActiveAbility::MulticastProjectileHit(class AActor* Victim, const struct FVector_NetQuantize& ImpactPos, const struct FVector_NetQuantizeNormal& ImpactNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbility", "MulticastProjectileHit");

	Params::SocialiteActiveAbility_MulticastProjectileHit Parms{};

	Parms.Victim = Victim;
	Parms.ImpactPos = std::move(ImpactPos);
	Parms.ImpactNormal = std::move(ImpactNormal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteActiveAbility.MulticastSocialiteActiveConeAttack
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FVector_NetQuantize              OriginPos                                              (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        Normal                                                 (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialiteActiveAbility::MulticastSocialiteActiveConeAttack(const struct FVector_NetQuantize& OriginPos, const struct FVector_NetQuantizeNormal& Normal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbility", "MulticastSocialiteActiveConeAttack");

	Params::SocialiteActiveAbility_MulticastSocialiteActiveConeAttack Parms{};

	Parms.OriginPos = std::move(OriginPos);
	Parms.Normal = std::move(Normal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteActiveAbility.OnAfterShotTimerEnd
// (Final, Native, Protected)

void ASocialiteActiveAbility::OnAfterShotTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbility", "OnAfterShotTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteActiveAbility.OnLocalSocialiteActiveEnd
// (Final, Native, Protected)

void ASocialiteActiveAbility::OnLocalSocialiteActiveEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbility", "OnLocalSocialiteActiveEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteActiveAbility.OnServerSocialiteActiveEnd
// (Final, Native, Protected)

void ASocialiteActiveAbility::OnServerSocialiteActiveEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbility", "OnServerSocialiteActiveEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteActiveAbility.Server_StartSocialiteActive
// (Net, NetReliable, Native, Event, Protected, NetServer)

void ASocialiteActiveAbility::Server_StartSocialiteActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbility", "Server_StartSocialiteActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteActiveAbility.Server_TriggerAttack
// (Net, NetReliable, Native, Event, Protected, NetServer, HasDefaults)
// Parameters:
// struct FVector                          OriginPos                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialiteActiveAbility::Server_TriggerAttack(const struct FVector& OriginPos, const struct FVector& Normal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbility", "Server_TriggerAttack");

	Params::SocialiteActiveAbility_Server_TriggerAttack Parms{};

	Parms.OriginPos = std::move(OriginPos);
	Parms.Normal = std::move(Normal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteActiveAbility.GetMuzzlePosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ASocialiteActiveAbility::GetMuzzlePosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbility", "GetMuzzlePosition");

	Params::SocialiteActiveAbility_GetMuzzlePosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SocialiteActiveAbilityMod1.BP_OnLocalSocialiteActiveEnd
// (Event, Protected, BlueprintEvent)

void ASocialiteActiveAbilityMod1::BP_OnLocalSocialiteActiveEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbilityMod1", "BP_OnLocalSocialiteActiveEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.SocialiteActiveAbilityMod1.BP_OnLocalSocialiteActiveStart
// (Event, Protected, BlueprintEvent)

void ASocialiteActiveAbilityMod1::BP_OnLocalSocialiteActiveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbilityMod1", "BP_OnLocalSocialiteActiveStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.SocialiteActiveAbilityMod1.BP_OnSocialiteActiveEffectHit
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactPoint                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactNormal                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialiteActiveAbilityMod1::BP_OnSocialiteActiveEffectHit(class AActor* Victim, const struct FVector& ImpactPoint, const struct FVector& ImpactNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbilityMod1", "BP_OnSocialiteActiveEffectHit");

	Params::SocialiteActiveAbilityMod1_BP_OnSocialiteActiveEffectHit Parms{};

	Parms.Victim = Victim;
	Parms.ImpactPoint = std::move(ImpactPoint);
	Parms.ImpactNormal = std::move(ImpactNormal);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.SocialiteActiveAbilityMod1.BP_OnSocialiteActiveMod1
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          FloorPos                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialiteActiveAbilityMod1::BP_OnSocialiteActiveMod1(const struct FVector& FloorPos, const struct FVector& Normal, float Radius, float Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbilityMod1", "BP_OnSocialiteActiveMod1");

	Params::SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1 Parms{};

	Parms.FloorPos = std::move(FloorPos);
	Parms.Normal = std::move(Normal);
	Parms.Radius = Radius;
	Parms.Height = Height;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.SocialiteActiveAbilityMod1.BP_OnSocialiteActiveMod1Local
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          FloorPos                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialiteActiveAbilityMod1::BP_OnSocialiteActiveMod1Local(const struct FVector& FloorPos, const struct FVector& Normal, float Radius, float Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbilityMod1", "BP_OnSocialiteActiveMod1Local");

	Params::SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Local Parms{};

	Parms.FloorPos = std::move(FloorPos);
	Parms.Normal = std::move(Normal);
	Parms.Radius = Radius;
	Parms.Height = Height;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.SocialiteActiveAbilityMod1.BP_OnSocialiteActiveMod1Replicated
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          FloorPos                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialiteActiveAbilityMod1::BP_OnSocialiteActiveMod1Replicated(const struct FVector& FloorPos, const struct FVector& Normal, float Radius, float Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbilityMod1", "BP_OnSocialiteActiveMod1Replicated");

	Params::SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Replicated Parms{};

	Parms.FloorPos = std::move(FloorPos);
	Parms.Normal = std::move(Normal);
	Parms.Radius = Radius;
	Parms.Height = Height;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.SocialiteActiveAbilityMod1.MulticastProjectileHit
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              ImpactPos                                              (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ImpactNormal                                           (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialiteActiveAbilityMod1::MulticastProjectileHit(class AActor* Victim, const struct FVector_NetQuantize& ImpactPos, const struct FVector_NetQuantizeNormal& ImpactNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbilityMod1", "MulticastProjectileHit");

	Params::SocialiteActiveAbilityMod1_MulticastProjectileHit Parms{};

	Parms.Victim = Victim;
	Parms.ImpactPos = std::move(ImpactPos);
	Parms.ImpactNormal = std::move(ImpactNormal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteActiveAbilityMod1.MulticastSocialiteActiveMod1
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FVector_NetQuantize              OriginPos                                              (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        Normal                                                 (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialiteActiveAbilityMod1::MulticastSocialiteActiveMod1(const struct FVector_NetQuantize& OriginPos, const struct FVector_NetQuantizeNormal& Normal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbilityMod1", "MulticastSocialiteActiveMod1");

	Params::SocialiteActiveAbilityMod1_MulticastSocialiteActiveMod1 Parms{};

	Parms.OriginPos = std::move(OriginPos);
	Parms.Normal = std::move(Normal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteActiveAbilityMod1.OnAfterShotTimerEnd
// (Final, Native, Protected)

void ASocialiteActiveAbilityMod1::OnAfterShotTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbilityMod1", "OnAfterShotTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteActiveAbilityMod1.OnServerSocialiteActiveEnd
// (Final, Native, Protected)

void ASocialiteActiveAbilityMod1::OnServerSocialiteActiveEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbilityMod1", "OnServerSocialiteActiveEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteActiveAbilityMod1.Server_StartSocialiteActive
// (Net, NetReliable, Native, Event, Protected, NetServer)

void ASocialiteActiveAbilityMod1::Server_StartSocialiteActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbilityMod1", "Server_StartSocialiteActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteActiveAbilityMod1.GetMuzzlePosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ASocialiteActiveAbilityMod1::GetMuzzlePosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbilityMod1", "GetMuzzlePosition");

	Params::SocialiteActiveAbilityMod1_GetMuzzlePosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SocialiteActiveAbilityMod2.HandleMiscToolSpawned
// (Final, Native, Protected)
// Parameters:
// class AActor*                           SpawnedTool                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialiteActiveAbilityMod2::HandleMiscToolSpawned(class AActor* SpawnedTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbilityMod2", "HandleMiscToolSpawned");

	Params::SocialiteActiveAbilityMod2_HandleMiscToolSpawned Parms{};

	Parms.SpawnedTool = SpawnedTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteActiveAbilityMod2.HandleTrapPickedUp
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Spy                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialiteActiveAbilityMod2::HandleTrapPickedUp(class AActor* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbilityMod2", "HandleTrapPickedUp");

	Params::SocialiteActiveAbilityMod2_HandleTrapPickedUp Parms{};

	Parms.Spy = Spy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteActiveAbilityMod2.HandleTrapTriggered
// (Final, Native, Protected)

void ASocialiteActiveAbilityMod2::HandleTrapTriggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbilityMod2", "HandleTrapTriggered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteActiveAbilityMod2.OnPendingSpawnTrapTimer
// (Final, Native, Protected)

void ASocialiteActiveAbilityMod2::OnPendingSpawnTrapTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbilityMod2", "OnPendingSpawnTrapTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteActiveAbilityMod2.OnRep_SocialiteTrap
// (Final, Native, Protected)

void ASocialiteActiveAbilityMod2::OnRep_SocialiteTrap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbilityMod2", "OnRep_SocialiteTrap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteActiveAbilityMod2.OnThrowDelayTimerEnd
// (Native, Protected)

void ASocialiteActiveAbilityMod2::OnThrowDelayTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbilityMod2", "OnThrowDelayTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteActiveAbilityMod2.OnThrowTimerEnd
// (Native, Protected)

void ASocialiteActiveAbilityMod2::OnThrowTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbilityMod2", "OnThrowTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteActiveAbilityMod2.OnTrapDeath
// (Final, Native, Protected)
// Parameters:
// class AActor*                           DeadActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialiteActiveAbilityMod2::OnTrapDeath(class AActor* DeadActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteActiveAbilityMod2", "OnTrapDeath");

	Params::SocialiteActiveAbilityMod2_OnTrapDeath Parms{};

	Parms.DeadActor = DeadActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialitePassiveAbility.OnUndercoverChange
// (Final, Native, Protected)
// Parameters:
// bool                                    Undercover                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialitePassiveAbility::OnUndercoverChange(bool Undercover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialitePassiveAbility", "OnUndercoverChange");

	Params::SocialitePassiveAbility_OnUndercoverChange Parms{};

	Parms.Undercover = Undercover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialitePassiveAbilityMod1.HandleSpyDeath
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             DeadSpy                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialitePassiveAbilityMod1::HandleSpyDeath(class ASpy* DeadSpy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialitePassiveAbilityMod1", "HandleSpyDeath");

	Params::SocialitePassiveAbilityMod1_HandleSpyDeath Parms{};

	Parms.DeadSpy = DeadSpy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialitePassiveAbilityMod1.HandleUnderCoverChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bUndercover                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialitePassiveAbilityMod1::HandleUnderCoverChanged(bool bUndercover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialitePassiveAbilityMod1", "HandleUnderCoverChanged");

	Params::SocialitePassiveAbilityMod1_HandleUnderCoverChanged Parms{};

	Parms.bUndercover = bUndercover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialitePassiveAbilityMod2.HandleSpyHeatChange
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewHeatValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HeatDelta                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialitePassiveAbilityMod2::HandleSpyHeatChange(class ASpy* Spy, int32 NewHeatValue, int32 HeatDelta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialitePassiveAbilityMod2", "HandleSpyHeatChange");

	Params::SocialitePassiveAbilityMod2_HandleSpyHeatChange Parms{};

	Parms.Spy = Spy;
	Parms.NewHeatValue = NewHeatValue;
	Parms.HeatDelta = HeatDelta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialitePassiveAbilityMod2.HandleSpySecurityStateChanged
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpySecurityState                       PreviousState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpySecurityState                       NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialitePassiveAbilityMod2::HandleSpySecurityStateChanged(class ASpy* Spy, ESpySecurityState PreviousState, ESpySecurityState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialitePassiveAbilityMod2", "HandleSpySecurityStateChanged");

	Params::SocialitePassiveAbilityMod2_HandleSpySecurityStateChanged Parms{};

	Parms.Spy = Spy;
	Parms.PreviousState = PreviousState;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteTrap.HandleDetectionCollisionBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASocialiteTrap::HandleDetectionCollisionBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteTrap", "HandleDetectionCollisionBeginOverlap");

	Params::SocialiteTrap_HandleDetectionCollisionBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteTrap.HandleDetectionCollisionEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialiteTrap::HandleDetectionCollisionEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteTrap", "HandleDetectionCollisionEndOverlap");

	Params::SocialiteTrap_HandleDetectionCollisionEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteTrap.OnHealthChanged
// (Final, Native, Protected)
// Parameters:
// class UHealthComponent*                 OwningHealthComp                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Health                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HealthDelta                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RawDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialiteTrap::OnHealthChanged(class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, float RawDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteTrap", "OnHealthChanged");

	Params::SocialiteTrap_OnHealthChanged Parms{};

	Parms.OwningHealthComp = OwningHealthComp;
	Parms.Health = Health;
	Parms.HealthDelta = HealthDelta;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.RawDamage = RawDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteTrap.OnInteractionComplete
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialiteTrap::OnInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteTrap", "OnInteractionComplete");

	Params::SocialiteTrap_OnInteractionComplete Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SocialiteTrap.OnSpyInRangeUndercoverChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bUndercover                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASocialiteTrap::OnSpyInRangeUndercoverChange(bool bUndercover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialiteTrap", "OnSpyInRangeUndercoverChange");

	Params::SocialiteTrap_OnSpyInRangeUndercoverChange Parms{};

	Parms.bUndercover = bUndercover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SoundMachine.NetMulticast_PlaySound
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FTrackSoundEvents                SoundToPlay                                            (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   NewRandomSeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASoundMachine::NetMulticast_PlaySound(const struct FTrackSoundEvents& SoundToPlay, int32 NewRandomSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundMachine", "NetMulticast_PlaySound");

	Params::SoundMachine_NetMulticast_PlaySound Parms{};

	Parms.SoundToPlay = std::move(SoundToPlay);
	Parms.NewRandomSeed = NewRandomSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SoundMachine.OnAudioEndedTimerEnd
// (Final, Native, Protected)

void ASoundMachine::OnAudioEndedTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundMachine", "OnAudioEndedTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SoundMachine.OnSoundLoopTimerEnd
// (Final, Native, Protected)

void ASoundMachine::OnSoundLoopTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundMachine", "OnSoundLoopTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SoundMachine.OnSoundPlayTimerEnd
// (Final, Native, Protected)

void ASoundMachine::OnSoundPlayTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundMachine", "OnSoundPlayTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SoundMachine.Server_PlaySound
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// struct FTrackSoundEvents                SoundToPlay                                            (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   NewRandomSeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASoundMachine::Server_PlaySound(const struct FTrackSoundEvents& SoundToPlay, int32 NewRandomSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundMachine", "Server_PlaySound");

	Params::SoundMachine_Server_PlaySound Parms{};

	Parms.SoundToPlay = std::move(SoundToPlay);
	Parms.NewRandomSeed = NewRandomSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SoundMachineTool.GetCurrentSoundTrackInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FTrackSoundEvents                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrackSoundEvents ASoundMachineTool::GetCurrentSoundTrackInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundMachineTool", "GetCurrentSoundTrackInfo");

	Params::SoundMachineTool_GetCurrentSoundTrackInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SoundMachineTool.HandleSoundMachineDropDone
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           ActorDropped                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndPos                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         EndRotation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ASoundMachineTool::HandleSoundMachineDropDone(class AActor* ActorDropped, const struct FVector& EndPos, const struct FRotator& EndRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundMachineTool", "HandleSoundMachineDropDone");

	Params::SoundMachineTool_HandleSoundMachineDropDone Parms{};

	Parms.ActorDropped = ActorDropped;
	Parms.EndPos = std::move(EndPos);
	Parms.EndRotation = std::move(EndRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SoundMachineTool.OnSoundCooldownTimerEnd
// (Final, Native, Protected)

void ASoundMachineTool::OnSoundCooldownTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundMachineTool", "OnSoundCooldownTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SoundMachineTool.IsSoundPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASoundMachineTool::IsSoundPlaying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundMachineTool", "IsSoundPlaying");

	Params::SoundMachineTool_IsSoundPlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SpawnerWeaponRound.BP_SignalRelease
// (Event, Public, BlueprintEvent)

void ASpawnerWeaponRound::BP_SignalRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeaponRound", "BP_SignalRelease");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.SpawnerWeaponRound.GetSpawnerWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ASpawnerWeaponRound::GetSpawnerWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeaponRound", "GetSpawnerWeapon");

	Params::SpawnerWeaponRound_GetSpawnerWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SpawnerWeaponRound.ProjectilesAbortHandler
// (Native, Protected)

void ASpawnerWeaponRound::ProjectilesAbortHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeaponRound", "ProjectilesAbortHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpawnerWeaponRound.ProjectilesReleasedHandler
// (Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// struct FVector                          AimPosition                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpawnerWeaponRound::ProjectilesReleasedHandler(const struct FVector& AimPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeaponRound", "ProjectilesReleasedHandler");

	Params::SpawnerWeaponRound_ProjectilesReleasedHandler Parms{};

	Parms.AimPosition = std::move(AimPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpawnerWeaponRound.ShowProjectilesHandler
// (Native, Protected)
// Parameters:
// EVisibilityMode                         VisibilityMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpawnerWeaponRound::ShowProjectilesHandler(EVisibilityMode VisibilityMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeaponRound", "ShowProjectilesHandler");

	Params::SpawnerWeaponRound_ShowProjectilesHandler Parms{};

	Parms.VisibilityMode = VisibilityMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpawnerWeaponRound.UpdateBreadcrumb
// (Final, Native, Protected)

void ASpawnerWeaponRound::UpdateBreadcrumb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeaponRound", "UpdateBreadcrumb");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpawnerWeaponRound.CanBeHeld
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpawnerWeaponRound::CanBeHeld() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeaponRound", "CanBeHeld");

	Params::SpawnerWeaponRound_CanBeHeld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SpawnerWeaponRound.GetActorToSpawnOnHit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftClassPtr<class UClass>             ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftClassPtr<class UClass> ASpawnerWeaponRound::GetActorToSpawnOnHit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeaponRound", "GetActorToSpawnOnHit");

	Params::SpawnerWeaponRound_GetActorToSpawnOnHit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SpawnerWeaponRound.GetReleasePosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector ASpawnerWeaponRound::GetReleasePosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeaponRound", "GetReleasePosition");

	Params::SpawnerWeaponRound_GetReleasePosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SpawnerWeaponRound.IsShootFromCameraAndFakeMuzzlePos
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpawnerWeaponRound::IsShootFromCameraAndFakeMuzzlePos() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeaponRound", "IsShootFromCameraAndFakeMuzzlePos");

	Params::SpawnerWeaponRound_IsShootFromCameraAndFakeMuzzlePos Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SpawnerWeaponRound_Projectile.ApplyNewBalancingTableAndUpdateStats
// (Native, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                       NewTable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NewBalancingName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpawnerWeaponRound_Projectile::ApplyNewBalancingTableAndUpdateStats(class UDataTable* NewTable, class FName NewBalancingName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeaponRound_Projectile", "ApplyNewBalancingTableAndUpdateStats");

	Params::SpawnerWeaponRound_Projectile_ApplyNewBalancingTableAndUpdateStats Parms{};

	Parms.NewTable = NewTable;
	Parms.NewBalancingName = NewBalancingName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpawnerWeaponRound_Projectile.BP_OnLifetimeCompleted
// (Event, Public, BlueprintEvent)

void ASpawnerWeaponRound_Projectile::BP_OnLifetimeCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeaponRound_Projectile", "BP_OnLifetimeCompleted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.SpawnerWeaponRound_Projectile.HandleBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASpawnerWeaponRound_Projectile::HandleBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeaponRound_Projectile", "HandleBeginOverlap");

	Params::SpawnerWeaponRound_Projectile_HandleBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpawnerWeaponRound_Projectile.HandleHit
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComp                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASpawnerWeaponRound_Projectile::HandleHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeaponRound_Projectile", "HandleHit");

	Params::SpawnerWeaponRound_Projectile_HandleHit Parms{};

	Parms.HitComp = HitComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpawnerWeaponRound_Projectile.OnLifetimeCompleted
// (Final, Native, Protected)

void ASpawnerWeaponRound_Projectile::OnLifetimeCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeaponRound_Projectile", "OnLifetimeCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpawnerWeaponRound_Projectile.UpdateStatsFromBalancingTable
// (Native, Public, BlueprintCallable)

void ASpawnerWeaponRound_Projectile::UpdateStatsFromBalancingTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeaponRound_Projectile", "UpdateStatsFromBalancingTable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpawnerWeaponRound_Projectile.GetBalancingDataTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* ASpawnerWeaponRound_Projectile::GetBalancingDataTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeaponRound_Projectile", "GetBalancingDataTable");

	Params::SpawnerWeaponRound_Projectile_GetBalancingDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SpawnerWeaponRound_Projectile.GetLifetime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASpawnerWeaponRound_Projectile::GetLifetime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerWeaponRound_Projectile", "GetLifetime");

	Params::SpawnerWeaponRound_Projectile_GetLifetime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.YumiPassiveAbilityMod1.HandleEffectNewSource
// (Final, Native, Protected)
// Parameters:
// class AActor*                           AffectingSource                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AffectedActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AYumiPassiveAbilityMod1::HandleEffectNewSource(class AActor* AffectingSource, class AActor* AffectedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YumiPassiveAbilityMod1", "HandleEffectNewSource");

	Params::YumiPassiveAbilityMod1_HandleEffectNewSource Parms{};

	Parms.AffectingSource = AffectingSource;
	Parms.AffectedActor = AffectedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.YumiPassiveAbilityMod1.HandleEffectRemoveSource
// (Final, Native, Protected)
// Parameters:
// class AActor*                           AffectingSource                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AffectedActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AYumiPassiveAbilityMod1::HandleEffectRemoveSource(class AActor* AffectingSource, class AActor* AffectedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YumiPassiveAbilityMod1", "HandleEffectRemoveSource");

	Params::YumiPassiveAbilityMod1_HandleEffectRemoveSource Parms{};

	Parms.AffectingSource = AffectingSource;
	Parms.AffectedActor = AffectedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.YumiPassiveAbilityMod1.HandleEffectStateChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bAffected                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AffectedActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AYumiPassiveAbilityMod1::HandleEffectStateChange(bool bAffected, class AActor* AffectedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YumiPassiveAbilityMod1", "HandleEffectStateChange");

	Params::YumiPassiveAbilityMod1_HandleEffectStateChange Parms{};

	Parms.bAffected = bAffected;
	Parms.AffectedActor = AffectedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.YumiPassiveAbilityMod1.HandleMiscToolSpawned
// (Final, Native, Protected)
// Parameters:
// class AActor*                           SpawnedTool                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AYumiPassiveAbilityMod1::HandleMiscToolSpawned(class AActor* SpawnedTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YumiPassiveAbilityMod1", "HandleMiscToolSpawned");

	Params::YumiPassiveAbilityMod1_HandleMiscToolSpawned Parms{};

	Parms.SpawnedTool = SpawnedTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.YumiPassiveAbilityMod1.HandlePlaceableSpawned
// (Final, Native, Protected)
// Parameters:
// class ABasePlaceable*                   NewPlaceable                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AYumiPassiveAbilityMod1::HandlePlaceableSpawned(class ABasePlaceable* NewPlaceable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YumiPassiveAbilityMod1", "HandlePlaceableSpawned");

	Params::YumiPassiveAbilityMod1_HandlePlaceableSpawned Parms{};

	Parms.NewPlaceable = NewPlaceable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.YumiPassiveAbilityMod1.HandleSpyToolLoadComplete
// (Final, Native, Protected)
// Parameters:
// class UToolLoadoutComponent*            ToolLoadout                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AYumiPassiveAbilityMod1::HandleSpyToolLoadComplete(class UToolLoadoutComponent* ToolLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YumiPassiveAbilityMod1", "HandleSpyToolLoadComplete");

	Params::YumiPassiveAbilityMod1_HandleSpyToolLoadComplete Parms{};

	Parms.ToolLoadout = ToolLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.YumiPassiveAbilityMod1.NotifyActorAffected_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           AffectedActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAffected                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AYumiPassiveAbilityMod1::NotifyActorAffected_Multicast(class AActor* AffectedActor, bool bAffected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YumiPassiveAbilityMod1", "NotifyActorAffected_Multicast");

	Params::YumiPassiveAbilityMod1_NotifyActorAffected_Multicast Parms{};

	Parms.AffectedActor = AffectedActor;
	Parms.bAffected = bAffected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SprayChargeSpawnerWeapon.BP_OnSprayImpacts
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class AProjectileWeapon*                Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSprayShotImpact>         Impacts                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ASprayChargeSpawnerWeapon::BP_OnSprayImpacts(class AProjectileWeapon* Weapon, const TArray<struct FSprayShotImpact>& Impacts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SprayChargeSpawnerWeapon", "BP_OnSprayImpacts");

	Params::SprayChargeSpawnerWeapon_BP_OnSprayImpacts Parms{};

	Parms.Weapon = Weapon;
	Parms.Impacts = std::move(Impacts);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.SprayChargeSpawnerWeapon.BP_OnSprayNoDamageImpacts
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class AProjectileWeapon*                Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSprayShotImpact>         Impacts                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ASprayChargeSpawnerWeapon::BP_OnSprayNoDamageImpacts(class AProjectileWeapon* Weapon, const TArray<struct FSprayShotImpact>& Impacts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SprayChargeSpawnerWeapon", "BP_OnSprayNoDamageImpacts");

	Params::SprayChargeSpawnerWeapon_BP_OnSprayNoDamageImpacts Parms{};

	Parms.Weapon = Weapon;
	Parms.Impacts = std::move(Impacts);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.SprayChargeSpawnerWeapon.BP_OnSprayShotFired
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<struct FVector>                  ShotEndPoints                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AProjectileWeapon*                Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASprayChargeSpawnerWeapon::BP_OnSprayShotFired(const TArray<struct FVector>& ShotEndPoints, class AProjectileWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SprayChargeSpawnerWeapon", "BP_OnSprayShotFired");

	Params::SprayChargeSpawnerWeapon_BP_OnSprayShotFired Parms{};

	Parms.ShotEndPoints = std::move(ShotEndPoints);
	Parms.Weapon = Weapon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.SprayWeapon.BP_OnSprayImpacts
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class AProjectileWeapon*                Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSprayShotImpact>         Impacts                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ASprayWeapon::BP_OnSprayImpacts(class AProjectileWeapon* Weapon, const TArray<struct FSprayShotImpact>& Impacts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SprayWeapon", "BP_OnSprayImpacts");

	Params::SprayWeapon_BP_OnSprayImpacts Parms{};

	Parms.Weapon = Weapon;
	Parms.Impacts = std::move(Impacts);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.SprayWeapon.BP_OnSprayNoDamageImpacts
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class AProjectileWeapon*                Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSprayShotImpact>         Impacts                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ASprayWeapon::BP_OnSprayNoDamageImpacts(class AProjectileWeapon* Weapon, const TArray<struct FSprayShotImpact>& Impacts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SprayWeapon", "BP_OnSprayNoDamageImpacts");

	Params::SprayWeapon_BP_OnSprayNoDamageImpacts Parms{};

	Parms.Weapon = Weapon;
	Parms.Impacts = std::move(Impacts);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.SprayWeapon.BP_OnSprayShotFired
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<struct FVector>                  ShotEndPoints                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AProjectileWeapon*                Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASprayWeapon::BP_OnSprayShotFired(const TArray<struct FVector>& ShotEndPoints, class AProjectileWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SprayWeapon", "BP_OnSprayShotFired");

	Params::SprayWeapon_BP_OnSprayShotFired Parms{};

	Parms.ShotEndPoints = std::move(ShotEndPoints);
	Parms.Weapon = Weapon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.Spy.AddAlwaysVisibleMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   InMesh                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::AddAlwaysVisibleMesh(class UMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "AddAlwaysVisibleMesh");

	Params::Spy_AddAlwaysVisibleMesh Parms{};

	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.AddCoverAffectingSource
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewCoverDrainSource                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECoverAffectingSourceType               NewCoverAffectingType                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::AddCoverAffectingSource(class AActor* NewCoverDrainSource, ECoverAffectingSourceType NewCoverAffectingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "AddCoverAffectingSource");

	Params::Spy_AddCoverAffectingSource Parms{};

	Parms.NewCoverDrainSource = NewCoverDrainSource;
	Parms.NewCoverAffectingType = NewCoverAffectingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.AddCoverDrainSource
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewCoverDrainSource                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewCoverDrain                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::AddCoverDrainSource(class AActor* NewCoverDrainSource, float NewCoverDrain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "AddCoverDrainSource");

	Params::Spy_AddCoverDrainSource Parms{};

	Parms.NewCoverDrainSource = NewCoverDrainSource;
	Parms.NewCoverDrain = NewCoverDrain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.AddEffectFromNPC
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AVictimEffect*                    InNewEffect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::AddEffectFromNPC(class AVictimEffect* InNewEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "AddEffectFromNPC");

	Params::Spy_AddEffectFromNPC Parms{};

	Parms.InNewEffect = InNewEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.AddRecoverReduction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Reduction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::AddRecoverReduction(float Reduction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "AddRecoverReduction");

	Params::Spy_AddRecoverReduction Parms{};

	Parms.Reduction = Reduction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.AddRunSpeedFactor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InNewSpeedFactor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::AddRunSpeedFactor(float InNewSpeedFactor, class AActor* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "AddRunSpeedFactor");

	Params::Spy_AddRunSpeedFactor Parms{};

	Parms.InNewSpeedFactor = InNewSpeedFactor;
	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.AddSlowSource
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewSlowSource                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewSlowPercent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::AddSlowSource(class AActor* NewSlowSource, float NewSlowPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "AddSlowSource");

	Params::Spy_AddSlowSource Parms{};

	Parms.NewSlowSource = NewSlowSource;
	Parms.NewSlowPercent = NewSlowPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.AllowActiveAbility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAllow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::AllowActiveAbility(bool bAllow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "AllowActiveAbility");

	Params::Spy_AllowActiveAbility Parms{};

	Parms.bAllow = bAllow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.AllowCover
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAllow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::AllowCover(bool bAllow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "AllowCover");

	Params::Spy_AllowCover Parms{};

	Parms.bAllow = bAllow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.AllowMelee
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAllow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::AllowMelee(bool bAllow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "AllowMelee");

	Params::Spy_AllowMelee Parms{};

	Parms.bAllow = bAllow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.AllowNavMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAllow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::AllowNavMode(bool bAllow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "AllowNavMode");

	Params::Spy_AllowNavMode Parms{};

	Parms.bAllow = bAllow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.AllowWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAllow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::AllowWeapon(bool bAllow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "AllowWeapon");

	Params::Spy_AllowWeapon Parms{};

	Parms.bAllow = bAllow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.AttachCurrentToolToMainAttachment
// (Final, Native, Public, BlueprintCallable)

void ASpy::AttachCurrentToolToMainAttachment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "AttachCurrentToolToMainAttachment");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.AttachCurrentToolToSocket
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::AttachCurrentToolToSocket(class FName SocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "AttachCurrentToolToSocket");

	Params::Spy_AttachCurrentToolToSocket Parms{};

	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.AttachToolToMainAttachment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ABaseSpyTool*                     ToolToAttatch                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::AttachToolToMainAttachment(class ABaseSpyTool* ToolToAttatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "AttachToolToMainAttachment");

	Params::Spy_AttachToolToMainAttachment Parms{};

	Parms.ToolToAttatch = ToolToAttatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.AttachToolToMeshOnAlternateBone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           TargetMesh                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::AttachToolToMeshOnAlternateBone(class USkeletalMeshComponent* TargetMesh, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "AttachToolToMeshOnAlternateBone");

	Params::Spy_AttachToolToMeshOnAlternateBone Parms{};

	Parms.TargetMesh = TargetMesh;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.AuthExternalBlowCover
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AController*                      InstigatedByIn                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           BlowCoverSourceActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::AuthExternalBlowCover(class AController* InstigatedByIn, class AActor* BlowCoverSourceActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "AuthExternalBlowCover");

	Params::Spy_AuthExternalBlowCover Parms{};

	Parms.InstigatedByIn = InstigatedByIn;
	Parms.BlowCoverSourceActor = BlowCoverSourceActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.BlockToolActions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bBlock                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::BlockToolActions(bool bBlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "BlockToolActions");

	Params::Spy_BlockToolActions Parms{};

	Parms.bBlock = bBlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.BP_BlockLeftHandFlavorAnimations
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bBlock                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBlockLeftHandFavorAnimationsBlueprintTypeFlagIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::BP_BlockLeftHandFlavorAnimations(bool bBlock, EBlockLeftHandFavorAnimationsBlueprintType FlagIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "BP_BlockLeftHandFlavorAnimations");

	Params::Spy_BP_BlockLeftHandFlavorAnimations Parms{};

	Parms.bBlock = bBlock;
	Parms.FlagIn = FlagIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.BP_CancelHealingConsumable
// (Event, Protected, BlueprintEvent)

void ASpy::BP_CancelHealingConsumable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "BP_CancelHealingConsumable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.Spy.BP_DebugGetShowRoomName
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::BP_DebugGetShowRoomName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "BP_DebugGetShowRoomName");

	Params::Spy_BP_DebugGetShowRoomName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.BP_GetCheatHideHuds
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::BP_GetCheatHideHuds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "BP_GetCheatHideHuds");

	Params::Spy_BP_GetCheatHideHuds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.BP_OnBounce
// (Event, Protected, BlueprintEvent)

void ASpy::BP_OnBounce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "BP_OnBounce");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.Spy.BP_OnCoverBlown
// (Event, Public, BlueprintEvent)

void ASpy::BP_OnCoverBlown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "BP_OnCoverBlown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.Spy.BP_OnCoverRatioUpdate
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   NewRatio                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::BP_OnCoverRatioUpdate(float NewRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "BP_OnCoverRatioUpdate");

	Params::Spy_BP_OnCoverRatioUpdate Parms{};

	Parms.NewRatio = NewRatio;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.Spy.BP_OnCoverRegained
// (Event, Public, BlueprintEvent)

void ASpy::BP_OnCoverRegained()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "BP_OnCoverRegained");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.Spy.BP_OnCoverSwitched
// (Event, Public, BlueprintEvent)
// Parameters:
// class ANPCCharacter*                    NewDisguise                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsFirstDisguise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowFeedback                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::BP_OnCoverSwitched(class ANPCCharacter* NewDisguise, bool bIsFirstDisguise, bool bShowFeedback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "BP_OnCoverSwitched");

	Params::Spy_BP_OnCoverSwitched Parms{};

	Parms.NewDisguise = NewDisguise;
	Parms.bIsFirstDisguise = bIsFirstDisguise;
	Parms.bShowFeedback = bShowFeedback;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.Spy.BP_OnCoverSwitchedVisualFeedback
// (Event, Public, BlueprintEvent)
// Parameters:
// class ANPCCharacter*                    NewDisguise                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::BP_OnCoverSwitchedVisualFeedback(class ANPCCharacter* NewDisguise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "BP_OnCoverSwitchedVisualFeedback");

	Params::Spy_BP_OnCoverSwitchedVisualFeedback Parms{};

	Parms.NewDisguise = NewDisguise;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.Spy.BP_OnHealthConsumableEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// ESpyHealthConsumableEvent               Event                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::BP_OnHealthConsumableEvent(ESpyHealthConsumableEvent Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "BP_OnHealthConsumableEvent");

	Params::Spy_BP_OnHealthConsumableEvent Parms{};

	Parms.Event = Event;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.Spy.BP_OnHudLoaded
// (Event, Public, BlueprintEvent)
// Parameters:
// class UUserWidget*                      HUD                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::BP_OnHudLoaded(class UUserWidget* HUD)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "BP_OnHudLoaded");

	Params::Spy_BP_OnHudLoaded Parms{};

	Parms.HUD = HUD;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.Spy.BP_OnIntroCoverRegained
// (Event, Public, BlueprintEvent)

void ASpy::BP_OnIntroCoverRegained()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "BP_OnIntroCoverRegained");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.Spy.BP_OnLocalFallLand
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   FallStep                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FallDamageAmount                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::BP_OnLocalFallLand(int32 FallStep, int32 FallDamageAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "BP_OnLocalFallLand");

	Params::Spy_BP_OnLocalFallLand Parms{};

	Parms.FallStep = FallStep;
	Parms.FallDamageAmount = FallDamageAmount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.Spy.BP_OnServerBeginPlay
// (Event, Public, BlueprintEvent)

void ASpy::BP_OnServerBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "BP_OnServerBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.Spy.BP_OnSpyDisappear
// (Event, Public, BlueprintEvent)

void ASpy::BP_OnSpyDisappear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "BP_OnSpyDisappear");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.Spy.BP_OnStartUsingFirstAid
// (Event, Public, BlueprintEvent)

void ASpy::BP_OnStartUsingFirstAid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "BP_OnStartUsingFirstAid");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.Spy.BP_OnStopUsingFirstAid
// (Event, Public, BlueprintEvent)

void ASpy::BP_OnStopUsingFirstAid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "BP_OnStopUsingFirstAid");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.Spy.BPSetWantedHeatLevel
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::BPSetWantedHeatLevel(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "BPSetWantedHeatLevel");

	Params::Spy_BPSetWantedHeatLevel Parms{};

	Parms.Level = Level;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.Spy.CancelLeftHandFlavorAnimations
// (Final, Native, Public, BlueprintCallable)

void ASpy::CancelLeftHandFlavorAnimations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "CancelLeftHandFlavorAnimations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.CanUseHealingConsumable
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::CanUseHealingConsumable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "CanUseHealingConsumable");

	Params::Spy_CanUseHealingConsumable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.Client_ObjectiveCarriedByYourTeam
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// bool                                    bYourFactionHasObjective                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::Client_ObjectiveCarriedByYourTeam(bool bYourFactionHasObjective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "Client_ObjectiveCarriedByYourTeam");

	Params::Spy_Client_ObjectiveCarriedByYourTeam Parms{};

	Parms.bYourFactionHasObjective = bYourFactionHasObjective;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.Client_ObjectiveDistanceProximityLevelChanged
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// uint8                                   NewLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::Client_ObjectiveDistanceProximityLevelChanged(uint8 NewLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "Client_ObjectiveDistanceProximityLevelChanged");

	Params::Spy_Client_ObjectiveDistanceProximityLevelChanged Parms{};

	Parms.NewLevel = NewLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.Client_OnConfirmDamageDealt
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsDead                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::Client_OnConfirmDamageDealt(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, bool bIsDead)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "Client_OnConfirmDamageDealt");

	Params::Spy_Client_OnConfirmDamageDealt Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.Damage = Damage;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.bIsDead = bIsDead;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.Client_OnFallLand
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// int32                                   FallStep                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FallDamageAmount                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::Client_OnFallLand(int32 FallStep, int32 FallDamageAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "Client_OnFallLand");

	Params::Spy_Client_OnFallLand Parms{};

	Parms.FallStep = FallStep;
	Parms.FallDamageAmount = FallDamageAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.Client_OnStartNPCInteract
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// class UNPCInteraction*                  InteractIn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::Client_OnStartNPCInteract(class UNPCInteraction* InteractIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "Client_OnStartNPCInteract");

	Params::Spy_Client_OnStartNPCInteract Parms{};

	Parms.InteractIn = InteractIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.CreateAnimationProp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             NameID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorToCreate                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachSocket                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFirstPerson                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ASpy::CreateAnimationProp(class FName NameID, TSubclassOf<class AActor> ActorToCreate, class FName AttachSocket, bool bFirstPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "CreateAnimationProp");

	Params::Spy_CreateAnimationProp Parms{};

	Parms.NameID = NameID;
	Parms.ActorToCreate = ActorToCreate;
	Parms.AttachSocket = AttachSocket;
	Parms.bFirstPerson = bFirstPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.DecrementHeat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Decrement                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::DecrementHeat(int32 Decrement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "DecrementHeat");

	Params::Spy_DecrementHeat Parms{};

	Parms.Decrement = Decrement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.DestroyAnimationProp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             NameID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFirstPerson                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::DestroyAnimationProp(class FName NameID, bool bFirstPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "DestroyAnimationProp");

	Params::Spy_DestroyAnimationProp Parms{};

	Parms.NameID = NameID;
	Parms.bFirstPerson = bFirstPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.DisableBlockRun
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDisable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::DisableBlockRun(bool bDisable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "DisableBlockRun");

	Params::Spy_DisableBlockRun Parms{};

	Parms.bDisable = bDisable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.DisableRun
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDisableRun                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::DisableRun(class AActor* Source, bool bDisableRun)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "DisableRun");

	Params::Spy_DisableRun Parms{};

	Parms.Source = Source;
	Parms.bDisableRun = bDisableRun;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.ExternalBounce
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ImpulseToApply                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           BouncedBy                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::ExternalBounce(const struct FVector& ImpulseToApply, class AActor* BouncedBy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "ExternalBounce");

	Params::Spy_ExternalBounce Parms{};

	Parms.ImpulseToApply = std::move(ImpulseToApply);
	Parms.BouncedBy = BouncedBy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.ExternalServerCompleteInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractableComponent*           InteractableComp_0                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::ExternalServerCompleteInteraction(class UInteractableComponent* InteractableComp_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "ExternalServerCompleteInteraction");

	Params::Spy_ExternalServerCompleteInteraction Parms{};

	Parms.InteractableComp_0 = InteractableComp_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.ExtractSetBlockingPlayer_Client
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    bBlocking                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::ExtractSetBlockingPlayer_Client(bool bBlocking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "ExtractSetBlockingPlayer_Client");

	Params::Spy_ExtractSetBlockingPlayer_Client Parms{};

	Parms.bBlocking = bBlocking;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.ExtractSetuptExtractZone_Client
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AExtractionInteractableActor*     Extract                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::ExtractSetuptExtractZone_Client(class AExtractionInteractableActor* Extract)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "ExtractSetuptExtractZone_Client");

	Params::Spy_ExtractSetuptExtractZone_Client Parms{};

	Parms.Extract = Extract;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.Force3rdPersonView
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    b3PForced                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::Force3rdPersonView(bool b3PForced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "Force3rdPersonView");

	Params::Spy_Force3rdPersonView Parms{};

	Parms.b3PForced = b3PForced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.ForceKillcamRevive
// (Net, NetReliable, Native, Event, Public, NetServer)

void ASpy::ForceKillcamRevive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "ForceKillcamRevive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.GetAnimationProp
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             NameID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFirstPerson                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ASpy::GetAnimationProp(class FName NameID, bool bFirstPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetAnimationProp");

	Params::Spy_GetAnimationProp Parms{};

	Parms.NameID = NameID;
	Parms.bFirstPerson = bFirstPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetCurrentHeatLevel
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASpy::GetCurrentHeatLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetCurrentHeatLevel");

	Params::Spy_GetCurrentHeatLevel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetCurrentHeatValue
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASpy::GetCurrentHeatValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetCurrentHeatValue");

	Params::Spy_GetCurrentHeatValue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetDIPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADeceiveIncPlayerController*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADeceiveIncPlayerController* ASpy::GetDIPlayerController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetDIPlayerController");

	Params::Spy_GetDIPlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetPlayerHud
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* ASpy::GetPlayerHud()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetPlayerHud");

	Params::Spy_GetPlayerHud Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetPowerupLevel
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// EPowerupType                            Powerup                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESecurityLevel                          Level                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAvailable                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::GetPowerupLevel(EPowerupType Powerup, ESecurityLevel* Level, bool* bAvailable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetPowerupLevel");

	Params::Spy_GetPowerupLevel Parms{};

	Parms.Powerup = Powerup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Level != nullptr)
		*Level = Parms.Level;

	if (bAvailable != nullptr)
		*bAvailable = Parms.bAvailable;
}


// Function DeceiveInc.Spy.GetSpyActiveEffectsOfClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                           EffectClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AVictimEffect*>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AVictimEffect*> ASpy::GetSpyActiveEffectsOfClass(class UClass* EffectClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetSpyActiveEffectsOfClass");

	Params::Spy_GetSpyActiveEffectsOfClass Parms{};

	Parms.EffectClass = EffectClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.HandleActiveAbilityLoadComplete
// (Final, Native, Protected)
// Parameters:
// class ABaseSpyTool*                     NewActiveAbility                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleActiveAbilityLoadComplete(class ABaseSpyTool* NewActiveAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleActiveAbilityLoadComplete");

	Params::Spy_HandleActiveAbilityLoadComplete Parms{};

	Parms.NewActiveAbility = NewActiveAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleActiveHandToolEvent
// (Final, Native, Protected)
// Parameters:
// ESpyToolEvent                           EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleActiveHandToolEvent(ESpyToolEvent EventType, class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleActiveHandToolEvent");

	Params::Spy_HandleActiveHandToolEvent Parms{};

	Parms.EventType = EventType;
	Parms.SpyTool = SpyTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleBooleanPlayerSettingChange
// (Final, Native, Protected)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleBooleanPlayerSettingChange(EPlayerSettingsType SettingType, bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleBooleanPlayerSettingChange");

	Params::Spy_HandleBooleanPlayerSettingChange Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleCallingCardToolFullThrowEnd
// (Final, Native, Protected)

void ASpy::HandleCallingCardToolFullThrowEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleCallingCardToolFullThrowEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleDeath
// (Final, Native, Protected)
// Parameters:
// class AActor*                           DeadActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleDeath(class AActor* DeadActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleDeath");

	Params::Spy_HandleDeath Parms{};

	Parms.DeadActor = DeadActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleEMPIsAffectedChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bIsAffected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AffectedActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleEMPIsAffectedChanged(bool bIsAffected, class AActor* AffectedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleEMPIsAffectedChanged");

	Params::Spy_HandleEMPIsAffectedChanged Parms{};

	Parms.bIsAffected = bIsAffected;
	Parms.AffectedActor = AffectedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleFloatPlayerSettingChange
// (Final, Native, Protected)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleFloatPlayerSettingChange(EPlayerSettingsType SettingType, float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleFloatPlayerSettingChange");

	Params::Spy_HandleFloatPlayerSettingChange Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleHealthChanged
// (Final, Native, Protected)
// Parameters:
// class UHealthComponent*                 OwningHealthComp                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Health                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HealthDelta                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RawDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleHealthChanged(class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, float RawDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleHealthChanged");

	Params::Spy_HandleHealthChanged Parms{};

	Parms.OwningHealthComp = OwningHealthComp;
	Parms.Health = Health;
	Parms.HealthDelta = HealthDelta;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.RawDamage = RawDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleInstigateZeroDamage
// (Final, Native, Protected)
// Parameters:
// class UHealthComponent*                 OwningHealthComp                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleInstigateZeroDamage(class UHealthComponent* OwningHealthComp, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleInstigateZeroDamage");

	Params::Spy_HandleInstigateZeroDamage Parms{};

	Parms.OwningHealthComp = OwningHealthComp;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleInteractableCompCancel
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleInteractableCompCancel(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleInteractableCompCancel");

	Params::Spy_HandleInteractableCompCancel Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleInteractableCompStart
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleInteractableCompStart(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleInteractableCompStart");

	Params::Spy_HandleInteractableCompStart Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleInteractionComplete
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleInteractionComplete");

	Params::Spy_HandleInteractionComplete Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleIntPlayerSettingChange
// (Final, Native, Protected)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleIntPlayerSettingChange(EPlayerSettingsType SettingType, int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleIntPlayerSettingChange");

	Params::Spy_HandleIntPlayerSettingChange Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleLoadoutSpawnCompleteEvent
// (Final, Native, Protected)
// Parameters:
// class UToolLoadoutComponent*            ToolLoadout                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleLoadoutSpawnCompleteEvent(class UToolLoadoutComponent* ToolLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleLoadoutSpawnCompleteEvent");

	Params::Spy_HandleLoadoutSpawnCompleteEvent Parms{};

	Parms.ToolLoadout = ToolLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleLocalInteractionCanceled
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleLocalInteractionCanceled(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleLocalInteractionCanceled");

	Params::Spy_HandleLocalInteractionCanceled Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleLocalInteractionComplete
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleLocalInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleLocalInteractionComplete");

	Params::Spy_HandleLocalInteractionComplete Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleLocalInteractionStart
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleLocalInteractionStart(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleLocalInteractionStart");

	Params::Spy_HandleLocalInteractionStart Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleLocalResourceAmountChanged
// (Final, Native, Protected)
// Parameters:
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ResourceDisplayName                                    (Parm, NativeAccessSpecifierPublic)
// int32                                   AmountDelta                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleLocalResourceAmountChanged(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 AmountDelta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleLocalResourceAmountChanged");

	Params::Spy_HandleLocalResourceAmountChanged Parms{};

	Parms.ResourceType = ResourceType;
	Parms.ResourceDisplayName = std::move(ResourceDisplayName);
	Parms.AmountDelta = AmountDelta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleMeleeAttackLoadComplete
// (Final, Native, Protected)
// Parameters:
// class ABaseSpyTool*                     NewMeleeAttack                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleMeleeAttackLoadComplete(class ABaseSpyTool* NewMeleeAttack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleMeleeAttackLoadComplete");

	Params::Spy_HandleMeleeAttackLoadComplete Parms{};

	Parms.NewMeleeAttack = NewMeleeAttack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleNewRadialMenuPingSelection
// (Final, Native, Protected)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleNewRadialMenuPingSelection(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleNewRadialMenuPingSelection");

	Params::Spy_HandleNewRadialMenuPingSelection Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleOverlapBegin
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleOverlapBegin");

	Params::Spy_HandleOverlapBegin Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleOverlapEnd
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleOverlapEnd");

	Params::Spy_HandleOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleResourceNewAmount
// (Final, Native, Protected)
// Parameters:
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ResourceDisplayName                                    (Parm, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleResourceNewAmount(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleResourceNewAmount");

	Params::Spy_HandleResourceNewAmount Parms{};

	Parms.ResourceType = ResourceType;
	Parms.ResourceDisplayName = std::move(ResourceDisplayName);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleResultScreenStart
// (Final, Native, Public)
// Parameters:
// class UResultScreenPhaseInfo*           PhaseInfo                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleResultScreenStart(class UResultScreenPhaseInfo* PhaseInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleResultScreenStart");

	Params::Spy_HandleResultScreenStart Parms{};

	Parms.PhaseInfo = PhaseInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleRevive
// (Final, Native, Protected)
// Parameters:
// class AActor*                           RevivedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleRevive(class AActor* RevivedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleRevive");

	Params::Spy_HandleRevive Parms{};

	Parms.RevivedActor = RevivedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleScramblerAffectingSourceRegister
// (Final, Native, Protected)
// Parameters:
// class AActor*                           AffectingSource                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AffectedActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleScramblerAffectingSourceRegister(class AActor* AffectingSource, class AActor* AffectedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleScramblerAffectingSourceRegister");

	Params::Spy_HandleScramblerAffectingSourceRegister Parms{};

	Parms.AffectingSource = AffectingSource;
	Parms.AffectedActor = AffectedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleScramblerAffectingSourceUnregister
// (Final, Native, Protected)
// Parameters:
// class AActor*                           AffectingSource                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AffectedActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleScramblerAffectingSourceUnregister(class AActor* AffectingSource, class AActor* AffectedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleScramblerAffectingSourceUnregister");

	Params::Spy_HandleScramblerAffectingSourceUnregister Parms{};

	Parms.AffectingSource = AffectingSource;
	Parms.AffectedActor = AffectedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleScramblerIsAffectedChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bIsAffected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AffectedActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleScramblerIsAffectedChanged(bool bIsAffected, class AActor* AffectedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleScramblerIsAffectedChanged");

	Params::Spy_HandleScramblerIsAffectedChanged Parms{};

	Parms.bIsAffected = bIsAffected;
	Parms.AffectedActor = AffectedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleSelectedToolChangeLoadoutEvent
// (Final, Native, Protected)
// Parameters:
// class ABaseSpyTool*                     NewToolInHand                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELoadoutSlot                            NewSelectedSlot                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleSelectedToolChangeLoadoutEvent(class ABaseSpyTool* NewToolInHand, ELoadoutSlot NewSelectedSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleSelectedToolChangeLoadoutEvent");

	Params::Spy_HandleSelectedToolChangeLoadoutEvent Parms{};

	Parms.NewToolInHand = NewToolInHand;
	Parms.NewSelectedSlot = NewSelectedSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleSpyToolLoadComplete
// (Final, Native, Protected)
// Parameters:
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleSpyToolLoadComplete(class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleSpyToolLoadComplete");

	Params::Spy_HandleSpyToolLoadComplete Parms{};

	Parms.SpyTool = SpyTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleTakePointDamage
// (Final, Native, Protected, HasDefaults)
// Parameters:
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              FHitComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ShotFromDirection                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HandleTakePointDamage(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& ShotFromDirection, const class UDamageType* DamageType, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleTakePointDamage");

	Params::Spy_HandleTakePointDamage Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.Damage = Damage;
	Parms.InstigatedBy = InstigatedBy;
	Parms.HitLocation = std::move(HitLocation);
	Parms.FHitComponent = FHitComponent;
	Parms.BoneName = BoneName;
	Parms.ShotFromDirection = std::move(ShotFromDirection);
	Parms.DamageType = DamageType;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleWeaponHitConfirmed
// (Final, Native, Protected)
// Parameters:
// struct FHitConfirmData                  HitConfirmedData                                       (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASpy::HandleWeaponHitConfirmed(const struct FHitConfirmData& HitConfirmedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleWeaponHitConfirmed");

	Params::Spy_HandleWeaponHitConfirmed Parms{};

	Parms.HitConfirmedData = std::move(HitConfirmedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HandleWeaponProjectileImpact
// (Final, Native, Protected)
// Parameters:
// struct FWeaponImpactData                WeaponImpactData                                       (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASpy::HandleWeaponProjectileImpact(const struct FWeaponImpactData& WeaponImpactData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HandleWeaponProjectileImpact");

	Params::Spy_HandleWeaponProjectileImpact Parms{};

	Parms.WeaponImpactData = std::move(WeaponImpactData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HeatTriggerNPCHit
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   NPCSecurityIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageRatio                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNpcKilled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HeatTriggerNPCHit(int32 NPCSecurityIndex, float DamageRatio, bool bNpcKilled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HeatTriggerNPCHit");

	Params::Spy_HeatTriggerNPCHit Parms{};

	Parms.NPCSecurityIndex = NPCSecurityIndex;
	Parms.DamageRatio = DamageRatio;
	Parms.bNpcKilled = bNpcKilled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HidePlayerHud
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Requester                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::HidePlayerHud(class AActor* Requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HidePlayerHud");

	Params::Spy_HidePlayerHud Parms{};

	Parms.Requester = Requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.HideToolsHud
// (Final, Native, Public, BlueprintCallable)

void ASpy::HideToolsHud()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "HideToolsHud");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.IncrementHeat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Increment                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::IncrementHeat(int32 Increment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IncrementHeat");

	Params::Spy_IncrementHeat Parms{};

	Parms.Increment = Increment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.IncrementStamina
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::IncrementStamina(float Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IncrementStamina");

	Params::Spy_IncrementStamina Parms{};

	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.IsScolded
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsScolded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsScolded");

	Params::Spy_IsScolded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsTeamAlive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsTeamAlive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsTeamAlive");

	Params::Spy_IsTeamAlive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.KeepRunAdditiveWhileRunningOutOfCover
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bKeepAdditive                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::KeepRunAdditiveWhileRunningOutOfCover(bool bKeepAdditive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "KeepRunAdditiveWhileRunningOutOfCover");

	Params::Spy_KeepRunAdditiveWhileRunningOutOfCover Parms{};

	Parms.bKeepAdditive = bKeepAdditive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.MakeSpyAndDisguiseInvisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInvisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::MakeSpyAndDisguiseInvisible(bool bInvisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "MakeSpyAndDisguiseInvisible");

	Params::Spy_MakeSpyAndDisguiseInvisible Parms{};

	Parms.bInvisible = bInvisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.NetMulticast_DirectionalDamageReceived
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              ShotFromDirection                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHitType                                HitType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::NetMulticast_DirectionalDamageReceived(float Damage, const struct FVector_NetQuantize& ShotFromDirection, EHitType HitType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "NetMulticast_DirectionalDamageReceived");

	Params::Spy_NetMulticast_DirectionalDamageReceived Parms{};

	Parms.Damage = Damage;
	Parms.ShotFromDirection = std::move(ShotFromDirection);
	Parms.HitType = HitType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.NetMulticast_ForceOutOfMimic
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ASpy::NetMulticast_ForceOutOfMimic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "NetMulticast_ForceOutOfMimic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.NetMulticast_TriggerChangeDisguiseVisualFeedback
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ANPCCharacter*                    NewDisguise                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::NetMulticast_TriggerChangeDisguiseVisualFeedback(class ANPCCharacter* NewDisguise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "NetMulticast_TriggerChangeDisguiseVisualFeedback");

	Params::Spy_NetMulticast_TriggerChangeDisguiseVisualFeedback Parms{};

	Parms.NewDisguise = NewDisguise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.NotifyAnimationStateJumpInChange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bJumpInStart                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::NotifyAnimationStateJumpInChange(bool bJumpInStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "NotifyAnimationStateJumpInChange");

	Params::Spy_NotifyAnimationStateJumpInChange Parms{};

	Parms.bJumpInStart = bJumpInStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnADSChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bADS                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::OnADSChanged(bool bADS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnADSChanged");

	Params::Spy_OnADSChanged Parms{};

	Parms.bADS = bADS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnAffectingSourceRegister
// (Final, Native, Protected)
// Parameters:
// class AActor*                           AffectingSource                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AffectedActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::OnAffectingSourceRegister(class AActor* AffectingSource, class AActor* AffectedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnAffectingSourceRegister");

	Params::Spy_OnAffectingSourceRegister Parms{};

	Parms.AffectingSource = AffectingSource;
	Parms.AffectedActor = AffectedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnAffectingSourceUnregister
// (Final, Native, Protected)
// Parameters:
// class AActor*                           AffectingSource                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AffectedActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::OnAffectingSourceUnregister(class AActor* AffectingSource, class AActor* AffectedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnAffectingSourceUnregister");

	Params::Spy_OnAffectingSourceUnregister Parms{};

	Parms.AffectingSource = AffectingSource;
	Parms.AffectedActor = AffectedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnAwardKillTimerEnd
// (Final, Native, Protected)

void ASpy::OnAwardKillTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnAwardKillTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnBlockRunAfterShootingTimerEnd
// (Final, Native, Public)

void ASpy::OnBlockRunAfterShootingTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnBlockRunAfterShootingTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnBlockShootingAfterRunTimerEnd
// (Final, Native, Public)

void ASpy::OnBlockShootingAfterRunTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnBlockShootingAfterRunTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnCheatToggleAutoShootForeverTimerEnd
// (Final, Native, Protected)

void ASpy::OnCheatToggleAutoShootForeverTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnCheatToggleAutoShootForeverTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction DeceiveInc.Spy.OnConfirmedDamageDealt__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::OnConfirmedDamageDealt__DelegateSignature(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnConfirmedDamageDealt__DelegateSignature");

	Params::Spy_OnConfirmedDamageDealt__DelegateSignature Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.Damage = Damage;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.Spy.OnDelayed3PTimerEnd
// (Final, Native, Protected)

void ASpy::OnDelayed3PTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnDelayed3PTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnHealthConsumableDisableCompleted
// (Final, Native, Public)

void ASpy::OnHealthConsumableDisableCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnHealthConsumableDisableCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnIntroPhaseStart
// (Final, Native, Public)
// Parameters:
// class UIntroPhaseInfo*                  PhaseInfo                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::OnIntroPhaseStart(class UIntroPhaseInfo* PhaseInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnIntroPhaseStart");

	Params::Spy_OnIntroPhaseStart Parms{};

	Parms.PhaseInfo = PhaseInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnMeleeImpact
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactPoint                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ChargeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ResultingHealthPercentage                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHitType                                HitType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMeleeHitConfirmedData           HitConfirmedData                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASpy::OnMeleeImpact(class AActor* Victim, const struct FVector& ImpactPoint, int32 ChargeLevel, float Damage, float ResultingHealthPercentage, EHitType HitType, const struct FMeleeHitConfirmedData& HitConfirmedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnMeleeImpact");

	Params::Spy_OnMeleeImpact Parms{};

	Parms.Victim = Victim;
	Parms.ImpactPoint = std::move(ImpactPoint);
	Parms.ChargeLevel = ChargeLevel;
	Parms.Damage = Damage;
	Parms.ResultingHealthPercentage = ResultingHealthPercentage;
	Parms.HitType = HitType;
	Parms.HitConfirmedData = std::move(HitConfirmedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnNewActiveCameraEvent
// (Final, Native, Protected)
// Parameters:
// class UObject*                          NewActiveCamera                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECameraPriority                         NewCameraPriority                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::OnNewActiveCameraEvent(class UObject* NewActiveCamera, ECameraPriority NewCameraPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnNewActiveCameraEvent");

	Params::Spy_OnNewActiveCameraEvent Parms{};

	Parms.NewActiveCamera = NewActiveCamera;
	Parms.NewCameraPriority = NewCameraPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnNewHighestWeightCameraEvent
// (Final, Native, Protected)
// Parameters:
// class UObject*                          NewActiveCamera                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECameraPriority                         NewCameraPriority                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::OnNewHighestWeightCameraEvent(class UObject* NewActiveCamera, ECameraPriority NewCameraPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnNewHighestWeightCameraEvent");

	Params::Spy_OnNewHighestWeightCameraEvent Parms{};

	Parms.NewActiveCamera = NewActiveCamera;
	Parms.NewCameraPriority = NewCameraPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnPowerupStateChangedClient
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// EPowerupType                            PowerupType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESecurityLevel                          PowerupLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAdded                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::OnPowerupStateChangedClient(EPowerupType PowerupType, ESecurityLevel PowerupLevel, bool bAdded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnPowerupStateChangedClient");

	Params::Spy_OnPowerupStateChangedClient Parms{};

	Parms.PowerupType = PowerupType;
	Parms.PowerupLevel = PowerupLevel;
	Parms.bAdded = bAdded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnPowerupStateChangedServer
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// EPowerupType                            PowerupType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESecurityLevel                          PowerupLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAdded                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::OnPowerupStateChangedServer(EPowerupType PowerupType, ESecurityLevel PowerupLevel, bool bAdded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnPowerupStateChangedServer");

	Params::Spy_OnPowerupStateChangedServer Parms{};

	Parms.PowerupType = PowerupType;
	Parms.PowerupLevel = PowerupLevel;
	Parms.bAdded = bAdded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnRep_CachedDIPlayerState
// (Final, Native, Protected)

void ASpy::OnRep_CachedDIPlayerState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnRep_CachedDIPlayerState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnRep_ControlledByDisguise
// (Final, Native, Protected)
// Parameters:
// struct FControlledByDisguiseData        PrevControlledByDisguiseData                           (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ASpy::OnRep_ControlledByDisguise(const struct FControlledByDisguiseData& PrevControlledByDisguiseData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnRep_ControlledByDisguise");

	Params::Spy_OnRep_ControlledByDisguise Parms{};

	Parms.PrevControlledByDisguiseData = std::move(PrevControlledByDisguiseData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnRep_CoverDrainSpeed
// (Final, Native, Protected)
// Parameters:
// float                                   OldCoverDrain                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::OnRep_CoverDrainSpeed(float OldCoverDrain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnRep_CoverDrainSpeed");

	Params::Spy_OnRep_CoverDrainSpeed Parms{};

	Parms.OldCoverDrain = OldCoverDrain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnRep_CoverRatio
// (Final, Native, Protected)
// Parameters:
// float                                   PreviousCoverRatio                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::OnRep_CoverRatio(float PreviousCoverRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnRep_CoverRatio");

	Params::Spy_OnRep_CoverRatio Parms{};

	Parms.PreviousCoverRatio = PreviousCoverRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnRep_CrouchingSpeed
// (Final, Native, Protected)
// Parameters:
// float                                   PreviousCrouchingSpeed                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::OnRep_CrouchingSpeed(float PreviousCrouchingSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnRep_CrouchingSpeed");

	Params::Spy_OnRep_CrouchingSpeed Parms{};

	Parms.PreviousCrouchingSpeed = PreviousCrouchingSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnRep_Disguise
// (Final, Native, Protected)
// Parameters:
// struct FDisguiseReplicationData         PreviousDisguiseData                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ASpy::OnRep_Disguise(const struct FDisguiseReplicationData& PreviousDisguiseData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnRep_Disguise");

	Params::Spy_OnRep_Disguise Parms{};

	Parms.PreviousDisguiseData = std::move(PreviousDisguiseData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnRep_HeatInfo
// (Final, Native, Protected)
// Parameters:
// struct FHeatStateData                   OldState                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ASpy::OnRep_HeatInfo(const struct FHeatStateData& OldState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnRep_HeatInfo");

	Params::Spy_OnRep_HeatInfo Parms{};

	Parms.OldState = std::move(OldState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnRep_Hidden
// (Final, Native, Protected)

void ASpy::OnRep_Hidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnRep_Hidden");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnRep_Imaterial
// (Final, Native, Protected)

void ASpy::OnRep_Imaterial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnRep_Imaterial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnRep_InVault
// (Final, Native, Protected)

void ASpy::OnRep_InVault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnRep_InVault");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnRep_IsBot
// (Final, Native, Public)

void ASpy::OnRep_IsBot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnRep_IsBot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnRep_IsSuspicious
// (Final, Native, Protected)

void ASpy::OnRep_IsSuspicious()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnRep_IsSuspicious");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnRep_LastHealthEvent
// (Final, Native, Protected)

void ASpy::OnRep_LastHealthEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnRep_LastHealthEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnRep_NewMimic
// (Final, Native, Protected)

void ASpy::OnRep_NewMimic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnRep_NewMimic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnRep_SecurityState
// (Final, Native, Protected)
// Parameters:
// ESpySecurityState                       PreviousSecurityState                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::OnRep_SecurityState(ESpySecurityState PreviousSecurityState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnRep_SecurityState");

	Params::Spy_OnRep_SecurityState Parms{};

	Parms.PreviousSecurityState = PreviousSecurityState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnRep_SlowPercent
// (Final, Native, Protected)

void ASpy::OnRep_SlowPercent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnRep_SlowPercent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnRep_StaminaChanged
// (Final, Native, Protected)

void ASpy::OnRep_StaminaChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnRep_StaminaChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnRep_UndercoverReplicationData
// (Final, Native, Protected)
// Parameters:
// struct FUndercoverReplicationData       PreviousUndercoverReplicationData                      (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ASpy::OnRep_UndercoverReplicationData(const struct FUndercoverReplicationData& PreviousUndercoverReplicationData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnRep_UndercoverReplicationData");

	Params::Spy_OnRep_UndercoverReplicationData Parms{};

	Parms.PreviousUndercoverReplicationData = std::move(PreviousUndercoverReplicationData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnRep_WalkingSpeed
// (Final, Native, Protected)
// Parameters:
// float                                   PreviousWalkingSpeed                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::OnRep_WalkingSpeed(float PreviousWalkingSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnRep_WalkingSpeed");

	Params::Spy_OnRep_WalkingSpeed Parms{};

	Parms.PreviousWalkingSpeed = PreviousWalkingSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnSuspiciousForBotsTimerEnd
// (Final, Native, Protected)

void ASpy::OnSuspiciousForBotsTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnSuspiciousForBotsTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.OnValidateBlowCoverOnClientTimerEnd
// (Final, Native, Protected)

void ASpy::OnValidateBlowCoverOnClientTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnValidateBlowCoverOnClientTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction DeceiveInc.Spy.OnWeaponProjectileImpact__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams, HasDefaults)
// Parameters:
// class ADeceiveIncPlayerController*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactPoint                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactDirection                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactNormal                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AProjectileWeapon*                Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::OnWeaponProjectileImpact__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, class AActor* Victim, const struct FVector& ImpactPoint, const struct FVector& ImpactDirection, const struct FVector& ImpactNormal, class AProjectileWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "OnWeaponProjectileImpact__DelegateSignature");

	Params::Spy_OnWeaponProjectileImpact__DelegateSignature Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Spy = Spy;
	Parms.Victim = Victim;
	Parms.ImpactPoint = std::move(ImpactPoint);
	Parms.ImpactDirection = std::move(ImpactDirection);
	Parms.ImpactNormal = std::move(ImpactNormal);
	Parms.Weapon = Weapon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.Spy.PrepareForIntro
// (Final, Native, Public, BlueprintCallable)

void ASpy::PrepareForIntro()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "PrepareForIntro");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.ReduceStamina
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::ReduceStamina(float Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "ReduceStamina");

	Params::Spy_ReduceStamina Parms{};

	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.RemoveAlwaysVisibleMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   InMesh                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::RemoveAlwaysVisibleMesh(class UMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "RemoveAlwaysVisibleMesh");

	Params::Spy_RemoveAlwaysVisibleMesh Parms{};

	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.RemoveCoverAffectingSource
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewCoverDrainSource                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECoverAffectingSourceType               NewCoverAffectingType                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::RemoveCoverAffectingSource(class AActor* NewCoverDrainSource, ECoverAffectingSourceType NewCoverAffectingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "RemoveCoverAffectingSource");

	Params::Spy_RemoveCoverAffectingSource Parms{};

	Parms.NewCoverDrainSource = NewCoverDrainSource;
	Parms.NewCoverAffectingType = NewCoverAffectingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.RemoveCoverDrainSource
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CoverDrainSourceToRemove                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::RemoveCoverDrainSource(class AActor* CoverDrainSourceToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "RemoveCoverDrainSource");

	Params::Spy_RemoveCoverDrainSource Parms{};

	Parms.CoverDrainSourceToRemove = CoverDrainSourceToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.RemoveEffectFromNPC
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AVictimEffect*                    InNewEffect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::RemoveEffectFromNPC(class AVictimEffect* InNewEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "RemoveEffectFromNPC");

	Params::Spy_RemoveEffectFromNPC Parms{};

	Parms.InNewEffect = InNewEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.RemoveRecoverReduction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Reduction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::RemoveRecoverReduction(float Reduction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "RemoveRecoverReduction");

	Params::Spy_RemoveRecoverReduction Parms{};

	Parms.Reduction = Reduction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.RemoveRunSpeedFactor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::RemoveRunSpeedFactor(class AActor* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "RemoveRunSpeedFactor");

	Params::Spy_RemoveRunSpeedFactor Parms{};

	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.RemoveSlowSource
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           SlowSourceToRemove                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::RemoveSlowSource(class AActor* SlowSourceToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "RemoveSlowSource");

	Params::Spy_RemoveSlowSource Parms{};

	Parms.SlowSourceToRemove = SlowSourceToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.ResetAttachToolToMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           TargetMesh                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::ResetAttachToolToMesh(class USkeletalMeshComponent* TargetMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "ResetAttachToolToMesh");

	Params::Spy_ResetAttachToolToMesh Parms{};

	Parms.TargetMesh = TargetMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.ResetStaminaToMax
// (Final, Native, Protected, BlueprintCallable)

void ASpy::ResetStaminaToMax()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "ResetStaminaToMax");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.Server_ExitNPCInteract
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::Server_ExitNPCInteract(bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "Server_ExitNPCInteract");

	Params::Spy_Server_ExitNPCInteract Parms{};

	Parms.bInstant = bInstant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.Server_ForceOutOfMimic
// (Net, NetReliable, Native, Event, Protected, NetServer)

void ASpy::Server_ForceOutOfMimic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "Server_ForceOutOfMimic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.Server_SetCrouchingSpeed
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// float                                   NewCrouchingSpeed                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::Server_SetCrouchingSpeed(float NewCrouchingSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "Server_SetCrouchingSpeed");

	Params::Spy_Server_SetCrouchingSpeed Parms{};

	Parms.NewCrouchingSpeed = NewCrouchingSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.Server_SetWalkingSpeed
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// float                                   NewWalkingSpeed                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::Server_SetWalkingSpeed(float NewWalkingSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "Server_SetWalkingSpeed");

	Params::Spy_Server_SetWalkingSpeed Parms{};

	Parms.NewWalkingSpeed = NewWalkingSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.Server_SpawnPing
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// struct FVector_NetQuantize              Position                                               (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUrgent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RadialPingIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::Server_SpawnPing(const struct FVector_NetQuantize& Position, class AActor* TargetActor, bool bUrgent, int32 RadialPingIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "Server_SpawnPing");

	Params::Spy_Server_SpawnPing Parms{};

	Parms.Position = std::move(Position);
	Parms.TargetActor = TargetActor;
	Parms.bUrgent = bUrgent;
	Parms.RadialPingIndex = RadialPingIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.SetHandToolVisibilityFromAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFirstPerson                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::SetHandToolVisibilityFromAnimation(bool bVisible, bool bFirstPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "SetHandToolVisibilityFromAnimation");

	Params::Spy_SetHandToolVisibilityFromAnimation Parms{};

	Parms.bVisible = bVisible;
	Parms.bFirstPerson = bFirstPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.SetHandToolVisibilityFromAnimationFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHandToolVisibilityFromAnimationFlag    FlagIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFirstPerson                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::SetHandToolVisibilityFromAnimationFlag(EHandToolVisibilityFromAnimationFlag FlagIn, bool bVisible, bool bFirstPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "SetHandToolVisibilityFromAnimationFlag");

	Params::Spy_SetHandToolVisibilityFromAnimationFlag Parms{};

	Parms.FlagIn = FlagIn;
	Parms.bVisible = bVisible;
	Parms.bFirstPerson = bFirstPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.SetHandToolVisibilityFromAnimationFlag1PAnd3P
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHandToolVisibilityFromAnimationFlag    FlagIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::SetHandToolVisibilityFromAnimationFlag1PAnd3P(EHandToolVisibilityFromAnimationFlag FlagIn, bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "SetHandToolVisibilityFromAnimationFlag1PAnd3P");

	Params::Spy_SetHandToolVisibilityFromAnimationFlag1PAnd3P Parms{};

	Parms.FlagIn = FlagIn;
	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.SetIsHidden
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewHiddenState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBlockShooting                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::SetIsHidden(bool bNewHiddenState, bool bBlockShooting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "SetIsHidden");

	Params::Spy_SetIsHidden Parms{};

	Parms.bNewHiddenState = bNewHiddenState;
	Parms.bBlockShooting = bBlockShooting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.SetIsImmaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewImaterialState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBlockShooting                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::SetIsImmaterial(bool bNewImaterialState, bool bBlockShooting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "SetIsImmaterial");

	Params::Spy_SetIsImmaterial Parms{};

	Parms.bNewImaterialState = bNewImaterialState;
	Parms.bBlockShooting = bBlockShooting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.SetJumpInAnimationSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    JumpInAnim                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::SetJumpInAnimationSequence(class UAnimSequence* JumpInAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "SetJumpInAnimationSequence");

	Params::Spy_SetJumpInAnimationSequence Parms{};

	Parms.JumpInAnim = JumpInAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.SetRunDrainEnabled
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::SetRunDrainEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "SetRunDrainEnabled");

	Params::Spy_SetRunDrainEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.SetSecondaryHandToolVisibilityFromAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFirstPerson                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::SetSecondaryHandToolVisibilityFromAnimation(bool bVisible, bool bFirstPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "SetSecondaryHandToolVisibilityFromAnimation");

	Params::Spy_SetSecondaryHandToolVisibilityFromAnimation Parms{};

	Parms.bVisible = bVisible;
	Parms.bFirstPerson = bFirstPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.SetupHeat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FHeatSetupData                   NewHeatSetup                                           (Parm, NativeAccessSpecifierPublic)

void ASpy::SetupHeat(const struct FHeatSetupData& NewHeatSetup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "SetupHeat");

	Params::Spy_SetupHeat Parms{};

	Parms.NewHeatSetup = std::move(NewHeatSetup);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.SetWeapon1PMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   WeaponMesh                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::SetWeapon1PMesh(class UMeshComponent* WeaponMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "SetWeapon1PMesh");

	Params::Spy_SetWeapon1PMesh Parms{};

	Parms.WeaponMesh = WeaponMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.SetWeapon3PMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   WeaponMesh                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::SetWeapon3PMesh(class UMeshComponent* WeaponMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "SetWeapon3PMesh");

	Params::Spy_SetWeapon3PMesh Parms{};

	Parms.WeaponMesh = WeaponMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.ShowPlayerHud
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Requester                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::ShowPlayerHud(class AActor* Requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "ShowPlayerHud");

	Params::Spy_ShowPlayerHud Parms{};

	Parms.Requester = Requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.ShowToolsHud
// (Final, Native, Public, BlueprintCallable)

void ASpy::ShowToolsHud()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "ShowToolsHud");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.TestOcclusionCollisionOfJointFromLocalCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             JointName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::TestOcclusionCollisionOfJointFromLocalCamera(class FName JointName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "TestOcclusionCollisionOfJointFromLocalCamera");

	Params::Spy_TestOcclusionCollisionOfJointFromLocalCamera Parms{};

	Parms.JointName = JointName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.TriggerHealthConsumableEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// ESpyHealthConsumableEvent               Event                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::TriggerHealthConsumableEvent(ESpyHealthConsumableEvent Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "TriggerHealthConsumableEvent");

	Params::Spy_TriggerHealthConsumableEvent Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.TriggerHealthConsumableEventServer
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// ESpyHealthConsumableEvent               Event                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy::TriggerHealthConsumableEventServer(ESpyHealthConsumableEvent Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "TriggerHealthConsumableEventServer");

	Params::Spy_TriggerHealthConsumableEventServer Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy.AreLeftHandFlavorAnimationsAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::AreLeftHandFlavorAnimationsAllowed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "AreLeftHandFlavorAnimationsAllowed");

	Params::Spy_AreLeftHandFlavorAnimationsAllowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.CanBeRevive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::CanBeRevive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "CanBeRevive");

	Params::Spy_CanBeRevive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetActiveAbilityTool
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABaseSpyActiveAbility*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABaseSpyActiveAbility* ASpy::GetActiveAbilityTool() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetActiveAbilityTool");

	Params::Spy_GetActiveAbilityTool Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetAgentExpertiseSkillData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAgentExpertiseSkillData*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAgentExpertiseSkillData* ASpy::GetAgentExpertiseSkillData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetAgentExpertiseSkillData");

	Params::Spy_GetAgentExpertiseSkillData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetAgentExpertiseVariantIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASpy::GetAgentExpertiseVariantIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetAgentExpertiseVariantIndex");

	Params::Spy_GetAgentExpertiseVariantIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetAgentPassiveSkillData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAgentPassiveSkillData*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAgentPassiveSkillData* ASpy::GetAgentPassiveSkillData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetAgentPassiveSkillData");

	Params::Spy_GetAgentPassiveSkillData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetAgentPassiveVariantIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASpy::GetAgentPassiveVariantIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetAgentPassiveVariantIndex");

	Params::Spy_GetAgentPassiveVariantIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetAgentWeaponData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAgentWeaponData*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAgentWeaponData* ASpy::GetAgentWeaponData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetAgentWeaponData");

	Params::Spy_GetAgentWeaponData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetAgentWeaponVariantIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASpy::GetAgentWeaponVariantIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetAgentWeaponVariantIndex");

	Params::Spy_GetAgentWeaponVariantIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetCoverRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASpy::GetCoverRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetCoverRatio");

	Params::Spy_GetCoverRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetCurrentActiveMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ASpy::GetCurrentActiveMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetCurrentActiveMesh");

	Params::Spy_GetCurrentActiveMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetCurrentArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALevelArea*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALevelArea* ASpy::GetCurrentArea() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetCurrentArea");

	Params::Spy_GetCurrentArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetCurrentHeading
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASpy::GetCurrentHeading() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetCurrentHeading");

	Params::Spy_GetCurrentHeading Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetCurrentRoom
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARoomVolume*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARoomVolume* ASpy::GetCurrentRoom() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetCurrentRoom");

	Params::Spy_GetCurrentRoom Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetCurrentStaminaRatio
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASpy::GetCurrentStaminaRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetCurrentStaminaRatio");

	Params::Spy_GetCurrentStaminaRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetCurrentTool
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABaseSpyTool*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABaseSpyTool* ASpy::GetCurrentTool() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetCurrentTool");

	Params::Spy_GetCurrentTool Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetDIPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADIPlayerState*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADIPlayerState* ASpy::GetDIPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetDIPlayerState");

	Params::Spy_GetDIPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetDisguise
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ANPCCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANPCCharacter* ASpy::GetDisguise() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetDisguise");

	Params::Spy_GetDisguise Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetEffectOfClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UClass*                           EffectClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVictimEffect*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AVictimEffect* ASpy::GetEffectOfClass(class UClass* EffectClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetEffectOfClass");

	Params::Spy_GetEffectOfClass Parms{};

	Parms.EffectClass = EffectClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetFactionId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ASpy::GetFactionId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetFactionId");

	Params::Spy_GetFactionId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetFeetLevelPos
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ASpy::GetFeetLevelPos() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetFeetLevelPos");

	Params::Spy_GetFeetLevelPos Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetInteractableType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInteractableType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInteractableType ASpy::GetInteractableType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetInteractableType");

	Params::Spy_GetInteractableType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetKillerData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLastInteractionData             ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLastInteractionData ASpy::GetKillerData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetKillerData");

	Params::Spy_GetKillerData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetLoadoutComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UToolLoadoutComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UToolLoadoutComponent* ASpy::GetLoadoutComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetLoadoutComponent");

	Params::Spy_GetLoadoutComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetMesh1P
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ASpy::GetMesh1P() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetMesh1P");

	Params::Spy_GetMesh1P Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetMesh3P
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ASpy::GetMesh3P() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetMesh3P");

	Params::Spy_GetMesh3P Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetOutOfCoverTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASpy::GetOutOfCoverTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetOutOfCoverTime");

	Params::Spy_GetOutOfCoverTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetPassiveAbilityTool
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABaseSpyPassiveAbility*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABaseSpyPassiveAbility* ASpy::GetPassiveAbilityTool() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetPassiveAbilityTool");

	Params::Spy_GetPassiveAbilityTool Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetPlayerName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ASpy::GetPlayerName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetPlayerName");

	Params::Spy_GetPlayerName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetPlayerPlatformType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlatformType                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlatformType ASpy::GetPlayerPlatformType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetPlayerPlatformType");

	Params::Spy_GetPlayerPlatformType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetPreviousFrameCoverRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASpy::GetPreviousFrameCoverRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetPreviousFrameCoverRatio");

	Params::Spy_GetPreviousFrameCoverRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetRunDrainCanTrigger
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::GetRunDrainCanTrigger() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetRunDrainCanTrigger");

	Params::Spy_GetRunDrainCanTrigger Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetRunDrainEnabled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::GetRunDrainEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetRunDrainEnabled");

	Params::Spy_GetRunDrainEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetSkinData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAgentSkinData*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAgentSkinData* ASpy::GetSkinData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetSkinData");

	Params::Spy_GetSkinData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetSlowPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASpy::GetSlowPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetSlowPercent");

	Params::Spy_GetSlowPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetSpyActiveEffects
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AVictimEffect*>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AVictimEffect*> ASpy::GetSpyActiveEffects() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetSpyActiveEffects");

	Params::Spy_GetSpyActiveEffects Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetToolInSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELoadoutSlot                            ToolSlot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseSpyTool*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABaseSpyTool* ASpy::GetToolInSlot(ELoadoutSlot ToolSlot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetToolInSlot");

	Params::Spy_GetToolInSlot Parms{};

	Parms.ToolSlot = ToolSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetViewPitch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASpy::GetViewPitch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetViewPitch");

	Params::Spy_GetViewPitch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetWeapon1PMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMeshComponent*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMeshComponent* ASpy::GetWeapon1PMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetWeapon1PMesh");

	Params::Spy_GetWeapon1PMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetWeapon3PMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMeshComponent*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMeshComponent* ASpy::GetWeapon3PMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetWeapon3PMesh");

	Params::Spy_GetWeapon3PMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.GetWeaponTool
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABaseSpyWeapon*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABaseSpyWeapon* ASpy::GetWeaponTool() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "GetWeaponTool");

	Params::Spy_GetWeaponTool Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsBot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsBot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsBot");

	Params::Spy_IsBot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsBurned
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsBurned() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsBurned");

	Params::Spy_IsBurned Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsCharmRecover
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsCharmRecover() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsCharmRecover");

	Params::Spy_IsCharmRecover Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsDead
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsDead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsDead");

	Params::Spy_IsDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsDisarmed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsDisarmed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsDisarmed");

	Params::Spy_IsDisarmed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsDisguiseVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsDisguiseVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsDisguiseVisible");

	Params::Spy_IsDisguiseVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsEnemyCharmRecover
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsEnemyCharmRecover() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsEnemyCharmRecover");

	Params::Spy_IsEnemyCharmRecover Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsFalling
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsFalling() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsFalling");

	Params::Spy_IsFalling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsFriendlyCharmRecover
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsFriendlyCharmRecover() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsFriendlyCharmRecover");

	Params::Spy_IsFriendlyCharmRecover Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsHidden
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsHidden() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsHidden");

	Params::Spy_IsHidden Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsHidingReticleInADS
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsHidingReticleInADS() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsHidingReticleInADS");

	Params::Spy_IsHidingReticleInADS Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsImmaterial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsImmaterial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsImmaterial");

	Params::Spy_IsImmaterial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsImmaterialOrHidden
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsImmaterialOrHidden() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsImmaterialOrHidden");

	Params::Spy_IsImmaterialOrHidden Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsInADS
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsInADS() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsInADS");

	Params::Spy_IsInADS Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsInMimic
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsInMimic() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsInMimic");

	Params::Spy_IsInMimic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsInNavMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsInNavMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsInNavMode");

	Params::Spy_IsInNavMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsInVault
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsInVault() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsInVault");

	Params::Spy_IsInVault Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsJumpDisabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsJumpDisabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsJumpDisabled");

	Params::Spy_IsJumpDisabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsKeepRunAdditiveWhileRunningOutOfCover
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsKeepRunAdditiveWhileRunningOutOfCover() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsKeepRunAdditiveWhileRunningOutOfCover");

	Params::Spy_IsKeepRunAdditiveWhileRunningOutOfCover Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsKillcamViewTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsKillcamViewTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsKillcamViewTarget");

	Params::Spy_IsKillcamViewTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsLastCoverBlowSelfInstigated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsLastCoverBlowSelfInstigated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsLastCoverBlowSelfInstigated");

	Params::Spy_IsLastCoverBlowSelfInstigated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsLocalOrKillcamViewTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsLocalOrKillcamViewTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsLocalOrKillcamViewTarget");

	Params::Spy_IsLocalOrKillcamViewTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsLocalSpy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsLocalSpy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsLocalSpy");

	Params::Spy_IsLocalSpy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsMovementDisabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsMovementDisabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsMovementDisabled");

	Params::Spy_IsMovementDisabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsPlayerHudVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsPlayerHudVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsPlayerHudVisible");

	Params::Spy_IsPlayerHudVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsRunBlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsRunBlocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsRunBlocked");

	Params::Spy_IsRunBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsRunDisabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsRunDisabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsRunDisabled");

	Params::Spy_IsRunDisabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsRunning
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsRunning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsRunning");

	Params::Spy_IsRunning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsSameFactionAsLocalPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsSameFactionAsLocalPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsSameFactionAsLocalPlayer");

	Params::Spy_IsSameFactionAsLocalPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsShootingBlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsShootingBlocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsShootingBlocked");

	Params::Spy_IsShootingBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsSilenced
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsSilenced() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsSilenced");

	Params::Spy_IsSilenced Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsSpeedBoostDisabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsSpeedBoostDisabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsSpeedBoostDisabled");

	Params::Spy_IsSpeedBoostDisabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsSpyAndDisguiseInvisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsSpyAndDisguiseInvisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsSpyAndDisguiseInvisible");

	Params::Spy_IsSpyAndDisguiseInvisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsSpyPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsSpyPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsSpyPlayer");

	Params::Spy_IsSpyPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsSpyPoisoned
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsSpyPoisoned() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsSpyPoisoned");

	Params::Spy_IsSpyPoisoned Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsSpyRunning
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsSpyRunning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsSpyRunning");

	Params::Spy_IsSpyRunning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsSpyVisibleToOthers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsSpyVisibleToOthers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsSpyVisibleToOthers");

	Params::Spy_IsSpyVisibleToOthers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsSuspicious
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsSuspicious() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsSuspicious");

	Params::Spy_IsSuspicious Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsTransformingOrInMimic
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsTransformingOrInMimic() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsTransformingOrInMimic");

	Params::Spy_IsTransformingOrInMimic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsTryingToRun
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsTryingToRun() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsTryingToRun");

	Params::Spy_IsTryingToRun Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsUndercover
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsUndercover() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsUndercover");

	Params::Spy_IsUndercover Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.IsViewIn1P
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::IsViewIn1P() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "IsViewIn1P");

	Params::Spy_IsViewIn1P Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy.ShouldBeUndercover
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpy::ShouldBeUndercover() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy", "ShouldBeUndercover");

	Params::Spy_ShouldBeUndercover Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy3DPortrait.BP_OnDamageReceived
// (Event, Public, BlueprintEvent)

void ASpy3DPortrait::BP_OnDamageReceived()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy3DPortrait", "BP_OnDamageReceived");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.Spy3DPortrait.BP_OnDisguiseChange
// (Event, Public, BlueprintEvent)

void ASpy3DPortrait::BP_OnDisguiseChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy3DPortrait", "BP_OnDisguiseChange");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.Spy3DPortrait.BP_OnDisguiseVisibilityChange
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy3DPortrait::BP_OnDisguiseVisibilityChange(bool bIsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy3DPortrait", "BP_OnDisguiseVisibilityChange");

	Params::Spy3DPortrait_BP_OnDisguiseVisibilityChange Parms{};

	Parms.bIsVisible = bIsVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.Spy3DPortrait.BP_OnSpyVisibilityChange
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy3DPortrait::BP_OnSpyVisibilityChange(bool bIsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy3DPortrait", "BP_OnSpyVisibilityChange");

	Params::Spy3DPortrait_BP_OnSpyVisibilityChange Parms{};

	Parms.bIsVisible = bIsVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.Spy3DPortrait.BP_UpdatePlayerHud
// (Event, Public, BlueprintEvent)
// Parameters:
// class UUserWidget*                      NewHud                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy3DPortrait::BP_UpdatePlayerHud(class UUserWidget* NewHud)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy3DPortrait", "BP_UpdatePlayerHud");

	Params::Spy3DPortrait_BP_UpdatePlayerHud Parms{};

	Parms.NewHud = NewHud;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.Spy3DPortrait.EnableSpotlight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy3DPortrait::EnableSpotlight(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy3DPortrait", "EnableSpotlight");

	Params::Spy3DPortrait_EnableSpotlight Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy3DPortrait.HandleCoverVisibilityChange
// (Final, Native, Protected)
// Parameters:
// bool                                    CoverVisible                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy3DPortrait::HandleCoverVisibilityChange(bool CoverVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy3DPortrait", "HandleCoverVisibilityChange");

	Params::Spy3DPortrait_HandleCoverVisibilityChange Parms{};

	Parms.CoverVisible = CoverVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy3DPortrait.HandleHealthChanged
// (Final, Native, Protected)
// Parameters:
// class UHealthComponent*                 OwningHealthComp                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Health                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HealthDelta                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RawDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpy3DPortrait::HandleHealthChanged(class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, float RawDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy3DPortrait", "HandleHealthChanged");

	Params::Spy3DPortrait_HandleHealthChanged Parms{};

	Parms.OwningHealthComp = OwningHealthComp;
	Parms.Health = Health;
	Parms.HealthDelta = HealthDelta;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.RawDamage = RawDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy3DPortrait.SnapSpyStaticPortraitNow
// (Final, Native, Public, BlueprintCallable)

void ASpy3DPortrait::SnapSpyStaticPortraitNow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy3DPortrait", "SnapSpyStaticPortraitNow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy3DPortrait.UpdateCameraRotation
// (Final, Native, Public, BlueprintCallable)

void ASpy3DPortrait::UpdateCameraRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy3DPortrait", "UpdateCameraRotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Spy3DPortrait.GetCurrentVisibleMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ASpy3DPortrait::GetCurrentVisibleMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy3DPortrait", "GetCurrentVisibleMesh");

	Params::Spy3DPortrait_GetCurrentVisibleMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy3DPortrait.GetDisguiseReferenceMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ASpy3DPortrait::GetDisguiseReferenceMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy3DPortrait", "GetDisguiseReferenceMesh");

	Params::Spy3DPortrait_GetDisguiseReferenceMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy3DPortrait.GetDisguiseSecurityLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESecurityLevel                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESecurityLevel ASpy3DPortrait::GetDisguiseSecurityLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy3DPortrait", "GetDisguiseSecurityLevel");

	Params::Spy3DPortrait_GetDisguiseSecurityLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy3DPortrait.GetSpyAnimMotionAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             MotionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimationAsset*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimationAsset* ASpy3DPortrait::GetSpyAnimMotionAsset(class FName MotionName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy3DPortrait", "GetSpyAnimMotionAsset");

	Params::Spy3DPortrait_GetSpyAnimMotionAsset Parms{};

	Parms.MotionName = MotionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Spy3DPortrait.GetSpyReferenceMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ASpy3DPortrait::GetSpyReferenceMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spy3DPortrait", "GetSpyReferenceMesh");

	Params::Spy3DPortrait_GetSpyReferenceMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SpyCache.BP_CloseCache
// (Event, Public, BlueprintEvent)

void ASpyCache::BP_CloseCache()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCache", "BP_CloseCache");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.SpyCache.BP_DoPing
// (Event, Public, BlueprintEvent)

void ASpyCache::BP_DoPing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCache", "BP_DoPing");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.SpyCache.OnInteractionCanceled
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpyCache::OnInteractionCanceled(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCache", "OnInteractionCanceled");

	Params::SpyCache_OnInteractionCanceled Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCache.OnInteractionComplete
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpyCache::OnInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCache", "OnInteractionComplete");

	Params::SpyCache_OnInteractionComplete Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCache.OnInteractionCompleteAll
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpyCache::OnInteractionCompleteAll(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCache", "OnInteractionCompleteAll");

	Params::SpyCache_OnInteractionCompleteAll Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCache.OnRep_CacheEnabled
// (Final, Native, Protected)
// Parameters:
// bool                                    OldVal                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpyCache::OnRep_CacheEnabled(bool OldVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCache", "OnRep_CacheEnabled");

	Params::SpyCache_OnRep_CacheEnabled Parms{};

	Parms.OldVal = OldVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatAbilityResetCooldown
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatAbilityResetCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatAbilityResetCooldown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatAbilityResetCooldownSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatAbilityResetCooldownSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatAbilityResetCooldownSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatAbilityToggleNoCooldown
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatAbilityToggleNoCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatAbilityToggleNoCooldown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatAbilityToggleNoCooldownSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatAbilityToggleNoCooldownSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatAbilityToggleNoCooldownSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatBotsDisableStalling
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatBotsDisableStalling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatBotsDisableStalling");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatBotsDisableStallingSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatBotsDisableStallingSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatBotsDisableStallingSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatBotToggleIgnoreOtherBots
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatBotToggleIgnoreOtherBots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatBotToggleIgnoreOtherBots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatBotToggleIgnoreOtherBotsSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatBotToggleIgnoreOtherBotsSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatBotToggleIgnoreOtherBotsSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatBotTogglePerfectFireRate
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatBotTogglePerfectFireRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatBotTogglePerfectFireRate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatBotTogglePerfectFireRateSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatBotTogglePerfectFireRateSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatBotTogglePerfectFireRateSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatDamage
// (Final, Exec, Native, Public)
// Parameters:
// float                                   DamageAmmount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatDamage(float DamageAmmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatDamage");

	Params::SpyCheatsComponent_CheatDamage Parms{};

	Parms.DamageAmmount = DamageAmmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatDamageSrv
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// float                                   DamageAmmount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatDamageSrv(float DamageAmmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatDamageSrv");

	Params::SpyCheatsComponent_CheatDamageSrv Parms{};

	Parms.DamageAmmount = DamageAmmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatDangerDebugDraw
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatDangerDebugDraw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatDangerDebugDraw");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatDelayDamage
// (Final, Exec, Native, Public)
// Parameters:
// float                                   DamageAmmount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatDelayDamage(float DamageAmmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatDelayDamage");

	Params::SpyCheatsComponent_CheatDelayDamage Parms{};

	Parms.DamageAmmount = DamageAmmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatDemiGodSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatDemiGodSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatDemiGodSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatDisableSpecialRule
// (Final, Exec, Native, Public)
// Parameters:
// EDISpecialRules                         SpecialRule                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatDisableSpecialRule(EDISpecialRules SpecialRule)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatDisableSpecialRule");

	Params::SpyCheatsComponent_CheatDisableSpecialRule Parms{};

	Parms.SpecialRule = SpecialRule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatDisguiseGiveSecurityLevel
// (Final, Exec, Native, Public)
// Parameters:
// ESecurityLevel                          Security                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatDisguiseGiveSecurityLevel(ESecurityLevel Security)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatDisguiseGiveSecurityLevel");

	Params::SpyCheatsComponent_CheatDisguiseGiveSecurityLevel Parms{};

	Parms.Security = Security;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatDisguiseGiveSecurityLevelSrv
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// ESecurityLevel                          Security                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatDisguiseGiveSecurityLevelSrv(ESecurityLevel Security)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatDisguiseGiveSecurityLevelSrv");

	Params::SpyCheatsComponent_CheatDisguiseGiveSecurityLevelSrv Parms{};

	Parms.Security = Security;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatDisguiseToggleDebugInfo
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatDisguiseToggleDebugInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatDisguiseToggleDebugInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatDisguiseToggleNoCover
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatDisguiseToggleNoCover()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatDisguiseToggleNoCover");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatDisguiseToggleNoCoverSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatDisguiseToggleNoCoverSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatDisguiseToggleNoCoverSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatDropInv
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatDropInv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatDropInv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatDropInvSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatDropInvSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatDropInvSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatEnableRulesetSrv
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// EDISpecialRules                         SpecialRule                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatEnableRulesetSrv(EDISpecialRules SpecialRule, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatEnableRulesetSrv");

	Params::SpyCheatsComponent_CheatEnableRulesetSrv Parms{};

	Parms.SpecialRule = SpecialRule;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatEnableSpecialRule
// (Final, Exec, Native, Public)
// Parameters:
// EDISpecialRules                         SpecialRule                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatEnableSpecialRule(EDISpecialRules SpecialRule)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatEnableSpecialRule");

	Params::SpyCheatsComponent_CheatEnableSpecialRule Parms{};

	Parms.SpecialRule = SpecialRule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatFillWithBots
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatFillWithBots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatFillWithBots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatFillWithBotsSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatFillWithBotsSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatFillWithBotsSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatForceShowHud
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatForceShowHud()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatForceShowHud");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatForceSpectator
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatForceSpectator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatForceSpectator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatForceSpectatorSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatForceSpectatorSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatForceSpectatorSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatFOVLog
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatFOVLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatFOVLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameAddTimeLeft
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   TimeToAdd                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatGameAddTimeLeft(int32 TimeToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameAddTimeLeft");

	Params::SpyCheatsComponent_CheatGameAddTimeLeft Parms{};

	Parms.TimeToAdd = TimeToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameAddTimeLeftSrv
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                                   TimeToAdd                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatGameAddTimeLeftSrv(int32 TimeToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameAddTimeLeftSrv");

	Params::SpyCheatsComponent_CheatGameAddTimeLeftSrv Parms{};

	Parms.TimeToAdd = TimeToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameChangeMap
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           NewMap                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatGameChangeMap(const class FString& NewMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameChangeMap");

	Params::SpyCheatsComponent_CheatGameChangeMap Parms{};

	Parms.NewMap = std::move(NewMap);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameChangeMapSrv
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FString                           NewMap                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatGameChangeMapSrv(const class FString& NewMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameChangeMapSrv");

	Params::SpyCheatsComponent_CheatGameChangeMapSrv Parms{};

	Parms.NewMap = std::move(NewMap);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameClearNPCBodies
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatGameClearNPCBodies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameClearNPCBodies");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameClearNPCBodiesSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatGameClearNPCBodiesSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameClearNPCBodiesSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameDisableGuards
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatGameDisableGuards()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameDisableGuards");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameEnableGuards
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatGameEnableGuards()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameEnableGuards");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameEndSrv
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bWin                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatGameEndSrv(bool bWin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameEndSrv");

	Params::SpyCheatsComponent_CheatGameEndSrv Parms{};

	Parms.bWin = bWin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameForceFaction
// (Final, Exec, Native, Public)
// Parameters:
// int8                                    NewFactionID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatGameForceFaction(int8 NewFactionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameForceFaction");

	Params::SpyCheatsComponent_CheatGameForceFaction Parms{};

	Parms.NewFactionID = NewFactionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameForceFactionSrv
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int8                                    NewFactionID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatGameForceFactionSrv(int8 NewFactionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameForceFactionSrv");

	Params::SpyCheatsComponent_CheatGameForceFactionSrv Parms{};

	Parms.NewFactionID = NewFactionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameForceShowTimer
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatGameForceShowTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameForceShowTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameKillAllNPCs
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatGameKillAllNPCs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameKillAllNPCs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameKillAllNPCsSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatGameKillAllNPCsSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameKillAllNPCsSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameLose
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatGameLose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameLose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGamePause
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatGamePause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGamePause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGamePauseSrv
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bPause                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatGamePauseSrv(bool bPause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGamePauseSrv");

	Params::SpyCheatsComponent_CheatGamePauseSrv Parms{};

	Parms.bPause = bPause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameSetGuardsEnabledSrv
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatGameSetGuardsEnabledSrv(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameSetGuardsEnabledSrv");

	Params::SpyCheatsComponent_CheatGameSetGuardsEnabledSrv Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameSetTimeLeft
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   TimeLeft                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatGameSetTimeLeft(int32 TimeLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameSetTimeLeft");

	Params::SpyCheatsComponent_CheatGameSetTimeLeft Parms{};

	Parms.TimeLeft = TimeLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameSetTimeLeftSrv
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                                   TimeLeft                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatGameSetTimeLeftSrv(int32 TimeLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameSetTimeLeftSrv");

	Params::SpyCheatsComponent_CheatGameSetTimeLeftSrv Parms{};

	Parms.TimeLeft = TimeLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameSkipPhase
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatGameSkipPhase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameSkipPhase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameTeleportToSafe
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatGameTeleportToSafe()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameTeleportToSafe");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameTeleportToSafeSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatGameTeleportToSafeSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameTeleportToSafeSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameToggleDebugGuardAggro
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatGameToggleDebugGuardAggro()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameToggleDebugGuardAggro");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameToggleDebugGuardAggroSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatGameToggleDebugGuardAggroSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameToggleDebugGuardAggroSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameToggleGuardTrailDebugDraw
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatGameToggleGuardTrailDebugDraw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameToggleGuardTrailDebugDraw");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameTogglePlayername
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatGameTogglePlayername()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameTogglePlayername");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameToggleShowRoomName
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatGameToggleShowRoomName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameToggleShowRoomName");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameTraceBondPiles
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatGameTraceBondPiles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameTraceBondPiles");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameTraceBondPilesSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatGameTraceBondPilesSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameTraceBondPilesSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameTraceVIPs
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatGameTraceVIPs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameTraceVIPs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameTraceVIPsSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatGameTraceVIPsSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameTraceVIPsSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameUnpause
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatGameUnpause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameUnpause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGameWin
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatGameWin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGameWin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGenericChestClose
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatGenericChestClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGenericChestClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGenericChestCloseSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatGenericChestCloseSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGenericChestCloseSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGiveAllCharge
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatGiveAllCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGiveAllCharge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGiveAllPowerups
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatGiveAllPowerups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGiveAllPowerups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGiveFullAmmo
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatGiveFullAmmo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGiveFullAmmo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGiveResource
// (Final, Exec, Native, Public)
// Parameters:
// EGameplayResourcesType                  Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Ammount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatGiveResource(EGameplayResourcesType Type, int32 Ammount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGiveResource");

	Params::SpyCheatsComponent_CheatGiveResource Parms{};

	Parms.Type = Type;
	Parms.Ammount = Ammount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGiveResourceSrv
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// EGameplayResourcesType                  Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Ammount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatGiveResourceSrv(EGameplayResourcesType Type, int32 Ammount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGiveResourceSrv");

	Params::SpyCheatsComponent_CheatGiveResourceSrv Parms{};

	Parms.Type = Type;
	Parms.Ammount = Ammount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGiveSpyKit
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatGiveSpyKit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGiveSpyKit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatGodSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatGodSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatGodSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatHeal
// (Final, Exec, Native, Public)
// Parameters:
// float                                   HealAmmount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatHeal(float HealAmmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatHeal");

	Params::SpyCheatsComponent_CheatHeal Parms{};

	Parms.HealAmmount = HealAmmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatHealSrv
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// float                                   HealAmmount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatHealSrv(float HealAmmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatHealSrv");

	Params::SpyCheatsComponent_CheatHealSrv Parms{};

	Parms.HealAmmount = HealAmmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatHeatReset
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatHeatReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatHeatReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatHeatSetLevel
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatHeatSetLevel(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatHeatSetLevel");

	Params::SpyCheatsComponent_CheatHeatSetLevel Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatHeatSetLevelSrv
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatHeatSetLevelSrv(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatHeatSetLevelSrv");

	Params::SpyCheatsComponent_CheatHeatSetLevelSrv Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatHideAllHuds
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatHideAllHuds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatHideAllHuds");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatHideHud
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           HudToHide                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatHideHud(const class FString& HudToHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatHideHud");

	Params::SpyCheatsComponent_CheatHideHud Parms{};

	Parms.HudToHide = std::move(HudToHide);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatIgnoreLastManStanding
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatIgnoreLastManStanding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatIgnoreLastManStanding");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatIgnoreLastManStandingSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatIgnoreLastManStandingSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatIgnoreLastManStandingSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatIntroShowcaseFillWithClones
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatIntroShowcaseFillWithClones()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatIntroShowcaseFillWithClones");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatLogActiveHandToolEventsDebug
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatLogActiveHandToolEventsDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatLogActiveHandToolEventsDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatLogClient
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatLogClient(const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatLogClient");

	Params::SpyCheatsComponent_CheatLogClient Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatLogServer
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatLogServer(const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatLogServer");

	Params::SpyCheatsComponent_CheatLogServer Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatLookAt3rdSpy
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatLookAt3rdSpy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatLookAt3rdSpy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatMeleeToggleDebug
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatMeleeToggleDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatMeleeToggleDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatNPCSetNetCullingDistance
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatNPCSetNetCullingDistance(float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatNPCSetNetCullingDistance");

	Params::SpyCheatsComponent_CheatNPCSetNetCullingDistance Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatNPCSetNetCullingDistanceSrv
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatNPCSetNetCullingDistanceSrv(float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatNPCSetNetCullingDistanceSrv");

	Params::SpyCheatsComponent_CheatNPCSetNetCullingDistanceSrv Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatNPCToggleDebugInfoTargeting
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatNPCToggleDebugInfoTargeting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatNPCToggleDebugInfoTargeting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatNPCToggleDebugSuspiciousness
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatNPCToggleDebugSuspiciousness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatNPCToggleDebugSuspiciousness");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatNPCToggleMeshTickEnabled
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatNPCToggleMeshTickEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatNPCToggleMeshTickEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatRestore
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatRestore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatRestore");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatRestoreSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatRestoreSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatRestoreSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatRevive
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatRevive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatRevive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatReviveSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatReviveSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatReviveSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatSetGameRuleset
// (Final, Exec, Native, Public)
// Parameters:
// EDIGameRuleset                          NewRuleset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatSetGameRuleset(EDIGameRuleset NewRuleset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatSetGameRuleset");

	Params::SpyCheatsComponent_CheatSetGameRuleset Parms{};

	Parms.NewRuleset = NewRuleset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatSetGameRulesetSrv
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// EDIGameRuleset                          NewRuleset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatSetGameRulesetSrv(EDIGameRuleset NewRuleset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatSetGameRulesetSrv");

	Params::SpyCheatsComponent_CheatSetGameRulesetSrv Parms{};

	Parms.NewRuleset = NewRuleset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatShowBotDebugText
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatShowBotDebugText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatShowBotDebugText");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatSkipGamePhaseSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatSkipGamePhaseSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatSkipGamePhaseSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatSmokeTestBotsBattleRoyale
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatSmokeTestBotsBattleRoyale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatSmokeTestBotsBattleRoyale");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatSmokeTestBotsBattleRoyaleDemiGod
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatSmokeTestBotsBattleRoyaleDemiGod()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatSmokeTestBotsBattleRoyaleDemiGod");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatSmokeTestBotsBattleRoyaleSrv
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bDemiGod                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatSmokeTestBotsBattleRoyaleSrv(bool bDemiGod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatSmokeTestBotsBattleRoyaleSrv");

	Params::SpyCheatsComponent_CheatSmokeTestBotsBattleRoyaleSrv Parms{};

	Parms.bDemiGod = bDemiGod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatSpawnBot
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           SpyName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatSpawnBot(const class FString& SpyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatSpawnBot");

	Params::SpyCheatsComponent_CheatSpawnBot Parms{};

	Parms.SpyName = std::move(SpyName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatSpawnBotAndDebug
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           SpyName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatSpawnBotAndDebug(const class FString& SpyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatSpawnBotAndDebug");

	Params::SpyCheatsComponent_CheatSpawnBotAndDebug Parms{};

	Parms.SpyName = std::move(SpyName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatSpawnBotSrv
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FString                           SpyName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpyCheatsComponent::CheatSpawnBotSrv(const class FString& SpyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatSpawnBotSrv");

	Params::SpyCheatsComponent_CheatSpawnBotSrv Parms{};

	Parms.SpyName = std::move(SpyName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatSuperEvilManeuverToMaketheServerCrash
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatSuperEvilManeuverToMaketheServerCrash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatSuperEvilManeuverToMaketheServerCrash");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatSuperEvilManeuverToMaketheServerCrashSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatSuperEvilManeuverToMaketheServerCrashSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatSuperEvilManeuverToMaketheServerCrashSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatTestCheat
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatTestCheat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatTestCheat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatToggleAimAssistExtraInfo
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatToggleAimAssistExtraInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatToggleAimAssistExtraInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatToggleAimAssistInfo
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatToggleAimAssistInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatToggleAimAssistInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatToggleAlwaysShowReticle
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatToggleAlwaysShowReticle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatToggleAlwaysShowReticle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatToggleAutoClick
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatToggleAutoClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatToggleAutoClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatToggleAutoShootForever
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatToggleAutoShootForever()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatToggleAutoShootForever");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatToggleDemiGod
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatToggleDemiGod()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatToggleDemiGod");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatToggleGod
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatToggleGod()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatToggleGod");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatToggleHideFriendlyGadgetOverlay
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatToggleHideFriendlyGadgetOverlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatToggleHideFriendlyGadgetOverlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatToggleIKFromPoseDebugDraws
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatToggleIKFromPoseDebugDraws()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatToggleIKFromPoseDebugDraws");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatToggleIKFromPoseEnabled
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatToggleIKFromPoseEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatToggleIKFromPoseEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatToggleSpySuspiciousSystem
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatToggleSpySuspiciousSystem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatToggleSpySuspiciousSystem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatToggleSpySuspiciousSystemSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatToggleSpySuspiciousSystemSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatToggleSpySuspiciousSystemSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatToggleSway1PDebugDraw
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatToggleSway1PDebugDraw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatToggleSway1PDebugDraw");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatToggleSway1PEnabled
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatToggleSway1PEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatToggleSway1PEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatTraceAllBots
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatTraceAllBots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatTraceAllBots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatTraceAllBotsSrv
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpyCheatsComponent::CheatTraceAllBotsSrv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatTraceAllBotsSrv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatWeaponToggleAmmoConsumption
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatWeaponToggleAmmoConsumption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatWeaponToggleAmmoConsumption");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatWeaponToggleDamageNumbers
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatWeaponToggleDamageNumbers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatWeaponToggleDamageNumbers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatWeaponToggleRecoil
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatWeaponToggleRecoil()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatWeaponToggleRecoil");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyCheatsComponent.CheatWeaponToggleSprayDebugDraw
// (Final, Exec, Native, Public)

void USpyCheatsComponent::CheatWeaponToggleSprayDebugDraw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyCheatsComponent", "CheatWeaponToggleSprayDebugDraw");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyGlassTool.HandleAddInteractionTimeReduction
// (Final, Native, Protected)
// Parameters:
// float                                   Reduction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpyGlassTool::HandleAddInteractionTimeReduction(float Reduction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyGlassTool", "HandleAddInteractionTimeReduction");

	Params::SpyGlassTool_HandleAddInteractionTimeReduction Parms{};

	Parms.Reduction = Reduction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyGlassTool.HandleCooldownChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bOnCooldown                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpyGlassTool::HandleCooldownChange(bool bOnCooldown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyGlassTool", "HandleCooldownChange");

	Params::SpyGlassTool_HandleCooldownChange Parms{};

	Parms.bOnCooldown = bOnCooldown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyGlassTool.HandleInteractionComplete
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpyGlassTool::HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyGlassTool", "HandleInteractionComplete");

	Params::SpyGlassTool_HandleInteractionComplete Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyGlassTool.HandleRemoveInteractionTimeReduction
// (Final, Native, Protected)
// Parameters:
// float                                   Reduction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpyGlassTool::HandleRemoveInteractionTimeReduction(float Reduction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyGlassTool", "HandleRemoveInteractionTimeReduction");

	Params::SpyGlassTool_HandleRemoveInteractionTimeReduction Parms{};

	Parms.Reduction = Reduction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyPing.BP_SetupPing
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FPingData                        SetupPingData                                          (Parm, NativeAccessSpecifierPublic)
// int32                                   FactionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpyPing::BP_SetupPing(const struct FPingData& SetupPingData, int32 FactionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyPing", "BP_SetupPing");

	Params::SpyPing_BP_SetupPing Parms{};

	Parms.SetupPingData = std::move(SetupPingData);
	Parms.FactionIndex = FactionIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.SpyPing.OnRep_PingData
// (Final, Native, Protected)

void ASpyPing::OnRep_PingData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyPing", "OnRep_PingData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SpyPing.GetWidgetFade
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASpyPing::GetWidgetFade() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpyPing", "GetWidgetFade");

	Params::SpyPing_GetWidgetFade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SquireActiveAbility.BP_OnInteractableDetected
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           InteractableActor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInteractableType                       InteractableType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   StencilValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASquireActiveAbility::BP_OnInteractableDetected(class AActor* InteractableActor, EInteractableType InteractableType, uint8 StencilValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquireActiveAbility", "BP_OnInteractableDetected");

	Params::SquireActiveAbility_BP_OnInteractableDetected Parms{};

	Parms.InteractableActor = InteractableActor;
	Parms.InteractableType = InteractableType;
	Parms.StencilValue = StencilValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.SquireActiveAbility.BP_OnInteractableDetectionEnd
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           InteractableActor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASquireActiveAbility::BP_OnInteractableDetectionEnd(class AActor* InteractableActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquireActiveAbility", "BP_OnInteractableDetectionEnd");

	Params::SquireActiveAbility_BP_OnInteractableDetectionEnd Parms{};

	Parms.InteractableActor = InteractableActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.SquireActiveAbility.BP_OnTriggerLocalDetection
// (Event, Public, BlueprintEvent)

void ASquireActiveAbility::BP_OnTriggerLocalDetection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquireActiveAbility", "BP_OnTriggerLocalDetection");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.SquireActiveAbilityMod2.BP_ClosestSpyInfo
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   AffectedSpies                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASquireActiveAbilityMod2::BP_ClosestSpyInfo(int32 AffectedSpies, class ASpy* Spy, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquireActiveAbilityMod2", "BP_ClosestSpyInfo");

	Params::SquireActiveAbilityMod2_BP_ClosestSpyInfo Parms{};

	Parms.AffectedSpies = AffectedSpies;
	Parms.Spy = Spy;
	Parms.Distance = Distance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.SquireActiveAbilityMod2.BP_DetectedSpiesChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   AffectedSpies                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASquireActiveAbilityMod2::BP_DetectedSpiesChanged(int32 AffectedSpies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquireActiveAbilityMod2", "BP_DetectedSpiesChanged");

	Params::SquireActiveAbilityMod2_BP_DetectedSpiesChanged Parms{};

	Parms.AffectedSpies = AffectedSpies;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.SquireActiveAbilityMod2.BP_DetectedSpy
// (Event, Public, BlueprintEvent)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASquireActiveAbilityMod2::BP_DetectedSpy(class ASpy* Spy, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquireActiveAbilityMod2", "BP_DetectedSpy");

	Params::SquireActiveAbilityMod2_BP_DetectedSpy Parms{};

	Parms.Spy = Spy;
	Parms.Distance = Distance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.SquireActiveAbilityMod2.OnRep_DetectedSpies
// (Final, Native, Protected)

void ASquireActiveAbilityMod2::OnRep_DetectedSpies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquireActiveAbilityMod2", "OnRep_DetectedSpies");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SquirePassiveAbilityMod2.HandleOnDisguiseShieldInitDone
// (Final, Native, Protected)
// Parameters:
// class UDisguiseShieldComponent*         DisguiseShieldComponent                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASquirePassiveAbilityMod2::HandleOnDisguiseShieldInitDone(class UDisguiseShieldComponent* DisguiseShieldComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquirePassiveAbilityMod2", "HandleOnDisguiseShieldInitDone");

	Params::SquirePassiveAbilityMod2_HandleOnDisguiseShieldInitDone Parms{};

	Parms.DisguiseShieldComponent = DisguiseShieldComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.GetPlayerVoiceChat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADeceiveIncPlayerVoiceChat*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADeceiveIncPlayerVoiceChat* USweetChatSubsystem::GetPlayerVoiceChat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "GetPlayerVoiceChat");

	Params::SweetChatSubsystem_GetPlayerVoiceChat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetChatSubsystem.HandleAudioDevicesChanged
// (Final, Native, Protected)

void USweetChatSubsystem::HandleAudioDevicesChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "HandleAudioDevicesChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.HandleBooleanPlayerSettingChange
// (Final, Native, Protected)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetChatSubsystem::HandleBooleanPlayerSettingChange(EPlayerSettingsType SettingType, bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "HandleBooleanPlayerSettingChange");

	Params::SweetChatSubsystem_HandleBooleanPlayerSettingChange Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.HandleIntegerPlayerSettingChange
// (Final, Native, Protected)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetChatSubsystem::HandleIntegerPlayerSettingChange(EPlayerSettingsType SettingType, int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "HandleIntegerPlayerSettingChange");

	Params::SweetChatSubsystem_HandleIntegerPlayerSettingChange Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.HandleJoinedChannelsChanged
// (Final, Native, Protected)

void USweetChatSubsystem::HandleJoinedChannelsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "HandleJoinedChannelsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.HandleLocalPlayerTalkingUpdate
// (Final, Native, Protected)
// Parameters:
// bool                                    Talking                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxAmp                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetChatSubsystem::HandleLocalPlayerTalkingUpdate(bool Talking, float MaxAmp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "HandleLocalPlayerTalkingUpdate");

	Params::SweetChatSubsystem_HandleLocalPlayerTalkingUpdate Parms{};

	Parms.Talking = Talking;
	Parms.MaxAmp = MaxAmp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.HandleParticipantsChanged
// (Final, Native, Protected)

void USweetChatSubsystem::HandleParticipantsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "HandleParticipantsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.HandleStringPlayerSettingChange
// (Final, Native, Protected)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NewValue                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetChatSubsystem::HandleStringPlayerSettingChange(EPlayerSettingsType SettingType, const class FString& NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "HandleStringPlayerSettingChange");

	Params::SweetChatSubsystem_HandleStringPlayerSettingChange Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = std::move(NewValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.HandleVCInstanceBeingDestroyed
// (Final, Native, Protected)
// Parameters:
// class AEOSVoiceChatHandler*             Instance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetChatSubsystem::HandleVCInstanceBeingDestroyed(class AEOSVoiceChatHandler* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "HandleVCInstanceBeingDestroyed");

	Params::SweetChatSubsystem_HandleVCInstanceBeingDestroyed Parms{};

	Parms.Instance = Instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.HandleVoiceChatChannelExited
// (Final, Native, Protected)
// Parameters:
// class FString                           ChannelName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Reason                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetChatSubsystem::HandleVoiceChatChannelExited(const class FString& ChannelName, const class FString& Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "HandleVoiceChatChannelExited");

	Params::SweetChatSubsystem_HandleVoiceChatChannelExited Parms{};

	Parms.ChannelName = std::move(ChannelName);
	Parms.Reason = std::move(Reason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.HandleVoiceChatChannelJoined
// (Final, Native, Protected)
// Parameters:
// class FString                           ChannelName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetChatSubsystem::HandleVoiceChatChannelJoined(const class FString& ChannelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "HandleVoiceChatChannelJoined");

	Params::SweetChatSubsystem_HandleVoiceChatChannelJoined Parms{};

	Parms.ChannelName = std::move(ChannelName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.HandleVoiceChatDisconnected
// (Final, Native, Protected)
// Parameters:
// class FString                           Reason                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetChatSubsystem::HandleVoiceChatDisconnected(const class FString& Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "HandleVoiceChatDisconnected");

	Params::SweetChatSubsystem_HandleVoiceChatDisconnected Parms{};

	Parms.Reason = std::move(Reason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.HandleVoiceChatLoggedIn
// (Final, Native, Protected)
// Parameters:
// class FString                           PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetChatSubsystem::HandleVoiceChatLoggedIn(const class FString& PlayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "HandleVoiceChatLoggedIn");

	Params::SweetChatSubsystem_HandleVoiceChatLoggedIn Parms{};

	Parms.PlayerName = std::move(PlayerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.HandleVoiceChatLoggedOut
// (Final, Native, Protected)
// Parameters:
// class FString                           PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetChatSubsystem::HandleVoiceChatLoggedOut(const class FString& PlayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "HandleVoiceChatLoggedOut");

	Params::SweetChatSubsystem_HandleVoiceChatLoggedOut Parms{};

	Parms.PlayerName = std::move(PlayerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.HandleVoiceChatPlayerAdded
// (Final, Native, Protected)
// Parameters:
// class FString                           ChannelName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetChatSubsystem::HandleVoiceChatPlayerAdded(const class FString& ChannelName, const class FString& PlayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "HandleVoiceChatPlayerAdded");

	Params::SweetChatSubsystem_HandleVoiceChatPlayerAdded Parms{};

	Parms.ChannelName = std::move(ChannelName);
	Parms.PlayerName = std::move(PlayerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.HandleVoiceChatPlayerMuteUpdated
// (Final, Native, Protected)
// Parameters:
// class FString                           ChannelName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsMuted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetChatSubsystem::HandleVoiceChatPlayerMuteUpdated(const class FString& ChannelName, const class FString& PlayerName, bool bIsMuted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "HandleVoiceChatPlayerMuteUpdated");

	Params::SweetChatSubsystem_HandleVoiceChatPlayerMuteUpdated Parms{};

	Parms.ChannelName = std::move(ChannelName);
	Parms.PlayerName = std::move(PlayerName);
	Parms.bIsMuted = bIsMuted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.HandleVoiceChatPlayerRemoved
// (Final, Native, Protected)
// Parameters:
// class FString                           ChannelName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetChatSubsystem::HandleVoiceChatPlayerRemoved(const class FString& ChannelName, const class FString& PlayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "HandleVoiceChatPlayerRemoved");

	Params::SweetChatSubsystem_HandleVoiceChatPlayerRemoved Parms{};

	Parms.ChannelName = std::move(ChannelName);
	Parms.PlayerName = std::move(PlayerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.HandleVoiceChatPlayerTalkingUpdated
// (Final, Native, Protected)
// Parameters:
// class FString                           ChannelName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsTalking                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetChatSubsystem::HandleVoiceChatPlayerTalkingUpdated(const class FString& ChannelName, const class FString& PlayerName, bool bIsTalking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "HandleVoiceChatPlayerTalkingUpdated");

	Params::SweetChatSubsystem_HandleVoiceChatPlayerTalkingUpdated Parms{};

	Parms.ChannelName = std::move(ChannelName);
	Parms.PlayerName = std::move(PlayerName);
	Parms.bIsTalking = bIsTalking;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.JoinVoiceChannel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ChannelName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ChannelCredentials                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetChatSubsystem::JoinVoiceChannel(const class FString& ChannelName, const class FString& ChannelCredentials)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "JoinVoiceChannel");

	Params::SweetChatSubsystem_JoinVoiceChannel Parms{};

	Parms.ChannelName = std::move(ChannelName);
	Parms.ChannelCredentials = std::move(ChannelCredentials);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetChatSubsystem.LeaveAllVoiceChannels
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetChatSubsystem::LeaveAllVoiceChannels()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "LeaveAllVoiceChannels");

	Params::SweetChatSubsystem_LeaveAllVoiceChannels Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetChatSubsystem.LeaveVoiceChannel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ChannelName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetChatSubsystem::LeaveVoiceChannel(const class FString& ChannelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "LeaveVoiceChannel");

	Params::SweetChatSubsystem_LeaveVoiceChannel Parms{};

	Parms.ChannelName = std::move(ChannelName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetChatSubsystem.SetInputMuted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bMuted                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetChatSubsystem::SetInputMuted(bool bMuted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "SetInputMuted");

	Params::SweetChatSubsystem_SetInputMuted Parms{};

	Parms.bMuted = bMuted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.SetInputVolume
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   Volume                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetChatSubsystem::SetInputVolume(const float& Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "SetInputVolume");

	Params::SweetChatSubsystem_SetInputVolume Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.SetLocalVoiceActivationThreshold
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FNormalizedThreshold                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetChatSubsystem::SetLocalVoiceActivationThreshold(float FNormalizedThreshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "SetLocalVoiceActivationThreshold");

	Params::SweetChatSubsystem_SetLocalVoiceActivationThreshold Parms{};

	Parms.FNormalizedThreshold = FNormalizedThreshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.SetOutputMuted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bMuted                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetChatSubsystem::SetOutputMuted(bool bMuted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "SetOutputMuted");

	Params::SweetChatSubsystem_SetOutputMuted Parms{};

	Parms.bMuted = bMuted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.SetOutputVolume
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   Volume                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetChatSubsystem::SetOutputVolume(const float& Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "SetOutputVolume");

	Params::SweetChatSubsystem_SetOutputVolume Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.SetPlayerMuted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAudioMuted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetChatSubsystem::SetPlayerMuted(const class FString& PlayerName, bool bAudioMuted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "SetPlayerMuted");

	Params::SweetChatSubsystem_SetPlayerMuted Parms{};

	Parms.PlayerName = std::move(PlayerName);
	Parms.bAudioMuted = bAudioMuted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.SetPlayerVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetChatSubsystem::SetPlayerVolume(const class FString& PlayerName, float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "SetPlayerVolume");

	Params::SweetChatSubsystem_SetPlayerVolume Parms{};

	Parms.PlayerName = std::move(PlayerName);
	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.SetTransmitMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerVoiceChatTransmitMode            TransmitMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USweetChatSubsystem::SetTransmitMode(EPlayerVoiceChatTransmitMode TransmitMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "SetTransmitMode");

	Params::SweetChatSubsystem_SetTransmitMode Parms{};

	Parms.TransmitMode = TransmitMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.SweetChatSubsystem.GetInputMuted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetChatSubsystem::GetInputMuted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "GetInputMuted");

	Params::SweetChatSubsystem_GetInputMuted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetChatSubsystem.GetInputVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USweetChatSubsystem::GetInputVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "GetInputVolume");

	Params::SweetChatSubsystem_GetInputVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetChatSubsystem.GetJoinedChannels
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> USweetChatSubsystem::GetJoinedChannels() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "GetJoinedChannels");

	Params::SweetChatSubsystem_GetJoinedChannels Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetChatSubsystem.GetLocalVoiceActivationThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USweetChatSubsystem::GetLocalVoiceActivationThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "GetLocalVoiceActivationThreshold");

	Params::SweetChatSubsystem_GetLocalVoiceActivationThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetChatSubsystem.GetLoggedInPlayerName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USweetChatSubsystem::GetLoggedInPlayerName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "GetLoggedInPlayerName");

	Params::SweetChatSubsystem_GetLoggedInPlayerName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetChatSubsystem.GetOutputMuted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetChatSubsystem::GetOutputMuted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "GetOutputMuted");

	Params::SweetChatSubsystem_GetOutputMuted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetChatSubsystem.GetOutputVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USweetChatSubsystem::GetOutputVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "GetOutputVolume");

	Params::SweetChatSubsystem_GetOutputVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetChatSubsystem.GetPlayersInChannel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ChannelName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> USweetChatSubsystem::GetPlayersInChannel(const class FString& ChannelName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "GetPlayersInChannel");

	Params::SweetChatSubsystem_GetPlayersInChannel Parms{};

	Parms.ChannelName = std::move(ChannelName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetChatSubsystem.GetPlayerVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USweetChatSubsystem::GetPlayerVolume(const class FString& PlayerName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "GetPlayerVolume");

	Params::SweetChatSubsystem_GetPlayerVolume Parms{};

	Parms.PlayerName = std::move(PlayerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetChatSubsystem.GetTransmitMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerVoiceChatTransmitMode            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerVoiceChatTransmitMode USweetChatSubsystem::GetTransmitMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "GetTransmitMode");

	Params::SweetChatSubsystem_GetTransmitMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetChatSubsystem.IsLocalPlayerTalking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetChatSubsystem::IsLocalPlayerTalking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "IsLocalPlayerTalking");

	Params::SweetChatSubsystem_IsLocalPlayerTalking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetChatSubsystem.IsPlayerMuted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetChatSubsystem::IsPlayerMuted(const class FString& PlayerName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "IsPlayerMuted");

	Params::SweetChatSubsystem_IsPlayerMuted Parms{};

	Parms.PlayerName = std::move(PlayerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetChatSubsystem.IsPlayerTalking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USweetChatSubsystem::IsPlayerTalking(const class FString& PlayerName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweetChatSubsystem", "IsPlayerTalking");

	Params::SweetChatSubsystem_IsPlayerTalking Parms{};

	Parms.PlayerName = std::move(PlayerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetMathBlueprintLibrary.GetClampedRatio
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USweetMathBlueprintLibrary::GetClampedRatio(float Value, float Min, float Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetMathBlueprintLibrary", "GetClampedRatio");

	Params::SweetMathBlueprintLibrary_GetClampedRatio Parms{};

	Parms.Value = Value;
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetMathBlueprintLibrary.GetRatio
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USweetMathBlueprintLibrary::GetRatio(float Value, float Min, float Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetMathBlueprintLibrary", "GetRatio");

	Params::SweetMathBlueprintLibrary_GetRatio Parms{};

	Parms.Value = Value;
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetMathBlueprintLibrary.LerpColor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FColor                           A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor USweetMathBlueprintLibrary::LerpColor(const struct FColor& A, const struct FColor& B, const float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetMathBlueprintLibrary", "LerpColor");

	Params::SweetMathBlueprintLibrary_LerpColor Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.SweetMathBlueprintLibrary.RandRangeExcludingInteger
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Excluded                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USweetMathBlueprintLibrary::RandRangeExcludingInteger(int32 Min, int32 Max, int32 Excluded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SweetMathBlueprintLibrary", "RandRangeExcludingInteger");

	Params::SweetMathBlueprintLibrary_RandRangeExcludingInteger Parms{};

	Parms.Min = Min;
	Parms.Max = Max;
	Parms.Excluded = Excluded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ToolLoadoutComponent.AddActorToIgnoreList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::AddActorToIgnoreList(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "AddActorToIgnoreList");

	Params::ToolLoadoutComponent_AddActorToIgnoreList Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.BP_OnActiveAbilityToolEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// ESpyToolEvent                           Event                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::BP_OnActiveAbilityToolEvent(ESpyToolEvent Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "BP_OnActiveAbilityToolEvent");

	Params::ToolLoadoutComponent_BP_OnActiveAbilityToolEvent Parms{};

	Parms.Event = Event;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.ToolLoadoutComponent.BP_OnActiveHandToolEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// ESpyToolEvent                           Event                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::BP_OnActiveHandToolEvent(ESpyToolEvent Event, class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "BP_OnActiveHandToolEvent");

	Params::ToolLoadoutComponent_BP_OnActiveHandToolEvent Parms{};

	Parms.Event = Event;
	Parms.SpyTool = SpyTool;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.ToolLoadoutComponent.BP_OnMeleeAttackEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// ESpyMeleeAttackEvent                    Event                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::BP_OnMeleeAttackEvent(ESpyMeleeAttackEvent Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "BP_OnMeleeAttackEvent");

	Params::ToolLoadoutComponent_BP_OnMeleeAttackEvent Parms{};

	Parms.Event = Event;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.ToolLoadoutComponent.Client_SetCurrentSelectedSlot
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// ELoadoutSlot                            ServerSelectedSlot                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::Client_SetCurrentSelectedSlot(ELoadoutSlot ServerSelectedSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "Client_SetCurrentSelectedSlot");

	Params::ToolLoadoutComponent_Client_SetCurrentSelectedSlot Parms{};

	Parms.ServerSelectedSlot = ServerSelectedSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.Client_SetForcedGadgetSlot
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// ELoadoutSlot                            ForcedToolSlot                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSwitchToSlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::Client_SetForcedGadgetSlot(ELoadoutSlot ForcedToolSlot, bool bSwitchToSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "Client_SetForcedGadgetSlot");

	Params::ToolLoadoutComponent_Client_SetForcedGadgetSlot Parms{};

	Parms.ForcedToolSlot = ForcedToolSlot;
	Parms.bSwitchToSlot = bSwitchToSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.DisableForcedGadgetSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSwitchToSlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::DisableForcedGadgetSlot(bool bSwitchToSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "DisableForcedGadgetSlot");

	Params::ToolLoadoutComponent_DisableForcedGadgetSlot Parms{};

	Parms.bSwitchToSlot = bSwitchToSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.EnableForcedGadgetSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELoadoutSlot                            ForcedSelection                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSwitchToSlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::EnableForcedGadgetSlot(ELoadoutSlot ForcedSelection, bool bSwitchToSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "EnableForcedGadgetSlot");

	Params::ToolLoadoutComponent_EnableForcedGadgetSlot Parms{};

	Parms.ForcedSelection = ForcedSelection;
	Parms.bSwitchToSlot = bSwitchToSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.HandleActiveAbilityToolEvent
// (Final, Native, Protected)
// Parameters:
// ESpyToolEvent                           Event                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::HandleActiveAbilityToolEvent(ESpyToolEvent Event, class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "HandleActiveAbilityToolEvent");

	Params::ToolLoadoutComponent_HandleActiveAbilityToolEvent Parms{};

	Parms.Event = Event;
	Parms.SpyTool = SpyTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.HandleActiveHandToolEvent
// (Final, Native, Protected)
// Parameters:
// ESpyToolEvent                           Event                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::HandleActiveHandToolEvent(ESpyToolEvent Event, class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "HandleActiveHandToolEvent");

	Params::ToolLoadoutComponent_HandleActiveHandToolEvent Parms{};

	Parms.Event = Event;
	Parms.SpyTool = SpyTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.HandleMeleeAttackEvent
// (Final, Native, Protected)
// Parameters:
// ESpyMeleeAttackEvent                    Event                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseMeleeAttack*                 MeleeAttack                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::HandleMeleeAttackEvent(ESpyMeleeAttackEvent Event, class ABaseMeleeAttack* MeleeAttack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "HandleMeleeAttackEvent");

	Params::ToolLoadoutComponent_HandleMeleeAttackEvent Parms{};

	Parms.Event = Event;
	Parms.MeleeAttack = MeleeAttack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.IsLoadoutSpawnComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UToolLoadoutComponent::IsLoadoutSpawnComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "IsLoadoutSpawnComplete");

	Params::ToolLoadoutComponent_IsLoadoutSpawnComplete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ToolLoadoutComponent.OnRep_ActivePowerInstance
// (Final, Native, Protected)
// Parameters:
// class ABaseSpyActiveAbility*            OldGadget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::OnRep_ActivePowerInstance(class ABaseSpyActiveAbility* OldGadget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "OnRep_ActivePowerInstance");

	Params::ToolLoadoutComponent_OnRep_ActivePowerInstance Parms{};

	Parms.OldGadget = OldGadget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.OnRep_CallingCardInstance
// (Final, Native, Protected)
// Parameters:
// class ACallingCardPlaceableTool*        OldGadget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::OnRep_CallingCardInstance(class ACallingCardPlaceableTool* OldGadget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "OnRep_CallingCardInstance");

	Params::ToolLoadoutComponent_OnRep_CallingCardInstance Parms{};

	Parms.OldGadget = OldGadget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.OnRep_CurrentSlot
// (Final, Native, Protected)
// Parameters:
// ELoadoutSlot                            OldSelectedSlot                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::OnRep_CurrentSlot(ELoadoutSlot OldSelectedSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "OnRep_CurrentSlot");

	Params::ToolLoadoutComponent_OnRep_CurrentSlot Parms{};

	Parms.OldSelectedSlot = OldSelectedSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.OnRep_MeleeAttackInstance
// (Final, Native, Protected)
// Parameters:
// class ABaseMeleeAttack*                 OldGadget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::OnRep_MeleeAttackInstance(class ABaseMeleeAttack* OldGadget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "OnRep_MeleeAttackInstance");

	Params::ToolLoadoutComponent_OnRep_MeleeAttackInstance Parms{};

	Parms.OldGadget = OldGadget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.OnRep_NavModeInstance
// (Final, Native, Protected)
// Parameters:
// class ABaseSpyTool*                     OldGadget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::OnRep_NavModeInstance(class ABaseSpyTool* OldGadget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "OnRep_NavModeInstance");

	Params::ToolLoadoutComponent_OnRep_NavModeInstance Parms{};

	Parms.OldGadget = OldGadget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.OnRep_PassivePowerInstance
// (Final, Native, Protected)
// Parameters:
// class ABaseSpyPassiveAbility*           OldGadget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::OnRep_PassivePowerInstance(class ABaseSpyPassiveAbility* OldGadget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "OnRep_PassivePowerInstance");

	Params::ToolLoadoutComponent_OnRep_PassivePowerInstance Parms{};

	Parms.OldGadget = OldGadget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.OnRep_SecondarySlotWeapon
// (Final, Native, Protected)
// Parameters:
// class ABaseSpyTool*                     OldWeapon                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::OnRep_SecondarySlotWeapon(class ABaseSpyTool* OldWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "OnRep_SecondarySlotWeapon");

	Params::ToolLoadoutComponent_OnRep_SecondarySlotWeapon Parms{};

	Parms.OldWeapon = OldWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.OnRep_SelectableSlotGadget1
// (Final, Native, Protected)
// Parameters:
// class ABaseSpyTool*                     OldGadget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::OnRep_SelectableSlotGadget1(class ABaseSpyTool* OldGadget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "OnRep_SelectableSlotGadget1");

	Params::ToolLoadoutComponent_OnRep_SelectableSlotGadget1 Parms{};

	Parms.OldGadget = OldGadget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.OnRep_SelectableSlotGadget2
// (Final, Native, Protected)
// Parameters:
// class ABaseSpyTool*                     OldGadget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::OnRep_SelectableSlotGadget2(class ABaseSpyTool* OldGadget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "OnRep_SelectableSlotGadget2");

	Params::ToolLoadoutComponent_OnRep_SelectableSlotGadget2 Parms{};

	Parms.OldGadget = OldGadget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.OnRep_SelectableSlotWeapon
// (Final, Native, Protected)
// Parameters:
// class ABaseSpyTool*                     OldWeapon                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::OnRep_SelectableSlotWeapon(class ABaseSpyTool* OldWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "OnRep_SelectableSlotWeapon");

	Params::ToolLoadoutComponent_OnRep_SelectableSlotWeapon Parms{};

	Parms.OldWeapon = OldWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.OnRep_TemporaryToolInstance
// (Final, Native, Protected)
// Parameters:
// class ABaseSpyTool*                     OldTempTool                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::OnRep_TemporaryToolInstance(class ABaseSpyTool* OldTempTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "OnRep_TemporaryToolInstance");

	Params::ToolLoadoutComponent_OnRep_TemporaryToolInstance Parms{};

	Parms.OldTempTool = OldTempTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.RemoveActorFromIgnoreList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::RemoveActorFromIgnoreList(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "RemoveActorFromIgnoreList");

	Params::ToolLoadoutComponent_RemoveActorFromIgnoreList Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.SelectHandToolFromNextSlot
// (Final, Native, Public, BlueprintCallable)

void UToolLoadoutComponent::SelectHandToolFromNextSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "SelectHandToolFromNextSlot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.SelectHandToolFromPreviousSlot
// (Final, Native, Public, BlueprintCallable)

void UToolLoadoutComponent::SelectHandToolFromPreviousSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "SelectHandToolFromPreviousSlot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.SelectHandToolFromSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELoadoutSlot                            ToolSlot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromServer                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromOwner                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::SelectHandToolFromSlot(ELoadoutSlot ToolSlot, bool bFromServer, bool bFromOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "SelectHandToolFromSlot");

	Params::ToolLoadoutComponent_SelectHandToolFromSlot Parms{};

	Parms.ToolSlot = ToolSlot;
	Parms.bFromServer = bFromServer;
	Parms.bFromOwner = bFromOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.Server_SelectHandToolFromSlot
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// ELoadoutSlot                            ToolSlot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToolLoadoutComponent::Server_SelectHandToolFromSlot(ELoadoutSlot ToolSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "Server_SelectHandToolFromSlot");

	Params::ToolLoadoutComponent_Server_SelectHandToolFromSlot Parms{};

	Parms.ToolSlot = ToolSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ToolLoadoutComponent.GetActivePower
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABaseSpyActiveAbility*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABaseSpyActiveAbility* UToolLoadoutComponent::GetActivePower() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "GetActivePower");

	Params::ToolLoadoutComponent_GetActivePower Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ToolLoadoutComponent.GetCallingCard
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABaseSpyTool*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABaseSpyTool* UToolLoadoutComponent::GetCallingCard() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "GetCallingCard");

	Params::ToolLoadoutComponent_GetCallingCard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ToolLoadoutComponent.GetCallingCardTool
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACallingCardPlaceableTool*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACallingCardPlaceableTool* UToolLoadoutComponent::GetCallingCardTool() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "GetCallingCardTool");

	Params::ToolLoadoutComponent_GetCallingCardTool Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ToolLoadoutComponent.GetCurrentHandTool
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABaseSpyTool*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABaseSpyTool* UToolLoadoutComponent::GetCurrentHandTool() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "GetCurrentHandTool");

	Params::ToolLoadoutComponent_GetCurrentHandTool Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ToolLoadoutComponent.GetCurrentHandToolSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELoadoutSlot                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELoadoutSlot UToolLoadoutComponent::GetCurrentHandToolSlot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "GetCurrentHandToolSlot");

	Params::ToolLoadoutComponent_GetCurrentHandToolSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ToolLoadoutComponent.GetHandToolInSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELoadoutSlot                            ToolSlot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseSpyTool*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABaseSpyTool* UToolLoadoutComponent::GetHandToolInSlot(ELoadoutSlot ToolSlot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "GetHandToolInSlot");

	Params::ToolLoadoutComponent_GetHandToolInSlot Parms{};

	Parms.ToolSlot = ToolSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ToolLoadoutComponent.GetHandToolSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABaseSpyTool*                     HandTool                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELoadoutSlot                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELoadoutSlot UToolLoadoutComponent::GetHandToolSlot(class ABaseSpyTool* HandTool) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "GetHandToolSlot");

	Params::ToolLoadoutComponent_GetHandToolSlot Parms{};

	Parms.HandTool = HandTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ToolLoadoutComponent.GetMeleeAttack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABaseMeleeAttack*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABaseMeleeAttack* UToolLoadoutComponent::GetMeleeAttack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "GetMeleeAttack");

	Params::ToolLoadoutComponent_GetMeleeAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ToolLoadoutComponent.GetNavModeTool
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABaseSpyTool*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABaseSpyTool* UToolLoadoutComponent::GetNavModeTool() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "GetNavModeTool");

	Params::ToolLoadoutComponent_GetNavModeTool Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ToolLoadoutComponent.GetPassivePower
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABaseSpyPassiveAbility*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABaseSpyPassiveAbility* UToolLoadoutComponent::GetPassivePower() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "GetPassivePower");

	Params::ToolLoadoutComponent_GetPassivePower Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ToolLoadoutComponent.HasAuthority
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UToolLoadoutComponent::HasAuthority() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "HasAuthority");

	Params::ToolLoadoutComponent_HasAuthority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ToolLoadoutComponent.IsActorInIgnoreList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UToolLoadoutComponent::IsActorInIgnoreList(class AActor* TargetActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "IsActorInIgnoreList");

	Params::ToolLoadoutComponent_IsActorInIgnoreList Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.ToolLoadoutComponent.IsLocallyControlled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UToolLoadoutComponent::IsLocallyControlled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToolLoadoutComponent", "IsLocallyControlled");

	Params::ToolLoadoutComponent_IsLocallyControlled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.Tripwire.OnRep_Connections
// (Final, Native, Protected)

void ATripwire::OnRep_Connections()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Tripwire", "OnRep_Connections");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Tripwire.OnRep_IsLinked
// (Final, Native, Protected)

void ATripwire::OnRep_IsLinked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Tripwire", "OnRep_IsLinked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.Tripwire.IsLinked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATripwire::IsLinked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Tripwire", "IsLinked");

	Params::Tripwire_IsLinked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.TripwireTool.BP_OnTripwireTriggered
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATripwireTool::BP_OnTripwireTriggered(class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TripwireTool", "BP_OnTripwireTriggered");

	Params::TripwireTool_BP_OnTripwireTriggered Parms{};

	Parms.Spy = Spy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.TripwireTool.HandleTripwireDropDone
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           ActorDropped                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndPos                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         EndRotation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATripwireTool::HandleTripwireDropDone(class AActor* ActorDropped, const struct FVector& EndPos, const struct FRotator& EndRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TripwireTool", "HandleTripwireDropDone");

	Params::TripwireTool_HandleTripwireDropDone Parms{};

	Parms.ActorDropped = ActorDropped;
	Parms.EndPos = std::move(EndPos);
	Parms.EndRotation = std::move(EndRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.UnlockConditionComponent.OnNewBotPlayerController
// (Final, Native, Private)
// Parameters:
// class ADeceiveIncPlayerBotController*   NewPlayerBot                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUnlockConditionComponent::OnNewBotPlayerController(class ADeceiveIncPlayerBotController* NewPlayerBot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnlockConditionComponent", "OnNewBotPlayerController");

	Params::UnlockConditionComponent_OnNewBotPlayerController Parms{};

	Parms.NewPlayerBot = NewPlayerBot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.UnlockConditionComponent.OnPlayerLogout
// (Final, Native, Private)
// Parameters:
// class AController*                      ExitingController                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUnlockConditionComponent::OnPlayerLogout(class AController* ExitingController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnlockConditionComponent", "OnPlayerLogout");

	Params::UnlockConditionComponent_OnPlayerLogout Parms{};

	Parms.ExitingController = ExitingController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.UnlockConditionComponent.OnPlayerPostLogin
// (Final, Native, Private)
// Parameters:
// class APlayerController*                NewPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUnlockConditionComponent::OnPlayerPostLogin(class APlayerController* NewPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnlockConditionComponent", "OnPlayerPostLogin");

	Params::UnlockConditionComponent_OnPlayerPostLogin Parms{};

	Parms.NewPlayer = NewPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.UnlockConditionComponent.OnRep_PlayerUnlocked
// (Final, Native, Private)

void UUnlockConditionComponent::OnRep_PlayerUnlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnlockConditionComponent", "OnRep_PlayerUnlocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.UnlockConditionComponent.OnResourceSpent
// (Final, Native, Private)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUnlockConditionComponent::OnResourceSpent(class UInteracterComponent* Interacter, EGameplayResourcesType ResourceType, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnlockConditionComponent", "OnResourceSpent");

	Params::UnlockConditionComponent_OnResourceSpent Parms{};

	Parms.Interacter = Interacter;
	Parms.ResourceType = ResourceType;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.UnlockConditionComponent.GetPlayerIdFromActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUnlockConditionComponent::GetPlayerIdFromActor(class AActor* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnlockConditionComponent", "GetPlayerIdFromActor");

	Params::UnlockConditionComponent_GetPlayerIdFromActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VictimEffectTickBehavior_Charm.OnServerSpyVictimUndercoverChange
// (Final, Native, Public)
// Parameters:
// bool                                    bUndercover                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVictimEffectTickBehavior_Charm::OnServerSpyVictimUndercoverChange(bool bUndercover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffectTickBehavior_Charm", "OnServerSpyVictimUndercoverChange");

	Params::VictimEffectTickBehavior_Charm_OnServerSpyVictimUndercoverChange Parms{};

	Parms.bUndercover = bUndercover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffectTickBehavior_Poison.HandleInteractionComplete
// (Final, Native, Protected)
// Parameters:
// class UInteracterComponent*             Interacter                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           Interactable                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVictimEffectTickBehavior_Poison::HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffectTickBehavior_Poison", "HandleInteractionComplete");

	Params::VictimEffectTickBehavior_Poison_HandleInteractionComplete Parms{};

	Parms.Interacter = Interacter;
	Parms.Interactable = Interactable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffectTickBehavior_Trace.OnTraceBegin
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UVictimEffectTickBehavior_Trace*  InTrace                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InTraceVictim                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVictimEffectTickBehavior_Trace::OnTraceBegin(class UVictimEffectTickBehavior_Trace* InTrace, class AActor* InTraceVictim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffectTickBehavior_Trace", "OnTraceBegin");

	Params::VictimEffectTickBehavior_Trace_OnTraceBegin Parms{};

	Parms.InTrace = InTrace;
	Parms.InTraceVictim = InTraceVictim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.VictimEffectTickBehavior_Trace.OnTraceEnd
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UVictimEffectTickBehavior_Trace*  InTrace                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InTraceVictim                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVictimEffectTickBehavior_Trace::OnTraceEnd(class UVictimEffectTickBehavior_Trace* InTrace, class AActor* InTraceVictim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffectTickBehavior_Trace", "OnTraceEnd");

	Params::VictimEffectTickBehavior_Trace_OnTraceEnd Parms{};

	Parms.InTrace = InTrace;
	Parms.InTraceVictim = InTraceVictim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.VictimEffectUserWidget.GetProgressRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVictimEffectUserWidget::GetProgressRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffectUserWidget", "GetProgressRatio");

	Params::VictimEffectUserWidget_GetProgressRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VictimEffectUserWidget.GetProgressRatioInverted
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVictimEffectUserWidget::GetProgressRatioInverted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffectUserWidget", "GetProgressRatioInverted");

	Params::VictimEffectUserWidget_GetProgressRatioInverted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VictimEffectUserWidget.HandleAddVictimEffect
// (Final, Native, Protected)
// Parameters:
// class AVictimEffect*                    Effect                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVictimEffectUserWidget::HandleAddVictimEffect(class AVictimEffect* Effect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffectUserWidget", "HandleAddVictimEffect");

	Params::VictimEffectUserWidget_HandleAddVictimEffect Parms{};

	Parms.Effect = Effect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffectUserWidget.HandleRemoveVictimEffect
// (Final, Native, Protected)
// Parameters:
// class AVictimEffect*                    Effect                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVictimEffectUserWidget::HandleRemoveVictimEffect(class AVictimEffect* Effect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffectUserWidget", "HandleRemoveVictimEffect");

	Params::VictimEffectUserWidget_HandleRemoveVictimEffect Parms{};

	Parms.Effect = Effect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VictimEffectUserWidget.SetupVictim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AVictimEffect*                    Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVictimEffectUserWidget::SetupVictim(class AVictimEffect* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictimEffectUserWidget", "SetupVictim");

	Params::VictimEffectUserWidget_SetupVictim Parms{};

	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilPassiveAbilityDeviceBased.HandleAbilityWeaponSpawned
// (Final, Native, Protected)
// Parameters:
// class AVigilActiveAbility*              Active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AProjectileWeapon*                Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVigilPassiveAbilityDeviceBased::HandleAbilityWeaponSpawned(class AVigilActiveAbility* Active, class AProjectileWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilPassiveAbilityDeviceBased", "HandleAbilityWeaponSpawned");

	Params::VigilPassiveAbilityDeviceBased_HandleAbilityWeaponSpawned Parms{};

	Parms.Active = Active;
	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilPassiveAbilityDeviceBased.HandleADSChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bInADS                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVigilPassiveAbilityDeviceBased::HandleADSChanged(bool bInADS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilPassiveAbilityDeviceBased", "HandleADSChanged");

	Params::VigilPassiveAbilityDeviceBased_HandleADSChanged Parms{};

	Parms.bInADS = bInADS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilPassiveAbilityDeviceBased.HandleDeviceDestroyed
// (Final, Native, Protected)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVigilPassiveAbilityDeviceBased::HandleDeviceDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilPassiveAbilityDeviceBased", "HandleDeviceDestroyed");

	Params::VigilPassiveAbilityDeviceBased_HandleDeviceDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilPassiveAbilityDeviceBased.HandleLoadoutSpawnCompleteEvent
// (Final, Native, Protected)
// Parameters:
// class UToolLoadoutComponent*            LoadoutComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVigilPassiveAbilityDeviceBased::HandleLoadoutSpawnCompleteEvent(class UToolLoadoutComponent* LoadoutComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilPassiveAbilityDeviceBased", "HandleLoadoutSpawnCompleteEvent");

	Params::VigilPassiveAbilityDeviceBased_HandleLoadoutSpawnCompleteEvent Parms{};

	Parms.LoadoutComponent = LoadoutComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilPassiveAbilityDeviceBased.HandleMeleeSpyToolEvent
// (Final, Native, Protected)
// Parameters:
// ESpyToolEvent                           EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseSpyTool*                     SpyTool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVigilPassiveAbilityDeviceBased::HandleMeleeSpyToolEvent(ESpyToolEvent EventType, class ABaseSpyTool* SpyTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilPassiveAbilityDeviceBased", "HandleMeleeSpyToolEvent");

	Params::VigilPassiveAbilityDeviceBased_HandleMeleeSpyToolEvent Parms{};

	Parms.EventType = EventType;
	Parms.SpyTool = SpyTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilPassiveAbilityDeviceBased.HandleSpyTransformInMimic
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABaseMimicScannableActor*         Mimic                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVigilPassiveAbilityDeviceBased::HandleSpyTransformInMimic(class ASpy* Spy, class ABaseMimicScannableActor* Mimic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilPassiveAbilityDeviceBased", "HandleSpyTransformInMimic");

	Params::VigilPassiveAbilityDeviceBased_HandleSpyTransformInMimic Parms{};

	Parms.Spy = Spy;
	Parms.Mimic = Mimic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilPassiveAbilityDeviceBased.HandleVictimCoverChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bUndercover                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVigilPassiveAbilityDeviceBased::HandleVictimCoverChange(bool bUndercover)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilPassiveAbilityDeviceBased", "HandleVictimCoverChange");

	Params::VigilPassiveAbilityDeviceBased_HandleVictimCoverChange Parms{};

	Parms.bUndercover = bUndercover;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilPassiveAbilityDeviceBased.HandleVictimCoverSwitch
// (Final, Native, Protected)
// Parameters:
// class ANPCCharacter*                    NewDisguise                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVigilPassiveAbilityDeviceBased::HandleVictimCoverSwitch(class ANPCCharacter* NewDisguise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilPassiveAbilityDeviceBased", "HandleVictimCoverSwitch");

	Params::VigilPassiveAbilityDeviceBased_HandleVictimCoverSwitch Parms{};

	Parms.NewDisguise = NewDisguise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilPassiveAbilityDeviceBased.NetMulticast_FireDevice
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FVector_NetQuantize              OriginPosition                                         (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              DestinationPos                                         (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVigilPassiveAbilityDeviceBased::NetMulticast_FireDevice(const struct FVector_NetQuantize& OriginPosition, const struct FVector_NetQuantize& DestinationPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilPassiveAbilityDeviceBased", "NetMulticast_FireDevice");

	Params::VigilPassiveAbilityDeviceBased_NetMulticast_FireDevice Parms{};

	Parms.OriginPosition = std::move(OriginPosition);
	Parms.DestinationPos = std::move(DestinationPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilPassiveAbilityDeviceBased.NetMulticast_OnVictimAnnouncementEnd
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ASpy*                             SpyVictim                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVigilPassiveAbilityDeviceBased::NetMulticast_OnVictimAnnouncementEnd(class ASpy* SpyVictim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilPassiveAbilityDeviceBased", "NetMulticast_OnVictimAnnouncementEnd");

	Params::VigilPassiveAbilityDeviceBased_NetMulticast_OnVictimAnnouncementEnd Parms{};

	Parms.SpyVictim = SpyVictim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilPassiveAbilityDeviceBased.NetMulticast_OnVictimAnnouncementStart
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ASpy*                             SpyVictim                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVigilPassiveAbilityDeviceBased::NetMulticast_OnVictimAnnouncementStart(class ASpy* SpyVictim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilPassiveAbilityDeviceBased", "NetMulticast_OnVictimAnnouncementStart");

	Params::VigilPassiveAbilityDeviceBased_NetMulticast_OnVictimAnnouncementStart Parms{};

	Parms.SpyVictim = SpyVictim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilPassiveAbilityDeviceBased.NetMulticast_StartDeviceThrow
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void AVigilPassiveAbilityDeviceBased::NetMulticast_StartDeviceThrow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilPassiveAbilityDeviceBased", "NetMulticast_StartDeviceThrow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilPassiveAbilityDeviceBased.NetMultucast_OnDeviceSpawnFailed
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void AVigilPassiveAbilityDeviceBased::NetMultucast_OnDeviceSpawnFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilPassiveAbilityDeviceBased", "NetMultucast_OnDeviceSpawnFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilPassiveAbilityDeviceBased.OnPassiveCooldownTimerEnd
// (Final, Native, Protected)

void AVigilPassiveAbilityDeviceBased::OnPassiveCooldownTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilPassiveAbilityDeviceBased", "OnPassiveCooldownTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilPassiveAbilityDeviceBased.OnRep_Device
// (Final, Native, Protected)

void AVigilPassiveAbilityDeviceBased::OnRep_Device()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilPassiveAbilityDeviceBased", "OnRep_Device");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilPassiveAbilityDeviceBased.OnRep_RealVictim
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OldRealVictim                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVigilPassiveAbilityDeviceBased::OnRep_RealVictim(class AActor* OldRealVictim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilPassiveAbilityDeviceBased", "OnRep_RealVictim");

	Params::VigilPassiveAbilityDeviceBased_OnRep_RealVictim Parms{};

	Parms.OldRealVictim = OldRealVictim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilPassiveAbilityDeviceBased.OnThrowDelayTimerEnd
// (Native, Protected)
// Parameters:
// bool                                    bIsLocal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVigilPassiveAbilityDeviceBased::OnThrowDelayTimerEnd(bool bIsLocal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilPassiveAbilityDeviceBased", "OnThrowDelayTimerEnd");

	Params::VigilPassiveAbilityDeviceBased_OnThrowDelayTimerEnd Parms{};

	Parms.bIsLocal = bIsLocal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilPassiveAbilityDeviceBased.OnThrowOutDelayTimerEnd
// (Native, Protected)

void AVigilPassiveAbilityDeviceBased::OnThrowOutDelayTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilPassiveAbilityDeviceBased", "OnThrowOutDelayTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilPassiveAbilityDeviceBased.Server_FireDevice
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// struct FVector_NetQuantize              OriginPosition                                         (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              DestinationPos                                         (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVigilPassiveAbilityDeviceBased::Server_FireDevice(const struct FVector_NetQuantize& OriginPosition, const struct FVector_NetQuantize& DestinationPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilPassiveAbilityDeviceBased", "Server_FireDevice");

	Params::VigilPassiveAbilityDeviceBased_Server_FireDevice Parms{};

	Parms.OriginPosition = std::move(OriginPosition);
	Parms.DestinationPos = std::move(DestinationPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilPassiveAbilityDeviceBased.Server_SpawnDevice
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// struct FVector_NetQuantize              HitLocation                                            (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              HitNormal                                              (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorHit                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVigilPassiveAbilityDeviceBased::Server_SpawnDevice(const struct FVector_NetQuantize& HitLocation, const struct FVector_NetQuantize& HitNormal, class AActor* ActorHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilPassiveAbilityDeviceBased", "Server_SpawnDevice");

	Params::VigilPassiveAbilityDeviceBased_Server_SpawnDevice Parms{};

	Parms.HitLocation = std::move(HitLocation);
	Parms.HitNormal = std::move(HitNormal);
	Parms.ActorHit = ActorHit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VigilPassiveAbilityDeviceBased.Server_StartDeviceThrow
// (Net, NetReliable, Native, Event, Protected, NetServer)

void AVigilPassiveAbilityDeviceBased::Server_StartDeviceThrow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VigilPassiveAbilityDeviceBased", "Server_StartDeviceThrow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VoiceChatControlPanelEntryWidget.BP_OnPlayerMutedChange
// (Event, Public, BlueprintEvent)

void UVoiceChatControlPanelEntryWidget::BP_OnPlayerMutedChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoiceChatControlPanelEntryWidget", "BP_OnPlayerMutedChange");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.VoiceChatControlPanelEntryWidget.BP_OnPlayerNameChange
// (Event, Public, BlueprintEvent)

void UVoiceChatControlPanelEntryWidget::BP_OnPlayerNameChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoiceChatControlPanelEntryWidget", "BP_OnPlayerNameChange");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.VoiceChatControlPanelEntryWidget.BP_OnPlayerStateChange
// (Event, Public, BlueprintEvent)

void UVoiceChatControlPanelEntryWidget::BP_OnPlayerStateChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoiceChatControlPanelEntryWidget", "BP_OnPlayerStateChange");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.VoiceChatControlPanelEntryWidget.BP_OnPlayerVolumeChange
// (Event, Public, BlueprintEvent)

void UVoiceChatControlPanelEntryWidget::BP_OnPlayerVolumeChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoiceChatControlPanelEntryWidget", "BP_OnPlayerVolumeChange");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.VoiceChatControlPanelEntryWidget.SetMuted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInMuted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoiceChatControlPanelEntryWidget::SetMuted(bool bInMuted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoiceChatControlPanelEntryWidget", "SetMuted");

	Params::VoiceChatControlPanelEntryWidget_SetMuted Parms{};

	Parms.bInMuted = bInMuted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VoiceChatControlPanelEntryWidget.SetVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewVolume                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoiceChatControlPanelEntryWidget::SetVolume(float NewVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoiceChatControlPanelEntryWidget", "SetVolume");

	Params::VoiceChatControlPanelEntryWidget_SetVolume Parms{};

	Parms.NewVolume = NewVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.VoiceChatControlPanelEntryWidget.GetVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVoiceChatControlPanelEntryWidget::GetVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoiceChatControlPanelEntryWidget", "GetVolume");

	Params::VoiceChatControlPanelEntryWidget_GetVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VoiceChatControlPanelEntryWidget.IsLocalPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoiceChatControlPanelEntryWidget::IsLocalPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoiceChatControlPanelEntryWidget", "IsLocalPlayer");

	Params::VoiceChatControlPanelEntryWidget_IsLocalPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VoiceChatControlPanelEntryWidget.IsMuted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoiceChatControlPanelEntryWidget::IsMuted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoiceChatControlPanelEntryWidget", "IsMuted");

	Params::VoiceChatControlPanelEntryWidget_IsMuted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VoicechatMemberWidget.OnPlayerInfoUpdated
// (Event, Public, BlueprintEvent)

void UVoicechatMemberWidget::OnPlayerInfoUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoicechatMemberWidget", "OnPlayerInfoUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.VoicechatMemberWidget.GetIntendedVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESlateVisibility                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateVisibility UVoicechatMemberWidget::GetIntendedVisibility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoicechatMemberWidget", "GetIntendedVisibility");

	Params::VoicechatMemberWidget_GetIntendedVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VoicechatMemberWidget.GetPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADIPlayerState*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADIPlayerState* UVoicechatMemberWidget::GetPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoicechatMemberWidget", "GetPlayerState");

	Params::VoicechatMemberWidget_GetPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VoicechatMemberWidget.GetUserName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UVoicechatMemberWidget::GetUserName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoicechatMemberWidget", "GetUserName");

	Params::VoicechatMemberWidget_GetUserName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VoicechatMemberWidget.GetUserPlatform
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlatformType                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlatformType UVoicechatMemberWidget::GetUserPlatform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoicechatMemberWidget", "GetUserPlatform");

	Params::VoicechatMemberWidget_GetUserPlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.VoicechatMemberWidget.IsPlayerTalking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoicechatMemberWidget::IsPlayerTalking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoicechatMemberWidget", "IsPlayerTalking");

	Params::VoicechatMemberWidget_IsPlayerTalking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.WeaponOverheatComponent.MulticastOverheatStart
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void UWeaponOverheatComponent::MulticastOverheatStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponOverheatComponent", "MulticastOverheatStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.WeaponOverheatComponent.OnHeatDecreaseDelayTimerEnd
// (Final, Native, Protected)

void UWeaponOverheatComponent::OnHeatDecreaseDelayTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponOverheatComponent", "OnHeatDecreaseDelayTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.WeaponOverheatComponent.OnShotCycleBegin
// (Final, Native, Protected)

void UWeaponOverheatComponent::OnShotCycleBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponOverheatComponent", "OnShotCycleBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.WeaponOverheatComponent.OnShotCycleEnd
// (Final, Native, Protected)

void UWeaponOverheatComponent::OnShotCycleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponOverheatComponent", "OnShotCycleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.WeaponOverheatComponent.OnWeaponDisabledChange
// (Final, Native, Protected)
// Parameters:
// class AProjectileWeapon*                Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDisabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponOverheatComponent::OnWeaponDisabledChange(class AProjectileWeapon* Weapon, bool bDisabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponOverheatComponent", "OnWeaponDisabledChange");

	Params::WeaponOverheatComponent_OnWeaponDisabledChange Parms{};

	Parms.Weapon = Weapon;
	Parms.bDisabled = bDisabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.WeaponOverheatComponent.OnWeaponShot
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// struct FVector                          ShotEndPoint                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AProjectileWeapon*                Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponOverheatComponent::OnWeaponShot(const struct FVector& ShotEndPoint, class AProjectileWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponOverheatComponent", "OnWeaponShot");

	Params::WeaponOverheatComponent_OnWeaponShot Parms{};

	Parms.ShotEndPoint = std::move(ShotEndPoint);
	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.WeaponOverheatComponent.GetCurWeaponHeat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWeaponOverheatComponent::GetCurWeaponHeat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponOverheatComponent", "GetCurWeaponHeat");

	Params::WeaponOverheatComponent_GetCurWeaponHeat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.WebStreamedFanartAsset.BP_OnFanartAssetDefinitionUpdated
// (Event, Public, BlueprintEvent)

void AWebStreamedFanartAsset::BP_OnFanartAssetDefinitionUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WebStreamedFanartAsset", "BP_OnFanartAssetDefinitionUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeceiveInc.WebStreamedFanartAsset.OnRep_FanartAssetDefinition
// (Final, Native, Protected)

void AWebStreamedFanartAsset::OnRep_FanartAssetDefinition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WebStreamedFanartAsset", "OnRep_FanartAssetDefinition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.XiuActiveAbility.BP_OnLocalNewXiuActiveTarget
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ANPCCharacter*                    PrevBestNPCTargetIn                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANPCCharacter*                    NewBestNPCTargetIn                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AXiuActiveAbility::BP_OnLocalNewXiuActiveTarget(class ANPCCharacter* PrevBestNPCTargetIn, class ANPCCharacter* NewBestNPCTargetIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuActiveAbility", "BP_OnLocalNewXiuActiveTarget");

	Params::XiuActiveAbility_BP_OnLocalNewXiuActiveTarget Parms{};

	Parms.PrevBestNPCTargetIn = PrevBestNPCTargetIn;
	Parms.NewBestNPCTargetIn = NewBestNPCTargetIn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.XiuActiveAbility.BP_OnLocalXiuActiveTargetSelected
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ANPCCharacter*                    SelectedTarget                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AXiuActiveAbility::BP_OnLocalXiuActiveTargetSelected(class ANPCCharacter* SelectedTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuActiveAbility", "BP_OnLocalXiuActiveTargetSelected");

	Params::XiuActiveAbility_BP_OnLocalXiuActiveTargetSelected Parms{};

	Parms.SelectedTarget = SelectedTarget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.XiuActiveAbility.BP_OnLocalXiuTravelEnd
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ANPCCharacter*                    TarvelToNPC                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AXiuActiveAbility::BP_OnLocalXiuTravelEnd(class ANPCCharacter* TarvelToNPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuActiveAbility", "BP_OnLocalXiuTravelEnd");

	Params::XiuActiveAbility_BP_OnLocalXiuTravelEnd Parms{};

	Parms.TarvelToNPC = TarvelToNPC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.XiuActiveAbility.BP_OnLocalXiuTravelStart
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ANPCCharacter*                    TarvelToNPC                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AXiuActiveAbility::BP_OnLocalXiuTravelStart(class ANPCCharacter* TarvelToNPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuActiveAbility", "BP_OnLocalXiuTravelStart");

	Params::XiuActiveAbility_BP_OnLocalXiuTravelStart Parms{};

	Parms.TarvelToNPC = TarvelToNPC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.XiuActiveAbility.BP_OnXiuTravelStart
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ANPCCharacter*                    PrevNPC                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANPCCharacter*                    TarvelToNPC                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AXiuActiveAbility::BP_OnXiuTravelStart(class ANPCCharacter* PrevNPC, class ANPCCharacter* TarvelToNPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuActiveAbility", "BP_OnXiuTravelStart");

	Params::XiuActiveAbility_BP_OnXiuTravelStart Parms{};

	Parms.PrevNPC = PrevNPC;
	Parms.TarvelToNPC = TarvelToNPC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.XiuActiveAbility.NetMulticast_OnTravelStart
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ANPCCharacter*                    PrevNPC                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANPCCharacter*                    TarvelToNPC                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AXiuActiveAbility::NetMulticast_OnTravelStart(class ANPCCharacter* PrevNPC, class ANPCCharacter* TarvelToNPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuActiveAbility", "NetMulticast_OnTravelStart");

	Params::XiuActiveAbility_NetMulticast_OnTravelStart Parms{};

	Parms.PrevNPC = PrevNPC;
	Parms.TarvelToNPC = TarvelToNPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.XiuActiveAbility.OnPostCompletedTimerEnd
// (Final, Native, Protected)

void AXiuActiveAbility::OnPostCompletedTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuActiveAbility", "OnPostCompletedTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.XiuActiveAbility.OnServerResetTargetNPC
// (Final, Native, Protected)

void AXiuActiveAbility::OnServerResetTargetNPC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuActiveAbility", "OnServerResetTargetNPC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.XiuActiveAbility.OnServerTravelEnd
// (Final, Native, Protected)

void AXiuActiveAbility::OnServerTravelEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuActiveAbility", "OnServerTravelEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.XiuActiveAbility.OnStoredTargetDeath
// (Final, Native, Protected)

void AXiuActiveAbility::OnStoredTargetDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuActiveAbility", "OnStoredTargetDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.XiuActiveAbility.OnStoredTargetDisguiseCoverBlown
// (Final, Native, Protected)

void AXiuActiveAbility::OnStoredTargetDisguiseCoverBlown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuActiveAbility", "OnStoredTargetDisguiseCoverBlown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.XiuActiveAbility.OnStoredTargetFellOutOfWorld
// (Final, Native, Protected)
// Parameters:
// class ANPCCharacter*                    NPCThatFell                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AXiuActiveAbility::OnStoredTargetFellOutOfWorld(class ANPCCharacter* NPCThatFell)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuActiveAbility", "OnStoredTargetFellOutOfWorld");

	Params::XiuActiveAbility_OnStoredTargetFellOutOfWorld Parms{};

	Parms.NPCThatFell = NPCThatFell;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.XiuActiveAbility.OnStoredTargetVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bNewVisibility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AXiuActiveAbility::OnStoredTargetVisibilityChanged(bool bNewVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuActiveAbility", "OnStoredTargetVisibilityChanged");

	Params::XiuActiveAbility_OnStoredTargetVisibilityChanged Parms{};

	Parms.bNewVisibility = bNewVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.XiuActiveAbility.Server_SetTarget
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class ANPCCharacter*                    NewTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AXiuActiveAbility::Server_SetTarget(class ANPCCharacter* NewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuActiveAbility", "Server_SetTarget");

	Params::XiuActiveAbility_Server_SetTarget Parms{};

	Parms.NewTarget = NewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.XiuActiveAbility.Server_StartTravel
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class ANPCCharacter*                    TravelToTarget                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AXiuActiveAbility::Server_StartTravel(class ANPCCharacter* TravelToTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuActiveAbility", "Server_StartTravel");

	Params::XiuActiveAbility_Server_StartTravel Parms{};

	Parms.TravelToTarget = TravelToTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.XiuActiveAbility.Server_TargetDecayed
// (Net, NetReliable, Native, Event, Protected, NetServer)

void AXiuActiveAbility::Server_TargetDecayed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuActiveAbility", "Server_TargetDecayed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.XiuPassiveAbility.BP_OnCoverBlownDetected
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          CoverBlownPosition                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AXiuPassiveAbility::BP_OnCoverBlownDetected(const struct FVector& CoverBlownPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuPassiveAbility", "BP_OnCoverBlownDetected");

	Params::XiuPassiveAbility_BP_OnCoverBlownDetected Parms{};

	Parms.CoverBlownPosition = std::move(CoverBlownPosition);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.XiuPassiveAbility.ClientSignalCoverBlownAtLocation
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// struct FVector_NetQuantize              CoverBlownPosition                                     (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AXiuPassiveAbility::ClientSignalCoverBlownAtLocation(const struct FVector_NetQuantize& CoverBlownPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuPassiveAbility", "ClientSignalCoverBlownAtLocation");

	Params::XiuPassiveAbility_ClientSignalCoverBlownAtLocation Parms{};

	Parms.CoverBlownPosition = std::move(CoverBlownPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.XiuPassiveAbility.HandleCoverBlownEvent
// (Final, Native, Protected)
// Parameters:
// class ASpy*                             Spy                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AXiuPassiveAbility::HandleCoverBlownEvent(class ASpy* Spy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuPassiveAbility", "HandleCoverBlownEvent");

	Params::XiuPassiveAbility_HandleCoverBlownEvent Parms{};

	Parms.Spy = Spy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.XiuPassiveAbilityMod2.BP_ShowSpys
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class ASpy*>                     Spys                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AXiuPassiveAbilityMod2::BP_ShowSpys(const TArray<class ASpy*>& Spys)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuPassiveAbilityMod2", "BP_ShowSpys");

	Params::XiuPassiveAbilityMod2_BP_ShowSpys Parms{};

	Parms.Spys = std::move(Spys);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeceiveInc.XiuPassiveAbilityMod2.GetTimeToShowPing
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AXiuPassiveAbilityMod2::GetTimeToShowPing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuPassiveAbilityMod2", "GetTimeToShowPing");

	Params::XiuPassiveAbilityMod2_GetTimeToShowPing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeceiveInc.XiuPassiveAbilityMod2.HandleExtractionStateChanged
// (Final, Native, Protected)

void AXiuPassiveAbilityMod2::HandleExtractionStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuPassiveAbilityMod2", "HandleExtractionStateChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.XiuPassiveAbilityMod2.HandleGamePhaseChanged
// (Final, Native, Protected)
// Parameters:
// ESpyGamePhase                           NewGamePhase                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AXiuPassiveAbilityMod2::HandleGamePhaseChanged(ESpyGamePhase NewGamePhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuPassiveAbilityMod2", "HandleGamePhaseChanged");

	Params::XiuPassiveAbilityMod2_HandleGamePhaseChanged Parms{};

	Parms.NewGamePhase = NewGamePhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.XiuPassiveAbilityMod2.HandleVaultTerminalDeactivation
// (Final, Native, Protected)
// Parameters:
// class ADIPlayerState*                   PlayerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FactionID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AXiuPassiveAbilityMod2::HandleVaultTerminalDeactivation(class ADIPlayerState* PlayerState, int32 FactionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuPassiveAbilityMod2", "HandleVaultTerminalDeactivation");

	Params::XiuPassiveAbilityMod2_HandleVaultTerminalDeactivation Parms{};

	Parms.PlayerState = PlayerState;
	Parms.FactionID = FactionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.XiuPassiveAbilityMod2.HandleVaultTerminalUnlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   UnlockValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AXiuPassiveAbilityMod2::HandleVaultTerminalUnlock(float UnlockValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XiuPassiveAbilityMod2", "HandleVaultTerminalUnlock");

	Params::XiuPassiveAbilityMod2_HandleVaultTerminalUnlock Parms{};

	Parms.UnlockValue = UnlockValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.YumiActiveAbility.HandleDelayedPowerDeactivationRequest
// (Final, Native, Protected)

void AYumiActiveAbility::HandleDelayedPowerDeactivationRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YumiActiveAbility", "HandleDelayedPowerDeactivationRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.YumiActiveAbility.HandleProjectileReleased
// (Final, Native, Protected)
// Parameters:
// class ASpawnerWeapon*                   Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASpawnerWeaponRound*              Projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AYumiActiveAbility::HandleProjectileReleased(class ASpawnerWeapon* Weapon, class ASpawnerWeaponRound* Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YumiActiveAbility", "HandleProjectileReleased");

	Params::YumiActiveAbility_HandleProjectileReleased Parms{};

	Parms.Weapon = Weapon;
	Parms.Projectile = Projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.YumiActiveAbility.HandleResourceAmountChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   TotalBulletLeft                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AYumiActiveAbility::HandleResourceAmountChanged(int32 TotalBulletLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YumiActiveAbility", "HandleResourceAmountChanged");

	Params::YumiActiveAbility_HandleResourceAmountChanged Parms{};

	Parms.TotalBulletLeft = TotalBulletLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.YumiActiveAbility.OnLoadoutSpawnComplete
// (Final, Native, Protected)
// Parameters:
// class UToolLoadoutComponent*            ToolLoadout                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AYumiActiveAbility::OnLoadoutSpawnComplete(class UToolLoadoutComponent* ToolLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YumiActiveAbility", "OnLoadoutSpawnComplete");

	Params::YumiActiveAbility_OnLoadoutSpawnComplete Parms{};

	Parms.ToolLoadout = ToolLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.YumiActiveAbility.OnProjectileLifeTimeTimerEnd
// (Final, Native, Protected)

void AYumiActiveAbility::OnProjectileLifeTimeTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YumiActiveAbility", "OnProjectileLifeTimeTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.YumiActiveAbility.OnResourceChanged
// (Final, Native, Protected)
// Parameters:
// EGameplayResourcesType                  ResourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ResourceDisplayName                                    (Parm, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AYumiActiveAbility::OnResourceChanged(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YumiActiveAbility", "OnResourceChanged");

	Params::YumiActiveAbility_OnResourceChanged Parms{};

	Parms.ResourceType = ResourceType;
	Parms.ResourceDisplayName = std::move(ResourceDisplayName);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.YumiActiveAbility.TriggerEMPSphereEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ABaseSphereActor*                 SphereActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AYumiActiveAbility::TriggerEMPSphereEnd(class ABaseSphereActor* SphereActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YumiActiveAbility", "TriggerEMPSphereEnd");

	Params::YumiActiveAbility_TriggerEMPSphereEnd Parms{};

	Parms.SphereActor = SphereActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.YumiActiveAbility.TriggerEMPSphereStart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ABaseSphereActor*                 SphereActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AYumiActiveAbility::TriggerEMPSphereStart(class ABaseSphereActor* SphereActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YumiActiveAbility", "TriggerEMPSphereStart");

	Params::YumiActiveAbility_TriggerEMPSphereStart Parms{};

	Parms.SphereActor = SphereActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.YumiPassiveAbilityMod2.HandleHitConfirmed
// (Final, Native, Protected)
// Parameters:
// struct FHitConfirmData                  HitConfirmData                                         (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AYumiPassiveAbilityMod2::HandleHitConfirmed(const struct FHitConfirmData& HitConfirmData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YumiPassiveAbilityMod2", "HandleHitConfirmed");

	Params::YumiPassiveAbilityMod2_HandleHitConfirmed Parms{};

	Parms.HitConfirmData = std::move(HitConfirmData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.YumiPassiveAbilityMod2.HandleMeleeDamageConfirmed
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactPoint                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ChargeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageDone                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ResultingHealthPercentage                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHitType                                HitType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMeleeHitConfirmedData           HitConfirmedData                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AYumiPassiveAbilityMod2::HandleMeleeDamageConfirmed(class AActor* Victim, const struct FVector& ImpactPoint, int32 ChargeLevel, float DamageDone, float ResultingHealthPercentage, EHitType HitType, const struct FMeleeHitConfirmedData& HitConfirmedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YumiPassiveAbilityMod2", "HandleMeleeDamageConfirmed");

	Params::YumiPassiveAbilityMod2_HandleMeleeDamageConfirmed Parms{};

	Parms.Victim = Victim;
	Parms.ImpactPoint = std::move(ImpactPoint);
	Parms.ChargeLevel = ChargeLevel;
	Parms.DamageDone = DamageDone;
	Parms.ResultingHealthPercentage = ResultingHealthPercentage;
	Parms.HitType = HitType;
	Parms.HitConfirmedData = std::move(HitConfirmedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.YumiPassiveAbilityMod2.HandleMiscToolSpawned
// (Final, Native, Protected)
// Parameters:
// class AActor*                           SpawnedTool                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AYumiPassiveAbilityMod2::HandleMiscToolSpawned(class AActor* SpawnedTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YumiPassiveAbilityMod2", "HandleMiscToolSpawned");

	Params::YumiPassiveAbilityMod2_HandleMiscToolSpawned Parms{};

	Parms.SpawnedTool = SpawnedTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.YumiPassiveAbilityMod2.HandlePlaceableSpawned
// (Final, Native, Protected)
// Parameters:
// class ABasePlaceable*                   NewPlaceable                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AYumiPassiveAbilityMod2::HandlePlaceableSpawned(class ABasePlaceable* NewPlaceable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YumiPassiveAbilityMod2", "HandlePlaceableSpawned");

	Params::YumiPassiveAbilityMod2_HandlePlaceableSpawned Parms{};

	Parms.NewPlaceable = NewPlaceable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.YumiPassiveAbilityMod2.HandleSpyToolLoadComplete
// (Final, Native, Protected)
// Parameters:
// class UToolLoadoutComponent*            ToolLoadout                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AYumiPassiveAbilityMod2::HandleSpyToolLoadComplete(class UToolLoadoutComponent* ToolLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YumiPassiveAbilityMod2", "HandleSpyToolLoadComplete");

	Params::YumiPassiveAbilityMod2_HandleSpyToolLoadComplete Parms{};

	Parms.ToolLoadout = ToolLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.YumiPassiveAbilityMod2.OnPlaceableDeath
// (Final, Native, Protected)
// Parameters:
// class AActor*                           DeadActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AYumiPassiveAbilityMod2::OnPlaceableDeath(class AActor* DeadActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("YumiPassiveAbilityMod2", "OnPlaceableDeath");

	Params::YumiPassiveAbilityMod2_OnPlaceableDeath Parms{};

	Parms.DeadActor = DeadActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ZoomComponent.AddZoomModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ModifierName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ZoomFactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpolationTime                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UZoomComponent::AddZoomModifier(class FName ModifierName, float ZoomFactor, float InterpolationTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZoomComponent", "AddZoomModifier");

	Params::ZoomComponent_AddZoomModifier Parms{};

	Parms.ModifierName = ModifierName;
	Parms.ZoomFactor = ZoomFactor;
	Parms.InterpolationTime = InterpolationTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ZoomComponent.AddZoomModifier3P
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ModifierName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ZoomFactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpolationTime                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UZoomComponent::AddZoomModifier3P(class FName ModifierName, float ZoomFactor, float InterpolationTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZoomComponent", "AddZoomModifier3P");

	Params::ZoomComponent_AddZoomModifier3P Parms{};

	Parms.ModifierName = ModifierName;
	Parms.ZoomFactor = ZoomFactor;
	Parms.InterpolationTime = InterpolationTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ZoomComponent.HandleIntPlayerSettingChange
// (Final, Native, Protected)
// Parameters:
// EPlayerSettingsType                     SettingType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UZoomComponent::HandleIntPlayerSettingChange(EPlayerSettingsType SettingType, int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZoomComponent", "HandleIntPlayerSettingChange");

	Params::ZoomComponent_HandleIntPlayerSettingChange Parms{};

	Parms.SettingType = SettingType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ZoomComponent.RemoveZoomModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ModifierName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpolationTime                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UZoomComponent::RemoveZoomModifier(class FName ModifierName, float InterpolationTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZoomComponent", "RemoveZoomModifier");

	Params::ZoomComponent_RemoveZoomModifier Parms{};

	Parms.ModifierName = ModifierName;
	Parms.InterpolationTime = InterpolationTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeceiveInc.ZoomComponent.RemoveZoomModifier3P
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ModifierName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpolationTime                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UZoomComponent::RemoveZoomModifier3P(class FName ModifierName, float InterpolationTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZoomComponent", "RemoveZoomModifier3P");

	Params::ZoomComponent_RemoveZoomModifier3P Parms{};

	Parms.ModifierName = ModifierName;
	Parms.InterpolationTime = InterpolationTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

