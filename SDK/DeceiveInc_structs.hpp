#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DeceiveInc

#include "Basic.hpp"

#include "InputCore_structs.hpp"
#include "Engine_structs.hpp"
#include "SlateCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "AnimGraphRuntime_structs.hpp"


namespace SDK
{

// Enum DeceiveInc.EBotActionResult
// NumValues: 0x0004
enum class EBotActionResult : uint8
{
	Completed                                = 0,
	Failed                                   = 1,
	Canceled                                 = 2,
	EBotActionResult_MAX                     = 3,
};

// Enum DeceiveInc.ESpyToolEvent
// NumValues: 0x002D
enum class ESpyToolEvent : uint8
{
	PrimaryInputBegin                        = 0,
	PrimaryInputEnd                          = 1,
	PrimaryInputFailed                       = 2,
	SecondaryInputBegin                      = 3,
	SecondaryInputEnd                        = 4,
	SecondaryInputFailed                     = 5,
	RecycleInputBegin                        = 6,
	RecycleInputEnd                          = 7,
	Shot                                     = 8,
	ShotFailed                               = 9,
	ReloadStarted                            = 10,
	ReloadCompleted                          = 11,
	ReloadAborted                            = 12,
	ActiveAbilityStart                       = 13,
	ActiveAbilityEnd                         = 14,
	SwitchTo                                 = 15,
	SwitchAway                               = 16,
	SecondaryWeaponShot                      = 17,
	SecondaryWeaponShotFailed                = 18,
	HoldingShot                              = 19,
	AbortedShot                              = 20,
	ADSBegin                                 = 21,
	ADSReached                               = 22,
	ADSEnd                                   = 23,
	SwitchAwayToPoudrier                     = 24,
	SwitchToFromPoudrier                     = 25,
	ActiveAbilityEffect                      = 26,
	PrimaryGadgetUseStart                    = 27,
	PrimaryGadgetUseEnd                      = 28,
	SecondaryGadgetUseStart                  = 29,
	SecondaryGadgetUseEnd                    = 30,
	ActiveAbilityFail                        = 31,
	ActiveAbilityOutro                       = 32,
	MeleeWeaponChargeBegin                   = 33,
	MeleeWeaponChargeLevelChange             = 34,
	MeleeWeaponImpulse                       = 35,
	MeleeWeaponImpulseEnd                    = 36,
	MeleeWeaponAttack                        = 37,
	MeleeWeaponCancel                        = 38,
	OverheatStarted                          = 39,
	OverheatEnd                              = 40,
	BurstFirstShot                           = 41,
	ToolRequest1PCameraStart                 = 42,
	ToolRequest1PCameraEnd                   = 43,
	ESpyToolEvent_MAX                        = 44,
};

// Enum DeceiveInc.EVisibilityMode
// NumValues: 0x0004
enum class EVisibilityMode : uint8
{
	FirstPerson                              = 0,
	ThirdPerson                              = 1,
	Hidden                                   = 2,
	EVisibilityMode_MAX                      = 3,
};

// Enum DeceiveInc.ELoadoutSlot
// NumValues: 0x000F
enum class ELoadoutSlot : uint8
{
	Weapon                                   = 0,
	Gadget1                                  = 1,
	Gadget2                                  = 2,
	Active                                   = 3,
	NavMode                                  = 4,
	SecondaryWeapon                          = 5,
	CallingCard                              = 6,
	TemporaryTool                            = 7,
	Passive                                  = 8,
	Melee                                    = 9,
	Count                                    = 10,
	Invalid                                  = 10,
	First_User_Selectable_Slot               = 0,
	Last_User_Selectable_Slot                = 2,
	ELoadoutSlot_MAX                         = 11,
};

// Enum DeceiveInc.ESpyMeleeAttackEvent
// NumValues: 0x0009
enum class ESpyMeleeAttackEvent : uint8
{
	ChargeBegin                              = 0,
	ChargeLevelChange                        = 1,
	Impulse                                  = 2,
	Attack                                   = 3,
	Cancel                                   = 4,
	ImpulseEnd                               = 5,
	AttackReset                              = 6,
	FullyCharge                              = 7,
	ESpyMeleeAttackEvent_MAX                 = 8,
};

// Enum DeceiveInc.EPlayerSettingsType
// NumValues: 0x008D
enum class EPlayerSettingsType : uint8
{
	None                                     = 0,
	Separator_AllPlatforms                   = 1,
	Separator_PCOnly                         = 2,
	Separator_ConsoleOnly                    = 3,
	Separator_XSXOnly                        = 4,
	Separator_PS5Only                        = 5,
	Separator_WindowsOnly                    = 6,
	Separator_LinuxOnly                      = 7,
	General_Language                         = 8,
	General_AudioLanguage                    = 9,
	General_MaxFramerate                     = 10,
	General_NetworkInfoDisplay               = 11,
	General_EnableCrossplayXbox              = 12,
	General_EnableCrossplayPS5               = 13,
	General_GameplayTips                     = 14,
	General_RazerChroma                      = 15,
	General_RazerChromaKeyMappings           = 16,
	General_HidePlayerNameFromOpponents      = 17,
	General_HideAllPlayerNames               = 18,
	General_HideMapName                      = 19,
	General_EnableSubtitles                  = 20,
	General_MatchmakingPreference            = 21,
	General_MatchmakingEnableBeginnerQueues  = 22,
	General_ProfilePrivacyPreference         = 23,
	General_EnableKillcam                    = 24,
	General_MatchmakingDelayType             = 25,
	General_MatchmakingDelay                 = 26,
	General_MatchmakingDelayRandomMax        = 27,
	General_ShowSpectatingPlayerLevel        = 28,
	General_ACTION_LinkTwitchAccount         = 29,
	General_ACTION_ResetToDefaults           = 30,
	General_ReduceMotionSickness             = 31,
	Controls_MouseLook_VerticalSensitivity   = 32,
	Controls_MouseLook_HorizontalSensitivity = 33,
	Controls_GamepadLook_VerticalSensitivity = 34,
	Controls_GamepadLook_HorizontalSensitivity = 35,
	Controls_MouseLook_ADSVerticalSensitivity = 36,
	Controls_MouseLook_ADSHorizontalSensitivity = 37,
	Controls_GamepadLook_ADSVerticalSensitivity = 38,
	Controls_GamepadLook_ADSHorizontalSensitivity = 39,
	Controls_MouseLook_NavVerticalSensitivity = 40,
	Controls_MouseLook_NavHorizontalSensitivity = 41,
	Controls_GamepadLook_NavVerticalSensitivity = 42,
	Controls_GamepadLook_NavHorizontalSensitivity = 43,
	Controls_MouseLook_SpectateVerticalSensitivity = 44,
	Controls_MouseLook_SpectateHorizontalSensitivity = 45,
	Controls_GamepadLook_SpectateVerticalSensitivity = 46,
	Controls_GamepadLook_SpectateHorizontalSensitivity = 47,
	Controls_GamepadMenu_CursorSensitivity   = 48,
	Controls_GamepadMenu_ScrollSensitivity   = 49,
	Controls_GamepadAimAssist                = 50,
	Controls_GamepadAimAssist_InfluenceTargetType = 51,
	Controls_GamepadAimAssist_InfluenceStrength_Hipfire = 52,
	Controls_GamepadAimAssist_InfluenceStrength_ADS = 53,
	Controls_GamepadAcceleration_VerticalFactor = 54,
	Controls_GamepadAcceleration_VerticalInterpolationTime = 55,
	Controls_GamepadAcceleration_HorizontalFactor = 56,
	Controls_GamepadAcceleration_HorizontalInterpolationTime = 57,
	Controls_InversePitch                    = 58,
	Controls_Run_Toggle                      = 59,
	Controls_Crouch_Toggle                   = 60,
	Controls_Navmode_Toggle                  = 61,
	Controls_Interact_Toggle                 = 62,
	Controls_ADS_Toggle                      = 63,
	Controls_FirstAid_Toggle                 = 64,
	Controls_ContinuousFireOnHold            = 65,
	Controls_EnableVibration                 = 66,
	Controls_VibrationScale                  = 67,
	Controls_ACTION_Keybindings              = 68,
	Controls_ACTION_Gamepadbindings          = 69,
	Controls_ACTION_Gamepadbindings_PS5      = 70,
	Controls_ACTION_ResetToDefaults          = 71,
	Audio_Master_Volume                      = 72,
	Audio_Music_Volume                       = 73,
	Audio_SFX_Volume                         = 74,
	Audio_Voice_Volume                       = 75,
	Audio_Ambient_Volume                     = 76,
	Audio_UI_Volume                          = 77,
	Audio_VoiceChat_Volume                   = 78,
	Audio_VoiceChat_MicrophoneVolume         = 79,
	Audio_VoiceChat_InputThreshold           = 80,
	Audio_Controller_Volume                  = 81,
	Audio_VoiceChat_PushToTalk               = 82,
	Audio_VoiceChat_Autojoin                 = 83,
	Audio_VoiceChat_Autojoin_Console         = 84,
	Audio_VoiceChat_InputDevice              = 85,
	Audio_VoiceChat_OutputDevice             = 86,
	Audio_LobbyMusic                         = 87,
	Audio_ACTION_ResetToDefaults             = 88,
	Graphics_Resolution                      = 89,
	Graphics_Preset                          = 90,
	Graphics_VSYNC                           = 91,
	Graphics_RenderType                      = 92,
	Graphics_FOV                             = 93,
	Graphics_ResolutionScale                 = 94,
	Graphics_HDR                             = 95,
	Graphics_StaticPortrait                  = 96,
	Graphics_ColorblindMode                  = 97,
	Graphics_ColorblindIntensity             = 98,
	Graphics_Advanced_ViewDistanceQuality    = 99,
	Graphics_Advanced_ShadowQuality          = 100,
	Graphics_Advanced_AntiAliasingQuality    = 101,
	Graphics_Advanced_TextureQuality         = 102,
	Graphics_Advanced_VisualEffectQuality    = 103,
	Graphics_Advanced_PostProcessingQuality  = 104,
	Graphics_Advanced_FoliageQuality         = 105,
	Graphics_Advanced_ShadingQuality         = 106,
	Graphics_DLSS_Enabled                    = 107,
	Graphics_DLSS_Quality                    = 108,
	Graphics_DLSS_Quality_Key                = 109,
	Graphics_XeSS_Enabled                    = 110,
	Graphics_XeSS_Quality                    = 111,
	Graphics_XeSS_Quality_Key                = 112,
	Graphics_DX12_Enabled                    = 113,
	Graphics_Crosshairs_RGBAColor            = 114,
	Graphics_Crosshairs_Scale                = 115,
	Graphics_Crosshairs_Type                 = 116,
	Graphics_ACTION_ResetToDefaults          = 117,
	Graphics_ACTION_AutodetectPreset         = 118,
	PrivateLobby_Bots_Difficulty             = 119,
	PrivateLobby_Bots_Amount                 = 120,
	PrivateLobby_NPC_Civilian                = 121,
	PrivateLobby_NPC_Staff                   = 122,
	PrivateLobby_NPC_Guard                   = 123,
	PrivateLobby_NPC_Technician              = 124,
	PrivateLobby_NPC_EliteGuard              = 125,
	PrivateLobby_NPC_MetalDouglas            = 126,
	PrivateLobby_NPC_VIP                     = 127,
	PrivateLobby_Heat_NPCDamage_Civilian     = 128,
	PrivateLobby_Heat_NPCDamage_Staff        = 129,
	PrivateLobby_Heat_NPCDamage_Guard        = 130,
	PrivateLobby_Heat_NPCDamage_Technician   = 131,
	PrivateLobby_Heat_NPCDamage_VIP          = 132,
	PrivateLobby_Heat_ScoldHeatPerSecond     = 133,
	PrivateLobby_Heat_HeatDelayForSpyHit     = 134,
	PrivateLobby_Heat_HeatDelayPassiveGain   = 135,
	PrivateLobby_Heat_HeatDelayAggroPostCover = 136,
	PrivateLobby_Heat_DelayToDecay           = 137,
	PrivateLobby_Heat_DecayRate              = 138,
	PrivateLobby_ACTION_ResetToDefaults      = 139,
	EPlayerSettingsType_MAX                  = 140,
};

// Enum DeceiveInc.DIXPEvent
// NumValues: 0x002E
enum class EDIXPEvent : uint8
{
	None                                     = 0,
	Intel                                    = 1,
	Kill                                     = 2,
	Kill_10                                  = 3,
	Kill_20                                  = 4,
	Kill_50                                  = 5,
	Kill_100                                 = 6,
	Kill_200                                 = 7,
	Kill_300                                 = 8,
	Keycard_Green                            = 9,
	Keycard_Blue                             = 10,
	Keycard_Purple                           = 11,
	Keycard_Gold                             = 12,
	Powerup_Civilian                         = 13,
	Powerup_Green                            = 14,
	Powerup_Blue                             = 15,
	Powerup_Purple                           = 16,
	Powerup_Gold                             = 17,
	EnterVault                               = 18,
	FirstObjectivePickup                     = 19,
	PickupObjective                          = 20,
	Extract                                  = 21,
	VaultComputer                            = 22,
	MatchPlayed                              = 23,
	LastSpyStanding                          = 24,
	TeammateRevive                           = 25,
	SoloGameMode                             = 26,
	XpBooster                                = 27,
	DoubleXp                                 = 28,
	DoorUnlock                               = 29,
	ChestUnlock                              = 30,
	Lootable_XP                              = 31,
	Lootable_Bond                            = 32,
	Lootable_Credits                         = 33,
	PrivateLobby                             = 34,
	PrivateLobbySandbox                      = 35,
	PremadeTeam                              = 36,
	Catwalk                                  = 37,
	ReticalScanner                           = 38,
	LimitedEvent1                            = 39,
	LimitedEvent2                            = 40,
	LimitedEvent3                            = 41,
	LimitedEvent4                            = 42,
	LimitedEvent5                            = 43,
	Count                                    = 44,
	DIXPEvent_MAX                            = 45,
};

// Enum DeceiveInc.EGameplayResourcesType
// NumValues: 0x0044
enum class EGameplayResourcesType : uint8
{
	None                                     = 0,
	Ammo                                     = 1,
	Health                                   = 2,
	Intel                                    = 3,
	Keycard_Green                            = 4,
	Keycard_Blue                             = 5,
	Keycard_Purple                           = 6,
	Keycard_Orange                           = 7,
	Mission_Objective                        = 8,
	Charge_BouncingMat                       = 9,
	Charge_UmbrellaShield                    = 10,
	Charge_Turret                            = 11,
	Charge_Scrambler                         = 12,
	Charge_HackTrap                          = 13,
	Charge_Drone                             = 14,
	Charge_DroneDart                         = 15,
	Charge_GooPod                            = 16,
	Charge_Tripwire                          = 17,
	Charge_SpyGlass                          = 18,
	Charge_OcclusionGadget                   = 19,
	Charge_SoundMachine                      = 20,
	Charge_NPCBug                            = 21,
	Charge_Active                            = 22,
	Charge_HealthConsumable                  = 23,
	Charge_OverchargedNavmode                = 24,
	PowerupModule_Cover                      = 25,
	PowerupModule_Ammo                       = 26,
	PowerupModule_Intel                      = 27,
	PowerupModule_Hacking                    = 28,
	PowerupModule_Health                     = 29,
	PowerupModule_Expertise                  = 30,
	SmallAmmoBox                             = 31,
	DispenserAmmoBox                         = 32,
	CallingCard                              = 33,
	Kill                                     = 34,
	SpyCache                                 = 35,
	PowerupModuleLevel_Civilian              = 36,
	PowerupModuleLevel_Staff                 = 37,
	PowerupModuleLevel_Guard                 = 38,
	PowerupModuleLevel_Technician            = 39,
	PowerupModuleLevel_VIP                   = 40,
	Custom1                                  = 41,
	Custom2                                  = 42,
	Custom3                                  = 43,
	Custom4                                  = 44,
	Custom5                                  = 45,
	Custom6                                  = 46,
	Custom7                                  = 47,
	LimitedEvent1                            = 48,
	LimitedEvent2                            = 49,
	LimitedEvent3                            = 50,
	LimitedEvent4                            = 51,
	LimitedEvent5                            = 52,
	Pickup_Currency_Soft                     = 53,
	Pickup_Currency_Hard                     = 54,
	Pickup_XP                                = 55,
	Last_Value                               = 55,
	Keycard_First                            = 4,
	Keycard_Last                             = 7,
	Charge_First                             = 9,
	Charge_Last                              = 24,
	PowerupModuleLevel_First                 = 36,
	PowerupModuleLevel_Last                  = 40,
	Custom_First                             = 41,
	Custom_Last                              = 47,
	Pickup_First                             = 53,
	Pickup_Last                              = 55,
	EGameplayResourcesType_MAX               = 56,
};

// Enum DeceiveInc.EInteractableState
// NumValues: 0x0005
enum class EInteractableState : uint8
{
	State_Far                                = 0,
	State_Close                              = 1,
	State_InRange                            = 2,
	State_BASE                               = 3,
	State_MAX                                = 4,
};

// Enum DeceiveInc.EHitType
// NumValues: 0x000D
enum class EHitType : uint8
{
	None                                     = 0,
	Inanimate                                = 1,
	Limb                                     = 2,
	Body                                     = 3,
	Critical                                 = 4,
	DisguiseShieldLimb                       = 5,
	DisguiseShieldBody                       = 6,
	DisguiseShieldCritical                   = 7,
	DisguiseShield                           = 8,
	UmbrellaShield                           = 9,
	Invulnerable                             = 10,
	Miss                                     = 11,
	EHitType_MAX                             = 12,
};

// Enum DeceiveInc.EGrabLootAnimation
// NumValues: 0x0005
enum class EGrabLootAnimation : uint8
{
	None                                     = 0,
	Keycard                                  = 1,
	LootableChip                             = 2,
	Objective                                = 3,
	EGrabLootAnimation_MAX                   = 4,
};

// Enum DeceiveInc.ESecurityLevel
// NumValues: 0x0007
enum class ESecurityLevel : uint8
{
	Civilian                                 = 0,
	Staff                                    = 1,
	Guard                                    = 2,
	Technician                               = 3,
	VIP                                      = 4,
	Count                                    = 5,
	ESecurityLevel_MAX                       = 6,
};

// Enum DeceiveInc.EPowerupType
// NumValues: 0x000D
enum class EPowerupType : uint8
{
	Cover                                    = 0,
	Ammo                                     = 1,
	Intel                                    = 2,
	Hacking                                  = 3,
	Health                                   = 4,
	Expertise                                = 5,
	SocialBattery                            = 6,
	Foodie                                   = 7,
	Exfiltrator                              = 8,
	Count                                    = 9,
	First                                    = 0,
	Last                                     = 8,
	EPowerupType_MAX                         = 10,
};

// Enum DeceiveInc.EDiSpyHurt3PDirection
// NumValues: 0x0005
enum class EDiSpyHurt3PDirection : uint8
{
	Front                                    = 0,
	Right                                    = 1,
	Back                                     = 2,
	Left                                     = 3,
	EDiSpyHurt3PDirection_MAX                = 4,
};

// Enum DeceiveInc.ECoverAffectingSourceType
// NumValues: 0x0008
enum class ECoverAffectingSourceType : uint8
{
	None                                     = 0,
	Aggro                                    = 1,
	Esposed                                  = 2,
	EMP                                      = 3,
	Tripwire                                 = 4,
	Running                                  = 5,
	Count                                    = 6,
	ECoverAffectingSourceType_MAX            = 7,
};

// Enum DeceiveInc.ESpyMovementState
// NumValues: 0x0005
enum class ESpyMovementState : uint8
{
	Idle                                     = 0,
	Walk                                     = 1,
	Run                                      = 2,
	Airborne                                 = 3,
	ESpyMovementState_MAX                    = 4,
};

// Enum DeceiveInc.ESpyHealthConsumableEvent
// NumValues: 0x0007
enum class ESpyHealthConsumableEvent : uint8
{
	HealthConsumableBegin                    = 0,
	HealthConsumableEnd                      = 1,
	HealthConsumableFailed                   = 2,
	HealthConsumableCancelRequest            = 3,
	HealthConsumableCancelTriggered          = 4,
	HealthConsumable_Invalid                 = 5,
	ESpyHealthConsumableEvent_MAX            = 6,
};

// Enum DeceiveInc.EBlockLeftHandFavorAnimationsBlueprintType
// NumValues: 0x0004
enum class EBlockLeftHandFavorAnimationsBlueprintType : uint8
{
	Generic                                  = 0,
	Charging                                 = 1,
	Count                                    = 2,
	EBlockLeftHandFavorAnimationsBlueprintType_MAX = 3,
};

// Enum DeceiveInc.EInteractableType
// NumValues: 0x002B
enum class EInteractableType : uint8
{
	Invalid                                  = 0,
	IntelSource                              = 1,
	KeyCard                                  = 2,
	Ammo                                     = 3,
	NPC                                      = 4,
	Spy                                      = 5,
	Door                                     = 6,
	HackableDoor                             = 7,
	Container                                = 8,
	Chest                                    = 9,
	StrongBox                                = 10,
	PowerupModule                            = 11,
	SpyCache                                 = 12,
	Objective                                = 13,
	Extraction                               = 14,
	VaultTerminal                            = 15,
	ObjectiveTerminal                        = 16,
	Furniture                                = 17,
	AmmoDispenser                            = 18,
	HealthDispenser                          = 19,
	Social                                   = 20,
	PickableTool                             = 21,
	Pickable_HardCurrency                    = 22,
	Pickable_SoftCurrency                    = 23,
	Pickable_XP                              = 24,
	Breadcrumb                               = 25,
	Consumable                               = 26,
	Deployable_BounceMat                     = 27,
	Deployable_Turret                        = 28,
	Deployable_Drone                         = 29,
	Deployable_Goopod                        = 30,
	Deployable_Tripwire                      = 31,
	Deployable_Scrambler                     = 32,
	Deployable_SoundMachine                  = 33,
	Environment_WindowShutter                = 34,
	Environment_ElevatorCallButton           = 35,
	KeycardPrinter                           = 36,
	LostAndFound                             = 37,
	HealthConsumable                         = 38,
	HealthConsumableDispenser                = 39,
	RetinalScanner                           = 40,
	Count                                    = 41,
	EInteractableType_MAX                    = 42,
};

// Enum DeceiveInc.EPlatformType
// NumValues: 0x0005
enum class EPlatformType : uint8
{
	PC                                       = 0,
	Xbox                                     = 1,
	PS                                       = 2,
	Count                                    = 3,
	EPlatformType_MAX                        = 4,
};

// Enum DeceiveInc.CameraPriority
// NumValues: 0x0022
enum class ECameraPriority : uint8
{
	Code_Lowest                              = 0,
	Design_Lowest                            = 1,
	Code_FirstPerson                         = 2,
	LD_FirstPerson                           = 3,
	Code_OverFirstPerson                     = 4,
	LD_OverFirstPerson                       = 5,
	Code_3rdPerson                           = 6,
	LD_3rdPerson                             = 7,
	Code_SecurityCamera                      = 8,
	LD_SecurityCamera                        = 9,
	Code_Gadget3rdPerson                     = 10,
	LD_Gadget3rdPerson                       = 11,
	Code_Ability                             = 12,
	LD_Ability                               = 13,
	Code_Gadget                              = 14,
	LD_Gadget                                = 15,
	Code_Spectator                           = 16,
	LD_Spectator                             = 17,
	Code_CameraTravel                        = 18,
	LD_CameraTravel                          = 19,
	Code_Map                                 = 20,
	LD_Map                                   = 21,
	Code_Menu                                = 22,
	LD_Menu                                  = 23,
	Code_OverMenu                            = 24,
	LD_OverMenu                              = 25,
	Code_OverOverMenu                        = 26,
	LD_OverOverMenu                          = 27,
	Code_GadgetHide1PAnd3P                   = 28,
	LD_GadgetHide1PAnd3P                     = 29,
	Code_DebugFreeCam                        = 30,
	Count                                    = 31,
	Invalid                                  = 31,
	CameraPriority_MAX                       = 32,
};

// Enum DeceiveInc.ESpySecurityState
// NumValues: 0x0005
enum class ESpySecurityState : uint8
{
	None                                     = 0,
	Scolded                                  = 1,
	Investigated                             = 2,
	LineOfSightFromAggroed                   = 3,
	ESpySecurityState_MAX                    = 4,
};

// Enum DeceiveInc.EHandToolVisibilityFromAnimationFlag
// NumValues: 0x0006
enum class EHandToolVisibilityFromAnimationFlag : uint8
{
	GenericAnimation                         = 0,
	Interaction                              = 1,
	Melee                                    = 2,
	ActiveAbility                            = 3,
	NoAmmoInMagazine                         = 4,
	EHandToolVisibilityFromAnimationFlag_MAX = 5,
};

// Enum DeceiveInc.EDIGameMode
// NumValues: 0x000C
enum class EDIGameMode : uint8
{
	None                                     = 0,
	CustomMatch                              = 1,
	Solo                                     = 2,
	Duo                                      = 3,
	Trio                                     = 4,
	Tutorial                                 = 5,
	Training                                 = 6,
	PrivateLobby                             = 7,
	LimitedTime1                             = 8,
	LimitedTime2                             = 9,
	Count                                    = 10,
	EDIGameMode_MAX                          = 11,
};

// Enum DeceiveInc.EBotsDifficulty
// NumValues: 0x0005
enum class EBotsDifficulty : uint8
{
	Easy                                     = 0,
	Normal                                   = 1,
	Difficult                                = 2,
	Count                                    = 3,
	EBotsDifficulty_MAX                      = 4,
};

// Enum DeceiveInc.ESpyGamePhase
// NumValues: 0x000A
enum class ESpyGamePhase : uint8
{
	LOADING                                  = 0,
	PREGAME                                  = 1,
	POSING_SPY_INTRO                         = 2,
	VAULT_LOCKED                             = 3,
	VAULT_UNLOCKED                           = 4,
	EXTRACTION_ARRIVING                      = 5,
	EXTRACTION_ARRIVED                       = 6,
	RESULT_SCREEN                            = 7,
	GAME_FINISHED                            = 8,
	ESpyGamePhase_MAX                        = 9,
};

// Enum DeceiveInc.EMatchResult
// NumValues: 0x0007
enum class EMatchResult : uint8
{
	Invalid                                  = 0,
	MissionSucess_ObjectiveExtracted         = 1,
	MissionSucess_LastManStanding            = 2,
	MissionFailed_NoAgentsLeft               = 3,
	MissionFailed_TimeOut                    = 4,
	Count                                    = 5,
	EMatchResult_MAX                         = 6,
};

// Enum DeceiveInc.EInteractCancelType
// NumValues: 0x0004
enum class EInteractCancelType : uint8
{
	DamageReceived                           = 0,
	ShotFired                                = 1,
	Count                                    = 2,
	EInteractCancelType_MAX                  = 3,
};

// Enum DeceiveInc.EMovementEventType
// NumValues: 0x0006
enum class EMovementEventType : uint8
{
	None                                     = 0,
	Jump                                     = 1,
	CrouchBegin                              = 2,
	CrouchEnd                                = 3,
	Count                                    = 4,
	EMovementEventType_MAX                   = 5,
};

// Enum DeceiveInc.EWeaponAmmoState
// NumValues: 0x0004
enum class EWeaponAmmoState : uint8
{
	LowAmmo                                  = 0,
	Normal                                   = 1,
	FullAmmo                                 = 2,
	EWeaponAmmoState_MAX                     = 3,
};

// Enum DeceiveInc.EMatchmakingError
// NumValues: 0x0007
enum class EMatchmakingError : uint8
{
	NONE                                     = 0,
	Failed                                   = 1,
	ErrorReachingService                     = 2,
	LeaderCanceled                           = 3,
	TimedOut                                 = 4,
	InvalidTicket                            = 5,
	EMatchmakingError_MAX                    = 6,
};

// Enum DeceiveInc.EDescribeMatchmakingStatus
// NumValues: 0x0009
enum class EDescribeMatchmakingStatus : uint8
{
	NONE                                     = 0,
	STATUS_STARTING                          = 1,
	STATUS_SEARCHING                         = 2,
	STATUS_COMPLETED                         = 3,
	STATUS_PLACING                           = 4,
	STATUS_FAILED                            = 5,
	STATUS_CANCELLED                         = 6,
	STATUS_TIMED_OUT                         = 7,
	EDescribeMatchmakingStatus_MAX           = 8,
};

// Enum DeceiveInc.EInputDeviceType
// NumValues: 0x0006
enum class EInputDeviceType : uint8
{
	Any                                      = 0,
	LastUsed                                 = 1,
	KeyboardAndMouse                         = 2,
	Gamepad                                  = 3,
	Count                                    = 4,
	EInputDeviceType_MAX                     = 5,
};

// Enum DeceiveInc.EClientConfigVersion
// NumValues: 0x000A
enum class EClientConfigVersion : uint8
{
	Undefined                                = 0,
	Catalog3                                 = 1,
	TU5_CombatUpdate                         = 2,
	JatimaniaEvent                           = 3,
	Catalog4                                 = 4,
	BackToSchool                             = 5,
	Catalog5                                 = 6,
	Count                                    = 7,
	CurrentVersion                           = 6,
	EClientConfigVersion_MAX                 = 8,
};

// Enum DeceiveInc.ELocalizationLanguage
// NumValues: 0x000B
enum class ELocalizationLanguage : uint8
{
	NONE                                     = 0,
	English                                  = 1,
	French                                   = 2,
	German                                   = 3,
	Spanish                                  = 4,
	Korean                                   = 5,
	Japanese                                 = 6,
	Russian                                  = 7,
	Chinese_Traditional                      = 8,
	Chinese_Simplified                       = 9,
	ELocalizationLanguage_MAX                = 10,
};

// Enum DeceiveInc.ESpecialAnnouncementType
// NumValues: 0x0004
enum class ESpecialAnnouncementType : uint8
{
	NONE                                     = 0,
	ShowOnStartOnly                          = 1,
	ShowOnEveryMainMenuVisit                 = 2,
	ESpecialAnnouncementType_MAX             = 3,
};

// Enum DeceiveInc.EAvaliableFeatureLevel
// NumValues: 0x000B
enum class EAvaliableFeatureLevel : uint8
{
	Catalog2                                 = 0,
	PrivateLobbies                           = 1,
	Catalog3                                 = 2,
	HolidayEvent2023                         = 3,
	Catalog4                                 = 4,
	NewDeceptionGadget                       = 5,
	NewReconGadget                           = 6,
	Catalog5                                 = 7,
	Unrestricted                             = 8,
	CurrentDefault                           = 7,
	EAvaliableFeatureLevel_MAX               = 9,
};

// Enum DeceiveInc.EDIGameRuleset
// NumValues: 0x0017
enum class EDIGameRuleset : uint8
{
	None                                     = 0,
	Default                                  = 1,
	LTM1                                     = 2,
	LTM2                                     = 3,
	CustomMatch                              = 4,
	Solo                                     = 5,
	Duo                                      = 6,
	Trio                                     = 7,
	Tutorial                                 = 8,
	Training                                 = 9,
	PrivateLobby                             = 10,
	Custom1                                  = 11,
	Custom2                                  = 12,
	Custom3                                  = 13,
	Custom4                                  = 14,
	Custom5                                  = 15,
	Custom6                                  = 16,
	Custom7                                  = 17,
	Custom8                                  = 18,
	Custom9                                  = 19,
	Count                                    = 20,
	Active                                   = 21,
	EDIGameRuleset_MAX                       = 22,
};

// Enum DeceiveInc.EInteractionIconState
// NumValues: 0x0007
enum class EInteractionIconState : uint8
{
	Hidden                                   = 0,
	CloseEnoughToSee                         = 1,
	Focused                                  = 2,
	CantInteract                             = 3,
	Interacting                              = 4,
	Complete                                 = 5,
	EInteractionIconState_MAX                = 6,
};

// Enum DeceiveInc.EAnnouncementGroup
// NumValues: 0x0004
enum class EAnnouncementGroup : uint8
{
	Announcement                             = 0,
	Notification                             = 1,
	Count                                    = 2,
	EAnnouncementGroup_MAX                   = 3,
};

// Enum DeceiveInc.EAnnouncementType
// NumValues: 0x001D
enum class EAnnouncementType : uint8
{
	Announcement                             = 0,
	TwitchEvent                              = 1,
	HuntedByAce                              = 2,
	HackTrapped                              = 3,
	ChasedByCavaliere                        = 4,
	Droned                                   = 5,
	StuckByVigil                             = 6,
	Bugged                                   = 7,
	Custom_01                                = 8,
	Custom_02                                = 9,
	Custom_03                                = 10,
	Custom_04                                = 11,
	Custom_05                                = 12,
	Custom_06                                = 13,
	Custom_07                                = 14,
	Custom_08                                = 15,
	Custom_09                                = 16,
	Custom_10                                = 17,
	Custom_11                                = 18,
	Custom_12                                = 19,
	Custom_13                                = 20,
	Custom_14                                = 21,
	Custom_15                                = 22,
	Custom_16                                = 23,
	Custom_17                                = 24,
	Custom_18                                = 25,
	Custom_19                                = 26,
	Custom_20                                = 27,
	EAnnouncementType_MAX                    = 28,
};

// Enum DeceiveInc.EScoldState
// NumValues: 0x0004
enum class EScoldState : uint8
{
	None                                     = 0,
	Scolding                                 = 1,
	Investigating                            = 2,
	EScoldState_MAX                          = 3,
};

// Enum DeceiveInc.ENPCMainAnimation
// NumValues: 0x000C
enum class ENPCMainAnimation : uint8
{
	GroundMove                               = 0,
	Jump                                     = 1,
	Fall                                     = 2,
	Dead                                     = 3,
	Crouched                                 = 4,
	Interacting                              = 5,
	Resurrect                                = 6,
	OpenDrawer                               = 7,
	CloseDrawer                              = 8,
	Listening                                = 9,
	Talking                                  = 10,
	ENPCMainAnimation_MAX                    = 11,
};

// Enum DeceiveInc.ENPCUpperBodyBoneGroup
// NumValues: 0x0004
enum class ENPCUpperBodyBoneGroup : uint8
{
	SpineAndUp                               = 0,
	RightArmAndHead                          = 1,
	FullBody                                 = 2,
	ENPCUpperBodyBoneGroup_MAX               = 3,
};

// Enum DeceiveInc.ENPCWalkDirection
// NumValues: 0x0005
enum class ENPCWalkDirection : uint8
{
	Forward                                  = 0,
	Right                                    = 1,
	Back                                     = 2,
	Left                                     = 3,
	ENPCWalkDirection_MAX                    = 4,
};

// Enum DeceiveInc.ENPCScaredReason
// NumValues: 0x0003
enum class ENPCScaredReason : uint8
{
	DangerEvent                              = 0,
	OngoingFightInRoom                       = 1,
	ENPCScaredReason_MAX                     = 2,
};

// Enum DeceiveInc.ECallingCardPosition
// NumValues: 0x0006
enum class ECallingCardPosition : uint8
{
	North                                    = 0,
	East                                     = 1,
	South                                    = 2,
	West                                     = 3,
	Count                                    = 4,
	ECallingCardPosition_MAX                 = 5,
};

// Enum DeceiveInc.InvestigationType
// NumValues: 0x0005
enum class EInvestigationType : uint8
{
	None                                     = 0,
	Investigating                            = 1,
	Attacking                                = 2,
	LostTarget                               = 3,
	InvestigationType_MAX                    = 4,
};

// Enum DeceiveInc.InvestigationState
// NumValues: 0x0008
enum class EInvestigationState : uint8
{
	AggroIntro                               = 0,
	Idle                                     = 1,
	Shooting                                 = 2,
	Melee                                    = 3,
	LostTarget                               = 4,
	GiveUp                                   = 5,
	AttackStatesStart                        = 2,
	InvestigationState_MAX                   = 6,
};

// Enum DeceiveInc.ESelectionValidationResult
// NumValues: 0x0006
enum class ESelectionValidationResult : uint8
{
	Success                                  = 0,
	InvalidSelection                         = 1,
	AgentUnavailable                         = 2,
	TeammateSelection                        = 3,
	Count                                    = 4,
	ESelectionValidationResult_MAX           = 5,
};

// Enum DeceiveInc.EDIITemTypeQuery
// NumValues: 0x0004
enum class EDIITemTypeQuery : uint8
{
	Skins                                    = 0,
	IntroPose                                = 1,
	Inks                                     = 2,
	EDIITemTypeQuery_MAX                     = 3,
};

// Enum DeceiveInc.ERemoteTurretAIState
// NumValues: 0x0008
enum class ERemoteTurretAIState : uint8
{
	Deploying                                = 0,
	Searching                                = 1,
	Charging                                 = 2,
	Shooting                                 = 3,
	TargetLost                               = 4,
	Deactivating                             = 5,
	Count                                    = 6,
	ERemoteTurretAIState_MAX                 = 7,
};

// Enum DeceiveInc.EDSState
// NumValues: 0x0008
enum class EDSState : uint8
{
	NONE                                     = 0,
	Registering                              = 1,
	Registered                               = 2,
	Claimed                                  = 3,
	InEnqueue                                = 4,
	SessionFull                              = 5,
	Deregistered                             = 6,
	EDSState_MAX                             = 7,
};

// Enum DeceiveInc.EActorAffectedType
// NumValues: 0x0004
enum class EActorAffectedType : uint8
{
	None                                     = 0,
	EMP                                      = 1,
	Scrambler                                = 2,
	EActorAffectedType_MAX                   = 3,
};

// Enum DeceiveInc.EDSAMSState
// NumValues: 0x0008
enum class EDSAMSState : uint8
{
	NONE                                     = 0,
	Creating                                 = 1,
	Ready                                    = 2,
	Claimed                                  = 3,
	Drain                                    = 4,
	Unregister                               = 5,
	Removed                                  = 6,
	EDSAMSState_MAX                          = 7,
};

// Enum DeceiveInc.EAoEShapeType
// NumValues: 0x0005
enum class EAoEShapeType : uint8
{
	Sphere                                   = 0,
	Capsule                                  = 1,
	Box                                      = 2,
	Cylinder                                 = 3,
	EAoEShapeType_MAX                        = 4,
};

// Enum DeceiveInc.EConditionType
// NumValues: 0x001F
enum class EConditionType : uint8
{
	Condition_Resource                       = 0,
	Condition_Unlock                         = 1,
	Condition_MaxUseCount                    = 2,
	Condition_RayCast                        = 3,
	Condition_Behind                         = 4,
	Condition_DisguiseAsNPC                  = 5,
	Condition_MaxResource                    = 6,
	Condition_Health                         = 7,
	Condition_PlayerOwned                    = 8,
	Condition_Extraction                     = 9,
	Condition_MimicSlice                     = 10,
	Condition_CoverLevel                     = 11,
	Condition_StatusEffect                   = 12,
	Condition_MaxHealth                      = 13,
	Condition_GamePhase                      = 14,
	Condition_ActiveAbility                  = 15,
	Condition_SecurityLevel                  = 16,
	Condition_Conversation                   = 17,
	Condition_InMimic                        = 18,
	Condition_Cooldown                       = 19,
	Condition_SingleUSer                     = 20,
	Condition_Undercover                     = 21,
	Condition_Team                           = 22,
	Condition_Poison                         = 23,
	Condition_ReviveTeam                     = 24,
	Condition_DoorClosed                     = 25,
	Condition_InSocialInteract               = 26,
	Condition_VaultOverride                  = 27,
	Condition_InNavmode                      = 28,
	Condition_Count                          = 29,
	Condition_MAX                            = 30,
};

// Enum DeceiveInc.EConditionRestrictions
// NumValues: 0x0004
enum class EConditionRestrictions : uint8
{
	AffectAll                                = 0,
	AffectInteractOnly                       = 1,
	AffectMimicScanOnly                      = 2,
	EConditionRestrictions_MAX               = 3,
};

// Enum DeceiveInc.EContainerState
// NumValues: 0x0003
enum class EContainerState : uint8
{
	Closed                                   = 0,
	Opened                                   = 1,
	EContainerState_MAX                      = 2,
};

// Enum DeceiveInc.EDoorState
// NumValues: 0x0004
enum class EDoorState : uint8
{
	Closed                                   = 0,
	OpenedFromFront                          = 1,
	OpenedFromBehind                         = 2,
	EDoorState_MAX                           = 3,
};

// Enum DeceiveInc.EPickableToolSlot
// NumValues: 0x0005
enum class EPickableToolSlot : uint8
{
	Weapon                                   = 0,
	Gadget                                   = 1,
	TemporaryTool                            = 2,
	Count                                    = 3,
	EPickableToolSlot_MAX                    = 4,
};

// Enum DeceiveInc.EPositionerSourceReference
// NumValues: 0x0004
enum class EPositionerSourceReference : uint8
{
	Camera                                   = 0,
	Positioner                               = 1,
	Count                                    = 2,
	EPositionerSourceReference_MAX           = 3,
};

// Enum DeceiveInc.EBotObstruction
// NumValues: 0x0004
enum class EBotObstruction : uint8
{
	None                                     = 0,
	DoorInstant                              = 1,
	DoorToHack                               = 2,
	EBotObstruction_MAX                      = 3,
};

// Enum DeceiveInc.EBotBrainType
// NumValues: 0x0007
enum class EBotBrainType : uint8
{
	None                                     = 0,
	GameplayBot                              = 1,
	ScriptedBot                              = 2,
	MirrorBot                                = 3,
	SmokeTestMurderBot                       = 4,
	TrainingBot                              = 5,
	EBotBrainType_MAX                        = 6,
};

// Enum DeceiveInc.EBotObjectiveType
// NumValues: 0x000B
enum class EBotObjectiveType : uint8
{
	Extract                                  = 0,
	CallExtraction                           = 1,
	GetBriefcase                             = 2,
	OpenVault                                = 3,
	PrintKeycard                             = 4,
	BriefcaseInVault                         = 5,
	KillBriefcaseCarrier                     = 6,
	PickUpBriefcase                          = 7,
	EnterRoom                                = 8,
	Invalid                                  = 9,
	EBotObjectiveType_MAX                    = 10,
};

// Enum DeceiveInc.ECancelObjectiveReason
// NumValues: 0x000A
enum class ECancelObjectiveReason : uint8
{
	Invalid                                  = 0,
	NormalAIDecision                         = 1,
	Fall                                     = 2,
	Bounced                                  = 3,
	Death                                    = 4,
	Scared                                   = 5,
	Investigation                            = 6,
	StopInvestigation                        = 7,
	BlockedByDoor                            = 8,
	ECancelObjectiveReason_MAX               = 9,
};

// Enum DeceiveInc.EChromaFeedbackEventType
// NumValues: 0x0022
enum class EChromaFeedbackEventType : uint8
{
	Invalid                                  = 0,
	State_Menu                               = 1,
	State_MenuStore                          = 2,
	State_MenuLootBriefcase                  = 3,
	State_MenuMatchmaking                    = 4,
	State_PhasePregameCharacterSelection     = 5,
	State_PhasePregame                       = 6,
	State_PhaseGroupShot                     = 7,
	State_PhaseLevelIntro                    = 8,
	State_PhaseCharacterIntro                = 9,
	State_PhaseInsertion                     = 10,
	State_PhaseInfiltration                  = 11,
	State_PhaseExtraction                    = 12,
	State_PhaseExtractionExtracting          = 13,
	State_PhaseExtractionContested           = 14,
	State_GameEndWin                         = 15,
	State_GameEndLost                        = 16,
	State_GadgetDroning                      = 17,
	State_GadgetMimicing                     = 18,
	State_LowHealth                          = 19,
	State_Navmode                            = 20,
	State_NavmodeEnhanced                    = 21,
	Event_CoverChangeToCivilian              = 22,
	Event_CoverChangeToStaff                 = 23,
	Event_CoverChangeToGuard                 = 24,
	Event_CoverChangeToTechnician            = 25,
	Event_CoverChangeToVip                   = 26,
	Event_Healing                            = 27,
	Event_DamageReceived                     = 28,
	Event_Death                              = 29,
	Event_SpyKill                            = 30,
	Event_Hacking                            = 31,
	Count                                    = 32,
	EChromaFeedbackEventType_MAX             = 33,
};

// Enum DeceiveInc.EChromaticFeedbackPriority
// NumValues: 0x0023
enum class EChromaticFeedbackPriority : uint8
{
	Invalid                                  = 0,
	Code_Lowest                              = 1,
	Design_Lowest                            = 2,
	Code_Lower                               = 3,
	Design_Lower                             = 4,
	Code_Low                                 = 5,
	Design_Low                               = 6,
	Code_Default                             = 7,
	Design_Default                           = 8,
	Code_LowPriorityAction                   = 9,
	Design_LowPriorityAction                 = 10,
	Code_Action                              = 11,
	Design_Action                            = 12,
	Code_HighPriorityAction                  = 13,
	Design_HighPriorityAction                = 14,
	Code_LowPriorityAbility                  = 15,
	Design_LowPriorityAbility                = 16,
	Code_Ability                             = 17,
	Design_Ability                           = 18,
	Code_HighPriorityAbility                 = 19,
	Design_HighPriorityAbility               = 20,
	Code_LowPriorityEvent                    = 21,
	Design_LowPriorityEvent                  = 22,
	Code_Event                               = 23,
	Design_Event                             = 24,
	Code_HighPriorityEvent                   = 25,
	Design_HighPriorityEvent                 = 26,
	Code_High                                = 27,
	Design_High                              = 28,
	Code_Higher                              = 29,
	Design_Higher                            = 30,
	Code_Highest                             = 31,
	Design_Highest                           = 32,
	Count                                    = 33,
	EChromaticFeedbackPriority_MAX           = 34,
};

// Enum DeceiveInc.EDSCState
// NumValues: 0x0008
enum class EDSCState : uint8
{
	NONE                                     = 0,
	Registering                              = 1,
	Registered                               = 2,
	Claimed                                  = 3,
	InEnqueue                                = 4,
	SessionFull                              = 5,
	Deregistered                             = 6,
	EDSCState_MAX                            = 7,
};

// Enum DeceiveInc.EDangerEventSourceType
// NumValues: 0x0008
enum class EDangerEventSourceType : uint8
{
	Invalid                                  = 0,
	AttackSource                             = 1,
	AttackImpact                             = 2,
	Blueprint                                = 3,
	Extraction                               = 4,
	MeleeAttackSource                        = 5,
	SoundMachine                             = 6,
	EDangerEventSourceType_MAX               = 7,
};

// Enum DeceiveInc.ENetInfoDisplayMode
// NumValues: 0x0005
enum class ENetInfoDisplayMode : uint8
{
	Hidden                                   = 0,
	IconsOnly                                = 1,
	Full                                     = 2,
	Count                                    = 3,
	ENetInfoDisplayMode_MAX                  = 4,
};

// Enum DeceiveInc.EDISpecialRules
// NumValues: 0x000B
enum class EDISpecialRules : uint8
{
	NONE                                     = 0,
	Rule1                                    = 1,
	Rule2                                    = 2,
	Rule3                                    = 4,
	Rule4                                    = 8,
	Rule5                                    = 16,
	Rule6                                    = 32,
	Rule7                                    = 64,
	Rule8                                    = 128,
	Rule4_GuardFollowsVIP                    = 8,
	EDISpecialRules_MAX                      = 129,
};

// Enum DeceiveInc.EModeAvaliability
// NumValues: 0x000A
enum class EModeAvaliability : uint8
{
	NONE                                     = 0,
	Solo                                     = 1,
	Duos                                     = 2,
	Trios                                    = 4,
	PrivateLobbies                           = 8,
	Training                                 = 16,
	Tutorial                                 = 32,
	LTM1                                     = 64,
	LTM2                                     = 128,
	EModeAvaliability_MAX                    = 129,
};

// Enum DeceiveInc.EStoreAvaliability
// NumValues: 0x0006
enum class EStoreAvaliability : uint8
{
	NONE                                     = 0,
	Steam                                    = 1,
	EGS                                      = 2,
	PSN                                      = 4,
	XBox                                     = 8,
	EStoreAvaliability_MAX                   = 9,
};

// Enum DeceiveInc.EMatchmakingAvailability
// NumValues: 0x000B
enum class EMatchmakingAvailability : uint8
{
	Available                                = 0,
	Available_RejoinOnly                     = 1,
	Disabled_NotPartyLeader                  = 2,
	Disabled_PartyMemberNotReady             = 3,
	Disabled_ModeUnavailable                 = 4,
	Disabled_PartyTooLarge                   = 5,
	Disabled_PartyTooSmall                   = 6,
	Disabled_NotInParty                      = 7,
	Disabled_Offline                         = 8,
	Count                                    = 9,
	EMatchmakingAvailability_MAX             = 10,
};

// Enum DeceiveInc.EToolVisibilityChangeReason
// NumValues: 0x0005
enum class EToolVisibilityChangeReason : uint8
{
	Generic                                  = 0,
	Animation                                = 1,
	OnAnyHandToolShowed                      = 2,
	Count                                    = 3,
	EToolVisibilityChangeReason_MAX          = 4,
};

// Enum DeceiveInc.EKeybindContext
// NumValues: 0x0007
enum class EKeybindContext : uint8
{
	Invalid                                  = 0,
	Spy                                      = 1,
	Controller                               = 2,
	Spectating                               = 3,
	Menu                                     = 4,
	Any                                      = 5,
	EKeybindContext_MAX                      = 6,
};

// Enum DeceiveInc.EGameStateClientEventType
// NumValues: 0x0003
enum class EGameStateClientEventType : uint8
{
	ExtractionPointSet                       = 0,
	Count                                    = 1,
	EGameStateClientEventType_MAX            = 2,
};

// Enum DeceiveInc.ESpyToolType
// NumValues: 0x000F
enum class ESpyToolType : uint8
{
	None                                     = 0,
	BouncingMat                              = 1,
	Drone                                    = 2,
	GooPod                                   = 3,
	HackTrap                                 = 4,
	Mimic                                    = 5,
	RemoteTurret                             = 6,
	Scrambler                                = 7,
	Shieldbrella                             = 8,
	SpyGlass                                 = 9,
	Tripwire                                 = 10,
	SoundMachine                             = 11,
	NPCBug                                   = 12,
	Count                                    = 13,
	ESpyToolType_MAX                         = 14,
};

// Enum DeceiveInc.ESpawningRule
// NumValues: 0x0006
enum class ESpawningRule : uint8
{
	OnlySpawnOnNpc                           = 0,
	PreferSpawnOnNpc                         = 1,
	PreferSpawnOnStartPoint                  = 2,
	OnlySpawnOnStartPoint                    = 3,
	Count                                    = 4,
	ESpawningRule_MAX                        = 5,
};

// Enum DeceiveInc.EEACAuthState
// NumValues: 0x0006
enum class EEACAuthState : uint8
{
	PreRegistration                          = 0,
	PendingRegistration                      = 1,
	Registered                               = 2,
	FailedRegistration                       = 3,
	PendingKick                              = 4,
	EEACAuthState_MAX                        = 5,
};

// Enum DeceiveInc.EClientEvent
// NumValues: 0x0002
enum class EClientEvent : uint8
{
	SpawnFailed                              = 0,
	EClientEvent_MAX                         = 1,
};

// Enum DeceiveInc.EPlayerVoiceChatTransmitMode
// NumValues: 0x0004
enum class EPlayerVoiceChatTransmitMode : uint8
{
	None                                     = 0,
	All                                      = 1,
	Channel                                  = 2,
	EPlayerVoiceChatTransmitMode_MAX         = 3,
};

// Enum DeceiveInc.EXpProgressionType
// NumValues: 0x0006
enum class EXpProgressionType : uint8
{
	AccountProgression                       = 0,
	AgentProgression                         = 1,
	CatalogueProgression                     = 2,
	LimitedEventProgression                  = 3,
	Count                                    = 4,
	EXpProgressionType_MAX                   = 5,
};

// Enum DeceiveInc.EAutomatedBotBehaviours
// NumValues: 0x0004
enum class EAutomatedBotBehaviours : uint8
{
	Disabled                                 = 0,
	Matchmaking                              = 1,
	CustomMission                            = 2,
	EAutomatedBotBehaviours_MAX              = 3,
};

// Enum DeceiveInc.ECharacterSelectAgentAvailability
// NumValues: 0x0005
enum class ECharacterSelectAgentAvailability : uint8
{
	Available                                = 0,
	Unavailable                              = 1,
	NotPurchased                             = 2,
	Count                                    = 3,
	ECharacterSelectAgentAvailability_MAX    = 4,
};

// Enum DeceiveInc.EClientLoginStateFlags
// NumValues: 0x000A
enum class EClientLoginStateFlags : uint8
{
	StateNone                                = 0,
	LoggingIn                                = 1,
	SaveGameLoaded                           = 2,
	PlatformSubscriptionConfirmed            = 4,
	WebServicesOnline                        = 8,
	AccelByteLoggingIn                       = 16,
	AccelByteOnline                          = 32,
	AccelByteLobbyOnline                     = 64,
	AgreementsSigned                         = 128,
	EClientLoginStateFlags_MAX               = 129,
};

// Enum DeceiveInc.EDIMenuGameModes
// NumValues: 0x000B
enum class EDIMenuGameModes : uint8
{
	NONE                                     = 0,
	CUSTOM_MATCH                             = 1,
	MATCHMAKING_SOLO                         = 2,
	MATCHMAKING_DUO                          = 3,
	MATCHMAKING_TEAM                         = 4,
	TUTORIAL                                 = 5,
	TRAINING                                 = 6,
	PRIVATE_LOBBY                            = 7,
	MATCHMAKING_LTM1                         = 8,
	MATCHMAKING_LTM2                         = 9,
	EDIMenuGameModes_MAX                     = 10,
};

// Enum DeceiveInc.EInputMode
// NumValues: 0x0005
enum class EInputMode : uint8
{
	UIOnly                                   = 0,
	GameAndUI                                = 1,
	GameOnly                                 = 2,
	Unchanged                                = 3,
	EInputMode_MAX                           = 4,
};

// Enum DeceiveInc.EDIPawnType
// NumValues: 0x0007
enum class EDIPawnType : uint8
{
	Invalid                                  = 0,
	Spy                                      = 1,
	Drone                                    = 2,
	FreeCamera                               = 3,
	Spectator                                = 4,
	Count                                    = 5,
	EDIPawnType_MAX                          = 6,
};

// Enum DeceiveInc.EAnonymizePlayerNameType
// NumValues: 0x0004
enum class EAnonymizePlayerNameType : uint8
{
	None                                     = 0,
	Opponents                                = 1,
	All                                      = 2,
	EAnonymizePlayerNameType_MAX             = 3,
};

// Enum DeceiveInc.DIReportType
// NumValues: 0x0008
enum class EDIReportType : uint8
{
	None                                     = 0,
	CommunicationAbuse                       = 1,
	Cheating                                 = 2,
	AbilityAbuse                             = 4,
	Sabotage                                 = 8,
	Disrespectful                            = 16,
	Threats                                  = 32,
	DIReportType_MAX                         = 33,
};

// Enum DeceiveInc.DIOnlinePresenceType
// NumValues: 0x0003
enum class EDIOnlinePresenceType : uint8
{
	IsOnline                                 = 0,
	Offline                                  = 1,
	DIOnlinePresenceType_MAX                 = 2,
};

// Enum DeceiveInc.EDIITemStoreCategoryOverride
// NumValues: 0x0005
enum class EDIITemStoreCategoryOverride : uint8
{
	None                                     = 0,
	Skin                                     = 1,
	IntroPose                                = 2,
	Ink                                      = 3,
	EDIITemStoreCategoryOverride_MAX         = 4,
};

// Enum DeceiveInc.EParticipantType
// NumValues: 0x0005
enum class EParticipantType : uint8
{
	Invalid                                  = 0,
	Bystander                                = 1,
	Active                                   = 2,
	AwareNotParticipating                    = 3,
	EParticipantType_MAX                     = 4,
};

// Enum DeceiveInc.EEncounterType
// NumValues: 0x0004
enum class EEncounterType : uint8
{
	Invalid                                  = 0,
	Investigate                              = 1,
	Intercept                                = 2,
	EEncounterType_MAX                       = 3,
};

// Enum DeceiveInc.EExtractionActorReplicatedState
// NumValues: 0x0006
enum class EExtractionActorReplicatedState : uint8
{
	Uninitialized                            = 0,
	Initialize                               = 1,
	Arriving                                 = 2,
	Arrived                                  = 3,
	Disable                                  = 4,
	EExtractionActorReplicatedState_MAX      = 5,
};

// Enum DeceiveInc.EInteract1PAnimation
// NumValues: 0x0009
enum class EInteract1PAnimation : uint8
{
	None                                     = 0,
	Grab                                     = 1,
	OpenDoor                                 = 2,
	WatchConfirm                             = 3,
	WatchCoverScan                           = 4,
	WatchHackIntel                           = 5,
	WatchLoop                                = 6,
	ConsumableHeal                           = 7,
	EInteract1PAnimation_MAX                 = 8,
};

// Enum DeceiveInc.ELevelAreaFlags
// NumValues: 0x0005
enum class ELevelAreaFlags : uint8
{
	None                                     = 0,
	ObjSpawnGroup                            = 1,
	Vault                                    = 2,
	Count                                    = 3,
	ELevelAreaFlags_MAX                      = 4,
};

// Enum DeceiveInc.DICommunityTrackerEvent
// NumValues: 0x0007
enum class EDICommunityTrackerEvent : uint8
{
	None                                     = 0,
	Intel                                    = 1,
	Ammo                                     = 2,
	Health                                   = 3,
	Keycard                                  = 4,
	NPCDeath                                 = 5,
	DICommunityTrackerEvent_MAX              = 6,
};

// Enum DeceiveInc.EPopupType
// NumValues: 0x0016
enum class EPopupType : uint8
{
	NONE                                     = 0,
	YesNoPopup                               = 1,
	OkPopup                                  = 2,
	OkTitlePopup                             = 3,
	QuitGamePopup                            = 4,
	ReleaseNotesPopup                        = 5,
	InputCapturePopup                        = 6,
	AgreementPopup                           = 7,
	PlaytestAgreementPopup                   = 8,
	UnlockPopup                              = 9,
	OwnershipTestFail                        = 10,
	CodeOfConduct                            = 11,
	ReportPopup                              = 12,
	BuyConfirmationPopup                     = 13,
	Credits                                  = 14,
	BuyItemPopup                             = 15,
	BuyCatalogue                             = 16,
	BuyConfirmationPopup_Soft                = 17,
	BuyConfirmationPopup_Hard                = 18,
	BuyConfirmationPopup_Catalogue           = 19,
	Custom                                   = 20,
	EPopupType_MAX                           = 21,
};

// Enum DeceiveInc.ESubMenuPages
// NumValues: 0x0005
enum class ESubMenuPages : uint8
{
	NONE                                     = 0,
	CustomGameHUB                            = 1,
	CustomGameCreate                         = 2,
	CustomGameList                           = 3,
	ESubMenuPages_MAX                        = 4,
};

// Enum DeceiveInc.EMainMenuPages
// NumValues: 0x0007
enum class EMainMenuPages : uint8
{
	NONE                                     = 0,
	HUB                                      = 1,
	Agent                                    = 2,
	Loot                                     = 3,
	Profile                                  = 4,
	Skin                                     = 5,
	EMainMenuPages_MAX                       = 6,
};

// Enum DeceiveInc.EMenuType
// NumValues: 0x0011
enum class EMenuType : uint8
{
	NONE                                     = 0,
	Login                                    = 1,
	Legal                                    = 2,
	MainMenu                                 = 3,
	PlayerSettings                           = 4,
	Keybindings                              = 5,
	GamepadKeybindings                       = 6,
	AgentSelect                              = 7,
	Pause                                    = 8,
	Spectator                                = 9,
	PrivateLobby                             = 10,
	PhaseMenu                                = 11,
	Bugreport                                = 12,
	EndScreen                                = 13,
	ResultScreen                             = 14,
	ShaderPrecompile                         = 15,
	EMenuType_MAX                            = 16,
};

// Enum DeceiveInc.EWrapType
// NumValues: 0x0003
enum class EWrapType : uint8
{
	Basic                                    = 0,
	CoverReactive                            = 1,
	EWrapType_MAX                            = 2,
};

// Enum DeceiveInc.ENavModeItemType
// NumValues: 0x000B
enum class ENavModeItemType : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Objective                                = 2,
	VaultDoor                                = 3,
	VaultTerminal                            = 4,
	HealingStation                           = 5,
	AmmoStation                              = 6,
	Extraction                               = 7,
	DownedAlly                               = 8,
	ConsumableStation                        = 9,
	ENavModeItemType_MAX                     = 10,
};

// Enum DeceiveInc.ENPCMovementStatus
// NumValues: 0x0004
enum class ENPCMovementStatus : uint8
{
	Idle                                     = 0,
	Moving                                   = 1,
	Airborne                                 = 2,
	ENPCMovementStatus_MAX                   = 3,
};

// Enum DeceiveInc.RotationAnimationType
// NumValues: 0x0005
enum class ERotationAnimationType : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	Count                                    = 3,
	RotationAnimationType_MAX                = 4,
};

// Enum DeceiveInc.GuardReorientType
// NumValues: 0x0005
enum class EGuardReorientType : uint8
{
	Forward                                  = 0,
	Strafe                                   = 1,
	WalkBack                                 = 2,
	Count                                    = 3,
	GuardReorientType_MAX                    = 4,
};

// Enum DeceiveInc.ENPCInteractionType
// NumValues: 0x0006
enum class ENPCInteractionType : uint8
{
	Generic                                  = 0,
	Conversation                             = 1,
	AIInteractable                           = 2,
	DeadNPC                                  = 3,
	Invalid                                  = 4,
	ENPCInteractionType_MAX                  = 5,
};

// Enum DeceiveInc.ENPCInteractionPositioning
// NumValues: 0x0004
enum class ENPCInteractionPositioning : uint8
{
	SnapOnStandPoint                         = 0,
	StandClose                               = 1,
	LookAtInRadius                           = 2,
	ENPCInteractionPositioning_MAX           = 3,
};

// Enum DeceiveInc.ENPCReplicatedVO
// NumValues: 0x0003
enum class ENPCReplicatedVO : uint8
{
	Scold                                    = 0,
	GuardAggro                               = 1,
	ENPCReplicatedVO_MAX                     = 2,
};

// Enum DeceiveInc.EPeripheralPatternType
// NumValues: 0x0016
enum class EPeripheralPatternType : uint8
{
	None                                     = 0,
	State_MainMenu                           = 1,
	State_Loading                            = 2,
	State_CharacterSelect                    = 3,
	State_Default                            = 4,
	State_LevelIntro                         = 5,
	State_Dead                               = 6,
	State_EndOfMatch                         = 7,
	Act_DisguiseChange_Civilian              = 8,
	Act_DisguiseChange_Staff                 = 9,
	Act_DisguiseChange_Guard                 = 10,
	Act_DisguiseChange_Technician            = 11,
	Act_DisguiseChange_Vip                   = 12,
	Act_AquiringIntel                        = 13,
	Act_Hacking                              = 14,
	Act_ItemPickup_Ammo                      = 15,
	Act_ItemPickup_GreenCard                 = 16,
	Act_ItemPickup_BlueCard                  = 17,
	Act_ItemPickup_PurpleCard                = 18,
	Act_ItemPickup_GoldCard                  = 19,
	Act_ItemPickup_Powerup                   = 20,
	EPeripheralPatternType_MAX               = 21,
};

// Enum DeceiveInc.EPlayerSettingsDefaultState
// NumValues: 0x0004
enum class EPlayerSettingsDefaultState : uint8
{
	Collapsed                                = 0,
	ExpandedSelfOnly                         = 1,
	ExpandedWithChildren                     = 2,
	EPlayerSettingsDefaultState_MAX          = 3,
};

// Enum DeceiveInc.EPlayerSettingsOption_AimAssist_InfluenceTargetType
// NumValues: 0x0004
enum class EPlayerSettingsOption_AimAssist_InfluenceTargetType : uint8
{
	AllTargets                               = 0,
	AllHostile                               = 1,
	SpiesOnly                                = 2,
	EPlayerSettingsOption_AimAssist_MAX      = 3,
};

// Enum DeceiveInc.EHitProcessingType
// NumValues: 0x0004
enum class EHitProcessingType : uint8
{
	Base                                     = 0,
	SprayWeapon                              = 1,
	Count                                    = 2,
	EHitProcessingType_MAX                   = 3,
};

// Enum DeceiveInc.EFDamageContextType
// NumValues: 0x0004
enum class EFDamageContextType : uint8
{
	Base                                     = 0,
	SprayWeapon                              = 1,
	Count                                    = 2,
	EFDamageContextType_MAX                  = 3,
};

// Enum DeceiveInc.EEffectOnHitRefreshBehavior
// NumValues: 0x0003
enum class EEffectOnHitRefreshBehavior : uint8
{
	ResetDuration                            = 0,
	AccumulateDuration                       = 1,
	EEffectOnHitRefreshBehavior_MAX          = 2,
};

// Enum DeceiveInc.ECycleEventMode
// NumValues: 0x0004
enum class ECycleEventMode : uint8
{
	None                                     = 0,
	Effective                                = 1,
	Ineffective                              = 2,
	ECycleEventMode_MAX                      = 3,
};

// Enum DeceiveInc.EFiringMode
// NumValues: 0x0005
enum class EFiringMode : uint8
{
	SemiAuto                                 = 0,
	FullAuto                                 = 1,
	BurstFire                                = 2,
	ChargeFire                               = 3,
	EFiringMode_MAX                          = 4,
};

// Enum DeceiveInc.ERevivePartyFailedCause
// NumValues: 0x0008
enum class ERevivePartyFailedCause : uint8
{
	None                                     = 0,
	InvalidData                              = 1,
	NoTeamate                                = 2,
	NoDeadTeamate                            = 3,
	CannotRevive                             = 4,
	NoRessources                             = 5,
	InvalidPhase                             = 6,
	ERevivePartyFailedCause_MAX              = 7,
};

// Enum DeceiveInc.EAimInputAssistMode
// NumValues: 0x0004
enum class EAimInputAssistMode : uint8
{
	None                                     = 0,
	Friction                                 = 1,
	Magnetism                                = 2,
	EAimInputAssistMode_MAX                  = 3,
};

// Enum DeceiveInc.ECompareCheck
// NumValues: 0x0005
enum class ECompareCheck : uint8
{
	Equal                                    = 0,
	GreaterOrEqual                           = 1,
	SmallerOrEqual                           = 2,
	NotEqual                                 = 3,
	ECompareCheck_MAX                        = 4,
};

// Enum DeceiveInc.ENPCPool
// NumValues: 0x0009
enum class ENPCPool : uint8
{
	Pool_Civilian                            = 0,
	Pool_Staff                               = 1,
	Pool_Guard                               = 2,
	Pool_Technician                          = 3,
	Pool_VIP                                 = 4,
	Pool_EliteGuard                          = 5,
	Pool_MetalDouglas                        = 6,
	Count                                    = 7,
	ENPCPool_MAX                             = 8,
};

// Enum DeceiveInc.ESpySecurityFlag
// NumValues: 0x0005
enum class ESpySecurityFlag : uint8
{
	NONE                                     = 0,
	SCOLDED                                  = 1,
	INVESTIGATED                             = 2,
	GUARD_AGGROED                            = 4,
	ESpySecurityFlag_MAX                     = 5,
};

// Enum DeceiveInc.EDataminingSessionType
// NumValues: 0x0005
enum class EDataminingSessionType : uint8
{
	Invalid                                  = 0,
	MainMenu                                 = 1,
	MissionServer                            = 2,
	MissionClient                            = 3,
	EDataminingSessionType_MAX               = 4,
};

// Enum DeceiveInc.EVaultOverrideStatus
// NumValues: 0x0005
enum class EVaultOverrideStatus : uint8
{
	NeedIntel                                = 0,
	NeedDisguise                             = 1,
	Ready                                    = 2,
	Activated                                = 3,
	EVaultOverrideStatus_MAX                 = 4,
};

// Enum DeceiveInc.EVictimEffectPositioningType
// NumValues: 0x0004
enum class EVictimEffectPositioningType : uint8
{
	Manual                                   = 0,
	AdoptVictimPosition                      = 1,
	AttachToVictim                           = 2,
	EVictimEffectPositioningType_MAX         = 3,
};

// Enum DeceiveInc.EVictimEffectType
// NumValues: 0x000F
enum class EVictimEffectType : uint8
{
	Undefined                                = 0,
	Damage                                   = 1,
	CoverBlow                                = 2,
	Fear                                     = 3,
	Impulse                                  = 4,
	Trace                                    = 5,
	Silence                                  = 6,
	NoAggro                                  = 7,
	Charm                                    = 8,
	Disarmed                                 = 9,
	Cleanse                                  = 10,
	CoverRegen                               = 11,
	Poison                                   = 12,
	Suppress                                 = 13,
	EVictimEffectType_MAX                    = 14,
};

// Enum DeceiveInc.EWebStreamedAssetType
// NumValues: 0x0004
enum class EWebStreamedAssetType : uint8
{
	None                                     = 0,
	StillImage                               = 1,
	Count                                    = 2,
	EWebStreamedAssetType_MAX                = 3,
};

// Enum DeceiveInc.EAssetAxisScaleType
// NumValues: 0x000F
enum class EAssetAxisScaleType : uint8
{
	NoScale                                  = 0,
	RatioBasedOnMesh_XHeight_YWidth_ShrinkOnly = 1,
	RatioBasedOnMesh_XHeight_ZWidth_ShrinkOnly = 2,
	RatioBasedOnMesh_YHeight_XWidth_ShrinkOnly = 3,
	RatioBasedOnMesh_YHeight_ZWidth_ShrinkOnly = 4,
	RatioBasedOnMesh_ZHeight_XWidth_ShrinkOnly = 5,
	RatioBasedOnMesh_ZHeight_YWidth_ShrinkOnly = 6,
	RatioBasedOnMesh_XHeight_YWidth_StretchOnly = 7,
	RatioBasedOnMesh_XHeight_ZWidth_StretchOnly = 8,
	RatioBasedOnMesh_YHeight_XWidth_StretchOnly = 9,
	RatioBasedOnMesh_YHeight_ZWidth_StretchOnly = 10,
	RatioBasedOnMesh_ZHeight_XWidth_StretchOnly = 11,
	RatioBasedOnMesh_ZHeight_YWidth_StretchOnly = 12,
	Count                                    = 13,
	EAssetAxisScaleType_MAX                  = 14,
};

// Enum DeceiveInc.EFormulaOperationType
// NumValues: 0x0005
enum class EFormulaOperationType : uint8
{
	Addition                                 = 0,
	Multiplication                           = 1,
	Fixed                                    = 2,
	Count                                    = 3,
	EFormulaOperationType_MAX                = 4,
};

// ScriptStruct DeceiveInc.StoreCatalogEntryPageSlotData
// 0x0010 (0x0010 - 0x0000)
struct FStoreCatalogEntryPageSlotData final
{
public:
	class UDIItem*                                Item;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemId;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreCatalogEntryPageSlotData) == 0x000008, "Wrong alignment on FStoreCatalogEntryPageSlotData");
static_assert(sizeof(FStoreCatalogEntryPageSlotData) == 0x000010, "Wrong size on FStoreCatalogEntryPageSlotData");
static_assert(offsetof(FStoreCatalogEntryPageSlotData, Item) == 0x000000, "Member 'FStoreCatalogEntryPageSlotData::Item' has a wrong offset!");
static_assert(offsetof(FStoreCatalogEntryPageSlotData, ItemId) == 0x000008, "Member 'FStoreCatalogEntryPageSlotData::ItemId' has a wrong offset!");

// ScriptStruct DeceiveInc.StoreCatalogEntryPageData
// 0x0060 (0x0060 - 0x0000)
struct FStoreCatalogEntryPageData final
{
public:
	struct FStoreCatalogEntryPageSlotData         Slot1Data;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStoreCatalogEntryPageSlotData         Slot2Data;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStoreCatalogEntryPageSlotData         Slot3Data;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStoreCatalogEntryPageSlotData         Slot4Data;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStoreCatalogEntryPageSlotData         Slot5Data;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class UDITitleItem*                           PageRewardTitle;                                   // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PageRewardTitleItemID;                             // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreCatalogEntryPageData) == 0x000008, "Wrong alignment on FStoreCatalogEntryPageData");
static_assert(sizeof(FStoreCatalogEntryPageData) == 0x000060, "Wrong size on FStoreCatalogEntryPageData");
static_assert(offsetof(FStoreCatalogEntryPageData, Slot1Data) == 0x000000, "Member 'FStoreCatalogEntryPageData::Slot1Data' has a wrong offset!");
static_assert(offsetof(FStoreCatalogEntryPageData, Slot2Data) == 0x000010, "Member 'FStoreCatalogEntryPageData::Slot2Data' has a wrong offset!");
static_assert(offsetof(FStoreCatalogEntryPageData, Slot3Data) == 0x000020, "Member 'FStoreCatalogEntryPageData::Slot3Data' has a wrong offset!");
static_assert(offsetof(FStoreCatalogEntryPageData, Slot4Data) == 0x000030, "Member 'FStoreCatalogEntryPageData::Slot4Data' has a wrong offset!");
static_assert(offsetof(FStoreCatalogEntryPageData, Slot5Data) == 0x000040, "Member 'FStoreCatalogEntryPageData::Slot5Data' has a wrong offset!");
static_assert(offsetof(FStoreCatalogEntryPageData, PageRewardTitle) == 0x000050, "Member 'FStoreCatalogEntryPageData::PageRewardTitle' has a wrong offset!");
static_assert(offsetof(FStoreCatalogEntryPageData, PageRewardTitleItemID) == 0x000058, "Member 'FStoreCatalogEntryPageData::PageRewardTitleItemID' has a wrong offset!");

// ScriptStruct DeceiveInc.ToolActionTextData
// 0x0020 (0x0020 - 0x0000)
struct FToolActionTextData final
{
public:
	class FText                                   ToolActionText;                                    // 0x0000(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsUsable;                                         // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisableByOther;                                 // 0x0019(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FToolActionTextData) == 0x000008, "Wrong alignment on FToolActionTextData");
static_assert(sizeof(FToolActionTextData) == 0x000020, "Wrong size on FToolActionTextData");
static_assert(offsetof(FToolActionTextData, ToolActionText) == 0x000000, "Member 'FToolActionTextData::ToolActionText' has a wrong offset!");
static_assert(offsetof(FToolActionTextData, bIsUsable) == 0x000018, "Member 'FToolActionTextData::bIsUsable' has a wrong offset!");
static_assert(offsetof(FToolActionTextData, bIsDisableByOther) == 0x000019, "Member 'FToolActionTextData::bIsDisableByOther' has a wrong offset!");

// ScriptStruct DeceiveInc.NonGenericXpInfo
// 0x0020 (0x0020 - 0x0000)
struct FNonGenericXpInfo final
{
public:
	class FString                                 XpType;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulatedXP;                                       // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CumulatedMultiplicator;                            // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NegativeMultiplicator;                             // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNonGenericXpInfo) == 0x000008, "Wrong alignment on FNonGenericXpInfo");
static_assert(sizeof(FNonGenericXpInfo) == 0x000020, "Wrong size on FNonGenericXpInfo");
static_assert(offsetof(FNonGenericXpInfo, XpType) == 0x000000, "Member 'FNonGenericXpInfo::XpType' has a wrong offset!");
static_assert(offsetof(FNonGenericXpInfo, CumulatedXP) == 0x000010, "Member 'FNonGenericXpInfo::CumulatedXP' has a wrong offset!");
static_assert(offsetof(FNonGenericXpInfo, CumulatedMultiplicator) == 0x000014, "Member 'FNonGenericXpInfo::CumulatedMultiplicator' has a wrong offset!");
static_assert(offsetof(FNonGenericXpInfo, NegativeMultiplicator) == 0x000018, "Member 'FNonGenericXpInfo::NegativeMultiplicator' has a wrong offset!");

// ScriptStruct DeceiveInc.PlayerXpEventInfo
// 0x000C (0x000C - 0x0000)
struct FPlayerXpEventInfo final
{
public:
	EDIXPEvent                                    EventType;                                         // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxTrigger;                                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriggerAmount;                                     // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerXpEventInfo) == 0x000004, "Wrong alignment on FPlayerXpEventInfo");
static_assert(sizeof(FPlayerXpEventInfo) == 0x00000C, "Wrong size on FPlayerXpEventInfo");
static_assert(offsetof(FPlayerXpEventInfo, EventType) == 0x000000, "Member 'FPlayerXpEventInfo::EventType' has a wrong offset!");
static_assert(offsetof(FPlayerXpEventInfo, MaxTrigger) == 0x000004, "Member 'FPlayerXpEventInfo::MaxTrigger' has a wrong offset!");
static_assert(offsetof(FPlayerXpEventInfo, TriggerAmount) == 0x000008, "Member 'FPlayerXpEventInfo::TriggerAmount' has a wrong offset!");

// ScriptStruct DeceiveInc.XpHolder
// 0x0040 (0x0040 - 0x0000)
struct FXpHolder final
{
public:
	int32                                         XP;                                                // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalMultiplicator;                                // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NegativeMultiplicator;                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNonGenericXpInfo>              NonGenericXpInfo;                                  // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerXpEventInfo>             PlayerXpEventInfo;                                 // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerXpEventInfo>             PlayerXpMultiplicatorInfo;                         // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FXpHolder) == 0x000008, "Wrong alignment on FXpHolder");
static_assert(sizeof(FXpHolder) == 0x000040, "Wrong size on FXpHolder");
static_assert(offsetof(FXpHolder, XP) == 0x000000, "Member 'FXpHolder::XP' has a wrong offset!");
static_assert(offsetof(FXpHolder, TotalMultiplicator) == 0x000004, "Member 'FXpHolder::TotalMultiplicator' has a wrong offset!");
static_assert(offsetof(FXpHolder, NegativeMultiplicator) == 0x000008, "Member 'FXpHolder::NegativeMultiplicator' has a wrong offset!");
static_assert(offsetof(FXpHolder, NonGenericXpInfo) == 0x000010, "Member 'FXpHolder::NonGenericXpInfo' has a wrong offset!");
static_assert(offsetof(FXpHolder, PlayerXpEventInfo) == 0x000020, "Member 'FXpHolder::PlayerXpEventInfo' has a wrong offset!");
static_assert(offsetof(FXpHolder, PlayerXpMultiplicatorInfo) == 0x000030, "Member 'FXpHolder::PlayerXpMultiplicatorInfo' has a wrong offset!");

// ScriptStruct DeceiveInc.Faction
// 0x0018 (0x0018 - 0x0000)
struct FFaction final
{
public:
	uint8                                         FactionID;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADIPlayerState*>                 Members;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFaction) == 0x000008, "Wrong alignment on FFaction");
static_assert(sizeof(FFaction) == 0x000018, "Wrong size on FFaction");
static_assert(offsetof(FFaction, FactionID) == 0x000000, "Member 'FFaction::FactionID' has a wrong offset!");
static_assert(offsetof(FFaction, Members) == 0x000008, "Member 'FFaction::Members' has a wrong offset!");

// ScriptStruct DeceiveInc.FactionData
// 0x0028 (0x0028 - 0x0000)
struct FFactionData final
{
public:
	TArray<struct FFaction>                       Factions;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int8                                          TeamSize;                                          // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Type;                                              // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFactionData) == 0x000008, "Wrong alignment on FFactionData");
static_assert(sizeof(FFactionData) == 0x000028, "Wrong size on FFactionData");
static_assert(offsetof(FFactionData, Factions) == 0x000000, "Member 'FFactionData::Factions' has a wrong offset!");
static_assert(offsetof(FFactionData, TeamSize) == 0x000010, "Member 'FFactionData::TeamSize' has a wrong offset!");
static_assert(offsetof(FFactionData, Type) == 0x000018, "Member 'FFactionData::Type' has a wrong offset!");

// ScriptStruct DeceiveInc.DIModeSettings
// 0x0008 (0x0008 - 0x0000)
struct FDIModeSettings
{
public:
	int32                                         MaximumPartySize;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinimumPartySize;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDIModeSettings) == 0x000004, "Wrong alignment on FDIModeSettings");
static_assert(sizeof(FDIModeSettings) == 0x000008, "Wrong size on FDIModeSettings");
static_assert(offsetof(FDIModeSettings, MaximumPartySize) == 0x000000, "Member 'FDIModeSettings::MaximumPartySize' has a wrong offset!");
static_assert(offsetof(FDIModeSettings, MinimumPartySize) == 0x000004, "Member 'FDIModeSettings::MinimumPartySize' has a wrong offset!");

// ScriptStruct DeceiveInc.LoginResponse
// 0x0020 (0x0020 - 0x0000)
struct FLoginResponse final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SessionToken;                                      // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoginResponse) == 0x000008, "Wrong alignment on FLoginResponse");
static_assert(sizeof(FLoginResponse) == 0x000020, "Wrong size on FLoginResponse");
static_assert(offsetof(FLoginResponse, SessionToken) == 0x000010, "Member 'FLoginResponse::SessionToken' has a wrong offset!");

// ScriptStruct DeceiveInc.MeleeChargeLevel
// 0x000C (0x000C - 0x0000)
struct FMeleeChargeLevel final
{
public:
	float                                         ChargeTime;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveImpactForce;                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveDamage;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeleeChargeLevel) == 0x000004, "Wrong alignment on FMeleeChargeLevel");
static_assert(sizeof(FMeleeChargeLevel) == 0x00000C, "Wrong size on FMeleeChargeLevel");
static_assert(offsetof(FMeleeChargeLevel, ChargeTime) == 0x000000, "Member 'FMeleeChargeLevel::ChargeTime' has a wrong offset!");
static_assert(offsetof(FMeleeChargeLevel, AdditiveImpactForce) == 0x000004, "Member 'FMeleeChargeLevel::AdditiveImpactForce' has a wrong offset!");
static_assert(offsetof(FMeleeChargeLevel, AdditiveDamage) == 0x000008, "Member 'FMeleeChargeLevel::AdditiveDamage' has a wrong offset!");

// ScriptStruct DeceiveInc.NewLevelRewardInfo
// 0x0028 (0x0028 - 0x0000)
struct FNewLevelRewardInfo final
{
public:
	class FText                                   RewardDisplayName;                                 // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UObject*                                RewardIcon;                                        // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardAmount;                                      // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNewLevelRewardInfo) == 0x000008, "Wrong alignment on FNewLevelRewardInfo");
static_assert(sizeof(FNewLevelRewardInfo) == 0x000028, "Wrong size on FNewLevelRewardInfo");
static_assert(offsetof(FNewLevelRewardInfo, RewardDisplayName) == 0x000000, "Member 'FNewLevelRewardInfo::RewardDisplayName' has a wrong offset!");
static_assert(offsetof(FNewLevelRewardInfo, RewardIcon) == 0x000018, "Member 'FNewLevelRewardInfo::RewardIcon' has a wrong offset!");
static_assert(offsetof(FNewLevelRewardInfo, RewardAmount) == 0x000020, "Member 'FNewLevelRewardInfo::RewardAmount' has a wrong offset!");

// ScriptStruct DeceiveInc.NewLevelInfo
// 0x0010 (0x0010 - 0x0000)
struct FNewLevelInfo final
{
public:
	int32                                         OldAccountLvl;                                     // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewAccountLvl;                                     // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldAgentLvl;                                       // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewAgentLvl;                                       // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNewLevelInfo) == 0x000004, "Wrong alignment on FNewLevelInfo");
static_assert(sizeof(FNewLevelInfo) == 0x000010, "Wrong size on FNewLevelInfo");
static_assert(offsetof(FNewLevelInfo, OldAccountLvl) == 0x000000, "Member 'FNewLevelInfo::OldAccountLvl' has a wrong offset!");
static_assert(offsetof(FNewLevelInfo, NewAccountLvl) == 0x000004, "Member 'FNewLevelInfo::NewAccountLvl' has a wrong offset!");
static_assert(offsetof(FNewLevelInfo, OldAgentLvl) == 0x000008, "Member 'FNewLevelInfo::OldAgentLvl' has a wrong offset!");
static_assert(offsetof(FNewLevelInfo, NewAgentLvl) == 0x00000C, "Member 'FNewLevelInfo::NewAgentLvl' has a wrong offset!");

// ScriptStruct DeceiveInc.HeatVisionSpyTargetData
// 0x0024 (0x0024 - 0x0000)
struct alignas(0x04) FHeatVisionSpyTargetData final
{
public:
	uint8                                         Pad_0[0x24];                                       // 0x0000(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHeatVisionSpyTargetData) == 0x000004, "Wrong alignment on FHeatVisionSpyTargetData");
static_assert(sizeof(FHeatVisionSpyTargetData) == 0x000024, "Wrong size on FHeatVisionSpyTargetData");

// ScriptStruct DeceiveInc.AASegmentPoint
// 0x0014 (0x0014 - 0x0000)
struct FAASegmentPoint final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalOffset;                                       // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAASegmentPoint) == 0x000004, "Wrong alignment on FAASegmentPoint");
static_assert(sizeof(FAASegmentPoint) == 0x000014, "Wrong size on FAASegmentPoint");
static_assert(offsetof(FAASegmentPoint, BoneName) == 0x000000, "Member 'FAASegmentPoint::BoneName' has a wrong offset!");
static_assert(offsetof(FAASegmentPoint, LocalOffset) == 0x000008, "Member 'FAASegmentPoint::LocalOffset' has a wrong offset!");

// ScriptStruct DeceiveInc.JumpFatigueSetting
// 0x000C (0x000C - 0x0000)
struct FJumpFatigueSetting final
{
public:
	int32                                         JumpCountThreshold;                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpVelocity;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowModifier;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJumpFatigueSetting) == 0x000004, "Wrong alignment on FJumpFatigueSetting");
static_assert(sizeof(FJumpFatigueSetting) == 0x00000C, "Wrong size on FJumpFatigueSetting");
static_assert(offsetof(FJumpFatigueSetting, JumpCountThreshold) == 0x000000, "Member 'FJumpFatigueSetting::JumpCountThreshold' has a wrong offset!");
static_assert(offsetof(FJumpFatigueSetting, JumpVelocity) == 0x000004, "Member 'FJumpFatigueSetting::JumpVelocity' has a wrong offset!");
static_assert(offsetof(FJumpFatigueSetting, SlowModifier) == 0x000008, "Member 'FJumpFatigueSetting::SlowModifier' has a wrong offset!");

// ScriptStruct DeceiveInc.WeaponImpactData
// 0x0050 (0x0050 - 0x0000)
struct FWeaponImpactData final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    ImpactPoint;                                       // 0x0008(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    ImpactDirection;                                   // 0x0014(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    ImpactNormal;                                      // 0x0020(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AProjectileWeapon*                      Weapon;                                            // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitType                                      HitType;                                           // 0x003C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0040(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpawnerWeaponRound*                    HittingProjectile;                                 // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponImpactData) == 0x000008, "Wrong alignment on FWeaponImpactData");
static_assert(sizeof(FWeaponImpactData) == 0x000050, "Wrong size on FWeaponImpactData");
static_assert(offsetof(FWeaponImpactData, Victim) == 0x000000, "Member 'FWeaponImpactData::Victim' has a wrong offset!");
static_assert(offsetof(FWeaponImpactData, ImpactPoint) == 0x000008, "Member 'FWeaponImpactData::ImpactPoint' has a wrong offset!");
static_assert(offsetof(FWeaponImpactData, ImpactDirection) == 0x000014, "Member 'FWeaponImpactData::ImpactDirection' has a wrong offset!");
static_assert(offsetof(FWeaponImpactData, ImpactNormal) == 0x000020, "Member 'FWeaponImpactData::ImpactNormal' has a wrong offset!");
static_assert(offsetof(FWeaponImpactData, Weapon) == 0x000030, "Member 'FWeaponImpactData::Weapon' has a wrong offset!");
static_assert(offsetof(FWeaponImpactData, Damage) == 0x000038, "Member 'FWeaponImpactData::Damage' has a wrong offset!");
static_assert(offsetof(FWeaponImpactData, HitType) == 0x00003C, "Member 'FWeaponImpactData::HitType' has a wrong offset!");
static_assert(offsetof(FWeaponImpactData, HitComponent) == 0x000040, "Member 'FWeaponImpactData::HitComponent' has a wrong offset!");
static_assert(offsetof(FWeaponImpactData, HittingProjectile) == 0x000048, "Member 'FWeaponImpactData::HittingProjectile' has a wrong offset!");

// ScriptStruct DeceiveInc.GivePlayerEloDefinition
// 0x0018 (0x0018 - 0x0000)
struct FGivePlayerEloDefinition final
{
public:
	class FString                                 PlayerID;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CombatElo;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGivePlayerEloDefinition) == 0x000008, "Wrong alignment on FGivePlayerEloDefinition");
static_assert(sizeof(FGivePlayerEloDefinition) == 0x000018, "Wrong size on FGivePlayerEloDefinition");
static_assert(offsetof(FGivePlayerEloDefinition, PlayerID) == 0x000000, "Member 'FGivePlayerEloDefinition::PlayerID' has a wrong offset!");
static_assert(offsetof(FGivePlayerEloDefinition, CombatElo) == 0x000010, "Member 'FGivePlayerEloDefinition::CombatElo' has a wrong offset!");

// ScriptStruct DeceiveInc.HitConfirmData
// 0x0040 (0x0040 - 0x0000)
struct FHitConfirmData final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    ImpactPoint;                                       // 0x0008(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AProjectileWeapon*                      Weapon;                                            // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultingHealthPercentage;                         // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitType                                      HitType;                                           // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RawDamage;                                         // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageWithoutModifiers;                            // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0038(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitConfirmData) == 0x000008, "Wrong alignment on FHitConfirmData");
static_assert(sizeof(FHitConfirmData) == 0x000040, "Wrong size on FHitConfirmData");
static_assert(offsetof(FHitConfirmData, Victim) == 0x000000, "Member 'FHitConfirmData::Victim' has a wrong offset!");
static_assert(offsetof(FHitConfirmData, ImpactPoint) == 0x000008, "Member 'FHitConfirmData::ImpactPoint' has a wrong offset!");
static_assert(offsetof(FHitConfirmData, Weapon) == 0x000018, "Member 'FHitConfirmData::Weapon' has a wrong offset!");
static_assert(offsetof(FHitConfirmData, Damage) == 0x000020, "Member 'FHitConfirmData::Damage' has a wrong offset!");
static_assert(offsetof(FHitConfirmData, ResultingHealthPercentage) == 0x000024, "Member 'FHitConfirmData::ResultingHealthPercentage' has a wrong offset!");
static_assert(offsetof(FHitConfirmData, HitType) == 0x000028, "Member 'FHitConfirmData::HitType' has a wrong offset!");
static_assert(offsetof(FHitConfirmData, RawDamage) == 0x00002C, "Member 'FHitConfirmData::RawDamage' has a wrong offset!");
static_assert(offsetof(FHitConfirmData, DamageWithoutModifiers) == 0x000030, "Member 'FHitConfirmData::DamageWithoutModifiers' has a wrong offset!");
static_assert(offsetof(FHitConfirmData, HitComponent) == 0x000038, "Member 'FHitConfirmData::HitComponent' has a wrong offset!");

// ScriptStruct DeceiveInc.DILimitedTimeFeatureSettings
// 0x0018 (0x0018 - 0x0000)
struct FDILimitedTimeFeatureSettings
{
public:
	bool                                          bFeatureActive;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              FeatureUTCStartTime;                               // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              FeatureUTCEndTime;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDILimitedTimeFeatureSettings) == 0x000008, "Wrong alignment on FDILimitedTimeFeatureSettings");
static_assert(sizeof(FDILimitedTimeFeatureSettings) == 0x000018, "Wrong size on FDILimitedTimeFeatureSettings");
static_assert(offsetof(FDILimitedTimeFeatureSettings, bFeatureActive) == 0x000000, "Member 'FDILimitedTimeFeatureSettings::bFeatureActive' has a wrong offset!");
static_assert(offsetof(FDILimitedTimeFeatureSettings, FeatureUTCStartTime) == 0x000008, "Member 'FDILimitedTimeFeatureSettings::FeatureUTCStartTime' has a wrong offset!");
static_assert(offsetof(FDILimitedTimeFeatureSettings, FeatureUTCEndTime) == 0x000010, "Member 'FDILimitedTimeFeatureSettings::FeatureUTCEndTime' has a wrong offset!");

// ScriptStruct DeceiveInc.DISpecialAnnouncmentSettings
// 0x0118 (0x0130 - 0x0018)
struct FDISpecialAnnouncmentSettings final : public FDILimitedTimeFeatureSettings
{
public:
	TMap<ELocalizationLanguage, class FText>      LocalizedTitle;                                    // 0x0018(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<ELocalizationLanguage, class FText>      LocalizedText;                                     // 0x0068(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                ImageAsset;                                        // 0x00B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpecialAnnouncementType                      AnnouncementType;                                  // 0x00E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   WidgetClass;                                       // 0x00E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActionOnClick;                                     // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventName;                                         // 0x0120(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDISpecialAnnouncmentSettings) == 0x000008, "Wrong alignment on FDISpecialAnnouncmentSettings");
static_assert(sizeof(FDISpecialAnnouncmentSettings) == 0x000130, "Wrong size on FDISpecialAnnouncmentSettings");
static_assert(offsetof(FDISpecialAnnouncmentSettings, LocalizedTitle) == 0x000018, "Member 'FDISpecialAnnouncmentSettings::LocalizedTitle' has a wrong offset!");
static_assert(offsetof(FDISpecialAnnouncmentSettings, LocalizedText) == 0x000068, "Member 'FDISpecialAnnouncmentSettings::LocalizedText' has a wrong offset!");
static_assert(offsetof(FDISpecialAnnouncmentSettings, ImageAsset) == 0x0000B8, "Member 'FDISpecialAnnouncmentSettings::ImageAsset' has a wrong offset!");
static_assert(offsetof(FDISpecialAnnouncmentSettings, AnnouncementType) == 0x0000E0, "Member 'FDISpecialAnnouncmentSettings::AnnouncementType' has a wrong offset!");
static_assert(offsetof(FDISpecialAnnouncmentSettings, WidgetClass) == 0x0000E8, "Member 'FDISpecialAnnouncmentSettings::WidgetClass' has a wrong offset!");
static_assert(offsetof(FDISpecialAnnouncmentSettings, ActionOnClick) == 0x000110, "Member 'FDISpecialAnnouncmentSettings::ActionOnClick' has a wrong offset!");
static_assert(offsetof(FDISpecialAnnouncmentSettings, EventName) == 0x000120, "Member 'FDISpecialAnnouncmentSettings::EventName' has a wrong offset!");

// ScriptStruct DeceiveInc.LootBundleItemDefinition
// 0x0018 (0x0018 - 0x0000)
struct FLootBundleItemDefinition final
{
public:
	class FString                                 Itid;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Qty;                                               // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLootBundleItemDefinition) == 0x000008, "Wrong alignment on FLootBundleItemDefinition");
static_assert(sizeof(FLootBundleItemDefinition) == 0x000018, "Wrong size on FLootBundleItemDefinition");
static_assert(offsetof(FLootBundleItemDefinition, Itid) == 0x000000, "Member 'FLootBundleItemDefinition::Itid' has a wrong offset!");
static_assert(offsetof(FLootBundleItemDefinition, Qty) == 0x000010, "Member 'FLootBundleItemDefinition::Qty' has a wrong offset!");

// ScriptStruct DeceiveInc.LootBundleDefinition
// 0x0028 (0x0028 - 0x0000)
struct FLootBundleDefinition final
{
public:
	class FString                                 BundleId;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         CreatedOn;                                         // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLootBundleItemDefinition>      Loot;                                              // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLootBundleDefinition) == 0x000008, "Wrong alignment on FLootBundleDefinition");
static_assert(sizeof(FLootBundleDefinition) == 0x000028, "Wrong size on FLootBundleDefinition");
static_assert(offsetof(FLootBundleDefinition, BundleId) == 0x000000, "Member 'FLootBundleDefinition::BundleId' has a wrong offset!");
static_assert(offsetof(FLootBundleDefinition, CreatedOn) == 0x000010, "Member 'FLootBundleDefinition::CreatedOn' has a wrong offset!");
static_assert(offsetof(FLootBundleDefinition, Loot) == 0x000018, "Member 'FLootBundleDefinition::Loot' has a wrong offset!");

// ScriptStruct DeceiveInc.MeleeHitConfirmedData
// 0x0040 (0x0040 - 0x0000)
struct FMeleeHitConfirmedData final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    ImpactPoint;                                       // 0x0008(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    ImpactDirection;                                   // 0x0014(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    ImpactNormal;                                      // 0x0020(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentChargeLevel;                                // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Damage;                                            // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ResultingHealthPercentage;                         // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitType                                      HitType;                                           // 0x0032(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0038(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeleeHitConfirmedData) == 0x000008, "Wrong alignment on FMeleeHitConfirmedData");
static_assert(sizeof(FMeleeHitConfirmedData) == 0x000040, "Wrong size on FMeleeHitConfirmedData");
static_assert(offsetof(FMeleeHitConfirmedData, Victim) == 0x000000, "Member 'FMeleeHitConfirmedData::Victim' has a wrong offset!");
static_assert(offsetof(FMeleeHitConfirmedData, ImpactPoint) == 0x000008, "Member 'FMeleeHitConfirmedData::ImpactPoint' has a wrong offset!");
static_assert(offsetof(FMeleeHitConfirmedData, ImpactDirection) == 0x000014, "Member 'FMeleeHitConfirmedData::ImpactDirection' has a wrong offset!");
static_assert(offsetof(FMeleeHitConfirmedData, ImpactNormal) == 0x000020, "Member 'FMeleeHitConfirmedData::ImpactNormal' has a wrong offset!");
static_assert(offsetof(FMeleeHitConfirmedData, CurrentChargeLevel) == 0x00002C, "Member 'FMeleeHitConfirmedData::CurrentChargeLevel' has a wrong offset!");
static_assert(offsetof(FMeleeHitConfirmedData, Damage) == 0x000030, "Member 'FMeleeHitConfirmedData::Damage' has a wrong offset!");
static_assert(offsetof(FMeleeHitConfirmedData, ResultingHealthPercentage) == 0x000031, "Member 'FMeleeHitConfirmedData::ResultingHealthPercentage' has a wrong offset!");
static_assert(offsetof(FMeleeHitConfirmedData, HitType) == 0x000032, "Member 'FMeleeHitConfirmedData::HitType' has a wrong offset!");
static_assert(offsetof(FMeleeHitConfirmedData, HitComponent) == 0x000038, "Member 'FMeleeHitConfirmedData::HitComponent' has a wrong offset!");

// ScriptStruct DeceiveInc.LastInteractionData
// 0x0010 (0x0010 - 0x0000)
struct FLastInteractionData final
{
public:
	TWeakObjectPtr<class ADIPlayerState>          PlayerState;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         TimeOfInteract;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLastInteractionData) == 0x000008, "Wrong alignment on FLastInteractionData");
static_assert(sizeof(FLastInteractionData) == 0x000010, "Wrong size on FLastInteractionData");
static_assert(offsetof(FLastInteractionData, PlayerState) == 0x000000, "Member 'FLastInteractionData::PlayerState' has a wrong offset!");
static_assert(offsetof(FLastInteractionData, TimeOfInteract) == 0x000008, "Member 'FLastInteractionData::TimeOfInteract' has a wrong offset!");

// ScriptStruct DeceiveInc.CoverSourceInfo
// 0x0010 (0x0010 - 0x0000)
struct FCoverSourceInfo final
{
public:
	TArray<class AActor*>                         AffectingSource;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoverSourceInfo) == 0x000008, "Wrong alignment on FCoverSourceInfo");
static_assert(sizeof(FCoverSourceInfo) == 0x000010, "Wrong size on FCoverSourceInfo");
static_assert(offsetof(FCoverSourceInfo, AffectingSource) == 0x000000, "Member 'FCoverSourceInfo::AffectingSource' has a wrong offset!");

// ScriptStruct DeceiveInc.SBMagnetismZoneConfig
// 0x0128 (0x0128 - 0x0000)
struct FSBMagnetismZoneConfig final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     MagnetismRatioCurvePitch;                          // 0x0008(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     MagnetismRatioCurveYaw;                            // 0x0090(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         MinimumPitchMagnitudeToApplyPitchMagnetism;        // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumYawMagnitudeToApplyYawMagnetism;            // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumExtraCorrectedInputAmplitude;               // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBMagnetismZoneConfig) == 0x000008, "Wrong alignment on FSBMagnetismZoneConfig");
static_assert(sizeof(FSBMagnetismZoneConfig) == 0x000128, "Wrong size on FSBMagnetismZoneConfig");
static_assert(offsetof(FSBMagnetismZoneConfig, Radius) == 0x000000, "Member 'FSBMagnetismZoneConfig::Radius' has a wrong offset!");
static_assert(offsetof(FSBMagnetismZoneConfig, MagnetismRatioCurvePitch) == 0x000008, "Member 'FSBMagnetismZoneConfig::MagnetismRatioCurvePitch' has a wrong offset!");
static_assert(offsetof(FSBMagnetismZoneConfig, MagnetismRatioCurveYaw) == 0x000090, "Member 'FSBMagnetismZoneConfig::MagnetismRatioCurveYaw' has a wrong offset!");
static_assert(offsetof(FSBMagnetismZoneConfig, MinimumPitchMagnitudeToApplyPitchMagnetism) == 0x000118, "Member 'FSBMagnetismZoneConfig::MinimumPitchMagnitudeToApplyPitchMagnetism' has a wrong offset!");
static_assert(offsetof(FSBMagnetismZoneConfig, MinimumYawMagnitudeToApplyYawMagnetism) == 0x00011C, "Member 'FSBMagnetismZoneConfig::MinimumYawMagnitudeToApplyYawMagnetism' has a wrong offset!");
static_assert(offsetof(FSBMagnetismZoneConfig, MaximumExtraCorrectedInputAmplitude) == 0x000120, "Member 'FSBMagnetismZoneConfig::MaximumExtraCorrectedInputAmplitude' has a wrong offset!");

// ScriptStruct DeceiveInc.ControlledByDisguiseData
// 0x001C (0x001C - 0x0000)
struct FControlledByDisguiseData final
{
public:
	bool                                          bControlledByDisguise;                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SocialInteractSpringArm3PPos;                      // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WantedSpyPos;                                      // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FControlledByDisguiseData) == 0x000004, "Wrong alignment on FControlledByDisguiseData");
static_assert(sizeof(FControlledByDisguiseData) == 0x00001C, "Wrong size on FControlledByDisguiseData");
static_assert(offsetof(FControlledByDisguiseData, bControlledByDisguise) == 0x000000, "Member 'FControlledByDisguiseData::bControlledByDisguise' has a wrong offset!");
static_assert(offsetof(FControlledByDisguiseData, SocialInteractSpringArm3PPos) == 0x000004, "Member 'FControlledByDisguiseData::SocialInteractSpringArm3PPos' has a wrong offset!");
static_assert(offsetof(FControlledByDisguiseData, WantedSpyPos) == 0x000010, "Member 'FControlledByDisguiseData::WantedSpyPos' has a wrong offset!");

// ScriptStruct DeceiveInc.DisguiseReplicationData
// 0x0010 (0x0010 - 0x0000)
struct FDisguiseReplicationData final
{
public:
	class ANPCCharacter*                          Disguise;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideVisualFeedback;                               // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyOldDisguise;                               // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDisguiseReplicationData) == 0x000008, "Wrong alignment on FDisguiseReplicationData");
static_assert(sizeof(FDisguiseReplicationData) == 0x000010, "Wrong size on FDisguiseReplicationData");
static_assert(offsetof(FDisguiseReplicationData, Disguise) == 0x000000, "Member 'FDisguiseReplicationData::Disguise' has a wrong offset!");
static_assert(offsetof(FDisguiseReplicationData, bHideVisualFeedback) == 0x000008, "Member 'FDisguiseReplicationData::bHideVisualFeedback' has a wrong offset!");
static_assert(offsetof(FDisguiseReplicationData, bDestroyOldDisguise) == 0x000009, "Member 'FDisguiseReplicationData::bDestroyOldDisguise' has a wrong offset!");

// ScriptStruct DeceiveInc.HeatStateData
// 0x0008 (0x0008 - 0x0000)
struct FHeatStateData final
{
public:
	int32                                         HeatLevel;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeatCount;                                         // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHeatStateData) == 0x000004, "Wrong alignment on FHeatStateData");
static_assert(sizeof(FHeatStateData) == 0x000008, "Wrong size on FHeatStateData");
static_assert(offsetof(FHeatStateData, HeatLevel) == 0x000000, "Member 'FHeatStateData::HeatLevel' has a wrong offset!");
static_assert(offsetof(FHeatStateData, HeatCount) == 0x000004, "Member 'FHeatStateData::HeatCount' has a wrong offset!");

// ScriptStruct DeceiveInc.BaseGamePhaseData
// 0x0050 (0x0050 - 0x0000)
struct FBaseGamePhaseData
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   PhaseTimerTxt;                                     // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PhaseMenuClass;                                    // 0x0020(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowRespawn;                                     // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowFactionChanges;                              // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBaseGamePhaseData) == 0x000008, "Wrong alignment on FBaseGamePhaseData");
static_assert(sizeof(FBaseGamePhaseData) == 0x000050, "Wrong size on FBaseGamePhaseData");
static_assert(offsetof(FBaseGamePhaseData, PhaseTimerTxt) == 0x000008, "Member 'FBaseGamePhaseData::PhaseTimerTxt' has a wrong offset!");
static_assert(offsetof(FBaseGamePhaseData, PhaseMenuClass) == 0x000020, "Member 'FBaseGamePhaseData::PhaseMenuClass' has a wrong offset!");
static_assert(offsetof(FBaseGamePhaseData, bAllowRespawn) == 0x000048, "Member 'FBaseGamePhaseData::bAllowRespawn' has a wrong offset!");
static_assert(offsetof(FBaseGamePhaseData, bAllowFactionChanges) == 0x000049, "Member 'FBaseGamePhaseData::bAllowFactionChanges' has a wrong offset!");

// ScriptStruct DeceiveInc.PregameLobbyPhaseData
// 0x0008 (0x0058 - 0x0050)
struct FPregameLobbyPhaseData final : public FBaseGamePhaseData
{
public:
	int32                                         DefaultPhaseDuration;                              // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPregameLobbyPhaseData) == 0x000008, "Wrong alignment on FPregameLobbyPhaseData");
static_assert(sizeof(FPregameLobbyPhaseData) == 0x000058, "Wrong size on FPregameLobbyPhaseData");
static_assert(offsetof(FPregameLobbyPhaseData, DefaultPhaseDuration) == 0x000050, "Member 'FPregameLobbyPhaseData::DefaultPhaseDuration' has a wrong offset!");

// ScriptStruct DeceiveInc.UndercoverReplicationData
// 0x0008 (0x0008 - 0x0000)
struct FUndercoverReplicationData final
{
public:
	bool                                          bShouldBeUndercover;                               // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        Flags;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUndercoverReplicationData) == 0x000004, "Wrong alignment on FUndercoverReplicationData");
static_assert(sizeof(FUndercoverReplicationData) == 0x000008, "Wrong size on FUndercoverReplicationData");
static_assert(offsetof(FUndercoverReplicationData, bShouldBeUndercover) == 0x000000, "Member 'FUndercoverReplicationData::bShouldBeUndercover' has a wrong offset!");
static_assert(offsetof(FUndercoverReplicationData, Flags) == 0x000004, "Member 'FUndercoverReplicationData::Flags' has a wrong offset!");

// ScriptStruct DeceiveInc.AgreementResponse
// 0x0030 (0x0030 - 0x0000)
struct FAgreementResponse final
{
public:
	class FString                                 UserId;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AgreementName;                                     // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DateSigned;                                        // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAgreementResponse) == 0x000008, "Wrong alignment on FAgreementResponse");
static_assert(sizeof(FAgreementResponse) == 0x000030, "Wrong size on FAgreementResponse");
static_assert(offsetof(FAgreementResponse, UserId) == 0x000000, "Member 'FAgreementResponse::UserId' has a wrong offset!");
static_assert(offsetof(FAgreementResponse, AgreementName) == 0x000010, "Member 'FAgreementResponse::AgreementName' has a wrong offset!");
static_assert(offsetof(FAgreementResponse, DateSigned) == 0x000020, "Member 'FAgreementResponse::DateSigned' has a wrong offset!");

// ScriptStruct DeceiveInc.LocalPlayerTalkingEvent
// 0x0008 (0x0008 - 0x0000)
struct FLocalPlayerTalkingEvent final
{
public:
	bool                                          bIsTalking;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Amplitude;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLocalPlayerTalkingEvent) == 0x000004, "Wrong alignment on FLocalPlayerTalkingEvent");
static_assert(sizeof(FLocalPlayerTalkingEvent) == 0x000008, "Wrong size on FLocalPlayerTalkingEvent");
static_assert(offsetof(FLocalPlayerTalkingEvent, bIsTalking) == 0x000000, "Member 'FLocalPlayerTalkingEvent::bIsTalking' has a wrong offset!");
static_assert(offsetof(FLocalPlayerTalkingEvent, Amplitude) == 0x000004, "Member 'FLocalPlayerTalkingEvent::Amplitude' has a wrong offset!");

// ScriptStruct DeceiveInc.HeatPenalityEntryData
// 0x0010 (0x0010 - 0x0000)
struct FHeatPenalityEntryData final
{
public:
	TSubclassOf<class AVictimEffect>              PenalityEffect;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenalityDuration;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHeatPenalityEntryData) == 0x000008, "Wrong alignment on FHeatPenalityEntryData");
static_assert(sizeof(FHeatPenalityEntryData) == 0x000010, "Wrong size on FHeatPenalityEntryData");
static_assert(offsetof(FHeatPenalityEntryData, PenalityEffect) == 0x000000, "Member 'FHeatPenalityEntryData::PenalityEffect' has a wrong offset!");
static_assert(offsetof(FHeatPenalityEntryData, PenalityDuration) == 0x000008, "Member 'FHeatPenalityEntryData::PenalityDuration' has a wrong offset!");

// ScriptStruct DeceiveInc.HeatLevelPenalityData
// 0x0010 (0x0010 - 0x0000)
struct FHeatLevelPenalityData final
{
public:
	TArray<struct FHeatPenalityEntryData>         EffectPerLevel;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHeatLevelPenalityData) == 0x000008, "Wrong alignment on FHeatLevelPenalityData");
static_assert(sizeof(FHeatLevelPenalityData) == 0x000010, "Wrong size on FHeatLevelPenalityData");
static_assert(offsetof(FHeatLevelPenalityData, EffectPerLevel) == 0x000000, "Member 'FHeatLevelPenalityData::EffectPerLevel' has a wrong offset!");

// ScriptStruct DeceiveInc.HeatSetupData
// 0x0050 (0x0050 - 0x0000)
struct FHeatSetupData final
{
public:
	TArray<int32>                                 Threasholds;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MaxHeat;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHeatLevelPenalityData>         PenalitiesPerLevel;                                // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 NPCDamageHeatPerPool;                              // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ScoldHeatPerSeccond;                               // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeatDelayForSpyHit;                                // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeatDelayPassiveGain;                              // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeatDelayAggroPostCover;                           // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayToDecay;                                      // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecayRate;                                         // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHeatSetupData) == 0x000008, "Wrong alignment on FHeatSetupData");
static_assert(sizeof(FHeatSetupData) == 0x000050, "Wrong size on FHeatSetupData");
static_assert(offsetof(FHeatSetupData, Threasholds) == 0x000000, "Member 'FHeatSetupData::Threasholds' has a wrong offset!");
static_assert(offsetof(FHeatSetupData, MaxHeat) == 0x000010, "Member 'FHeatSetupData::MaxHeat' has a wrong offset!");
static_assert(offsetof(FHeatSetupData, PenalitiesPerLevel) == 0x000018, "Member 'FHeatSetupData::PenalitiesPerLevel' has a wrong offset!");
static_assert(offsetof(FHeatSetupData, NPCDamageHeatPerPool) == 0x000028, "Member 'FHeatSetupData::NPCDamageHeatPerPool' has a wrong offset!");
static_assert(offsetof(FHeatSetupData, ScoldHeatPerSeccond) == 0x000038, "Member 'FHeatSetupData::ScoldHeatPerSeccond' has a wrong offset!");
static_assert(offsetof(FHeatSetupData, HeatDelayForSpyHit) == 0x00003C, "Member 'FHeatSetupData::HeatDelayForSpyHit' has a wrong offset!");
static_assert(offsetof(FHeatSetupData, HeatDelayPassiveGain) == 0x000040, "Member 'FHeatSetupData::HeatDelayPassiveGain' has a wrong offset!");
static_assert(offsetof(FHeatSetupData, HeatDelayAggroPostCover) == 0x000044, "Member 'FHeatSetupData::HeatDelayAggroPostCover' has a wrong offset!");
static_assert(offsetof(FHeatSetupData, DelayToDecay) == 0x000048, "Member 'FHeatSetupData::DelayToDecay' has a wrong offset!");
static_assert(offsetof(FHeatSetupData, DecayRate) == 0x00004C, "Member 'FHeatSetupData::DecayRate' has a wrong offset!");

// ScriptStruct DeceiveInc.DamageBehavior
// 0x00D8 (0x00D8 - 0x0000)
struct FDamageBehavior final
{
public:
	class FName                                   BehaviorName;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalDamageMultiplier;                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimbDamageMultiplier;                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxiumEffectiveRange;                              // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     NormalizedDamageFalloffCurve;                      // 0x0018(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EHitType                                      ForceHitType;                                      // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   EffectOnPawnHit;                                   // 0x00A8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DoEffectOnEnemyFactionOnly;                        // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageBehavior) == 0x000008, "Wrong alignment on FDamageBehavior");
static_assert(sizeof(FDamageBehavior) == 0x0000D8, "Wrong size on FDamageBehavior");
static_assert(offsetof(FDamageBehavior, BehaviorName) == 0x000000, "Member 'FDamageBehavior::BehaviorName' has a wrong offset!");
static_assert(offsetof(FDamageBehavior, Damage) == 0x000008, "Member 'FDamageBehavior::Damage' has a wrong offset!");
static_assert(offsetof(FDamageBehavior, CriticalDamageMultiplier) == 0x00000C, "Member 'FDamageBehavior::CriticalDamageMultiplier' has a wrong offset!");
static_assert(offsetof(FDamageBehavior, LimbDamageMultiplier) == 0x000010, "Member 'FDamageBehavior::LimbDamageMultiplier' has a wrong offset!");
static_assert(offsetof(FDamageBehavior, MaxiumEffectiveRange) == 0x000014, "Member 'FDamageBehavior::MaxiumEffectiveRange' has a wrong offset!");
static_assert(offsetof(FDamageBehavior, NormalizedDamageFalloffCurve) == 0x000018, "Member 'FDamageBehavior::NormalizedDamageFalloffCurve' has a wrong offset!");
static_assert(offsetof(FDamageBehavior, ForceHitType) == 0x0000A0, "Member 'FDamageBehavior::ForceHitType' has a wrong offset!");
static_assert(offsetof(FDamageBehavior, EffectOnPawnHit) == 0x0000A8, "Member 'FDamageBehavior::EffectOnPawnHit' has a wrong offset!");
static_assert(offsetof(FDamageBehavior, DoEffectOnEnemyFactionOnly) == 0x0000D0, "Member 'FDamageBehavior::DoEffectOnEnemyFactionOnly' has a wrong offset!");

// ScriptStruct DeceiveInc.RewardInfo
// 0x0010 (0x0010 - 0x0000)
struct FRewardInfo final
{
public:
	class UDIPrimaryDataAsset*                    RewardDataAsset;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardAmount;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinWeightToSkipRareLoot;                           // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRewardInfo) == 0x000008, "Wrong alignment on FRewardInfo");
static_assert(sizeof(FRewardInfo) == 0x000010, "Wrong size on FRewardInfo");
static_assert(offsetof(FRewardInfo, RewardDataAsset) == 0x000000, "Member 'FRewardInfo::RewardDataAsset' has a wrong offset!");
static_assert(offsetof(FRewardInfo, RewardAmount) == 0x000008, "Member 'FRewardInfo::RewardAmount' has a wrong offset!");
static_assert(offsetof(FRewardInfo, MinWeightToSkipRareLoot) == 0x00000C, "Member 'FRewardInfo::MinWeightToSkipRareLoot' has a wrong offset!");

// ScriptStruct DeceiveInc.LevelReward
// 0x0010 (0x0010 - 0x0000)
struct FLevelReward final
{
public:
	TArray<struct FRewardInfo>                    RewardsList;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelReward) == 0x000008, "Wrong alignment on FLevelReward");
static_assert(sizeof(FLevelReward) == 0x000010, "Wrong size on FLevelReward");
static_assert(offsetof(FLevelReward, RewardsList) == 0x000000, "Member 'FLevelReward::RewardsList' has a wrong offset!");

// ScriptStruct DeceiveInc.CrouchFatigueSetting
// 0x0008 (0x0008 - 0x0000)
struct FCrouchFatigueSetting final
{
public:
	int32                                         CrouchCountThreshold;                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowModifier;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrouchFatigueSetting) == 0x000004, "Wrong alignment on FCrouchFatigueSetting");
static_assert(sizeof(FCrouchFatigueSetting) == 0x000008, "Wrong size on FCrouchFatigueSetting");
static_assert(offsetof(FCrouchFatigueSetting, CrouchCountThreshold) == 0x000000, "Member 'FCrouchFatigueSetting::CrouchCountThreshold' has a wrong offset!");
static_assert(offsetof(FCrouchFatigueSetting, SlowModifier) == 0x000004, "Member 'FCrouchFatigueSetting::SlowModifier' has a wrong offset!");

// ScriptStruct DeceiveInc.GameSessionConnectionInfo
// 0x0028 (0x0028 - 0x0000)
struct FGameSessionConnectionInfo final
{
public:
	class FString                                 IpAddress;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Port;                                              // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerSessionId;                                   // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameSessionConnectionInfo) == 0x000008, "Wrong alignment on FGameSessionConnectionInfo");
static_assert(sizeof(FGameSessionConnectionInfo) == 0x000028, "Wrong size on FGameSessionConnectionInfo");
static_assert(offsetof(FGameSessionConnectionInfo, IpAddress) == 0x000000, "Member 'FGameSessionConnectionInfo::IpAddress' has a wrong offset!");
static_assert(offsetof(FGameSessionConnectionInfo, Port) == 0x000010, "Member 'FGameSessionConnectionInfo::Port' has a wrong offset!");
static_assert(offsetof(FGameSessionConnectionInfo, PlayerSessionId) == 0x000018, "Member 'FGameSessionConnectionInfo::PlayerSessionId' has a wrong offset!");

// ScriptStruct DeceiveInc.PrecacheBreadcrumb
// 0x0018 (0x0018 - 0x0000)
struct FPrecacheBreadcrumb final
{
public:
	TArray<class ABaseBreadcrumbsActor*>          Sources;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         CurIndex;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPrecacheBreadcrumb) == 0x000008, "Wrong alignment on FPrecacheBreadcrumb");
static_assert(sizeof(FPrecacheBreadcrumb) == 0x000018, "Wrong size on FPrecacheBreadcrumb");
static_assert(offsetof(FPrecacheBreadcrumb, Sources) == 0x000000, "Member 'FPrecacheBreadcrumb::Sources' has a wrong offset!");
static_assert(offsetof(FPrecacheBreadcrumb, CurIndex) == 0x000010, "Member 'FPrecacheBreadcrumb::CurIndex' has a wrong offset!");

// ScriptStruct DeceiveInc.ObjectToSpawn
// 0x0040 (0x0040 - 0x0000)
struct FObjectToSpawn final
{
public:
	class FString                                 ObjectType;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     BPClassToSpawn;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OccurenceFactor;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObjectScore;                                       // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MaxOnePerRoom;                                     // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           RoomExclusionGroups;                               // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          CanFillRoom;                                       // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanSpawnInPrivateLobbies;                          // 0x0039(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnOnStart;                                     // 0x003A(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x1];                                       // 0x003B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpawnPriority;                                     // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectToSpawn) == 0x000008, "Wrong alignment on FObjectToSpawn");
static_assert(sizeof(FObjectToSpawn) == 0x000040, "Wrong size on FObjectToSpawn");
static_assert(offsetof(FObjectToSpawn, ObjectType) == 0x000000, "Member 'FObjectToSpawn::ObjectType' has a wrong offset!");
static_assert(offsetof(FObjectToSpawn, BPClassToSpawn) == 0x000010, "Member 'FObjectToSpawn::BPClassToSpawn' has a wrong offset!");
static_assert(offsetof(FObjectToSpawn, OccurenceFactor) == 0x000018, "Member 'FObjectToSpawn::OccurenceFactor' has a wrong offset!");
static_assert(offsetof(FObjectToSpawn, ObjectScore) == 0x00001C, "Member 'FObjectToSpawn::ObjectScore' has a wrong offset!");
static_assert(offsetof(FObjectToSpawn, MaxOnePerRoom) == 0x000020, "Member 'FObjectToSpawn::MaxOnePerRoom' has a wrong offset!");
static_assert(offsetof(FObjectToSpawn, RoomExclusionGroups) == 0x000028, "Member 'FObjectToSpawn::RoomExclusionGroups' has a wrong offset!");
static_assert(offsetof(FObjectToSpawn, CanFillRoom) == 0x000038, "Member 'FObjectToSpawn::CanFillRoom' has a wrong offset!");
static_assert(offsetof(FObjectToSpawn, CanSpawnInPrivateLobbies) == 0x000039, "Member 'FObjectToSpawn::CanSpawnInPrivateLobbies' has a wrong offset!");
static_assert(offsetof(FObjectToSpawn, bSpawnOnStart) == 0x00003A, "Member 'FObjectToSpawn::bSpawnOnStart' has a wrong offset!");
static_assert(offsetof(FObjectToSpawn, SpawnPriority) == 0x00003C, "Member 'FObjectToSpawn::SpawnPriority' has a wrong offset!");

// ScriptStruct DeceiveInc.ChromaticFeedback
// 0x0018 (0x0018 - 0x0000)
struct FChromaticFeedback final
{
public:
	class FString                                 EffectName;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHighlightMappedKeys;                              // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChromaticFeedbackPriority                    Priority;                                          // 0x0012(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChromaticFeedback) == 0x000008, "Wrong alignment on FChromaticFeedback");
static_assert(sizeof(FChromaticFeedback) == 0x000018, "Wrong size on FChromaticFeedback");
static_assert(offsetof(FChromaticFeedback, EffectName) == 0x000000, "Member 'FChromaticFeedback::EffectName' has a wrong offset!");
static_assert(offsetof(FChromaticFeedback, bLooping) == 0x000010, "Member 'FChromaticFeedback::bLooping' has a wrong offset!");
static_assert(offsetof(FChromaticFeedback, bHighlightMappedKeys) == 0x000011, "Member 'FChromaticFeedback::bHighlightMappedKeys' has a wrong offset!");
static_assert(offsetof(FChromaticFeedback, Priority) == 0x000012, "Member 'FChromaticFeedback::Priority' has a wrong offset!");

// ScriptStruct DeceiveInc.ChromaticFeedbackSettings
// 0x0050 (0x0050 - 0x0000)
struct FChromaticFeedbackSettings final
{
public:
	TMap<EChromaFeedbackEventType, struct FChromaticFeedback> Effects;                                           // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChromaticFeedbackSettings) == 0x000008, "Wrong alignment on FChromaticFeedbackSettings");
static_assert(sizeof(FChromaticFeedbackSettings) == 0x000050, "Wrong size on FChromaticFeedbackSettings");
static_assert(offsetof(FChromaticFeedbackSettings, Effects) == 0x000000, "Member 'FChromaticFeedbackSettings::Effects' has a wrong offset!");

// ScriptStruct DeceiveInc.RollKickData
// 0x0018 (0x0018 - 0x0000)
struct FRollKickData final
{
public:
	class UCurveFloat*                            RollKickCurve;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollKickDuration;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollKickDegree;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollKickRecoverDuration;                           // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRollKickData) == 0x000008, "Wrong alignment on FRollKickData");
static_assert(sizeof(FRollKickData) == 0x000018, "Wrong size on FRollKickData");
static_assert(offsetof(FRollKickData, RollKickCurve) == 0x000000, "Member 'FRollKickData::RollKickCurve' has a wrong offset!");
static_assert(offsetof(FRollKickData, RollKickDuration) == 0x000008, "Member 'FRollKickData::RollKickDuration' has a wrong offset!");
static_assert(offsetof(FRollKickData, RollKickDegree) == 0x00000C, "Member 'FRollKickData::RollKickDegree' has a wrong offset!");
static_assert(offsetof(FRollKickData, RollKickRecoverDuration) == 0x000010, "Member 'FRollKickData::RollKickRecoverDuration' has a wrong offset!");

// ScriptStruct DeceiveInc.RecoilData
// 0x0030 (0x0030 - 0x0000)
struct FRecoilData final
{
public:
	class UCurveFloat*                            RecoilCurve;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilDuration;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RecoilPerShot;                                     // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilHorizontalVariance;                          // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilVerticalVariance;                            // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CompensationSpeed;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CompensationHorizontalRatio;                       // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CompensationVerticalRatio;                         // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilBuildUpMultiplier;                           // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilBuildUpFadeOutDuration;                      // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRecoilData) == 0x000008, "Wrong alignment on FRecoilData");
static_assert(sizeof(FRecoilData) == 0x000030, "Wrong size on FRecoilData");
static_assert(offsetof(FRecoilData, RecoilCurve) == 0x000000, "Member 'FRecoilData::RecoilCurve' has a wrong offset!");
static_assert(offsetof(FRecoilData, RecoilDuration) == 0x000008, "Member 'FRecoilData::RecoilDuration' has a wrong offset!");
static_assert(offsetof(FRecoilData, RecoilPerShot) == 0x00000C, "Member 'FRecoilData::RecoilPerShot' has a wrong offset!");
static_assert(offsetof(FRecoilData, RecoilHorizontalVariance) == 0x000014, "Member 'FRecoilData::RecoilHorizontalVariance' has a wrong offset!");
static_assert(offsetof(FRecoilData, RecoilVerticalVariance) == 0x000018, "Member 'FRecoilData::RecoilVerticalVariance' has a wrong offset!");
static_assert(offsetof(FRecoilData, CompensationSpeed) == 0x00001C, "Member 'FRecoilData::CompensationSpeed' has a wrong offset!");
static_assert(offsetof(FRecoilData, CompensationHorizontalRatio) == 0x000020, "Member 'FRecoilData::CompensationHorizontalRatio' has a wrong offset!");
static_assert(offsetof(FRecoilData, CompensationVerticalRatio) == 0x000024, "Member 'FRecoilData::CompensationVerticalRatio' has a wrong offset!");
static_assert(offsetof(FRecoilData, RecoilBuildUpMultiplier) == 0x000028, "Member 'FRecoilData::RecoilBuildUpMultiplier' has a wrong offset!");
static_assert(offsetof(FRecoilData, RecoilBuildUpFadeOutDuration) == 0x00002C, "Member 'FRecoilData::RecoilBuildUpFadeOutDuration' has a wrong offset!");

// ScriptStruct DeceiveInc.SocialBatteryPerLevelData
// 0x000C (0x000C - 0x0000)
struct FSocialBatteryPerLevelData final
{
public:
	float                                         Cap;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickRate;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickDamage;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSocialBatteryPerLevelData) == 0x000004, "Wrong alignment on FSocialBatteryPerLevelData");
static_assert(sizeof(FSocialBatteryPerLevelData) == 0x00000C, "Wrong size on FSocialBatteryPerLevelData");
static_assert(offsetof(FSocialBatteryPerLevelData, Cap) == 0x000000, "Member 'FSocialBatteryPerLevelData::Cap' has a wrong offset!");
static_assert(offsetof(FSocialBatteryPerLevelData, TickRate) == 0x000004, "Member 'FSocialBatteryPerLevelData::TickRate' has a wrong offset!");
static_assert(offsetof(FSocialBatteryPerLevelData, TickDamage) == 0x000008, "Member 'FSocialBatteryPerLevelData::TickDamage' has a wrong offset!");

// ScriptStruct DeceiveInc.SocialBatteryData
// 0x0060 (0x0060 - 0x0000)
struct FSocialBatteryData final
{
public:
	float                                         TickRate;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickDamage;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ESecurityLevel, struct FSocialBatteryPerLevelData> PerLevel;                                          // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSubclassOf<class AVictimEffect>              HealingEffect;                                     // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSocialBatteryData) == 0x000008, "Wrong alignment on FSocialBatteryData");
static_assert(sizeof(FSocialBatteryData) == 0x000060, "Wrong size on FSocialBatteryData");
static_assert(offsetof(FSocialBatteryData, TickRate) == 0x000000, "Member 'FSocialBatteryData::TickRate' has a wrong offset!");
static_assert(offsetof(FSocialBatteryData, TickDamage) == 0x000004, "Member 'FSocialBatteryData::TickDamage' has a wrong offset!");
static_assert(offsetof(FSocialBatteryData, PerLevel) == 0x000008, "Member 'FSocialBatteryData::PerLevel' has a wrong offset!");
static_assert(offsetof(FSocialBatteryData, HealingEffect) == 0x000058, "Member 'FSocialBatteryData::HealingEffect' has a wrong offset!");

// ScriptStruct DeceiveInc.DISerializedDeckEntry
// 0x0010 (0x0010 - 0x0000)
struct FDISerializedDeckEntry final
{
public:
	TArray<EPowerupType>                          EquippedPowerups;                                  // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDISerializedDeckEntry) == 0x000008, "Wrong alignment on FDISerializedDeckEntry");
static_assert(sizeof(FDISerializedDeckEntry) == 0x000010, "Wrong size on FDISerializedDeckEntry");
static_assert(offsetof(FDISerializedDeckEntry, EquippedPowerups) == 0x000000, "Member 'FDISerializedDeckEntry::EquippedPowerups' has a wrong offset!");

// ScriptStruct DeceiveInc.DINetInfoClientSettings
// 0x0014 (0x0014 - 0x0000)
struct FDINetInfoClientSettings final
{
public:
	float                                         MinimumIconDisplayTime;                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BadPingThreshold;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BadServerPerfThreshold;                            // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BadPacketLossThreshold;                            // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowRegion;                                       // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowServerFrameTime;                              // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowServerVersion;                                // 0x0012(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowSessionID;                                    // 0x0013(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDINetInfoClientSettings) == 0x000004, "Wrong alignment on FDINetInfoClientSettings");
static_assert(sizeof(FDINetInfoClientSettings) == 0x000014, "Wrong size on FDINetInfoClientSettings");
static_assert(offsetof(FDINetInfoClientSettings, MinimumIconDisplayTime) == 0x000000, "Member 'FDINetInfoClientSettings::MinimumIconDisplayTime' has a wrong offset!");
static_assert(offsetof(FDINetInfoClientSettings, BadPingThreshold) == 0x000004, "Member 'FDINetInfoClientSettings::BadPingThreshold' has a wrong offset!");
static_assert(offsetof(FDINetInfoClientSettings, BadServerPerfThreshold) == 0x000008, "Member 'FDINetInfoClientSettings::BadServerPerfThreshold' has a wrong offset!");
static_assert(offsetof(FDINetInfoClientSettings, BadPacketLossThreshold) == 0x00000C, "Member 'FDINetInfoClientSettings::BadPacketLossThreshold' has a wrong offset!");
static_assert(offsetof(FDINetInfoClientSettings, bShowRegion) == 0x000010, "Member 'FDINetInfoClientSettings::bShowRegion' has a wrong offset!");
static_assert(offsetof(FDINetInfoClientSettings, bShowServerFrameTime) == 0x000011, "Member 'FDINetInfoClientSettings::bShowServerFrameTime' has a wrong offset!");
static_assert(offsetof(FDINetInfoClientSettings, bShowServerVersion) == 0x000012, "Member 'FDINetInfoClientSettings::bShowServerVersion' has a wrong offset!");
static_assert(offsetof(FDINetInfoClientSettings, bShowSessionID) == 0x000013, "Member 'FDINetInfoClientSettings::bShowSessionID' has a wrong offset!");

// ScriptStruct DeceiveInc.GameLiftMatchmakerPlayer
// 0x0010 (0x0010 - 0x0000)
struct FGameLiftMatchmakerPlayer final
{
public:
	class FString                                 BanditId;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameLiftMatchmakerPlayer) == 0x000008, "Wrong alignment on FGameLiftMatchmakerPlayer");
static_assert(sizeof(FGameLiftMatchmakerPlayer) == 0x000010, "Wrong size on FGameLiftMatchmakerPlayer");
static_assert(offsetof(FGameLiftMatchmakerPlayer, BanditId) == 0x000000, "Member 'FGameLiftMatchmakerPlayer::BanditId' has a wrong offset!");

// ScriptStruct DeceiveInc.GameLiftMatchmakerTeam
// 0x0020 (0x0020 - 0x0000)
struct FGameLiftMatchmakerTeam final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameLiftMatchmakerPlayer>      Players;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameLiftMatchmakerTeam) == 0x000008, "Wrong alignment on FGameLiftMatchmakerTeam");
static_assert(sizeof(FGameLiftMatchmakerTeam) == 0x000020, "Wrong size on FGameLiftMatchmakerTeam");
static_assert(offsetof(FGameLiftMatchmakerTeam, Name) == 0x000000, "Member 'FGameLiftMatchmakerTeam::Name' has a wrong offset!");
static_assert(offsetof(FGameLiftMatchmakerTeam, Players) == 0x000010, "Member 'FGameLiftMatchmakerTeam::Players' has a wrong offset!");

// ScriptStruct DeceiveInc.BaseMeleeAttackBalancingData
// 0x0008 (0x0010 - 0x0008)
struct FBaseMeleeAttackBalancingData final : public FTableRowBase
{
public:
	float                                         TEMP_MeleeDamage;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBaseMeleeAttackBalancingData) == 0x000008, "Wrong alignment on FBaseMeleeAttackBalancingData");
static_assert(sizeof(FBaseMeleeAttackBalancingData) == 0x000010, "Wrong size on FBaseMeleeAttackBalancingData");
static_assert(offsetof(FBaseMeleeAttackBalancingData, TEMP_MeleeDamage) == 0x000008, "Member 'FBaseMeleeAttackBalancingData::TEMP_MeleeDamage' has a wrong offset!");

// ScriptStruct DeceiveInc.UpdatedItemResponse
// 0x0038 (0x0038 - 0x0000)
struct FUpdatedItemResponse final
{
public:
	int64                                         UpdatedOn;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ConsumedOn;                                        // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         RemainingTime;                                     // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ItemId;                                            // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Seen;                                              // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUpdatedItemResponse) == 0x000008, "Wrong alignment on FUpdatedItemResponse");
static_assert(sizeof(FUpdatedItemResponse) == 0x000038, "Wrong size on FUpdatedItemResponse");
static_assert(offsetof(FUpdatedItemResponse, UpdatedOn) == 0x000000, "Member 'FUpdatedItemResponse::UpdatedOn' has a wrong offset!");
static_assert(offsetof(FUpdatedItemResponse, ConsumedOn) == 0x000008, "Member 'FUpdatedItemResponse::ConsumedOn' has a wrong offset!");
static_assert(offsetof(FUpdatedItemResponse, RemainingTime) == 0x000010, "Member 'FUpdatedItemResponse::RemainingTime' has a wrong offset!");
static_assert(offsetof(FUpdatedItemResponse, Quantity) == 0x000018, "Member 'FUpdatedItemResponse::Quantity' has a wrong offset!");
static_assert(offsetof(FUpdatedItemResponse, ItemId) == 0x000020, "Member 'FUpdatedItemResponse::ItemId' has a wrong offset!");
static_assert(offsetof(FUpdatedItemResponse, Seen) == 0x000030, "Member 'FUpdatedItemResponse::Seen' has a wrong offset!");

// ScriptStruct DeceiveInc.UpdatedInventoryResponse
// 0x0010 (0x0010 - 0x0000)
struct FUpdatedInventoryResponse final
{
public:
	TArray<struct FUpdatedItemResponse>           UpdatedItems;                                      // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUpdatedInventoryResponse) == 0x000008, "Wrong alignment on FUpdatedInventoryResponse");
static_assert(sizeof(FUpdatedInventoryResponse) == 0x000010, "Wrong size on FUpdatedInventoryResponse");
static_assert(offsetof(FUpdatedInventoryResponse, UpdatedItems) == 0x000000, "Member 'FUpdatedInventoryResponse::UpdatedItems' has a wrong offset!");

// ScriptStruct DeceiveInc.DroppedInvCacheEntry
// 0x0010 (0x0010 - 0x0000)
struct FDroppedInvCacheEntry final
{
public:
	TArray<class ABasePickableActor*>             CacheItems;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDroppedInvCacheEntry) == 0x000008, "Wrong alignment on FDroppedInvCacheEntry");
static_assert(sizeof(FDroppedInvCacheEntry) == 0x000010, "Wrong size on FDroppedInvCacheEntry");
static_assert(offsetof(FDroppedInvCacheEntry, CacheItems) == 0x000000, "Member 'FDroppedInvCacheEntry::CacheItems' has a wrong offset!");

// ScriptStruct DeceiveInc.AceActiveTrailVFXData
// 0x0080 (0x0080 - 0x0000)
struct FAceActiveTrailVFXData final
{
public:
	class AActor*                                 VFXActor;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x78];                                       // 0x0008(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAceActiveTrailVFXData) == 0x000008, "Wrong alignment on FAceActiveTrailVFXData");
static_assert(sizeof(FAceActiveTrailVFXData) == 0x000080, "Wrong size on FAceActiveTrailVFXData");
static_assert(offsetof(FAceActiveTrailVFXData, VFXActor) == 0x000000, "Member 'FAceActiveTrailVFXData::VFXActor' has a wrong offset!");

// ScriptStruct DeceiveInc.GuardEncounterHeatData
// 0x0024 (0x0024 - 0x0000)
struct FGuardEncounterHeatData final
{
public:
	float                                         EncounterDistanceToTarget;                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncounterDistanceToTargetMin;                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncounterDistanceToRepursue;                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncounterShootRange;                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncounterMoveFromIdleDistance;                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncounterFiringFrequency;                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncounterMeleeRange;                               // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncounterMeleeFrequency;                           // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncounterMeleeDamage;                              // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGuardEncounterHeatData) == 0x000004, "Wrong alignment on FGuardEncounterHeatData");
static_assert(sizeof(FGuardEncounterHeatData) == 0x000024, "Wrong size on FGuardEncounterHeatData");
static_assert(offsetof(FGuardEncounterHeatData, EncounterDistanceToTarget) == 0x000000, "Member 'FGuardEncounterHeatData::EncounterDistanceToTarget' has a wrong offset!");
static_assert(offsetof(FGuardEncounterHeatData, EncounterDistanceToTargetMin) == 0x000004, "Member 'FGuardEncounterHeatData::EncounterDistanceToTargetMin' has a wrong offset!");
static_assert(offsetof(FGuardEncounterHeatData, EncounterDistanceToRepursue) == 0x000008, "Member 'FGuardEncounterHeatData::EncounterDistanceToRepursue' has a wrong offset!");
static_assert(offsetof(FGuardEncounterHeatData, EncounterShootRange) == 0x00000C, "Member 'FGuardEncounterHeatData::EncounterShootRange' has a wrong offset!");
static_assert(offsetof(FGuardEncounterHeatData, EncounterMoveFromIdleDistance) == 0x000010, "Member 'FGuardEncounterHeatData::EncounterMoveFromIdleDistance' has a wrong offset!");
static_assert(offsetof(FGuardEncounterHeatData, EncounterFiringFrequency) == 0x000014, "Member 'FGuardEncounterHeatData::EncounterFiringFrequency' has a wrong offset!");
static_assert(offsetof(FGuardEncounterHeatData, EncounterMeleeRange) == 0x000018, "Member 'FGuardEncounterHeatData::EncounterMeleeRange' has a wrong offset!");
static_assert(offsetof(FGuardEncounterHeatData, EncounterMeleeFrequency) == 0x00001C, "Member 'FGuardEncounterHeatData::EncounterMeleeFrequency' has a wrong offset!");
static_assert(offsetof(FGuardEncounterHeatData, EncounterMeleeDamage) == 0x000020, "Member 'FGuardEncounterHeatData::EncounterMeleeDamage' has a wrong offset!");

// ScriptStruct DeceiveInc.ObjectToSpawnCount
// 0x0018 (0x0018 - 0x0000)
struct FObjectToSpawnCount final
{
public:
	class FString                                 ObjectType;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        SpawnCount;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FObjectToSpawnCount) == 0x000008, "Wrong alignment on FObjectToSpawnCount");
static_assert(sizeof(FObjectToSpawnCount) == 0x000018, "Wrong size on FObjectToSpawnCount");
static_assert(offsetof(FObjectToSpawnCount, ObjectType) == 0x000000, "Member 'FObjectToSpawnCount::ObjectType' has a wrong offset!");
static_assert(offsetof(FObjectToSpawnCount, SpawnCount) == 0x000010, "Member 'FObjectToSpawnCount::SpawnCount' has a wrong offset!");

// ScriptStruct DeceiveInc.ChargeLevelWeaponData
// 0x000C (0x000C - 0x0000)
struct FChargeLevelWeaponData final
{
public:
	float                                         ChargeDurationForLevel;                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChargeLevelDamage;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargeLevelExplosionSize;                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChargeLevelWeaponData) == 0x000004, "Wrong alignment on FChargeLevelWeaponData");
static_assert(sizeof(FChargeLevelWeaponData) == 0x00000C, "Wrong size on FChargeLevelWeaponData");
static_assert(offsetof(FChargeLevelWeaponData, ChargeDurationForLevel) == 0x000000, "Member 'FChargeLevelWeaponData::ChargeDurationForLevel' has a wrong offset!");
static_assert(offsetof(FChargeLevelWeaponData, ChargeLevelDamage) == 0x000004, "Member 'FChargeLevelWeaponData::ChargeLevelDamage' has a wrong offset!");
static_assert(offsetof(FChargeLevelWeaponData, ChargeLevelExplosionSize) == 0x000008, "Member 'FChargeLevelWeaponData::ChargeLevelExplosionSize' has a wrong offset!");

// ScriptStruct DeceiveInc.DescribeMatchmakingResponse
// 0x0030 (0x0030 - 0x0000)
struct FDescribeMatchmakingResponse final
{
public:
	EDescribeMatchmakingStatus                    Status;                                            // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EstimatedWait;                                     // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameSessionConnectionInfo             GameSessionConnectionInfo;                         // 0x0008(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FDescribeMatchmakingResponse) == 0x000008, "Wrong alignment on FDescribeMatchmakingResponse");
static_assert(sizeof(FDescribeMatchmakingResponse) == 0x000030, "Wrong size on FDescribeMatchmakingResponse");
static_assert(offsetof(FDescribeMatchmakingResponse, Status) == 0x000000, "Member 'FDescribeMatchmakingResponse::Status' has a wrong offset!");
static_assert(offsetof(FDescribeMatchmakingResponse, EstimatedWait) == 0x000004, "Member 'FDescribeMatchmakingResponse::EstimatedWait' has a wrong offset!");
static_assert(offsetof(FDescribeMatchmakingResponse, GameSessionConnectionInfo) == 0x000008, "Member 'FDescribeMatchmakingResponse::GameSessionConnectionInfo' has a wrong offset!");

// ScriptStruct DeceiveInc.ClaimedItemResponse
// 0x0018 (0x0018 - 0x0000)
struct FClaimedItemResponse final
{
public:
	class FString                                 ItemId;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Compensation;                                      // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClaimedItemResponse) == 0x000008, "Wrong alignment on FClaimedItemResponse");
static_assert(sizeof(FClaimedItemResponse) == 0x000018, "Wrong size on FClaimedItemResponse");
static_assert(offsetof(FClaimedItemResponse, ItemId) == 0x000000, "Member 'FClaimedItemResponse::ItemId' has a wrong offset!");
static_assert(offsetof(FClaimedItemResponse, Compensation) == 0x000010, "Member 'FClaimedItemResponse::Compensation' has a wrong offset!");

// ScriptStruct DeceiveInc.LootClaimResponse
// 0x0020 (0x0020 - 0x0000)
struct FLootClaimResponse final
{
public:
	TArray<struct FClaimedItemResponse>           ClaimResults;                                      // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FUpdatedItemResponse>           UpdatedItems;                                      // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLootClaimResponse) == 0x000008, "Wrong alignment on FLootClaimResponse");
static_assert(sizeof(FLootClaimResponse) == 0x000020, "Wrong size on FLootClaimResponse");
static_assert(offsetof(FLootClaimResponse, ClaimResults) == 0x000000, "Member 'FLootClaimResponse::ClaimResults' has a wrong offset!");
static_assert(offsetof(FLootClaimResponse, UpdatedItems) == 0x000010, "Member 'FLootClaimResponse::UpdatedItems' has a wrong offset!");

// ScriptStruct DeceiveInc.TrackSoundEvents
// 0x0040 (0x0040 - 0x0000)
struct FTrackSoundEvents final
{
public:
	class FText                                   TrackName;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAkAudioEvent*>                  AudioEvents;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bTriggerDanger;                                    // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInfinite;                                       // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeToPlay;                                        // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntervalBetweenAudioEventMin;                      // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntervalBetweenAudioEventMax;                      // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinDifferentSoundToPlay;                           // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxDifferentSoundToPlay;                           // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrackSoundEvents) == 0x000008, "Wrong alignment on FTrackSoundEvents");
static_assert(sizeof(FTrackSoundEvents) == 0x000040, "Wrong size on FTrackSoundEvents");
static_assert(offsetof(FTrackSoundEvents, TrackName) == 0x000000, "Member 'FTrackSoundEvents::TrackName' has a wrong offset!");
static_assert(offsetof(FTrackSoundEvents, AudioEvents) == 0x000018, "Member 'FTrackSoundEvents::AudioEvents' has a wrong offset!");
static_assert(offsetof(FTrackSoundEvents, bTriggerDanger) == 0x000028, "Member 'FTrackSoundEvents::bTriggerDanger' has a wrong offset!");
static_assert(offsetof(FTrackSoundEvents, bIsInfinite) == 0x000029, "Member 'FTrackSoundEvents::bIsInfinite' has a wrong offset!");
static_assert(offsetof(FTrackSoundEvents, TimeToPlay) == 0x00002C, "Member 'FTrackSoundEvents::TimeToPlay' has a wrong offset!");
static_assert(offsetof(FTrackSoundEvents, IntervalBetweenAudioEventMin) == 0x000030, "Member 'FTrackSoundEvents::IntervalBetweenAudioEventMin' has a wrong offset!");
static_assert(offsetof(FTrackSoundEvents, IntervalBetweenAudioEventMax) == 0x000034, "Member 'FTrackSoundEvents::IntervalBetweenAudioEventMax' has a wrong offset!");
static_assert(offsetof(FTrackSoundEvents, MinDifferentSoundToPlay) == 0x000038, "Member 'FTrackSoundEvents::MinDifferentSoundToPlay' has a wrong offset!");
static_assert(offsetof(FTrackSoundEvents, MaxDifferentSoundToPlay) == 0x00003C, "Member 'FTrackSoundEvents::MaxDifferentSoundToPlay' has a wrong offset!");

// ScriptStruct DeceiveInc.SpyTimeoutData
// 0x0030 (0x0030 - 0x0000)
struct FSpyTimeoutData final
{
public:
	TSoftObjectPtr<class ASpy>                    Spy;                                               // 0x0000(0x0028)(BlueprintVisible, ExportObject, InstancedReference, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpyTimeoutData) == 0x000008, "Wrong alignment on FSpyTimeoutData");
static_assert(sizeof(FSpyTimeoutData) == 0x000030, "Wrong size on FSpyTimeoutData");
static_assert(offsetof(FSpyTimeoutData, Spy) == 0x000000, "Member 'FSpyTimeoutData::Spy' has a wrong offset!");
static_assert(offsetof(FSpyTimeoutData, Timeout) == 0x000028, "Member 'FSpyTimeoutData::Timeout' has a wrong offset!");

// ScriptStruct DeceiveInc.DIMessageSettings
// 0x0110 (0x0128 - 0x0018)
struct FDIMessageSettings final : public FDILimitedTimeFeatureSettings
{
public:
	TMap<ELocalizationLanguage, class FText>      LocalizedTitle;                                    // 0x0018(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<ELocalizationLanguage, class FText>      LocalizedText;                                     // 0x0068(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                ImageAsset;                                        // 0x00B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WidgetClass;                                       // 0x00E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActionOnClick;                                     // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExtraData;                                         // 0x0118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDIMessageSettings) == 0x000008, "Wrong alignment on FDIMessageSettings");
static_assert(sizeof(FDIMessageSettings) == 0x000128, "Wrong size on FDIMessageSettings");
static_assert(offsetof(FDIMessageSettings, LocalizedTitle) == 0x000018, "Member 'FDIMessageSettings::LocalizedTitle' has a wrong offset!");
static_assert(offsetof(FDIMessageSettings, LocalizedText) == 0x000068, "Member 'FDIMessageSettings::LocalizedText' has a wrong offset!");
static_assert(offsetof(FDIMessageSettings, ImageAsset) == 0x0000B8, "Member 'FDIMessageSettings::ImageAsset' has a wrong offset!");
static_assert(offsetof(FDIMessageSettings, WidgetClass) == 0x0000E0, "Member 'FDIMessageSettings::WidgetClass' has a wrong offset!");
static_assert(offsetof(FDIMessageSettings, ActionOnClick) == 0x000108, "Member 'FDIMessageSettings::ActionOnClick' has a wrong offset!");
static_assert(offsetof(FDIMessageSettings, ExtraData) == 0x000118, "Member 'FDIMessageSettings::ExtraData' has a wrong offset!");

// ScriptStruct DeceiveInc.PoisonedActor
// 0x0010 (0x0010 - 0x0000)
struct FPoisonedActor final
{
public:
	class AActor*                                 PoisonedActor;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageDelayTime;                                   // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActorInRange;                                   // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPoisonedActor) == 0x000008, "Wrong alignment on FPoisonedActor");
static_assert(sizeof(FPoisonedActor) == 0x000010, "Wrong size on FPoisonedActor");
static_assert(offsetof(FPoisonedActor, PoisonedActor) == 0x000000, "Member 'FPoisonedActor::PoisonedActor' has a wrong offset!");
static_assert(offsetof(FPoisonedActor, DamageDelayTime) == 0x000008, "Member 'FPoisonedActor::DamageDelayTime' has a wrong offset!");
static_assert(offsetof(FPoisonedActor, bIsActorInRange) == 0x00000C, "Member 'FPoisonedActor::bIsActorInRange' has a wrong offset!");

// ScriptStruct DeceiveInc.DIPlatformSpecificClientSettings
// 0x0050 (0x0050 - 0x0000)
struct FDIPlatformSpecificClientSettings final
{
public:
	bool                                          bTrialVersionAllowed;                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              TrialUTCStartTime;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              TrialUTCEndTime;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAvaliableFeatureLevel                        BlockedToFeatureLevel;                             // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DisabledModes;                                     // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchmakingExtraSuffix;                            // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDIMessageSettings>             MessagesOfTheDay;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDISpecialAnnouncmentSettings>  SpecialAnnouncements;                              // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDIPlatformSpecificClientSettings) == 0x000008, "Wrong alignment on FDIPlatformSpecificClientSettings");
static_assert(sizeof(FDIPlatformSpecificClientSettings) == 0x000050, "Wrong size on FDIPlatformSpecificClientSettings");
static_assert(offsetof(FDIPlatformSpecificClientSettings, bTrialVersionAllowed) == 0x000000, "Member 'FDIPlatformSpecificClientSettings::bTrialVersionAllowed' has a wrong offset!");
static_assert(offsetof(FDIPlatformSpecificClientSettings, TrialUTCStartTime) == 0x000008, "Member 'FDIPlatformSpecificClientSettings::TrialUTCStartTime' has a wrong offset!");
static_assert(offsetof(FDIPlatformSpecificClientSettings, TrialUTCEndTime) == 0x000010, "Member 'FDIPlatformSpecificClientSettings::TrialUTCEndTime' has a wrong offset!");
static_assert(offsetof(FDIPlatformSpecificClientSettings, BlockedToFeatureLevel) == 0x000018, "Member 'FDIPlatformSpecificClientSettings::BlockedToFeatureLevel' has a wrong offset!");
static_assert(offsetof(FDIPlatformSpecificClientSettings, DisabledModes) == 0x00001C, "Member 'FDIPlatformSpecificClientSettings::DisabledModes' has a wrong offset!");
static_assert(offsetof(FDIPlatformSpecificClientSettings, MatchmakingExtraSuffix) == 0x000020, "Member 'FDIPlatformSpecificClientSettings::MatchmakingExtraSuffix' has a wrong offset!");
static_assert(offsetof(FDIPlatformSpecificClientSettings, MessagesOfTheDay) == 0x000030, "Member 'FDIPlatformSpecificClientSettings::MessagesOfTheDay' has a wrong offset!");
static_assert(offsetof(FDIPlatformSpecificClientSettings, SpecialAnnouncements) == 0x000040, "Member 'FDIPlatformSpecificClientSettings::SpecialAnnouncements' has a wrong offset!");

// ScriptStruct DeceiveInc.DIPrivateLobbyModeSettings
// 0x0020 (0x0028 - 0x0008)
struct FDIPrivateLobbyModeSettings final : public FDIModeSettings
{
public:
	TArray<class FString>                         AvailablePrivateLobbyRegions;                      // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         DisabledPrivateLobbyMaps;                          // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDIPrivateLobbyModeSettings) == 0x000008, "Wrong alignment on FDIPrivateLobbyModeSettings");
static_assert(sizeof(FDIPrivateLobbyModeSettings) == 0x000028, "Wrong size on FDIPrivateLobbyModeSettings");
static_assert(offsetof(FDIPrivateLobbyModeSettings, AvailablePrivateLobbyRegions) == 0x000008, "Member 'FDIPrivateLobbyModeSettings::AvailablePrivateLobbyRegions' has a wrong offset!");
static_assert(offsetof(FDIPrivateLobbyModeSettings, DisabledPrivateLobbyMaps) == 0x000018, "Member 'FDIPrivateLobbyModeSettings::DisabledPrivateLobbyMaps' has a wrong offset!");

// ScriptStruct DeceiveInc.DILimitedTimeModeSettings
// 0x00B8 (0x00C0 - 0x0008)
struct FDILimitedTimeModeSettings final : public FDIModeSettings
{
public:
	bool                                          bFeatureActive;                                    // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              FeatureUTCStartTime;                               // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              FeatureUTCEndTime;                                 // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ELocalizationLanguage, class FText>      LocalizedTitle;                                    // 0x0020(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<ELocalizationLanguage, class FText>      LocalizedDescription;                              // 0x0070(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDILimitedTimeModeSettings) == 0x000008, "Wrong alignment on FDILimitedTimeModeSettings");
static_assert(sizeof(FDILimitedTimeModeSettings) == 0x0000C0, "Wrong size on FDILimitedTimeModeSettings");
static_assert(offsetof(FDILimitedTimeModeSettings, bFeatureActive) == 0x000008, "Member 'FDILimitedTimeModeSettings::bFeatureActive' has a wrong offset!");
static_assert(offsetof(FDILimitedTimeModeSettings, FeatureUTCStartTime) == 0x000010, "Member 'FDILimitedTimeModeSettings::FeatureUTCStartTime' has a wrong offset!");
static_assert(offsetof(FDILimitedTimeModeSettings, FeatureUTCEndTime) == 0x000018, "Member 'FDILimitedTimeModeSettings::FeatureUTCEndTime' has a wrong offset!");
static_assert(offsetof(FDILimitedTimeModeSettings, LocalizedTitle) == 0x000020, "Member 'FDILimitedTimeModeSettings::LocalizedTitle' has a wrong offset!");
static_assert(offsetof(FDILimitedTimeModeSettings, LocalizedDescription) == 0x000070, "Member 'FDILimitedTimeModeSettings::LocalizedDescription' has a wrong offset!");

// ScriptStruct DeceiveInc.DIVersionedClientConfigSettings
// 0x0318 (0x0318 - 0x0000)
struct FDIVersionedClientConfigSettings final
{
public:
	EAvaliableFeatureLevel                        AvaliableFeatureLevel;                             // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AvailableModes;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTrialVersionAllowed;                              // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDIPlatformSpecificClientSettings      PlatformSpecificSettings_Steam;                    // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDIPlatformSpecificClientSettings      PlatformSpecificSettings_EGS;                      // 0x0060(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDIPlatformSpecificClientSettings      PlatformSpecificSettings_PS5;                      // 0x00B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDIPlatformSpecificClientSettings      PlatformSpecificSettings_XSX;                      // 0x0100(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FDIMessageSettings>             MessagesOfTheDay;                                  // 0x0150(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDISpecialAnnouncmentSettings>  SpecialAnnouncements;                              // 0x0160(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDIPrivateLobbyModeSettings            PrivateLobbySettings;                              // 0x0170(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDILimitedTimeModeSettings             LTM1Settings;                                      // 0x0198(0x00C0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDILimitedTimeModeSettings             LTM2Settings;                                      // 0x0258(0x00C0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDIVersionedClientConfigSettings) == 0x000008, "Wrong alignment on FDIVersionedClientConfigSettings");
static_assert(sizeof(FDIVersionedClientConfigSettings) == 0x000318, "Wrong size on FDIVersionedClientConfigSettings");
static_assert(offsetof(FDIVersionedClientConfigSettings, AvaliableFeatureLevel) == 0x000000, "Member 'FDIVersionedClientConfigSettings::AvaliableFeatureLevel' has a wrong offset!");
static_assert(offsetof(FDIVersionedClientConfigSettings, AvailableModes) == 0x000004, "Member 'FDIVersionedClientConfigSettings::AvailableModes' has a wrong offset!");
static_assert(offsetof(FDIVersionedClientConfigSettings, bTrialVersionAllowed) == 0x000008, "Member 'FDIVersionedClientConfigSettings::bTrialVersionAllowed' has a wrong offset!");
static_assert(offsetof(FDIVersionedClientConfigSettings, PlatformSpecificSettings_Steam) == 0x000010, "Member 'FDIVersionedClientConfigSettings::PlatformSpecificSettings_Steam' has a wrong offset!");
static_assert(offsetof(FDIVersionedClientConfigSettings, PlatformSpecificSettings_EGS) == 0x000060, "Member 'FDIVersionedClientConfigSettings::PlatformSpecificSettings_EGS' has a wrong offset!");
static_assert(offsetof(FDIVersionedClientConfigSettings, PlatformSpecificSettings_PS5) == 0x0000B0, "Member 'FDIVersionedClientConfigSettings::PlatformSpecificSettings_PS5' has a wrong offset!");
static_assert(offsetof(FDIVersionedClientConfigSettings, PlatformSpecificSettings_XSX) == 0x000100, "Member 'FDIVersionedClientConfigSettings::PlatformSpecificSettings_XSX' has a wrong offset!");
static_assert(offsetof(FDIVersionedClientConfigSettings, MessagesOfTheDay) == 0x000150, "Member 'FDIVersionedClientConfigSettings::MessagesOfTheDay' has a wrong offset!");
static_assert(offsetof(FDIVersionedClientConfigSettings, SpecialAnnouncements) == 0x000160, "Member 'FDIVersionedClientConfigSettings::SpecialAnnouncements' has a wrong offset!");
static_assert(offsetof(FDIVersionedClientConfigSettings, PrivateLobbySettings) == 0x000170, "Member 'FDIVersionedClientConfigSettings::PrivateLobbySettings' has a wrong offset!");
static_assert(offsetof(FDIVersionedClientConfigSettings, LTM1Settings) == 0x000198, "Member 'FDIVersionedClientConfigSettings::LTM1Settings' has a wrong offset!");
static_assert(offsetof(FDIVersionedClientConfigSettings, LTM2Settings) == 0x000258, "Member 'FDIVersionedClientConfigSettings::LTM2Settings' has a wrong offset!");

// ScriptStruct DeceiveInc.DIMultiClientConfigSettings
// 0x0050 (0x0050 - 0x0000)
struct FDIMultiClientConfigSettings final
{
public:
	TMap<EClientConfigVersion, struct FDIVersionedClientConfigSettings> VersionedConfig;                                   // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDIMultiClientConfigSettings) == 0x000008, "Wrong alignment on FDIMultiClientConfigSettings");
static_assert(sizeof(FDIMultiClientConfigSettings) == 0x000050, "Wrong size on FDIMultiClientConfigSettings");
static_assert(offsetof(FDIMultiClientConfigSettings, VersionedConfig) == 0x000000, "Member 'FDIMultiClientConfigSettings::VersionedConfig' has a wrong offset!");

// ScriptStruct DeceiveInc.DIClientConfigSettings
// 0x00A0 (0x00A0 - 0x0000)
struct FDIClientConfigSettings final
{
public:
	int32                                         Version;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeginnerQueueMaxLevel_Solo;                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeginnerQueueMaxLevel_Duo;                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeginnerQueueMaxLevel_Trio;                        // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumXPBoosterCount;                             // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BeginnerQueuePrefix;                               // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDINetInfoClientSettings               NetInfoClientSettings;                             // 0x0028(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDIMultiClientConfigSettings           VersionedClientConfigs;                            // 0x0040(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FDILimitedTimeFeatureSettings>  MaintenancePeriods;                                // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDIClientConfigSettings) == 0x000008, "Wrong alignment on FDIClientConfigSettings");
static_assert(sizeof(FDIClientConfigSettings) == 0x0000A0, "Wrong size on FDIClientConfigSettings");
static_assert(offsetof(FDIClientConfigSettings, Version) == 0x000000, "Member 'FDIClientConfigSettings::Version' has a wrong offset!");
static_assert(offsetof(FDIClientConfigSettings, BeginnerQueueMaxLevel_Solo) == 0x000004, "Member 'FDIClientConfigSettings::BeginnerQueueMaxLevel_Solo' has a wrong offset!");
static_assert(offsetof(FDIClientConfigSettings, BeginnerQueueMaxLevel_Duo) == 0x000008, "Member 'FDIClientConfigSettings::BeginnerQueueMaxLevel_Duo' has a wrong offset!");
static_assert(offsetof(FDIClientConfigSettings, BeginnerQueueMaxLevel_Trio) == 0x00000C, "Member 'FDIClientConfigSettings::BeginnerQueueMaxLevel_Trio' has a wrong offset!");
static_assert(offsetof(FDIClientConfigSettings, MaximumXPBoosterCount) == 0x000010, "Member 'FDIClientConfigSettings::MaximumXPBoosterCount' has a wrong offset!");
static_assert(offsetof(FDIClientConfigSettings, BeginnerQueuePrefix) == 0x000018, "Member 'FDIClientConfigSettings::BeginnerQueuePrefix' has a wrong offset!");
static_assert(offsetof(FDIClientConfigSettings, NetInfoClientSettings) == 0x000028, "Member 'FDIClientConfigSettings::NetInfoClientSettings' has a wrong offset!");
static_assert(offsetof(FDIClientConfigSettings, VersionedClientConfigs) == 0x000040, "Member 'FDIClientConfigSettings::VersionedClientConfigs' has a wrong offset!");
static_assert(offsetof(FDIClientConfigSettings, MaintenancePeriods) == 0x000090, "Member 'FDIClientConfigSettings::MaintenancePeriods' has a wrong offset!");

// ScriptStruct DeceiveInc.AccelbyteLoginRequestBody
// 0x0020 (0x0020 - 0x0000)
struct FAccelbyteLoginRequestBody final
{
public:
	class FString                                 AccelbyteToken;                                    // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ProfileVisibility;                                 // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccelbyteLoginRequestBody) == 0x000008, "Wrong alignment on FAccelbyteLoginRequestBody");
static_assert(sizeof(FAccelbyteLoginRequestBody) == 0x000020, "Wrong size on FAccelbyteLoginRequestBody");
static_assert(offsetof(FAccelbyteLoginRequestBody, AccelbyteToken) == 0x000000, "Member 'FAccelbyteLoginRequestBody::AccelbyteToken' has a wrong offset!");
static_assert(offsetof(FAccelbyteLoginRequestBody, ProfileVisibility) == 0x000010, "Member 'FAccelbyteLoginRequestBody::ProfileVisibility' has a wrong offset!");

// ScriptStruct DeceiveInc.DamageContextData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FDamageContextData
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DamageSourceName;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageContextData) == 0x000008, "Wrong alignment on FDamageContextData");
static_assert(sizeof(FDamageContextData) == 0x000010, "Wrong size on FDamageContextData");
static_assert(offsetof(FDamageContextData, DamageSourceName) == 0x000008, "Member 'FDamageContextData::DamageSourceName' has a wrong offset!");

// ScriptStruct DeceiveInc.FactionPlan
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FFactionPlan final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFactionPlan) == 0x000008, "Wrong alignment on FFactionPlan");
static_assert(sizeof(FFactionPlan) == 0x000018, "Wrong size on FFactionPlan");

// ScriptStruct DeceiveInc.PlayerResults
// 0x0088 (0x0088 - 0x0000)
struct FPlayerResults final
{
public:
	class FString                                 UserId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AgentPick;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWinner;                                          // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Eliminations;                                      // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Deaths;                                            // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExperienceGained;                                  // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayTime;                                          // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Gadget1;                                           // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Gadget2;                                           // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WeaponMod;                                         // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActiveMod;                                         // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PassiveMod;                                        // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerResults) == 0x000008, "Wrong alignment on FPlayerResults");
static_assert(sizeof(FPlayerResults) == 0x000088, "Wrong size on FPlayerResults");
static_assert(offsetof(FPlayerResults, UserId) == 0x000000, "Member 'FPlayerResults::UserId' has a wrong offset!");
static_assert(offsetof(FPlayerResults, AgentPick) == 0x000010, "Member 'FPlayerResults::AgentPick' has a wrong offset!");
static_assert(offsetof(FPlayerResults, IsWinner) == 0x000020, "Member 'FPlayerResults::IsWinner' has a wrong offset!");
static_assert(offsetof(FPlayerResults, Eliminations) == 0x000024, "Member 'FPlayerResults::Eliminations' has a wrong offset!");
static_assert(offsetof(FPlayerResults, Deaths) == 0x000028, "Member 'FPlayerResults::Deaths' has a wrong offset!");
static_assert(offsetof(FPlayerResults, ExperienceGained) == 0x00002C, "Member 'FPlayerResults::ExperienceGained' has a wrong offset!");
static_assert(offsetof(FPlayerResults, PlayTime) == 0x000030, "Member 'FPlayerResults::PlayTime' has a wrong offset!");
static_assert(offsetof(FPlayerResults, Gadget1) == 0x000038, "Member 'FPlayerResults::Gadget1' has a wrong offset!");
static_assert(offsetof(FPlayerResults, Gadget2) == 0x000048, "Member 'FPlayerResults::Gadget2' has a wrong offset!");
static_assert(offsetof(FPlayerResults, WeaponMod) == 0x000058, "Member 'FPlayerResults::WeaponMod' has a wrong offset!");
static_assert(offsetof(FPlayerResults, ActiveMod) == 0x000068, "Member 'FPlayerResults::ActiveMod' has a wrong offset!");
static_assert(offsetof(FPlayerResults, PassiveMod) == 0x000078, "Member 'FPlayerResults::PassiveMod' has a wrong offset!");

// ScriptStruct DeceiveInc.AnimNode_DirectionalTilt
// 0x0060 (0x0128 - 0x00C8)
struct FAnimNode_DirectionalTilt final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         MainTiltBone;                                      // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         KeepOriBone;                                       // 0x00D8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FBoneReference>                 CounterAnimateBones;                               // 0x00E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         ExtraRotationBone;                                 // 0x00F8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                DirectionInput;                                    // 0x0108(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardAngleMin;                                   // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardAngleMax;                                   // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SideAngleMin;                                      // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SideAngleMax;                                      // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_DirectionalTilt) == 0x000008, "Wrong alignment on FAnimNode_DirectionalTilt");
static_assert(sizeof(FAnimNode_DirectionalTilt) == 0x000128, "Wrong size on FAnimNode_DirectionalTilt");
static_assert(offsetof(FAnimNode_DirectionalTilt, MainTiltBone) == 0x0000C8, "Member 'FAnimNode_DirectionalTilt::MainTiltBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_DirectionalTilt, KeepOriBone) == 0x0000D8, "Member 'FAnimNode_DirectionalTilt::KeepOriBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_DirectionalTilt, CounterAnimateBones) == 0x0000E8, "Member 'FAnimNode_DirectionalTilt::CounterAnimateBones' has a wrong offset!");
static_assert(offsetof(FAnimNode_DirectionalTilt, ExtraRotationBone) == 0x0000F8, "Member 'FAnimNode_DirectionalTilt::ExtraRotationBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_DirectionalTilt, DirectionInput) == 0x000108, "Member 'FAnimNode_DirectionalTilt::DirectionInput' has a wrong offset!");
static_assert(offsetof(FAnimNode_DirectionalTilt, ForwardAngleMin) == 0x000114, "Member 'FAnimNode_DirectionalTilt::ForwardAngleMin' has a wrong offset!");
static_assert(offsetof(FAnimNode_DirectionalTilt, ForwardAngleMax) == 0x000118, "Member 'FAnimNode_DirectionalTilt::ForwardAngleMax' has a wrong offset!");
static_assert(offsetof(FAnimNode_DirectionalTilt, SideAngleMin) == 0x00011C, "Member 'FAnimNode_DirectionalTilt::SideAngleMin' has a wrong offset!");
static_assert(offsetof(FAnimNode_DirectionalTilt, SideAngleMax) == 0x000120, "Member 'FAnimNode_DirectionalTilt::SideAngleMax' has a wrong offset!");

// ScriptStruct DeceiveInc.WireLocationsData
// 0x0028 (0x0028 - 0x0000)
struct FWireLocationsData final
{
public:
	class AActor*                                 WireStartActor;                                    // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 WireEndActor;                                      // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WireStartLocation;                                 // 0x0010(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WireEndLocation;                                   // 0x001C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWireLocationsData) == 0x000008, "Wrong alignment on FWireLocationsData");
static_assert(sizeof(FWireLocationsData) == 0x000028, "Wrong size on FWireLocationsData");
static_assert(offsetof(FWireLocationsData, WireStartActor) == 0x000000, "Member 'FWireLocationsData::WireStartActor' has a wrong offset!");
static_assert(offsetof(FWireLocationsData, WireEndActor) == 0x000008, "Member 'FWireLocationsData::WireEndActor' has a wrong offset!");
static_assert(offsetof(FWireLocationsData, WireStartLocation) == 0x000010, "Member 'FWireLocationsData::WireStartLocation' has a wrong offset!");
static_assert(offsetof(FWireLocationsData, WireEndLocation) == 0x00001C, "Member 'FWireLocationsData::WireEndLocation' has a wrong offset!");

// ScriptStruct DeceiveInc.SpyGamePhaseData
// 0x0000 (0x0050 - 0x0050)
struct FSpyGamePhaseData : public FBaseGamePhaseData
{
};
static_assert(alignof(FSpyGamePhaseData) == 0x000008, "Wrong alignment on FSpyGamePhaseData");
static_assert(sizeof(FSpyGamePhaseData) == 0x000050, "Wrong size on FSpyGamePhaseData");

// ScriptStruct DeceiveInc.ExtractionArrivingPhaseData
// 0x0098 (0x00E8 - 0x0050)
struct FExtractionArrivingPhaseData final : public FSpyGamePhaseData
{
public:
	class FText                                   ObjectiveDescCarrier;                              // 0x0050(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ObjectivePromptTextCarrier;                        // 0x0068(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ObjectiveDescNonCarrier;                           // 0x0080(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ObjectivePromptTextNonCarrier;                     // 0x0098(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ObjectiveDescNonCarrierTeammate;                   // 0x00B0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ObjectivePromptTextNonCarrierTeammate;             // 0x00C8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         DefaultPhaseDuration;                              // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtractionArrivalTime;                             // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExtractionArrivingPhaseData) == 0x000008, "Wrong alignment on FExtractionArrivingPhaseData");
static_assert(sizeof(FExtractionArrivingPhaseData) == 0x0000E8, "Wrong size on FExtractionArrivingPhaseData");
static_assert(offsetof(FExtractionArrivingPhaseData, ObjectiveDescCarrier) == 0x000050, "Member 'FExtractionArrivingPhaseData::ObjectiveDescCarrier' has a wrong offset!");
static_assert(offsetof(FExtractionArrivingPhaseData, ObjectivePromptTextCarrier) == 0x000068, "Member 'FExtractionArrivingPhaseData::ObjectivePromptTextCarrier' has a wrong offset!");
static_assert(offsetof(FExtractionArrivingPhaseData, ObjectiveDescNonCarrier) == 0x000080, "Member 'FExtractionArrivingPhaseData::ObjectiveDescNonCarrier' has a wrong offset!");
static_assert(offsetof(FExtractionArrivingPhaseData, ObjectivePromptTextNonCarrier) == 0x000098, "Member 'FExtractionArrivingPhaseData::ObjectivePromptTextNonCarrier' has a wrong offset!");
static_assert(offsetof(FExtractionArrivingPhaseData, ObjectiveDescNonCarrierTeammate) == 0x0000B0, "Member 'FExtractionArrivingPhaseData::ObjectiveDescNonCarrierTeammate' has a wrong offset!");
static_assert(offsetof(FExtractionArrivingPhaseData, ObjectivePromptTextNonCarrierTeammate) == 0x0000C8, "Member 'FExtractionArrivingPhaseData::ObjectivePromptTextNonCarrierTeammate' has a wrong offset!");
static_assert(offsetof(FExtractionArrivingPhaseData, DefaultPhaseDuration) == 0x0000E0, "Member 'FExtractionArrivingPhaseData::DefaultPhaseDuration' has a wrong offset!");
static_assert(offsetof(FExtractionArrivingPhaseData, ExtractionArrivalTime) == 0x0000E4, "Member 'FExtractionArrivingPhaseData::ExtractionArrivalTime' has a wrong offset!");

// ScriptStruct DeceiveInc.LimitedEventItemsInfo
// 0x0048 (0x0048 - 0x0000)
struct FLimitedEventItemsInfo final
{
public:
	class FString                                 EventName;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              EventIcon;                                         // 0x0010(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDIPrimaryDataAsset>> EventAssets;                                       // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLimitedEventItemsInfo) == 0x000008, "Wrong alignment on FLimitedEventItemsInfo");
static_assert(sizeof(FLimitedEventItemsInfo) == 0x000048, "Wrong size on FLimitedEventItemsInfo");
static_assert(offsetof(FLimitedEventItemsInfo, EventName) == 0x000000, "Member 'FLimitedEventItemsInfo::EventName' has a wrong offset!");
static_assert(offsetof(FLimitedEventItemsInfo, EventIcon) == 0x000010, "Member 'FLimitedEventItemsInfo::EventIcon' has a wrong offset!");
static_assert(offsetof(FLimitedEventItemsInfo, EventAssets) == 0x000038, "Member 'FLimitedEventItemsInfo::EventAssets' has a wrong offset!");

// ScriptStruct DeceiveInc.InteractableData
// 0x0020 (0x0020 - 0x0000)
struct FInteractableData final
{
public:
	class UInteractableComponent*                 InteractableComp;                                  // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HotnessLevel;                                      // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLastInteractionData                   LastInteractionData;                               // 0x0010(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractableData) == 0x000008, "Wrong alignment on FInteractableData");
static_assert(sizeof(FInteractableData) == 0x000020, "Wrong size on FInteractableData");
static_assert(offsetof(FInteractableData, InteractableComp) == 0x000000, "Member 'FInteractableData::InteractableComp' has a wrong offset!");
static_assert(offsetof(FInteractableData, HotnessLevel) == 0x000008, "Member 'FInteractableData::HotnessLevel' has a wrong offset!");
static_assert(offsetof(FInteractableData, LastInteractionData) == 0x000010, "Member 'FInteractableData::LastInteractionData' has a wrong offset!");

// ScriptStruct DeceiveInc.FetchMatchmakingTokenResponse
// 0x0010 (0x0010 - 0x0000)
struct FFetchMatchmakingTokenResponse final
{
public:
	class FString                                 MatchmakingToken;                                  // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFetchMatchmakingTokenResponse) == 0x000008, "Wrong alignment on FFetchMatchmakingTokenResponse");
static_assert(sizeof(FFetchMatchmakingTokenResponse) == 0x000010, "Wrong size on FFetchMatchmakingTokenResponse");
static_assert(offsetof(FFetchMatchmakingTokenResponse, MatchmakingToken) == 0x000000, "Member 'FFetchMatchmakingTokenResponse::MatchmakingToken' has a wrong offset!");

// ScriptStruct DeceiveInc.AudioEventToPlay
// 0x0008 (0x0008 - 0x0000)
struct FAudioEventToPlay final
{
public:
	int32                                         AudioIndex;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntervalToNextAudio;                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAudioEventToPlay) == 0x000004, "Wrong alignment on FAudioEventToPlay");
static_assert(sizeof(FAudioEventToPlay) == 0x000008, "Wrong size on FAudioEventToPlay");
static_assert(offsetof(FAudioEventToPlay, AudioIndex) == 0x000000, "Member 'FAudioEventToPlay::AudioIndex' has a wrong offset!");
static_assert(offsetof(FAudioEventToPlay, IntervalToNextAudio) == 0x000004, "Member 'FAudioEventToPlay::IntervalToNextAudio' has a wrong offset!");

// ScriptStruct DeceiveInc.ModifiedChargedDamagePerType
// 0x0008 (0x0008 - 0x0000)
struct FModifiedChargedDamagePerType final
{
public:
	EHitType                                      DamageType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageMultiplier;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModifiedChargedDamagePerType) == 0x000004, "Wrong alignment on FModifiedChargedDamagePerType");
static_assert(sizeof(FModifiedChargedDamagePerType) == 0x000008, "Wrong size on FModifiedChargedDamagePerType");
static_assert(offsetof(FModifiedChargedDamagePerType, DamageType) == 0x000000, "Member 'FModifiedChargedDamagePerType::DamageType' has a wrong offset!");
static_assert(offsetof(FModifiedChargedDamagePerType, DamageMultiplier) == 0x000004, "Member 'FModifiedChargedDamagePerType::DamageMultiplier' has a wrong offset!");

// ScriptStruct DeceiveInc.ModifiedChargedDamageData
// 0x0018 (0x0018 - 0x0000)
struct FModifiedChargedDamageData final
{
public:
	TArray<struct FModifiedChargedDamagePerType>  DamagePerHitType;                                  // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DefaultDamageMultiplier;                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModifiedChargedDamageData) == 0x000008, "Wrong alignment on FModifiedChargedDamageData");
static_assert(sizeof(FModifiedChargedDamageData) == 0x000018, "Wrong size on FModifiedChargedDamageData");
static_assert(offsetof(FModifiedChargedDamageData, DamagePerHitType) == 0x000000, "Member 'FModifiedChargedDamageData::DamagePerHitType' has a wrong offset!");
static_assert(offsetof(FModifiedChargedDamageData, DefaultDamageMultiplier) == 0x000010, "Member 'FModifiedChargedDamageData::DefaultDamageMultiplier' has a wrong offset!");

// ScriptStruct DeceiveInc.DIOnlineAchievement
// 0x0018 (0x0018 - 0x0000)
struct FDIOnlineAchievement final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Progress;                                          // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Increment;                                         // 0x0014(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDIOnlineAchievement) == 0x000008, "Wrong alignment on FDIOnlineAchievement");
static_assert(sizeof(FDIOnlineAchievement) == 0x000018, "Wrong size on FDIOnlineAchievement");
static_assert(offsetof(FDIOnlineAchievement, ID) == 0x000000, "Member 'FDIOnlineAchievement::ID' has a wrong offset!");
static_assert(offsetof(FDIOnlineAchievement, Progress) == 0x000010, "Member 'FDIOnlineAchievement::Progress' has a wrong offset!");
static_assert(offsetof(FDIOnlineAchievement, Increment) == 0x000014, "Member 'FDIOnlineAchievement::Increment' has a wrong offset!");

// ScriptStruct DeceiveInc.StoreCatalogEntryRewardData
// 0x00B0 (0x00B0 - 0x0000)
struct FStoreCatalogEntryRewardData final
{
public:
	class UDIItem*                                Reward1;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Reward1ItemID;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Reward1Name;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Reward1Image;                                      // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDIItem*                                Reward2;                                           // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Reward2ItemID;                                     // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Reward2Name;                                       // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Reward2Image;                                      // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDITitleItem*                           RewardTitle;                                       // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardTitleItemID;                                 // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreCatalogEntryRewardData) == 0x000008, "Wrong alignment on FStoreCatalogEntryRewardData");
static_assert(sizeof(FStoreCatalogEntryRewardData) == 0x0000B0, "Wrong size on FStoreCatalogEntryRewardData");
static_assert(offsetof(FStoreCatalogEntryRewardData, Reward1) == 0x000000, "Member 'FStoreCatalogEntryRewardData::Reward1' has a wrong offset!");
static_assert(offsetof(FStoreCatalogEntryRewardData, Reward1ItemID) == 0x000008, "Member 'FStoreCatalogEntryRewardData::Reward1ItemID' has a wrong offset!");
static_assert(offsetof(FStoreCatalogEntryRewardData, Reward1Name) == 0x000010, "Member 'FStoreCatalogEntryRewardData::Reward1Name' has a wrong offset!");
static_assert(offsetof(FStoreCatalogEntryRewardData, Reward1Image) == 0x000028, "Member 'FStoreCatalogEntryRewardData::Reward1Image' has a wrong offset!");
static_assert(offsetof(FStoreCatalogEntryRewardData, Reward2) == 0x000050, "Member 'FStoreCatalogEntryRewardData::Reward2' has a wrong offset!");
static_assert(offsetof(FStoreCatalogEntryRewardData, Reward2ItemID) == 0x000058, "Member 'FStoreCatalogEntryRewardData::Reward2ItemID' has a wrong offset!");
static_assert(offsetof(FStoreCatalogEntryRewardData, Reward2Name) == 0x000060, "Member 'FStoreCatalogEntryRewardData::Reward2Name' has a wrong offset!");
static_assert(offsetof(FStoreCatalogEntryRewardData, Reward2Image) == 0x000078, "Member 'FStoreCatalogEntryRewardData::Reward2Image' has a wrong offset!");
static_assert(offsetof(FStoreCatalogEntryRewardData, RewardTitle) == 0x0000A0, "Member 'FStoreCatalogEntryRewardData::RewardTitle' has a wrong offset!");
static_assert(offsetof(FStoreCatalogEntryRewardData, RewardTitleItemID) == 0x0000A8, "Member 'FStoreCatalogEntryRewardData::RewardTitleItemID' has a wrong offset!");

// ScriptStruct DeceiveInc.SkinSpecifiAnimOverrideData
// 0x0028 (0x0028 - 0x0000)
struct FSkinSpecifiAnimOverrideData final
{
public:
	TSoftObjectPtr<class UAnimSequence>           IntroPoseAnim;                                     // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkinSpecifiAnimOverrideData) == 0x000008, "Wrong alignment on FSkinSpecifiAnimOverrideData");
static_assert(sizeof(FSkinSpecifiAnimOverrideData) == 0x000028, "Wrong size on FSkinSpecifiAnimOverrideData");
static_assert(offsetof(FSkinSpecifiAnimOverrideData, IntroPoseAnim) == 0x000000, "Member 'FSkinSpecifiAnimOverrideData::IntroPoseAnim' has a wrong offset!");

// ScriptStruct DeceiveInc.AnimationPropData
// 0x0060 (0x0060 - 0x0000)
struct FAnimationPropData final
{
public:
	TSoftClassPtr<class UClass>                   PropBPClass;                                       // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           PropAnim;                                          // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocketName;                                  // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NameID;                                            // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationPropData) == 0x000008, "Wrong alignment on FAnimationPropData");
static_assert(sizeof(FAnimationPropData) == 0x000060, "Wrong size on FAnimationPropData");
static_assert(offsetof(FAnimationPropData, PropBPClass) == 0x000000, "Member 'FAnimationPropData::PropBPClass' has a wrong offset!");
static_assert(offsetof(FAnimationPropData, PropAnim) == 0x000028, "Member 'FAnimationPropData::PropAnim' has a wrong offset!");
static_assert(offsetof(FAnimationPropData, AttachSocketName) == 0x000050, "Member 'FAnimationPropData::AttachSocketName' has a wrong offset!");
static_assert(offsetof(FAnimationPropData, NameID) == 0x000058, "Member 'FAnimationPropData::NameID' has a wrong offset!");

// ScriptStruct DeceiveInc.AnimNode_IKFromPose
// 0x0060 (0x0128 - 0x00C8)
struct FAnimNode_IKFromPose final : public FAnimNode_SkeletalControlBase
{
public:
	struct FComponentSpacePoseLink                ReferencePose;                                     // 0x00C8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         ShoulderBone;                                      // 0x00D8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         ElbowBone;                                         // 0x00E8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         HandBone;                                          // 0x00F8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         ReferenceBone;                                     // 0x0108(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnableIK;                                         // 0x0118(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnableIKInterpolationTime;                         // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandHeightOffset;                                  // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_IKFromPose) == 0x000008, "Wrong alignment on FAnimNode_IKFromPose");
static_assert(sizeof(FAnimNode_IKFromPose) == 0x000128, "Wrong size on FAnimNode_IKFromPose");
static_assert(offsetof(FAnimNode_IKFromPose, ReferencePose) == 0x0000C8, "Member 'FAnimNode_IKFromPose::ReferencePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_IKFromPose, ShoulderBone) == 0x0000D8, "Member 'FAnimNode_IKFromPose::ShoulderBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_IKFromPose, ElbowBone) == 0x0000E8, "Member 'FAnimNode_IKFromPose::ElbowBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_IKFromPose, HandBone) == 0x0000F8, "Member 'FAnimNode_IKFromPose::HandBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_IKFromPose, ReferenceBone) == 0x000108, "Member 'FAnimNode_IKFromPose::ReferenceBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_IKFromPose, bEnableIK) == 0x000118, "Member 'FAnimNode_IKFromPose::bEnableIK' has a wrong offset!");
static_assert(offsetof(FAnimNode_IKFromPose, EnableIKInterpolationTime) == 0x00011C, "Member 'FAnimNode_IKFromPose::EnableIKInterpolationTime' has a wrong offset!");
static_assert(offsetof(FAnimNode_IKFromPose, HandHeightOffset) == 0x000120, "Member 'FAnimNode_IKFromPose::HandHeightOffset' has a wrong offset!");

// ScriptStruct DeceiveInc.AnimNode_Sway1P
// 0x00E0 (0x01A8 - 0x00C8)
struct FAnimNode_Sway1P final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         MainShoulderBone;                                  // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         CameraBone;                                        // 0x00D8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         WeaponBone;                                        // 0x00E8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         HandBone;                                          // 0x00F8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         ElbowBone;                                         // 0x0108(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         ExtraFollowHandBone;                               // 0x0118(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                SwayFactor;                                        // 0x0128(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSway;                                       // 0x0134(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_135[0x3];                                      // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnableSwayInterpolationTime;                       // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotateAroundCameraBone;                           // 0x013C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D[0x3];                                      // 0x013D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotateAroundCameraBoneChangeInterpolationTime;     // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShoulderPitchMin;                                  // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShoulderPitchMax;                                  // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShoulderYawMin;                                    // 0x014C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShoulderYawMax;                                    // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSecondaryIK;                                // 0x0154(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_155[0x3];                                      // 0x0155(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecondaryIKInterpolationTime;                      // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneReference                         SecondaryHandBone;                                 // 0x015C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         SecondaryElbowBone;                                // 0x016C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         SecondaryShoulderBone;                             // 0x017C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SideSwayMultiplier;                                // 0x018C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateAroundCameraBoneMultiplier;                  // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x14];                                     // 0x0194(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_Sway1P) == 0x000008, "Wrong alignment on FAnimNode_Sway1P");
static_assert(sizeof(FAnimNode_Sway1P) == 0x0001A8, "Wrong size on FAnimNode_Sway1P");
static_assert(offsetof(FAnimNode_Sway1P, MainShoulderBone) == 0x0000C8, "Member 'FAnimNode_Sway1P::MainShoulderBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_Sway1P, CameraBone) == 0x0000D8, "Member 'FAnimNode_Sway1P::CameraBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_Sway1P, WeaponBone) == 0x0000E8, "Member 'FAnimNode_Sway1P::WeaponBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_Sway1P, HandBone) == 0x0000F8, "Member 'FAnimNode_Sway1P::HandBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_Sway1P, ElbowBone) == 0x000108, "Member 'FAnimNode_Sway1P::ElbowBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_Sway1P, ExtraFollowHandBone) == 0x000118, "Member 'FAnimNode_Sway1P::ExtraFollowHandBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_Sway1P, SwayFactor) == 0x000128, "Member 'FAnimNode_Sway1P::SwayFactor' has a wrong offset!");
static_assert(offsetof(FAnimNode_Sway1P, bEnableSway) == 0x000134, "Member 'FAnimNode_Sway1P::bEnableSway' has a wrong offset!");
static_assert(offsetof(FAnimNode_Sway1P, EnableSwayInterpolationTime) == 0x000138, "Member 'FAnimNode_Sway1P::EnableSwayInterpolationTime' has a wrong offset!");
static_assert(offsetof(FAnimNode_Sway1P, bRotateAroundCameraBone) == 0x00013C, "Member 'FAnimNode_Sway1P::bRotateAroundCameraBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_Sway1P, RotateAroundCameraBoneChangeInterpolationTime) == 0x000140, "Member 'FAnimNode_Sway1P::RotateAroundCameraBoneChangeInterpolationTime' has a wrong offset!");
static_assert(offsetof(FAnimNode_Sway1P, ShoulderPitchMin) == 0x000144, "Member 'FAnimNode_Sway1P::ShoulderPitchMin' has a wrong offset!");
static_assert(offsetof(FAnimNode_Sway1P, ShoulderPitchMax) == 0x000148, "Member 'FAnimNode_Sway1P::ShoulderPitchMax' has a wrong offset!");
static_assert(offsetof(FAnimNode_Sway1P, ShoulderYawMin) == 0x00014C, "Member 'FAnimNode_Sway1P::ShoulderYawMin' has a wrong offset!");
static_assert(offsetof(FAnimNode_Sway1P, ShoulderYawMax) == 0x000150, "Member 'FAnimNode_Sway1P::ShoulderYawMax' has a wrong offset!");
static_assert(offsetof(FAnimNode_Sway1P, bEnableSecondaryIK) == 0x000154, "Member 'FAnimNode_Sway1P::bEnableSecondaryIK' has a wrong offset!");
static_assert(offsetof(FAnimNode_Sway1P, SecondaryIKInterpolationTime) == 0x000158, "Member 'FAnimNode_Sway1P::SecondaryIKInterpolationTime' has a wrong offset!");
static_assert(offsetof(FAnimNode_Sway1P, SecondaryHandBone) == 0x00015C, "Member 'FAnimNode_Sway1P::SecondaryHandBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_Sway1P, SecondaryElbowBone) == 0x00016C, "Member 'FAnimNode_Sway1P::SecondaryElbowBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_Sway1P, SecondaryShoulderBone) == 0x00017C, "Member 'FAnimNode_Sway1P::SecondaryShoulderBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_Sway1P, SideSwayMultiplier) == 0x00018C, "Member 'FAnimNode_Sway1P::SideSwayMultiplier' has a wrong offset!");
static_assert(offsetof(FAnimNode_Sway1P, RotateAroundCameraBoneMultiplier) == 0x000190, "Member 'FAnimNode_Sway1P::RotateAroundCameraBoneMultiplier' has a wrong offset!");

// ScriptStruct DeceiveInc.AnimNode_SweetLookAt
// 0x0010 (0x01C0 - 0x01B0)
struct FAnimNode_SweetLookAt final : public FAnimNode_LookAt
{
public:
	float                                         LookAtAxisPitchOffset;                             // 0x01B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0xC];                                      // 0x01B4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_SweetLookAt) == 0x000010, "Wrong alignment on FAnimNode_SweetLookAt");
static_assert(sizeof(FAnimNode_SweetLookAt) == 0x0001C0, "Wrong size on FAnimNode_SweetLookAt");
static_assert(offsetof(FAnimNode_SweetLookAt, LookAtAxisPitchOffset) == 0x0001B0, "Member 'FAnimNode_SweetLookAt::LookAtAxisPitchOffset' has a wrong offset!");

// ScriptStruct DeceiveInc.LootRewardDefinition
// 0x0020 (0x0020 - 0x0000)
struct FLootRewardDefinition final
{
public:
	class FString                                 PlayerID;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLootBundleDefinition>          Bundles;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLootRewardDefinition) == 0x000008, "Wrong alignment on FLootRewardDefinition");
static_assert(sizeof(FLootRewardDefinition) == 0x000020, "Wrong size on FLootRewardDefinition");
static_assert(offsetof(FLootRewardDefinition, PlayerID) == 0x000000, "Member 'FLootRewardDefinition::PlayerID' has a wrong offset!");
static_assert(offsetof(FLootRewardDefinition, Bundles) == 0x000010, "Member 'FLootRewardDefinition::Bundles' has a wrong offset!");

// ScriptStruct DeceiveInc.ReplicateBlueprintData
// 0x0014 (0x0014 - 0x0000)
struct FReplicateBlueprintData final
{
public:
	float                                         Lifetime;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    Position;                                          // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActive;                                           // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplicateBlueprintData) == 0x000004, "Wrong alignment on FReplicateBlueprintData");
static_assert(sizeof(FReplicateBlueprintData) == 0x000014, "Wrong size on FReplicateBlueprintData");
static_assert(offsetof(FReplicateBlueprintData, Lifetime) == 0x000000, "Member 'FReplicateBlueprintData::Lifetime' has a wrong offset!");
static_assert(offsetof(FReplicateBlueprintData, Position) == 0x000004, "Member 'FReplicateBlueprintData::Position' has a wrong offset!");
static_assert(offsetof(FReplicateBlueprintData, bActive) == 0x000010, "Member 'FReplicateBlueprintData::bActive' has a wrong offset!");

// ScriptStruct DeceiveInc.ContainerGeneratedData
// 0x0020 (0x0020 - 0x0000)
struct FContainerGeneratedData final
{
public:
	uint32                                        PartOfRoomCRC;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        ToReachRoomCells;                                  // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	bool                                          bNoValidCellInRange;                               // 0x0018(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContainerGeneratedData) == 0x000008, "Wrong alignment on FContainerGeneratedData");
static_assert(sizeof(FContainerGeneratedData) == 0x000020, "Wrong size on FContainerGeneratedData");
static_assert(offsetof(FContainerGeneratedData, PartOfRoomCRC) == 0x000000, "Member 'FContainerGeneratedData::PartOfRoomCRC' has a wrong offset!");
static_assert(offsetof(FContainerGeneratedData, ToReachRoomCells) == 0x000008, "Member 'FContainerGeneratedData::ToReachRoomCells' has a wrong offset!");
static_assert(offsetof(FContainerGeneratedData, bNoValidCellInRange) == 0x000018, "Member 'FContainerGeneratedData::bNoValidCellInRange' has a wrong offset!");

// ScriptStruct DeceiveInc.PlatformPurchaseMapping
// 0x0058 (0x0058 - 0x0000)
struct FPlatformPurchaseMapping final
{
public:
	int32                                         SteamItemID;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EOSItemID;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PSItemIDUS;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PSItemIDEU;                                        // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PSItemIDAS;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 XBOXStoreID;                                       // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlatformPurchaseMapping) == 0x000008, "Wrong alignment on FPlatformPurchaseMapping");
static_assert(sizeof(FPlatformPurchaseMapping) == 0x000058, "Wrong size on FPlatformPurchaseMapping");
static_assert(offsetof(FPlatformPurchaseMapping, SteamItemID) == 0x000000, "Member 'FPlatformPurchaseMapping::SteamItemID' has a wrong offset!");
static_assert(offsetof(FPlatformPurchaseMapping, EOSItemID) == 0x000008, "Member 'FPlatformPurchaseMapping::EOSItemID' has a wrong offset!");
static_assert(offsetof(FPlatformPurchaseMapping, PSItemIDUS) == 0x000018, "Member 'FPlatformPurchaseMapping::PSItemIDUS' has a wrong offset!");
static_assert(offsetof(FPlatformPurchaseMapping, PSItemIDEU) == 0x000028, "Member 'FPlatformPurchaseMapping::PSItemIDEU' has a wrong offset!");
static_assert(offsetof(FPlatformPurchaseMapping, PSItemIDAS) == 0x000038, "Member 'FPlatformPurchaseMapping::PSItemIDAS' has a wrong offset!");
static_assert(offsetof(FPlatformPurchaseMapping, XBOXStoreID) == 0x000048, "Member 'FPlatformPurchaseMapping::XBOXStoreID' has a wrong offset!");

// ScriptStruct DeceiveInc.ToolWidgetParam
// 0x0038 (0x0038 - 0x0000)
struct FToolWidgetParam final
{
public:
	TSoftClassPtr<class UClass>                   WidgetClass;                                       // 0x0000(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoAddToViewport;                                // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WidgetName;                                        // 0x002C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FToolWidgetParam) == 0x000008, "Wrong alignment on FToolWidgetParam");
static_assert(sizeof(FToolWidgetParam) == 0x000038, "Wrong size on FToolWidgetParam");
static_assert(offsetof(FToolWidgetParam, WidgetClass) == 0x000000, "Member 'FToolWidgetParam::WidgetClass' has a wrong offset!");
static_assert(offsetof(FToolWidgetParam, bAutoAddToViewport) == 0x000028, "Member 'FToolWidgetParam::bAutoAddToViewport' has a wrong offset!");
static_assert(offsetof(FToolWidgetParam, WidgetName) == 0x00002C, "Member 'FToolWidgetParam::WidgetName' has a wrong offset!");

// ScriptStruct DeceiveInc.ToolAssetsId
// 0x0024 (0x0024 - 0x0000)
struct FToolAssetsId final
{
public:
	struct FPrimaryAssetId                        ToolId;                                            // 0x0000(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        WrapId;                                            // 0x0010(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsToolWrap;                                       // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FToolAssetsId) == 0x000004, "Wrong alignment on FToolAssetsId");
static_assert(sizeof(FToolAssetsId) == 0x000024, "Wrong size on FToolAssetsId");
static_assert(offsetof(FToolAssetsId, ToolId) == 0x000000, "Member 'FToolAssetsId::ToolId' has a wrong offset!");
static_assert(offsetof(FToolAssetsId, WrapId) == 0x000010, "Member 'FToolAssetsId::WrapId' has a wrong offset!");
static_assert(offsetof(FToolAssetsId, bIsToolWrap) == 0x000020, "Member 'FToolAssetsId::bIsToolWrap' has a wrong offset!");

// ScriptStruct DeceiveInc.PossibleObjectToSpawn
// 0x0018 (0x0018 - 0x0000)
struct FPossibleObjectToSpawn final
{
public:
	class FString                                 ObjectType;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnWeight;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ObjectTypeCRC;                                     // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPossibleObjectToSpawn) == 0x000008, "Wrong alignment on FPossibleObjectToSpawn");
static_assert(sizeof(FPossibleObjectToSpawn) == 0x000018, "Wrong size on FPossibleObjectToSpawn");
static_assert(offsetof(FPossibleObjectToSpawn, ObjectType) == 0x000000, "Member 'FPossibleObjectToSpawn::ObjectType' has a wrong offset!");
static_assert(offsetof(FPossibleObjectToSpawn, SpawnWeight) == 0x000010, "Member 'FPossibleObjectToSpawn::SpawnWeight' has a wrong offset!");
static_assert(offsetof(FPossibleObjectToSpawn, ObjectTypeCRC) == 0x000014, "Member 'FPossibleObjectToSpawn::ObjectTypeCRC' has a wrong offset!");

// ScriptStruct DeceiveInc.PossibleObjectsOnSpawnPointType
// 0x0028 (0x0028 - 0x0000)
struct FPossibleObjectsOnSpawnPointType final
{
public:
	class FString                                 SpawnPointType;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPossibleObjectToSpawn>         ObjectsToSpawn;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        SpawnPointTypeCRC;                                 // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPossibleObjectsOnSpawnPointType) == 0x000008, "Wrong alignment on FPossibleObjectsOnSpawnPointType");
static_assert(sizeof(FPossibleObjectsOnSpawnPointType) == 0x000028, "Wrong size on FPossibleObjectsOnSpawnPointType");
static_assert(offsetof(FPossibleObjectsOnSpawnPointType, SpawnPointType) == 0x000000, "Member 'FPossibleObjectsOnSpawnPointType::SpawnPointType' has a wrong offset!");
static_assert(offsetof(FPossibleObjectsOnSpawnPointType, ObjectsToSpawn) == 0x000010, "Member 'FPossibleObjectsOnSpawnPointType::ObjectsToSpawn' has a wrong offset!");
static_assert(offsetof(FPossibleObjectsOnSpawnPointType, SpawnPointTypeCRC) == 0x000020, "Member 'FPossibleObjectsOnSpawnPointType::SpawnPointTypeCRC' has a wrong offset!");

// ScriptStruct DeceiveInc.CachedBounceData
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FCachedBounceData final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCachedBounceData) == 0x000004, "Wrong alignment on FCachedBounceData");
static_assert(sizeof(FCachedBounceData) == 0x00001C, "Wrong size on FCachedBounceData");

// ScriptStruct DeceiveInc.BuyShopItemRequestBody
// 0x0020 (0x0020 - 0x0000)
struct FBuyShopItemRequestBody final
{
public:
	class FString                                 ItemId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrencyId;                                        // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBuyShopItemRequestBody) == 0x000008, "Wrong alignment on FBuyShopItemRequestBody");
static_assert(sizeof(FBuyShopItemRequestBody) == 0x000020, "Wrong size on FBuyShopItemRequestBody");
static_assert(offsetof(FBuyShopItemRequestBody, ItemId) == 0x000000, "Member 'FBuyShopItemRequestBody::ItemId' has a wrong offset!");
static_assert(offsetof(FBuyShopItemRequestBody, CurrencyId) == 0x000010, "Member 'FBuyShopItemRequestBody::CurrencyId' has a wrong offset!");

// ScriptStruct DeceiveInc.ChargeStateInfo
// 0x0002 (0x0002 - 0x0000)
struct FChargeStateInfo final
{
public:
	bool                                          bIsCharging;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChargeCanceled;                                   // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChargeStateInfo) == 0x000001, "Wrong alignment on FChargeStateInfo");
static_assert(sizeof(FChargeStateInfo) == 0x000002, "Wrong size on FChargeStateInfo");
static_assert(offsetof(FChargeStateInfo, bIsCharging) == 0x000000, "Member 'FChargeStateInfo::bIsCharging' has a wrong offset!");
static_assert(offsetof(FChargeStateInfo, bChargeCanceled) == 0x000001, "Member 'FChargeStateInfo::bChargeCanceled' has a wrong offset!");

// ScriptStruct DeceiveInc.RewardPerMatch
// 0x0008 (0x0008 - 0x0000)
struct FRewardPerMatch final
{
public:
	float                                         SoftCurrencyRatioPerXp;                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSoftCurrency;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRewardPerMatch) == 0x000004, "Wrong alignment on FRewardPerMatch");
static_assert(sizeof(FRewardPerMatch) == 0x000008, "Wrong size on FRewardPerMatch");
static_assert(offsetof(FRewardPerMatch, SoftCurrencyRatioPerXp) == 0x000000, "Member 'FRewardPerMatch::SoftCurrencyRatioPerXp' has a wrong offset!");
static_assert(offsetof(FRewardPerMatch, MaxSoftCurrency) == 0x000004, "Member 'FRewardPerMatch::MaxSoftCurrency' has a wrong offset!");

// ScriptStruct DeceiveInc.ClockResponse
// 0x0008 (0x0008 - 0x0000)
struct FClockResponse final
{
public:
	int64                                         EpochSeconds;                                      // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FClockResponse) == 0x000008, "Wrong alignment on FClockResponse");
static_assert(sizeof(FClockResponse) == 0x000008, "Wrong size on FClockResponse");
static_assert(offsetof(FClockResponse, EpochSeconds) == 0x000000, "Member 'FClockResponse::EpochSeconds' has a wrong offset!");

// ScriptStruct DeceiveInc.CoverAffectingSourceInfo
// 0x0010 (0x0010 - 0x0000)
struct FCoverAffectingSourceInfo final
{
public:
	ECoverAffectingSourceType                     Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoverAffectingSourceInfo) == 0x000008, "Wrong alignment on FCoverAffectingSourceInfo");
static_assert(sizeof(FCoverAffectingSourceInfo) == 0x000010, "Wrong size on FCoverAffectingSourceInfo");
static_assert(offsetof(FCoverAffectingSourceInfo, Type) == 0x000000, "Member 'FCoverAffectingSourceInfo::Type' has a wrong offset!");
static_assert(offsetof(FCoverAffectingSourceInfo, Icon) == 0x000008, "Member 'FCoverAffectingSourceInfo::Icon' has a wrong offset!");

// ScriptStruct DeceiveInc.UserDataResponse
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FUserDataResponse final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUserDataResponse) == 0x000008, "Wrong alignment on FUserDataResponse");
static_assert(sizeof(FUserDataResponse) == 0x000010, "Wrong size on FUserDataResponse");

// ScriptStruct DeceiveInc.DISerializedAgentSelectionInfo
// 0x00A4 (0x00A4 - 0x0000)
struct FDISerializedAgentSelectionInfo final
{
public:
	struct FPrimaryAssetId                        AgentSkinId;                                       // 0x0000(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        IntroPoseId;                                       // 0x0010(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        WeaponVariant;                                     // 0x0020(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        WeaponWrapId;                                      // 0x0030(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        Gadget1;                                           // 0x0040(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        Gadget1WrapId;                                     // 0x0050(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        Gadget2;                                           // 0x0060(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        Gadget2WrapId;                                     // 0x0070(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ActiveVariant;                                     // 0x0080(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        PassiveVariant;                                    // 0x0090(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEmptyGadgets;                                     // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EquippedDeck;                                      // 0x00A1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x2];                                       // 0x00A2(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDISerializedAgentSelectionInfo) == 0x000004, "Wrong alignment on FDISerializedAgentSelectionInfo");
static_assert(sizeof(FDISerializedAgentSelectionInfo) == 0x0000A4, "Wrong size on FDISerializedAgentSelectionInfo");
static_assert(offsetof(FDISerializedAgentSelectionInfo, AgentSkinId) == 0x000000, "Member 'FDISerializedAgentSelectionInfo::AgentSkinId' has a wrong offset!");
static_assert(offsetof(FDISerializedAgentSelectionInfo, IntroPoseId) == 0x000010, "Member 'FDISerializedAgentSelectionInfo::IntroPoseId' has a wrong offset!");
static_assert(offsetof(FDISerializedAgentSelectionInfo, WeaponVariant) == 0x000020, "Member 'FDISerializedAgentSelectionInfo::WeaponVariant' has a wrong offset!");
static_assert(offsetof(FDISerializedAgentSelectionInfo, WeaponWrapId) == 0x000030, "Member 'FDISerializedAgentSelectionInfo::WeaponWrapId' has a wrong offset!");
static_assert(offsetof(FDISerializedAgentSelectionInfo, Gadget1) == 0x000040, "Member 'FDISerializedAgentSelectionInfo::Gadget1' has a wrong offset!");
static_assert(offsetof(FDISerializedAgentSelectionInfo, Gadget1WrapId) == 0x000050, "Member 'FDISerializedAgentSelectionInfo::Gadget1WrapId' has a wrong offset!");
static_assert(offsetof(FDISerializedAgentSelectionInfo, Gadget2) == 0x000060, "Member 'FDISerializedAgentSelectionInfo::Gadget2' has a wrong offset!");
static_assert(offsetof(FDISerializedAgentSelectionInfo, Gadget2WrapId) == 0x000070, "Member 'FDISerializedAgentSelectionInfo::Gadget2WrapId' has a wrong offset!");
static_assert(offsetof(FDISerializedAgentSelectionInfo, ActiveVariant) == 0x000080, "Member 'FDISerializedAgentSelectionInfo::ActiveVariant' has a wrong offset!");
static_assert(offsetof(FDISerializedAgentSelectionInfo, PassiveVariant) == 0x000090, "Member 'FDISerializedAgentSelectionInfo::PassiveVariant' has a wrong offset!");
static_assert(offsetof(FDISerializedAgentSelectionInfo, bEmptyGadgets) == 0x0000A0, "Member 'FDISerializedAgentSelectionInfo::bEmptyGadgets' has a wrong offset!");
static_assert(offsetof(FDISerializedAgentSelectionInfo, EquippedDeck) == 0x0000A1, "Member 'FDISerializedAgentSelectionInfo::EquippedDeck' has a wrong offset!");

// ScriptStruct DeceiveInc.PlayerAgentSelectionInfo
// 0x00B4 (0x00B4 - 0x0000)
struct FPlayerAgentSelectionInfo final
{
public:
	struct FPrimaryAssetId                        AgentId;                                           // 0x0000(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDISerializedAgentSelectionInfo        SelectionInfo;                                     // 0x0010(0x00A4)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerAgentSelectionInfo) == 0x000004, "Wrong alignment on FPlayerAgentSelectionInfo");
static_assert(sizeof(FPlayerAgentSelectionInfo) == 0x0000B4, "Wrong size on FPlayerAgentSelectionInfo");
static_assert(offsetof(FPlayerAgentSelectionInfo, AgentId) == 0x000000, "Member 'FPlayerAgentSelectionInfo::AgentId' has a wrong offset!");
static_assert(offsetof(FPlayerAgentSelectionInfo, SelectionInfo) == 0x000010, "Member 'FPlayerAgentSelectionInfo::SelectionInfo' has a wrong offset!");

// ScriptStruct DeceiveInc.PlatformInfo
// 0x0020 (0x0020 - 0x0000)
struct FPlatformInfo final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             UITexture;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlatformInfo) == 0x000008, "Wrong alignment on FPlatformInfo");
static_assert(sizeof(FPlatformInfo) == 0x000020, "Wrong size on FPlatformInfo");
static_assert(offsetof(FPlatformInfo, Name) == 0x000000, "Member 'FPlatformInfo::Name' has a wrong offset!");
static_assert(offsetof(FPlatformInfo, UITexture) == 0x000018, "Member 'FPlatformInfo::UITexture' has a wrong offset!");

// ScriptStruct DeceiveInc.PregameLobbySessionInfo
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FPregameLobbySessionInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetId                        PregameLobbyMapDataId;                             // 0x0008(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        DestinationMapDataId;                              // 0x0018(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPregameLobbySessionInfo) == 0x000008, "Wrong alignment on FPregameLobbySessionInfo");
static_assert(sizeof(FPregameLobbySessionInfo) == 0x000028, "Wrong size on FPregameLobbySessionInfo");
static_assert(offsetof(FPregameLobbySessionInfo, PregameLobbyMapDataId) == 0x000008, "Member 'FPregameLobbySessionInfo::PregameLobbyMapDataId' has a wrong offset!");
static_assert(offsetof(FPregameLobbySessionInfo, DestinationMapDataId) == 0x000018, "Member 'FPregameLobbySessionInfo::DestinationMapDataId' has a wrong offset!");

// ScriptStruct DeceiveInc.SpyGameSessionInfo
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FSpyGameSessionInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetId                        SpyGameModeMapDataId;                              // 0x0008(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        NextPregameLobbyMapDataId;                         // 0x0018(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpyGameSessionInfo) == 0x000008, "Wrong alignment on FSpyGameSessionInfo");
static_assert(sizeof(FSpyGameSessionInfo) == 0x000028, "Wrong size on FSpyGameSessionInfo");
static_assert(offsetof(FSpyGameSessionInfo, SpyGameModeMapDataId) == 0x000008, "Member 'FSpyGameSessionInfo::SpyGameModeMapDataId' has a wrong offset!");
static_assert(offsetof(FSpyGameSessionInfo, NextPregameLobbyMapDataId) == 0x000018, "Member 'FSpyGameSessionInfo::NextPregameLobbyMapDataId' has a wrong offset!");

// ScriptStruct DeceiveInc.FactionResponse
// 0x0020 (0x0020 - 0x0000)
struct FFactionResponse final
{
public:
	class FString                                 TeamName;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         PlayerIds;                                         // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFactionResponse) == 0x000008, "Wrong alignment on FFactionResponse");
static_assert(sizeof(FFactionResponse) == 0x000020, "Wrong size on FFactionResponse");
static_assert(offsetof(FFactionResponse, TeamName) == 0x000000, "Member 'FFactionResponse::TeamName' has a wrong offset!");
static_assert(offsetof(FFactionResponse, PlayerIds) == 0x000010, "Member 'FFactionResponse::PlayerIds' has a wrong offset!");

// ScriptStruct DeceiveInc.PlayerEACData
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FPlayerEACData final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerEACData) == 0x000008, "Wrong alignment on FPlayerEACData");
static_assert(sizeof(FPlayerEACData) == 0x000030, "Wrong size on FPlayerEACData");

// ScriptStruct DeceiveInc.ProgressionReward
// 0x0018 (0x0018 - 0x0000)
struct FProgressionReward final
{
public:
	int32                                         LvlObtained;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLevelReward                           RewardData;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProgressionReward) == 0x000008, "Wrong alignment on FProgressionReward");
static_assert(sizeof(FProgressionReward) == 0x000018, "Wrong size on FProgressionReward");
static_assert(offsetof(FProgressionReward, LvlObtained) == 0x000000, "Member 'FProgressionReward::LvlObtained' has a wrong offset!");
static_assert(offsetof(FProgressionReward, RewardData) == 0x000008, "Member 'FProgressionReward::RewardData' has a wrong offset!");

// ScriptStruct DeceiveInc.EchelonProgression
// 0x0038 (0x0038 - 0x0000)
struct FEchelonProgression final
{
public:
	int32                                         LvlToUnlock;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              EchelonImage;                                      // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 EchelonColor;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEchelonProgression) == 0x000008, "Wrong alignment on FEchelonProgression");
static_assert(sizeof(FEchelonProgression) == 0x000038, "Wrong size on FEchelonProgression");
static_assert(offsetof(FEchelonProgression, LvlToUnlock) == 0x000000, "Member 'FEchelonProgression::LvlToUnlock' has a wrong offset!");
static_assert(offsetof(FEchelonProgression, EchelonImage) == 0x000008, "Member 'FEchelonProgression::EchelonImage' has a wrong offset!");
static_assert(offsetof(FEchelonProgression, EchelonColor) == 0x000030, "Member 'FEchelonProgression::EchelonColor' has a wrong offset!");

// ScriptStruct DeceiveInc.XpEventGroupDisplayInfo
// 0x0050 (0x0050 - 0x0000)
struct FXpEventGroupDisplayInfo final
{
public:
	float                                         TotalXp;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriggerAmount;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTriggerAmount;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateColor                            DisplayColor;                                      // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FXpEventGroupDisplayInfo) == 0x000008, "Wrong alignment on FXpEventGroupDisplayInfo");
static_assert(sizeof(FXpEventGroupDisplayInfo) == 0x000050, "Wrong size on FXpEventGroupDisplayInfo");
static_assert(offsetof(FXpEventGroupDisplayInfo, TotalXp) == 0x000000, "Member 'FXpEventGroupDisplayInfo::TotalXp' has a wrong offset!");
static_assert(offsetof(FXpEventGroupDisplayInfo, TriggerAmount) == 0x000004, "Member 'FXpEventGroupDisplayInfo::TriggerAmount' has a wrong offset!");
static_assert(offsetof(FXpEventGroupDisplayInfo, MaxTriggerAmount) == 0x000008, "Member 'FXpEventGroupDisplayInfo::MaxTriggerAmount' has a wrong offset!");
static_assert(offsetof(FXpEventGroupDisplayInfo, DisplayName) == 0x000010, "Member 'FXpEventGroupDisplayInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FXpEventGroupDisplayInfo, DisplayColor) == 0x000028, "Member 'FXpEventGroupDisplayInfo::DisplayColor' has a wrong offset!");

// ScriptStruct DeceiveInc.XpTypeEventGroupDisplayInfo
// 0x00B0 (0x00B0 - 0x0000)
struct FXpTypeEventGroupDisplayInfo final
{
public:
	class FString                                 XpTypeGroup;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FXpEventGroupDisplayInfo> XpEventDisplayInfo;                                // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FString, struct FXpEventGroupDisplayInfo> XpMultiplicatorEventDisplayInfo;                   // 0x0060(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FXpTypeEventGroupDisplayInfo) == 0x000008, "Wrong alignment on FXpTypeEventGroupDisplayInfo");
static_assert(sizeof(FXpTypeEventGroupDisplayInfo) == 0x0000B0, "Wrong size on FXpTypeEventGroupDisplayInfo");
static_assert(offsetof(FXpTypeEventGroupDisplayInfo, XpTypeGroup) == 0x000000, "Member 'FXpTypeEventGroupDisplayInfo::XpTypeGroup' has a wrong offset!");
static_assert(offsetof(FXpTypeEventGroupDisplayInfo, XpEventDisplayInfo) == 0x000010, "Member 'FXpTypeEventGroupDisplayInfo::XpEventDisplayInfo' has a wrong offset!");
static_assert(offsetof(FXpTypeEventGroupDisplayInfo, XpMultiplicatorEventDisplayInfo) == 0x000060, "Member 'FXpTypeEventGroupDisplayInfo::XpMultiplicatorEventDisplayInfo' has a wrong offset!");

// ScriptStruct DeceiveInc.VaultUnlockedPhaseData
// 0x0078 (0x00C8 - 0x0050)
struct FVaultUnlockedPhaseData final : public FSpyGamePhaseData
{
public:
	int32                                         DefaultPhaseDuration;                              // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CriticalTimeLeft;                                  // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CriticalTimeAnnoucementText;                       // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EAnnouncementType                             CriticalTimeAnnoucementType;                       // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CriticalTimeAnnoucementPriority;                   // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalTimeAnnoucementDuration;                   // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ObjectiveDescTxtOutsideVault;                      // 0x0080(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ObjectiveDescTxtInsideVault;                       // 0x0098(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ObjectivePromptText;                               // 0x00B0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVaultUnlockedPhaseData) == 0x000008, "Wrong alignment on FVaultUnlockedPhaseData");
static_assert(sizeof(FVaultUnlockedPhaseData) == 0x0000C8, "Wrong size on FVaultUnlockedPhaseData");
static_assert(offsetof(FVaultUnlockedPhaseData, DefaultPhaseDuration) == 0x000050, "Member 'FVaultUnlockedPhaseData::DefaultPhaseDuration' has a wrong offset!");
static_assert(offsetof(FVaultUnlockedPhaseData, CriticalTimeLeft) == 0x000054, "Member 'FVaultUnlockedPhaseData::CriticalTimeLeft' has a wrong offset!");
static_assert(offsetof(FVaultUnlockedPhaseData, CriticalTimeAnnoucementText) == 0x000058, "Member 'FVaultUnlockedPhaseData::CriticalTimeAnnoucementText' has a wrong offset!");
static_assert(offsetof(FVaultUnlockedPhaseData, CriticalTimeAnnoucementType) == 0x000070, "Member 'FVaultUnlockedPhaseData::CriticalTimeAnnoucementType' has a wrong offset!");
static_assert(offsetof(FVaultUnlockedPhaseData, CriticalTimeAnnoucementPriority) == 0x000074, "Member 'FVaultUnlockedPhaseData::CriticalTimeAnnoucementPriority' has a wrong offset!");
static_assert(offsetof(FVaultUnlockedPhaseData, CriticalTimeAnnoucementDuration) == 0x000078, "Member 'FVaultUnlockedPhaseData::CriticalTimeAnnoucementDuration' has a wrong offset!");
static_assert(offsetof(FVaultUnlockedPhaseData, ObjectiveDescTxtOutsideVault) == 0x000080, "Member 'FVaultUnlockedPhaseData::ObjectiveDescTxtOutsideVault' has a wrong offset!");
static_assert(offsetof(FVaultUnlockedPhaseData, ObjectiveDescTxtInsideVault) == 0x000098, "Member 'FVaultUnlockedPhaseData::ObjectiveDescTxtInsideVault' has a wrong offset!");
static_assert(offsetof(FVaultUnlockedPhaseData, ObjectivePromptText) == 0x0000B0, "Member 'FVaultUnlockedPhaseData::ObjectivePromptText' has a wrong offset!");

// ScriptStruct DeceiveInc.PlayerMatchResult
// 0x0088 (0x0088 - 0x0000)
struct alignas(0x08) FPlayerMatchResult final
{
public:
	uint8                                         Pad_0[0x88];                                       // 0x0000(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerMatchResult) == 0x000008, "Wrong alignment on FPlayerMatchResult");
static_assert(sizeof(FPlayerMatchResult) == 0x000088, "Wrong size on FPlayerMatchResult");

// ScriptStruct DeceiveInc.PlayerXPInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FPlayerXPInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerXPInfo) == 0x000008, "Wrong alignment on FPlayerXPInfo");
static_assert(sizeof(FPlayerXPInfo) == 0x000018, "Wrong size on FPlayerXPInfo");

// ScriptStruct DeceiveInc.NavModeItemList
// 0x0010 (0x0010 - 0x0000)
struct FNavModeItemList final
{
public:
	TArray<class UNavModeItemComponent*>          NavmodeItems;                                      // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavModeItemList) == 0x000008, "Wrong alignment on FNavModeItemList");
static_assert(sizeof(FNavModeItemList) == 0x000010, "Wrong size on FNavModeItemList");
static_assert(offsetof(FNavModeItemList, NavmodeItems) == 0x000000, "Member 'FNavModeItemList::NavmodeItems' has a wrong offset!");

// ScriptStruct DeceiveInc.SandboxSettings
// 0x0080 (0x0080 - 0x0000)
struct FSandboxSettings final
{
public:
	bool                                          bIsPrivateSandboxGame;                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrivateFillBot;                                   // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 NPCPopulation;                                     // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FObjectToSpawnCount>            ObjectsToSpawnCountOverride;                       // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FHeatSetupData                         HeatSettings;                                      // 0x0028(0x0050)(NativeAccessSpecifierPublic)
	EBotsDifficulty                               BotsDifficulty;                                    // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BotsAmount;                                        // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSandboxSettings) == 0x000008, "Wrong alignment on FSandboxSettings");
static_assert(sizeof(FSandboxSettings) == 0x000080, "Wrong size on FSandboxSettings");
static_assert(offsetof(FSandboxSettings, bIsPrivateSandboxGame) == 0x000000, "Member 'FSandboxSettings::bIsPrivateSandboxGame' has a wrong offset!");
static_assert(offsetof(FSandboxSettings, bPrivateFillBot) == 0x000001, "Member 'FSandboxSettings::bPrivateFillBot' has a wrong offset!");
static_assert(offsetof(FSandboxSettings, NPCPopulation) == 0x000008, "Member 'FSandboxSettings::NPCPopulation' has a wrong offset!");
static_assert(offsetof(FSandboxSettings, ObjectsToSpawnCountOverride) == 0x000018, "Member 'FSandboxSettings::ObjectsToSpawnCountOverride' has a wrong offset!");
static_assert(offsetof(FSandboxSettings, HeatSettings) == 0x000028, "Member 'FSandboxSettings::HeatSettings' has a wrong offset!");
static_assert(offsetof(FSandboxSettings, BotsDifficulty) == 0x000078, "Member 'FSandboxSettings::BotsDifficulty' has a wrong offset!");
static_assert(offsetof(FSandboxSettings, BotsAmount) == 0x00007C, "Member 'FSandboxSettings::BotsAmount' has a wrong offset!");

// ScriptStruct DeceiveInc.RollKickInfo
// 0x0018 (0x0018 - 0x0000)
struct FRollKickInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            Curve;                                             // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRollKickInfo) == 0x000008, "Wrong alignment on FRollKickInfo");
static_assert(sizeof(FRollKickInfo) == 0x000018, "Wrong size on FRollKickInfo");
static_assert(offsetof(FRollKickInfo, Curve) == 0x000010, "Member 'FRollKickInfo::Curve' has a wrong offset!");

// ScriptStruct DeceiveInc.ReportAccelbyteRequestBody
// 0x0040 (0x0040 - 0x0000)
struct FReportAccelbyteRequestBody final
{
public:
	class FString                                 Reporter;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccelbyteId;                                       // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchId;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReportAccelbyteRequestBody) == 0x000008, "Wrong alignment on FReportAccelbyteRequestBody");
static_assert(sizeof(FReportAccelbyteRequestBody) == 0x000040, "Wrong size on FReportAccelbyteRequestBody");
static_assert(offsetof(FReportAccelbyteRequestBody, Reporter) == 0x000000, "Member 'FReportAccelbyteRequestBody::Reporter' has a wrong offset!");
static_assert(offsetof(FReportAccelbyteRequestBody, AccelbyteId) == 0x000010, "Member 'FReportAccelbyteRequestBody::AccelbyteId' has a wrong offset!");
static_assert(offsetof(FReportAccelbyteRequestBody, MatchId) == 0x000020, "Member 'FReportAccelbyteRequestBody::MatchId' has a wrong offset!");
static_assert(offsetof(FReportAccelbyteRequestBody, Message) == 0x000030, "Member 'FReportAccelbyteRequestBody::Message' has a wrong offset!");

// ScriptStruct DeceiveInc.RecoilInfo
// 0x0030 (0x0030 - 0x0000)
struct FRecoilInfo final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RecoilCurve;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRecoilInfo) == 0x000008, "Wrong alignment on FRecoilInfo");
static_assert(sizeof(FRecoilInfo) == 0x000030, "Wrong size on FRecoilInfo");
static_assert(offsetof(FRecoilInfo, RecoilCurve) == 0x000028, "Member 'FRecoilInfo::RecoilCurve' has a wrong offset!");

// ScriptStruct DeceiveInc.FanartAssetDefinition
// 0x0030 (0x0030 - 0x0000)
struct FFanartAssetDefinition final
{
public:
	class FString                                 AssetURL;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Author;                                            // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFanartAssetDefinition) == 0x000008, "Wrong alignment on FFanartAssetDefinition");
static_assert(sizeof(FFanartAssetDefinition) == 0x000030, "Wrong size on FFanartAssetDefinition");
static_assert(offsetof(FFanartAssetDefinition, AssetURL) == 0x000000, "Member 'FFanartAssetDefinition::AssetURL' has a wrong offset!");
static_assert(offsetof(FFanartAssetDefinition, Title) == 0x000010, "Member 'FFanartAssetDefinition::Title' has a wrong offset!");
static_assert(offsetof(FFanartAssetDefinition, Author) == 0x000020, "Member 'FFanartAssetDefinition::Author' has a wrong offset!");

// ScriptStruct DeceiveInc.DIFanartSettings
// 0x0010 (0x0010 - 0x0000)
struct FDIFanartSettings final
{
public:
	TArray<struct FFanartAssetDefinition>         Fanart;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDIFanartSettings) == 0x000008, "Wrong alignment on FDIFanartSettings");
static_assert(sizeof(FDIFanartSettings) == 0x000010, "Wrong size on FDIFanartSettings");
static_assert(offsetof(FDIFanartSettings, Fanart) == 0x000000, "Member 'FDIFanartSettings::Fanart' has a wrong offset!");

// ScriptStruct DeceiveInc.ConnectedRoomData
// 0x0020 (0x0020 - 0x0000)
struct FConnectedRoomData final
{
public:
	float                                         PathDistance;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistFactor;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ExitCellPos;                                       // 0x0008(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESecurityLevel                                MinimumSecurityLevel;                              // 0x0014(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0xB];                                       // 0x0015(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConnectedRoomData) == 0x000004, "Wrong alignment on FConnectedRoomData");
static_assert(sizeof(FConnectedRoomData) == 0x000020, "Wrong size on FConnectedRoomData");
static_assert(offsetof(FConnectedRoomData, PathDistance) == 0x000000, "Member 'FConnectedRoomData::PathDistance' has a wrong offset!");
static_assert(offsetof(FConnectedRoomData, DistFactor) == 0x000004, "Member 'FConnectedRoomData::DistFactor' has a wrong offset!");
static_assert(offsetof(FConnectedRoomData, ExitCellPos) == 0x000008, "Member 'FConnectedRoomData::ExitCellPos' has a wrong offset!");
static_assert(offsetof(FConnectedRoomData, MinimumSecurityLevel) == 0x000014, "Member 'FConnectedRoomData::MinimumSecurityLevel' has a wrong offset!");

// ScriptStruct DeceiveInc.DIMapWeight
// 0x0010 (0x0010 - 0x0000)
struct FDIMapWeight final
{
public:
	class UMapData*                               MapDataAsset;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapWeightInRotation;                               // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDIMapWeight) == 0x000008, "Wrong alignment on FDIMapWeight");
static_assert(sizeof(FDIMapWeight) == 0x000010, "Wrong size on FDIMapWeight");
static_assert(offsetof(FDIMapWeight, MapDataAsset) == 0x000000, "Member 'FDIMapWeight::MapDataAsset' has a wrong offset!");
static_assert(offsetof(FDIMapWeight, MapWeightInRotation) == 0x000008, "Member 'FDIMapWeight::MapWeightInRotation' has a wrong offset!");

// ScriptStruct DeceiveInc.DIMapConfigSettings
// 0x0010 (0x0010 - 0x0000)
struct FDIMapConfigSettings final
{
public:
	TArray<struct FDIMapWeight>                   MapWeights;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDIMapConfigSettings) == 0x000008, "Wrong alignment on FDIMapConfigSettings");
static_assert(sizeof(FDIMapConfigSettings) == 0x000010, "Wrong size on FDIMapConfigSettings");
static_assert(offsetof(FDIMapConfigSettings, MapWeights) == 0x000000, "Member 'FDIMapConfigSettings::MapWeights' has a wrong offset!");

// ScriptStruct DeceiveInc.DIServerConfigSettings
// 0x0028 (0x0028 - 0x0000)
struct FDIServerConfigSettings final
{
public:
	struct FDILimitedTimeFeatureSettings          DoubleXPSettings;                                  // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FDIMapConfigSettings                   MapConfig;                                         // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDIServerConfigSettings) == 0x000008, "Wrong alignment on FDIServerConfigSettings");
static_assert(sizeof(FDIServerConfigSettings) == 0x000028, "Wrong size on FDIServerConfigSettings");
static_assert(offsetof(FDIServerConfigSettings, DoubleXPSettings) == 0x000000, "Member 'FDIServerConfigSettings::DoubleXPSettings' has a wrong offset!");
static_assert(offsetof(FDIServerConfigSettings, MapConfig) == 0x000018, "Member 'FDIServerConfigSettings::MapConfig' has a wrong offset!");

// ScriptStruct DeceiveInc.StartTwitchOauthFlowResponse
// 0x0010 (0x0010 - 0x0000)
struct FStartTwitchOauthFlowResponse final
{
public:
	class FString                                 State;                                             // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStartTwitchOauthFlowResponse) == 0x000008, "Wrong alignment on FStartTwitchOauthFlowResponse");
static_assert(sizeof(FStartTwitchOauthFlowResponse) == 0x000010, "Wrong size on FStartTwitchOauthFlowResponse");
static_assert(offsetof(FStartTwitchOauthFlowResponse, State) == 0x000000, "Member 'FStartTwitchOauthFlowResponse::State' has a wrong offset!");

// ScriptStruct DeceiveInc.DescribeAllowedGameModesResponse
// 0x0002 (0x0002 - 0x0000)
struct FDescribeAllowedGameModesResponse final
{
public:
	bool                                          bCrossplayAllowed;                                 // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeamsAllowed;                                     // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDescribeAllowedGameModesResponse) == 0x000001, "Wrong alignment on FDescribeAllowedGameModesResponse");
static_assert(sizeof(FDescribeAllowedGameModesResponse) == 0x000002, "Wrong size on FDescribeAllowedGameModesResponse");
static_assert(offsetof(FDescribeAllowedGameModesResponse, bCrossplayAllowed) == 0x000000, "Member 'FDescribeAllowedGameModesResponse::bCrossplayAllowed' has a wrong offset!");
static_assert(offsetof(FDescribeAllowedGameModesResponse, bTeamsAllowed) == 0x000001, "Member 'FDescribeAllowedGameModesResponse::bTeamsAllowed' has a wrong offset!");

// ScriptStruct DeceiveInc.PlayerSettingEntry
// 0x0030 (0x0030 - 0x0000)
struct FPlayerSettingEntry final
{
public:
	EPlayerSettingsType                           Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   SettingWidget;                                     // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerSettingEntry) == 0x000008, "Wrong alignment on FPlayerSettingEntry");
static_assert(sizeof(FPlayerSettingEntry) == 0x000030, "Wrong size on FPlayerSettingEntry");
static_assert(offsetof(FPlayerSettingEntry, Type) == 0x000000, "Member 'FPlayerSettingEntry::Type' has a wrong offset!");
static_assert(offsetof(FPlayerSettingEntry, SettingWidget) == 0x000008, "Member 'FPlayerSettingEntry::SettingWidget' has a wrong offset!");

// ScriptStruct DeceiveInc.DIBalancingDataUpdateEntry
// 0x0020 (0x0020 - 0x0000)
struct FDIBalancingDataUpdateEntry final
{
public:
	class FString                                 TableName;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CSVData;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDIBalancingDataUpdateEntry) == 0x000008, "Wrong alignment on FDIBalancingDataUpdateEntry");
static_assert(sizeof(FDIBalancingDataUpdateEntry) == 0x000020, "Wrong size on FDIBalancingDataUpdateEntry");
static_assert(offsetof(FDIBalancingDataUpdateEntry, TableName) == 0x000000, "Member 'FDIBalancingDataUpdateEntry::TableName' has a wrong offset!");
static_assert(offsetof(FDIBalancingDataUpdateEntry, CSVData) == 0x000010, "Member 'FDIBalancingDataUpdateEntry::CSVData' has a wrong offset!");

// ScriptStruct DeceiveInc.DIBalancingDataUpdate
// 0x0010 (0x0010 - 0x0000)
struct FDIBalancingDataUpdate final
{
public:
	TArray<struct FDIBalancingDataUpdateEntry>    Tables;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDIBalancingDataUpdate) == 0x000008, "Wrong alignment on FDIBalancingDataUpdate");
static_assert(sizeof(FDIBalancingDataUpdate) == 0x000010, "Wrong size on FDIBalancingDataUpdate");
static_assert(offsetof(FDIBalancingDataUpdate, Tables) == 0x000000, "Member 'FDIBalancingDataUpdate::Tables' has a wrong offset!");

// ScriptStruct DeceiveInc.NPCLookAtReplicationData
// 0x000C (0x000C - 0x0000)
struct FNPCLookAtReplicationData final
{
public:
	struct FVector_NetQuantize                    TargetLookAtPos;                                   // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCLookAtReplicationData) == 0x000004, "Wrong alignment on FNPCLookAtReplicationData");
static_assert(sizeof(FNPCLookAtReplicationData) == 0x00000C, "Wrong size on FNPCLookAtReplicationData");
static_assert(offsetof(FNPCLookAtReplicationData, TargetLookAtPos) == 0x000000, "Member 'FNPCLookAtReplicationData::TargetLookAtPos' has a wrong offset!");

// ScriptStruct DeceiveInc.NPCFindFloorResult
// 0x0094 (0x0094 - 0x0000)
struct FNPCFindFloorResult final
{
public:
	uint8                                         bBlockingHit : 1;                                  // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWalkableFloor : 1;                                // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLineTrace : 1;                                    // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FloorDist;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineDist;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x000C(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCFindFloorResult) == 0x000004, "Wrong alignment on FNPCFindFloorResult");
static_assert(sizeof(FNPCFindFloorResult) == 0x000094, "Wrong size on FNPCFindFloorResult");
static_assert(offsetof(FNPCFindFloorResult, FloorDist) == 0x000004, "Member 'FNPCFindFloorResult::FloorDist' has a wrong offset!");
static_assert(offsetof(FNPCFindFloorResult, LineDist) == 0x000008, "Member 'FNPCFindFloorResult::LineDist' has a wrong offset!");
static_assert(offsetof(FNPCFindFloorResult, HitResult) == 0x00000C, "Member 'FNPCFindFloorResult::HitResult' has a wrong offset!");

// ScriptStruct DeceiveInc.BuyItemInfo
// 0x0040 (0x0040 - 0x0000)
struct FBuyItemInfo final
{
public:
	class FString                                 ItemId;                                            // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrencyId;                                        // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x20];                                      // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBuyItemInfo) == 0x000008, "Wrong alignment on FBuyItemInfo");
static_assert(sizeof(FBuyItemInfo) == 0x000040, "Wrong size on FBuyItemInfo");
static_assert(offsetof(FBuyItemInfo, ItemId) == 0x000000, "Member 'FBuyItemInfo::ItemId' has a wrong offset!");
static_assert(offsetof(FBuyItemInfo, CurrencyId) == 0x000010, "Member 'FBuyItemInfo::CurrencyId' has a wrong offset!");

// ScriptStruct DeceiveInc.FactionTeamPlan
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FFactionTeamPlan final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFactionTeamPlan) == 0x000008, "Wrong alignment on FFactionTeamPlan");
static_assert(sizeof(FFactionTeamPlan) == 0x000020, "Wrong size on FFactionTeamPlan");

// ScriptStruct DeceiveInc.XpEventInfo
// 0x0068 (0x0068 - 0x0000)
struct FXpEventInfo final
{
public:
	int32                                         XpGiven;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxEventTrigger;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSharedToFaction;                                // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateColor                            DisplayColor;                                      // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bAffectGenericXpType;                              // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         SpecificXpTypeToAffect;                            // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FXpEventInfo) == 0x000008, "Wrong alignment on FXpEventInfo");
static_assert(sizeof(FXpEventInfo) == 0x000068, "Wrong size on FXpEventInfo");
static_assert(offsetof(FXpEventInfo, XpGiven) == 0x000000, "Member 'FXpEventInfo::XpGiven' has a wrong offset!");
static_assert(offsetof(FXpEventInfo, MaxEventTrigger) == 0x000004, "Member 'FXpEventInfo::MaxEventTrigger' has a wrong offset!");
static_assert(offsetof(FXpEventInfo, bIsSharedToFaction) == 0x000008, "Member 'FXpEventInfo::bIsSharedToFaction' has a wrong offset!");
static_assert(offsetof(FXpEventInfo, DisplayName) == 0x000010, "Member 'FXpEventInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FXpEventInfo, DisplayColor) == 0x000028, "Member 'FXpEventInfo::DisplayColor' has a wrong offset!");
static_assert(offsetof(FXpEventInfo, bAffectGenericXpType) == 0x000050, "Member 'FXpEventInfo::bAffectGenericXpType' has a wrong offset!");
static_assert(offsetof(FXpEventInfo, SpecificXpTypeToAffect) == 0x000058, "Member 'FXpEventInfo::SpecificXpTypeToAffect' has a wrong offset!");

// ScriptStruct DeceiveInc.AgreementInfo
// 0x0048 (0x0048 - 0x0000)
struct FAgreementInfo final
{
public:
	class FString                                 AgreementName;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   AgreementTitle;                                    // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   AgreementText;                                     // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EPopupType                                    AgreementType;                                     // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAgreementInfo) == 0x000008, "Wrong alignment on FAgreementInfo");
static_assert(sizeof(FAgreementInfo) == 0x000048, "Wrong size on FAgreementInfo");
static_assert(offsetof(FAgreementInfo, AgreementName) == 0x000000, "Member 'FAgreementInfo::AgreementName' has a wrong offset!");
static_assert(offsetof(FAgreementInfo, AgreementTitle) == 0x000010, "Member 'FAgreementInfo::AgreementTitle' has a wrong offset!");
static_assert(offsetof(FAgreementInfo, AgreementText) == 0x000028, "Member 'FAgreementInfo::AgreementText' has a wrong offset!");
static_assert(offsetof(FAgreementInfo, AgreementType) == 0x000040, "Member 'FAgreementInfo::AgreementType' has a wrong offset!");

// ScriptStruct DeceiveInc.DIRuleDefinition
// 0x00F8 (0x00F8 - 0x0000)
struct FDIRuleDefinition final
{
public:
	TMap<TSoftObjectPtr<class UDataTable>, TSoftObjectPtr<class UDataTable>> DataTableOverrides;                                // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class UDataAsset>, TSoftObjectPtr<class UDataAsset>> DataAssetOverrides;                                // 0x0050(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class UObject>, TSoftObjectPtr<class UObject>> GenericObjectOverrides;                            // 0x00A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         SpecialRules;                                      // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDIRuleDefinition) == 0x000008, "Wrong alignment on FDIRuleDefinition");
static_assert(sizeof(FDIRuleDefinition) == 0x0000F8, "Wrong size on FDIRuleDefinition");
static_assert(offsetof(FDIRuleDefinition, DataTableOverrides) == 0x000000, "Member 'FDIRuleDefinition::DataTableOverrides' has a wrong offset!");
static_assert(offsetof(FDIRuleDefinition, DataAssetOverrides) == 0x000050, "Member 'FDIRuleDefinition::DataAssetOverrides' has a wrong offset!");
static_assert(offsetof(FDIRuleDefinition, GenericObjectOverrides) == 0x0000A0, "Member 'FDIRuleDefinition::GenericObjectOverrides' has a wrong offset!");
static_assert(offsetof(FDIRuleDefinition, SpecialRules) == 0x0000F0, "Member 'FDIRuleDefinition::SpecialRules' has a wrong offset!");

// ScriptStruct DeceiveInc.BundleItemEntry
// 0x0038 (0x0038 - 0x0000)
struct FBundleItemEntry final
{
public:
	int32                                         ItemId;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDIItem>                 Item;                                              // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBundleItemEntry) == 0x000008, "Wrong alignment on FBundleItemEntry");
static_assert(sizeof(FBundleItemEntry) == 0x000038, "Wrong size on FBundleItemEntry");
static_assert(offsetof(FBundleItemEntry, ItemId) == 0x000000, "Member 'FBundleItemEntry::ItemId' has a wrong offset!");
static_assert(offsetof(FBundleItemEntry, Item) == 0x000008, "Member 'FBundleItemEntry::Item' has a wrong offset!");
static_assert(offsetof(FBundleItemEntry, Quantity) == 0x000030, "Member 'FBundleItemEntry::Quantity' has a wrong offset!");

// ScriptStruct DeceiveInc.DIItemSerializer
// 0x0120 (0x0120 - 0x0000)
struct FDIItemSerializer final
{
public:
	int32                                         ItemId;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemName;                                          // 0x0008(0x0018)(NativeAccessSpecifierPublic)
	class FString                                 LocID;                                             // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ItemImage;                                         // 0x0030(0x0018)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemRarity;                                        // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ItemAsset;                                         // 0x004C(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBundleItemEntry>               BundledItems;                                      // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bShowWhenNotOwned;                                 // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCannotBePurchased;                                // 0x0071(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShopExclusive;                                  // 0x0072(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlagAsNew;                                        // 0x0073(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlagAsPopular;                                    // 0x0074(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDIITemStoreCategoryOverride                  CategoryOverride;                                  // 0x0075(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_76[0x2];                                       // 0x0076(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            Costs;                                             // 0x0078(0x0050)(NativeAccessSpecifierPublic)
	TMap<int32, int32>                            BaseCosts;                                         // 0x00C8(0x0050)(NativeAccessSpecifierPublic)
	int32                                         RequiredCatalogID;                                 // 0x0118(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VoucherItemID;                                     // 0x011C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDIItemSerializer) == 0x000008, "Wrong alignment on FDIItemSerializer");
static_assert(sizeof(FDIItemSerializer) == 0x000120, "Wrong size on FDIItemSerializer");
static_assert(offsetof(FDIItemSerializer, ItemId) == 0x000000, "Member 'FDIItemSerializer::ItemId' has a wrong offset!");
static_assert(offsetof(FDIItemSerializer, ItemName) == 0x000008, "Member 'FDIItemSerializer::ItemName' has a wrong offset!");
static_assert(offsetof(FDIItemSerializer, LocID) == 0x000020, "Member 'FDIItemSerializer::LocID' has a wrong offset!");
static_assert(offsetof(FDIItemSerializer, ItemImage) == 0x000030, "Member 'FDIItemSerializer::ItemImage' has a wrong offset!");
static_assert(offsetof(FDIItemSerializer, ItemRarity) == 0x000048, "Member 'FDIItemSerializer::ItemRarity' has a wrong offset!");
static_assert(offsetof(FDIItemSerializer, ItemAsset) == 0x00004C, "Member 'FDIItemSerializer::ItemAsset' has a wrong offset!");
static_assert(offsetof(FDIItemSerializer, BundledItems) == 0x000060, "Member 'FDIItemSerializer::BundledItems' has a wrong offset!");
static_assert(offsetof(FDIItemSerializer, bShowWhenNotOwned) == 0x000070, "Member 'FDIItemSerializer::bShowWhenNotOwned' has a wrong offset!");
static_assert(offsetof(FDIItemSerializer, bCannotBePurchased) == 0x000071, "Member 'FDIItemSerializer::bCannotBePurchased' has a wrong offset!");
static_assert(offsetof(FDIItemSerializer, bIsShopExclusive) == 0x000072, "Member 'FDIItemSerializer::bIsShopExclusive' has a wrong offset!");
static_assert(offsetof(FDIItemSerializer, bFlagAsNew) == 0x000073, "Member 'FDIItemSerializer::bFlagAsNew' has a wrong offset!");
static_assert(offsetof(FDIItemSerializer, bFlagAsPopular) == 0x000074, "Member 'FDIItemSerializer::bFlagAsPopular' has a wrong offset!");
static_assert(offsetof(FDIItemSerializer, CategoryOverride) == 0x000075, "Member 'FDIItemSerializer::CategoryOverride' has a wrong offset!");
static_assert(offsetof(FDIItemSerializer, Costs) == 0x000078, "Member 'FDIItemSerializer::Costs' has a wrong offset!");
static_assert(offsetof(FDIItemSerializer, BaseCosts) == 0x0000C8, "Member 'FDIItemSerializer::BaseCosts' has a wrong offset!");
static_assert(offsetof(FDIItemSerializer, RequiredCatalogID) == 0x000118, "Member 'FDIItemSerializer::RequiredCatalogID' has a wrong offset!");
static_assert(offsetof(FDIItemSerializer, VoucherItemID) == 0x00011C, "Member 'FDIItemSerializer::VoucherItemID' has a wrong offset!");

// ScriptStruct DeceiveInc.WidgetRequestInfo
// 0x0018 (0x0018 - 0x0000)
struct FWidgetRequestInfo final
{
public:
	TWeakObjectPtr<class UActorComponent>         Requester;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  WidgetContainer;                                   // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  REquesterOwner;                                    // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWidgetRequestInfo) == 0x000004, "Wrong alignment on FWidgetRequestInfo");
static_assert(sizeof(FWidgetRequestInfo) == 0x000018, "Wrong size on FWidgetRequestInfo");
static_assert(offsetof(FWidgetRequestInfo, Requester) == 0x000000, "Member 'FWidgetRequestInfo::Requester' has a wrong offset!");
static_assert(offsetof(FWidgetRequestInfo, WidgetContainer) == 0x000008, "Member 'FWidgetRequestInfo::WidgetContainer' has a wrong offset!");
static_assert(offsetof(FWidgetRequestInfo, REquesterOwner) == 0x000010, "Member 'FWidgetRequestInfo::REquesterOwner' has a wrong offset!");

// ScriptStruct DeceiveInc.MatchesPlayerInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FMatchesPlayerInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchesPlayerInfo) == 0x000008, "Wrong alignment on FMatchesPlayerInfo");
static_assert(sizeof(FMatchesPlayerInfo) == 0x000018, "Wrong size on FMatchesPlayerInfo");

// ScriptStruct DeceiveInc.ObjectTypeInSpawnGroup
// 0x0004 (0x0004 - 0x0000)
struct FObjectTypeInSpawnGroup final
{
public:
	float                                         OccurenceFactor;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectTypeInSpawnGroup) == 0x000004, "Wrong alignment on FObjectTypeInSpawnGroup");
static_assert(sizeof(FObjectTypeInSpawnGroup) == 0x000004, "Wrong size on FObjectTypeInSpawnGroup");
static_assert(offsetof(FObjectTypeInSpawnGroup, OccurenceFactor) == 0x000000, "Member 'FObjectTypeInSpawnGroup::OccurenceFactor' has a wrong offset!");

// ScriptStruct DeceiveInc.ObjectSpawnGroupContainer
// 0x0050 (0x0050 - 0x0000)
struct FObjectSpawnGroupContainer final
{
public:
	TMap<uint32, struct FObjectTypeInSpawnGroup>  SpawnGroupObjectTypes;                             // 0x0000(0x0050)(Edit, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectSpawnGroupContainer) == 0x000008, "Wrong alignment on FObjectSpawnGroupContainer");
static_assert(sizeof(FObjectSpawnGroupContainer) == 0x000050, "Wrong size on FObjectSpawnGroupContainer");
static_assert(offsetof(FObjectSpawnGroupContainer, SpawnGroupObjectTypes) == 0x000000, "Member 'FObjectSpawnGroupContainer::SpawnGroupObjectTypes' has a wrong offset!");

// ScriptStruct DeceiveInc.DIPartyExtraDataBase
// 0x0018 (0x0018 - 0x0000)
struct FDIPartyExtraDataBase
{
public:
	int32                                         PartyExtraDataType;                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LocalRequestID;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Payload;                                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDIPartyExtraDataBase) == 0x000008, "Wrong alignment on FDIPartyExtraDataBase");
static_assert(sizeof(FDIPartyExtraDataBase) == 0x000018, "Wrong size on FDIPartyExtraDataBase");
static_assert(offsetof(FDIPartyExtraDataBase, PartyExtraDataType) == 0x000000, "Member 'FDIPartyExtraDataBase::PartyExtraDataType' has a wrong offset!");
static_assert(offsetof(FDIPartyExtraDataBase, LocalRequestID) == 0x000004, "Member 'FDIPartyExtraDataBase::LocalRequestID' has a wrong offset!");
static_assert(offsetof(FDIPartyExtraDataBase, Payload) == 0x000008, "Member 'FDIPartyExtraDataBase::Payload' has a wrong offset!");

// ScriptStruct DeceiveInc.DIPartyExtraDataContainer
// 0x0010 (0x0010 - 0x0000)
struct FDIPartyExtraDataContainer final
{
public:
	TArray<struct FDIPartyExtraDataBase>          ExtraDataItems;                                    // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDIPartyExtraDataContainer) == 0x000008, "Wrong alignment on FDIPartyExtraDataContainer");
static_assert(sizeof(FDIPartyExtraDataContainer) == 0x000010, "Wrong size on FDIPartyExtraDataContainer");
static_assert(offsetof(FDIPartyExtraDataContainer, ExtraDataItems) == 0x000000, "Member 'FDIPartyExtraDataContainer::ExtraDataItems' has a wrong offset!");

// ScriptStruct DeceiveInc.DIPartyExtraData_FactionChangeRequest
// 0x0000 (0x0018 - 0x0018)
struct FDIPartyExtraData_FactionChangeRequest final : public FDIPartyExtraDataBase
{
};
static_assert(alignof(FDIPartyExtraData_FactionChangeRequest) == 0x000008, "Wrong alignment on FDIPartyExtraData_FactionChangeRequest");
static_assert(sizeof(FDIPartyExtraData_FactionChangeRequest) == 0x000018, "Wrong size on FDIPartyExtraData_FactionChangeRequest");

// ScriptStruct DeceiveInc.EnhancedBindableAction
// 0x0030 (0x0030 - 0x0000)
struct FEnhancedBindableAction final
{
public:
	class FName                                   ActionDataAssetName;                               // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0008(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasInvertedModifier;                              // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scalar;                                            // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnhancedBindableAction) == 0x000008, "Wrong alignment on FEnhancedBindableAction");
static_assert(sizeof(FEnhancedBindableAction) == 0x000030, "Wrong size on FEnhancedBindableAction");
static_assert(offsetof(FEnhancedBindableAction, ActionDataAssetName) == 0x000000, "Member 'FEnhancedBindableAction::ActionDataAssetName' has a wrong offset!");
static_assert(offsetof(FEnhancedBindableAction, Key) == 0x000008, "Member 'FEnhancedBindableAction::Key' has a wrong offset!");
static_assert(offsetof(FEnhancedBindableAction, bHasInvertedModifier) == 0x000020, "Member 'FEnhancedBindableAction::bHasInvertedModifier' has a wrong offset!");
static_assert(offsetof(FEnhancedBindableAction, Scalar) == 0x000024, "Member 'FEnhancedBindableAction::Scalar' has a wrong offset!");

// ScriptStruct DeceiveInc.DISerializedPlayerKeybindings
// 0x0048 (0x0048 - 0x0000)
struct FDISerializedPlayerKeybindings final
{
public:
	TArray<struct FEnhancedBindableAction>        EnhancedBindableActions_Spy_Keyboard;              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEnhancedBindableAction>        EnhancedBindableActions_Spy_Gamepad;               // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEnhancedBindableAction>        EnhancedBindableActions_Controller_Keyboard;       // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEnhancedBindableAction>        EnhancedBindableActions_Controller_Gamepad;        // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        KeybindingsVersion;                                // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDISerializedPlayerKeybindings) == 0x000008, "Wrong alignment on FDISerializedPlayerKeybindings");
static_assert(sizeof(FDISerializedPlayerKeybindings) == 0x000048, "Wrong size on FDISerializedPlayerKeybindings");
static_assert(offsetof(FDISerializedPlayerKeybindings, EnhancedBindableActions_Spy_Keyboard) == 0x000000, "Member 'FDISerializedPlayerKeybindings::EnhancedBindableActions_Spy_Keyboard' has a wrong offset!");
static_assert(offsetof(FDISerializedPlayerKeybindings, EnhancedBindableActions_Spy_Gamepad) == 0x000010, "Member 'FDISerializedPlayerKeybindings::EnhancedBindableActions_Spy_Gamepad' has a wrong offset!");
static_assert(offsetof(FDISerializedPlayerKeybindings, EnhancedBindableActions_Controller_Keyboard) == 0x000020, "Member 'FDISerializedPlayerKeybindings::EnhancedBindableActions_Controller_Keyboard' has a wrong offset!");
static_assert(offsetof(FDISerializedPlayerKeybindings, EnhancedBindableActions_Controller_Gamepad) == 0x000030, "Member 'FDISerializedPlayerKeybindings::EnhancedBindableActions_Controller_Gamepad' has a wrong offset!");
static_assert(offsetof(FDISerializedPlayerKeybindings, KeybindingsVersion) == 0x000040, "Member 'FDISerializedPlayerKeybindings::KeybindingsVersion' has a wrong offset!");

// ScriptStruct DeceiveInc.SpawnNPCLevelData
// 0x0018 (0x0018 - 0x0000)
struct FSpawnNPCLevelData final
{
public:
	uint32                                        SpawnCount;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ANPCCharacter>>      NPCBPClasses;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnNPCLevelData) == 0x000008, "Wrong alignment on FSpawnNPCLevelData");
static_assert(sizeof(FSpawnNPCLevelData) == 0x000018, "Wrong size on FSpawnNPCLevelData");
static_assert(offsetof(FSpawnNPCLevelData, SpawnCount) == 0x000000, "Member 'FSpawnNPCLevelData::SpawnCount' has a wrong offset!");
static_assert(offsetof(FSpawnNPCLevelData, NPCBPClasses) == 0x000008, "Member 'FSpawnNPCLevelData::NPCBPClasses' has a wrong offset!");

// ScriptStruct DeceiveInc.BindableKeyEntry
// 0x0050 (0x0050 - 0x0000)
struct FBindableKeyEntry final
{
public:
	class FName                                   BindingName;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DisplayExtraInfo;                                  // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EKeybindContext                               Category;                                          // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAxis;                                           // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsKeyboardBindable;                               // 0x003A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGamepadBindable;                                // 0x003B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideInShippingBuilds;                             // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           InputAction;                                       // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBindableKeyEntry) == 0x000008, "Wrong alignment on FBindableKeyEntry");
static_assert(sizeof(FBindableKeyEntry) == 0x000050, "Wrong size on FBindableKeyEntry");
static_assert(offsetof(FBindableKeyEntry, BindingName) == 0x000000, "Member 'FBindableKeyEntry::BindingName' has a wrong offset!");
static_assert(offsetof(FBindableKeyEntry, DisplayName) == 0x000008, "Member 'FBindableKeyEntry::DisplayName' has a wrong offset!");
static_assert(offsetof(FBindableKeyEntry, DisplayExtraInfo) == 0x000020, "Member 'FBindableKeyEntry::DisplayExtraInfo' has a wrong offset!");
static_assert(offsetof(FBindableKeyEntry, Category) == 0x000038, "Member 'FBindableKeyEntry::Category' has a wrong offset!");
static_assert(offsetof(FBindableKeyEntry, bIsAxis) == 0x000039, "Member 'FBindableKeyEntry::bIsAxis' has a wrong offset!");
static_assert(offsetof(FBindableKeyEntry, bIsKeyboardBindable) == 0x00003A, "Member 'FBindableKeyEntry::bIsKeyboardBindable' has a wrong offset!");
static_assert(offsetof(FBindableKeyEntry, bIsGamepadBindable) == 0x00003B, "Member 'FBindableKeyEntry::bIsGamepadBindable' has a wrong offset!");
static_assert(offsetof(FBindableKeyEntry, bHideInShippingBuilds) == 0x00003C, "Member 'FBindableKeyEntry::bHideInShippingBuilds' has a wrong offset!");
static_assert(offsetof(FBindableKeyEntry, Scale) == 0x000040, "Member 'FBindableKeyEntry::Scale' has a wrong offset!");
static_assert(offsetof(FBindableKeyEntry, InputAction) == 0x000048, "Member 'FBindableKeyEntry::InputAction' has a wrong offset!");

// ScriptStruct DeceiveInc.DIPlayerStateCacheEntry
// 0x0048 (0x0048 - 0x0000)
struct FDIPlayerStateCacheEntry final
{
public:
	class AActor*                                 CacheOwner;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DataHolder;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDIPrimaryDataAsset*>            CachedDAS;                                         // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 DataHolderAcc;                                     // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDIPrimaryDataAsset*>            CachedDASAcc;                                      // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDIPlayerStateCacheEntry) == 0x000008, "Wrong alignment on FDIPlayerStateCacheEntry");
static_assert(sizeof(FDIPlayerStateCacheEntry) == 0x000048, "Wrong size on FDIPlayerStateCacheEntry");
static_assert(offsetof(FDIPlayerStateCacheEntry, CacheOwner) == 0x000000, "Member 'FDIPlayerStateCacheEntry::CacheOwner' has a wrong offset!");
static_assert(offsetof(FDIPlayerStateCacheEntry, DataHolder) == 0x000008, "Member 'FDIPlayerStateCacheEntry::DataHolder' has a wrong offset!");
static_assert(offsetof(FDIPlayerStateCacheEntry, CachedDAS) == 0x000010, "Member 'FDIPlayerStateCacheEntry::CachedDAS' has a wrong offset!");
static_assert(offsetof(FDIPlayerStateCacheEntry, DataHolderAcc) == 0x000030, "Member 'FDIPlayerStateCacheEntry::DataHolderAcc' has a wrong offset!");
static_assert(offsetof(FDIPlayerStateCacheEntry, CachedDASAcc) == 0x000038, "Member 'FDIPlayerStateCacheEntry::CachedDASAcc' has a wrong offset!");

// ScriptStruct DeceiveInc.AxisBindingSaveData
// 0x0020 (0x0020 - 0x0000)
struct FAxisBindingSaveData final
{
public:
	class FName                                   AxisName;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKey>                           Keys;                                              // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAxisBindingSaveData) == 0x000008, "Wrong alignment on FAxisBindingSaveData");
static_assert(sizeof(FAxisBindingSaveData) == 0x000020, "Wrong size on FAxisBindingSaveData");
static_assert(offsetof(FAxisBindingSaveData, AxisName) == 0x000000, "Member 'FAxisBindingSaveData::AxisName' has a wrong offset!");
static_assert(offsetof(FAxisBindingSaveData, Scale) == 0x000008, "Member 'FAxisBindingSaveData::Scale' has a wrong offset!");
static_assert(offsetof(FAxisBindingSaveData, Keys) == 0x000010, "Member 'FAxisBindingSaveData::Keys' has a wrong offset!");

// ScriptStruct DeceiveInc.ActionBindingSaveData
// 0x0018 (0x0018 - 0x0000)
struct FActionBindingSaveData final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKey>                           Keys;                                              // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActionBindingSaveData) == 0x000008, "Wrong alignment on FActionBindingSaveData");
static_assert(sizeof(FActionBindingSaveData) == 0x000018, "Wrong size on FActionBindingSaveData");
static_assert(offsetof(FActionBindingSaveData, ActionName) == 0x000000, "Member 'FActionBindingSaveData::ActionName' has a wrong offset!");
static_assert(offsetof(FActionBindingSaveData, Keys) == 0x000008, "Member 'FActionBindingSaveData::Keys' has a wrong offset!");

// ScriptStruct DeceiveInc.PopManCacheEntry
// 0x0050 (0x0050 - 0x0000)
struct FPopManCacheEntry final
{
public:
	TMap<TSubclassOf<class ANPCCharacter>, class ANPCCharacter*> PerClassCache;                                     // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPopManCacheEntry) == 0x000008, "Wrong alignment on FPopManCacheEntry");
static_assert(sizeof(FPopManCacheEntry) == 0x000050, "Wrong size on FPopManCacheEntry");
static_assert(offsetof(FPopManCacheEntry, PerClassCache) == 0x000000, "Member 'FPopManCacheEntry::PerClassCache' has a wrong offset!");

// ScriptStruct DeceiveInc.SettingsTextOptions
// 0x0010 (0x0010 - 0x0000)
struct FSettingsTextOptions final
{
public:
	TArray<class FText>                           Options;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSettingsTextOptions) == 0x000008, "Wrong alignment on FSettingsTextOptions");
static_assert(sizeof(FSettingsTextOptions) == 0x000010, "Wrong size on FSettingsTextOptions");
static_assert(offsetof(FSettingsTextOptions, Options) == 0x000000, "Member 'FSettingsTextOptions::Options' has a wrong offset!");

// ScriptStruct DeceiveInc.PlayerSettingDefinitionBase
// 0x0068 (0x0068 - 0x0000)
struct FPlayerSettingDefinitionBase
{
public:
	class FText                                   SettingShortDescription;                           // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   SettingLongDescription;                            // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   SettingTooltipDescription;                         // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   SettingDisabledReasonTooltip;                      // 0x0048(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bAlwaysShownInEditor;                              // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowedPerAgentSetting;                           // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowedOnPlatform_Windows;                        // 0x0062(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowedOnPlatform_Linux;                          // 0x0063(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowedOnPlatform_XSX;                            // 0x0064(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowedOnPlatform_PS5;                            // 0x0065(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugOnlySetting;                                 // 0x0066(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_67[0x1];                                       // 0x0067(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerSettingDefinitionBase) == 0x000008, "Wrong alignment on FPlayerSettingDefinitionBase");
static_assert(sizeof(FPlayerSettingDefinitionBase) == 0x000068, "Wrong size on FPlayerSettingDefinitionBase");
static_assert(offsetof(FPlayerSettingDefinitionBase, SettingShortDescription) == 0x000000, "Member 'FPlayerSettingDefinitionBase::SettingShortDescription' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinitionBase, SettingLongDescription) == 0x000018, "Member 'FPlayerSettingDefinitionBase::SettingLongDescription' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinitionBase, SettingTooltipDescription) == 0x000030, "Member 'FPlayerSettingDefinitionBase::SettingTooltipDescription' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinitionBase, SettingDisabledReasonTooltip) == 0x000048, "Member 'FPlayerSettingDefinitionBase::SettingDisabledReasonTooltip' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinitionBase, bAlwaysShownInEditor) == 0x000060, "Member 'FPlayerSettingDefinitionBase::bAlwaysShownInEditor' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinitionBase, bAllowedPerAgentSetting) == 0x000061, "Member 'FPlayerSettingDefinitionBase::bAllowedPerAgentSetting' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinitionBase, bAllowedOnPlatform_Windows) == 0x000062, "Member 'FPlayerSettingDefinitionBase::bAllowedOnPlatform_Windows' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinitionBase, bAllowedOnPlatform_Linux) == 0x000063, "Member 'FPlayerSettingDefinitionBase::bAllowedOnPlatform_Linux' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinitionBase, bAllowedOnPlatform_XSX) == 0x000064, "Member 'FPlayerSettingDefinitionBase::bAllowedOnPlatform_XSX' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinitionBase, bAllowedOnPlatform_PS5) == 0x000065, "Member 'FPlayerSettingDefinitionBase::bAllowedOnPlatform_PS5' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinitionBase, bDebugOnlySetting) == 0x000066, "Member 'FPlayerSettingDefinitionBase::bDebugOnlySetting' has a wrong offset!");

// ScriptStruct DeceiveInc.CommunityTrackers
// 0x0030 (0x0030 - 0x0000)
struct FCommunityTrackers final
{
public:
	int32                                         CollateralKO;                                      // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FirstAidExpenditure;                               // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmmoExpenditure;                                   // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntelGathered;                                     // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KeycardsAcquired;                                  // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Extractions;                                       // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DaysWithoutIncident;                               // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EmployeeOfTheMonth;                                // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCommunityTrackers) == 0x000008, "Wrong alignment on FCommunityTrackers");
static_assert(sizeof(FCommunityTrackers) == 0x000030, "Wrong size on FCommunityTrackers");
static_assert(offsetof(FCommunityTrackers, CollateralKO) == 0x000000, "Member 'FCommunityTrackers::CollateralKO' has a wrong offset!");
static_assert(offsetof(FCommunityTrackers, FirstAidExpenditure) == 0x000004, "Member 'FCommunityTrackers::FirstAidExpenditure' has a wrong offset!");
static_assert(offsetof(FCommunityTrackers, AmmoExpenditure) == 0x000008, "Member 'FCommunityTrackers::AmmoExpenditure' has a wrong offset!");
static_assert(offsetof(FCommunityTrackers, IntelGathered) == 0x00000C, "Member 'FCommunityTrackers::IntelGathered' has a wrong offset!");
static_assert(offsetof(FCommunityTrackers, KeycardsAcquired) == 0x000010, "Member 'FCommunityTrackers::KeycardsAcquired' has a wrong offset!");
static_assert(offsetof(FCommunityTrackers, Extractions) == 0x000014, "Member 'FCommunityTrackers::Extractions' has a wrong offset!");
static_assert(offsetof(FCommunityTrackers, DaysWithoutIncident) == 0x000018, "Member 'FCommunityTrackers::DaysWithoutIncident' has a wrong offset!");
static_assert(offsetof(FCommunityTrackers, EmployeeOfTheMonth) == 0x000020, "Member 'FCommunityTrackers::EmployeeOfTheMonth' has a wrong offset!");

// ScriptStruct DeceiveInc.MatchResults
// 0x0068 (0x0068 - 0x0000)
struct FMatchResults final
{
public:
	class FString                                 MatchId;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatchTimeSeconds;                                  // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPrivateGame;                                     // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GameMode;                                          // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPlayerResults>                 PlayerResults;                                     // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCommunityTrackers                     CommunityTrackers;                                 // 0x0038(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchResults) == 0x000008, "Wrong alignment on FMatchResults");
static_assert(sizeof(FMatchResults) == 0x000068, "Wrong size on FMatchResults");
static_assert(offsetof(FMatchResults, MatchId) == 0x000000, "Member 'FMatchResults::MatchId' has a wrong offset!");
static_assert(offsetof(FMatchResults, MatchTimeSeconds) == 0x000010, "Member 'FMatchResults::MatchTimeSeconds' has a wrong offset!");
static_assert(offsetof(FMatchResults, IsPrivateGame) == 0x000014, "Member 'FMatchResults::IsPrivateGame' has a wrong offset!");
static_assert(offsetof(FMatchResults, GameMode) == 0x000018, "Member 'FMatchResults::GameMode' has a wrong offset!");
static_assert(offsetof(FMatchResults, PlayerResults) == 0x000028, "Member 'FMatchResults::PlayerResults' has a wrong offset!");
static_assert(offsetof(FMatchResults, CommunityTrackers) == 0x000038, "Member 'FMatchResults::CommunityTrackers' has a wrong offset!");

// ScriptStruct DeceiveInc.PlayerSettingDefinition_String
// 0x0020 (0x0088 - 0x0068)
struct FPlayerSettingDefinition_String final : public FPlayerSettingDefinitionBase
{
public:
	class FText                                   DefaultValue;                                      // 0x0068(0x0018)(Edit, NativeAccessSpecifierPublic)
	int32                                         MinStringLength;                                   // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxStringLength;                                   // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerSettingDefinition_String) == 0x000008, "Wrong alignment on FPlayerSettingDefinition_String");
static_assert(sizeof(FPlayerSettingDefinition_String) == 0x000088, "Wrong size on FPlayerSettingDefinition_String");
static_assert(offsetof(FPlayerSettingDefinition_String, DefaultValue) == 0x000068, "Member 'FPlayerSettingDefinition_String::DefaultValue' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinition_String, MinStringLength) == 0x000080, "Member 'FPlayerSettingDefinition_String::MinStringLength' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinition_String, MaxStringLength) == 0x000084, "Member 'FPlayerSettingDefinition_String::MaxStringLength' has a wrong offset!");

// ScriptStruct DeceiveInc.PlayerSettingDefinition_Float
// 0x0018 (0x0080 - 0x0068)
struct FPlayerSettingDefinition_Float final : public FPlayerSettingDefinitionBase
{
public:
	float                                         DefaultValue_Windows;                              // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultValue_Linux;                                // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultValue_XSX;                                  // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultValue_PS5;                                  // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinValue;                                          // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerSettingDefinition_Float) == 0x000008, "Wrong alignment on FPlayerSettingDefinition_Float");
static_assert(sizeof(FPlayerSettingDefinition_Float) == 0x000080, "Wrong size on FPlayerSettingDefinition_Float");
static_assert(offsetof(FPlayerSettingDefinition_Float, DefaultValue_Windows) == 0x000068, "Member 'FPlayerSettingDefinition_Float::DefaultValue_Windows' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinition_Float, DefaultValue_Linux) == 0x00006C, "Member 'FPlayerSettingDefinition_Float::DefaultValue_Linux' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinition_Float, DefaultValue_XSX) == 0x000070, "Member 'FPlayerSettingDefinition_Float::DefaultValue_XSX' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinition_Float, DefaultValue_PS5) == 0x000074, "Member 'FPlayerSettingDefinition_Float::DefaultValue_PS5' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinition_Float, MinValue) == 0x000078, "Member 'FPlayerSettingDefinition_Float::MinValue' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinition_Float, MaxValue) == 0x00007C, "Member 'FPlayerSettingDefinition_Float::MaxValue' has a wrong offset!");

// ScriptStruct DeceiveInc.ReductionPowerupSettings
// 0x0050 (0x0050 - 0x0000)
struct FReductionPowerupSettings final
{
public:
	TMap<ESecurityLevel, float>                   ReductionValuePerLevel;                            // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReductionPowerupSettings) == 0x000008, "Wrong alignment on FReductionPowerupSettings");
static_assert(sizeof(FReductionPowerupSettings) == 0x000050, "Wrong size on FReductionPowerupSettings");
static_assert(offsetof(FReductionPowerupSettings, ReductionValuePerLevel) == 0x000000, "Member 'FReductionPowerupSettings::ReductionValuePerLevel' has a wrong offset!");

// ScriptStruct DeceiveInc.PlayerSettingDefinition_Integer
// 0x0018 (0x0080 - 0x0068)
struct FPlayerSettingDefinition_Integer final : public FPlayerSettingDefinitionBase
{
public:
	int32                                         DefaultValue_Windows;                              // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultValue_Linux;                                // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultValue_XSX;                                  // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultValue_PS5;                                  // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinValue;                                          // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxValue;                                          // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerSettingDefinition_Integer) == 0x000008, "Wrong alignment on FPlayerSettingDefinition_Integer");
static_assert(sizeof(FPlayerSettingDefinition_Integer) == 0x000080, "Wrong size on FPlayerSettingDefinition_Integer");
static_assert(offsetof(FPlayerSettingDefinition_Integer, DefaultValue_Windows) == 0x000068, "Member 'FPlayerSettingDefinition_Integer::DefaultValue_Windows' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinition_Integer, DefaultValue_Linux) == 0x00006C, "Member 'FPlayerSettingDefinition_Integer::DefaultValue_Linux' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinition_Integer, DefaultValue_XSX) == 0x000070, "Member 'FPlayerSettingDefinition_Integer::DefaultValue_XSX' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinition_Integer, DefaultValue_PS5) == 0x000074, "Member 'FPlayerSettingDefinition_Integer::DefaultValue_PS5' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinition_Integer, MinValue) == 0x000078, "Member 'FPlayerSettingDefinition_Integer::MinValue' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinition_Integer, MaxValue) == 0x00007C, "Member 'FPlayerSettingDefinition_Integer::MaxValue' has a wrong offset!");

// ScriptStruct DeceiveInc.PlayerSettingDefinition_Boolean
// 0x0008 (0x0070 - 0x0068)
struct FPlayerSettingDefinition_Boolean final : public FPlayerSettingDefinitionBase
{
public:
	bool                                          DefaultValue_Windows;                              // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DefaultValue_Linux;                                // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DefaultValue_XSX;                                  // 0x006A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DefaultValue_PS5;                                  // 0x006B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerSettingDefinition_Boolean) == 0x000008, "Wrong alignment on FPlayerSettingDefinition_Boolean");
static_assert(sizeof(FPlayerSettingDefinition_Boolean) == 0x000070, "Wrong size on FPlayerSettingDefinition_Boolean");
static_assert(offsetof(FPlayerSettingDefinition_Boolean, DefaultValue_Windows) == 0x000068, "Member 'FPlayerSettingDefinition_Boolean::DefaultValue_Windows' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinition_Boolean, DefaultValue_Linux) == 0x000069, "Member 'FPlayerSettingDefinition_Boolean::DefaultValue_Linux' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinition_Boolean, DefaultValue_XSX) == 0x00006A, "Member 'FPlayerSettingDefinition_Boolean::DefaultValue_XSX' has a wrong offset!");
static_assert(offsetof(FPlayerSettingDefinition_Boolean, DefaultValue_PS5) == 0x00006B, "Member 'FPlayerSettingDefinition_Boolean::DefaultValue_PS5' has a wrong offset!");

// ScriptStruct DeceiveInc.EOSLoginRequestBody
// 0x0010 (0x0010 - 0x0000)
struct FEOSLoginRequestBody final
{
public:
	class FString                                 AccessToken;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEOSLoginRequestBody) == 0x000008, "Wrong alignment on FEOSLoginRequestBody");
static_assert(sizeof(FEOSLoginRequestBody) == 0x000010, "Wrong size on FEOSLoginRequestBody");
static_assert(offsetof(FEOSLoginRequestBody, AccessToken) == 0x000000, "Member 'FEOSLoginRequestBody::AccessToken' has a wrong offset!");

// ScriptStruct DeceiveInc.PlayerXpTypeEventInfo
// 0x0030 (0x0030 - 0x0000)
struct FPlayerXpTypeEventInfo final
{
public:
	class FString                                 XpType;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPlayerXpEventInfo>             XpEventInfo;                                       // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerXpEventInfo>             XpMultiplicatorInfo;                               // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerXpTypeEventInfo) == 0x000008, "Wrong alignment on FPlayerXpTypeEventInfo");
static_assert(sizeof(FPlayerXpTypeEventInfo) == 0x000030, "Wrong size on FPlayerXpTypeEventInfo");
static_assert(offsetof(FPlayerXpTypeEventInfo, XpType) == 0x000000, "Member 'FPlayerXpTypeEventInfo::XpType' has a wrong offset!");
static_assert(offsetof(FPlayerXpTypeEventInfo, XpEventInfo) == 0x000010, "Member 'FPlayerXpTypeEventInfo::XpEventInfo' has a wrong offset!");
static_assert(offsetof(FPlayerXpTypeEventInfo, XpMultiplicatorInfo) == 0x000020, "Member 'FPlayerXpTypeEventInfo::XpMultiplicatorInfo' has a wrong offset!");

// ScriptStruct DeceiveInc.PlayerXpTypeDefinition
// 0x0018 (0x0018 - 0x0000)
struct FPlayerXpTypeDefinition final
{
public:
	class FString                                 XpType;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XP;                                                // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerXpTypeDefinition) == 0x000008, "Wrong alignment on FPlayerXpTypeDefinition");
static_assert(sizeof(FPlayerXpTypeDefinition) == 0x000018, "Wrong size on FPlayerXpTypeDefinition");
static_assert(offsetof(FPlayerXpTypeDefinition, XpType) == 0x000000, "Member 'FPlayerXpTypeDefinition::XpType' has a wrong offset!");
static_assert(offsetof(FPlayerXpTypeDefinition, Level) == 0x000010, "Member 'FPlayerXpTypeDefinition::Level' has a wrong offset!");
static_assert(offsetof(FPlayerXpTypeDefinition, XP) == 0x000014, "Member 'FPlayerXpTypeDefinition::XP' has a wrong offset!");

// ScriptStruct DeceiveInc.PlayerProgression
// 0x0020 (0x0020 - 0x0000)
struct FPlayerProgression final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XP;                                                // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CombatElo;                                         // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerXpTypeDefinition>        PlayerXpTypes;                                     // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerProgression) == 0x000008, "Wrong alignment on FPlayerProgression");
static_assert(sizeof(FPlayerProgression) == 0x000020, "Wrong size on FPlayerProgression");
static_assert(offsetof(FPlayerProgression, Level) == 0x000000, "Member 'FPlayerProgression::Level' has a wrong offset!");
static_assert(offsetof(FPlayerProgression, XP) == 0x000004, "Member 'FPlayerProgression::XP' has a wrong offset!");
static_assert(offsetof(FPlayerProgression, CombatElo) == 0x000008, "Member 'FPlayerProgression::CombatElo' has a wrong offset!");
static_assert(offsetof(FPlayerProgression, PlayerXpTypes) == 0x000010, "Member 'FPlayerProgression::PlayerXpTypes' has a wrong offset!");

// ScriptStruct DeceiveInc.IntroPhaseData
// 0x0008 (0x0058 - 0x0050)
struct FIntroPhaseData final : public FSpyGamePhaseData
{
public:
	int32                                         DefaultPhaseDuration;                              // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIntroPhaseData) == 0x000008, "Wrong alignment on FIntroPhaseData");
static_assert(sizeof(FIntroPhaseData) == 0x000058, "Wrong size on FIntroPhaseData");
static_assert(offsetof(FIntroPhaseData, DefaultPhaseDuration) == 0x000050, "Member 'FIntroPhaseData::DefaultPhaseDuration' has a wrong offset!");

// ScriptStruct DeceiveInc.DISerializedLocalSaveData
// 0x0028 (0x0028 - 0x0000)
struct FDISerializedLocalSaveData final
{
public:
	bool                                          bTutorialCompleted;                                // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTutorialSkipped;                                  // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDiguisedAsAngelfish;                              // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDiguisedAsJati;                                   // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDiguisedAsLuana;                                  // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDiguisedAsSebastianGarcia;                        // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDiguisedAsStarling;                               // 0x0006(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FSocialInteractionsTime;                           // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FCallingCardsThrown;                               // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FGamesWon;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PS5MatchId;                                        // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDISerializedLocalSaveData) == 0x000008, "Wrong alignment on FDISerializedLocalSaveData");
static_assert(sizeof(FDISerializedLocalSaveData) == 0x000028, "Wrong size on FDISerializedLocalSaveData");
static_assert(offsetof(FDISerializedLocalSaveData, bTutorialCompleted) == 0x000000, "Member 'FDISerializedLocalSaveData::bTutorialCompleted' has a wrong offset!");
static_assert(offsetof(FDISerializedLocalSaveData, bTutorialSkipped) == 0x000001, "Member 'FDISerializedLocalSaveData::bTutorialSkipped' has a wrong offset!");
static_assert(offsetof(FDISerializedLocalSaveData, bDiguisedAsAngelfish) == 0x000002, "Member 'FDISerializedLocalSaveData::bDiguisedAsAngelfish' has a wrong offset!");
static_assert(offsetof(FDISerializedLocalSaveData, bDiguisedAsJati) == 0x000003, "Member 'FDISerializedLocalSaveData::bDiguisedAsJati' has a wrong offset!");
static_assert(offsetof(FDISerializedLocalSaveData, bDiguisedAsLuana) == 0x000004, "Member 'FDISerializedLocalSaveData::bDiguisedAsLuana' has a wrong offset!");
static_assert(offsetof(FDISerializedLocalSaveData, bDiguisedAsSebastianGarcia) == 0x000005, "Member 'FDISerializedLocalSaveData::bDiguisedAsSebastianGarcia' has a wrong offset!");
static_assert(offsetof(FDISerializedLocalSaveData, bDiguisedAsStarling) == 0x000006, "Member 'FDISerializedLocalSaveData::bDiguisedAsStarling' has a wrong offset!");
static_assert(offsetof(FDISerializedLocalSaveData, FSocialInteractionsTime) == 0x000008, "Member 'FDISerializedLocalSaveData::FSocialInteractionsTime' has a wrong offset!");
static_assert(offsetof(FDISerializedLocalSaveData, FCallingCardsThrown) == 0x00000C, "Member 'FDISerializedLocalSaveData::FCallingCardsThrown' has a wrong offset!");
static_assert(offsetof(FDISerializedLocalSaveData, FGamesWon) == 0x000010, "Member 'FDISerializedLocalSaveData::FGamesWon' has a wrong offset!");
static_assert(offsetof(FDISerializedLocalSaveData, PS5MatchId) == 0x000018, "Member 'FDISerializedLocalSaveData::PS5MatchId' has a wrong offset!");

// ScriptStruct DeceiveInc.MinMaxChances
// 0x0008 (0x0008 - 0x0000)
struct FMinMaxChances final
{
public:
	float                                         MinChances;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxChances;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinMaxChances) == 0x000004, "Wrong alignment on FMinMaxChances");
static_assert(sizeof(FMinMaxChances) == 0x000008, "Wrong size on FMinMaxChances");
static_assert(offsetof(FMinMaxChances, MinChances) == 0x000000, "Member 'FMinMaxChances::MinChances' has a wrong offset!");
static_assert(offsetof(FMinMaxChances, MaxChances) == 0x000004, "Member 'FMinMaxChances::MaxChances' has a wrong offset!");

// ScriptStruct DeceiveInc.DISerializedCallingCardSelection
// 0x0050 (0x0050 - 0x0000)
struct FDISerializedCallingCardSelection final
{
public:
	struct FPrimaryAssetId                        NorthCallingCardId;                                // 0x0000(0x0010)(ZeroConstructor, Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        EastCallingCardId;                                 // 0x0010(0x0010)(ZeroConstructor, Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SouthCallingCardId;                                // 0x0020(0x0010)(ZeroConstructor, Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        WestCallingCardId;                                 // 0x0030(0x0010)(ZeroConstructor, Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                SelectedCallingCards;                              // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDISerializedCallingCardSelection) == 0x000008, "Wrong alignment on FDISerializedCallingCardSelection");
static_assert(sizeof(FDISerializedCallingCardSelection) == 0x000050, "Wrong size on FDISerializedCallingCardSelection");
static_assert(offsetof(FDISerializedCallingCardSelection, NorthCallingCardId) == 0x000000, "Member 'FDISerializedCallingCardSelection::NorthCallingCardId' has a wrong offset!");
static_assert(offsetof(FDISerializedCallingCardSelection, EastCallingCardId) == 0x000010, "Member 'FDISerializedCallingCardSelection::EastCallingCardId' has a wrong offset!");
static_assert(offsetof(FDISerializedCallingCardSelection, SouthCallingCardId) == 0x000020, "Member 'FDISerializedCallingCardSelection::SouthCallingCardId' has a wrong offset!");
static_assert(offsetof(FDISerializedCallingCardSelection, WestCallingCardId) == 0x000030, "Member 'FDISerializedCallingCardSelection::WestCallingCardId' has a wrong offset!");
static_assert(offsetof(FDISerializedCallingCardSelection, SelectedCallingCards) == 0x000040, "Member 'FDISerializedCallingCardSelection::SelectedCallingCards' has a wrong offset!");

// ScriptStruct DeceiveInc.DISerializedAccessories
// 0x0098 (0x0098 - 0x0000)
struct FDISerializedAccessories final
{
public:
	int64                                         UpdatedOn;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SelectedTitleId;                                   // 0x0008(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SelectedBreadcrumbId;                              // 0x0018(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDISerializedCallingCardSelection      CallingCardSelectionInfo;                          // 0x0028(0x0050)(NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        AvatarId;                                          // 0x0078(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        IntroPoseId;                                       // 0x0088(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDISerializedAccessories) == 0x000008, "Wrong alignment on FDISerializedAccessories");
static_assert(sizeof(FDISerializedAccessories) == 0x000098, "Wrong size on FDISerializedAccessories");
static_assert(offsetof(FDISerializedAccessories, UpdatedOn) == 0x000000, "Member 'FDISerializedAccessories::UpdatedOn' has a wrong offset!");
static_assert(offsetof(FDISerializedAccessories, SelectedTitleId) == 0x000008, "Member 'FDISerializedAccessories::SelectedTitleId' has a wrong offset!");
static_assert(offsetof(FDISerializedAccessories, SelectedBreadcrumbId) == 0x000018, "Member 'FDISerializedAccessories::SelectedBreadcrumbId' has a wrong offset!");
static_assert(offsetof(FDISerializedAccessories, CallingCardSelectionInfo) == 0x000028, "Member 'FDISerializedAccessories::CallingCardSelectionInfo' has a wrong offset!");
static_assert(offsetof(FDISerializedAccessories, AvatarId) == 0x000078, "Member 'FDISerializedAccessories::AvatarId' has a wrong offset!");
static_assert(offsetof(FDISerializedAccessories, IntroPoseId) == 0x000088, "Member 'FDISerializedAccessories::IntroPoseId' has a wrong offset!");

// ScriptStruct DeceiveInc.HitProcessingData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FHitProcessingData
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitProcessingData) == 0x000008, "Wrong alignment on FHitProcessingData");
static_assert(sizeof(FHitProcessingData) == 0x000008, "Wrong size on FHitProcessingData");

// ScriptStruct DeceiveInc.DISerializedAgentSelection
// 0x0068 (0x0068 - 0x0000)
struct FDISerializedAgentSelection final
{
public:
	int64                                         UpdatedOn;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SelectedAgentId;                                   // 0x0008(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDISerializedAgentSelectionInfo> AgentSelectionInfos;                               // 0x0018(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FDISerializedAgentSelection) == 0x000008, "Wrong alignment on FDISerializedAgentSelection");
static_assert(sizeof(FDISerializedAgentSelection) == 0x000068, "Wrong size on FDISerializedAgentSelection");
static_assert(offsetof(FDISerializedAgentSelection, UpdatedOn) == 0x000000, "Member 'FDISerializedAgentSelection::UpdatedOn' has a wrong offset!");
static_assert(offsetof(FDISerializedAgentSelection, SelectedAgentId) == 0x000008, "Member 'FDISerializedAgentSelection::SelectedAgentId' has a wrong offset!");
static_assert(offsetof(FDISerializedAgentSelection, AgentSelectionInfos) == 0x000018, "Member 'FDISerializedAgentSelection::AgentSelectionInfos' has a wrong offset!");

// ScriptStruct DeceiveInc.DISerializedDecks
// 0x0028 (0x0028 - 0x0000)
struct FDISerializedDecks final
{
public:
	TArray<struct FDISerializedDeckEntry>         Decks;                                             // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         DecksNames;                                        // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         EquippedDeck;                                      // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDISerializedDecks) == 0x000008, "Wrong alignment on FDISerializedDecks");
static_assert(sizeof(FDISerializedDecks) == 0x000028, "Wrong size on FDISerializedDecks");
static_assert(offsetof(FDISerializedDecks, Decks) == 0x000000, "Member 'FDISerializedDecks::Decks' has a wrong offset!");
static_assert(offsetof(FDISerializedDecks, DecksNames) == 0x000010, "Member 'FDISerializedDecks::DecksNames' has a wrong offset!");
static_assert(offsetof(FDISerializedDecks, EquippedDeck) == 0x000020, "Member 'FDISerializedDecks::EquippedDeck' has a wrong offset!");

// ScriptStruct DeceiveInc.DISerializedInventoryItem
// 0x0030 (0x0030 - 0x0000)
struct FDISerializedInventoryItem final
{
public:
	int64                                         UpdatedOn;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ConsumedOn;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         RemainingTime;                                     // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemId;                                            // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Seen;                                              // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDISerializedInventoryItem) == 0x000008, "Wrong alignment on FDISerializedInventoryItem");
static_assert(sizeof(FDISerializedInventoryItem) == 0x000030, "Wrong size on FDISerializedInventoryItem");
static_assert(offsetof(FDISerializedInventoryItem, UpdatedOn) == 0x000000, "Member 'FDISerializedInventoryItem::UpdatedOn' has a wrong offset!");
static_assert(offsetof(FDISerializedInventoryItem, ConsumedOn) == 0x000008, "Member 'FDISerializedInventoryItem::ConsumedOn' has a wrong offset!");
static_assert(offsetof(FDISerializedInventoryItem, RemainingTime) == 0x000010, "Member 'FDISerializedInventoryItem::RemainingTime' has a wrong offset!");
static_assert(offsetof(FDISerializedInventoryItem, ItemId) == 0x000018, "Member 'FDISerializedInventoryItem::ItemId' has a wrong offset!");
static_assert(offsetof(FDISerializedInventoryItem, Quantity) == 0x000028, "Member 'FDISerializedInventoryItem::Quantity' has a wrong offset!");
static_assert(offsetof(FDISerializedInventoryItem, Seen) == 0x00002C, "Member 'FDISerializedInventoryItem::Seen' has a wrong offset!");

// ScriptStruct DeceiveInc.DISerializedInventory
// 0x0050 (0x0050 - 0x0000)
struct FDISerializedInventory final
{
public:
	TMap<class FString, struct FDISerializedInventoryItem> InventoryItems;                                    // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FDISerializedInventory) == 0x000008, "Wrong alignment on FDISerializedInventory");
static_assert(sizeof(FDISerializedInventory) == 0x000050, "Wrong size on FDISerializedInventory");
static_assert(offsetof(FDISerializedInventory, InventoryItems) == 0x000000, "Member 'FDISerializedInventory::InventoryItems' has a wrong offset!");

// ScriptStruct DeceiveInc.LootDefinition
// 0x0010 (0x0010 - 0x0000)
struct FLootDefinition final
{
public:
	class FString                                 BundleId;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLootDefinition) == 0x000008, "Wrong alignment on FLootDefinition");
static_assert(sizeof(FLootDefinition) == 0x000010, "Wrong size on FLootDefinition");
static_assert(offsetof(FLootDefinition, BundleId) == 0x000000, "Member 'FLootDefinition::BundleId' has a wrong offset!");

// ScriptStruct DeceiveInc.DISerializedLoot
// 0x0010 (0x0010 - 0x0000)
struct FDISerializedLoot final
{
public:
	TArray<struct FLootDefinition>                LootBundles;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDISerializedLoot) == 0x000008, "Wrong alignment on FDISerializedLoot");
static_assert(sizeof(FDISerializedLoot) == 0x000010, "Wrong size on FDISerializedLoot");
static_assert(offsetof(FDISerializedLoot, LootBundles) == 0x000000, "Member 'FDISerializedLoot::LootBundles' has a wrong offset!");

// ScriptStruct DeceiveInc.DISerializedProgression
// 0x0020 (0x0020 - 0x0000)
struct FDISerializedProgression final
{
public:
	int32                                         XP;                                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CombatElo;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerXpTypeDefinition>        PlayerXpTypes;                                     // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDISerializedProgression) == 0x000008, "Wrong alignment on FDISerializedProgression");
static_assert(sizeof(FDISerializedProgression) == 0x000020, "Wrong size on FDISerializedProgression");
static_assert(offsetof(FDISerializedProgression, XP) == 0x000000, "Member 'FDISerializedProgression::XP' has a wrong offset!");
static_assert(offsetof(FDISerializedProgression, Level) == 0x000004, "Member 'FDISerializedProgression::Level' has a wrong offset!");
static_assert(offsetof(FDISerializedProgression, CombatElo) == 0x000008, "Member 'FDISerializedProgression::CombatElo' has a wrong offset!");
static_assert(offsetof(FDISerializedProgression, PlayerXpTypes) == 0x000010, "Member 'FDISerializedProgression::PlayerXpTypes' has a wrong offset!");

// ScriptStruct DeceiveInc.AgentPlayTimeDefinition
// 0x0018 (0x0018 - 0x0000)
struct FAgentPlayTimeDefinition final
{
public:
	class FString                                 AgentId;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimePlayed;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAgentPlayTimeDefinition) == 0x000008, "Wrong alignment on FAgentPlayTimeDefinition");
static_assert(sizeof(FAgentPlayTimeDefinition) == 0x000018, "Wrong size on FAgentPlayTimeDefinition");
static_assert(offsetof(FAgentPlayTimeDefinition, AgentId) == 0x000000, "Member 'FAgentPlayTimeDefinition::AgentId' has a wrong offset!");
static_assert(offsetof(FAgentPlayTimeDefinition, TimePlayed) == 0x000010, "Member 'FAgentPlayTimeDefinition::TimePlayed' has a wrong offset!");

// ScriptStruct DeceiveInc.DISerializedStats
// 0x0048 (0x0048 - 0x0000)
struct FDISerializedStats final
{
public:
	int32                                         MatchesPlayedSolo;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatchesWonSolo;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimePlayedSolo;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EliminationsSolo;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DeathsSolo;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatchesPlayedTeam;                                 // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatchesWonTeam;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimePlayedTeam;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EliminationsTeam;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DeathsTeam;                                        // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatchesWonDuo;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatchesPlayedDuo;                                  // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimePlayedDuo;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAgentPlayTimeDefinition>       AgentPlayTime;                                     // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDISerializedStats) == 0x000008, "Wrong alignment on FDISerializedStats");
static_assert(sizeof(FDISerializedStats) == 0x000048, "Wrong size on FDISerializedStats");
static_assert(offsetof(FDISerializedStats, MatchesPlayedSolo) == 0x000000, "Member 'FDISerializedStats::MatchesPlayedSolo' has a wrong offset!");
static_assert(offsetof(FDISerializedStats, MatchesWonSolo) == 0x000004, "Member 'FDISerializedStats::MatchesWonSolo' has a wrong offset!");
static_assert(offsetof(FDISerializedStats, TimePlayedSolo) == 0x000008, "Member 'FDISerializedStats::TimePlayedSolo' has a wrong offset!");
static_assert(offsetof(FDISerializedStats, EliminationsSolo) == 0x00000C, "Member 'FDISerializedStats::EliminationsSolo' has a wrong offset!");
static_assert(offsetof(FDISerializedStats, DeathsSolo) == 0x000010, "Member 'FDISerializedStats::DeathsSolo' has a wrong offset!");
static_assert(offsetof(FDISerializedStats, MatchesPlayedTeam) == 0x000014, "Member 'FDISerializedStats::MatchesPlayedTeam' has a wrong offset!");
static_assert(offsetof(FDISerializedStats, MatchesWonTeam) == 0x000018, "Member 'FDISerializedStats::MatchesWonTeam' has a wrong offset!");
static_assert(offsetof(FDISerializedStats, TimePlayedTeam) == 0x00001C, "Member 'FDISerializedStats::TimePlayedTeam' has a wrong offset!");
static_assert(offsetof(FDISerializedStats, EliminationsTeam) == 0x000020, "Member 'FDISerializedStats::EliminationsTeam' has a wrong offset!");
static_assert(offsetof(FDISerializedStats, DeathsTeam) == 0x000024, "Member 'FDISerializedStats::DeathsTeam' has a wrong offset!");
static_assert(offsetof(FDISerializedStats, MatchesWonDuo) == 0x000028, "Member 'FDISerializedStats::MatchesWonDuo' has a wrong offset!");
static_assert(offsetof(FDISerializedStats, MatchesPlayedDuo) == 0x00002C, "Member 'FDISerializedStats::MatchesPlayedDuo' has a wrong offset!");
static_assert(offsetof(FDISerializedStats, TimePlayedDuo) == 0x000030, "Member 'FDISerializedStats::TimePlayedDuo' has a wrong offset!");
static_assert(offsetof(FDISerializedStats, AgentPlayTime) == 0x000038, "Member 'FDISerializedStats::AgentPlayTime' has a wrong offset!");

// ScriptStruct DeceiveInc.ClassPlayTimeDefinition
// 0x0018 (0x0018 - 0x0000)
struct FClassPlayTimeDefinition final
{
public:
	class FString                                 ClassName;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimePlayed;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClassPlayTimeDefinition) == 0x000008, "Wrong alignment on FClassPlayTimeDefinition");
static_assert(sizeof(FClassPlayTimeDefinition) == 0x000018, "Wrong size on FClassPlayTimeDefinition");
static_assert(offsetof(FClassPlayTimeDefinition, ClassName) == 0x000000, "Member 'FClassPlayTimeDefinition::ClassName' has a wrong offset!");
static_assert(offsetof(FClassPlayTimeDefinition, TimePlayed) == 0x000010, "Member 'FClassPlayTimeDefinition::TimePlayed' has a wrong offset!");

// ScriptStruct DeceiveInc.ItemUnlockLevelInfo
// 0x0018 (0x0018 - 0x0000)
struct FItemUnlockLevelInfo final
{
public:
	int32                                         UnlockLvl;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 XpType;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemUnlockLevelInfo) == 0x000008, "Wrong alignment on FItemUnlockLevelInfo");
static_assert(sizeof(FItemUnlockLevelInfo) == 0x000018, "Wrong size on FItemUnlockLevelInfo");
static_assert(offsetof(FItemUnlockLevelInfo, UnlockLvl) == 0x000000, "Member 'FItemUnlockLevelInfo::UnlockLvl' has a wrong offset!");
static_assert(offsetof(FItemUnlockLevelInfo, XpType) == 0x000008, "Member 'FItemUnlockLevelInfo::XpType' has a wrong offset!");

// ScriptStruct DeceiveInc.ItemUnlockLevelArray
// 0x0010 (0x0010 - 0x0000)
struct FItemUnlockLevelArray final
{
public:
	TArray<struct FItemUnlockLevelInfo>           ItemUnlockLevelInfo;                               // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemUnlockLevelArray) == 0x000008, "Wrong alignment on FItemUnlockLevelArray");
static_assert(sizeof(FItemUnlockLevelArray) == 0x000010, "Wrong size on FItemUnlockLevelArray");
static_assert(offsetof(FItemUnlockLevelArray, ItemUnlockLevelInfo) == 0x000000, "Member 'FItemUnlockLevelArray::ItemUnlockLevelInfo' has a wrong offset!");

// ScriptStruct DeceiveInc.CustomSpy3PMovementSet
// 0x0010 (0x0010 - 0x0000)
struct FCustomSpy3PMovementSet final
{
public:
	class FName                                   NameID;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDiSpy3PMovementSet*                    CustomMovementSet;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomSpy3PMovementSet) == 0x000008, "Wrong alignment on FCustomSpy3PMovementSet");
static_assert(sizeof(FCustomSpy3PMovementSet) == 0x000010, "Wrong size on FCustomSpy3PMovementSet");
static_assert(offsetof(FCustomSpy3PMovementSet, NameID) == 0x000000, "Member 'FCustomSpy3PMovementSet::NameID' has a wrong offset!");
static_assert(offsetof(FCustomSpy3PMovementSet, CustomMovementSet) == 0x000008, "Member 'FCustomSpy3PMovementSet::CustomMovementSet' has a wrong offset!");

// ScriptStruct DeceiveInc.ScheduleSlotEntryData
// 0x0018 (0x0018 - 0x0000)
struct FScheduleSlotEntryData final
{
public:
	struct FTimespan                              RotationDuration;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDIItem*                                ItemOnDisplay;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemId;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScheduleSlotEntryData) == 0x000008, "Wrong alignment on FScheduleSlotEntryData");
static_assert(sizeof(FScheduleSlotEntryData) == 0x000018, "Wrong size on FScheduleSlotEntryData");
static_assert(offsetof(FScheduleSlotEntryData, RotationDuration) == 0x000000, "Member 'FScheduleSlotEntryData::RotationDuration' has a wrong offset!");
static_assert(offsetof(FScheduleSlotEntryData, ItemOnDisplay) == 0x000008, "Member 'FScheduleSlotEntryData::ItemOnDisplay' has a wrong offset!");
static_assert(offsetof(FScheduleSlotEntryData, ItemId) == 0x000010, "Member 'FScheduleSlotEntryData::ItemId' has a wrong offset!");

// ScriptStruct DeceiveInc.ScheduleSlotData
// 0x0010 (0x0010 - 0x0000)
struct FScheduleSlotData final
{
public:
	TArray<struct FScheduleSlotEntryData>         SlotScheduleEntries;                               // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScheduleSlotData) == 0x000008, "Wrong alignment on FScheduleSlotData");
static_assert(sizeof(FScheduleSlotData) == 0x000010, "Wrong size on FScheduleSlotData");
static_assert(offsetof(FScheduleSlotData, SlotScheduleEntries) == 0x000000, "Member 'FScheduleSlotData::SlotScheduleEntries' has a wrong offset!");

// ScriptStruct DeceiveInc.ScheduleSaleEntry
// 0x0018 (0x0018 - 0x0000)
struct FScheduleSaleEntry final
{
public:
	int32                                         SalePrice;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDIItem*                                ItemOnSale;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemId;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScheduleSaleEntry) == 0x000008, "Wrong alignment on FScheduleSaleEntry");
static_assert(sizeof(FScheduleSaleEntry) == 0x000018, "Wrong size on FScheduleSaleEntry");
static_assert(offsetof(FScheduleSaleEntry, SalePrice) == 0x000000, "Member 'FScheduleSaleEntry::SalePrice' has a wrong offset!");
static_assert(offsetof(FScheduleSaleEntry, ItemOnSale) == 0x000008, "Member 'FScheduleSaleEntry::ItemOnSale' has a wrong offset!");
static_assert(offsetof(FScheduleSaleEntry, ItemId) == 0x000010, "Member 'FScheduleSaleEntry::ItemId' has a wrong offset!");

// ScriptStruct DeceiveInc.ScheduleSerializer
// 0x0070 (0x0070 - 0x0000)
struct FScheduleSerializer final
{
public:
	struct FDateTime                              StartDate;                                         // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasRotation;                                      // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScheduleSlotData                      Slot1Schedule;                                     // 0x0010(0x0010)(NativeAccessSpecifierPublic)
	struct FScheduleSlotData                      Slot2Schedule;                                     // 0x0020(0x0010)(NativeAccessSpecifierPublic)
	struct FScheduleSlotData                      Slot3Schedule;                                     // 0x0030(0x0010)(NativeAccessSpecifierPublic)
	struct FScheduleSlotData                      Slot4Schedule;                                     // 0x0040(0x0010)(NativeAccessSpecifierPublic)
	struct FScheduleSlotData                      Slot5Schedule;                                     // 0x0050(0x0010)(NativeAccessSpecifierPublic)
	TArray<struct FScheduleSaleEntry>             OnSaleItems;                                       // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScheduleSerializer) == 0x000008, "Wrong alignment on FScheduleSerializer");
static_assert(sizeof(FScheduleSerializer) == 0x000070, "Wrong size on FScheduleSerializer");
static_assert(offsetof(FScheduleSerializer, StartDate) == 0x000000, "Member 'FScheduleSerializer::StartDate' has a wrong offset!");
static_assert(offsetof(FScheduleSerializer, bHasRotation) == 0x000008, "Member 'FScheduleSerializer::bHasRotation' has a wrong offset!");
static_assert(offsetof(FScheduleSerializer, Slot1Schedule) == 0x000010, "Member 'FScheduleSerializer::Slot1Schedule' has a wrong offset!");
static_assert(offsetof(FScheduleSerializer, Slot2Schedule) == 0x000020, "Member 'FScheduleSerializer::Slot2Schedule' has a wrong offset!");
static_assert(offsetof(FScheduleSerializer, Slot3Schedule) == 0x000030, "Member 'FScheduleSerializer::Slot3Schedule' has a wrong offset!");
static_assert(offsetof(FScheduleSerializer, Slot4Schedule) == 0x000040, "Member 'FScheduleSerializer::Slot4Schedule' has a wrong offset!");
static_assert(offsetof(FScheduleSerializer, Slot5Schedule) == 0x000050, "Member 'FScheduleSerializer::Slot5Schedule' has a wrong offset!");
static_assert(offsetof(FScheduleSerializer, OnSaleItems) == 0x000060, "Member 'FScheduleSerializer::OnSaleItems' has a wrong offset!");

// ScriptStruct DeceiveInc.AllDIItemsSerializer
// 0x0010 (0x0010 - 0x0000)
struct FAllDIItemsSerializer final
{
public:
	TArray<struct FDIItemSerializer>              AllSerializedData;                                 // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAllDIItemsSerializer) == 0x000008, "Wrong alignment on FAllDIItemsSerializer");
static_assert(sizeof(FAllDIItemsSerializer) == 0x000010, "Wrong size on FAllDIItemsSerializer");
static_assert(offsetof(FAllDIItemsSerializer, AllSerializedData) == 0x000000, "Member 'FAllDIItemsSerializer::AllSerializedData' has a wrong offset!");

// ScriptStruct DeceiveInc.ValuePerRarityEntry
// 0x0008 (0x0008 - 0x0000)
struct FValuePerRarityEntry final
{
public:
	int32                                         SoftCost;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HardCost;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FValuePerRarityEntry) == 0x000004, "Wrong alignment on FValuePerRarityEntry");
static_assert(sizeof(FValuePerRarityEntry) == 0x000008, "Wrong size on FValuePerRarityEntry");
static_assert(offsetof(FValuePerRarityEntry, SoftCost) == 0x000000, "Member 'FValuePerRarityEntry::SoftCost' has a wrong offset!");
static_assert(offsetof(FValuePerRarityEntry, HardCost) == 0x000004, "Member 'FValuePerRarityEntry::HardCost' has a wrong offset!");

// ScriptStruct DeceiveInc.SoftCurrencyGroupCostDataEntry
// 0x0018 (0x0018 - 0x0000)
struct FSoftCurrencyGroupCostDataEntry final
{
public:
	TSubclassOf<class UDIPrimaryDataAsset>        AssetType;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FValuePerRarityEntry>           ValuesPerRarity;                                   // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoftCurrencyGroupCostDataEntry) == 0x000008, "Wrong alignment on FSoftCurrencyGroupCostDataEntry");
static_assert(sizeof(FSoftCurrencyGroupCostDataEntry) == 0x000018, "Wrong size on FSoftCurrencyGroupCostDataEntry");
static_assert(offsetof(FSoftCurrencyGroupCostDataEntry, AssetType) == 0x000000, "Member 'FSoftCurrencyGroupCostDataEntry::AssetType' has a wrong offset!");
static_assert(offsetof(FSoftCurrencyGroupCostDataEntry, ValuesPerRarity) == 0x000008, "Member 'FSoftCurrencyGroupCostDataEntry::ValuesPerRarity' has a wrong offset!");

// ScriptStruct DeceiveInc.SoftCurrencyGroupCostData
// 0x0010 (0x0010 - 0x0000)
struct FSoftCurrencyGroupCostData final
{
public:
	TArray<struct FSoftCurrencyGroupCostDataEntry> ValuesPerRarity;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoftCurrencyGroupCostData) == 0x000008, "Wrong alignment on FSoftCurrencyGroupCostData");
static_assert(sizeof(FSoftCurrencyGroupCostData) == 0x000010, "Wrong size on FSoftCurrencyGroupCostData");
static_assert(offsetof(FSoftCurrencyGroupCostData, ValuesPerRarity) == 0x000000, "Member 'FSoftCurrencyGroupCostData::ValuesPerRarity' has a wrong offset!");

// ScriptStruct DeceiveInc.DataItemIDGenerationData
// 0x0018 (0x0018 - 0x0000)
struct FDataItemIDGenerationData final
{
public:
	TSubclassOf<class UDIItem>                    HandledClass;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInt32Range>                    IDRanges;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDataItemIDGenerationData) == 0x000008, "Wrong alignment on FDataItemIDGenerationData");
static_assert(sizeof(FDataItemIDGenerationData) == 0x000018, "Wrong size on FDataItemIDGenerationData");
static_assert(offsetof(FDataItemIDGenerationData, HandledClass) == 0x000000, "Member 'FDataItemIDGenerationData::HandledClass' has a wrong offset!");
static_assert(offsetof(FDataItemIDGenerationData, IDRanges) == 0x000008, "Member 'FDataItemIDGenerationData::IDRanges' has a wrong offset!");

// ScriptStruct DeceiveInc.ItemCostEntry
// 0x0038 (0x0038 - 0x0000)
struct FItemCostEntry final
{
public:
	int32                                         CurrencyId;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDICurrencyItem>         CurrencyType;                                      // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost;                                              // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemCostEntry) == 0x000008, "Wrong alignment on FItemCostEntry");
static_assert(sizeof(FItemCostEntry) == 0x000038, "Wrong size on FItemCostEntry");
static_assert(offsetof(FItemCostEntry, CurrencyId) == 0x000000, "Member 'FItemCostEntry::CurrencyId' has a wrong offset!");
static_assert(offsetof(FItemCostEntry, CurrencyType) == 0x000008, "Member 'FItemCostEntry::CurrencyType' has a wrong offset!");
static_assert(offsetof(FItemCostEntry, Cost) == 0x000030, "Member 'FItemCostEntry::Cost' has a wrong offset!");

// ScriptStruct DeceiveInc.XpMultiplicatorEventInfo
// 0x0068 (0x0068 - 0x0000)
struct FXpMultiplicatorEventInfo final
{
public:
	float                                         MultiplicatorGiven;                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxEventTrigger;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSharedToFaction;                                // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateColor                            DisplayColor;                                      // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bAffectGenericXpType;                              // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         SpecificXpTypeToAffect;                            // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FXpMultiplicatorEventInfo) == 0x000008, "Wrong alignment on FXpMultiplicatorEventInfo");
static_assert(sizeof(FXpMultiplicatorEventInfo) == 0x000068, "Wrong size on FXpMultiplicatorEventInfo");
static_assert(offsetof(FXpMultiplicatorEventInfo, MultiplicatorGiven) == 0x000000, "Member 'FXpMultiplicatorEventInfo::MultiplicatorGiven' has a wrong offset!");
static_assert(offsetof(FXpMultiplicatorEventInfo, MaxEventTrigger) == 0x000004, "Member 'FXpMultiplicatorEventInfo::MaxEventTrigger' has a wrong offset!");
static_assert(offsetof(FXpMultiplicatorEventInfo, bIsSharedToFaction) == 0x000008, "Member 'FXpMultiplicatorEventInfo::bIsSharedToFaction' has a wrong offset!");
static_assert(offsetof(FXpMultiplicatorEventInfo, DisplayName) == 0x000010, "Member 'FXpMultiplicatorEventInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FXpMultiplicatorEventInfo, DisplayColor) == 0x000028, "Member 'FXpMultiplicatorEventInfo::DisplayColor' has a wrong offset!");
static_assert(offsetof(FXpMultiplicatorEventInfo, bAffectGenericXpType) == 0x000050, "Member 'FXpMultiplicatorEventInfo::bAffectGenericXpType' has a wrong offset!");
static_assert(offsetof(FXpMultiplicatorEventInfo, SpecificXpTypeToAffect) == 0x000058, "Member 'FXpMultiplicatorEventInfo::SpecificXpTypeToAffect' has a wrong offset!");

// ScriptStruct DeceiveInc.DropAtInfo
// 0x0010 (0x0010 - 0x0000)
struct FDropAtInfo final
{
public:
	class UObject*                                ObjectToDropFrom;                                  // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDropAtInfo) == 0x000008, "Wrong alignment on FDropAtInfo");
static_assert(sizeof(FDropAtInfo) == 0x000010, "Wrong size on FDropAtInfo");
static_assert(offsetof(FDropAtInfo, ObjectToDropFrom) == 0x000000, "Member 'FDropAtInfo::ObjectToDropFrom' has a wrong offset!");
static_assert(offsetof(FDropAtInfo, SocketName) == 0x000008, "Member 'FDropAtInfo::SocketName' has a wrong offset!");

// ScriptStruct DeceiveInc.DropReplicatedData
// 0x0040 (0x0040 - 0x0000)
struct FDropReplicatedData final
{
public:
	struct FVector_NetQuantize                    StartPos;                                          // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    EndPos;                                            // 0x000C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              Normal;                                            // 0x0018(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FDropAtInfo                            DropAtInfo;                                        // 0x0030(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDropReplicatedData) == 0x000008, "Wrong alignment on FDropReplicatedData");
static_assert(sizeof(FDropReplicatedData) == 0x000040, "Wrong size on FDropReplicatedData");
static_assert(offsetof(FDropReplicatedData, StartPos) == 0x000000, "Member 'FDropReplicatedData::StartPos' has a wrong offset!");
static_assert(offsetof(FDropReplicatedData, EndPos) == 0x00000C, "Member 'FDropReplicatedData::EndPos' has a wrong offset!");
static_assert(offsetof(FDropReplicatedData, Normal) == 0x000018, "Member 'FDropReplicatedData::Normal' has a wrong offset!");
static_assert(offsetof(FDropReplicatedData, Rotation) == 0x000024, "Member 'FDropReplicatedData::Rotation' has a wrong offset!");
static_assert(offsetof(FDropReplicatedData, DropAtInfo) == 0x000030, "Member 'FDropReplicatedData::DropAtInfo' has a wrong offset!");

// ScriptStruct DeceiveInc.AccuracyHealthThreshold
// 0x0008 (0x0008 - 0x0000)
struct FAccuracyHealthThreshold final
{
public:
	float                                         HealthThreshold;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccuracyMultiplier;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccuracyHealthThreshold) == 0x000004, "Wrong alignment on FAccuracyHealthThreshold");
static_assert(sizeof(FAccuracyHealthThreshold) == 0x000008, "Wrong size on FAccuracyHealthThreshold");
static_assert(offsetof(FAccuracyHealthThreshold, HealthThreshold) == 0x000000, "Member 'FAccuracyHealthThreshold::HealthThreshold' has a wrong offset!");
static_assert(offsetof(FAccuracyHealthThreshold, AccuracyMultiplier) == 0x000004, "Member 'FAccuracyHealthThreshold::AccuracyMultiplier' has a wrong offset!");

// ScriptStruct DeceiveInc.HeatLevelEncounterData
// 0x0030 (0x0030 - 0x0000)
struct FHeatLevelEncounterData final
{
public:
	bool                                          bAllowShooting;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowMelee;                                       // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxGuards;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleRatioMaxTime;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkRatioMaxTime;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunRatioMaxTime;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAccuracyHealthThreshold>       AccuracyHealthMultipliers;                         // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AssignRange;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHeatLevelEncounterData) == 0x000008, "Wrong alignment on FHeatLevelEncounterData");
static_assert(sizeof(FHeatLevelEncounterData) == 0x000030, "Wrong size on FHeatLevelEncounterData");
static_assert(offsetof(FHeatLevelEncounterData, bAllowShooting) == 0x000000, "Member 'FHeatLevelEncounterData::bAllowShooting' has a wrong offset!");
static_assert(offsetof(FHeatLevelEncounterData, bAllowMelee) == 0x000001, "Member 'FHeatLevelEncounterData::bAllowMelee' has a wrong offset!");
static_assert(offsetof(FHeatLevelEncounterData, MaxGuards) == 0x000004, "Member 'FHeatLevelEncounterData::MaxGuards' has a wrong offset!");
static_assert(offsetof(FHeatLevelEncounterData, IdleRatioMaxTime) == 0x000008, "Member 'FHeatLevelEncounterData::IdleRatioMaxTime' has a wrong offset!");
static_assert(offsetof(FHeatLevelEncounterData, WalkRatioMaxTime) == 0x00000C, "Member 'FHeatLevelEncounterData::WalkRatioMaxTime' has a wrong offset!");
static_assert(offsetof(FHeatLevelEncounterData, RunRatioMaxTime) == 0x000010, "Member 'FHeatLevelEncounterData::RunRatioMaxTime' has a wrong offset!");
static_assert(offsetof(FHeatLevelEncounterData, AccuracyHealthMultipliers) == 0x000018, "Member 'FHeatLevelEncounterData::AccuracyHealthMultipliers' has a wrong offset!");
static_assert(offsetof(FHeatLevelEncounterData, AssignRange) == 0x000028, "Member 'FHeatLevelEncounterData::AssignRange' has a wrong offset!");

// ScriptStruct DeceiveInc.DebugEncounterReplicationData
// 0x0058 (0x0058 - 0x0000)
struct FDebugEncounterReplicationData final
{
public:
	TArray<class ANPCCharacter*>                  Assigneds;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ANPCCharacter*>                  ByStanders;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ANPCCharacter*>                  AwaresNotParticipating;                            // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ANPCCharacter*>                  Fakers;                                            // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class ASpy*                                   TargetSpy;                                         // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EncounterLocation;                                 // 0x0048(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugIndexedID;                                    // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugEncounterReplicationData) == 0x000008, "Wrong alignment on FDebugEncounterReplicationData");
static_assert(sizeof(FDebugEncounterReplicationData) == 0x000058, "Wrong size on FDebugEncounterReplicationData");
static_assert(offsetof(FDebugEncounterReplicationData, Assigneds) == 0x000000, "Member 'FDebugEncounterReplicationData::Assigneds' has a wrong offset!");
static_assert(offsetof(FDebugEncounterReplicationData, ByStanders) == 0x000010, "Member 'FDebugEncounterReplicationData::ByStanders' has a wrong offset!");
static_assert(offsetof(FDebugEncounterReplicationData, AwaresNotParticipating) == 0x000020, "Member 'FDebugEncounterReplicationData::AwaresNotParticipating' has a wrong offset!");
static_assert(offsetof(FDebugEncounterReplicationData, Fakers) == 0x000030, "Member 'FDebugEncounterReplicationData::Fakers' has a wrong offset!");
static_assert(offsetof(FDebugEncounterReplicationData, TargetSpy) == 0x000040, "Member 'FDebugEncounterReplicationData::TargetSpy' has a wrong offset!");
static_assert(offsetof(FDebugEncounterReplicationData, EncounterLocation) == 0x000048, "Member 'FDebugEncounterReplicationData::EncounterLocation' has a wrong offset!");
static_assert(offsetof(FDebugEncounterReplicationData, DebugIndexedID) == 0x000054, "Member 'FDebugEncounterReplicationData::DebugIndexedID' has a wrong offset!");

// ScriptStruct DeceiveInc.CachedImpulseData
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x04) FCachedImpulseData final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCachedImpulseData) == 0x000004, "Wrong alignment on FCachedImpulseData");
static_assert(sizeof(FCachedImpulseData) == 0x000020, "Wrong size on FCachedImpulseData");

// ScriptStruct DeceiveInc.FakeMovementRepData
// 0x001C (0x001C - 0x0000)
struct FFakeMovementRepData final
{
public:
	struct FVector_NetQuantize                    SpawnPosition;                                     // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMovementEnabled;                                  // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    MoveDirection;                                     // 0x0010(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFakeMovementRepData) == 0x000004, "Wrong alignment on FFakeMovementRepData");
static_assert(sizeof(FFakeMovementRepData) == 0x00001C, "Wrong size on FFakeMovementRepData");
static_assert(offsetof(FFakeMovementRepData, SpawnPosition) == 0x000000, "Member 'FFakeMovementRepData::SpawnPosition' has a wrong offset!");
static_assert(offsetof(FFakeMovementRepData, bMovementEnabled) == 0x00000C, "Member 'FFakeMovementRepData::bMovementEnabled' has a wrong offset!");
static_assert(offsetof(FFakeMovementRepData, MoveDirection) == 0x000010, "Member 'FFakeMovementRepData::MoveDirection' has a wrong offset!");

// ScriptStruct DeceiveInc.FallDamageStep
// 0x0008 (0x0008 - 0x0000)
struct FFallDamageStep final
{
public:
	float                                         FallingVelocity;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FallDamage;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFallDamageStep) == 0x000004, "Wrong alignment on FFallDamageStep");
static_assert(sizeof(FFallDamageStep) == 0x000008, "Wrong size on FFallDamageStep");
static_assert(offsetof(FFallDamageStep, FallingVelocity) == 0x000000, "Member 'FFallDamageStep::FallingVelocity' has a wrong offset!");
static_assert(offsetof(FFallDamageStep, FallDamage) == 0x000004, "Member 'FFallDamageStep::FallDamage' has a wrong offset!");

// ScriptStruct DeceiveInc.FetchMatchmakingTokenRequestBody
// 0x0050 (0x0050 - 0x0000)
struct FFetchMatchmakingTokenRequestBody final
{
public:
	TMap<class FString, int32>                    PingData;                                          // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FFetchMatchmakingTokenRequestBody) == 0x000008, "Wrong alignment on FFetchMatchmakingTokenRequestBody");
static_assert(sizeof(FFetchMatchmakingTokenRequestBody) == 0x000050, "Wrong size on FFetchMatchmakingTokenRequestBody");
static_assert(offsetof(FFetchMatchmakingTokenRequestBody, PingData) == 0x000000, "Member 'FFetchMatchmakingTokenRequestBody::PingData' has a wrong offset!");

// ScriptStruct DeceiveInc.GameLiftMatchmakerData
// 0x0050 (0x0050 - 0x0000)
struct FGameLiftMatchmakerData final
{
public:
	class FString                                 MatchId;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameSessionARN;                                    // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchmakerConfigurationARN;                        // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameLiftMatchmakerTeam>        Teams;                                             // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 AutoBackfillTicketId;                              // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameLiftMatchmakerData) == 0x000008, "Wrong alignment on FGameLiftMatchmakerData");
static_assert(sizeof(FGameLiftMatchmakerData) == 0x000050, "Wrong size on FGameLiftMatchmakerData");
static_assert(offsetof(FGameLiftMatchmakerData, MatchId) == 0x000000, "Member 'FGameLiftMatchmakerData::MatchId' has a wrong offset!");
static_assert(offsetof(FGameLiftMatchmakerData, GameSessionARN) == 0x000010, "Member 'FGameLiftMatchmakerData::GameSessionARN' has a wrong offset!");
static_assert(offsetof(FGameLiftMatchmakerData, MatchmakerConfigurationARN) == 0x000020, "Member 'FGameLiftMatchmakerData::MatchmakerConfigurationARN' has a wrong offset!");
static_assert(offsetof(FGameLiftMatchmakerData, Teams) == 0x000030, "Member 'FGameLiftMatchmakerData::Teams' has a wrong offset!");
static_assert(offsetof(FGameLiftMatchmakerData, AutoBackfillTicketId) == 0x000040, "Member 'FGameLiftMatchmakerData::AutoBackfillTicketId' has a wrong offset!");

// ScriptStruct DeceiveInc.RessourceMaxMods
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FRessourceMaxMods final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRessourceMaxMods) == 0x000004, "Wrong alignment on FRessourceMaxMods");
static_assert(sizeof(FRessourceMaxMods) == 0x000014, "Wrong size on FRessourceMaxMods");

// ScriptStruct DeceiveInc.PlayerResourceData
// 0x0008 (0x0008 - 0x0000)
struct FPlayerResourceData final
{
public:
	int32                                         Amount;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAmount;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerResourceData) == 0x000004, "Wrong alignment on FPlayerResourceData");
static_assert(sizeof(FPlayerResourceData) == 0x000008, "Wrong size on FPlayerResourceData");
static_assert(offsetof(FPlayerResourceData, Amount) == 0x000000, "Member 'FPlayerResourceData::Amount' has a wrong offset!");
static_assert(offsetof(FPlayerResourceData, MaxAmount) == 0x000004, "Member 'FPlayerResourceData::MaxAmount' has a wrong offset!");

// ScriptStruct DeceiveInc.GameplayResourcesSettings
// 0x0030 (0x0030 - 0x0000)
struct FGameplayResourcesSettings final
{
public:
	TSubclassOf<class AActor>                     DropResourceActor;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         DefaultMaxAmount;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGrabLootAnimation                            GrabAnimation;                                     // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     DisplayOnlyResourceActor;                          // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayResourcesSettings) == 0x000008, "Wrong alignment on FGameplayResourcesSettings");
static_assert(sizeof(FGameplayResourcesSettings) == 0x000030, "Wrong size on FGameplayResourcesSettings");
static_assert(offsetof(FGameplayResourcesSettings, DropResourceActor) == 0x000000, "Member 'FGameplayResourcesSettings::DropResourceActor' has a wrong offset!");
static_assert(offsetof(FGameplayResourcesSettings, DisplayName) == 0x000008, "Member 'FGameplayResourcesSettings::DisplayName' has a wrong offset!");
static_assert(offsetof(FGameplayResourcesSettings, DefaultMaxAmount) == 0x000020, "Member 'FGameplayResourcesSettings::DefaultMaxAmount' has a wrong offset!");
static_assert(offsetof(FGameplayResourcesSettings, GrabAnimation) == 0x000024, "Member 'FGameplayResourcesSettings::GrabAnimation' has a wrong offset!");
static_assert(offsetof(FGameplayResourcesSettings, DisplayOnlyResourceActor) == 0x000028, "Member 'FGameplayResourcesSettings::DisplayOnlyResourceActor' has a wrong offset!");

// ScriptStruct DeceiveInc.GameSessionResponse
// 0x0098 (0x0098 - 0x0000)
struct alignas(0x08) FGameSessionResponse final
{
public:
	uint8                                         Pad_0[0x98];                                       // 0x0000(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameSessionResponse) == 0x000008, "Wrong alignment on FGameSessionResponse");
static_assert(sizeof(FGameSessionResponse) == 0x000098, "Wrong size on FGameSessionResponse");

// ScriptStruct DeceiveInc.SandboxSettingsResponse
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x08) FSandboxSettingsResponse final
{
public:
	uint8                                         Pad_0[0x80];                                       // 0x0000(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSandboxSettingsResponse) == 0x000008, "Wrong alignment on FSandboxSettingsResponse");
static_assert(sizeof(FSandboxSettingsResponse) == 0x000080, "Wrong size on FSandboxSettingsResponse");

// ScriptStruct DeceiveInc.CurrencyRewardDefinition
// 0x0028 (0x0028 - 0x0000)
struct FCurrencyRewardDefinition final
{
public:
	class FString                                 PlayerID;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrencyType;                                      // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrencyAmount;                                    // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCurrencyRewardDefinition) == 0x000008, "Wrong alignment on FCurrencyRewardDefinition");
static_assert(sizeof(FCurrencyRewardDefinition) == 0x000028, "Wrong size on FCurrencyRewardDefinition");
static_assert(offsetof(FCurrencyRewardDefinition, PlayerID) == 0x000000, "Member 'FCurrencyRewardDefinition::PlayerID' has a wrong offset!");
static_assert(offsetof(FCurrencyRewardDefinition, CurrencyType) == 0x000010, "Member 'FCurrencyRewardDefinition::CurrencyType' has a wrong offset!");
static_assert(offsetof(FCurrencyRewardDefinition, CurrencyAmount) == 0x000020, "Member 'FCurrencyRewardDefinition::CurrencyAmount' has a wrong offset!");

// ScriptStruct DeceiveInc.GiveCurrencyRequestBody
// 0x0010 (0x0010 - 0x0000)
struct FGiveCurrencyRequestBody final
{
public:
	TArray<struct FCurrencyRewardDefinition>      CurrencyRewards;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGiveCurrencyRequestBody) == 0x000008, "Wrong alignment on FGiveCurrencyRequestBody");
static_assert(sizeof(FGiveCurrencyRequestBody) == 0x000010, "Wrong size on FGiveCurrencyRequestBody");
static_assert(offsetof(FGiveCurrencyRequestBody, CurrencyRewards) == 0x000000, "Member 'FGiveCurrencyRequestBody::CurrencyRewards' has a wrong offset!");

// ScriptStruct DeceiveInc.GiveLootBundleRequestBody
// 0x0010 (0x0010 - 0x0000)
struct FGiveLootBundleRequestBody final
{
public:
	TArray<struct FLootRewardDefinition>          LootRewards;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGiveLootBundleRequestBody) == 0x000008, "Wrong alignment on FGiveLootBundleRequestBody");
static_assert(sizeof(FGiveLootBundleRequestBody) == 0x000010, "Wrong size on FGiveLootBundleRequestBody");
static_assert(offsetof(FGiveLootBundleRequestBody, LootRewards) == 0x000000, "Member 'FGiveLootBundleRequestBody::LootRewards' has a wrong offset!");

// ScriptStruct DeceiveInc.GivePlayerXpDefinition
// 0x0028 (0x0028 - 0x0000)
struct FGivePlayerXpDefinition final
{
public:
	class FString                                 PlayerID;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Experience;                                        // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ProgressionType;                                   // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGivePlayerXpDefinition) == 0x000008, "Wrong alignment on FGivePlayerXpDefinition");
static_assert(sizeof(FGivePlayerXpDefinition) == 0x000028, "Wrong size on FGivePlayerXpDefinition");
static_assert(offsetof(FGivePlayerXpDefinition, PlayerID) == 0x000000, "Member 'FGivePlayerXpDefinition::PlayerID' has a wrong offset!");
static_assert(offsetof(FGivePlayerXpDefinition, Level) == 0x000010, "Member 'FGivePlayerXpDefinition::Level' has a wrong offset!");
static_assert(offsetof(FGivePlayerXpDefinition, Experience) == 0x000014, "Member 'FGivePlayerXpDefinition::Experience' has a wrong offset!");
static_assert(offsetof(FGivePlayerXpDefinition, ProgressionType) == 0x000018, "Member 'FGivePlayerXpDefinition::ProgressionType' has a wrong offset!");

// ScriptStruct DeceiveInc.GiveXpRequestBody
// 0x0028 (0x0028 - 0x0000)
struct FGiveXpRequestBody final
{
public:
	int32                                         TimePlayed;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGivePlayerXpDefinition>        Progression;                                       // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGivePlayerEloDefinition>       Elo;                                               // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGiveXpRequestBody) == 0x000008, "Wrong alignment on FGiveXpRequestBody");
static_assert(sizeof(FGiveXpRequestBody) == 0x000028, "Wrong size on FGiveXpRequestBody");
static_assert(offsetof(FGiveXpRequestBody, TimePlayed) == 0x000000, "Member 'FGiveXpRequestBody::TimePlayed' has a wrong offset!");
static_assert(offsetof(FGiveXpRequestBody, Progression) == 0x000008, "Member 'FGiveXpRequestBody::Progression' has a wrong offset!");
static_assert(offsetof(FGiveXpRequestBody, Elo) == 0x000018, "Member 'FGiveXpRequestBody::Elo' has a wrong offset!");

// ScriptStruct DeceiveInc.HealthInfo
// 0x0020 (0x0020 - 0x0000)
struct FHealthInfo final
{
public:
	float                                         Health;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDamageType*                            DamageType;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastRaw;                                           // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHealthInfo) == 0x000008, "Wrong alignment on FHealthInfo");
static_assert(sizeof(FHealthInfo) == 0x000020, "Wrong size on FHealthInfo");
static_assert(offsetof(FHealthInfo, Health) == 0x000000, "Member 'FHealthInfo::Health' has a wrong offset!");
static_assert(offsetof(FHealthInfo, DamageType) == 0x000008, "Member 'FHealthInfo::DamageType' has a wrong offset!");
static_assert(offsetof(FHealthInfo, DamageCauser) == 0x000010, "Member 'FHealthInfo::DamageCauser' has a wrong offset!");
static_assert(offsetof(FHealthInfo, LastRaw) == 0x000018, "Member 'FHealthInfo::LastRaw' has a wrong offset!");

// ScriptStruct DeceiveInc.DeceiveIncPointDamageEvent
// 0x0008 (0x00B0 - 0x00A8)
struct FDeceiveIncPointDamageEvent final : public FPointDamageEvent
{
public:
	EHitType                                      HitType;                                           // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDeceiveIncPointDamageEvent) == 0x000008, "Wrong alignment on FDeceiveIncPointDamageEvent");
static_assert(sizeof(FDeceiveIncPointDamageEvent) == 0x0000B0, "Wrong size on FDeceiveIncPointDamageEvent");
static_assert(offsetof(FDeceiveIncPointDamageEvent, HitType) == 0x0000A8, "Member 'FDeceiveIncPointDamageEvent::HitType' has a wrong offset!");

// ScriptStruct DeceiveInc.InteractableTypeBlockRequest
// 0x0018 (0x0018 - 0x0000)
struct FInteractableTypeBlockRequest final
{
public:
	class AActor*                                 Requester;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EInteractableType>                     BlockedInteractableType;                           // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractableTypeBlockRequest) == 0x000008, "Wrong alignment on FInteractableTypeBlockRequest");
static_assert(sizeof(FInteractableTypeBlockRequest) == 0x000018, "Wrong size on FInteractableTypeBlockRequest");
static_assert(offsetof(FInteractableTypeBlockRequest, Requester) == 0x000000, "Member 'FInteractableTypeBlockRequest::Requester' has a wrong offset!");
static_assert(offsetof(FInteractableTypeBlockRequest, BlockedInteractableType) == 0x000008, "Member 'FInteractableTypeBlockRequest::BlockedInteractableType' has a wrong offset!");

// ScriptStruct DeceiveInc.InteractableState
// 0x0010 (0x0010 - 0x0000)
struct FInteractableState final
{
public:
	class UInteractableComponent*                 InteractableComp;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractableState                            InteractableState;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractableState) == 0x000008, "Wrong alignment on FInteractableState");
static_assert(sizeof(FInteractableState) == 0x000010, "Wrong size on FInteractableState");
static_assert(offsetof(FInteractableState, InteractableComp) == 0x000000, "Member 'FInteractableState::InteractableComp' has a wrong offset!");
static_assert(offsetof(FInteractableState, InteractableState) == 0x000008, "Member 'FInteractableState::InteractableState' has a wrong offset!");

// ScriptStruct DeceiveInc.LarcinStealResourcesSettings
// 0x0010 (0x0010 - 0x0000)
struct FLarcinStealResourcesSettings final
{
public:
	EGrabLootAnimation                            GrabAnimation;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     DisplayOnlyResourceActor;                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLarcinStealResourcesSettings) == 0x000008, "Wrong alignment on FLarcinStealResourcesSettings");
static_assert(sizeof(FLarcinStealResourcesSettings) == 0x000010, "Wrong size on FLarcinStealResourcesSettings");
static_assert(offsetof(FLarcinStealResourcesSettings, GrabAnimation) == 0x000000, "Member 'FLarcinStealResourcesSettings::GrabAnimation' has a wrong offset!");
static_assert(offsetof(FLarcinStealResourcesSettings, DisplayOnlyResourceActor) == 0x000008, "Member 'FLarcinStealResourcesSettings::DisplayOnlyResourceActor' has a wrong offset!");

// ScriptStruct DeceiveInc.XpTypeInventory
// 0x0050 (0x0050 - 0x0000)
struct FXpTypeInventory final
{
public:
	TMap<class UDIPrimaryDataAsset*, int32>       ItemsMap;                                          // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FXpTypeInventory) == 0x000008, "Wrong alignment on FXpTypeInventory");
static_assert(sizeof(FXpTypeInventory) == 0x000050, "Wrong size on FXpTypeInventory");
static_assert(offsetof(FXpTypeInventory, ItemsMap) == 0x000000, "Member 'FXpTypeInventory::ItemsMap' has a wrong offset!");

// ScriptStruct DeceiveInc.LocalSessionDataResponse
// 0x0030 (0x0030 - 0x0000)
struct FLocalSessionDataResponse final
{
public:
	class FString                                 SessionID;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameMode;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFactionResponse>               FactionPlanResponse;                               // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLocalSessionDataResponse) == 0x000008, "Wrong alignment on FLocalSessionDataResponse");
static_assert(sizeof(FLocalSessionDataResponse) == 0x000030, "Wrong size on FLocalSessionDataResponse");
static_assert(offsetof(FLocalSessionDataResponse, SessionID) == 0x000000, "Member 'FLocalSessionDataResponse::SessionID' has a wrong offset!");
static_assert(offsetof(FLocalSessionDataResponse, GameMode) == 0x000010, "Member 'FLocalSessionDataResponse::GameMode' has a wrong offset!");
static_assert(offsetof(FLocalSessionDataResponse, FactionPlanResponse) == 0x000020, "Member 'FLocalSessionDataResponse::FactionPlanResponse' has a wrong offset!");

// ScriptStruct DeceiveInc.LootRewardInfo
// 0x0010 (0x0010 - 0x0000)
struct FLootRewardInfo final
{
public:
	class UDIPrimaryDataAsset*                    RewardDataAsset;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LootWeight;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLootRewardInfo) == 0x000008, "Wrong alignment on FLootRewardInfo");
static_assert(sizeof(FLootRewardInfo) == 0x000010, "Wrong size on FLootRewardInfo");
static_assert(offsetof(FLootRewardInfo, RewardDataAsset) == 0x000000, "Member 'FLootRewardInfo::RewardDataAsset' has a wrong offset!");
static_assert(offsetof(FLootRewardInfo, LootWeight) == 0x000008, "Member 'FLootRewardInfo::LootWeight' has a wrong offset!");

// ScriptStruct DeceiveInc.ReplicatedPlayerUseLeft
// 0x0008 (0x0008 - 0x0000)
struct FReplicatedPlayerUseLeft final
{
public:
	int32                                         PlayerIndex;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseLeft;                                           // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplicatedPlayerUseLeft) == 0x000004, "Wrong alignment on FReplicatedPlayerUseLeft");
static_assert(sizeof(FReplicatedPlayerUseLeft) == 0x000008, "Wrong size on FReplicatedPlayerUseLeft");
static_assert(offsetof(FReplicatedPlayerUseLeft, PlayerIndex) == 0x000000, "Member 'FReplicatedPlayerUseLeft::PlayerIndex' has a wrong offset!");
static_assert(offsetof(FReplicatedPlayerUseLeft, UseLeft) == 0x000004, "Member 'FReplicatedPlayerUseLeft::UseLeft' has a wrong offset!");

// ScriptStruct DeceiveInc.NavModeItemTypeSettings
// 0x0010 (0x0010 - 0x0000)
struct FNavModeItemTypeSettings final
{
public:
	float                                         SeingDistance;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedLineOfSight;                                  // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisibleThroughFloor;                              // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowAllItemOfType;                                // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 NavModeColor;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 NavModeSelectedColor;                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavModeItemTypeSettings) == 0x000004, "Wrong alignment on FNavModeItemTypeSettings");
static_assert(sizeof(FNavModeItemTypeSettings) == 0x000010, "Wrong size on FNavModeItemTypeSettings");
static_assert(offsetof(FNavModeItemTypeSettings, SeingDistance) == 0x000000, "Member 'FNavModeItemTypeSettings::SeingDistance' has a wrong offset!");
static_assert(offsetof(FNavModeItemTypeSettings, bNeedLineOfSight) == 0x000004, "Member 'FNavModeItemTypeSettings::bNeedLineOfSight' has a wrong offset!");
static_assert(offsetof(FNavModeItemTypeSettings, bVisibleThroughFloor) == 0x000005, "Member 'FNavModeItemTypeSettings::bVisibleThroughFloor' has a wrong offset!");
static_assert(offsetof(FNavModeItemTypeSettings, bShowAllItemOfType) == 0x000006, "Member 'FNavModeItemTypeSettings::bShowAllItemOfType' has a wrong offset!");
static_assert(offsetof(FNavModeItemTypeSettings, NavModeColor) == 0x000008, "Member 'FNavModeItemTypeSettings::NavModeColor' has a wrong offset!");
static_assert(offsetof(FNavModeItemTypeSettings, NavModeSelectedColor) == 0x00000C, "Member 'FNavModeItemTypeSettings::NavModeSelectedColor' has a wrong offset!");

// ScriptStruct DeceiveInc.DINetworkInfoData
// 0x0050 (0x0050 - 0x0000)
struct FDINetworkInfoData final
{
public:
	float                                         Ping;                                              // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KBpsIn;                                            // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KBpsOut;                                           // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PacketLossIn;                                      // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PacketLossOut;                                     // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PacketsPerSecIn;                                   // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PacketsPerSecOut;                                  // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerFrameTime;                                   // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerRegion;                                      // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerVersion;                                     // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SessionID;                                         // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDINetworkInfoData) == 0x000008, "Wrong alignment on FDINetworkInfoData");
static_assert(sizeof(FDINetworkInfoData) == 0x000050, "Wrong size on FDINetworkInfoData");
static_assert(offsetof(FDINetworkInfoData, Ping) == 0x000000, "Member 'FDINetworkInfoData::Ping' has a wrong offset!");
static_assert(offsetof(FDINetworkInfoData, KBpsIn) == 0x000004, "Member 'FDINetworkInfoData::KBpsIn' has a wrong offset!");
static_assert(offsetof(FDINetworkInfoData, KBpsOut) == 0x000008, "Member 'FDINetworkInfoData::KBpsOut' has a wrong offset!");
static_assert(offsetof(FDINetworkInfoData, PacketLossIn) == 0x00000C, "Member 'FDINetworkInfoData::PacketLossIn' has a wrong offset!");
static_assert(offsetof(FDINetworkInfoData, PacketLossOut) == 0x000010, "Member 'FDINetworkInfoData::PacketLossOut' has a wrong offset!");
static_assert(offsetof(FDINetworkInfoData, PacketsPerSecIn) == 0x000014, "Member 'FDINetworkInfoData::PacketsPerSecIn' has a wrong offset!");
static_assert(offsetof(FDINetworkInfoData, PacketsPerSecOut) == 0x000018, "Member 'FDINetworkInfoData::PacketsPerSecOut' has a wrong offset!");
static_assert(offsetof(FDINetworkInfoData, ServerFrameTime) == 0x00001C, "Member 'FDINetworkInfoData::ServerFrameTime' has a wrong offset!");
static_assert(offsetof(FDINetworkInfoData, ServerRegion) == 0x000020, "Member 'FDINetworkInfoData::ServerRegion' has a wrong offset!");
static_assert(offsetof(FDINetworkInfoData, ServerVersion) == 0x000030, "Member 'FDINetworkInfoData::ServerVersion' has a wrong offset!");
static_assert(offsetof(FDINetworkInfoData, SessionID) == 0x000040, "Member 'FDINetworkInfoData::SessionID' has a wrong offset!");

// ScriptStruct DeceiveInc.NPCBugViewLimit
// 0x0018 (0x0018 - 0x0000)
struct FNPCBugViewLimit final
{
public:
	float                                         ViewPitchMin;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewPitchMax;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewYawMin;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewYawMax;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewRollMin;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewRollMax;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCBugViewLimit) == 0x000004, "Wrong alignment on FNPCBugViewLimit");
static_assert(sizeof(FNPCBugViewLimit) == 0x000018, "Wrong size on FNPCBugViewLimit");
static_assert(offsetof(FNPCBugViewLimit, ViewPitchMin) == 0x000000, "Member 'FNPCBugViewLimit::ViewPitchMin' has a wrong offset!");
static_assert(offsetof(FNPCBugViewLimit, ViewPitchMax) == 0x000004, "Member 'FNPCBugViewLimit::ViewPitchMax' has a wrong offset!");
static_assert(offsetof(FNPCBugViewLimit, ViewYawMin) == 0x000008, "Member 'FNPCBugViewLimit::ViewYawMin' has a wrong offset!");
static_assert(offsetof(FNPCBugViewLimit, ViewYawMax) == 0x00000C, "Member 'FNPCBugViewLimit::ViewYawMax' has a wrong offset!");
static_assert(offsetof(FNPCBugViewLimit, ViewRollMin) == 0x000010, "Member 'FNPCBugViewLimit::ViewRollMin' has a wrong offset!");
static_assert(offsetof(FNPCBugViewLimit, ViewRollMax) == 0x000014, "Member 'FNPCBugViewLimit::ViewRollMax' has a wrong offset!");

// ScriptStruct DeceiveInc.NPCMovementReplicationData
// 0x0010 (0x0010 - 0x0000)
struct FNPCMovementReplicationData final
{
public:
	struct FVector_NetQuantize                    TargetPos;                                         // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MovementFlags;                                     // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCMovementReplicationData) == 0x000004, "Wrong alignment on FNPCMovementReplicationData");
static_assert(sizeof(FNPCMovementReplicationData) == 0x000010, "Wrong size on FNPCMovementReplicationData");
static_assert(offsetof(FNPCMovementReplicationData, TargetPos) == 0x000000, "Member 'FNPCMovementReplicationData::TargetPos' has a wrong offset!");
static_assert(offsetof(FNPCMovementReplicationData, MovementFlags) == 0x00000C, "Member 'FNPCMovementReplicationData::MovementFlags' has a wrong offset!");

// ScriptStruct DeceiveInc.NPCInteractAnimKit
// 0x0028 (0x0028 - 0x0000)
struct FNPCInteractAnimKit final
{
public:
	class UAnimSequence*                          AnimationIn;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  AnimationLoops;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimationOut;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowLookAt;                                      // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCInteractAnimKit) == 0x000008, "Wrong alignment on FNPCInteractAnimKit");
static_assert(sizeof(FNPCInteractAnimKit) == 0x000028, "Wrong size on FNPCInteractAnimKit");
static_assert(offsetof(FNPCInteractAnimKit, AnimationIn) == 0x000000, "Member 'FNPCInteractAnimKit::AnimationIn' has a wrong offset!");
static_assert(offsetof(FNPCInteractAnimKit, AnimationLoops) == 0x000008, "Member 'FNPCInteractAnimKit::AnimationLoops' has a wrong offset!");
static_assert(offsetof(FNPCInteractAnimKit, AnimationOut) == 0x000018, "Member 'FNPCInteractAnimKit::AnimationOut' has a wrong offset!");
static_assert(offsetof(FNPCInteractAnimKit, bAllowLookAt) == 0x000020, "Member 'FNPCInteractAnimKit::bAllowLookAt' has a wrong offset!");

// ScriptStruct DeceiveInc.PossibleObjectsToSpawn
// 0x0020 (0x0020 - 0x0000)
struct FPossibleObjectsToSpawn final
{
public:
	TArray<struct FPossibleObjectToSpawn>         ObjectsToSpawn;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPossibleObjectsOnSpawnPointType> ObjectsToSpawnOnSpawnPointType;                    // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPossibleObjectsToSpawn) == 0x000008, "Wrong alignment on FPossibleObjectsToSpawn");
static_assert(sizeof(FPossibleObjectsToSpawn) == 0x000020, "Wrong size on FPossibleObjectsToSpawn");
static_assert(offsetof(FPossibleObjectsToSpawn, ObjectsToSpawn) == 0x000000, "Member 'FPossibleObjectsToSpawn::ObjectsToSpawn' has a wrong offset!");
static_assert(offsetof(FPossibleObjectsToSpawn, ObjectsToSpawnOnSpawnPointType) == 0x000010, "Member 'FPossibleObjectsToSpawn::ObjectsToSpawnOnSpawnPointType' has a wrong offset!");

// ScriptStruct DeceiveInc.PossibleObjectToSpawnPresets
// 0x0140 (0x0140 - 0x0000)
struct FPossibleObjectToSpawnPresets final
{
public:
	struct FPossibleObjectsToSpawn                InVaultPresets[0x5];                               // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FPossibleObjectsToSpawn                OutOfVaultPresets[0x5];                            // 0x00A0(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPossibleObjectToSpawnPresets) == 0x000008, "Wrong alignment on FPossibleObjectToSpawnPresets");
static_assert(sizeof(FPossibleObjectToSpawnPresets) == 0x000140, "Wrong size on FPossibleObjectToSpawnPresets");
static_assert(offsetof(FPossibleObjectToSpawnPresets, InVaultPresets) == 0x000000, "Member 'FPossibleObjectToSpawnPresets::InVaultPresets' has a wrong offset!");
static_assert(offsetof(FPossibleObjectToSpawnPresets, OutOfVaultPresets) == 0x0000A0, "Member 'FPossibleObjectToSpawnPresets::OutOfVaultPresets' has a wrong offset!");

// ScriptStruct DeceiveInc.OctoActiveAbilityResultReplication
// 0x0020 (0x0020 - 0x0000)
struct FOctoActiveAbilityResultReplication final
{
public:
	TArray<class AActor*>                         HackedActors;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         RebootedActors;                                    // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOctoActiveAbilityResultReplication) == 0x000008, "Wrong alignment on FOctoActiveAbilityResultReplication");
static_assert(sizeof(FOctoActiveAbilityResultReplication) == 0x000020, "Wrong size on FOctoActiveAbilityResultReplication");
static_assert(offsetof(FOctoActiveAbilityResultReplication, HackedActors) == 0x000000, "Member 'FOctoActiveAbilityResultReplication::HackedActors' has a wrong offset!");
static_assert(offsetof(FOctoActiveAbilityResultReplication, RebootedActors) == 0x000010, "Member 'FOctoActiveAbilityResultReplication::RebootedActors' has a wrong offset!");

// ScriptStruct DeceiveInc.OctoDrainZoneVisualFeedbackData
// 0x0018 (0x0018 - 0x0000)
struct FOctoDrainZoneVisualFeedbackData final
{
public:
	TWeakObjectPtr<class AOctoIntelDrainZoneVisualFeedback> ZoneActor;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AOctoActiveAbilityMod1>> OctoActivesDrainingThisZone;                       // 0x0008(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOctoDrainZoneVisualFeedbackData) == 0x000008, "Wrong alignment on FOctoDrainZoneVisualFeedbackData");
static_assert(sizeof(FOctoDrainZoneVisualFeedbackData) == 0x000018, "Wrong size on FOctoDrainZoneVisualFeedbackData");
static_assert(offsetof(FOctoDrainZoneVisualFeedbackData, ZoneActor) == 0x000000, "Member 'FOctoDrainZoneVisualFeedbackData::ZoneActor' has a wrong offset!");
static_assert(offsetof(FOctoDrainZoneVisualFeedbackData, OctoActivesDrainingThisZone) == 0x000008, "Member 'FOctoDrainZoneVisualFeedbackData::OctoActivesDrainingThisZone' has a wrong offset!");

// ScriptStruct DeceiveInc.PingInfo
// 0x0040 (0x0040 - 0x0000)
struct FPingInfo final
{
public:
	TSoftObjectPtr<class UTexture2D>              PingTexture;                                       // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   PingText;                                          // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPingInfo) == 0x000008, "Wrong alignment on FPingInfo");
static_assert(sizeof(FPingInfo) == 0x000040, "Wrong size on FPingInfo");
static_assert(offsetof(FPingInfo, PingTexture) == 0x000000, "Member 'FPingInfo::PingTexture' has a wrong offset!");
static_assert(offsetof(FPingInfo, PingText) == 0x000028, "Member 'FPingInfo::PingText' has a wrong offset!");

// ScriptStruct DeceiveInc.DangerScareSetting
// 0x000C (0x000C - 0x0000)
struct FDangerScareSetting final
{
public:
	float                                         DangerScareRadius;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DangerScareHalfHeight;                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoOcclusionCheck;                                 // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOcclusionUseComplex;                              // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             OcclusionCheckChannel;                             // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotifyEncounterManagerDirectly;                   // 0x000B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDangerScareSetting) == 0x000004, "Wrong alignment on FDangerScareSetting");
static_assert(sizeof(FDangerScareSetting) == 0x00000C, "Wrong size on FDangerScareSetting");
static_assert(offsetof(FDangerScareSetting, DangerScareRadius) == 0x000000, "Member 'FDangerScareSetting::DangerScareRadius' has a wrong offset!");
static_assert(offsetof(FDangerScareSetting, DangerScareHalfHeight) == 0x000004, "Member 'FDangerScareSetting::DangerScareHalfHeight' has a wrong offset!");
static_assert(offsetof(FDangerScareSetting, bDoOcclusionCheck) == 0x000008, "Member 'FDangerScareSetting::bDoOcclusionCheck' has a wrong offset!");
static_assert(offsetof(FDangerScareSetting, bOcclusionUseComplex) == 0x000009, "Member 'FDangerScareSetting::bOcclusionUseComplex' has a wrong offset!");
static_assert(offsetof(FDangerScareSetting, OcclusionCheckChannel) == 0x00000A, "Member 'FDangerScareSetting::OcclusionCheckChannel' has a wrong offset!");
static_assert(offsetof(FDangerScareSetting, bNotifyEncounterManagerDirectly) == 0x00000B, "Member 'FDangerScareSetting::bNotifyEncounterManagerDirectly' has a wrong offset!");

// ScriptStruct DeceiveInc.DangerScareSettings
// 0x0060 (0x0060 - 0x0000)
struct FDangerScareSettings final
{
public:
	struct FDangerScareSetting                    DefaultSetting;                                    // 0x0000(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EDangerEventSourceType, struct FDangerScareSetting> SettingPerSourceType;                              // 0x0010(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDangerScareSettings) == 0x000008, "Wrong alignment on FDangerScareSettings");
static_assert(sizeof(FDangerScareSettings) == 0x000060, "Wrong size on FDangerScareSettings");
static_assert(offsetof(FDangerScareSettings, DefaultSetting) == 0x000000, "Member 'FDangerScareSettings::DefaultSetting' has a wrong offset!");
static_assert(offsetof(FDangerScareSettings, SettingPerSourceType) == 0x000010, "Member 'FDangerScareSettings::SettingPerSourceType' has a wrong offset!");

// ScriptStruct DeceiveInc.RoomWeightMultiplierBySLevel
// 0x0014 (0x0014 - 0x0000)
struct FRoomWeightMultiplierBySLevel final
{
public:
	float                                         CivilianRoomMultiplier;                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaffRoomMultiplier;                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GuardRoomMultiplier;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TechnicianRoomMultiplier;                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VIPRoomMultiplier;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoomWeightMultiplierBySLevel) == 0x000004, "Wrong alignment on FRoomWeightMultiplierBySLevel");
static_assert(sizeof(FRoomWeightMultiplierBySLevel) == 0x000014, "Wrong size on FRoomWeightMultiplierBySLevel");
static_assert(offsetof(FRoomWeightMultiplierBySLevel, CivilianRoomMultiplier) == 0x000000, "Member 'FRoomWeightMultiplierBySLevel::CivilianRoomMultiplier' has a wrong offset!");
static_assert(offsetof(FRoomWeightMultiplierBySLevel, StaffRoomMultiplier) == 0x000004, "Member 'FRoomWeightMultiplierBySLevel::StaffRoomMultiplier' has a wrong offset!");
static_assert(offsetof(FRoomWeightMultiplierBySLevel, GuardRoomMultiplier) == 0x000008, "Member 'FRoomWeightMultiplierBySLevel::GuardRoomMultiplier' has a wrong offset!");
static_assert(offsetof(FRoomWeightMultiplierBySLevel, TechnicianRoomMultiplier) == 0x00000C, "Member 'FRoomWeightMultiplierBySLevel::TechnicianRoomMultiplier' has a wrong offset!");
static_assert(offsetof(FRoomWeightMultiplierBySLevel, VIPRoomMultiplier) == 0x000010, "Member 'FRoomWeightMultiplierBySLevel::VIPRoomMultiplier' has a wrong offset!");

// ScriptStruct DeceiveInc.NPCSuspiciousRankParams
// 0x0008 (0x0008 - 0x0000)
struct FNPCSuspiciousRankParams final
{
public:
	float                                         RankPercentage;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuspiciousPercentage;                              // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCSuspiciousRankParams) == 0x000004, "Wrong alignment on FNPCSuspiciousRankParams");
static_assert(sizeof(FNPCSuspiciousRankParams) == 0x000008, "Wrong size on FNPCSuspiciousRankParams");
static_assert(offsetof(FNPCSuspiciousRankParams, RankPercentage) == 0x000000, "Member 'FNPCSuspiciousRankParams::RankPercentage' has a wrong offset!");
static_assert(offsetof(FNPCSuspiciousRankParams, SuspiciousPercentage) == 0x000004, "Member 'FNPCSuspiciousRankParams::SuspiciousPercentage' has a wrong offset!");

// ScriptStruct DeceiveInc.DangerSourceStorage
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FDangerSourceStorage final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDangerSourceStorage) == 0x000008, "Wrong alignment on FDangerSourceStorage");
static_assert(sizeof(FDangerSourceStorage) == 0x000040, "Wrong size on FDangerSourceStorage");

// ScriptStruct DeceiveInc.PerPowerupPickupData
// 0x0003 (0x0003 - 0x0000)
struct FPerPowerupPickupData final
{
public:
	EPowerupType                                  PowerupType;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESecurityLevel                                Level;                                             // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerPowerupPickupData) == 0x000001, "Wrong alignment on FPerPowerupPickupData");
static_assert(sizeof(FPerPowerupPickupData) == 0x000003, "Wrong size on FPerPowerupPickupData");
static_assert(offsetof(FPerPowerupPickupData, PowerupType) == 0x000000, "Member 'FPerPowerupPickupData::PowerupType' has a wrong offset!");
static_assert(offsetof(FPerPowerupPickupData, Level) == 0x000001, "Member 'FPerPowerupPickupData::Level' has a wrong offset!");
static_assert(offsetof(FPerPowerupPickupData, bEnabled) == 0x000002, "Member 'FPerPowerupPickupData::bEnabled' has a wrong offset!");

// ScriptStruct DeceiveInc.ExfiltratorData
// 0x0050 (0x0050 - 0x0000)
struct FExfiltratorData final
{
public:
	TMap<ESecurityLevel, float>                   PerLevel;                                          // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExfiltratorData) == 0x000008, "Wrong alignment on FExfiltratorData");
static_assert(sizeof(FExfiltratorData) == 0x000050, "Wrong size on FExfiltratorData");
static_assert(offsetof(FExfiltratorData, PerLevel) == 0x000000, "Member 'FExfiltratorData::PerLevel' has a wrong offset!");

// ScriptStruct DeceiveInc.FoodieData
// 0x0050 (0x0050 - 0x0000)
struct FFoodieData final
{
public:
	TMap<ESecurityLevel, int32>                   PerLevelOverride;                                  // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFoodieData) == 0x000008, "Wrong alignment on FFoodieData");
static_assert(sizeof(FFoodieData) == 0x000050, "Wrong size on FFoodieData");
static_assert(offsetof(FFoodieData, PerLevelOverride) == 0x000000, "Member 'FFoodieData::PerLevelOverride' has a wrong offset!");

// ScriptStruct DeceiveInc.RessourceModData
// 0x0008 (0x0008 - 0x0000)
struct FRessourceModData final
{
public:
	int32                                         MaxAmountToAdd;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResourceAmountToGive;                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRessourceModData) == 0x000004, "Wrong alignment on FRessourceModData");
static_assert(sizeof(FRessourceModData) == 0x000008, "Wrong size on FRessourceModData");
static_assert(offsetof(FRessourceModData, MaxAmountToAdd) == 0x000000, "Member 'FRessourceModData::MaxAmountToAdd' has a wrong offset!");
static_assert(offsetof(FRessourceModData, ResourceAmountToGive) == 0x000004, "Member 'FRessourceModData::ResourceAmountToGive' has a wrong offset!");

// ScriptStruct DeceiveInc.MaxAmountPowerupSettings
// 0x0058 (0x0058 - 0x0000)
struct FMaxAmountPowerupSettings final
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ESecurityLevel, struct FRessourceModData> AmmountPerLevel;                                   // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaxAmountPowerupSettings) == 0x000008, "Wrong alignment on FMaxAmountPowerupSettings");
static_assert(sizeof(FMaxAmountPowerupSettings) == 0x000058, "Wrong size on FMaxAmountPowerupSettings");
static_assert(offsetof(FMaxAmountPowerupSettings, ResourceType) == 0x000000, "Member 'FMaxAmountPowerupSettings::ResourceType' has a wrong offset!");
static_assert(offsetof(FMaxAmountPowerupSettings, AmmountPerLevel) == 0x000008, "Member 'FMaxAmountPowerupSettings::AmmountPerLevel' has a wrong offset!");

// ScriptStruct DeceiveInc.PowerupInfo
// 0x00A8 (0x00A8 - 0x0000)
struct FPowerupInfo final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             UITexture;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      MeshTexture;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   BuffStatName;                                      // 0x0040(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<ESecurityLevel, class FText>             PerLevelBuffStatValue;                             // 0x0058(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPowerupInfo) == 0x000008, "Wrong alignment on FPowerupInfo");
static_assert(sizeof(FPowerupInfo) == 0x0000A8, "Wrong size on FPowerupInfo");
static_assert(offsetof(FPowerupInfo, Name) == 0x000000, "Member 'FPowerupInfo::Name' has a wrong offset!");
static_assert(offsetof(FPowerupInfo, Description) == 0x000018, "Member 'FPowerupInfo::Description' has a wrong offset!");
static_assert(offsetof(FPowerupInfo, UITexture) == 0x000030, "Member 'FPowerupInfo::UITexture' has a wrong offset!");
static_assert(offsetof(FPowerupInfo, MeshTexture) == 0x000038, "Member 'FPowerupInfo::MeshTexture' has a wrong offset!");
static_assert(offsetof(FPowerupInfo, BuffStatName) == 0x000040, "Member 'FPowerupInfo::BuffStatName' has a wrong offset!");
static_assert(offsetof(FPowerupInfo, PerLevelBuffStatValue) == 0x000058, "Member 'FPowerupInfo::PerLevelBuffStatValue' has a wrong offset!");

// ScriptStruct DeceiveInc.DIPrivateLobbyFactonInfo
// 0x0010 (0x0010 - 0x0000)
struct FDIPrivateLobbyFactonInfo final
{
public:
	TArray<class FString>                         FactionMembersId;                                  // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDIPrivateLobbyFactonInfo) == 0x000008, "Wrong alignment on FDIPrivateLobbyFactonInfo");
static_assert(sizeof(FDIPrivateLobbyFactonInfo) == 0x000010, "Wrong size on FDIPrivateLobbyFactonInfo");
static_assert(offsetof(FDIPrivateLobbyFactonInfo, FactionMembersId) == 0x000000, "Member 'FDIPrivateLobbyFactonInfo::FactionMembersId' has a wrong offset!");

// ScriptStruct DeceiveInc.DIPrivateLobbyInfo
// 0x00C8 (0x00C8 - 0x0000)
struct FDIPrivateLobbyInfo final
{
public:
	EDIGameMode                                   GameMode;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OperationMapCode;                                  // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerRegion;                                      // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDIPrivateLobbyFactonInfo>      Factions;                                          // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDIPrivateLobbyFactonInfo              SpectatorFaction;                                  // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<int32>                                 NPCPopulationCount;                                // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FObjectToSpawnCount>            ObjectsToSpawnCountOverride;                       // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FHeatSetupData                         HeatSettings;                                      // 0x0068(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EBotsDifficulty                               BotsDifficulty;                                    // 0x00B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BotsAmount;                                        // 0x00BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFillWithBots;                                     // 0x00C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSandboxMode;                                      // 0x00C1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x6];                                       // 0x00C2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDIPrivateLobbyInfo) == 0x000008, "Wrong alignment on FDIPrivateLobbyInfo");
static_assert(sizeof(FDIPrivateLobbyInfo) == 0x0000C8, "Wrong size on FDIPrivateLobbyInfo");
static_assert(offsetof(FDIPrivateLobbyInfo, GameMode) == 0x000000, "Member 'FDIPrivateLobbyInfo::GameMode' has a wrong offset!");
static_assert(offsetof(FDIPrivateLobbyInfo, OperationMapCode) == 0x000008, "Member 'FDIPrivateLobbyInfo::OperationMapCode' has a wrong offset!");
static_assert(offsetof(FDIPrivateLobbyInfo, ServerRegion) == 0x000018, "Member 'FDIPrivateLobbyInfo::ServerRegion' has a wrong offset!");
static_assert(offsetof(FDIPrivateLobbyInfo, Factions) == 0x000028, "Member 'FDIPrivateLobbyInfo::Factions' has a wrong offset!");
static_assert(offsetof(FDIPrivateLobbyInfo, SpectatorFaction) == 0x000038, "Member 'FDIPrivateLobbyInfo::SpectatorFaction' has a wrong offset!");
static_assert(offsetof(FDIPrivateLobbyInfo, NPCPopulationCount) == 0x000048, "Member 'FDIPrivateLobbyInfo::NPCPopulationCount' has a wrong offset!");
static_assert(offsetof(FDIPrivateLobbyInfo, ObjectsToSpawnCountOverride) == 0x000058, "Member 'FDIPrivateLobbyInfo::ObjectsToSpawnCountOverride' has a wrong offset!");
static_assert(offsetof(FDIPrivateLobbyInfo, HeatSettings) == 0x000068, "Member 'FDIPrivateLobbyInfo::HeatSettings' has a wrong offset!");
static_assert(offsetof(FDIPrivateLobbyInfo, BotsDifficulty) == 0x0000B8, "Member 'FDIPrivateLobbyInfo::BotsDifficulty' has a wrong offset!");
static_assert(offsetof(FDIPrivateLobbyInfo, BotsAmount) == 0x0000BC, "Member 'FDIPrivateLobbyInfo::BotsAmount' has a wrong offset!");
static_assert(offsetof(FDIPrivateLobbyInfo, bFillWithBots) == 0x0000C0, "Member 'FDIPrivateLobbyInfo::bFillWithBots' has a wrong offset!");
static_assert(offsetof(FDIPrivateLobbyInfo, bSandboxMode) == 0x0000C1, "Member 'FDIPrivateLobbyInfo::bSandboxMode' has a wrong offset!");

// ScriptStruct DeceiveInc.LootRewardPerLevel
// 0x0020 (0x0020 - 0x0000)
struct FLootRewardPerLevel final
{
public:
	struct FRewardInfo                            LootRewardPoolInfo;                                // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         LevelStart;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelEnd;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LootRewardLevelInterval;                           // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLootRewardPerLevel) == 0x000008, "Wrong alignment on FLootRewardPerLevel");
static_assert(sizeof(FLootRewardPerLevel) == 0x000020, "Wrong size on FLootRewardPerLevel");
static_assert(offsetof(FLootRewardPerLevel, LootRewardPoolInfo) == 0x000000, "Member 'FLootRewardPerLevel::LootRewardPoolInfo' has a wrong offset!");
static_assert(offsetof(FLootRewardPerLevel, LevelStart) == 0x000010, "Member 'FLootRewardPerLevel::LevelStart' has a wrong offset!");
static_assert(offsetof(FLootRewardPerLevel, LevelEnd) == 0x000014, "Member 'FLootRewardPerLevel::LevelEnd' has a wrong offset!");
static_assert(offsetof(FLootRewardPerLevel, LootRewardLevelInterval) == 0x000018, "Member 'FLootRewardPerLevel::LootRewardLevelInterval' has a wrong offset!");

// ScriptStruct DeceiveInc.SprayWeaponHitProcessingData
// 0x0008 (0x0010 - 0x0008)
struct FSprayWeaponHitProcessingData final : public FHitProcessingData
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSprayWeaponHitProcessingData) == 0x000008, "Wrong alignment on FSprayWeaponHitProcessingData");
static_assert(sizeof(FSprayWeaponHitProcessingData) == 0x000010, "Wrong size on FSprayWeaponHitProcessingData");

// ScriptStruct DeceiveInc.SprayWeaponDamageContextData
// 0x0008 (0x0018 - 0x0010)
struct FSprayWeaponDamageContextData final : public FDamageContextData
{
public:
	float                                         RatioOfProjectilesHitting;                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSprayWeaponDamageContextData) == 0x000008, "Wrong alignment on FSprayWeaponDamageContextData");
static_assert(sizeof(FSprayWeaponDamageContextData) == 0x000018, "Wrong size on FSprayWeaponDamageContextData");
static_assert(offsetof(FSprayWeaponDamageContextData, RatioOfProjectilesHitting) == 0x000010, "Member 'FSprayWeaponDamageContextData::RatioOfProjectilesHitting' has a wrong offset!");

// ScriptStruct DeceiveInc.ProjectileBalancingData
// 0x0020 (0x0028 - 0x0008)
struct FProjectileBalancingData final : public FTableRowBase
{
public:
	class FName                                   BehaviorName;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChargedBehaviorName;                               // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileLifetime;                                // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FullyChargedSpeed;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialSpeed;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScale;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileBalancingData) == 0x000008, "Wrong alignment on FProjectileBalancingData");
static_assert(sizeof(FProjectileBalancingData) == 0x000028, "Wrong size on FProjectileBalancingData");
static_assert(offsetof(FProjectileBalancingData, BehaviorName) == 0x000008, "Member 'FProjectileBalancingData::BehaviorName' has a wrong offset!");
static_assert(offsetof(FProjectileBalancingData, ChargedBehaviorName) == 0x000010, "Member 'FProjectileBalancingData::ChargedBehaviorName' has a wrong offset!");
static_assert(offsetof(FProjectileBalancingData, ProjectileLifetime) == 0x000018, "Member 'FProjectileBalancingData::ProjectileLifetime' has a wrong offset!");
static_assert(offsetof(FProjectileBalancingData, FullyChargedSpeed) == 0x00001C, "Member 'FProjectileBalancingData::FullyChargedSpeed' has a wrong offset!");
static_assert(offsetof(FProjectileBalancingData, InitialSpeed) == 0x000020, "Member 'FProjectileBalancingData::InitialSpeed' has a wrong offset!");
static_assert(offsetof(FProjectileBalancingData, GravityScale) == 0x000024, "Member 'FProjectileBalancingData::GravityScale' has a wrong offset!");

// ScriptStruct DeceiveInc.ProjectileWeaponBalancingData
// 0x0050 (0x0058 - 0x0008)
struct FProjectileWeaponBalancingData : public FTableRowBase
{
public:
	int32                                         MagSize;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LowAmmoCount;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResourceOnStart;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResourcePerFullAmmoPack;                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResourcePerDispenserAmmoPack;                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResourceAtMaxAmmo;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResourcePerShot;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverwriteBlockShootingAfterMelee;                  // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 OverwriteBlockShootingAfterMeleeChargeLevel;       // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         ReloadTime;                                        // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireRate;                                          // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShotDelayAfterBurst;                               // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDamageBehavior>                DamageBehaviors;                                   // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileWeaponBalancingData) == 0x000008, "Wrong alignment on FProjectileWeaponBalancingData");
static_assert(sizeof(FProjectileWeaponBalancingData) == 0x000058, "Wrong size on FProjectileWeaponBalancingData");
static_assert(offsetof(FProjectileWeaponBalancingData, MagSize) == 0x000008, "Member 'FProjectileWeaponBalancingData::MagSize' has a wrong offset!");
static_assert(offsetof(FProjectileWeaponBalancingData, LowAmmoCount) == 0x00000C, "Member 'FProjectileWeaponBalancingData::LowAmmoCount' has a wrong offset!");
static_assert(offsetof(FProjectileWeaponBalancingData, ResourceOnStart) == 0x000010, "Member 'FProjectileWeaponBalancingData::ResourceOnStart' has a wrong offset!");
static_assert(offsetof(FProjectileWeaponBalancingData, ResourcePerFullAmmoPack) == 0x000014, "Member 'FProjectileWeaponBalancingData::ResourcePerFullAmmoPack' has a wrong offset!");
static_assert(offsetof(FProjectileWeaponBalancingData, ResourcePerDispenserAmmoPack) == 0x000018, "Member 'FProjectileWeaponBalancingData::ResourcePerDispenserAmmoPack' has a wrong offset!");
static_assert(offsetof(FProjectileWeaponBalancingData, ResourceAtMaxAmmo) == 0x00001C, "Member 'FProjectileWeaponBalancingData::ResourceAtMaxAmmo' has a wrong offset!");
static_assert(offsetof(FProjectileWeaponBalancingData, ResourcePerShot) == 0x000020, "Member 'FProjectileWeaponBalancingData::ResourcePerShot' has a wrong offset!");
static_assert(offsetof(FProjectileWeaponBalancingData, OverwriteBlockShootingAfterMelee) == 0x000024, "Member 'FProjectileWeaponBalancingData::OverwriteBlockShootingAfterMelee' has a wrong offset!");
static_assert(offsetof(FProjectileWeaponBalancingData, OverwriteBlockShootingAfterMeleeChargeLevel) == 0x000028, "Member 'FProjectileWeaponBalancingData::OverwriteBlockShootingAfterMeleeChargeLevel' has a wrong offset!");
static_assert(offsetof(FProjectileWeaponBalancingData, ReloadTime) == 0x000038, "Member 'FProjectileWeaponBalancingData::ReloadTime' has a wrong offset!");
static_assert(offsetof(FProjectileWeaponBalancingData, FireRate) == 0x00003C, "Member 'FProjectileWeaponBalancingData::FireRate' has a wrong offset!");
static_assert(offsetof(FProjectileWeaponBalancingData, ShotDelayAfterBurst) == 0x000040, "Member 'FProjectileWeaponBalancingData::ShotDelayAfterBurst' has a wrong offset!");
static_assert(offsetof(FProjectileWeaponBalancingData, DamageBehaviors) == 0x000048, "Member 'FProjectileWeaponBalancingData::DamageBehaviors' has a wrong offset!");

// ScriptStruct DeceiveInc.SpawnerWeaponBalancingData
// 0x0008 (0x0060 - 0x0058)
struct FSpawnerWeaponBalancingData final : public FProjectileWeaponBalancingData
{
public:
	float                                         FullChargeTime;                                    // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnerWeaponBalancingData) == 0x000008, "Wrong alignment on FSpawnerWeaponBalancingData");
static_assert(sizeof(FSpawnerWeaponBalancingData) == 0x000060, "Wrong size on FSpawnerWeaponBalancingData");
static_assert(offsetof(FSpawnerWeaponBalancingData, FullChargeTime) == 0x000058, "Member 'FSpawnerWeaponBalancingData::FullChargeTime' has a wrong offset!");

// ScriptStruct DeceiveInc.ReportRequestBody
// 0x0040 (0x0040 - 0x0000)
struct FReportRequestBody final
{
public:
	class FString                                 Reporter;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Reportee;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchId;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReportRequestBody) == 0x000008, "Wrong alignment on FReportRequestBody");
static_assert(sizeof(FReportRequestBody) == 0x000040, "Wrong size on FReportRequestBody");
static_assert(offsetof(FReportRequestBody, Reporter) == 0x000000, "Member 'FReportRequestBody::Reporter' has a wrong offset!");
static_assert(offsetof(FReportRequestBody, Reportee) == 0x000010, "Member 'FReportRequestBody::Reportee' has a wrong offset!");
static_assert(offsetof(FReportRequestBody, MatchId) == 0x000020, "Member 'FReportRequestBody::MatchId' has a wrong offset!");
static_assert(offsetof(FReportRequestBody, Message) == 0x000030, "Member 'FReportRequestBody::Message' has a wrong offset!");

// ScriptStruct DeceiveInc.RewardBundleInfo
// 0x0108 (0x0108 - 0x0000)
struct FRewardBundleInfo final
{
public:
	class FString                                 BundleXpType;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BundleLevel;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   BundleName;                                        // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   BundleDesc;                                        // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            BundleIcon;                                        // 0x0048(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                BundleIconTexture;                                 // 0x00D0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDIPrimaryDataAsset*>            BundleAssets;                                      // 0x00F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRewardBundleInfo) == 0x000008, "Wrong alignment on FRewardBundleInfo");
static_assert(sizeof(FRewardBundleInfo) == 0x000108, "Wrong size on FRewardBundleInfo");
static_assert(offsetof(FRewardBundleInfo, BundleXpType) == 0x000000, "Member 'FRewardBundleInfo::BundleXpType' has a wrong offset!");
static_assert(offsetof(FRewardBundleInfo, BundleLevel) == 0x000010, "Member 'FRewardBundleInfo::BundleLevel' has a wrong offset!");
static_assert(offsetof(FRewardBundleInfo, BundleName) == 0x000018, "Member 'FRewardBundleInfo::BundleName' has a wrong offset!");
static_assert(offsetof(FRewardBundleInfo, BundleDesc) == 0x000030, "Member 'FRewardBundleInfo::BundleDesc' has a wrong offset!");
static_assert(offsetof(FRewardBundleInfo, BundleIcon) == 0x000048, "Member 'FRewardBundleInfo::BundleIcon' has a wrong offset!");
static_assert(offsetof(FRewardBundleInfo, BundleIconTexture) == 0x0000D0, "Member 'FRewardBundleInfo::BundleIconTexture' has a wrong offset!");
static_assert(offsetof(FRewardBundleInfo, BundleAssets) == 0x0000F8, "Member 'FRewardBundleInfo::BundleAssets' has a wrong offset!");

// ScriptStruct DeceiveInc.RoomObjectSpawnParams
// 0x000C (0x000C - 0x0000)
struct FRoomObjectSpawnParams final
{
public:
	float                                         MinScore;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxScore;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalObjectSpawnScore;                             // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoomObjectSpawnParams) == 0x000004, "Wrong alignment on FRoomObjectSpawnParams");
static_assert(sizeof(FRoomObjectSpawnParams) == 0x00000C, "Wrong size on FRoomObjectSpawnParams");
static_assert(offsetof(FRoomObjectSpawnParams, MinScore) == 0x000000, "Member 'FRoomObjectSpawnParams::MinScore' has a wrong offset!");
static_assert(offsetof(FRoomObjectSpawnParams, MaxScore) == 0x000004, "Member 'FRoomObjectSpawnParams::MaxScore' has a wrong offset!");
static_assert(offsetof(FRoomObjectSpawnParams, TotalObjectSpawnScore) == 0x000008, "Member 'FRoomObjectSpawnParams::TotalObjectSpawnScore' has a wrong offset!");

// ScriptStruct DeceiveInc.ExitPoint
// 0x0078 (0x0078 - 0x0000)
struct FExitPoint final
{
public:
	struct FVector                                ExitCellPos;                                       // 0x0000(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalRoomWeightForNPCPool[0x7];                    // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalRoomWeightForNPCPoolOfSameVaultFlag[0x7];     // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint32>                                ReachableRoomCRCs;                                 // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x20];                                      // 0x0058(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExitPoint) == 0x000008, "Wrong alignment on FExitPoint");
static_assert(sizeof(FExitPoint) == 0x000078, "Wrong size on FExitPoint");
static_assert(offsetof(FExitPoint, ExitCellPos) == 0x000000, "Member 'FExitPoint::ExitCellPos' has a wrong offset!");
static_assert(offsetof(FExitPoint, TotalRoomWeightForNPCPool) == 0x00000C, "Member 'FExitPoint::TotalRoomWeightForNPCPool' has a wrong offset!");
static_assert(offsetof(FExitPoint, TotalRoomWeightForNPCPoolOfSameVaultFlag) == 0x000028, "Member 'FExitPoint::TotalRoomWeightForNPCPoolOfSameVaultFlag' has a wrong offset!");
static_assert(offsetof(FExitPoint, ReachableRoomCRCs) == 0x000048, "Member 'FExitPoint::ReachableRoomCRCs' has a wrong offset!");

// ScriptStruct DeceiveInc.ExitPointReachableRoomConnectedData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FExitPointReachableRoomConnectedData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExitPointReachableRoomConnectedData) == 0x000008, "Wrong alignment on FExitPointReachableRoomConnectedData");
static_assert(sizeof(FExitPointReachableRoomConnectedData) == 0x000010, "Wrong size on FExitPointReachableRoomConnectedData");

// ScriptStruct DeceiveInc.GeneratedRoomData
// 0x0070 (0x0070 - 0x0000)
struct FGeneratedRoomData final
{
public:
	TArray<struct FVector>                        ValidCells;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	struct FVector                                GridOrigin;                                        // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        GridSizeX;                                         // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        GridSizeY;                                         // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CenterValidPos;                                    // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalRoomWeightForNPCPool[0x7];                    // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalRoomWeightForNPCPoolOfSameVaultFlag[0x7];     // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGeneratedRoomData) == 0x000008, "Wrong alignment on FGeneratedRoomData");
static_assert(sizeof(FGeneratedRoomData) == 0x000070, "Wrong size on FGeneratedRoomData");
static_assert(offsetof(FGeneratedRoomData, ValidCells) == 0x000000, "Member 'FGeneratedRoomData::ValidCells' has a wrong offset!");
static_assert(offsetof(FGeneratedRoomData, GridOrigin) == 0x000010, "Member 'FGeneratedRoomData::GridOrigin' has a wrong offset!");
static_assert(offsetof(FGeneratedRoomData, GridSizeX) == 0x00001C, "Member 'FGeneratedRoomData::GridSizeX' has a wrong offset!");
static_assert(offsetof(FGeneratedRoomData, GridSizeY) == 0x000020, "Member 'FGeneratedRoomData::GridSizeY' has a wrong offset!");
static_assert(offsetof(FGeneratedRoomData, CenterValidPos) == 0x000024, "Member 'FGeneratedRoomData::CenterValidPos' has a wrong offset!");
static_assert(offsetof(FGeneratedRoomData, TotalRoomWeightForNPCPool) == 0x000030, "Member 'FGeneratedRoomData::TotalRoomWeightForNPCPool' has a wrong offset!");
static_assert(offsetof(FGeneratedRoomData, TotalRoomWeightForNPCPoolOfSameVaultFlag) == 0x00004C, "Member 'FGeneratedRoomData::TotalRoomWeightForNPCPoolOfSameVaultFlag' has a wrong offset!");
static_assert(offsetof(FGeneratedRoomData, Weight) == 0x000068, "Member 'FGeneratedRoomData::Weight' has a wrong offset!");

// ScriptStruct DeceiveInc.PoisonedInteractable
// 0x0010 (0x0010 - 0x0000)
struct FPoisonedInteractable final
{
public:
	class AActor*                                 InteractableActor;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToLive;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPoisonedInteractable) == 0x000008, "Wrong alignment on FPoisonedInteractable");
static_assert(sizeof(FPoisonedInteractable) == 0x000010, "Wrong size on FPoisonedInteractable");
static_assert(offsetof(FPoisonedInteractable, InteractableActor) == 0x000000, "Member 'FPoisonedInteractable::InteractableActor' has a wrong offset!");
static_assert(offsetof(FPoisonedInteractable, TimeToLive) == 0x000008, "Member 'FPoisonedInteractable::TimeToLive' has a wrong offset!");

// ScriptStruct DeceiveInc.DIPerAgentSerializedPlayerSettings
// 0x00F0 (0x00F0 - 0x0000)
struct FDIPerAgentSerializedPlayerSettings final
{
public:
	TMap<EPlayerSettingsType, int32>              IntegerSettings;                                   // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	TMap<EPlayerSettingsType, float>              FloatSettings;                                     // 0x0050(0x0050)(NativeAccessSpecifierPublic)
	TMap<EPlayerSettingsType, class FString>      StringSettings;                                    // 0x00A0(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FDIPerAgentSerializedPlayerSettings) == 0x000008, "Wrong alignment on FDIPerAgentSerializedPlayerSettings");
static_assert(sizeof(FDIPerAgentSerializedPlayerSettings) == 0x0000F0, "Wrong size on FDIPerAgentSerializedPlayerSettings");
static_assert(offsetof(FDIPerAgentSerializedPlayerSettings, IntegerSettings) == 0x000000, "Member 'FDIPerAgentSerializedPlayerSettings::IntegerSettings' has a wrong offset!");
static_assert(offsetof(FDIPerAgentSerializedPlayerSettings, FloatSettings) == 0x000050, "Member 'FDIPerAgentSerializedPlayerSettings::FloatSettings' has a wrong offset!");
static_assert(offsetof(FDIPerAgentSerializedPlayerSettings, StringSettings) == 0x0000A0, "Member 'FDIPerAgentSerializedPlayerSettings::StringSettings' has a wrong offset!");

// ScriptStruct DeceiveInc.DISerializedPlayerSettings
// 0x0158 (0x0158 - 0x0000)
struct FDISerializedPlayerSettings final
{
public:
	TMap<EPlayerSettingsType, int32>              IntegerSettings;                                   // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	TMap<EPlayerSettingsType, float>              FloatSettings;                                     // 0x0050(0x0050)(NativeAccessSpecifierPublic)
	TMap<EPlayerSettingsType, class FString>      StringSettings;                                    // 0x00A0(0x0050)(NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDIPerAgentSerializedPlayerSettings> PerAgentSettings;                                  // 0x00F0(0x0050)(NativeAccessSpecifierPublic)
	uint32                                        SettingsVersion;                                   // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SerializedLocalLanguage;                           // 0x0148(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDISerializedPlayerSettings) == 0x000008, "Wrong alignment on FDISerializedPlayerSettings");
static_assert(sizeof(FDISerializedPlayerSettings) == 0x000158, "Wrong size on FDISerializedPlayerSettings");
static_assert(offsetof(FDISerializedPlayerSettings, IntegerSettings) == 0x000000, "Member 'FDISerializedPlayerSettings::IntegerSettings' has a wrong offset!");
static_assert(offsetof(FDISerializedPlayerSettings, FloatSettings) == 0x000050, "Member 'FDISerializedPlayerSettings::FloatSettings' has a wrong offset!");
static_assert(offsetof(FDISerializedPlayerSettings, StringSettings) == 0x0000A0, "Member 'FDISerializedPlayerSettings::StringSettings' has a wrong offset!");
static_assert(offsetof(FDISerializedPlayerSettings, PerAgentSettings) == 0x0000F0, "Member 'FDISerializedPlayerSettings::PerAgentSettings' has a wrong offset!");
static_assert(offsetof(FDISerializedPlayerSettings, SettingsVersion) == 0x000140, "Member 'FDISerializedPlayerSettings::SettingsVersion' has a wrong offset!");
static_assert(offsetof(FDISerializedPlayerSettings, SerializedLocalLanguage) == 0x000148, "Member 'FDISerializedPlayerSettings::SerializedLocalLanguage' has a wrong offset!");

// ScriptStruct DeceiveInc.AATargetSegment
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FAATargetSegment final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAATargetSegment) == 0x000008, "Wrong alignment on FAATargetSegment");
static_assert(sizeof(FAATargetSegment) == 0x000018, "Wrong size on FAATargetSegment");

// ScriptStruct DeceiveInc.AATargetSegmentDefinition
// 0x0018 (0x0018 - 0x0000)
struct FAATargetSegmentDefinition final
{
public:
	TArray<struct FAASegmentPoint>                SegmentPoints;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         SegmentPriority;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAATargetSegmentDefinition) == 0x000008, "Wrong alignment on FAATargetSegmentDefinition");
static_assert(sizeof(FAATargetSegmentDefinition) == 0x000018, "Wrong size on FAATargetSegmentDefinition");
static_assert(offsetof(FAATargetSegmentDefinition, SegmentPoints) == 0x000000, "Member 'FAATargetSegmentDefinition::SegmentPoints' has a wrong offset!");
static_assert(offsetof(FAATargetSegmentDefinition, SegmentPriority) == 0x000010, "Member 'FAATargetSegmentDefinition::SegmentPriority' has a wrong offset!");

// ScriptStruct DeceiveInc.SBAimAssistTargetData_V2
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FSBAimAssistTargetData_V2
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBAimAssistTargetData_V2) == 0x000008, "Wrong alignment on FSBAimAssistTargetData_V2");
static_assert(sizeof(FSBAimAssistTargetData_V2) == 0x000030, "Wrong size on FSBAimAssistTargetData_V2");

// ScriptStruct DeceiveInc.SBAimAssistCurrentTargetData_V2
// 0x0030 (0x0060 - 0x0030)
struct FSBAimAssistCurrentTargetData_V2 final : public FSBAimAssistTargetData_V2
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBAimAssistCurrentTargetData_V2) == 0x000008, "Wrong alignment on FSBAimAssistCurrentTargetData_V2");
static_assert(sizeof(FSBAimAssistCurrentTargetData_V2) == 0x000060, "Wrong size on FSBAimAssistCurrentTargetData_V2");

// ScriptStruct DeceiveInc.SBAimAssistTargetData
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FSBAimAssistTargetData final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBAimAssistTargetData) == 0x000004, "Wrong alignment on FSBAimAssistTargetData");
static_assert(sizeof(FSBAimAssistTargetData) == 0x00001C, "Wrong size on FSBAimAssistTargetData");

// ScriptStruct DeceiveInc.SBAutoAimConfig
// 0x0020 (0x0020 - 0x0000)
struct FSBAutoAimConfig final
{
public:
	float                                         SpeedPitch;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedYaw;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoAimZoneRadius;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationDistance;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeWithoutCameraInputToEnableAutoAim;             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeWithMovementInputToEnableAutoAim;              // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOnlyWithInactiveBulletMagnetism;               // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeToBlockAfterChangeTarget;                      // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBAutoAimConfig) == 0x000004, "Wrong alignment on FSBAutoAimConfig");
static_assert(sizeof(FSBAutoAimConfig) == 0x000020, "Wrong size on FSBAutoAimConfig");
static_assert(offsetof(FSBAutoAimConfig, SpeedPitch) == 0x000000, "Member 'FSBAutoAimConfig::SpeedPitch' has a wrong offset!");
static_assert(offsetof(FSBAutoAimConfig, SpeedYaw) == 0x000004, "Member 'FSBAutoAimConfig::SpeedYaw' has a wrong offset!");
static_assert(offsetof(FSBAutoAimConfig, AutoAimZoneRadius) == 0x000008, "Member 'FSBAutoAimConfig::AutoAimZoneRadius' has a wrong offset!");
static_assert(offsetof(FSBAutoAimConfig, ActivationDistance) == 0x00000C, "Member 'FSBAutoAimConfig::ActivationDistance' has a wrong offset!");
static_assert(offsetof(FSBAutoAimConfig, TimeWithoutCameraInputToEnableAutoAim) == 0x000010, "Member 'FSBAutoAimConfig::TimeWithoutCameraInputToEnableAutoAim' has a wrong offset!");
static_assert(offsetof(FSBAutoAimConfig, TimeWithMovementInputToEnableAutoAim) == 0x000014, "Member 'FSBAutoAimConfig::TimeWithMovementInputToEnableAutoAim' has a wrong offset!");
static_assert(offsetof(FSBAutoAimConfig, bUseOnlyWithInactiveBulletMagnetism) == 0x000018, "Member 'FSBAutoAimConfig::bUseOnlyWithInactiveBulletMagnetism' has a wrong offset!");
static_assert(offsetof(FSBAutoAimConfig, TimeToBlockAfterChangeTarget) == 0x00001C, "Member 'FSBAutoAimConfig::TimeToBlockAfterChangeTarget' has a wrong offset!");

// ScriptStruct DeceiveInc.SBZonesScalingConfig
// 0x0088 (0x0088 - 0x0000)
struct FSBZonesScalingConfig final
{
public:
	struct FRuntimeFloatCurve                     ZonesScalingCurve;                                 // 0x0000(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBZonesScalingConfig) == 0x000008, "Wrong alignment on FSBZonesScalingConfig");
static_assert(sizeof(FSBZonesScalingConfig) == 0x000088, "Wrong size on FSBZonesScalingConfig");
static_assert(offsetof(FSBZonesScalingConfig, ZonesScalingCurve) == 0x000000, "Member 'FSBZonesScalingConfig::ZonesScalingCurve' has a wrong offset!");

// ScriptStruct DeceiveInc.SBBulletMagnetismZoneConfig
// 0x000C (0x000C - 0x0000)
struct FSBBulletMagnetismZoneConfig final
{
public:
	float                                         StartRadius;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimZoneRadius;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestrictToGamepad;                                // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBBulletMagnetismZoneConfig) == 0x000004, "Wrong alignment on FSBBulletMagnetismZoneConfig");
static_assert(sizeof(FSBBulletMagnetismZoneConfig) == 0x00000C, "Wrong size on FSBBulletMagnetismZoneConfig");
static_assert(offsetof(FSBBulletMagnetismZoneConfig, StartRadius) == 0x000000, "Member 'FSBBulletMagnetismZoneConfig::StartRadius' has a wrong offset!");
static_assert(offsetof(FSBBulletMagnetismZoneConfig, AimZoneRadius) == 0x000004, "Member 'FSBBulletMagnetismZoneConfig::AimZoneRadius' has a wrong offset!");
static_assert(offsetof(FSBBulletMagnetismZoneConfig, bRestrictToGamepad) == 0x000008, "Member 'FSBBulletMagnetismZoneConfig::bRestrictToGamepad' has a wrong offset!");

// ScriptStruct DeceiveInc.SBFrictionZoneConfig
// 0x0118 (0x0118 - 0x0000)
struct FSBFrictionZoneConfig final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiplier;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     FrictionMultiplierCurvePitch;                      // 0x0008(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     FrictionMultiplierCurveYaw;                        // 0x0090(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSBFrictionZoneConfig) == 0x000008, "Wrong alignment on FSBFrictionZoneConfig");
static_assert(sizeof(FSBFrictionZoneConfig) == 0x000118, "Wrong size on FSBFrictionZoneConfig");
static_assert(offsetof(FSBFrictionZoneConfig, Radius) == 0x000000, "Member 'FSBFrictionZoneConfig::Radius' has a wrong offset!");
static_assert(offsetof(FSBFrictionZoneConfig, Multiplier) == 0x000004, "Member 'FSBFrictionZoneConfig::Multiplier' has a wrong offset!");
static_assert(offsetof(FSBFrictionZoneConfig, FrictionMultiplierCurvePitch) == 0x000008, "Member 'FSBFrictionZoneConfig::FrictionMultiplierCurvePitch' has a wrong offset!");
static_assert(offsetof(FSBFrictionZoneConfig, FrictionMultiplierCurveYaw) == 0x000090, "Member 'FSBFrictionZoneConfig::FrictionMultiplierCurveYaw' has a wrong offset!");

// ScriptStruct DeceiveInc.SBSocketData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FSBSocketData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSBSocketData) == 0x000004, "Wrong alignment on FSBSocketData");
static_assert(sizeof(FSBSocketData) == 0x000010, "Wrong size on FSBSocketData");

// ScriptStruct DeceiveInc.SessionRefreshResponse
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FSessionRefreshResponse final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSessionRefreshResponse) == 0x000008, "Wrong alignment on FSessionRefreshResponse");
static_assert(sizeof(FSessionRefreshResponse) == 0x000010, "Wrong size on FSessionRefreshResponse");

// ScriptStruct DeceiveInc.SetCrossplayPreferenceRequestBody
// 0x0004 (0x0004 - 0x0000)
struct FSetCrossplayPreferenceRequestBody final
{
public:
	int32                                         CrossplayCode;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSetCrossplayPreferenceRequestBody) == 0x000004, "Wrong alignment on FSetCrossplayPreferenceRequestBody");
static_assert(sizeof(FSetCrossplayPreferenceRequestBody) == 0x000004, "Wrong size on FSetCrossplayPreferenceRequestBody");
static_assert(offsetof(FSetCrossplayPreferenceRequestBody, CrossplayCode) == 0x000000, "Member 'FSetCrossplayPreferenceRequestBody::CrossplayCode' has a wrong offset!");

// ScriptStruct DeceiveInc.SignAgreementRequestBody
// 0x0010 (0x0010 - 0x0000)
struct FSignAgreementRequestBody final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSignAgreementRequestBody) == 0x000008, "Wrong alignment on FSignAgreementRequestBody");
static_assert(sizeof(FSignAgreementRequestBody) == 0x000010, "Wrong size on FSignAgreementRequestBody");
static_assert(offsetof(FSignAgreementRequestBody, Name) == 0x000000, "Member 'FSignAgreementRequestBody::Name' has a wrong offset!");

// ScriptStruct DeceiveInc.SingleUserReplicationData
// 0x0010 (0x0010 - 0x0000)
struct FSingleUserReplicationData final
{
public:
	uint32                                        FactionID;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSingleUserReplicationData) == 0x000008, "Wrong alignment on FSingleUserReplicationData");
static_assert(sizeof(FSingleUserReplicationData) == 0x000010, "Wrong size on FSingleUserReplicationData");
static_assert(offsetof(FSingleUserReplicationData, FactionID) == 0x000000, "Member 'FSingleUserReplicationData::FactionID' has a wrong offset!");
static_assert(offsetof(FSingleUserReplicationData, Actor) == 0x000008, "Member 'FSingleUserReplicationData::Actor' has a wrong offset!");

// ScriptStruct DeceiveInc.SAAQueryData
// 0x0018 (0x0018 - 0x0000)
struct FSAAQueryData final
{
public:
	struct FVector                                Pos;                                               // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSAAQueryData) == 0x000004, "Wrong alignment on FSAAQueryData");
static_assert(sizeof(FSAAQueryData) == 0x000018, "Wrong size on FSAAQueryData");
static_assert(offsetof(FSAAQueryData, Pos) == 0x000000, "Member 'FSAAQueryData::Pos' has a wrong offset!");
static_assert(offsetof(FSAAQueryData, Normal) == 0x00000C, "Member 'FSAAQueryData::Normal' has a wrong offset!");

// ScriptStruct DeceiveInc.SprayChargeLevel
// 0x000C (0x000C - 0x0000)
struct FSprayChargeLevel final
{
public:
	float                                         ChargeTime;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProjectileToShoot;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayBetweenShotsPercentFactor;                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSprayChargeLevel) == 0x000004, "Wrong alignment on FSprayChargeLevel");
static_assert(sizeof(FSprayChargeLevel) == 0x00000C, "Wrong size on FSprayChargeLevel");
static_assert(offsetof(FSprayChargeLevel, ChargeTime) == 0x000000, "Member 'FSprayChargeLevel::ChargeTime' has a wrong offset!");
static_assert(offsetof(FSprayChargeLevel, ProjectileToShoot) == 0x000004, "Member 'FSprayChargeLevel::ProjectileToShoot' has a wrong offset!");
static_assert(offsetof(FSprayChargeLevel, DelayBetweenShotsPercentFactor) == 0x000008, "Member 'FSprayChargeLevel::DelayBetweenShotsPercentFactor' has a wrong offset!");

// ScriptStruct DeceiveInc.CoverData
// 0x0010 (0x0010 - 0x0000)
struct FCoverData final
{
public:
	TArray<class AActor*>                         AffectingSource;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoverData) == 0x000008, "Wrong alignment on FCoverData");
static_assert(sizeof(FCoverData) == 0x000010, "Wrong size on FCoverData");
static_assert(offsetof(FCoverData, AffectingSource) == 0x000000, "Member 'FCoverData::AffectingSource' has a wrong offset!");

// ScriptStruct DeceiveInc.BlockRunFlagInfo
// 0x0018 (0x0018 - 0x0000)
struct FBlockRunFlagInfo final
{
public:
	TArray<class AActor*>                         Sources;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Cpt;                                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBlockRunFlagInfo) == 0x000008, "Wrong alignment on FBlockRunFlagInfo");
static_assert(sizeof(FBlockRunFlagInfo) == 0x000018, "Wrong size on FBlockRunFlagInfo");
static_assert(offsetof(FBlockRunFlagInfo, Sources) == 0x000000, "Member 'FBlockRunFlagInfo::Sources' has a wrong offset!");
static_assert(offsetof(FBlockRunFlagInfo, Cpt) == 0x000010, "Member 'FBlockRunFlagInfo::Cpt' has a wrong offset!");

// ScriptStruct DeceiveInc.ResultScreenPhaseData
// 0x0008 (0x0058 - 0x0050)
struct FResultScreenPhaseData final : public FSpyGamePhaseData
{
public:
	int32                                         DefaultPhaseDuration;                              // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FResultScreenPhaseData) == 0x000008, "Wrong alignment on FResultScreenPhaseData");
static_assert(sizeof(FResultScreenPhaseData) == 0x000058, "Wrong size on FResultScreenPhaseData");
static_assert(offsetof(FResultScreenPhaseData, DefaultPhaseDuration) == 0x000050, "Member 'FResultScreenPhaseData::DefaultPhaseDuration' has a wrong offset!");

// ScriptStruct DeceiveInc.ExtractionArrivedPhaseData
// 0x0070 (0x00C0 - 0x0050)
struct FExtractionArrivedPhaseData final : public FSpyGamePhaseData
{
public:
	class FText                                   ObjectiveDescCarrier;                              // 0x0050(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ObjectiveDescNonCarrier;                           // 0x0068(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ObjectiveDescNonCarrierTeammate;                   // 0x0080(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ObjectivePromptText;                               // 0x0098(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         DefaultPhaseDuration;                              // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OvertimeDuration;                                  // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExfilRecallDelay;                                  // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExfilRecallDuration;                               // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExtractionArrivedPhaseData) == 0x000008, "Wrong alignment on FExtractionArrivedPhaseData");
static_assert(sizeof(FExtractionArrivedPhaseData) == 0x0000C0, "Wrong size on FExtractionArrivedPhaseData");
static_assert(offsetof(FExtractionArrivedPhaseData, ObjectiveDescCarrier) == 0x000050, "Member 'FExtractionArrivedPhaseData::ObjectiveDescCarrier' has a wrong offset!");
static_assert(offsetof(FExtractionArrivedPhaseData, ObjectiveDescNonCarrier) == 0x000068, "Member 'FExtractionArrivedPhaseData::ObjectiveDescNonCarrier' has a wrong offset!");
static_assert(offsetof(FExtractionArrivedPhaseData, ObjectiveDescNonCarrierTeammate) == 0x000080, "Member 'FExtractionArrivedPhaseData::ObjectiveDescNonCarrierTeammate' has a wrong offset!");
static_assert(offsetof(FExtractionArrivedPhaseData, ObjectivePromptText) == 0x000098, "Member 'FExtractionArrivedPhaseData::ObjectivePromptText' has a wrong offset!");
static_assert(offsetof(FExtractionArrivedPhaseData, DefaultPhaseDuration) == 0x0000B0, "Member 'FExtractionArrivedPhaseData::DefaultPhaseDuration' has a wrong offset!");
static_assert(offsetof(FExtractionArrivedPhaseData, OvertimeDuration) == 0x0000B4, "Member 'FExtractionArrivedPhaseData::OvertimeDuration' has a wrong offset!");
static_assert(offsetof(FExtractionArrivedPhaseData, ExfilRecallDelay) == 0x0000B8, "Member 'FExtractionArrivedPhaseData::ExfilRecallDelay' has a wrong offset!");
static_assert(offsetof(FExtractionArrivedPhaseData, ExfilRecallDuration) == 0x0000BC, "Member 'FExtractionArrivedPhaseData::ExfilRecallDuration' has a wrong offset!");

// ScriptStruct DeceiveInc.VaultLockedPhaseData
// 0x0048 (0x0098 - 0x0050)
struct FVaultLockedPhaseData final : public FSpyGamePhaseData
{
public:
	int32                                         DefaultPhaseDuration;                              // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CriticalTimeLeft;                                  // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CriticalTimeAnnoucementText;                       // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EAnnouncementType                             CriticalTimeAnnoucementType;                       // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CriticalTimeAnnoucementPriority;                   // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalTimeAnnoucementDuration;                   // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ObjectiveDescTxt;                                  // 0x0080(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVaultLockedPhaseData) == 0x000008, "Wrong alignment on FVaultLockedPhaseData");
static_assert(sizeof(FVaultLockedPhaseData) == 0x000098, "Wrong size on FVaultLockedPhaseData");
static_assert(offsetof(FVaultLockedPhaseData, DefaultPhaseDuration) == 0x000050, "Member 'FVaultLockedPhaseData::DefaultPhaseDuration' has a wrong offset!");
static_assert(offsetof(FVaultLockedPhaseData, CriticalTimeLeft) == 0x000054, "Member 'FVaultLockedPhaseData::CriticalTimeLeft' has a wrong offset!");
static_assert(offsetof(FVaultLockedPhaseData, CriticalTimeAnnoucementText) == 0x000058, "Member 'FVaultLockedPhaseData::CriticalTimeAnnoucementText' has a wrong offset!");
static_assert(offsetof(FVaultLockedPhaseData, CriticalTimeAnnoucementType) == 0x000070, "Member 'FVaultLockedPhaseData::CriticalTimeAnnoucementType' has a wrong offset!");
static_assert(offsetof(FVaultLockedPhaseData, CriticalTimeAnnoucementPriority) == 0x000074, "Member 'FVaultLockedPhaseData::CriticalTimeAnnoucementPriority' has a wrong offset!");
static_assert(offsetof(FVaultLockedPhaseData, CriticalTimeAnnoucementDuration) == 0x000078, "Member 'FVaultLockedPhaseData::CriticalTimeAnnoucementDuration' has a wrong offset!");
static_assert(offsetof(FVaultLockedPhaseData, ObjectiveDescTxt) == 0x000080, "Member 'FVaultLockedPhaseData::ObjectiveDescTxt' has a wrong offset!");

// ScriptStruct DeceiveInc.PingData
// 0x0058 (0x0058 - 0x0000)
struct FPingData final
{
public:
	class AActor*                                 PingedActor;                                       // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCriticalPing;                                     // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFriendly;                                       // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPingInfo                              PingInfo;                                          // 0x0010(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         Fake;                                              // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPingData) == 0x000008, "Wrong alignment on FPingData");
static_assert(sizeof(FPingData) == 0x000058, "Wrong size on FPingData");
static_assert(offsetof(FPingData, PingedActor) == 0x000000, "Member 'FPingData::PingedActor' has a wrong offset!");
static_assert(offsetof(FPingData, bCriticalPing) == 0x000008, "Member 'FPingData::bCriticalPing' has a wrong offset!");
static_assert(offsetof(FPingData, bIsFriendly) == 0x000009, "Member 'FPingData::bIsFriendly' has a wrong offset!");
static_assert(offsetof(FPingData, PingInfo) == 0x000010, "Member 'FPingData::PingInfo' has a wrong offset!");
static_assert(offsetof(FPingData, Fake) == 0x000050, "Member 'FPingData::Fake' has a wrong offset!");

// ScriptStruct DeceiveInc.SandboxSettingsRequest
// 0x0080 (0x0080 - 0x0000)
struct FSandboxSettingsRequest final
{
public:
	bool                                          DisableProgression;                                // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FillWithBots;                                      // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 NPCPopulation;                                     // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FObjectToSpawnCount>            ObjectsToSpawnCountOverride;                       // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FHeatSetupData                         HeatSettings;                                      // 0x0028(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         BotsDifficulty;                                    // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BotsAmount;                                        // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSandboxSettingsRequest) == 0x000008, "Wrong alignment on FSandboxSettingsRequest");
static_assert(sizeof(FSandboxSettingsRequest) == 0x000080, "Wrong size on FSandboxSettingsRequest");
static_assert(offsetof(FSandboxSettingsRequest, DisableProgression) == 0x000000, "Member 'FSandboxSettingsRequest::DisableProgression' has a wrong offset!");
static_assert(offsetof(FSandboxSettingsRequest, FillWithBots) == 0x000001, "Member 'FSandboxSettingsRequest::FillWithBots' has a wrong offset!");
static_assert(offsetof(FSandboxSettingsRequest, NPCPopulation) == 0x000008, "Member 'FSandboxSettingsRequest::NPCPopulation' has a wrong offset!");
static_assert(offsetof(FSandboxSettingsRequest, ObjectsToSpawnCountOverride) == 0x000018, "Member 'FSandboxSettingsRequest::ObjectsToSpawnCountOverride' has a wrong offset!");
static_assert(offsetof(FSandboxSettingsRequest, HeatSettings) == 0x000028, "Member 'FSandboxSettingsRequest::HeatSettings' has a wrong offset!");
static_assert(offsetof(FSandboxSettingsRequest, BotsDifficulty) == 0x000078, "Member 'FSandboxSettingsRequest::BotsDifficulty' has a wrong offset!");
static_assert(offsetof(FSandboxSettingsRequest, BotsAmount) == 0x00007C, "Member 'FSandboxSettingsRequest::BotsAmount' has a wrong offset!");

// ScriptStruct DeceiveInc.StartMatchmakingRequestBody
// 0x00E0 (0x00E0 - 0x0000)
struct FStartMatchmakingRequestBody final
{
public:
	class FString                                 ClientVersion;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameMode;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSandboxSettingsRequest                SandboxSettings;                                   // 0x0020(0x0080)(NativeAccessSpecifierPublic)
	class FString                                 MapCode;                                           // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDIPrivateLobbyFactonInfo>      Factions;                                          // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Region;                                            // 0x00C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Tokens;                                            // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStartMatchmakingRequestBody) == 0x000008, "Wrong alignment on FStartMatchmakingRequestBody");
static_assert(sizeof(FStartMatchmakingRequestBody) == 0x0000E0, "Wrong size on FStartMatchmakingRequestBody");
static_assert(offsetof(FStartMatchmakingRequestBody, ClientVersion) == 0x000000, "Member 'FStartMatchmakingRequestBody::ClientVersion' has a wrong offset!");
static_assert(offsetof(FStartMatchmakingRequestBody, GameMode) == 0x000010, "Member 'FStartMatchmakingRequestBody::GameMode' has a wrong offset!");
static_assert(offsetof(FStartMatchmakingRequestBody, SandboxSettings) == 0x000020, "Member 'FStartMatchmakingRequestBody::SandboxSettings' has a wrong offset!");
static_assert(offsetof(FStartMatchmakingRequestBody, MapCode) == 0x0000A0, "Member 'FStartMatchmakingRequestBody::MapCode' has a wrong offset!");
static_assert(offsetof(FStartMatchmakingRequestBody, Factions) == 0x0000B0, "Member 'FStartMatchmakingRequestBody::Factions' has a wrong offset!");
static_assert(offsetof(FStartMatchmakingRequestBody, Region) == 0x0000C0, "Member 'FStartMatchmakingRequestBody::Region' has a wrong offset!");
static_assert(offsetof(FStartMatchmakingRequestBody, Tokens) == 0x0000D0, "Member 'FStartMatchmakingRequestBody::Tokens' has a wrong offset!");

// ScriptStruct DeceiveInc.StartMatchmakingResponse
// 0x0010 (0x0010 - 0x0000)
struct FStartMatchmakingResponse final
{
public:
	class FString                                 TicketId;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStartMatchmakingResponse) == 0x000008, "Wrong alignment on FStartMatchmakingResponse");
static_assert(sizeof(FStartMatchmakingResponse) == 0x000010, "Wrong size on FStartMatchmakingResponse");
static_assert(offsetof(FStartMatchmakingResponse, TicketId) == 0x000000, "Member 'FStartMatchmakingResponse::TicketId' has a wrong offset!");

// ScriptStruct DeceiveInc.StartSteamTransactionRequestBody
// 0x0004 (0x0004 - 0x0000)
struct FStartSteamTransactionRequestBody final
{
public:
	int32                                         SteamShopItemId;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStartSteamTransactionRequestBody) == 0x000004, "Wrong alignment on FStartSteamTransactionRequestBody");
static_assert(sizeof(FStartSteamTransactionRequestBody) == 0x000004, "Wrong size on FStartSteamTransactionRequestBody");
static_assert(offsetof(FStartSteamTransactionRequestBody, SteamShopItemId) == 0x000000, "Member 'FStartSteamTransactionRequestBody::SteamShopItemId' has a wrong offset!");

// ScriptStruct DeceiveInc.SteamLoginRequestBody
// 0x0030 (0x0030 - 0x0000)
struct FSteamLoginRequestBody final
{
public:
	class FString                                 SteamTicket;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccelbyteToken;                                    // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ProfileVisibility;                                 // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSteamLoginRequestBody) == 0x000008, "Wrong alignment on FSteamLoginRequestBody");
static_assert(sizeof(FSteamLoginRequestBody) == 0x000030, "Wrong size on FSteamLoginRequestBody");
static_assert(offsetof(FSteamLoginRequestBody, SteamTicket) == 0x000000, "Member 'FSteamLoginRequestBody::SteamTicket' has a wrong offset!");
static_assert(offsetof(FSteamLoginRequestBody, AccelbyteToken) == 0x000010, "Member 'FSteamLoginRequestBody::AccelbyteToken' has a wrong offset!");
static_assert(offsetof(FSteamLoginRequestBody, ProfileVisibility) == 0x000020, "Member 'FSteamLoginRequestBody::ProfileVisibility' has a wrong offset!");

// ScriptStruct DeceiveInc.SwayAxisParams
// 0x0010 (0x0010 - 0x0000)
struct FSwayAxisParams final
{
public:
	float                                         InputAccel;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PingPongSpeed;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StabilizeTimeFactor;                               // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFactor;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSwayAxisParams) == 0x000004, "Wrong alignment on FSwayAxisParams");
static_assert(sizeof(FSwayAxisParams) == 0x000010, "Wrong size on FSwayAxisParams");
static_assert(offsetof(FSwayAxisParams, InputAccel) == 0x000000, "Member 'FSwayAxisParams::InputAccel' has a wrong offset!");
static_assert(offsetof(FSwayAxisParams, PingPongSpeed) == 0x000004, "Member 'FSwayAxisParams::PingPongSpeed' has a wrong offset!");
static_assert(offsetof(FSwayAxisParams, StabilizeTimeFactor) == 0x000008, "Member 'FSwayAxisParams::StabilizeTimeFactor' has a wrong offset!");
static_assert(offsetof(FSwayAxisParams, MaxFactor) == 0x00000C, "Member 'FSwayAxisParams::MaxFactor' has a wrong offset!");

// ScriptStruct DeceiveInc.SummaryData
// 0x0060 (0x0060 - 0x0000)
struct FSummaryData final
{
public:
	class FString                                 MapName;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SessionID;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchResult;                                       // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         PlayerInfos;                                       // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         MatchPhaseInfos;                                   // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MinFPS;                                            // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFPS;                                            // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAverageFPS;                                     // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAverageFPS;                                     // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSummaryData) == 0x000008, "Wrong alignment on FSummaryData");
static_assert(sizeof(FSummaryData) == 0x000060, "Wrong size on FSummaryData");
static_assert(offsetof(FSummaryData, MapName) == 0x000000, "Member 'FSummaryData::MapName' has a wrong offset!");
static_assert(offsetof(FSummaryData, SessionID) == 0x000010, "Member 'FSummaryData::SessionID' has a wrong offset!");
static_assert(offsetof(FSummaryData, MatchResult) == 0x000020, "Member 'FSummaryData::MatchResult' has a wrong offset!");
static_assert(offsetof(FSummaryData, PlayerInfos) == 0x000030, "Member 'FSummaryData::PlayerInfos' has a wrong offset!");
static_assert(offsetof(FSummaryData, MatchPhaseInfos) == 0x000040, "Member 'FSummaryData::MatchPhaseInfos' has a wrong offset!");
static_assert(offsetof(FSummaryData, MinFPS) == 0x000050, "Member 'FSummaryData::MinFPS' has a wrong offset!");
static_assert(offsetof(FSummaryData, MaxFPS) == 0x000054, "Member 'FSummaryData::MaxFPS' has a wrong offset!");
static_assert(offsetof(FSummaryData, MinAverageFPS) == 0x000058, "Member 'FSummaryData::MinAverageFPS' has a wrong offset!");
static_assert(offsetof(FSummaryData, MaxAverageFPS) == 0x00005C, "Member 'FSummaryData::MaxAverageFPS' has a wrong offset!");

// ScriptStruct DeceiveInc.RosterEntry
// 0x0050 (0x0050 - 0x0000)
struct FRosterEntry final
{
public:
	class ADIPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x48];                                       // 0x0008(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRosterEntry) == 0x000008, "Wrong alignment on FRosterEntry");
static_assert(sizeof(FRosterEntry) == 0x000050, "Wrong size on FRosterEntry");
static_assert(offsetof(FRosterEntry, PlayerState) == 0x000000, "Member 'FRosterEntry::PlayerState' has a wrong offset!");

// ScriptStruct DeceiveInc.SwitchStateCollection
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FSwitchStateCollection final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSwitchStateCollection) == 0x000008, "Wrong alignment on FSwitchStateCollection");
static_assert(sizeof(FSwitchStateCollection) == 0x000010, "Wrong size on FSwitchStateCollection");

// ScriptStruct DeceiveInc.SwitchState
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FSwitchState final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSwitchState) == 0x000004, "Wrong alignment on FSwitchState");
static_assert(sizeof(FSwitchState) == 0x00001C, "Wrong size on FSwitchState");

// ScriptStruct DeceiveInc.AdditionalWrapMaterial
// 0x0010 (0x0010 - 0x0000)
struct FAdditionalWrapMaterial final
{
public:
	TArray<TSoftObjectPtr<class UMaterialInstance>> AdditionnalMaterial;                               // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAdditionalWrapMaterial) == 0x000008, "Wrong alignment on FAdditionalWrapMaterial");
static_assert(sizeof(FAdditionalWrapMaterial) == 0x000010, "Wrong size on FAdditionalWrapMaterial");
static_assert(offsetof(FAdditionalWrapMaterial, AdditionnalMaterial) == 0x000000, "Member 'FAdditionalWrapMaterial::AdditionnalMaterial' has a wrong offset!");

// ScriptStruct DeceiveInc.ReplicatedPlayerUnlocked
// 0x0008 (0x0008 - 0x0000)
struct FReplicatedPlayerUnlocked final
{
public:
	int32                                         PlayerIndex;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnlocked;                                         // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplicatedPlayerUnlocked) == 0x000004, "Wrong alignment on FReplicatedPlayerUnlocked");
static_assert(sizeof(FReplicatedPlayerUnlocked) == 0x000008, "Wrong size on FReplicatedPlayerUnlocked");
static_assert(offsetof(FReplicatedPlayerUnlocked, PlayerIndex) == 0x000000, "Member 'FReplicatedPlayerUnlocked::PlayerIndex' has a wrong offset!");
static_assert(offsetof(FReplicatedPlayerUnlocked, bUnlocked) == 0x000004, "Member 'FReplicatedPlayerUnlocked::bUnlocked' has a wrong offset!");

// ScriptStruct DeceiveInc.EffectInfo
// 0x0020 (0x0020 - 0x0000)
struct FEffectInfo final
{
public:
	bool                                          EffectActive;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EffectFading;                                      // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 EffectVictim;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 EffectInstigator;                                  // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectDuration;                                    // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EffectInstigatorFaction;                           // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffectInfo) == 0x000008, "Wrong alignment on FEffectInfo");
static_assert(sizeof(FEffectInfo) == 0x000020, "Wrong size on FEffectInfo");
static_assert(offsetof(FEffectInfo, EffectActive) == 0x000000, "Member 'FEffectInfo::EffectActive' has a wrong offset!");
static_assert(offsetof(FEffectInfo, EffectFading) == 0x000001, "Member 'FEffectInfo::EffectFading' has a wrong offset!");
static_assert(offsetof(FEffectInfo, EffectVictim) == 0x000008, "Member 'FEffectInfo::EffectVictim' has a wrong offset!");
static_assert(offsetof(FEffectInfo, EffectInstigator) == 0x000010, "Member 'FEffectInfo::EffectInstigator' has a wrong offset!");
static_assert(offsetof(FEffectInfo, EffectDuration) == 0x000018, "Member 'FEffectInfo::EffectDuration' has a wrong offset!");
static_assert(offsetof(FEffectInfo, EffectInstigatorFaction) == 0x00001C, "Member 'FEffectInfo::EffectInstigatorFaction' has a wrong offset!");

// ScriptStruct DeceiveInc.MimicVictimInfo
// 0x0030 (0x0030 - 0x0000)
struct FMimicVictimInfo final
{
public:
	class AActor*                                 MimicActor;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeHitOnMimic;                                // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitNormalOnMimic;                                  // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MimicRotation;                                     // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMimicVictimInfo) == 0x000008, "Wrong alignment on FMimicVictimInfo");
static_assert(sizeof(FMimicVictimInfo) == 0x000030, "Wrong size on FMimicVictimInfo");
static_assert(offsetof(FMimicVictimInfo, MimicActor) == 0x000000, "Member 'FMimicVictimInfo::MimicActor' has a wrong offset!");
static_assert(offsetof(FMimicVictimInfo, RelativeHitOnMimic) == 0x000008, "Member 'FMimicVictimInfo::RelativeHitOnMimic' has a wrong offset!");
static_assert(offsetof(FMimicVictimInfo, HitNormalOnMimic) == 0x000014, "Member 'FMimicVictimInfo::HitNormalOnMimic' has a wrong offset!");
static_assert(offsetof(FMimicVictimInfo, MimicRotation) == 0x000020, "Member 'FMimicVictimInfo::MimicRotation' has a wrong offset!");

// ScriptStruct DeceiveInc.VoicechatMemberData
// 0x0030 (0x0030 - 0x0000)
struct FVoicechatMemberData final
{
public:
	class FString                                 ChatId;                                            // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChannelName;                                       // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTalking;                                          // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UVoicechatMemberWidget*                 ActiveWidget;                                      // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVoicechatMemberData) == 0x000008, "Wrong alignment on FVoicechatMemberData");
static_assert(sizeof(FVoicechatMemberData) == 0x000030, "Wrong size on FVoicechatMemberData");
static_assert(offsetof(FVoicechatMemberData, ChatId) == 0x000000, "Member 'FVoicechatMemberData::ChatId' has a wrong offset!");
static_assert(offsetof(FVoicechatMemberData, ChannelName) == 0x000010, "Member 'FVoicechatMemberData::ChannelName' has a wrong offset!");
static_assert(offsetof(FVoicechatMemberData, bTalking) == 0x000020, "Member 'FVoicechatMemberData::bTalking' has a wrong offset!");
static_assert(offsetof(FVoicechatMemberData, ActiveWidget) == 0x000028, "Member 'FVoicechatMemberData::ActiveWidget' has a wrong offset!");

// ScriptStruct DeceiveInc.SprayShotImpact
// 0x0020 (0x0020 - 0x0000)
struct FSprayShotImpact final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPoint;                                       // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactNormal;                                      // 0x0014(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSprayShotImpact) == 0x000008, "Wrong alignment on FSprayShotImpact");
static_assert(sizeof(FSprayShotImpact) == 0x000020, "Wrong size on FSprayShotImpact");
static_assert(offsetof(FSprayShotImpact, Victim) == 0x000000, "Member 'FSprayShotImpact::Victim' has a wrong offset!");
static_assert(offsetof(FSprayShotImpact, ImpactPoint) == 0x000008, "Member 'FSprayShotImpact::ImpactPoint' has a wrong offset!");
static_assert(offsetof(FSprayShotImpact, ImpactNormal) == 0x000014, "Member 'FSprayShotImpact::ImpactNormal' has a wrong offset!");

// ScriptStruct DeceiveInc.WebStreamedAssetDefinition
// 0x0018 (0x0018 - 0x0000)
struct FWebStreamedAssetDefinition final
{
public:
	class FString                                 URL;                                               // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWebStreamedAssetType                         AssetType;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWebStreamedAssetDefinition) == 0x000008, "Wrong alignment on FWebStreamedAssetDefinition");
static_assert(sizeof(FWebStreamedAssetDefinition) == 0x000018, "Wrong size on FWebStreamedAssetDefinition");
static_assert(offsetof(FWebStreamedAssetDefinition, URL) == 0x000000, "Member 'FWebStreamedAssetDefinition::URL' has a wrong offset!");
static_assert(offsetof(FWebStreamedAssetDefinition, AssetType) == 0x000010, "Member 'FWebStreamedAssetDefinition::AssetType' has a wrong offset!");

// ScriptStruct DeceiveInc.XiuVictimData
// 0x0018 (0x0018 - 0x0000)
struct FXiuVictimData final
{
public:
	class ASpy*                                   Victim;                                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVictimEffect*                          VictimEffect;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVictimLowHealth;                                // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FXiuVictimData) == 0x000008, "Wrong alignment on FXiuVictimData");
static_assert(sizeof(FXiuVictimData) == 0x000018, "Wrong size on FXiuVictimData");
static_assert(offsetof(FXiuVictimData, Victim) == 0x000000, "Member 'FXiuVictimData::Victim' has a wrong offset!");
static_assert(offsetof(FXiuVictimData, VictimEffect) == 0x000008, "Member 'FXiuVictimData::VictimEffect' has a wrong offset!");
static_assert(offsetof(FXiuVictimData, bIsVictimLowHealth) == 0x000010, "Member 'FXiuVictimData::bIsVictimLowHealth' has a wrong offset!");

// ScriptStruct DeceiveInc.ReplicatedPlayerPosition
// 0x0018 (0x0018 - 0x0000)
struct FReplicatedPlayerPosition final
{
public:
	struct FVector_NetQuantize                    Location;                                          // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    FowardVector;                                      // 0x000C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplicatedPlayerPosition) == 0x000004, "Wrong alignment on FReplicatedPlayerPosition");
static_assert(sizeof(FReplicatedPlayerPosition) == 0x000018, "Wrong size on FReplicatedPlayerPosition");
static_assert(offsetof(FReplicatedPlayerPosition, Location) == 0x000000, "Member 'FReplicatedPlayerPosition::Location' has a wrong offset!");
static_assert(offsetof(FReplicatedPlayerPosition, FowardVector) == 0x00000C, "Member 'FReplicatedPlayerPosition::FowardVector' has a wrong offset!");

// ScriptStruct DeceiveInc.FormulaOperation
// 0x0008 (0x0008 - 0x0000)
struct FFormulaOperation final
{
public:
	EFormulaOperationType                         OperationType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFormulaOperation) == 0x000004, "Wrong alignment on FFormulaOperation");
static_assert(sizeof(FFormulaOperation) == 0x000008, "Wrong size on FFormulaOperation");
static_assert(offsetof(FFormulaOperation, OperationType) == 0x000000, "Member 'FFormulaOperation::OperationType' has a wrong offset!");
static_assert(offsetof(FFormulaOperation, Value) == 0x000004, "Member 'FFormulaOperation::Value' has a wrong offset!");

// ScriptStruct DeceiveInc.Formula
// 0x0010 (0x0010 - 0x0000)
struct FFormula final
{
public:
	int32                                         LevelStart;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelEnd;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFormulaOperation                      FormulaOperation;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFormula) == 0x000004, "Wrong alignment on FFormula");
static_assert(sizeof(FFormula) == 0x000010, "Wrong size on FFormula");
static_assert(offsetof(FFormula, LevelStart) == 0x000000, "Member 'FFormula::LevelStart' has a wrong offset!");
static_assert(offsetof(FFormula, LevelEnd) == 0x000004, "Member 'FFormula::LevelEnd' has a wrong offset!");
static_assert(offsetof(FFormula, FormulaOperation) == 0x000008, "Member 'FFormula::FormulaOperation' has a wrong offset!");

}

