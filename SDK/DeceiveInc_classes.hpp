#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DeceiveInc

#include "Basic.hpp"

#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "SlateCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "DeceiveInc_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "NavigationSystem_classes.hpp"
#include "AccelByteUe4Sdk_structs.hpp"
#include "EnhancedInput_classes.hpp"


namespace SDK
{

// Class DeceiveInc.BotAction
// 0x0020 (0x0048 - 0x0028)
class UBotAction : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnBotActionEnd;                                    // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotAction">();
	}
	static class UBotAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotAction>();
	}
};
static_assert(alignof(UBotAction) == 0x000008, "Wrong alignment on UBotAction");
static_assert(sizeof(UBotAction) == 0x000048, "Wrong size on UBotAction");
static_assert(offsetof(UBotAction, OnBotActionEnd) == 0x000028, "Member 'UBotAction::OnBotActionEnd' has a wrong offset!");

// Class DeceiveInc.BotActionInteract
// 0x0070 (0x00B8 - 0x0048)
class UBotActionInteract final : public UBotAction
{
public:
	uint8                                         Pad_48[0x70];                                      // 0x0048(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLocaInteractionCompleted(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void OnReceiveMoveCompleted(const struct FAIRequestID& RequestId, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotActionInteract">();
	}
	static class UBotActionInteract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotActionInteract>();
	}
};
static_assert(alignof(UBotActionInteract) == 0x000008, "Wrong alignment on UBotActionInteract");
static_assert(sizeof(UBotActionInteract) == 0x0000B8, "Wrong size on UBotActionInteract");

// Class DeceiveInc.SweetAimAssistInputModifier
// 0x0010 (0x0038 - 0x0028)
class USweetAimAssistInputModifier : public UInputModifier
{
public:
	uint8                                         Pad_28[0x4];                                       // 0x0028(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InputThreshold;                                    // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeThreshold;                                     // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SweetAimAssistInputModifier">();
	}
	static class USweetAimAssistInputModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<USweetAimAssistInputModifier>();
	}
};
static_assert(alignof(USweetAimAssistInputModifier) == 0x000008, "Wrong alignment on USweetAimAssistInputModifier");
static_assert(sizeof(USweetAimAssistInputModifier) == 0x000038, "Wrong size on USweetAimAssistInputModifier");
static_assert(offsetof(USweetAimAssistInputModifier, InputThreshold) == 0x00002C, "Member 'USweetAimAssistInputModifier::InputThreshold' has a wrong offset!");
static_assert(offsetof(USweetAimAssistInputModifier, TimeThreshold) == 0x000030, "Member 'USweetAimAssistInputModifier::TimeThreshold' has a wrong offset!");

// Class DeceiveInc.DIDedicatedServerManager
// 0x00D8 (0x0100 - 0x0028)
class UDIDedicatedServerManager : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                WorldContext;                                      // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0xC0];                                      // 0x0040(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIDedicatedServerManager">();
	}
	static class UDIDedicatedServerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIDedicatedServerManager>();
	}
};
static_assert(alignof(UDIDedicatedServerManager) == 0x000008, "Wrong alignment on UDIDedicatedServerManager");
static_assert(sizeof(UDIDedicatedServerManager) == 0x000100, "Wrong size on UDIDedicatedServerManager");
static_assert(offsetof(UDIDedicatedServerManager, WorldContext) == 0x000038, "Member 'UDIDedicatedServerManager::WorldContext' has a wrong offset!");

// Class DeceiveInc.BotActionMoveTo
// 0x0018 (0x0060 - 0x0048)
class UBotActionMoveTo final : public UBotAction
{
public:
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReceiveMoveCompleted(const struct FAIRequestID& RequestId, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotActionMoveTo">();
	}
	static class UBotActionMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotActionMoveTo>();
	}
};
static_assert(alignof(UBotActionMoveTo) == 0x000008, "Wrong alignment on UBotActionMoveTo");
static_assert(sizeof(UBotActionMoveTo) == 0x000060, "Wrong size on UBotActionMoveTo");

// Class DeceiveInc.DeceiveIncCheatManager
// 0x0000 (0x0088 - 0x0088)
class UDeceiveIncCheatManager : public UCheatManager
{
public:
	void CheatEndGame();
	void CheatEndGameSrv();
	void CheatIgnorePrivateLobbyMinimumPlayerCount();
	void CheatMenuCatalogueTogglePageLock();
	void CheatMenuEnableFreeLootBundle(int32 ItemId0, int32 ItemId1, int32 ItemId2);
	void CheatMenuEnableInventory();
	void CheatMenuGiveFakeLootBundles(int32 Amount);
	void CheatSetXpTypeLvlAndXp(const class FString& XpType, int32 Lvl, int32 XpAmount, EXpProgressionType ProgressionType);
	void CheatShowcollisionPatch(bool bShow);
	void CheatTestSpawnPlayers(int32 NbTeams, int32 NbPlayersPerTeam);
	void CheatToggleDebugInputAccelerator();
	void CheatToggleDebugWidgetScale();
	void CheatTriggerShaderPrecompile(bool bShowMenu);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeceiveIncCheatManager">();
	}
	static class UDeceiveIncCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeceiveIncCheatManager>();
	}
};
static_assert(alignof(UDeceiveIncCheatManager) == 0x000008, "Wrong alignment on UDeceiveIncCheatManager");
static_assert(sizeof(UDeceiveIncCheatManager) == 0x000088, "Wrong size on UDeceiveIncCheatManager");

// Class DeceiveInc.AccelByteDedicatedServerManager
// 0x02F0 (0x03F0 - 0x0100)
class alignas(0x10) UAccelByteDedicatedServerManager final : public UDIDedicatedServerManager
{
public:
	uint8                                         Pad_100[0xA0];                                     // 0x0100(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerController*>              PendingValidationBeforeMatchUpdate;                // 0x01A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B0[0x240];                                    // 0x01B0(0x0240)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AccelByteDedicatedServerManager">();
	}
	static class UAccelByteDedicatedServerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAccelByteDedicatedServerManager>();
	}
};
static_assert(alignof(UAccelByteDedicatedServerManager) == 0x000010, "Wrong alignment on UAccelByteDedicatedServerManager");
static_assert(sizeof(UAccelByteDedicatedServerManager) == 0x0003F0, "Wrong size on UAccelByteDedicatedServerManager");
static_assert(offsetof(UAccelByteDedicatedServerManager, PendingValidationBeforeMatchUpdate) == 0x0001A0, "Member 'UAccelByteDedicatedServerManager::PendingValidationBeforeMatchUpdate' has a wrong offset!");

// Class DeceiveInc.BotObjectiveRequirement
// 0x0008 (0x0030 - 0x0028)
class UBotObjectiveRequirement : public UObject
{
public:
	class UBotObjective*                          ObjectiveToResolveRequirement;                     // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjectiveRequirement">();
	}
	static class UBotObjectiveRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjectiveRequirement>();
	}
};
static_assert(alignof(UBotObjectiveRequirement) == 0x000008, "Wrong alignment on UBotObjectiveRequirement");
static_assert(sizeof(UBotObjectiveRequirement) == 0x000030, "Wrong size on UBotObjectiveRequirement");
static_assert(offsetof(UBotObjectiveRequirement, ObjectiveToResolveRequirement) == 0x000028, "Member 'UBotObjectiveRequirement::ObjectiveToResolveRequirement' has a wrong offset!");

// Class DeceiveInc.BotObjectiveRequirementResource
// 0x0008 (0x0038 - 0x0030)
class UBotObjectiveRequirementResource final : public UBotObjectiveRequirement
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjectiveRequirementResource">();
	}
	static class UBotObjectiveRequirementResource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjectiveRequirementResource>();
	}
};
static_assert(alignof(UBotObjectiveRequirementResource) == 0x000008, "Wrong alignment on UBotObjectiveRequirementResource");
static_assert(sizeof(UBotObjectiveRequirementResource) == 0x000038, "Wrong size on UBotObjectiveRequirementResource");

// Class DeceiveInc.BaseSpyTool
// 0x0310 (0x0530 - 0x0220)
class ABaseSpyTool : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnSpyToolEvent;                                    // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyToolNewOwner;                                 // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOperatorRelease;                                 // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActionTextDataChanged;                           // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChargeAmountChanged;                             // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVisibilityChanged;                               // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnToolAttachToComponents;                          // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnToolCooldownChanged;                             // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bBlockLeftHandFlavorAnimationsOnADS;               // 0x02A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MovementSet3P;                                     // 0x02A4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAnimInstance>              Anim_1P_Class;                                     // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              Anim_3P_Class;                                     // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLinkAnimation;                                    // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameplayResourcesType                        ToolResourceType;                                  // 0x02C1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESpyToolType                                  SpyToolType;                                       // 0x02C2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C3[0x1];                                      // 0x02C3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ToolResourceToGiveAtStart;                         // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FToolWidgetParam>               ToolWidgetsToSpawn;                                // 0x02C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class USlateBrushAsset*                       ToolIcon;                                          // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ToolPrimaryActionText;                             // 0x02E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ToolSecondaryActionText;                           // 0x02F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bShowReticule;                                     // 0x0310(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlockRunOnADS;                                    // 0x0311(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlockRunFire;                                     // 0x0312(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanBeShowWithOtherTool;                           // 0x0313(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PreferredAttachSocket;                             // 0x0314(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31C[0x4];                                      // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USBAimAssistConfigDataAsset*            AimAssistConfig;                                   // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ToolBalancingName;                                 // 0x0328(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ToolBalancingDataTable;                            // 0x0330(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bToolGeneratesHeat;                                // 0x0338(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_339[0x7];                                      // 0x0339(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             ActiveToolBalancingDataTable;                      // 0x0340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreRightArmInHurtAdditive;                     // 0x0348(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_349[0x7];                                      // 0x0349(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorAffectedComponent*                EMPAffectedComponent;                              // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActorAffectedComponent*                ScramblerAffectedComponent;                        // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FToolAssetsId                          ToolAssetsId;                                      // 0x0360(0x0024)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_384[0x4];                                      // 0x0384(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               PoudrierPreviewTexture;                            // 0x0388(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UMaterialInstance>> ToolWrapMaterials;                                 // 0x0390(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class ABaseSpyTool*                           SecondaryTool;                                     // 0x03A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseSpyTool*                           IsSecondaryToolFor;                                // 0x03A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseSpyTool*                           OwningTool;                                        // 0x03B0(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UActorComponent*>                ComponentsToApplyWrap;                             // 0x03B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class AActor*>              AnimationProps1P;                                  // 0x03C8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class AActor*>              AnimationProps3P;                                  // 0x0418(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_468[0x10];                                     // 0x0468(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUserWidget*>                    ShowedHUD;                                         // 0x0478(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSet<class AActor*>                           IgnoredActors;                                     // 0x0488(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class UUserWidget*>         ToolWidgets;                                       // 0x04D8(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_528[0x8];                                      // 0x0528(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddActorToIgnoreList(class AActor* TargetActor);
	bool AnimSwitchToPoudrier(bool bFirstPerson);
	void ApplyNewBalancingTableAndUpdateStats(class UDataTable* NewTable, class FName NewBalancingName);
	void ApplyWrapToComponent(class UMeshComponent* TargetComponent, bool ApplyToChildrens);
	void AttachToNewPreferredAttachSocket(class USceneComponent* Parent, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies, class FName NewPreferredAttachSocket);
	void BP_HideToolFromAnim(bool bShouldAffectSecondaryTool);
	void BP_OnGameRulesetChanged();
	void BP_OnOperatorRelease(class AActor* ReleasingOperator);
	void BP_OnOwnerSet(class ABaseSpyTool* SpyTool);
	void BP_OnPrimaryBegin(class ABaseSpyTool* SpyTool);
	void BP_OnPrimaryEnd(class ABaseSpyTool* SpyTool);
	void BP_OnPrimaryFailed(class ABaseSpyTool* SpyTool);
	void BP_OnRecycleBegin(class ABaseSpyTool* SpyTool);
	void BP_OnRecycleEnd(class ABaseSpyTool* SpyTool);
	void BP_OnSecondaryBegin(class ABaseSpyTool* SpyTool);
	void BP_OnSecondaryEnd(class ABaseSpyTool* SpyTool);
	void BP_OnSecondaryFailed(class ABaseSpyTool* SpyTool);
	void BP_OnSetupResource(class ABaseSpyTool* SpyTool);
	void BP_OnSpyToolEvent(ESpyToolEvent Event, class ABaseSpyTool* SpyTool);
	void BP_OnSwitchAwayFrom(class ABaseSpyTool* SpyTool);
	void BP_OnSwitchTo(class ABaseSpyTool* SpyTool);
	void BP_ShowToolFromAnim(bool bShouldAffectSecondaryTool);
	void BP_ShowToolFromSecondaryVisibilityFromAnim(bool bShouldAffectSecondaryTool);
	void BP_ShowToolHUD(class FName HUDName, bool bShowIn);
	class AActor* CreateAnimationProp(class FName NameID, TSubclassOf<class AActor> ActorToCreate, class FName AttachSocket, bool bFirstPerson);
	void DestroyAllAnimationProps();
	void DestroyAnimationProp(class FName NameID, bool bFirstPerson);
	void FireEvent(ESpyToolEvent Event);
	class AActor* GetAnimationProp(class FName NameID, bool bFirstPerson);
	EVisibilityMode GetCurrentVisibility();
	void GetToolActionsData(struct FToolActionTextData* PrimaryActionData, struct FToolActionTextData* SecondaryActionData);
	void HandleEMPIsAffectedChanged(bool bIsAffected, class AActor* AffectedActor);
	void HandleGameRulesChanged(EDIGameRuleset NewRuleset);
	void HandleLoadoutSpawnComplete(class UToolLoadoutComponent* ToolLoadout);
	void HandleScramblerIsAffectedChanged(bool bIsAffected, class AActor* AffectedActor);
	void HandleToolCooldownChange(bool bOnCooldown);
	bool IsAllowingMelee();
	void NetMulticast_NotifyPrimaryGadgetUse(bool bStart);
	void NetMulticast_NotifySecondaryGadgetUse(bool bStart);
	void OnAnyHandToolShowed(class ABaseSpyTool* SpyTool, ELoadoutSlot HandToolSlot);
	void OnPlayerHUDVisibilityChange(bool bVisible);
	void OnRep_NewToolAssetsId();
	void OnSpyDeath(class AActor* DeadActor);
	void PrimaryBegin();
	void PrimaryEnd();
	void PrimaryFailed();
	void RecycleBegin();
	void RecycleEnd();
	void RemoveActorFromIgnoreList(class AActor* TargetActor);
	void SecondaryBegin();
	void SecondaryEnd();
	void SecondaryFailed();
	void Server_NotifyPrimaryGadgetUse(bool bStart);
	void Server_NotifySecondaryGadgetUse(bool bStart);
	void SetLocalVisibility(EVisibilityMode InMode, bool bCanShowPoudrier, EToolVisibilityChangeReason InReason);
	void SetVisibility(bool bVisible);
	bool ShouldShowPoudrierMesh();
	void SwitchAwayFrom();
	void SwitchTo();
	void UpdateActionTextData();
	void UpdateStatsFromBalancingTable();

	bool CanBeUse() const;
	bool CanRecycle() const;
	class USBAimAssistConfigDataAsset* GetAimAssistConfiguration() const;
	TSubclassOf<class UAnimInstance> GetAnim1PClass() const;
	TSubclassOf<class UAnimInstance> GetAnim3PClass() const;
	int32 GetComittedResourceNum() const;
	class USkeletalMeshComponent* GetCurrentActiveMesh() const;
	const TSet<class AActor*> GetIgnoredActors() const;
	int32 GetInitChargeCount() const;
	int32 GetMaxResourceNum() const;
	class USkeletalMeshComponent* GetMeshComponent1P() const;
	class USkeletalMeshComponent* GetMeshComponent3P() const;
	class AController* GetOperatingController() const;
	struct FVector GetPositionerBeamLocation() const;
	class FName GetPreferredAttachSocket() const;
	float GetRechargeDuration() const;
	float GetRecycleRatio() const;
	int32 GetResourceNum() const;
	class ABaseSpyTool* GetSecondaryTool() const;
	const ESpyToolType GetSpyToolType() const;
	class UCooldownComponent* GetToolCooldownComponent() const;
	float GetToolCooldownRatio() const;
	class USlateBrushAsset* GetToolIconSlateBrush() const;
	const EGameplayResourcesType GetToolResourceType() const;
	class UUserWidget* GetToolWidget(int32 WidgetIndex) const;
	class UUserWidget* GetToolWidgetByName(class FName WidgetName) const;
	int32 GetUncomittedResourceNum() const;
	bool IsActorInIgnoreList(class AActor* TargetActor) const;
	bool IsKillcamViewTarget() const;
	bool IsLocallyControlled() const;
	bool IsOnCooldown() const;
	bool IsOwnedByBot() const;
	bool IsPrimaryActive() const;
	bool IsPrimaryAvailable() const;
	bool IsRecycleActive() const;
	bool IsRecycleRequested() const;
	bool IsSecondaryActive() const;
	bool IsSecondaryAvailable() const;
	bool IsToolActive() const;
	bool IsToolDisabled() const;
	bool IsToolSelected() const;
	bool IsUserViewIn1P() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseSpyTool">();
	}
	static class ABaseSpyTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseSpyTool>();
	}
};
static_assert(alignof(ABaseSpyTool) == 0x000008, "Wrong alignment on ABaseSpyTool");
static_assert(sizeof(ABaseSpyTool) == 0x000530, "Wrong size on ABaseSpyTool");
static_assert(offsetof(ABaseSpyTool, OnSpyToolEvent) == 0x000220, "Member 'ABaseSpyTool::OnSpyToolEvent' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, OnSpyToolNewOwner) == 0x000230, "Member 'ABaseSpyTool::OnSpyToolNewOwner' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, OnOperatorRelease) == 0x000240, "Member 'ABaseSpyTool::OnOperatorRelease' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, OnActionTextDataChanged) == 0x000250, "Member 'ABaseSpyTool::OnActionTextDataChanged' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, OnChargeAmountChanged) == 0x000260, "Member 'ABaseSpyTool::OnChargeAmountChanged' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, OnVisibilityChanged) == 0x000270, "Member 'ABaseSpyTool::OnVisibilityChanged' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, OnToolAttachToComponents) == 0x000280, "Member 'ABaseSpyTool::OnToolAttachToComponents' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, OnToolCooldownChanged) == 0x000290, "Member 'ABaseSpyTool::OnToolCooldownChanged' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, bBlockLeftHandFlavorAnimationsOnADS) == 0x0002A0, "Member 'ABaseSpyTool::bBlockLeftHandFlavorAnimationsOnADS' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, MovementSet3P) == 0x0002A4, "Member 'ABaseSpyTool::MovementSet3P' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, Anim_1P_Class) == 0x0002B0, "Member 'ABaseSpyTool::Anim_1P_Class' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, Anim_3P_Class) == 0x0002B8, "Member 'ABaseSpyTool::Anim_3P_Class' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, bLinkAnimation) == 0x0002C0, "Member 'ABaseSpyTool::bLinkAnimation' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, ToolResourceType) == 0x0002C1, "Member 'ABaseSpyTool::ToolResourceType' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, SpyToolType) == 0x0002C2, "Member 'ABaseSpyTool::SpyToolType' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, ToolResourceToGiveAtStart) == 0x0002C4, "Member 'ABaseSpyTool::ToolResourceToGiveAtStart' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, ToolWidgetsToSpawn) == 0x0002C8, "Member 'ABaseSpyTool::ToolWidgetsToSpawn' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, ToolIcon) == 0x0002D8, "Member 'ABaseSpyTool::ToolIcon' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, ToolPrimaryActionText) == 0x0002E0, "Member 'ABaseSpyTool::ToolPrimaryActionText' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, ToolSecondaryActionText) == 0x0002F8, "Member 'ABaseSpyTool::ToolSecondaryActionText' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, bShowReticule) == 0x000310, "Member 'ABaseSpyTool::bShowReticule' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, bBlockRunOnADS) == 0x000311, "Member 'ABaseSpyTool::bBlockRunOnADS' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, bBlockRunFire) == 0x000312, "Member 'ABaseSpyTool::bBlockRunFire' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, bCanBeShowWithOtherTool) == 0x000313, "Member 'ABaseSpyTool::bCanBeShowWithOtherTool' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, PreferredAttachSocket) == 0x000314, "Member 'ABaseSpyTool::PreferredAttachSocket' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, AimAssistConfig) == 0x000320, "Member 'ABaseSpyTool::AimAssistConfig' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, ToolBalancingName) == 0x000328, "Member 'ABaseSpyTool::ToolBalancingName' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, ToolBalancingDataTable) == 0x000330, "Member 'ABaseSpyTool::ToolBalancingDataTable' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, bToolGeneratesHeat) == 0x000338, "Member 'ABaseSpyTool::bToolGeneratesHeat' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, ActiveToolBalancingDataTable) == 0x000340, "Member 'ABaseSpyTool::ActiveToolBalancingDataTable' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, bIgnoreRightArmInHurtAdditive) == 0x000348, "Member 'ABaseSpyTool::bIgnoreRightArmInHurtAdditive' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, EMPAffectedComponent) == 0x000350, "Member 'ABaseSpyTool::EMPAffectedComponent' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, ScramblerAffectedComponent) == 0x000358, "Member 'ABaseSpyTool::ScramblerAffectedComponent' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, ToolAssetsId) == 0x000360, "Member 'ABaseSpyTool::ToolAssetsId' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, PoudrierPreviewTexture) == 0x000388, "Member 'ABaseSpyTool::PoudrierPreviewTexture' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, ToolWrapMaterials) == 0x000390, "Member 'ABaseSpyTool::ToolWrapMaterials' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, SecondaryTool) == 0x0003A0, "Member 'ABaseSpyTool::SecondaryTool' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, IsSecondaryToolFor) == 0x0003A8, "Member 'ABaseSpyTool::IsSecondaryToolFor' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, OwningTool) == 0x0003B0, "Member 'ABaseSpyTool::OwningTool' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, ComponentsToApplyWrap) == 0x0003B8, "Member 'ABaseSpyTool::ComponentsToApplyWrap' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, AnimationProps1P) == 0x0003C8, "Member 'ABaseSpyTool::AnimationProps1P' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, AnimationProps3P) == 0x000418, "Member 'ABaseSpyTool::AnimationProps3P' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, ShowedHUD) == 0x000478, "Member 'ABaseSpyTool::ShowedHUD' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, IgnoredActors) == 0x000488, "Member 'ABaseSpyTool::IgnoredActors' has a wrong offset!");
static_assert(offsetof(ABaseSpyTool, ToolWidgets) == 0x0004D8, "Member 'ABaseSpyTool::ToolWidgets' has a wrong offset!");

// Class DeceiveInc.BaseSpyActiveAbility
// 0x0060 (0x0590 - 0x0530)
class ABaseSpyActiveAbility : public ABaseSpyTool
{
public:
	uint8                                         Pad_530[0x8];                                      // 0x0530(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCooldownComponent*                     CooldownComponent;                                 // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UToolLoadoutComponent*                  LoadoutComponent;                                  // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveDuration;                                    // 0x0548(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PercentToRefund;                                   // 0x054C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayToCanCancel;                                  // 0x0550(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayToSwitchBackToWeapon;                         // 0x0554(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoDelayToSwitchBackToWeaponOnCancel;              // 0x0558(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablesInteractWhenActive;                       // 0x0559(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCancelable;                                       // 0x055A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeSilencedWhenActive;                          // 0x055B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNavmodeCancelAbility;                             // 0x055C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCancelableOnPrimaryClick;                         // 0x055D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwitchToSlot;                                     // 0x055E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceGadgetWhenSwitchingToSlot;                   // 0x055F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwitchToWeaponOnActiveEnd;                        // 0x0560(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerCooldownOnCancel;                          // 0x0561(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFinitDuration;                                    // 0x0562(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowMeleeWhenActive;                             // 0x0563(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockedByMelee;                                   // 0x0564(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowHealingConsumableWhenActive;                 // 0x0565(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActivated;                                      // 0x0566(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_567[0x1];                                      // 0x0567(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActiveTime;                                        // 0x0568(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56C[0x24];                                     // 0x056C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnActiveBegin();
	void BP_OnActiveBeginLocal();
	void BP_OnActiveBeginReplicated();
	void BP_OnActiveEnd();
	void BP_OnActiveEndLocal();
	void BP_OnActiveEndReplicated();
	float GetActivePowerRatio();
	void OnSetToStartCooldownTimerEnd();
	void OnSwitchBackToWeaponTimerEnd();
	void OnVaultLockedPhaseStart(class UVaultLockedPhaseInfo* PhaseInfo);
	void OwnerTrigerActiveFailed();
	void ResetPendingActiveAbilityOutAnimation();
	void Server_CancelActivePower(bool bRefundActive);
	void TriggerActivePower();
	void TriggerActivePowerNetMulticast();
	void TriggerDeactivatePowerNetMulticast();
	void TriggerUnhandledActivePressedMulticast();
	void UnhandledActivePressed();

	bool BP_IsActiveInProgress() const;
	float GetActiveTimeLeft() const;
	bool HasPendingActiveAbilityOutAnimation() const;
	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseSpyActiveAbility">();
	}
	static class ABaseSpyActiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseSpyActiveAbility>();
	}
};
static_assert(alignof(ABaseSpyActiveAbility) == 0x000008, "Wrong alignment on ABaseSpyActiveAbility");
static_assert(sizeof(ABaseSpyActiveAbility) == 0x000590, "Wrong size on ABaseSpyActiveAbility");
static_assert(offsetof(ABaseSpyActiveAbility, CooldownComponent) == 0x000538, "Member 'ABaseSpyActiveAbility::CooldownComponent' has a wrong offset!");
static_assert(offsetof(ABaseSpyActiveAbility, LoadoutComponent) == 0x000540, "Member 'ABaseSpyActiveAbility::LoadoutComponent' has a wrong offset!");
static_assert(offsetof(ABaseSpyActiveAbility, ActiveDuration) == 0x000548, "Member 'ABaseSpyActiveAbility::ActiveDuration' has a wrong offset!");
static_assert(offsetof(ABaseSpyActiveAbility, PercentToRefund) == 0x00054C, "Member 'ABaseSpyActiveAbility::PercentToRefund' has a wrong offset!");
static_assert(offsetof(ABaseSpyActiveAbility, DelayToCanCancel) == 0x000550, "Member 'ABaseSpyActiveAbility::DelayToCanCancel' has a wrong offset!");
static_assert(offsetof(ABaseSpyActiveAbility, DelayToSwitchBackToWeapon) == 0x000554, "Member 'ABaseSpyActiveAbility::DelayToSwitchBackToWeapon' has a wrong offset!");
static_assert(offsetof(ABaseSpyActiveAbility, bDoDelayToSwitchBackToWeaponOnCancel) == 0x000558, "Member 'ABaseSpyActiveAbility::bDoDelayToSwitchBackToWeaponOnCancel' has a wrong offset!");
static_assert(offsetof(ABaseSpyActiveAbility, bDisablesInteractWhenActive) == 0x000559, "Member 'ABaseSpyActiveAbility::bDisablesInteractWhenActive' has a wrong offset!");
static_assert(offsetof(ABaseSpyActiveAbility, bCancelable) == 0x00055A, "Member 'ABaseSpyActiveAbility::bCancelable' has a wrong offset!");
static_assert(offsetof(ABaseSpyActiveAbility, bCanBeSilencedWhenActive) == 0x00055B, "Member 'ABaseSpyActiveAbility::bCanBeSilencedWhenActive' has a wrong offset!");
static_assert(offsetof(ABaseSpyActiveAbility, bNavmodeCancelAbility) == 0x00055C, "Member 'ABaseSpyActiveAbility::bNavmodeCancelAbility' has a wrong offset!");
static_assert(offsetof(ABaseSpyActiveAbility, bCancelableOnPrimaryClick) == 0x00055D, "Member 'ABaseSpyActiveAbility::bCancelableOnPrimaryClick' has a wrong offset!");
static_assert(offsetof(ABaseSpyActiveAbility, bSwitchToSlot) == 0x00055E, "Member 'ABaseSpyActiveAbility::bSwitchToSlot' has a wrong offset!");
static_assert(offsetof(ABaseSpyActiveAbility, bForceGadgetWhenSwitchingToSlot) == 0x00055F, "Member 'ABaseSpyActiveAbility::bForceGadgetWhenSwitchingToSlot' has a wrong offset!");
static_assert(offsetof(ABaseSpyActiveAbility, bSwitchToWeaponOnActiveEnd) == 0x000560, "Member 'ABaseSpyActiveAbility::bSwitchToWeaponOnActiveEnd' has a wrong offset!");
static_assert(offsetof(ABaseSpyActiveAbility, bTriggerCooldownOnCancel) == 0x000561, "Member 'ABaseSpyActiveAbility::bTriggerCooldownOnCancel' has a wrong offset!");
static_assert(offsetof(ABaseSpyActiveAbility, bFinitDuration) == 0x000562, "Member 'ABaseSpyActiveAbility::bFinitDuration' has a wrong offset!");
static_assert(offsetof(ABaseSpyActiveAbility, bAllowMeleeWhenActive) == 0x000563, "Member 'ABaseSpyActiveAbility::bAllowMeleeWhenActive' has a wrong offset!");
static_assert(offsetof(ABaseSpyActiveAbility, bBlockedByMelee) == 0x000564, "Member 'ABaseSpyActiveAbility::bBlockedByMelee' has a wrong offset!");
static_assert(offsetof(ABaseSpyActiveAbility, bAllowHealingConsumableWhenActive) == 0x000565, "Member 'ABaseSpyActiveAbility::bAllowHealingConsumableWhenActive' has a wrong offset!");
static_assert(offsetof(ABaseSpyActiveAbility, bIsActivated) == 0x000566, "Member 'ABaseSpyActiveAbility::bIsActivated' has a wrong offset!");
static_assert(offsetof(ABaseSpyActiveAbility, ActiveTime) == 0x000568, "Member 'ABaseSpyActiveAbility::ActiveTime' has a wrong offset!");

// Class DeceiveInc.ChavezActiveAbilityMod2_1
// 0x0098 (0x0628 - 0x0590)
class AChavezActiveAbilityMod2_1 final : public ABaseSpyActiveAbility
{
public:
	float                                         TriggerDelay;                                      // 0x0590(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_594[0xC];                                      // 0x0594(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpulseStrength;                                   // 0x05A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ImpulseStrengthOOCSpy;                             // 0x05A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SweepHalfExtends;                                  // 0x05A8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ForwardSweepOffestMul;                             // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BumpOOCSpyDamage;                                  // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BumpImpulseVerticalOffset;                         // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BumpBlowCoverSpiesAlways;                          // 0x05C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BumpOpenLockedDoors;                               // 0x05C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BumpDestroysTools;                                 // 0x05C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C3[0x1];                                      // 0x05C3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BumpDelayAfterSpy;                                 // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DoorBumpOpenDuration;                              // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             BumpCollCheck;                                     // 0x05CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBumpAffectAllies;                                 // 0x05CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAllStarActive;                                  // 0x05CE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5CF[0x1];                                      // 0x05CF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChavezBumpActor;                                 // 0x05D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnChavezBumpSpy;                                   // 0x05E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnChavezBumpNPC;                                   // 0x05F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnChavezBumpDoor;                                  // 0x0600(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnChavezBumpTool;                                  // 0x0610(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 CurrentBumpedActor;                                // 0x0620(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BP_DoorBumped(class ABaseDoorActor* Door);
	void MulticastBumpActor(class AActor* BumpedActor);
	void OnTriggerDelayTimer();
	void TryBumpActor(class AActor* ToBump);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChavezActiveAbilityMod2_1">();
	}
	static class AChavezActiveAbilityMod2_1* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChavezActiveAbilityMod2_1>();
	}
};
static_assert(alignof(AChavezActiveAbilityMod2_1) == 0x000008, "Wrong alignment on AChavezActiveAbilityMod2_1");
static_assert(sizeof(AChavezActiveAbilityMod2_1) == 0x000628, "Wrong size on AChavezActiveAbilityMod2_1");
static_assert(offsetof(AChavezActiveAbilityMod2_1, TriggerDelay) == 0x000590, "Member 'AChavezActiveAbilityMod2_1::TriggerDelay' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod2_1, ImpulseStrength) == 0x0005A0, "Member 'AChavezActiveAbilityMod2_1::ImpulseStrength' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod2_1, ImpulseStrengthOOCSpy) == 0x0005A4, "Member 'AChavezActiveAbilityMod2_1::ImpulseStrengthOOCSpy' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod2_1, SweepHalfExtends) == 0x0005A8, "Member 'AChavezActiveAbilityMod2_1::SweepHalfExtends' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod2_1, ForwardSweepOffestMul) == 0x0005B4, "Member 'AChavezActiveAbilityMod2_1::ForwardSweepOffestMul' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod2_1, BumpOOCSpyDamage) == 0x0005B8, "Member 'AChavezActiveAbilityMod2_1::BumpOOCSpyDamage' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod2_1, BumpImpulseVerticalOffset) == 0x0005BC, "Member 'AChavezActiveAbilityMod2_1::BumpImpulseVerticalOffset' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod2_1, BumpBlowCoverSpiesAlways) == 0x0005C0, "Member 'AChavezActiveAbilityMod2_1::BumpBlowCoverSpiesAlways' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod2_1, BumpOpenLockedDoors) == 0x0005C1, "Member 'AChavezActiveAbilityMod2_1::BumpOpenLockedDoors' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod2_1, BumpDestroysTools) == 0x0005C2, "Member 'AChavezActiveAbilityMod2_1::BumpDestroysTools' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod2_1, BumpDelayAfterSpy) == 0x0005C4, "Member 'AChavezActiveAbilityMod2_1::BumpDelayAfterSpy' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod2_1, DoorBumpOpenDuration) == 0x0005C8, "Member 'AChavezActiveAbilityMod2_1::DoorBumpOpenDuration' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod2_1, BumpCollCheck) == 0x0005CC, "Member 'AChavezActiveAbilityMod2_1::BumpCollCheck' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod2_1, bBumpAffectAllies) == 0x0005CD, "Member 'AChavezActiveAbilityMod2_1::bBumpAffectAllies' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod2_1, bIsAllStarActive) == 0x0005CE, "Member 'AChavezActiveAbilityMod2_1::bIsAllStarActive' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod2_1, OnChavezBumpActor) == 0x0005D0, "Member 'AChavezActiveAbilityMod2_1::OnChavezBumpActor' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod2_1, OnChavezBumpSpy) == 0x0005E0, "Member 'AChavezActiveAbilityMod2_1::OnChavezBumpSpy' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod2_1, OnChavezBumpNPC) == 0x0005F0, "Member 'AChavezActiveAbilityMod2_1::OnChavezBumpNPC' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod2_1, OnChavezBumpDoor) == 0x000600, "Member 'AChavezActiveAbilityMod2_1::OnChavezBumpDoor' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod2_1, OnChavezBumpTool) == 0x000610, "Member 'AChavezActiveAbilityMod2_1::OnChavezBumpTool' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod2_1, CurrentBumpedActor) == 0x000620, "Member 'AChavezActiveAbilityMod2_1::CurrentBumpedActor' has a wrong offset!");

// Class DeceiveInc.DISessionSubsystem
// 0x0168 (0x0198 - 0x0030)
class UDISessionSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0xD0];                                      // 0x0030(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSessionUpdated;                                  // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x18];                                     // 0x0110(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCheatEnableInventoryCheck;                       // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCheatMenuEnableFreeLootBundle;                   // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 BanditId;                                          // 0x0148(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ProfileVisibility;                                 // 0x0158(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TwitchAccountLinked;                               // 0x0159(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBetaAccess;                                    // 0x015A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSteamSharing;                                   // 0x015B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsToxic;                                          // 0x015C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15D[0x3];                                      // 0x015D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GameLiftPlayerSessionId;                           // 0x0160(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDISessionProgression*                  Progression;                                       // 0x0170(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDISessionSelections*                   SessionSelections;                                 // 0x0178(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDISessionInventory*                    PlayerInventory;                                   // 0x0180(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDISessionLoot*                         PlayerLoot;                                        // 0x0188(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDISessionStats*                        PlayerStats;                                       // 0x0190(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	int32 GetCurrencyTypeAmount(const struct FPrimaryAssetId& CurrencyType);
	int32 GetDIITemCostForCurrency(const class UDIItem* ItemToCheck, class UDICurrencyItem* Currency);
	struct FItemUnlockLevelArray GetItemUnlockInfo(const struct FPrimaryAssetId& AssetId);
	bool GetXPBoosterActive();
	int32 GetXPBoosterAmmount();
	int32 GetXPBoosterTimeLeft();
	class FString GetXPBoosterTimeLeftFormat();
	const bool IsAgentAvailable(const struct FPrimaryAssetId& AssetId, bool* bIsPurchased);
	const bool IsOwnedItemAccelByteID(const class FString& AccelByteItemId);
	const bool IsOwnedStringItemID(const class FString& ItemId);
	const bool IsSelectedAgentValid();
	const int32 QuantityOwned(const struct FPrimaryAssetId& AssetId);

	bool CanAssetBePurchased(const struct FPrimaryAssetId& AssetId) const;
	bool CanDIItemBePurchased(const class UDIItem* ItemToCheck) const;
	bool CanPurchaseItemWithCurrency(const class UDIItem* ItemToCheck, const class FString& CurrencyId) const;
	bool CanPurchaseStringItemWithCurrency(const class FString& ItemToCheck, const class FString& CurrencyId) const;
	bool CanShowAssetInMenu(const struct FPrimaryAssetId& AssetId) const;
	const bool DIITemIsOwned(const class UDIItem* ItemToCheck) const;
	int32 GetCheatFreeLootAmount() const;
	int32 GetPlayerTotalMasteries() const;
	const bool IsAvailableForUse(const struct FPrimaryAssetId& AssetId) const;
	bool IsCheatFreeLootBundle() const;
	bool IsConsumableDIItem(const class UDIItem* ItemToCheck) const;
	bool IsConsumableItem(const class FString& ItemToCheck) const;
	bool IsGameplayAsset(const struct FPrimaryAssetId& AssetId) const;
	const bool IsInPlayerInventory(const struct FPrimaryAssetId& AssetId) const;
	bool IsLocalUserToxic() const;
	const bool IsOwned(const struct FPrimaryAssetId& AssetId) const;
	const bool IsOwnedItemID(int32 ItemId) const;
	const int32 QuantityOwnedStringItemID(const class FString& ItemId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DISessionSubsystem">();
	}
	static class UDISessionSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDISessionSubsystem>();
	}
};
static_assert(alignof(UDISessionSubsystem) == 0x000008, "Wrong alignment on UDISessionSubsystem");
static_assert(sizeof(UDISessionSubsystem) == 0x000198, "Wrong size on UDISessionSubsystem");
static_assert(offsetof(UDISessionSubsystem, OnSessionUpdated) == 0x000100, "Member 'UDISessionSubsystem::OnSessionUpdated' has a wrong offset!");
static_assert(offsetof(UDISessionSubsystem, OnCheatEnableInventoryCheck) == 0x000128, "Member 'UDISessionSubsystem::OnCheatEnableInventoryCheck' has a wrong offset!");
static_assert(offsetof(UDISessionSubsystem, OnCheatMenuEnableFreeLootBundle) == 0x000138, "Member 'UDISessionSubsystem::OnCheatMenuEnableFreeLootBundle' has a wrong offset!");
static_assert(offsetof(UDISessionSubsystem, BanditId) == 0x000148, "Member 'UDISessionSubsystem::BanditId' has a wrong offset!");
static_assert(offsetof(UDISessionSubsystem, ProfileVisibility) == 0x000158, "Member 'UDISessionSubsystem::ProfileVisibility' has a wrong offset!");
static_assert(offsetof(UDISessionSubsystem, TwitchAccountLinked) == 0x000159, "Member 'UDISessionSubsystem::TwitchAccountLinked' has a wrong offset!");
static_assert(offsetof(UDISessionSubsystem, bHasBetaAccess) == 0x00015A, "Member 'UDISessionSubsystem::bHasBetaAccess' has a wrong offset!");
static_assert(offsetof(UDISessionSubsystem, bIsSteamSharing) == 0x00015B, "Member 'UDISessionSubsystem::bIsSteamSharing' has a wrong offset!");
static_assert(offsetof(UDISessionSubsystem, bIsToxic) == 0x00015C, "Member 'UDISessionSubsystem::bIsToxic' has a wrong offset!");
static_assert(offsetof(UDISessionSubsystem, GameLiftPlayerSessionId) == 0x000160, "Member 'UDISessionSubsystem::GameLiftPlayerSessionId' has a wrong offset!");
static_assert(offsetof(UDISessionSubsystem, Progression) == 0x000170, "Member 'UDISessionSubsystem::Progression' has a wrong offset!");
static_assert(offsetof(UDISessionSubsystem, SessionSelections) == 0x000178, "Member 'UDISessionSubsystem::SessionSelections' has a wrong offset!");
static_assert(offsetof(UDISessionSubsystem, PlayerInventory) == 0x000180, "Member 'UDISessionSubsystem::PlayerInventory' has a wrong offset!");
static_assert(offsetof(UDISessionSubsystem, PlayerLoot) == 0x000188, "Member 'UDISessionSubsystem::PlayerLoot' has a wrong offset!");
static_assert(offsetof(UDISessionSubsystem, PlayerStats) == 0x000190, "Member 'UDISessionSubsystem::PlayerStats' has a wrong offset!");

// Class DeceiveInc.AceActiveAbility
// 0x0178 (0x0708 - 0x0590)
class AAceActiveAbility : public ABaseSpyActiveAbility
{
public:
	uint8                                         Pad_590[0x88];                                     // 0x0590(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   VictimEffect;                                      // 0x0618(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCooldownComponent*                     HasValidLastHitTargetTimer;                        // 0x0640(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ActiveStartAnnouncementText;                       // 0x0648(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ActiveEndAnnouncementText;                         // 0x0660(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         ActiveAnnouncementPriority;                        // 0x0678(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveAnnouncementDuration;                        // 0x067C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepLastTargetHitDuration;                         // 0x0680(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_684[0x4];                                      // 0x0684(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ConfirmedTarget;                                   // 0x0688(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 LastHitTarget;                                     // 0x0690(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_698[0x60];                                     // 0x0698(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class AVictimEffect*                          CurrentVictimEffect;                               // 0x06F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartCooldownOnVictimDeath;                       // 0x0700(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_701[0x7];                                      // 0x0701(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetTimeRemainingBeforeLastHitTargetReset();
	void MarkByAceActive(class AActor* MarkedTarget);
	void NetMulticast_MarkByAceActive(class AActor* MarkedTarget);
	void NetMulticast_OnActiveEndAnnouncement(class ASpy* SpyTarget);
	void NetMulticast_OnActiveStartAnnouncement(class ASpy* SpyTarget);
	void OnConfirmedDamageDealt(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);
	void OnConfirmedTargetDeath(class AActor* DeadActor);
	void OnLastHitTargetDeath(class AActor* DeadActor);
	void OnLastHitTargetIsOnCooldownChange(bool OnCooldown);
	void OnRep_ConfirmedTarget(class AActor* PrevConfirmedTarget);

	bool HasValidLastHitTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AceActiveAbility">();
	}
	static class AAceActiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAceActiveAbility>();
	}
};
static_assert(alignof(AAceActiveAbility) == 0x000008, "Wrong alignment on AAceActiveAbility");
static_assert(sizeof(AAceActiveAbility) == 0x000708, "Wrong size on AAceActiveAbility");
static_assert(offsetof(AAceActiveAbility, VictimEffect) == 0x000618, "Member 'AAceActiveAbility::VictimEffect' has a wrong offset!");
static_assert(offsetof(AAceActiveAbility, HasValidLastHitTargetTimer) == 0x000640, "Member 'AAceActiveAbility::HasValidLastHitTargetTimer' has a wrong offset!");
static_assert(offsetof(AAceActiveAbility, ActiveStartAnnouncementText) == 0x000648, "Member 'AAceActiveAbility::ActiveStartAnnouncementText' has a wrong offset!");
static_assert(offsetof(AAceActiveAbility, ActiveEndAnnouncementText) == 0x000660, "Member 'AAceActiveAbility::ActiveEndAnnouncementText' has a wrong offset!");
static_assert(offsetof(AAceActiveAbility, ActiveAnnouncementPriority) == 0x000678, "Member 'AAceActiveAbility::ActiveAnnouncementPriority' has a wrong offset!");
static_assert(offsetof(AAceActiveAbility, ActiveAnnouncementDuration) == 0x00067C, "Member 'AAceActiveAbility::ActiveAnnouncementDuration' has a wrong offset!");
static_assert(offsetof(AAceActiveAbility, KeepLastTargetHitDuration) == 0x000680, "Member 'AAceActiveAbility::KeepLastTargetHitDuration' has a wrong offset!");
static_assert(offsetof(AAceActiveAbility, ConfirmedTarget) == 0x000688, "Member 'AAceActiveAbility::ConfirmedTarget' has a wrong offset!");
static_assert(offsetof(AAceActiveAbility, LastHitTarget) == 0x000690, "Member 'AAceActiveAbility::LastHitTarget' has a wrong offset!");
static_assert(offsetof(AAceActiveAbility, CurrentVictimEffect) == 0x0006F8, "Member 'AAceActiveAbility::CurrentVictimEffect' has a wrong offset!");
static_assert(offsetof(AAceActiveAbility, bStartCooldownOnVictimDeath) == 0x000700, "Member 'AAceActiveAbility::bStartCooldownOnVictimDeath' has a wrong offset!");

// Class DeceiveInc.AceActiveAbilityHeatVision
// 0x0108 (0x0698 - 0x0590)
class AAceActiveAbilityHeatVision final : public ABaseSpyActiveAbility
{
public:
	class FText                                   EffectStartAnnouncementText;                       // 0x0590(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   EffectEndAnnouncementText;                         // 0x05A8(0x0018)(Edit, NativeAccessSpecifierPublic)
	EAnnouncementType                             EffectAnnouncementType;                            // 0x05C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnnouncementGroup                            EffectAnnouncementGroup;                           // 0x05C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C2[0x2];                                      // 0x05C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EffectAnnouncementPriority;                        // 0x05C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectAnnouncementDuration;                        // 0x05C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CC[0x4];                                      // 0x05CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ASpy*, struct FHeatVisionSpyTargetData> SpyTargets;                                        // 0x05D0(0x0050)(Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   EffectZoneAsset;                                   // 0x0620(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoneMovementSpeedFactor;                           // 0x0648(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomizeTargetOffsetDelay;                        // 0x064C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinHeatActivationAmount;                           // 0x0650(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraceHeatAmount;                                   // 0x0654(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScaleFactorAtMaxHeat;                              // 0x0658(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_65C[0x4];                                      // 0x065C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   MaxHeatVictimEffect;                               // 0x0660(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HeatDetectionRange;                                // 0x0688(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HeatDetectionHeight;                               // 0x068C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_690[0x8];                                      // 0x0690(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleSpyHeatChanged(class ASpy* Spy, int32 NewHeatValue, int32 HeatDelta);
	void NetMulticast_OnVictimEffectStart(class AActor* Victim);
	void NetMulticast_SpyAffectedByZoneChange(class ASpy* AffectedSpyIn, bool bAffectedIn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AceActiveAbilityHeatVision">();
	}
	static class AAceActiveAbilityHeatVision* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAceActiveAbilityHeatVision>();
	}
};
static_assert(alignof(AAceActiveAbilityHeatVision) == 0x000008, "Wrong alignment on AAceActiveAbilityHeatVision");
static_assert(sizeof(AAceActiveAbilityHeatVision) == 0x000698, "Wrong size on AAceActiveAbilityHeatVision");
static_assert(offsetof(AAceActiveAbilityHeatVision, EffectStartAnnouncementText) == 0x000590, "Member 'AAceActiveAbilityHeatVision::EffectStartAnnouncementText' has a wrong offset!");
static_assert(offsetof(AAceActiveAbilityHeatVision, EffectEndAnnouncementText) == 0x0005A8, "Member 'AAceActiveAbilityHeatVision::EffectEndAnnouncementText' has a wrong offset!");
static_assert(offsetof(AAceActiveAbilityHeatVision, EffectAnnouncementType) == 0x0005C0, "Member 'AAceActiveAbilityHeatVision::EffectAnnouncementType' has a wrong offset!");
static_assert(offsetof(AAceActiveAbilityHeatVision, EffectAnnouncementGroup) == 0x0005C1, "Member 'AAceActiveAbilityHeatVision::EffectAnnouncementGroup' has a wrong offset!");
static_assert(offsetof(AAceActiveAbilityHeatVision, EffectAnnouncementPriority) == 0x0005C4, "Member 'AAceActiveAbilityHeatVision::EffectAnnouncementPriority' has a wrong offset!");
static_assert(offsetof(AAceActiveAbilityHeatVision, EffectAnnouncementDuration) == 0x0005C8, "Member 'AAceActiveAbilityHeatVision::EffectAnnouncementDuration' has a wrong offset!");
static_assert(offsetof(AAceActiveAbilityHeatVision, SpyTargets) == 0x0005D0, "Member 'AAceActiveAbilityHeatVision::SpyTargets' has a wrong offset!");
static_assert(offsetof(AAceActiveAbilityHeatVision, EffectZoneAsset) == 0x000620, "Member 'AAceActiveAbilityHeatVision::EffectZoneAsset' has a wrong offset!");
static_assert(offsetof(AAceActiveAbilityHeatVision, ZoneMovementSpeedFactor) == 0x000648, "Member 'AAceActiveAbilityHeatVision::ZoneMovementSpeedFactor' has a wrong offset!");
static_assert(offsetof(AAceActiveAbilityHeatVision, RandomizeTargetOffsetDelay) == 0x00064C, "Member 'AAceActiveAbilityHeatVision::RandomizeTargetOffsetDelay' has a wrong offset!");
static_assert(offsetof(AAceActiveAbilityHeatVision, MinHeatActivationAmount) == 0x000650, "Member 'AAceActiveAbilityHeatVision::MinHeatActivationAmount' has a wrong offset!");
static_assert(offsetof(AAceActiveAbilityHeatVision, TraceHeatAmount) == 0x000654, "Member 'AAceActiveAbilityHeatVision::TraceHeatAmount' has a wrong offset!");
static_assert(offsetof(AAceActiveAbilityHeatVision, ScaleFactorAtMaxHeat) == 0x000658, "Member 'AAceActiveAbilityHeatVision::ScaleFactorAtMaxHeat' has a wrong offset!");
static_assert(offsetof(AAceActiveAbilityHeatVision, MaxHeatVictimEffect) == 0x000660, "Member 'AAceActiveAbilityHeatVision::MaxHeatVictimEffect' has a wrong offset!");
static_assert(offsetof(AAceActiveAbilityHeatVision, HeatDetectionRange) == 0x000688, "Member 'AAceActiveAbilityHeatVision::HeatDetectionRange' has a wrong offset!");
static_assert(offsetof(AAceActiveAbilityHeatVision, HeatDetectionHeight) == 0x00068C, "Member 'AAceActiveAbilityHeatVision::HeatDetectionHeight' has a wrong offset!");

// Class DeceiveInc.DIPrimaryDataAsset
// 0x0008 (0x0038 - 0x0030)
class UDIPrimaryDataAsset : public UPrimaryDataAsset
{
public:
	struct FPrimaryAssetType                      AssetType;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FPrimaryAssetId BP_GetPrimaryAssetId() const;
	class FString GetIdentifierString() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIPrimaryDataAsset">();
	}
	static class UDIPrimaryDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIPrimaryDataAsset>();
	}
};
static_assert(alignof(UDIPrimaryDataAsset) == 0x000008, "Wrong alignment on UDIPrimaryDataAsset");
static_assert(sizeof(UDIPrimaryDataAsset) == 0x000038, "Wrong size on UDIPrimaryDataAsset");
static_assert(offsetof(UDIPrimaryDataAsset, AssetType) == 0x000030, "Member 'UDIPrimaryDataAsset::AssetType' has a wrong offset!");

// Class DeceiveInc.StoreItemMappingData
// 0x0050 (0x0088 - 0x0038)
class UStoreItemMappingData final : public UDIPrimaryDataAsset
{
public:
	TMap<class FString, struct FPlatformPurchaseMapping> StoreItemMapping;                                  // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreItemMappingData">();
	}
	static class UStoreItemMappingData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreItemMappingData>();
	}
};
static_assert(alignof(UStoreItemMappingData) == 0x000008, "Wrong alignment on UStoreItemMappingData");
static_assert(sizeof(UStoreItemMappingData) == 0x000088, "Wrong size on UStoreItemMappingData");
static_assert(offsetof(UStoreItemMappingData, StoreItemMapping) == 0x000038, "Member 'UStoreItemMappingData::StoreItemMapping' has a wrong offset!");

// Class DeceiveInc.AceActiveAbilityMod2
// 0x0040 (0x05D0 - 0x0590)
class AAceActiveAbilityMod2 final : public ABaseSpyActiveAbility
{
public:
	TSoftClassPtr<class UClass>                   EffectZoneAsset;                                   // 0x0590(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URangePlacementComponent*               RangePlacementComp;                                // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CurrentZoneEffect;                                 // 0x05C0(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C8[0x8];                                      // 0x05C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleMiscToolSpawned(class AActor* SpawnedTool);
	void OnSpawnRetriggerDelayTimerEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AceActiveAbilityMod2">();
	}
	static class AAceActiveAbilityMod2* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAceActiveAbilityMod2>();
	}
};
static_assert(alignof(AAceActiveAbilityMod2) == 0x000008, "Wrong alignment on AAceActiveAbilityMod2");
static_assert(sizeof(AAceActiveAbilityMod2) == 0x0005D0, "Wrong size on AAceActiveAbilityMod2");
static_assert(offsetof(AAceActiveAbilityMod2, EffectZoneAsset) == 0x000590, "Member 'AAceActiveAbilityMod2::EffectZoneAsset' has a wrong offset!");
static_assert(offsetof(AAceActiveAbilityMod2, RangePlacementComp) == 0x0005B8, "Member 'AAceActiveAbilityMod2::RangePlacementComp' has a wrong offset!");
static_assert(offsetof(AAceActiveAbilityMod2, CurrentZoneEffect) == 0x0005C0, "Member 'AAceActiveAbilityMod2::CurrentZoneEffect' has a wrong offset!");

// Class DeceiveInc.DiActivitySubsystem
// 0x0060 (0x0090 - 0x0030)
class UDiActivitySubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x60];                                      // 0x0030(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleMenuEvent(const class FString& EventName, bool AnswerValue);
	void HandleStateChanged(const class FName& CurrentState);
	void OnPostLoadMap(class UWorld* LoadedWorld);
	void OnWorldCleanup(class UWorld* World, bool bSessionEnded, bool bCleanupResources);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiActivitySubsystem">();
	}
	static class UDiActivitySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiActivitySubsystem>();
	}
};
static_assert(alignof(UDiActivitySubsystem) == 0x000008, "Wrong alignment on UDiActivitySubsystem");
static_assert(sizeof(UDiActivitySubsystem) == 0x000090, "Wrong size on UDiActivitySubsystem");

// Class DeceiveInc.AceHeatVisionZone
// 0x0078 (0x0298 - 0x0220)
class AAceHeatVisionZone final : public AActor
{
public:
	TSubclassOf<class AVictimEffect>              HeatZoneVictimEffect;                              // 0x0220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CollisionMesh;                                     // 0x0228(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ANPCCharacter*>                  NPCsInZone;                                        // 0x0230(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class AActor*, class AVictimEffect*>     VictimEffects;                                     // 0x0240(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnZoneRadiusScaleFactorChange(float NewScaleFactor);
	void HandleComponentOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void HandleComponentOverlapStart(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void SetCollisionMesh(class UStaticMeshComponent* CollisionMeshIn);
	void SetDefaultRadius(float Radius);

	float GetDefaultRadius() const;
	float GetZoneRadiusScaleFactor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AceHeatVisionZone">();
	}
	static class AAceHeatVisionZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAceHeatVisionZone>();
	}
};
static_assert(alignof(AAceHeatVisionZone) == 0x000008, "Wrong alignment on AAceHeatVisionZone");
static_assert(sizeof(AAceHeatVisionZone) == 0x000298, "Wrong size on AAceHeatVisionZone");
static_assert(offsetof(AAceHeatVisionZone, HeatZoneVictimEffect) == 0x000220, "Member 'AAceHeatVisionZone::HeatZoneVictimEffect' has a wrong offset!");
static_assert(offsetof(AAceHeatVisionZone, CollisionMesh) == 0x000228, "Member 'AAceHeatVisionZone::CollisionMesh' has a wrong offset!");
static_assert(offsetof(AAceHeatVisionZone, NPCsInZone) == 0x000230, "Member 'AAceHeatVisionZone::NPCsInZone' has a wrong offset!");
static_assert(offsetof(AAceHeatVisionZone, VictimEffects) == 0x000240, "Member 'AAceHeatVisionZone::VictimEffects' has a wrong offset!");

// Class DeceiveInc.SweetInputModifierAccelerator2D
// 0x0028 (0x0050 - 0x0028)
class USweetInputModifierAccelerator2D : public UInputModifier
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Threshold;                                         // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DropThreshold;                                     // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VerticalMaxBoostValue;                             // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HorizontalMaxBoostValue;                           // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToMaxBoost;                                    // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToRemoveBoost;                                 // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerSettingsType                           VerticalMaxBoostValueSetting;                      // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerSettingsType                           HorizontalMaxBoostValueSetting;                    // 0x0049(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerSettingsType                           TimeToMaxBoostSetting;                             // 0x004A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B[0x5];                                       // 0x004B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SweetInputModifierAccelerator2D">();
	}
	static class USweetInputModifierAccelerator2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<USweetInputModifierAccelerator2D>();
	}
};
static_assert(alignof(USweetInputModifierAccelerator2D) == 0x000008, "Wrong alignment on USweetInputModifierAccelerator2D");
static_assert(sizeof(USweetInputModifierAccelerator2D) == 0x000050, "Wrong size on USweetInputModifierAccelerator2D");
static_assert(offsetof(USweetInputModifierAccelerator2D, Threshold) == 0x000030, "Member 'USweetInputModifierAccelerator2D::Threshold' has a wrong offset!");
static_assert(offsetof(USweetInputModifierAccelerator2D, DropThreshold) == 0x000034, "Member 'USweetInputModifierAccelerator2D::DropThreshold' has a wrong offset!");
static_assert(offsetof(USweetInputModifierAccelerator2D, VerticalMaxBoostValue) == 0x000038, "Member 'USweetInputModifierAccelerator2D::VerticalMaxBoostValue' has a wrong offset!");
static_assert(offsetof(USweetInputModifierAccelerator2D, HorizontalMaxBoostValue) == 0x00003C, "Member 'USweetInputModifierAccelerator2D::HorizontalMaxBoostValue' has a wrong offset!");
static_assert(offsetof(USweetInputModifierAccelerator2D, TimeToMaxBoost) == 0x000040, "Member 'USweetInputModifierAccelerator2D::TimeToMaxBoost' has a wrong offset!");
static_assert(offsetof(USweetInputModifierAccelerator2D, TimeToRemoveBoost) == 0x000044, "Member 'USweetInputModifierAccelerator2D::TimeToRemoveBoost' has a wrong offset!");
static_assert(offsetof(USweetInputModifierAccelerator2D, VerticalMaxBoostValueSetting) == 0x000048, "Member 'USweetInputModifierAccelerator2D::VerticalMaxBoostValueSetting' has a wrong offset!");
static_assert(offsetof(USweetInputModifierAccelerator2D, HorizontalMaxBoostValueSetting) == 0x000049, "Member 'USweetInputModifierAccelerator2D::HorizontalMaxBoostValueSetting' has a wrong offset!");
static_assert(offsetof(USweetInputModifierAccelerator2D, TimeToMaxBoostSetting) == 0x00004A, "Member 'USweetInputModifierAccelerator2D::TimeToMaxBoostSetting' has a wrong offset!");

// Class DeceiveInc.BaseSpyPassiveAbility
// 0x0000 (0x0530 - 0x0530)
class ABaseSpyPassiveAbility : public ABaseSpyTool
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseSpyPassiveAbility">();
	}
	static class ABaseSpyPassiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseSpyPassiveAbility>();
	}
};
static_assert(alignof(ABaseSpyPassiveAbility) == 0x000008, "Wrong alignment on ABaseSpyPassiveAbility");
static_assert(sizeof(ABaseSpyPassiveAbility) == 0x000530, "Wrong size on ABaseSpyPassiveAbility");

// Class DeceiveInc.AcePassiveAbility
// 0x0098 (0x05C8 - 0x0530)
class AAcePassiveAbility final : public ABaseSpyPassiveAbility
{
public:
	uint8                                         Pad_530[0x10];                                     // 0x0530(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AProjectileWeapon*                      Weapon;                                            // 0x0540(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsReady;                                          // 0x0548(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_549[0x3];                                      // 0x0549(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayAfterShooting;                                // 0x054C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargeDuration;                                    // 0x0550(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_554[0x4];                                      // 0x0554(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FModifiedChargedDamageData             ModifiedChargedDamage;                             // 0x0558(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bModifiesDamages;                                  // 0x0570(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_571[0x3];                                      // 0x0571(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentChargeTime;                                 // 0x0574(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_578[0x8];                                      // 0x0578(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPassiveReady;                                    // 0x0580(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPassiveCanceled;                                 // 0x0590(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ChargedAttackVictimEffectClass;                    // 0x05A0(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleHitConfirmed(const struct FHitConfirmData& HitConfirmData);
	void HandleShotFired(const struct FVector& ShotEndPoint, class AProjectileWeapon* Weapon_0);
	void OnChargeCanceledClient(bool bShotFired);
	void OnChargeReadyClient();

	float GetChargeRatio() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AcePassiveAbility">();
	}
	static class AAcePassiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAcePassiveAbility>();
	}
};
static_assert(alignof(AAcePassiveAbility) == 0x000008, "Wrong alignment on AAcePassiveAbility");
static_assert(sizeof(AAcePassiveAbility) == 0x0005C8, "Wrong size on AAcePassiveAbility");
static_assert(offsetof(AAcePassiveAbility, Weapon) == 0x000540, "Member 'AAcePassiveAbility::Weapon' has a wrong offset!");
static_assert(offsetof(AAcePassiveAbility, bIsReady) == 0x000548, "Member 'AAcePassiveAbility::bIsReady' has a wrong offset!");
static_assert(offsetof(AAcePassiveAbility, DelayAfterShooting) == 0x00054C, "Member 'AAcePassiveAbility::DelayAfterShooting' has a wrong offset!");
static_assert(offsetof(AAcePassiveAbility, ChargeDuration) == 0x000550, "Member 'AAcePassiveAbility::ChargeDuration' has a wrong offset!");
static_assert(offsetof(AAcePassiveAbility, ModifiedChargedDamage) == 0x000558, "Member 'AAcePassiveAbility::ModifiedChargedDamage' has a wrong offset!");
static_assert(offsetof(AAcePassiveAbility, bModifiesDamages) == 0x000570, "Member 'AAcePassiveAbility::bModifiesDamages' has a wrong offset!");
static_assert(offsetof(AAcePassiveAbility, CurrentChargeTime) == 0x000574, "Member 'AAcePassiveAbility::CurrentChargeTime' has a wrong offset!");
static_assert(offsetof(AAcePassiveAbility, OnPassiveReady) == 0x000580, "Member 'AAcePassiveAbility::OnPassiveReady' has a wrong offset!");
static_assert(offsetof(AAcePassiveAbility, OnPassiveCanceled) == 0x000590, "Member 'AAcePassiveAbility::OnPassiveCanceled' has a wrong offset!");
static_assert(offsetof(AAcePassiveAbility, ChargedAttackVictimEffectClass) == 0x0005A0, "Member 'AAcePassiveAbility::ChargedAttackVictimEffectClass' has a wrong offset!");

// Class DeceiveInc.BasePlaceable
// 0x0098 (0x02B8 - 0x0220)
class ABasePlaceable : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnIsEnableChanged;                                 // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlaceableDestroyed;                              // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlaceableBeginPlay;                              // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 PlaceableMesh;                                     // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHealthComponent*                       HealthComponent;                                   // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnPlaceableOwnerChange;                            // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OwnerTool;                                         // 0x0280(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADIPlayerState*                         OwnerState;                                        // 0x0288(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FToolAssetsId                          PlaceableWrapInfo;                                 // 0x0290(0x0024)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDeath(class AActor* DeadActor);
	void OnRep_WrapData();

	bool IsLocallyOwned() const;
	bool IsOwnerFriendlyWith(const class AActor* ToCheck) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePlaceable">();
	}
	static class ABasePlaceable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABasePlaceable>();
	}
};
static_assert(alignof(ABasePlaceable) == 0x000008, "Wrong alignment on ABasePlaceable");
static_assert(sizeof(ABasePlaceable) == 0x0002B8, "Wrong size on ABasePlaceable");
static_assert(offsetof(ABasePlaceable, OnIsEnableChanged) == 0x000228, "Member 'ABasePlaceable::OnIsEnableChanged' has a wrong offset!");
static_assert(offsetof(ABasePlaceable, OnPlaceableDestroyed) == 0x000238, "Member 'ABasePlaceable::OnPlaceableDestroyed' has a wrong offset!");
static_assert(offsetof(ABasePlaceable, OnPlaceableBeginPlay) == 0x000248, "Member 'ABasePlaceable::OnPlaceableBeginPlay' has a wrong offset!");
static_assert(offsetof(ABasePlaceable, PlaceableMesh) == 0x000258, "Member 'ABasePlaceable::PlaceableMesh' has a wrong offset!");
static_assert(offsetof(ABasePlaceable, HealthComponent) == 0x000260, "Member 'ABasePlaceable::HealthComponent' has a wrong offset!");
static_assert(offsetof(ABasePlaceable, OnPlaceableOwnerChange) == 0x000268, "Member 'ABasePlaceable::OnPlaceableOwnerChange' has a wrong offset!");
static_assert(offsetof(ABasePlaceable, OwnerTool) == 0x000280, "Member 'ABasePlaceable::OwnerTool' has a wrong offset!");
static_assert(offsetof(ABasePlaceable, OwnerState) == 0x000288, "Member 'ABasePlaceable::OwnerState' has a wrong offset!");
static_assert(offsetof(ABasePlaceable, PlaceableWrapInfo) == 0x000290, "Member 'ABasePlaceable::PlaceableWrapInfo' has a wrong offset!");

// Class DeceiveInc.BasePickablePlaceable
// 0x0060 (0x0318 - 0x02B8)
class ABasePickablePlaceable : public ABasePlaceable
{
public:
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       RegistrationCollisionShapeComp;                    // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 InteractableComp;                                  // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerOwnedConditionComponent*         PlayerOwnedCond;                                   // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URayCastConditionComponent*             RayCastCond;                                       // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActorAffectedComponent*                EMPAffectedComponent;                              // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActorAffectedComponent*                ScramblerAffectedComp;                             // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDropAtComponent*                       DropAtComp;                                        // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnPlaceableDropDone;                               // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_SetCanBePing(bool bCanBePingIn);
	void HandleDropDone(class AActor* ActorDropped, const struct FVector& EndPos, const struct FRotator& EndRotation);
	void HandleEMPIsAffectedChanged(bool bIsAffected, class AActor* AffectedActor);
	void HandleScramblerIsAffectedChanged(bool bIsAffected, class AActor* AffectedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePickablePlaceable">();
	}
	static class ABasePickablePlaceable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABasePickablePlaceable>();
	}
};
static_assert(alignof(ABasePickablePlaceable) == 0x000008, "Wrong alignment on ABasePickablePlaceable");
static_assert(sizeof(ABasePickablePlaceable) == 0x000318, "Wrong size on ABasePickablePlaceable");
static_assert(offsetof(ABasePickablePlaceable, RegistrationCollisionShapeComp) == 0x0002C8, "Member 'ABasePickablePlaceable::RegistrationCollisionShapeComp' has a wrong offset!");
static_assert(offsetof(ABasePickablePlaceable, InteractableComp) == 0x0002D0, "Member 'ABasePickablePlaceable::InteractableComp' has a wrong offset!");
static_assert(offsetof(ABasePickablePlaceable, PlayerOwnedCond) == 0x0002D8, "Member 'ABasePickablePlaceable::PlayerOwnedCond' has a wrong offset!");
static_assert(offsetof(ABasePickablePlaceable, RayCastCond) == 0x0002E0, "Member 'ABasePickablePlaceable::RayCastCond' has a wrong offset!");
static_assert(offsetof(ABasePickablePlaceable, EMPAffectedComponent) == 0x0002E8, "Member 'ABasePickablePlaceable::EMPAffectedComponent' has a wrong offset!");
static_assert(offsetof(ABasePickablePlaceable, ScramblerAffectedComp) == 0x0002F0, "Member 'ABasePickablePlaceable::ScramblerAffectedComp' has a wrong offset!");
static_assert(offsetof(ABasePickablePlaceable, DropAtComp) == 0x0002F8, "Member 'ABasePickablePlaceable::DropAtComp' has a wrong offset!");
static_assert(offsetof(ABasePickablePlaceable, OnPlaceableDropDone) == 0x000300, "Member 'ABasePickablePlaceable::OnPlaceableDropDone' has a wrong offset!");

// Class DeceiveInc.BouncingMat
// 0x00C0 (0x03D8 - 0x0318)
class ABouncingMat final : public ABasePickablePlaceable
{
public:
	FMulticastInlineDelegateProperty_             OnNotifyDeflate;                                   // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         ImpulseValue;                                      // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DeflatedCollisionProfileName;                      // 0x032C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   InflatedCollisionProfileName;                      // 0x0334(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          CollisionBox;                                      // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnInflate;                                         // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	float                                         AutoDeflateDelay;                                  // 0x0358(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPrimitiveComponent*>            ColIgnoredActors;                                  // 0x0360(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class AActor*, struct FCachedBounceData> ImpulsedList;                                      // 0x0370(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0x12];                                     // 0x03C0(0x0012)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsInflated;                                       // 0x03D2(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D3[0x5];                                      // 0x03D3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MulticastNPCImpulse(const struct FVector_NetQuantize& Impulse, const struct FVector_NetQuantize& VelocityIn, class ANPCCharacter* ImpulsedNPC);
	void OnBouncingMatOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnRep_NewInflatedValue();
	void ServerSetInflate(bool bInflated);
	void ServerSpyBouncedLocalImpulse(class ASpy* BouncedSpyIn, const struct FVector_NetQuantize& Impulse, const struct FVector_NetQuantize& VelocityIn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BouncingMat">();
	}
	static class ABouncingMat* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABouncingMat>();
	}
};
static_assert(alignof(ABouncingMat) == 0x000008, "Wrong alignment on ABouncingMat");
static_assert(sizeof(ABouncingMat) == 0x0003D8, "Wrong size on ABouncingMat");
static_assert(offsetof(ABouncingMat, OnNotifyDeflate) == 0x000318, "Member 'ABouncingMat::OnNotifyDeflate' has a wrong offset!");
static_assert(offsetof(ABouncingMat, ImpulseValue) == 0x000328, "Member 'ABouncingMat::ImpulseValue' has a wrong offset!");
static_assert(offsetof(ABouncingMat, DeflatedCollisionProfileName) == 0x00032C, "Member 'ABouncingMat::DeflatedCollisionProfileName' has a wrong offset!");
static_assert(offsetof(ABouncingMat, InflatedCollisionProfileName) == 0x000334, "Member 'ABouncingMat::InflatedCollisionProfileName' has a wrong offset!");
static_assert(offsetof(ABouncingMat, CollisionBox) == 0x000340, "Member 'ABouncingMat::CollisionBox' has a wrong offset!");
static_assert(offsetof(ABouncingMat, OnInflate) == 0x000348, "Member 'ABouncingMat::OnInflate' has a wrong offset!");
static_assert(offsetof(ABouncingMat, AutoDeflateDelay) == 0x000358, "Member 'ABouncingMat::AutoDeflateDelay' has a wrong offset!");
static_assert(offsetof(ABouncingMat, ColIgnoredActors) == 0x000360, "Member 'ABouncingMat::ColIgnoredActors' has a wrong offset!");
static_assert(offsetof(ABouncingMat, ImpulsedList) == 0x000370, "Member 'ABouncingMat::ImpulsedList' has a wrong offset!");
static_assert(offsetof(ABouncingMat, bIsInflated) == 0x0003D2, "Member 'ABouncingMat::bIsInflated' has a wrong offset!");

// Class DeceiveInc.BaseConditionComponent
// 0x0020 (0x00D0 - 0x00B0)
class UBaseConditionComponent : public UActorComponent
{
public:
	EConditionRestrictions                        Restrictions;                                      // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCheckRuleApply_Base*                   ConditionalRuleCheck;                              // 0x00B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlocking;                                         // 0x00C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x5];                                       // 0x00C1(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsConditionEnabled;                               // 0x00C6(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnlyCheckForFail;                                 // 0x00C7(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ManualPriority;                                    // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldFrustumCheckIfMet;                          // 0x00CC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsConditionMet(const class UInteracterComponent* InteracterComp, class AActor* PlayerActor);

	EConditionType GetConditionType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseConditionComponent">();
	}
	static class UBaseConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseConditionComponent>();
	}
};
static_assert(alignof(UBaseConditionComponent) == 0x000008, "Wrong alignment on UBaseConditionComponent");
static_assert(sizeof(UBaseConditionComponent) == 0x0000D0, "Wrong size on UBaseConditionComponent");
static_assert(offsetof(UBaseConditionComponent, Restrictions) == 0x0000B0, "Member 'UBaseConditionComponent::Restrictions' has a wrong offset!");
static_assert(offsetof(UBaseConditionComponent, ConditionalRuleCheck) == 0x0000B8, "Member 'UBaseConditionComponent::ConditionalRuleCheck' has a wrong offset!");
static_assert(offsetof(UBaseConditionComponent, bBlocking) == 0x0000C0, "Member 'UBaseConditionComponent::bBlocking' has a wrong offset!");
static_assert(offsetof(UBaseConditionComponent, bIsConditionEnabled) == 0x0000C6, "Member 'UBaseConditionComponent::bIsConditionEnabled' has a wrong offset!");
static_assert(offsetof(UBaseConditionComponent, bOnlyCheckForFail) == 0x0000C7, "Member 'UBaseConditionComponent::bOnlyCheckForFail' has a wrong offset!");
static_assert(offsetof(UBaseConditionComponent, ManualPriority) == 0x0000C8, "Member 'UBaseConditionComponent::ManualPriority' has a wrong offset!");
static_assert(offsetof(UBaseConditionComponent, bShouldFrustumCheckIfMet) == 0x0000CC, "Member 'UBaseConditionComponent::bShouldFrustumCheckIfMet' has a wrong offset!");

// Class DeceiveInc.ValidateExtractionComponent
// 0x0020 (0x00F0 - 0x00D0)
class UValidateExtractionComponent final : public UBaseConditionComponent
{
public:
	class AExtractionInteractableActor*           ExtractionToValidate;                              // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnResult;                                          // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	float                                         InteractDuration;                                  // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValidateExtractionComponent">();
	}
	static class UValidateExtractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValidateExtractionComponent>();
	}
};
static_assert(alignof(UValidateExtractionComponent) == 0x000008, "Wrong alignment on UValidateExtractionComponent");
static_assert(sizeof(UValidateExtractionComponent) == 0x0000F0, "Wrong size on UValidateExtractionComponent");
static_assert(offsetof(UValidateExtractionComponent, ExtractionToValidate) == 0x0000D0, "Member 'UValidateExtractionComponent::ExtractionToValidate' has a wrong offset!");
static_assert(offsetof(UValidateExtractionComponent, OnResult) == 0x0000D8, "Member 'UValidateExtractionComponent::OnResult' has a wrong offset!");
static_assert(offsetof(UValidateExtractionComponent, InteractDuration) == 0x0000E8, "Member 'UValidateExtractionComponent::InteractDuration' has a wrong offset!");

// Class DeceiveInc.AceTrailActiveAbility
// 0x00E8 (0x07F0 - 0x0708)
class AAceTrailActiveAbility final : public AAceActiveAbility
{
public:
	float                                         TrailVFXLookAheadDist;                             // 0x0708(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrailVFXSpawnInterval;                             // 0x070C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrailVFXTravelSpeed;                               // 0x0710(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_714[0x4];                                      // 0x0714(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     TrailVFXBPClass;                                   // 0x0718(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SecondaryTrailVFXLookAheadDist;                    // 0x0720(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SecondaryTrailVFXSpawnInterval;                    // 0x0724(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SecondaryTrailVFXTravelSpeed;                      // 0x0728(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_72C[0x4];                                      // 0x072C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     SecondaryTrailVFXBPClass;                          // 0x0730(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     AttachedToTargetVFXBPClass;                        // 0x0738(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_740[0x68];                                     // 0x0740(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAceActiveTrailVFXData>         Trails;                                            // 0x07A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 AttachedToTargetVFX;                               // 0x07B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C0[0x30];                                     // 0x07C0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnUpdateAceActiveTrail(const TArray<struct FVector>& TrailPoints);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AceTrailActiveAbility">();
	}
	static class AAceTrailActiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAceTrailActiveAbility>();
	}
};
static_assert(alignof(AAceTrailActiveAbility) == 0x000008, "Wrong alignment on AAceTrailActiveAbility");
static_assert(sizeof(AAceTrailActiveAbility) == 0x0007F0, "Wrong size on AAceTrailActiveAbility");
static_assert(offsetof(AAceTrailActiveAbility, TrailVFXLookAheadDist) == 0x000708, "Member 'AAceTrailActiveAbility::TrailVFXLookAheadDist' has a wrong offset!");
static_assert(offsetof(AAceTrailActiveAbility, TrailVFXSpawnInterval) == 0x00070C, "Member 'AAceTrailActiveAbility::TrailVFXSpawnInterval' has a wrong offset!");
static_assert(offsetof(AAceTrailActiveAbility, TrailVFXTravelSpeed) == 0x000710, "Member 'AAceTrailActiveAbility::TrailVFXTravelSpeed' has a wrong offset!");
static_assert(offsetof(AAceTrailActiveAbility, TrailVFXBPClass) == 0x000718, "Member 'AAceTrailActiveAbility::TrailVFXBPClass' has a wrong offset!");
static_assert(offsetof(AAceTrailActiveAbility, SecondaryTrailVFXLookAheadDist) == 0x000720, "Member 'AAceTrailActiveAbility::SecondaryTrailVFXLookAheadDist' has a wrong offset!");
static_assert(offsetof(AAceTrailActiveAbility, SecondaryTrailVFXSpawnInterval) == 0x000724, "Member 'AAceTrailActiveAbility::SecondaryTrailVFXSpawnInterval' has a wrong offset!");
static_assert(offsetof(AAceTrailActiveAbility, SecondaryTrailVFXTravelSpeed) == 0x000728, "Member 'AAceTrailActiveAbility::SecondaryTrailVFXTravelSpeed' has a wrong offset!");
static_assert(offsetof(AAceTrailActiveAbility, SecondaryTrailVFXBPClass) == 0x000730, "Member 'AAceTrailActiveAbility::SecondaryTrailVFXBPClass' has a wrong offset!");
static_assert(offsetof(AAceTrailActiveAbility, AttachedToTargetVFXBPClass) == 0x000738, "Member 'AAceTrailActiveAbility::AttachedToTargetVFXBPClass' has a wrong offset!");
static_assert(offsetof(AAceTrailActiveAbility, Trails) == 0x0007A8, "Member 'AAceTrailActiveAbility::Trails' has a wrong offset!");
static_assert(offsetof(AAceTrailActiveAbility, AttachedToTargetVFX) == 0x0007B8, "Member 'AAceTrailActiveAbility::AttachedToTargetVFX' has a wrong offset!");

// Class DeceiveInc.ConversationConditionComponent
// 0x0008 (0x00D8 - 0x00D0)
class UConversationConditionComponent final : public UBaseConditionComponent
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConversationConditionComponent">();
	}
	static class UConversationConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConversationConditionComponent>();
	}
};
static_assert(alignof(UConversationConditionComponent) == 0x000008, "Wrong alignment on UConversationConditionComponent");
static_assert(sizeof(UConversationConditionComponent) == 0x0000D8, "Wrong size on UConversationConditionComponent");

// Class DeceiveInc.AchievementSubsystem
// 0x0020 (0x0050 - 0x0030)
class UAchievementSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_ResetAchievements();
	void BP_UpdateAchievementProgress(const class FString& AchievementID, float Progress, bool Increment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementSubsystem">();
	}
	static class UAchievementSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementSubsystem>();
	}
};
static_assert(alignof(UAchievementSubsystem) == 0x000008, "Wrong alignment on UAchievementSubsystem");
static_assert(sizeof(UAchievementSubsystem) == 0x000050, "Wrong size on UAchievementSubsystem");

// Class DeceiveInc.DISpectatorPawn
// 0x0068 (0x0310 - 0x02A8)
class ADISpectatorPawn final : public ASpectatorPawn
{
public:
	class UCameraComponent*                       Camera3P;                                          // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpringArmComponent*                    SpringArm3P;                                       // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       CameraFreeMove;                                    // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RevivePingCooldown;                                // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x1C];                                     // 0x02C4(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      RegisteredInputController;                         // 0x02E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x28];                                     // 0x02E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheatSpectateFreeMove();
	void CheatSpectateFreeMoveSrv();
	void CheatSpectateReviveSpy();
	class ADIPlayerState* GetSpectatingPlayerState();
	void HandleBooleanPlayerSettingChange(EPlayerSettingsType SettingType, bool NewValue);
	void HandleFloatPlayerSettingChange(EPlayerSettingsType SettingType, float NewValue);
	void HandlePhaseChanged(ESpyGamePhase NewGamePhase);
	void LookHorizontal(float AxisValue);
	void LookHorizontalRate(float AxisValue);
	void LookVertical(float AxisValue);
	void LookVerticalRate(float AxisValue);
	void OnAutoSpectatingChange(class ADeceiveIncPlayerController* PlayerController, bool bAutoSpectatingIn);
	void OnSpectateNextInput();
	void OnSpectatePrevInput();
	void OnSpectateRevivePingInput();
	void OnToggleAutoSpectateInput();
	void ShowUserInterface(bool bShow);

	bool GetIsDedicatedSpectator() const;
	float GetRevivePingCooldownRatio() const;
	class AActor* GetSpectatingActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DISpectatorPawn">();
	}
	static class ADISpectatorPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADISpectatorPawn>();
	}
};
static_assert(alignof(ADISpectatorPawn) == 0x000008, "Wrong alignment on ADISpectatorPawn");
static_assert(sizeof(ADISpectatorPawn) == 0x000310, "Wrong size on ADISpectatorPawn");
static_assert(offsetof(ADISpectatorPawn, Camera3P) == 0x0002A8, "Member 'ADISpectatorPawn::Camera3P' has a wrong offset!");
static_assert(offsetof(ADISpectatorPawn, SpringArm3P) == 0x0002B0, "Member 'ADISpectatorPawn::SpringArm3P' has a wrong offset!");
static_assert(offsetof(ADISpectatorPawn, CameraFreeMove) == 0x0002B8, "Member 'ADISpectatorPawn::CameraFreeMove' has a wrong offset!");
static_assert(offsetof(ADISpectatorPawn, RevivePingCooldown) == 0x0002C0, "Member 'ADISpectatorPawn::RevivePingCooldown' has a wrong offset!");
static_assert(offsetof(ADISpectatorPawn, RegisteredInputController) == 0x0002E0, "Member 'ADISpectatorPawn::RegisteredInputController' has a wrong offset!");

// Class DeceiveInc.ActiveAbilityConditionComponent
// 0x0008 (0x00D8 - 0x00D0)
class UActiveAbilityConditionComponent final : public UBaseConditionComponent
{
public:
	bool                                          bCanInteractWhenInMimic;                           // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActiveAbilityConditionComponent">();
	}
	static class UActiveAbilityConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActiveAbilityConditionComponent>();
	}
};
static_assert(alignof(UActiveAbilityConditionComponent) == 0x000008, "Wrong alignment on UActiveAbilityConditionComponent");
static_assert(sizeof(UActiveAbilityConditionComponent) == 0x0000D8, "Wrong size on UActiveAbilityConditionComponent");
static_assert(offsetof(UActiveAbilityConditionComponent, bCanInteractWhenInMimic) == 0x0000D0, "Member 'UActiveAbilityConditionComponent::bCanInteractWhenInMimic' has a wrong offset!");

// Class DeceiveInc.ChavezActiveAbility
// 0x0058 (0x05E8 - 0x0590)
class AChavezActiveAbility : public ABaseSpyActiveAbility
{
public:
	class UHealthComponent*                       HealthComponent;                                   // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Invulnerability;                                   // 0x0598(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostCompletedDuration;                             // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C4[0x4];                                      // 0x05C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDamageModifier*                        InvulnerabilityInstance;                           // 0x05C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHitBlocked;                                      // 0x05D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E0[0x8];                                      // 0x05E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleTakePointDamage(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& ShotFromDirection, const class UDamageType* DamageType, class AActor* DamageCauser);
	void MulticastShieldHit(const struct FVector_NetQuantize& HitPos);
	void OnPostTriggerDeactivatePower();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChavezActiveAbility">();
	}
	static class AChavezActiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChavezActiveAbility>();
	}
};
static_assert(alignof(AChavezActiveAbility) == 0x000008, "Wrong alignment on AChavezActiveAbility");
static_assert(sizeof(AChavezActiveAbility) == 0x0005E8, "Wrong size on AChavezActiveAbility");
static_assert(offsetof(AChavezActiveAbility, HealthComponent) == 0x000590, "Member 'AChavezActiveAbility::HealthComponent' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbility, Invulnerability) == 0x000598, "Member 'AChavezActiveAbility::Invulnerability' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbility, PostCompletedDuration) == 0x0005C0, "Member 'AChavezActiveAbility::PostCompletedDuration' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbility, InvulnerabilityInstance) == 0x0005C8, "Member 'AChavezActiveAbility::InvulnerabilityInstance' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbility, OnHitBlocked) == 0x0005D0, "Member 'AChavezActiveAbility::OnHitBlocked' has a wrong offset!");

// Class DeceiveInc.ChavezActiveAbilityMod1
// 0x0030 (0x0618 - 0x05E8)
class AChavezActiveAbilityMod1 final : public AChavezActiveAbility
{
public:
	uint8                                         Pad_5E8[0x8];                                      // 0x05E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentWeaponBuff;                                 // 0x05F0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F4[0x8];                                      // 0x05F4(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDmageBuffPercent;                               // 0x05FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRatioToBuff;                                 // 0x0600(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_604[0x4];                                      // 0x0604(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChavezActiveDamageMod;                           // 0x0608(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void HandleTakeAnyDamage(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);
	void HandleWeaponReloaded(ESpyToolEvent EventType, class ABaseSpyTool* SpyTool);
	void OnRep_CurrentWeaponBuff();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChavezActiveAbilityMod1">();
	}
	static class AChavezActiveAbilityMod1* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChavezActiveAbilityMod1>();
	}
};
static_assert(alignof(AChavezActiveAbilityMod1) == 0x000008, "Wrong alignment on AChavezActiveAbilityMod1");
static_assert(sizeof(AChavezActiveAbilityMod1) == 0x000618, "Wrong size on AChavezActiveAbilityMod1");
static_assert(offsetof(AChavezActiveAbilityMod1, CurrentWeaponBuff) == 0x0005F0, "Member 'AChavezActiveAbilityMod1::CurrentWeaponBuff' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod1, MaxDmageBuffPercent) == 0x0005FC, "Member 'AChavezActiveAbilityMod1::MaxDmageBuffPercent' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod1, DamageRatioToBuff) == 0x000600, "Member 'AChavezActiveAbilityMod1::DamageRatioToBuff' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod1, OnChavezActiveDamageMod) == 0x000608, "Member 'AChavezActiveAbilityMod1::OnChavezActiveDamageMod' has a wrong offset!");

// Class DeceiveInc.SweetDataminingSubsystem
// 0x00B0 (0x00E0 - 0x0030)
class USweetDataminingSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRosterEntry>                   RegisteredPlayers;                                 // 0x0040(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UWorld*                                 SessionGameWorld;                                  // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x88];                                      // 0x0058(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsRecording() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SweetDataminingSubsystem">();
	}
	static class USweetDataminingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USweetDataminingSubsystem>();
	}
};
static_assert(alignof(USweetDataminingSubsystem) == 0x000008, "Wrong alignment on USweetDataminingSubsystem");
static_assert(sizeof(USweetDataminingSubsystem) == 0x0000E0, "Wrong size on USweetDataminingSubsystem");
static_assert(offsetof(USweetDataminingSubsystem, RegisteredPlayers) == 0x000040, "Member 'USweetDataminingSubsystem::RegisteredPlayers' has a wrong offset!");
static_assert(offsetof(USweetDataminingSubsystem, SessionGameWorld) == 0x000050, "Member 'USweetDataminingSubsystem::SessionGameWorld' has a wrong offset!");

// Class DeceiveInc.ActorAffectedComponent
// 0x0058 (0x0108 - 0x00B0)
class UActorAffectedComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnIsAffectedChanged;                               // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAffectingSourceRegister;                         // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAffectingSourceUnregister;                       // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActorAffectedUpdateDelegateEvent;                // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         AffectingSources;                                  // 0x00F0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x3];                                      // 0x0100(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EActorAffectedType                            AffectedType;                                      // 0x0103(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EActorAffectedType GetAffectedType();
	void OnRep_Sources(const TArray<class AActor*>& OldSources);
	void RegisterAffectingSource(class AActor* AffectingSource);
	void UnregisterAffectingSource(class AActor* AffectingSource);

	bool IsAffected() const;
	bool IsAffectedForFaction(class AActor* ToCompare) const;
	bool IsDisabledByEffect() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorAffectedComponent">();
	}
	static class UActorAffectedComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorAffectedComponent>();
	}
};
static_assert(alignof(UActorAffectedComponent) == 0x000008, "Wrong alignment on UActorAffectedComponent");
static_assert(sizeof(UActorAffectedComponent) == 0x000108, "Wrong size on UActorAffectedComponent");
static_assert(offsetof(UActorAffectedComponent, OnIsAffectedChanged) == 0x0000B0, "Member 'UActorAffectedComponent::OnIsAffectedChanged' has a wrong offset!");
static_assert(offsetof(UActorAffectedComponent, OnAffectingSourceRegister) == 0x0000C0, "Member 'UActorAffectedComponent::OnAffectingSourceRegister' has a wrong offset!");
static_assert(offsetof(UActorAffectedComponent, OnAffectingSourceUnregister) == 0x0000D0, "Member 'UActorAffectedComponent::OnAffectingSourceUnregister' has a wrong offset!");
static_assert(offsetof(UActorAffectedComponent, OnActorAffectedUpdateDelegateEvent) == 0x0000E0, "Member 'UActorAffectedComponent::OnActorAffectedUpdateDelegateEvent' has a wrong offset!");
static_assert(offsetof(UActorAffectedComponent, AffectingSources) == 0x0000F0, "Member 'UActorAffectedComponent::AffectingSources' has a wrong offset!");
static_assert(offsetof(UActorAffectedComponent, AffectedType) == 0x000103, "Member 'UActorAffectedComponent::AffectedType' has a wrong offset!");

// Class DeceiveInc.ActorAffectingInterface
// 0x0000 (0x0028 - 0x0028)
class IActorAffectingInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorAffectingInterface">();
	}
	static class IActorAffectingInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IActorAffectingInterface>();
	}
};
static_assert(alignof(IActorAffectingInterface) == 0x000008, "Wrong alignment on IActorAffectingInterface");
static_assert(sizeof(IActorAffectingInterface) == 0x000028, "Wrong size on IActorAffectingInterface");

// Class DeceiveInc.HansPassiveAbilityMod2
// 0x0018 (0x0548 - 0x0530)
class AHansPassiveAbilityMod2 final : public ABaseSpyPassiveAbility
{
public:
	float                                         PercentRefunded;                                   // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_534[0x4];                                      // 0x0534(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           EffectsToHandle;                                   // 0x0538(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void HandleVictimEffectApplied(class ASpy* Victim, class AVictimEffect* Effect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HansPassiveAbilityMod2">();
	}
	static class AHansPassiveAbilityMod2* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHansPassiveAbilityMod2>();
	}
};
static_assert(alignof(AHansPassiveAbilityMod2) == 0x000008, "Wrong alignment on AHansPassiveAbilityMod2");
static_assert(sizeof(AHansPassiveAbilityMod2) == 0x000548, "Wrong size on AHansPassiveAbilityMod2");
static_assert(offsetof(AHansPassiveAbilityMod2, PercentRefunded) == 0x000530, "Member 'AHansPassiveAbilityMod2::PercentRefunded' has a wrong offset!");
static_assert(offsetof(AHansPassiveAbilityMod2, EffectsToHandle) == 0x000538, "Member 'AHansPassiveAbilityMod2::EffectsToHandle' has a wrong offset!");

// Class DeceiveInc.DiPawnInterface
// 0x0000 (0x0028 - 0x0028)
class IDiPawnInterface final : public IInterface
{
public:
	void DisableDIPawnInput(class AActor* Requester);
	void EnableDIPawnInput(class AActor* Requester);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiPawnInterface">();
	}
	static class IDiPawnInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDiPawnInterface>();
	}
};
static_assert(alignof(IDiPawnInterface) == 0x000008, "Wrong alignment on IDiPawnInterface");
static_assert(sizeof(IDiPawnInterface) == 0x000028, "Wrong size on IDiPawnInterface");

// Class DeceiveInc.BaseGamePhaseInfo
// 0x0000 (0x0028 - 0x0028)
class UBaseGamePhaseInfo : public UObject
{
public:
	class FText GetPhaseTimerTxt();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseGamePhaseInfo">();
	}
	static class UBaseGamePhaseInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseGamePhaseInfo>();
	}
};
static_assert(alignof(UBaseGamePhaseInfo) == 0x000008, "Wrong alignment on UBaseGamePhaseInfo");
static_assert(sizeof(UBaseGamePhaseInfo) == 0x000028, "Wrong size on UBaseGamePhaseInfo");

// Class DeceiveInc.SpyGamePhaseInfo
// 0x0000 (0x0028 - 0x0028)
class USpyGamePhaseInfo : public UBaseGamePhaseInfo
{
public:
	float GetCriticalTimeAnnoucementDuration();
	int32 GetCriticalTimeAnnoucementPriority();
	class FText GetCriticalTimeAnnoucementText();
	EAnnouncementType GetCriticalTimeAnnoucementType();
	int32 GetCriticalTimeLeft();
	ESpyGamePhase GetGamePhase();
	bool HasCriticalTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpyGamePhaseInfo">();
	}
	static class USpyGamePhaseInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpyGamePhaseInfo>();
	}
};
static_assert(alignof(USpyGamePhaseInfo) == 0x000008, "Wrong alignment on USpyGamePhaseInfo");
static_assert(sizeof(USpyGamePhaseInfo) == 0x000028, "Wrong size on USpyGamePhaseInfo");

// Class DeceiveInc.ResultScreenPhaseInfo
// 0x0058 (0x0080 - 0x0028)
class UResultScreenPhaseInfo final : public USpyGamePhaseInfo
{
public:
	struct FResultScreenPhaseData                 DefaultPhaseData;                                  // 0x0028(0x0058)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResultScreenPhaseInfo">();
	}
	static class UResultScreenPhaseInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResultScreenPhaseInfo>();
	}
};
static_assert(alignof(UResultScreenPhaseInfo) == 0x000008, "Wrong alignment on UResultScreenPhaseInfo");
static_assert(sizeof(UResultScreenPhaseInfo) == 0x000080, "Wrong size on UResultScreenPhaseInfo");
static_assert(offsetof(UResultScreenPhaseInfo, DefaultPhaseData) == 0x000028, "Member 'UResultScreenPhaseInfo::DefaultPhaseData' has a wrong offset!");

// Class DeceiveInc.AgentData
// 0x0230 (0x0268 - 0x0038)
class UAgentData final : public UDIPrimaryDataAsset
{
public:
	uint8                                         Difficulty;                                        // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   AgentName;                                         // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   AgentBio;                                          // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsAgentReleased;                                  // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 AgentColor;                                        // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                MenuAgentSelectionPortraitSelected;                // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                MenuAgentSelectionPortraitUnselected;              // 0x00A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                MenuAgentSelectionPortraitUnavailable;             // 0x00C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            ClassIconBrush;                                    // 0x00F0(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ClassName;                                         // 0x0178(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ClassDescription;                                  // 0x0190(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   AgentTagline;                                      // 0x01A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UAgentSkinData*                         DefaultSkin;                                       // 0x01C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAgentSkinData*>                 Skins;                                             // 0x01C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAgentIntroPoseDataAsset*               DefaultIntroPose;                                  // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAgentIntroPoseDataAsset*>       IntroPoses;                                        // 0x01E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDiSpyAnimationMotionSet> DefaultMotionSet;                                  // 0x01F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAgentWeaponData*>               WeaponVariants;                                    // 0x0218(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAgentExpertiseSkillData*>       ExpertiseSkillVariants;                            // 0x0228(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAgentPassiveSkillData*>         PassiveSkillVariants;                              // 0x0238(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UModsVariantMediaDataAsset*             ModsVariantMedia;                                  // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AgentBalancingName;                                // 0x0250(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanSpawnAsBot;                                    // 0x0260(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ShouldShowAgent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AgentData">();
	}
	static class UAgentData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAgentData>();
	}
};
static_assert(alignof(UAgentData) == 0x000008, "Wrong alignment on UAgentData");
static_assert(sizeof(UAgentData) == 0x000268, "Wrong size on UAgentData");
static_assert(offsetof(UAgentData, Difficulty) == 0x000038, "Member 'UAgentData::Difficulty' has a wrong offset!");
static_assert(offsetof(UAgentData, AgentName) == 0x000040, "Member 'UAgentData::AgentName' has a wrong offset!");
static_assert(offsetof(UAgentData, AgentBio) == 0x000058, "Member 'UAgentData::AgentBio' has a wrong offset!");
static_assert(offsetof(UAgentData, bIsAgentReleased) == 0x000070, "Member 'UAgentData::bIsAgentReleased' has a wrong offset!");
static_assert(offsetof(UAgentData, AgentColor) == 0x000074, "Member 'UAgentData::AgentColor' has a wrong offset!");
static_assert(offsetof(UAgentData, MenuAgentSelectionPortraitSelected) == 0x000078, "Member 'UAgentData::MenuAgentSelectionPortraitSelected' has a wrong offset!");
static_assert(offsetof(UAgentData, MenuAgentSelectionPortraitUnselected) == 0x0000A0, "Member 'UAgentData::MenuAgentSelectionPortraitUnselected' has a wrong offset!");
static_assert(offsetof(UAgentData, MenuAgentSelectionPortraitUnavailable) == 0x0000C8, "Member 'UAgentData::MenuAgentSelectionPortraitUnavailable' has a wrong offset!");
static_assert(offsetof(UAgentData, ClassIconBrush) == 0x0000F0, "Member 'UAgentData::ClassIconBrush' has a wrong offset!");
static_assert(offsetof(UAgentData, ClassName) == 0x000178, "Member 'UAgentData::ClassName' has a wrong offset!");
static_assert(offsetof(UAgentData, ClassDescription) == 0x000190, "Member 'UAgentData::ClassDescription' has a wrong offset!");
static_assert(offsetof(UAgentData, AgentTagline) == 0x0001A8, "Member 'UAgentData::AgentTagline' has a wrong offset!");
static_assert(offsetof(UAgentData, DefaultSkin) == 0x0001C0, "Member 'UAgentData::DefaultSkin' has a wrong offset!");
static_assert(offsetof(UAgentData, Skins) == 0x0001C8, "Member 'UAgentData::Skins' has a wrong offset!");
static_assert(offsetof(UAgentData, DefaultIntroPose) == 0x0001D8, "Member 'UAgentData::DefaultIntroPose' has a wrong offset!");
static_assert(offsetof(UAgentData, IntroPoses) == 0x0001E0, "Member 'UAgentData::IntroPoses' has a wrong offset!");
static_assert(offsetof(UAgentData, DefaultMotionSet) == 0x0001F0, "Member 'UAgentData::DefaultMotionSet' has a wrong offset!");
static_assert(offsetof(UAgentData, WeaponVariants) == 0x000218, "Member 'UAgentData::WeaponVariants' has a wrong offset!");
static_assert(offsetof(UAgentData, ExpertiseSkillVariants) == 0x000228, "Member 'UAgentData::ExpertiseSkillVariants' has a wrong offset!");
static_assert(offsetof(UAgentData, PassiveSkillVariants) == 0x000238, "Member 'UAgentData::PassiveSkillVariants' has a wrong offset!");
static_assert(offsetof(UAgentData, ModsVariantMedia) == 0x000248, "Member 'UAgentData::ModsVariantMedia' has a wrong offset!");
static_assert(offsetof(UAgentData, AgentBalancingName) == 0x000250, "Member 'UAgentData::AgentBalancingName' has a wrong offset!");
static_assert(offsetof(UAgentData, bCanSpawnAsBot) == 0x000260, "Member 'UAgentData::bCanSpawnAsBot' has a wrong offset!");

// Class DeceiveInc.AgentExpertiseSkillData
// 0x0128 (0x0160 - 0x0038)
class UAgentExpertiseSkillData final : public UDIPrimaryDataAsset
{
public:
	class FText                                   ExpertiseTitle;                                    // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ExpertiseDescLong;                                 // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ExpertiseUnlockDesc;                               // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateBrush                            ExpertiseIconBrush;                                // 0x0080(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInstance>       ExpertiseIconMaterial;                             // 0x0108(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     HudAgentSkillBorderImage;                          // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ExpertiseSkillClass;                               // 0x0138(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AgentExpertiseSkillData">();
	}
	static class UAgentExpertiseSkillData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAgentExpertiseSkillData>();
	}
};
static_assert(alignof(UAgentExpertiseSkillData) == 0x000008, "Wrong alignment on UAgentExpertiseSkillData");
static_assert(sizeof(UAgentExpertiseSkillData) == 0x000160, "Wrong size on UAgentExpertiseSkillData");
static_assert(offsetof(UAgentExpertiseSkillData, ExpertiseTitle) == 0x000038, "Member 'UAgentExpertiseSkillData::ExpertiseTitle' has a wrong offset!");
static_assert(offsetof(UAgentExpertiseSkillData, ExpertiseDescLong) == 0x000050, "Member 'UAgentExpertiseSkillData::ExpertiseDescLong' has a wrong offset!");
static_assert(offsetof(UAgentExpertiseSkillData, ExpertiseUnlockDesc) == 0x000068, "Member 'UAgentExpertiseSkillData::ExpertiseUnlockDesc' has a wrong offset!");
static_assert(offsetof(UAgentExpertiseSkillData, ExpertiseIconBrush) == 0x000080, "Member 'UAgentExpertiseSkillData::ExpertiseIconBrush' has a wrong offset!");
static_assert(offsetof(UAgentExpertiseSkillData, ExpertiseIconMaterial) == 0x000108, "Member 'UAgentExpertiseSkillData::ExpertiseIconMaterial' has a wrong offset!");
static_assert(offsetof(UAgentExpertiseSkillData, HudAgentSkillBorderImage) == 0x000130, "Member 'UAgentExpertiseSkillData::HudAgentSkillBorderImage' has a wrong offset!");
static_assert(offsetof(UAgentExpertiseSkillData, ExpertiseSkillClass) == 0x000138, "Member 'UAgentExpertiseSkillData::ExpertiseSkillClass' has a wrong offset!");

// Class DeceiveInc.AgentIntroPoseDataAsset
// 0x0148 (0x0180 - 0x0038)
class UAgentIntroPoseDataAsset final : public UDIPrimaryDataAsset
{
public:
	class UAgentData*                             Agent;                                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   IntroPoseName;                                     // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           IntroPoseAnim;                                     // 0x0058(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           WeaponAnim;                                        // 0x0080(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x00A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowWeapon;                                       // 0x00A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IntroPoseRarity;                                   // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAnimationPropData>             AnimationProps;                                    // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bAllowCustomSkinLayer;                             // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetCustomSkinLayerOnLoop;                       // 0x00C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x6];                                       // 0x00C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           DisableCustomSkinLayerABPs;                        // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bAllowPlayDelay;                                   // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSoftObjectPtr<class UAgentSkinData>, struct FSkinSpecifiAnimOverrideData> SkinSpecificOverride;                              // 0x00E0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class USkeletalMesh>, struct FSkinSpecifiAnimOverrideData> SkeletonSpecificOverride;                          // 0x0130(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AgentIntroPoseDataAsset">();
	}
	static class UAgentIntroPoseDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAgentIntroPoseDataAsset>();
	}
};
static_assert(alignof(UAgentIntroPoseDataAsset) == 0x000008, "Wrong alignment on UAgentIntroPoseDataAsset");
static_assert(sizeof(UAgentIntroPoseDataAsset) == 0x000180, "Wrong size on UAgentIntroPoseDataAsset");
static_assert(offsetof(UAgentIntroPoseDataAsset, Agent) == 0x000038, "Member 'UAgentIntroPoseDataAsset::Agent' has a wrong offset!");
static_assert(offsetof(UAgentIntroPoseDataAsset, IntroPoseName) == 0x000040, "Member 'UAgentIntroPoseDataAsset::IntroPoseName' has a wrong offset!");
static_assert(offsetof(UAgentIntroPoseDataAsset, IntroPoseAnim) == 0x000058, "Member 'UAgentIntroPoseDataAsset::IntroPoseAnim' has a wrong offset!");
static_assert(offsetof(UAgentIntroPoseDataAsset, WeaponAnim) == 0x000080, "Member 'UAgentIntroPoseDataAsset::WeaponAnim' has a wrong offset!");
static_assert(offsetof(UAgentIntroPoseDataAsset, bLooping) == 0x0000A8, "Member 'UAgentIntroPoseDataAsset::bLooping' has a wrong offset!");
static_assert(offsetof(UAgentIntroPoseDataAsset, bShowWeapon) == 0x0000A9, "Member 'UAgentIntroPoseDataAsset::bShowWeapon' has a wrong offset!");
static_assert(offsetof(UAgentIntroPoseDataAsset, IntroPoseRarity) == 0x0000AC, "Member 'UAgentIntroPoseDataAsset::IntroPoseRarity' has a wrong offset!");
static_assert(offsetof(UAgentIntroPoseDataAsset, AnimationProps) == 0x0000B0, "Member 'UAgentIntroPoseDataAsset::AnimationProps' has a wrong offset!");
static_assert(offsetof(UAgentIntroPoseDataAsset, bAllowCustomSkinLayer) == 0x0000C0, "Member 'UAgentIntroPoseDataAsset::bAllowCustomSkinLayer' has a wrong offset!");
static_assert(offsetof(UAgentIntroPoseDataAsset, bResetCustomSkinLayerOnLoop) == 0x0000C1, "Member 'UAgentIntroPoseDataAsset::bResetCustomSkinLayerOnLoop' has a wrong offset!");
static_assert(offsetof(UAgentIntroPoseDataAsset, DisableCustomSkinLayerABPs) == 0x0000C8, "Member 'UAgentIntroPoseDataAsset::DisableCustomSkinLayerABPs' has a wrong offset!");
static_assert(offsetof(UAgentIntroPoseDataAsset, bAllowPlayDelay) == 0x0000D8, "Member 'UAgentIntroPoseDataAsset::bAllowPlayDelay' has a wrong offset!");
static_assert(offsetof(UAgentIntroPoseDataAsset, SkinSpecificOverride) == 0x0000E0, "Member 'UAgentIntroPoseDataAsset::SkinSpecificOverride' has a wrong offset!");
static_assert(offsetof(UAgentIntroPoseDataAsset, SkeletonSpecificOverride) == 0x000130, "Member 'UAgentIntroPoseDataAsset::SkeletonSpecificOverride' has a wrong offset!");

// Class DeceiveInc.AgentPassiveSkillData
// 0x0120 (0x0158 - 0x0038)
class UAgentPassiveSkillData final : public UDIPrimaryDataAsset
{
public:
	class FText                                   PassiveTitle;                                      // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   PassiveDescLong;                                   // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   PassiveUnlockDesc;                                 // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateBrush                            PassiveIconBrush;                                  // 0x0080(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                PassiveIconTexture;                                // 0x0108(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PassiveSkillClass;                                 // 0x0130(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AgentPassiveSkillData">();
	}
	static class UAgentPassiveSkillData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAgentPassiveSkillData>();
	}
};
static_assert(alignof(UAgentPassiveSkillData) == 0x000008, "Wrong alignment on UAgentPassiveSkillData");
static_assert(sizeof(UAgentPassiveSkillData) == 0x000158, "Wrong size on UAgentPassiveSkillData");
static_assert(offsetof(UAgentPassiveSkillData, PassiveTitle) == 0x000038, "Member 'UAgentPassiveSkillData::PassiveTitle' has a wrong offset!");
static_assert(offsetof(UAgentPassiveSkillData, PassiveDescLong) == 0x000050, "Member 'UAgentPassiveSkillData::PassiveDescLong' has a wrong offset!");
static_assert(offsetof(UAgentPassiveSkillData, PassiveUnlockDesc) == 0x000068, "Member 'UAgentPassiveSkillData::PassiveUnlockDesc' has a wrong offset!");
static_assert(offsetof(UAgentPassiveSkillData, PassiveIconBrush) == 0x000080, "Member 'UAgentPassiveSkillData::PassiveIconBrush' has a wrong offset!");
static_assert(offsetof(UAgentPassiveSkillData, PassiveIconTexture) == 0x000108, "Member 'UAgentPassiveSkillData::PassiveIconTexture' has a wrong offset!");
static_assert(offsetof(UAgentPassiveSkillData, PassiveSkillClass) == 0x000130, "Member 'UAgentPassiveSkillData::PassiveSkillClass' has a wrong offset!");

// Class DeceiveInc.DIBalancingManagerSubsytem
// 0x0008 (0x0038 - 0x0030)
class UDIBalancingManagerSubsytem final : public UGameInstanceSubsystem
{
public:
	class UDIBalancingData*                       BalancingData;                                     // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleAssetLoadCompleted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIBalancingManagerSubsytem">();
	}
	static class UDIBalancingManagerSubsytem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIBalancingManagerSubsytem>();
	}
};
static_assert(alignof(UDIBalancingManagerSubsytem) == 0x000008, "Wrong alignment on UDIBalancingManagerSubsytem");
static_assert(sizeof(UDIBalancingManagerSubsytem) == 0x000038, "Wrong size on UDIBalancingManagerSubsytem");
static_assert(offsetof(UDIBalancingManagerSubsytem, BalancingData) == 0x000030, "Member 'UDIBalancingManagerSubsytem::BalancingData' has a wrong offset!");

// Class DeceiveInc.AgentSkinData
// 0x00D8 (0x0110 - 0x0038)
class UAgentSkinData final : public UDIPrimaryDataAsset
{
public:
	class UAgentData*                             Agent;                                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SpyPawn;                                           // 0x0040(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PosingSpyPawn;                                     // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        IsVariationOf;                                     // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   AgentNameOverride;                                 // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   SkinName;                                          // 0x00B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   SkinUnlockDesc;                                    // 0x00D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         SkinRarity;                                        // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   AgentTaglineOverride;                              // 0x00F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UAgentIntroPoseDataAsset*               MenuPoseOverwrite;                                 // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class FText GetAgentName() const;
	class FText GetAgentTagline() const;
	class UAgentIntroPoseDataAsset* GetDefaultIntroPoseForSkin() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AgentSkinData">();
	}
	static class UAgentSkinData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAgentSkinData>();
	}
};
static_assert(alignof(UAgentSkinData) == 0x000008, "Wrong alignment on UAgentSkinData");
static_assert(sizeof(UAgentSkinData) == 0x000110, "Wrong size on UAgentSkinData");
static_assert(offsetof(UAgentSkinData, Agent) == 0x000038, "Member 'UAgentSkinData::Agent' has a wrong offset!");
static_assert(offsetof(UAgentSkinData, SpyPawn) == 0x000040, "Member 'UAgentSkinData::SpyPawn' has a wrong offset!");
static_assert(offsetof(UAgentSkinData, PosingSpyPawn) == 0x000068, "Member 'UAgentSkinData::PosingSpyPawn' has a wrong offset!");
static_assert(offsetof(UAgentSkinData, IsVariationOf) == 0x000090, "Member 'UAgentSkinData::IsVariationOf' has a wrong offset!");
static_assert(offsetof(UAgentSkinData, AgentNameOverride) == 0x0000A0, "Member 'UAgentSkinData::AgentNameOverride' has a wrong offset!");
static_assert(offsetof(UAgentSkinData, SkinName) == 0x0000B8, "Member 'UAgentSkinData::SkinName' has a wrong offset!");
static_assert(offsetof(UAgentSkinData, SkinUnlockDesc) == 0x0000D0, "Member 'UAgentSkinData::SkinUnlockDesc' has a wrong offset!");
static_assert(offsetof(UAgentSkinData, SkinRarity) == 0x0000E8, "Member 'UAgentSkinData::SkinRarity' has a wrong offset!");
static_assert(offsetof(UAgentSkinData, AgentTaglineOverride) == 0x0000F0, "Member 'UAgentSkinData::AgentTaglineOverride' has a wrong offset!");
static_assert(offsetof(UAgentSkinData, MenuPoseOverwrite) == 0x000108, "Member 'UAgentSkinData::MenuPoseOverwrite' has a wrong offset!");

// Class DeceiveInc.HansPassiveAbility
// 0x0030 (0x0560 - 0x0530)
class AHansPassiveAbility : public ABaseSpyPassiveAbility
{
public:
	FMulticastInlineDelegateProperty_             OnHansPassiveTrigger;                              // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         DetectionHeightOffsetOver;                         // 0x0540(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetectionHeightOffsetUnder;                        // 0x0544(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetectionRadius;                                   // 0x0548(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54C[0x4];                                      // 0x054C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASpy*>                           AffectedSpies;                                     // 0x0550(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void BP_OnHansPassiveTrigger(class ASpy* TriggeredSpy, const TArray<class ASpy*>& TriggeredSpies);
	void MulticastNotifyTriggerHansPassive(class ASpy* AffectedSpy, const TArray<class ASpy*>& TriggeredSpies);
	void OnUndercoverChange(bool Undercover);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HansPassiveAbility">();
	}
	static class AHansPassiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHansPassiveAbility>();
	}
};
static_assert(alignof(AHansPassiveAbility) == 0x000008, "Wrong alignment on AHansPassiveAbility");
static_assert(sizeof(AHansPassiveAbility) == 0x000560, "Wrong size on AHansPassiveAbility");
static_assert(offsetof(AHansPassiveAbility, OnHansPassiveTrigger) == 0x000530, "Member 'AHansPassiveAbility::OnHansPassiveTrigger' has a wrong offset!");
static_assert(offsetof(AHansPassiveAbility, DetectionHeightOffsetOver) == 0x000540, "Member 'AHansPassiveAbility::DetectionHeightOffsetOver' has a wrong offset!");
static_assert(offsetof(AHansPassiveAbility, DetectionHeightOffsetUnder) == 0x000544, "Member 'AHansPassiveAbility::DetectionHeightOffsetUnder' has a wrong offset!");
static_assert(offsetof(AHansPassiveAbility, DetectionRadius) == 0x000548, "Member 'AHansPassiveAbility::DetectionRadius' has a wrong offset!");
static_assert(offsetof(AHansPassiveAbility, AffectedSpies) == 0x000550, "Member 'AHansPassiveAbility::AffectedSpies' has a wrong offset!");

// Class DeceiveInc.HansPassiveAbilityMod1
// 0x0008 (0x0568 - 0x0560)
class AHansPassiveAbilityMod1 final : public AHansPassiveAbility
{
public:
	uint8                                         Pad_560[0x8];                                      // 0x0560(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleCoverBlownEvent(class ASpy* Spy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HansPassiveAbilityMod1">();
	}
	static class AHansPassiveAbilityMod1* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHansPassiveAbilityMod1>();
	}
};
static_assert(alignof(AHansPassiveAbilityMod1) == 0x000008, "Wrong alignment on AHansPassiveAbilityMod1");
static_assert(sizeof(AHansPassiveAbilityMod1) == 0x000568, "Wrong size on AHansPassiveAbilityMod1");

// Class DeceiveInc.AgentWeaponData
// 0x0310 (0x0348 - 0x0038)
class UAgentWeaponData final : public UDIPrimaryDataAsset
{
public:
	class FText                                   WeaponTitleTxt;                                    // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   WeaponDescTxt;                                     // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   WeaponDescTxtLong;                                 // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   WeaponUnlockDesc;                                  // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateBrush                            WeaponIconBrush;                                   // 0x0098(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                WeaponIconTexture;                                 // 0x0120(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   WeaponMagTxt;                                      // 0x0148(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   WeaponReloadTxt;                                   // 0x0160(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bHideSecondaryInfo;                                // 0x0178(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeaponIsDualShot;                                 // 0x0179(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17A[0x6];                                      // 0x017A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DamageTxtOverride;                                 // 0x0180(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   MagSizeTxtOverride;                                // 0x0198(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ReloadTxtOverride;                                 // 0x01B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ReloadSubTxtOverride;                              // 0x01C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   RofTxtOverride;                                    // 0x01E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   RofSubTxtOverride;                                 // 0x01F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   LowerBodyTxtOverride;                              // 0x0210(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   HSTxtOverride;                                     // 0x0228(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UToolWrapData*                          WeaponWrapDataAsset;                               // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           PosingWeaponMesh;                                  // 0x0248(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class USkeletalMesh>>   AdditionalPosingWeaponMesh;                        // 0x0270(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              PosingWeaponAnimationBlueprint;                    // 0x0280(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UAnimInstance>>      AdditionalPosingWeaponAnimationBlueprint;          // 0x0288(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         FullAmmoPack;                                      // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DispenserAmmoPack;                                 // 0x029C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumAmmo;                                       // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   WeaponClass;                                       // 0x02A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SecondaryWeaponClass;                              // 0x02D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   AtlDmgText;                                        // 0x02F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   AtlLowerBodyText;                                  // 0x0310(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   AtlHeadshotText;                                   // 0x0328(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bCanBeUsedByBots;                                  // 0x0340(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AgentWeaponData">();
	}
	static class UAgentWeaponData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAgentWeaponData>();
	}
};
static_assert(alignof(UAgentWeaponData) == 0x000008, "Wrong alignment on UAgentWeaponData");
static_assert(sizeof(UAgentWeaponData) == 0x000348, "Wrong size on UAgentWeaponData");
static_assert(offsetof(UAgentWeaponData, WeaponTitleTxt) == 0x000038, "Member 'UAgentWeaponData::WeaponTitleTxt' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, WeaponDescTxt) == 0x000050, "Member 'UAgentWeaponData::WeaponDescTxt' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, WeaponDescTxtLong) == 0x000068, "Member 'UAgentWeaponData::WeaponDescTxtLong' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, WeaponUnlockDesc) == 0x000080, "Member 'UAgentWeaponData::WeaponUnlockDesc' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, WeaponIconBrush) == 0x000098, "Member 'UAgentWeaponData::WeaponIconBrush' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, WeaponIconTexture) == 0x000120, "Member 'UAgentWeaponData::WeaponIconTexture' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, WeaponMagTxt) == 0x000148, "Member 'UAgentWeaponData::WeaponMagTxt' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, WeaponReloadTxt) == 0x000160, "Member 'UAgentWeaponData::WeaponReloadTxt' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, bHideSecondaryInfo) == 0x000178, "Member 'UAgentWeaponData::bHideSecondaryInfo' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, bWeaponIsDualShot) == 0x000179, "Member 'UAgentWeaponData::bWeaponIsDualShot' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, DamageTxtOverride) == 0x000180, "Member 'UAgentWeaponData::DamageTxtOverride' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, MagSizeTxtOverride) == 0x000198, "Member 'UAgentWeaponData::MagSizeTxtOverride' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, ReloadTxtOverride) == 0x0001B0, "Member 'UAgentWeaponData::ReloadTxtOverride' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, ReloadSubTxtOverride) == 0x0001C8, "Member 'UAgentWeaponData::ReloadSubTxtOverride' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, RofTxtOverride) == 0x0001E0, "Member 'UAgentWeaponData::RofTxtOverride' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, RofSubTxtOverride) == 0x0001F8, "Member 'UAgentWeaponData::RofSubTxtOverride' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, LowerBodyTxtOverride) == 0x000210, "Member 'UAgentWeaponData::LowerBodyTxtOverride' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, HSTxtOverride) == 0x000228, "Member 'UAgentWeaponData::HSTxtOverride' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, WeaponWrapDataAsset) == 0x000240, "Member 'UAgentWeaponData::WeaponWrapDataAsset' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, PosingWeaponMesh) == 0x000248, "Member 'UAgentWeaponData::PosingWeaponMesh' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, AdditionalPosingWeaponMesh) == 0x000270, "Member 'UAgentWeaponData::AdditionalPosingWeaponMesh' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, PosingWeaponAnimationBlueprint) == 0x000280, "Member 'UAgentWeaponData::PosingWeaponAnimationBlueprint' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, AdditionalPosingWeaponAnimationBlueprint) == 0x000288, "Member 'UAgentWeaponData::AdditionalPosingWeaponAnimationBlueprint' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, FullAmmoPack) == 0x000298, "Member 'UAgentWeaponData::FullAmmoPack' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, DispenserAmmoPack) == 0x00029C, "Member 'UAgentWeaponData::DispenserAmmoPack' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, MaximumAmmo) == 0x0002A0, "Member 'UAgentWeaponData::MaximumAmmo' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, WeaponClass) == 0x0002A8, "Member 'UAgentWeaponData::WeaponClass' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, SecondaryWeaponClass) == 0x0002D0, "Member 'UAgentWeaponData::SecondaryWeaponClass' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, AtlDmgText) == 0x0002F8, "Member 'UAgentWeaponData::AtlDmgText' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, AtlLowerBodyText) == 0x000310, "Member 'UAgentWeaponData::AtlLowerBodyText' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, AtlHeadshotText) == 0x000328, "Member 'UAgentWeaponData::AtlHeadshotText' has a wrong offset!");
static_assert(offsetof(UAgentWeaponData, bCanBeUsedByBots) == 0x000340, "Member 'UAgentWeaponData::bCanBeUsedByBots' has a wrong offset!");

// Class DeceiveInc.HumanPawn
// 0x0000 (0x0028 - 0x0028)
class IHumanPawn final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanPawn">();
	}
	static class IHumanPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHumanPawn>();
	}
};
static_assert(alignof(IHumanPawn) == 0x000008, "Wrong alignment on IHumanPawn");
static_assert(sizeof(IHumanPawn) == 0x000028, "Wrong size on IHumanPawn");

// Class DeceiveInc.AgonesDedicatedServerManager
// 0x0040 (0x0140 - 0x0100)
class UAgonesDedicatedServerManager final : public UDIDedicatedServerManager
{
public:
	class UAgonesComponent*                       AgonesSDK;                                         // 0x0100(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x38];                                     // 0x0108(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AgonesErrorHandler(const struct FAgonesError& Error);
	void ReadySuccessHandler(const struct FEmptyResponse& Response);
	void ShutdownSuccessHandler(const struct FEmptyResponse& Response);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AgonesDedicatedServerManager">();
	}
	static class UAgonesDedicatedServerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAgonesDedicatedServerManager>();
	}
};
static_assert(alignof(UAgonesDedicatedServerManager) == 0x000008, "Wrong alignment on UAgonesDedicatedServerManager");
static_assert(sizeof(UAgonesDedicatedServerManager) == 0x000140, "Wrong size on UAgonesDedicatedServerManager");
static_assert(offsetof(UAgonesDedicatedServerManager, AgonesSDK) == 0x000100, "Member 'UAgonesDedicatedServerManager::AgonesSDK' has a wrong offset!");

// Class DeceiveInc.AMSDedicatedServerManager
// 0x0110 (0x0210 - 0x0100)
class UAMSDedicatedServerManager final : public UDIDedicatedServerManager
{
public:
	uint8                                         Pad_100[0x110];                                    // 0x0100(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AMSDedicatedServerManager">();
	}
	static class UAMSDedicatedServerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAMSDedicatedServerManager>();
	}
};
static_assert(alignof(UAMSDedicatedServerManager) == 0x000008, "Wrong alignment on UAMSDedicatedServerManager");
static_assert(sizeof(UAMSDedicatedServerManager) == 0x000210, "Wrong size on UAMSDedicatedServerManager");

// Class DeceiveInc.DeceiveIncGameStateBase
// 0x0298 (0x0528 - 0x0290)
class ADeceiveIncGameStateBase : public AGameState
{
public:
	FMulticastInlineDelegateProperty_             OnMatchStateChanged;                               // 0x0290(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMatchResultsPosted;                              // 0x02A0(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPhaseTimeTick;                                   // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerStateArrayModified;                        // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerStateJoin;                                 // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerStateLeave;                                // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVaultTerminalDeactivation;                       // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 PS5MatchId;                                        // 0x0300(0x0010)(Net, ZeroConstructor, Transient, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPS5MatchIdUpdated;                               // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FUniqueNetIdRepl                       PS5MatchResponsiblePlayer;                         // 0x0320(0x0028)(Net, Transient, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_348[0x10];                                     // 0x0348(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseGamePhaseInfo*                     CurrentPhaseInfo;                                  // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_360[0x4];                                      // 0x0360(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentPhaseElapsedTime;                           // 0x0364(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDIGameRuleset                                CurrentRuleset;                                    // 0x0368(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDIGameMode                                   CurrentGameModeType;                               // 0x0369(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36A[0x6];                                      // 0x036A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionAuthorityComponent*         InteractionAuthorityComponent;                     // 0x0370(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScanAuthorityComponent*                ScanAuthorityComponent;                            // 0x0378(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPowerupManagerComponent*               PowerupManagerComponent;                           // 0x0380(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFactionData                           ReplicatedFactionData;                             // 0x0388(0x0028)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0xD0];                                     // 0x03B0(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADIPlayerState*>                 InactivePlayerStates;                              // 0x0480(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class FString                                 ServerRegion;                                      // 0x0490(0x0010)(Net, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ServerVersion;                                     // 0x04A0(0x0010)(Net, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ServerPerformance;                                 // 0x04B0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B4[0x4];                                      // 0x04B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCommunityTrackers                     TotalCommunityTrackers;                            // 0x04B8(0x0030)(Net, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E8[0x40];                                     // 0x04E8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTimeToPhase(int32 SecondsToAdd);
	bool CanGiveXpEvent();
	void CheatSkipCurrentPhase();
	TArray<struct FXpTypeEventGroupDisplayInfo> GetAllXpEventDisplayInfoForPlayer(class ADIPlayerState* DIPlayerState);
	class FString GetCommunityTrackerFromKey(const class FString& Key);
	class UMapData* GetCurrentMapData();
	class UBaseGamePhaseInfo* GetCurrentPhaseInfo();
	class FText GetDisplayNameForXPEvent(EDIXPEvent XPEventType);
	TArray<class FString> GetEventSpecificXpTypeToAffect(EDIXPEvent XPEventType);
	int32 GetLevelForXpValue(int32 CurrentLevel, int32 XPTotal, EXpProgressionType ProgressionType);
	TArray<class FString> GetMultiplicatorEventSpecificXpTypeToAffect(EDIXPEvent XPEventType);
	class FText GetNextMapName();
	int32 GetProgressionMaxLevel(EXpProgressionType ProgressionType);
	float GetProgressionPercent(int32 CurrentLevel, int32 XPTotal, EXpProgressionType ProgressionType);
	int32 GetRequiredXPForLevel(int32 Level, EXpProgressionType ProgressionType);
	TMap<class FString, struct FXpEventGroupDisplayInfo> GetXpEventDisplayInfoForPlayer(class ADIPlayerState* DIPlayerState);
	TMap<class FString, struct FXpEventGroupDisplayInfo> GetXpMultiplicatorEventDisplayInfoForPlayer(class ADIPlayerState* DIPlayerState);
	float GetXpMultiplicatorValueForEvent(EDIXPEvent XPEventType);
	int32 GetXpValueForEvent(EDIXPEvent XPEventType);
	void HandleCommunityTrackerEvent(EDICommunityTrackerEvent CommunityTrackerEventType, int32 EventAmount);
	void HandleSpyDespawnedEvent(class ASpy* Spy);
	void HandleSpySpawnedEvent(class ASpy* Spy);
	void HandleVaultTerminalDeactivation(class ADIPlayerState* DIPlayerState);
	void HandleXPEvent(class ADIPlayerState* DIPlayerState, EDIXPEvent XPEventType, int32 EventAmount);
	void IncrementVaultDeactivationCount(class ADIPlayerState* DIPlayerState);
	bool IsPrivateLobbyMatch();
	bool IsXpEventAffectingRegularXpType(EDIXPEvent XPEventType);
	bool IsXpEventSharedToFaction(EDIXPEvent XPEventType);
	bool IsXpMultiplicatorEventAffectingRegularXpType(EDIXPEvent XPEventType);
	void LockPlayerControlsMulticast(bool bLock);
	void NetMulticast_SignalGlobalEventToClients(EGameStateClientEventType ClientEvent);
	void NetMulticast_SignalVaultTerminalDeactivationToClient(class ADIPlayerState* PlayerState, int32 FactionID);
	void OnRep_CurrentGameModeType();
	void OnRep_CurrentPhaseElapsedTime(int32 OldValue);
	void OnRep_CurrentRuleset();
	void OnRep_FactionData();
	void OnRep_PS5MatchId();
	void OnRep_PS5MatchResponsiblePlayer();
	void SetCurrentPhaseTimeLeftInSeconds(int32 SecondsLeft);
	void SetPauseTimer(bool bPause);

	class FString GetCurrentLimitedEventId() const;
	int32 GetCurrentPhaseTimeLeftInSeconds() const;
	int32 GetMaximumPlayerCountForCurrentMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeceiveIncGameStateBase">();
	}
	static class ADeceiveIncGameStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeceiveIncGameStateBase>();
	}
};
static_assert(alignof(ADeceiveIncGameStateBase) == 0x000008, "Wrong alignment on ADeceiveIncGameStateBase");
static_assert(sizeof(ADeceiveIncGameStateBase) == 0x000528, "Wrong size on ADeceiveIncGameStateBase");
static_assert(offsetof(ADeceiveIncGameStateBase, OnMatchStateChanged) == 0x000290, "Member 'ADeceiveIncGameStateBase::OnMatchStateChanged' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameStateBase, OnMatchResultsPosted) == 0x0002A0, "Member 'ADeceiveIncGameStateBase::OnMatchResultsPosted' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameStateBase, OnPhaseTimeTick) == 0x0002B0, "Member 'ADeceiveIncGameStateBase::OnPhaseTimeTick' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameStateBase, OnPlayerStateArrayModified) == 0x0002C0, "Member 'ADeceiveIncGameStateBase::OnPlayerStateArrayModified' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameStateBase, OnPlayerStateJoin) == 0x0002D0, "Member 'ADeceiveIncGameStateBase::OnPlayerStateJoin' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameStateBase, OnPlayerStateLeave) == 0x0002E0, "Member 'ADeceiveIncGameStateBase::OnPlayerStateLeave' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameStateBase, OnVaultTerminalDeactivation) == 0x0002F0, "Member 'ADeceiveIncGameStateBase::OnVaultTerminalDeactivation' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameStateBase, PS5MatchId) == 0x000300, "Member 'ADeceiveIncGameStateBase::PS5MatchId' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameStateBase, OnPS5MatchIdUpdated) == 0x000310, "Member 'ADeceiveIncGameStateBase::OnPS5MatchIdUpdated' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameStateBase, PS5MatchResponsiblePlayer) == 0x000320, "Member 'ADeceiveIncGameStateBase::PS5MatchResponsiblePlayer' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameStateBase, CurrentPhaseInfo) == 0x000358, "Member 'ADeceiveIncGameStateBase::CurrentPhaseInfo' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameStateBase, CurrentPhaseElapsedTime) == 0x000364, "Member 'ADeceiveIncGameStateBase::CurrentPhaseElapsedTime' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameStateBase, CurrentRuleset) == 0x000368, "Member 'ADeceiveIncGameStateBase::CurrentRuleset' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameStateBase, CurrentGameModeType) == 0x000369, "Member 'ADeceiveIncGameStateBase::CurrentGameModeType' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameStateBase, InteractionAuthorityComponent) == 0x000370, "Member 'ADeceiveIncGameStateBase::InteractionAuthorityComponent' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameStateBase, ScanAuthorityComponent) == 0x000378, "Member 'ADeceiveIncGameStateBase::ScanAuthorityComponent' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameStateBase, PowerupManagerComponent) == 0x000380, "Member 'ADeceiveIncGameStateBase::PowerupManagerComponent' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameStateBase, ReplicatedFactionData) == 0x000388, "Member 'ADeceiveIncGameStateBase::ReplicatedFactionData' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameStateBase, InactivePlayerStates) == 0x000480, "Member 'ADeceiveIncGameStateBase::InactivePlayerStates' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameStateBase, ServerRegion) == 0x000490, "Member 'ADeceiveIncGameStateBase::ServerRegion' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameStateBase, ServerVersion) == 0x0004A0, "Member 'ADeceiveIncGameStateBase::ServerVersion' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameStateBase, ServerPerformance) == 0x0004B0, "Member 'ADeceiveIncGameStateBase::ServerPerformance' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameStateBase, TotalCommunityTrackers) == 0x0004B8, "Member 'ADeceiveIncGameStateBase::TotalCommunityTrackers' has a wrong offset!");

// Class DeceiveInc.DeceiveIncMatchGameState
// 0x0320 (0x0848 - 0x0528)
class ADeceiveIncMatchGameState : public ADeceiveIncGameStateBase
{
public:
	FMulticastInlineDelegateProperty_             OnPregameLobbyGamePhaseStart;                      // 0x0528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPregameLobbyLoadPending;                         // 0x0538(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FPregameLobbySessionInfo               PregameLobbySessionInfo;                           // 0x0548(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, EditConst, RepNotify, Protected, NativeAccessSpecifierProtected)
	class UDamageModifier*                        InvulnerabilityInstance;                           // 0x0570(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnGamePhaseChanged;                                // 0x0578(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIntroPhaseStart;                                 // 0x0588(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVaultLockedPhaseStart;                           // 0x0598(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVaultUnlockedPhaseStart;                         // 0x05A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExtractionArrivingPhaseStart;                    // 0x05B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExtractionArrivedPhaseStart;                     // 0x05C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnResultScreenPhaseStart;                          // 0x05D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnObjectiveDropped;                                // 0x05E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnObjectivePicked;                                 // 0x05F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnObjectiveDroppedLocal;                           // 0x0608(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnObjectivePickedLocal;                            // 0x0618(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnObjectivePing;                                   // 0x0628(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExtractionPointSet;                              // 0x0638(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNewExtraction;                                   // 0x0648(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyExtractingChange;                             // 0x0658(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCriticalTime;                                    // 0x0668(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMatchResultUpdate;                               // 0x0678(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExtractionOnTheWay;                              // 0x0688(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExtractionMovedCompleted;                        // 0x0698(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExtractionArrived;                               // 0x06A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVaultTerminalUnlockedCountChanged;               // 0x06B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FSpyGameSessionInfo                    SpyGameSessionInfo;                                // 0x06C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, EditConst, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6F0[0x1];                                      // 0x06F0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	ESpyGamePhase                                 GamePhase;                                         // 0x06F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6F2[0x6];                                      // 0x06F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AExtractionInteractableActor*           ExtractionPoint;                                   // 0x06F8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AExtractionInteractableActor*           PreviousExtractionPoint;                           // 0x0700(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         ExtractPoints;                                     // 0x0708(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         ExtractTerminals;                                  // 0x0718(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bExtractionRequested;                              // 0x0728(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_729[0x7];                                      // 0x0729(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         BurnedExtracts;                                    // 0x0730(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bExtractionOnTheWay;                               // 0x0740(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_741[0x3];                                      // 0x0741(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArrivalTimeNextCar;                                // 0x0744(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayTimeNextCar;                                  // 0x0748(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74C[0x4];                                      // 0x074C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AEncounterManager*                      EncounterManager;                                  // 0x0750(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADIPlayerState*                         ExtractedPlayer;                                   // 0x0758(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASpectatorManager*                      SpectatorManager;                                  // 0x0760(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASpy*                                   ObjectiveCarrier;                                  // 0x0768(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_770[0x8];                                      // 0x0770(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ADIPlayerState*                         LastManStanding;                                   // 0x0778(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_780[0x1];                                      // 0x0780(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bExfilLastManStarted;                              // 0x0781(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMatchResult                                  MatchResult;                                       // 0x0782(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_783[0x9];                                      // 0x0783(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsInPregame;                                      // 0x078C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78D[0x13];                                     // 0x078D(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	class UMapData*                               CachedMapData;                                     // 0x07A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpyGameModeMapData*                    CachedSpyGameModeMapData;                          // 0x07A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ASBCollisionPatch*>              ColPatches;                                        // 0x07B0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FSandboxSettings                       SandboxSettings;                                   // 0x07C0(0x0080)(Net, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_840[0x8];                                      // 0x0840(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AdvancePhase(bool bViaTimer);
	EDIGameMode GetGameMode();
	void HandleNewSpyLoadoutCompleted(class UToolLoadoutComponent* ToolLoadout);
	bool IsInPregamePhase();
	void OnExtractionArrivedMulticast();
	void OnExtractionOnTheWayMulticast();
	void OnRep_ColPatches();
	void OnRep_Extraction();
	void OnRep_MatchResult(EMatchResult PreviousResult);
	void OnRep_ObjectiveCarrier(class ASpy* OldValue);
	void OnRep_PregameLobbySessionInfo();
	void OnRep_SpyGamePhase();
	void OnRep_SpyGameSessionInfo();
	void SetVaultTerminalUnlockedCount(int32 NewCount);
	void SetVaultTerminalUnlockedRequirementCount(int32 NewCount);
	bool ShouldShowTimer();

	int32 GetCurrentGamePhaseTimeLeft() const;
	class ADIPlayerState* GetPlayerExtracted() const;
	int32 GetTimeLeftforHUD() const;
	int32 GetVaultTerminalUnlockedCount() const;
	int32 GetVaultTerminalUnlockedRequirementCount() const;
	bool HasReachedVaultTerminalUnlockedRequirement() const;
	bool IsMatchFinished() const;
	bool IsMatchOnGoing() const;
	bool IsOnlyBotsAreAlive() const;
	bool IsSandboxGame() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeceiveIncMatchGameState">();
	}
	static class ADeceiveIncMatchGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeceiveIncMatchGameState>();
	}
};
static_assert(alignof(ADeceiveIncMatchGameState) == 0x000008, "Wrong alignment on ADeceiveIncMatchGameState");
static_assert(sizeof(ADeceiveIncMatchGameState) == 0x000848, "Wrong size on ADeceiveIncMatchGameState");
static_assert(offsetof(ADeceiveIncMatchGameState, OnPregameLobbyGamePhaseStart) == 0x000528, "Member 'ADeceiveIncMatchGameState::OnPregameLobbyGamePhaseStart' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, OnPregameLobbyLoadPending) == 0x000538, "Member 'ADeceiveIncMatchGameState::OnPregameLobbyLoadPending' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, PregameLobbySessionInfo) == 0x000548, "Member 'ADeceiveIncMatchGameState::PregameLobbySessionInfo' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, InvulnerabilityInstance) == 0x000570, "Member 'ADeceiveIncMatchGameState::InvulnerabilityInstance' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, OnGamePhaseChanged) == 0x000578, "Member 'ADeceiveIncMatchGameState::OnGamePhaseChanged' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, OnIntroPhaseStart) == 0x000588, "Member 'ADeceiveIncMatchGameState::OnIntroPhaseStart' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, OnVaultLockedPhaseStart) == 0x000598, "Member 'ADeceiveIncMatchGameState::OnVaultLockedPhaseStart' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, OnVaultUnlockedPhaseStart) == 0x0005A8, "Member 'ADeceiveIncMatchGameState::OnVaultUnlockedPhaseStart' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, OnExtractionArrivingPhaseStart) == 0x0005B8, "Member 'ADeceiveIncMatchGameState::OnExtractionArrivingPhaseStart' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, OnExtractionArrivedPhaseStart) == 0x0005C8, "Member 'ADeceiveIncMatchGameState::OnExtractionArrivedPhaseStart' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, OnResultScreenPhaseStart) == 0x0005D8, "Member 'ADeceiveIncMatchGameState::OnResultScreenPhaseStart' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, OnObjectiveDropped) == 0x0005E8, "Member 'ADeceiveIncMatchGameState::OnObjectiveDropped' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, OnObjectivePicked) == 0x0005F8, "Member 'ADeceiveIncMatchGameState::OnObjectivePicked' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, OnObjectiveDroppedLocal) == 0x000608, "Member 'ADeceiveIncMatchGameState::OnObjectiveDroppedLocal' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, OnObjectivePickedLocal) == 0x000618, "Member 'ADeceiveIncMatchGameState::OnObjectivePickedLocal' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, OnObjectivePing) == 0x000628, "Member 'ADeceiveIncMatchGameState::OnObjectivePing' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, OnExtractionPointSet) == 0x000638, "Member 'ADeceiveIncMatchGameState::OnExtractionPointSet' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, OnNewExtraction) == 0x000648, "Member 'ADeceiveIncMatchGameState::OnNewExtraction' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, OnSpyExtractingChange) == 0x000658, "Member 'ADeceiveIncMatchGameState::OnSpyExtractingChange' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, OnCriticalTime) == 0x000668, "Member 'ADeceiveIncMatchGameState::OnCriticalTime' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, OnMatchResultUpdate) == 0x000678, "Member 'ADeceiveIncMatchGameState::OnMatchResultUpdate' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, OnExtractionOnTheWay) == 0x000688, "Member 'ADeceiveIncMatchGameState::OnExtractionOnTheWay' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, OnExtractionMovedCompleted) == 0x000698, "Member 'ADeceiveIncMatchGameState::OnExtractionMovedCompleted' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, OnExtractionArrived) == 0x0006A8, "Member 'ADeceiveIncMatchGameState::OnExtractionArrived' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, OnVaultTerminalUnlockedCountChanged) == 0x0006B8, "Member 'ADeceiveIncMatchGameState::OnVaultTerminalUnlockedCountChanged' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, SpyGameSessionInfo) == 0x0006C8, "Member 'ADeceiveIncMatchGameState::SpyGameSessionInfo' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, GamePhase) == 0x0006F1, "Member 'ADeceiveIncMatchGameState::GamePhase' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, ExtractionPoint) == 0x0006F8, "Member 'ADeceiveIncMatchGameState::ExtractionPoint' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, PreviousExtractionPoint) == 0x000700, "Member 'ADeceiveIncMatchGameState::PreviousExtractionPoint' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, ExtractPoints) == 0x000708, "Member 'ADeceiveIncMatchGameState::ExtractPoints' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, ExtractTerminals) == 0x000718, "Member 'ADeceiveIncMatchGameState::ExtractTerminals' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, bExtractionRequested) == 0x000728, "Member 'ADeceiveIncMatchGameState::bExtractionRequested' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, BurnedExtracts) == 0x000730, "Member 'ADeceiveIncMatchGameState::BurnedExtracts' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, bExtractionOnTheWay) == 0x000740, "Member 'ADeceiveIncMatchGameState::bExtractionOnTheWay' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, ArrivalTimeNextCar) == 0x000744, "Member 'ADeceiveIncMatchGameState::ArrivalTimeNextCar' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, DelayTimeNextCar) == 0x000748, "Member 'ADeceiveIncMatchGameState::DelayTimeNextCar' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, EncounterManager) == 0x000750, "Member 'ADeceiveIncMatchGameState::EncounterManager' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, ExtractedPlayer) == 0x000758, "Member 'ADeceiveIncMatchGameState::ExtractedPlayer' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, SpectatorManager) == 0x000760, "Member 'ADeceiveIncMatchGameState::SpectatorManager' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, ObjectiveCarrier) == 0x000768, "Member 'ADeceiveIncMatchGameState::ObjectiveCarrier' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, LastManStanding) == 0x000778, "Member 'ADeceiveIncMatchGameState::LastManStanding' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, bExfilLastManStarted) == 0x000781, "Member 'ADeceiveIncMatchGameState::bExfilLastManStarted' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, MatchResult) == 0x000782, "Member 'ADeceiveIncMatchGameState::MatchResult' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, bIsInPregame) == 0x00078C, "Member 'ADeceiveIncMatchGameState::bIsInPregame' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, CachedMapData) == 0x0007A0, "Member 'ADeceiveIncMatchGameState::CachedMapData' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, CachedSpyGameModeMapData) == 0x0007A8, "Member 'ADeceiveIncMatchGameState::CachedSpyGameModeMapData' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, ColPatches) == 0x0007B0, "Member 'ADeceiveIncMatchGameState::ColPatches' has a wrong offset!");
static_assert(offsetof(ADeceiveIncMatchGameState, SandboxSettings) == 0x0007C0, "Member 'ADeceiveIncMatchGameState::SandboxSettings' has a wrong offset!");

// Class DeceiveInc.DeceiveIncPreGameState
// 0x0000 (0x0848 - 0x0848)
class ADeceiveIncPreGameState final : public ADeceiveIncMatchGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeceiveIncPreGameState">();
	}
	static class ADeceiveIncPreGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeceiveIncPreGameState>();
	}
};
static_assert(alignof(ADeceiveIncPreGameState) == 0x000008, "Wrong alignment on ADeceiveIncPreGameState");
static_assert(sizeof(ADeceiveIncPreGameState) == 0x000848, "Wrong size on ADeceiveIncPreGameState");

// Class DeceiveInc.AnalogCursorSettings
// 0x00E0 (0x0118 - 0x0038)
class UAnalogCursorSettings final : public UDeveloperSettings
{
public:
	struct FRuntimeFloatCurve                     AnalogCursorAccelerationCurve;                     // 0x0038(0x0088)(Edit, Config, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UMaterialParameterCollection> MaterialParams;                                    // 0x00C0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxAnalogCursorSpeed;                              // 0x00E8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxAnalogCursorSpeedWhenHovered;                   // 0x00EC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnalogCursorDragCoefficient;                       // 0x00F0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnalogCursorDragCoefficientWhenHovered;            // 0x00F4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinAnalogCursorSpeed;                              // 0x00F8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnalogCursorDeadZone;                              // 0x00FC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnalogCursorVerticalDeadZone;                      // 0x0100(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnalogCursorHorizontalDeadZone;                    // 0x0104(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnalogCursorAccelerationMultiplier;                // 0x0108(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnalogCursorSize;                                  // 0x010C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnalogCursorScrollSpeed;                           // 0x0110(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseEngineAnalogCursor;                            // 0x0114(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAnalogCursorKeepMomentum;                         // 0x0115(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_116[0x2];                                      // 0x0116(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnalogCursorSettings">();
	}
	static class UAnalogCursorSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnalogCursorSettings>();
	}
};
static_assert(alignof(UAnalogCursorSettings) == 0x000008, "Wrong alignment on UAnalogCursorSettings");
static_assert(sizeof(UAnalogCursorSettings) == 0x000118, "Wrong size on UAnalogCursorSettings");
static_assert(offsetof(UAnalogCursorSettings, AnalogCursorAccelerationCurve) == 0x000038, "Member 'UAnalogCursorSettings::AnalogCursorAccelerationCurve' has a wrong offset!");
static_assert(offsetof(UAnalogCursorSettings, MaterialParams) == 0x0000C0, "Member 'UAnalogCursorSettings::MaterialParams' has a wrong offset!");
static_assert(offsetof(UAnalogCursorSettings, MaxAnalogCursorSpeed) == 0x0000E8, "Member 'UAnalogCursorSettings::MaxAnalogCursorSpeed' has a wrong offset!");
static_assert(offsetof(UAnalogCursorSettings, MaxAnalogCursorSpeedWhenHovered) == 0x0000EC, "Member 'UAnalogCursorSettings::MaxAnalogCursorSpeedWhenHovered' has a wrong offset!");
static_assert(offsetof(UAnalogCursorSettings, AnalogCursorDragCoefficient) == 0x0000F0, "Member 'UAnalogCursorSettings::AnalogCursorDragCoefficient' has a wrong offset!");
static_assert(offsetof(UAnalogCursorSettings, AnalogCursorDragCoefficientWhenHovered) == 0x0000F4, "Member 'UAnalogCursorSettings::AnalogCursorDragCoefficientWhenHovered' has a wrong offset!");
static_assert(offsetof(UAnalogCursorSettings, MinAnalogCursorSpeed) == 0x0000F8, "Member 'UAnalogCursorSettings::MinAnalogCursorSpeed' has a wrong offset!");
static_assert(offsetof(UAnalogCursorSettings, AnalogCursorDeadZone) == 0x0000FC, "Member 'UAnalogCursorSettings::AnalogCursorDeadZone' has a wrong offset!");
static_assert(offsetof(UAnalogCursorSettings, AnalogCursorVerticalDeadZone) == 0x000100, "Member 'UAnalogCursorSettings::AnalogCursorVerticalDeadZone' has a wrong offset!");
static_assert(offsetof(UAnalogCursorSettings, AnalogCursorHorizontalDeadZone) == 0x000104, "Member 'UAnalogCursorSettings::AnalogCursorHorizontalDeadZone' has a wrong offset!");
static_assert(offsetof(UAnalogCursorSettings, AnalogCursorAccelerationMultiplier) == 0x000108, "Member 'UAnalogCursorSettings::AnalogCursorAccelerationMultiplier' has a wrong offset!");
static_assert(offsetof(UAnalogCursorSettings, AnalogCursorSize) == 0x00010C, "Member 'UAnalogCursorSettings::AnalogCursorSize' has a wrong offset!");
static_assert(offsetof(UAnalogCursorSettings, AnalogCursorScrollSpeed) == 0x000110, "Member 'UAnalogCursorSettings::AnalogCursorScrollSpeed' has a wrong offset!");
static_assert(offsetof(UAnalogCursorSettings, bUseEngineAnalogCursor) == 0x000114, "Member 'UAnalogCursorSettings::bUseEngineAnalogCursor' has a wrong offset!");
static_assert(offsetof(UAnalogCursorSettings, bAnalogCursorKeepMomentum) == 0x000115, "Member 'UAnalogCursorSettings::bAnalogCursorKeepMomentum' has a wrong offset!");

// Class DeceiveInc.DeceiveIncBotController
// 0x0158 (0x0480 - 0x0328)
class ADeceiveIncBotController : public AAIController
{
public:
	uint8                                         Pad_328[0xC0];                                     // 0x0328(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	class UBotBrain*                              Brain;                                             // 0x03E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayBotBrainDataAsset*             GameplayBotBrainParams;                            // 0x03F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBotPlanProgressFlowDataAsset*          PlanProgressFlowParams;                            // 0x03F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    DebugTextRenderComponent;                          // 0x0400(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBotPlanFightDataAsset*                 PlanFightParams;                                   // 0x0408(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EBotBrainType, class UBotPlanFightDataAsset*> PlanFightParamsBrainOverwrite;                     // 0x0410(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UBotPlanFightDataAsset*                 UsedPlanFightParams;                               // 0x0460(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_468[0x18];                                     // 0x0468(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSpyDeath(class ASpy* Spy);
	void ScriptedAggroLocalPlayer();
	class UBotAction* ScriptedMoveTo(const struct FVector& MovePosition);
	void ScriptedTriggerActiveAbility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeceiveIncBotController">();
	}
	static class ADeceiveIncBotController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeceiveIncBotController>();
	}
};
static_assert(alignof(ADeceiveIncBotController) == 0x000008, "Wrong alignment on ADeceiveIncBotController");
static_assert(sizeof(ADeceiveIncBotController) == 0x000480, "Wrong size on ADeceiveIncBotController");
static_assert(offsetof(ADeceiveIncBotController, Brain) == 0x0003E8, "Member 'ADeceiveIncBotController::Brain' has a wrong offset!");
static_assert(offsetof(ADeceiveIncBotController, GameplayBotBrainParams) == 0x0003F0, "Member 'ADeceiveIncBotController::GameplayBotBrainParams' has a wrong offset!");
static_assert(offsetof(ADeceiveIncBotController, PlanProgressFlowParams) == 0x0003F8, "Member 'ADeceiveIncBotController::PlanProgressFlowParams' has a wrong offset!");
static_assert(offsetof(ADeceiveIncBotController, DebugTextRenderComponent) == 0x000400, "Member 'ADeceiveIncBotController::DebugTextRenderComponent' has a wrong offset!");
static_assert(offsetof(ADeceiveIncBotController, PlanFightParams) == 0x000408, "Member 'ADeceiveIncBotController::PlanFightParams' has a wrong offset!");
static_assert(offsetof(ADeceiveIncBotController, PlanFightParamsBrainOverwrite) == 0x000410, "Member 'ADeceiveIncBotController::PlanFightParamsBrainOverwrite' has a wrong offset!");
static_assert(offsetof(ADeceiveIncBotController, UsedPlanFightParams) == 0x000460, "Member 'ADeceiveIncBotController::UsedPlanFightParams' has a wrong offset!");

// Class DeceiveInc.DeceiveIncPlayerBotController
// 0x0000 (0x0480 - 0x0480)
class ADeceiveIncPlayerBotController final : public ADeceiveIncBotController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeceiveIncPlayerBotController">();
	}
	static class ADeceiveIncPlayerBotController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeceiveIncPlayerBotController>();
	}
};
static_assert(alignof(ADeceiveIncPlayerBotController) == 0x000008, "Wrong alignment on ADeceiveIncPlayerBotController");
static_assert(sizeof(ADeceiveIncPlayerBotController) == 0x000480, "Wrong size on ADeceiveIncPlayerBotController");

// Class DeceiveInc.AnalogCursorSubsystem
// 0x0010 (0x0040 - 0x0030)
class UAnalogCursorSubsystem final : public ULocalPlayerSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void Global_DisableVirtualCursor(class APlayerController* PC);
	static void Global_EnableVirtualCursor(class APlayerController* PC);
	static bool Global_IsCursorOverInteractableWidget(class APlayerController* PC);

	void DisableAnalogCursor();
	void EnableAnalogCursor();

	bool ContainsGamepadCursorInputProcessor() const;
	bool IsCursorOverInteractableWidget() const;
	bool IsCursorValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnalogCursorSubsystem">();
	}
	static class UAnalogCursorSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnalogCursorSubsystem>();
	}
};
static_assert(alignof(UAnalogCursorSubsystem) == 0x000008, "Wrong alignment on UAnalogCursorSubsystem");
static_assert(sizeof(UAnalogCursorSubsystem) == 0x000040, "Wrong size on UAnalogCursorSubsystem");

// Class DeceiveInc.AnnouncementInstance
// 0x0058 (0x0080 - 0x0028)
class UAnnouncementInstance final : public UObject
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHideTimerEnd();
	void OnTimerEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnnouncementInstance">();
	}
	static class UAnnouncementInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnnouncementInstance>();
	}
};
static_assert(alignof(UAnnouncementInstance) == 0x000008, "Wrong alignment on UAnnouncementInstance");
static_assert(sizeof(UAnnouncementInstance) == 0x000080, "Wrong size on UAnnouncementInstance");

// Class DeceiveInc.AnnouncementSubsystem
// 0x0068 (0x0098 - 0x0030)
class UAnnouncementSubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnShowAnnouncementDelegate;                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHideAnnouncementDelegate;                        // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnClearAnnouncementGroupDelegate;                  // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAnnouncementInstance*                  DisplayedInstances[0x2];                           // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x28];                                      // 0x0070(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ClearAnnouncementGroup(class AActor* CallerActor, EAnnouncementGroup Group);
	static void ConfirmAnnouncementHidden(class AActor* CallerActor, int32 AnnouncementInstanceID);
	static void ShowAnnouncement(class AActor* CallerActor, const class FText& TextToDisplay, EAnnouncementType AnnouncementType, EAnnouncementGroup Group, int32 Priority, float Duration, bool bCanBeQueued);
	static void ShowAnnouncementWithSubText(class AActor* CallerActor, const class FText& TextToDisplay, const class FText& SubTextToDisplay, EAnnouncementType AnnouncementType, EAnnouncementGroup Group, int32 Priority, float Duration, bool bCanBeQueued);

	void OnClearAnnouncementGroupDelegate__DelegateSignature(int32 DisplayedAnnouncementInstanceID, const TArray<int32>& QueuedAnnouncementInstanceID, EAnnouncementGroup Group);
	void OnHideAnnouncementDelegate__DelegateSignature(int32 AnnouncementInstanceID, EAnnouncementType AnnouncementType, EAnnouncementGroup Group);
	void OnShowAnnouncementDelegate__DelegateSignature(int32 AnnouncementInstanceID, const class FText& TextToDisplay, const class FText& SubTextToDisplay, EAnnouncementType AnnouncementType, EAnnouncementGroup Group, float Duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnnouncementSubsystem">();
	}
	static class UAnnouncementSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnnouncementSubsystem>();
	}
};
static_assert(alignof(UAnnouncementSubsystem) == 0x000008, "Wrong alignment on UAnnouncementSubsystem");
static_assert(sizeof(UAnnouncementSubsystem) == 0x000098, "Wrong size on UAnnouncementSubsystem");
static_assert(offsetof(UAnnouncementSubsystem, OnShowAnnouncementDelegate) == 0x000030, "Member 'UAnnouncementSubsystem::OnShowAnnouncementDelegate' has a wrong offset!");
static_assert(offsetof(UAnnouncementSubsystem, OnHideAnnouncementDelegate) == 0x000040, "Member 'UAnnouncementSubsystem::OnHideAnnouncementDelegate' has a wrong offset!");
static_assert(offsetof(UAnnouncementSubsystem, OnClearAnnouncementGroupDelegate) == 0x000050, "Member 'UAnnouncementSubsystem::OnClearAnnouncementGroupDelegate' has a wrong offset!");
static_assert(offsetof(UAnnouncementSubsystem, DisplayedInstances) == 0x000060, "Member 'UAnnouncementSubsystem::DisplayedInstances' has a wrong offset!");

// Class DeceiveInc.DiMenuPageUserWidget
// 0x0020 (0x0280 - 0x0260)
class UDiMenuPageUserWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMenuPageUserWidgetClosed;                        // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWidget*                                DefaultKeyboardFocusWidget;                        // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BP_OnGotoMenuCommand(const TArray<class FString>& CommandParams);
	void BP_OnMenuPageUserWidgetClosed();
	class UWidget* GetDefaultFocusWidget();
	void HandleGOTOMENUCommandAction(const TArray<class FString>& CommandParams);
	void SetAsDefaultFocusWidget(class UWidget* DefaultFocus);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiMenuPageUserWidget">();
	}
	static class UDiMenuPageUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiMenuPageUserWidget>();
	}
};
static_assert(alignof(UDiMenuPageUserWidget) == 0x000008, "Wrong alignment on UDiMenuPageUserWidget");
static_assert(sizeof(UDiMenuPageUserWidget) == 0x000280, "Wrong size on UDiMenuPageUserWidget");
static_assert(offsetof(UDiMenuPageUserWidget, OnMenuPageUserWidgetClosed) == 0x000268, "Member 'UDiMenuPageUserWidget::OnMenuPageUserWidgetClosed' has a wrong offset!");
static_assert(offsetof(UDiMenuPageUserWidget, DefaultKeyboardFocusWidget) == 0x000278, "Member 'UDiMenuPageUserWidget::DefaultKeyboardFocusWidget' has a wrong offset!");

// Class DeceiveInc.DiCharacterMenuPageUserWidget
// 0x0000 (0x0280 - 0x0280)
class UDiCharacterMenuPageUserWidget final : public UDiMenuPageUserWidget
{
public:
	void BP_OnSelectCharacterRequest(const class UAgentData* AgentToSelect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiCharacterMenuPageUserWidget">();
	}
	static class UDiCharacterMenuPageUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiCharacterMenuPageUserWidget>();
	}
};
static_assert(alignof(UDiCharacterMenuPageUserWidget) == 0x000008, "Wrong alignment on UDiCharacterMenuPageUserWidget");
static_assert(sizeof(UDiCharacterMenuPageUserWidget) == 0x000280, "Wrong size on UDiCharacterMenuPageUserWidget");

// Class DeceiveInc.AOEWeaponComponent
// 0x0008 (0x00B8 - 0x00B0)
class UAOEWeaponComponent final : public UActorComponent
{
public:
	float                                         AOEDamage;                                         // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AOERadius;                                         // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleWeaponProjectileImpact(const struct FWeaponImpactData& WeaponImpactData);
	void Server_AOEDamage(const struct FWeaponImpactData& WeaponImpactData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AOEWeaponComponent">();
	}
	static class UAOEWeaponComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAOEWeaponComponent>();
	}
};
static_assert(alignof(UAOEWeaponComponent) == 0x000008, "Wrong alignment on UAOEWeaponComponent");
static_assert(sizeof(UAOEWeaponComponent) == 0x0000B8, "Wrong size on UAOEWeaponComponent");
static_assert(offsetof(UAOEWeaponComponent, AOEDamage) == 0x0000B0, "Member 'UAOEWeaponComponent::AOEDamage' has a wrong offset!");
static_assert(offsetof(UAOEWeaponComponent, AOERadius) == 0x0000B4, "Member 'UAOEWeaponComponent::AOERadius' has a wrong offset!");

// Class DeceiveInc.HitscanFakeProjectile
// 0x0010 (0x0230 - 0x0220)
class AHitscanFakeProjectile final : public AActor
{
public:
	float                                         SpeedInMetersBySecond;                             // 0x0220(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       BaseShapeComponent;                                // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitscanFakeProjectile">();
	}
	static class AHitscanFakeProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHitscanFakeProjectile>();
	}
};
static_assert(alignof(AHitscanFakeProjectile) == 0x000008, "Wrong alignment on AHitscanFakeProjectile");
static_assert(sizeof(AHitscanFakeProjectile) == 0x000230, "Wrong size on AHitscanFakeProjectile");
static_assert(offsetof(AHitscanFakeProjectile, SpeedInMetersBySecond) == 0x000220, "Member 'AHitscanFakeProjectile::SpeedInMetersBySecond' has a wrong offset!");
static_assert(offsetof(AHitscanFakeProjectile, BaseShapeComponent) == 0x000228, "Member 'AHitscanFakeProjectile::BaseShapeComponent' has a wrong offset!");

// Class DeceiveInc.AttachToSpyComponent
// 0x0080 (0x0130 - 0x00B0)
class UAttachToSpyComponent final : public UActorComponent
{
public:
	class ASpy*                                   SpyOwner;                                          // 0x00B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 SpawnedInstance;                                   // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        AttachScene;                                       // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseMimicScannableActor*               CurrentMimic;                                      // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ANPCCharacter*                          CurrentDisguise;                                   // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x1];                                       // 0x00D8(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAttachToSpy;                                      // 0x00D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DA[0x2];                                       // 0x00DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpySocket;                                         // 0x00DC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttachToMimic;                                    // 0x00E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MimicSocket;                                       // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttachToDisguise;                                 // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DisguiseSocket;                                    // 0x00F4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ActorToAttach;                                     // 0x0100(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SocketToAttach;                                    // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleCoverChanged(class ANPCCharacter* Disguise);
	void HandleMimicChanged(class ABaseMimicScannableActor* NewMimic);
	void HandleResourceChanged(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 Amount);
	void HandleUnderCoverChanged(bool IsUndercover);
	void HandleVisibilityChanged(bool bIs1P);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttachToSpyComponent">();
	}
	static class UAttachToSpyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttachToSpyComponent>();
	}
};
static_assert(alignof(UAttachToSpyComponent) == 0x000008, "Wrong alignment on UAttachToSpyComponent");
static_assert(sizeof(UAttachToSpyComponent) == 0x000130, "Wrong size on UAttachToSpyComponent");
static_assert(offsetof(UAttachToSpyComponent, SpyOwner) == 0x0000B0, "Member 'UAttachToSpyComponent::SpyOwner' has a wrong offset!");
static_assert(offsetof(UAttachToSpyComponent, SpawnedInstance) == 0x0000B8, "Member 'UAttachToSpyComponent::SpawnedInstance' has a wrong offset!");
static_assert(offsetof(UAttachToSpyComponent, AttachScene) == 0x0000C0, "Member 'UAttachToSpyComponent::AttachScene' has a wrong offset!");
static_assert(offsetof(UAttachToSpyComponent, CurrentMimic) == 0x0000C8, "Member 'UAttachToSpyComponent::CurrentMimic' has a wrong offset!");
static_assert(offsetof(UAttachToSpyComponent, CurrentDisguise) == 0x0000D0, "Member 'UAttachToSpyComponent::CurrentDisguise' has a wrong offset!");
static_assert(offsetof(UAttachToSpyComponent, bAttachToSpy) == 0x0000D9, "Member 'UAttachToSpyComponent::bAttachToSpy' has a wrong offset!");
static_assert(offsetof(UAttachToSpyComponent, SpySocket) == 0x0000DC, "Member 'UAttachToSpyComponent::SpySocket' has a wrong offset!");
static_assert(offsetof(UAttachToSpyComponent, bAttachToMimic) == 0x0000E4, "Member 'UAttachToSpyComponent::bAttachToMimic' has a wrong offset!");
static_assert(offsetof(UAttachToSpyComponent, MimicSocket) == 0x0000E8, "Member 'UAttachToSpyComponent::MimicSocket' has a wrong offset!");
static_assert(offsetof(UAttachToSpyComponent, bAttachToDisguise) == 0x0000F0, "Member 'UAttachToSpyComponent::bAttachToDisguise' has a wrong offset!");
static_assert(offsetof(UAttachToSpyComponent, DisguiseSocket) == 0x0000F4, "Member 'UAttachToSpyComponent::DisguiseSocket' has a wrong offset!");
static_assert(offsetof(UAttachToSpyComponent, ActorToAttach) == 0x000100, "Member 'UAttachToSpyComponent::ActorToAttach' has a wrong offset!");
static_assert(offsetof(UAttachToSpyComponent, SocketToAttach) == 0x000128, "Member 'UAttachToSpyComponent::SocketToAttach' has a wrong offset!");

// Class DeceiveInc.DIWidgetComponent
// 0x0000 (0x05B0 - 0x05B0)
class UDIWidgetComponent : public UWidgetComponent
{
public:
	bool                                          bOnlyTickWhenVisible;                              // 0x05AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5AB[0x5];                                      // 0x05AB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIWidgetComponent">();
	}
	static class UDIWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIWidgetComponent>();
	}
};
static_assert(alignof(UDIWidgetComponent) == 0x000010, "Wrong alignment on UDIWidgetComponent");
static_assert(sizeof(UDIWidgetComponent) == 0x0005B0, "Wrong size on UDIWidgetComponent");
static_assert(offsetof(UDIWidgetComponent, bOnlyTickWhenVisible) == 0x0005AA, "Member 'UDIWidgetComponent::bOnlyTickWhenVisible' has a wrong offset!");

// Class DeceiveInc.InteractionIconComponent
// 0x0090 (0x0640 - 0x05B0)
class UInteractionIconComponent final : public UDIWidgetComponent
{
public:
	FMulticastInlineDelegateProperty_             OnEnabledChanged;                                  // 0x05B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractionIconStateChanged;                     // 0x05C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractCancel;                                  // 0x05D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTextChanged;                                     // 0x05E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCustomEventTriggered;                            // 0x05F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bHideWhenConditionsNotMet;                         // 0x0600(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_601[0x3F];                                     // 0x0601(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetTooltipText();
	void OnCompleteEnd();
	void SetEnabled(bool bEnabled);
	void SetEnabledLocal(bool bEnabled);
	void SetToolTipText(const class FText& NewText);
	void StartInteraction(float PercentToSet, class UProgressBar* ProgressBar);
	void StopInteraction(float PercentToSet);

	EInteractionIconState GetInteractionIconState() const;
	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionIconComponent">();
	}
	static class UInteractionIconComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionIconComponent>();
	}
};
static_assert(alignof(UInteractionIconComponent) == 0x000010, "Wrong alignment on UInteractionIconComponent");
static_assert(sizeof(UInteractionIconComponent) == 0x000640, "Wrong size on UInteractionIconComponent");
static_assert(offsetof(UInteractionIconComponent, OnEnabledChanged) == 0x0005B0, "Member 'UInteractionIconComponent::OnEnabledChanged' has a wrong offset!");
static_assert(offsetof(UInteractionIconComponent, OnInteractionIconStateChanged) == 0x0005C0, "Member 'UInteractionIconComponent::OnInteractionIconStateChanged' has a wrong offset!");
static_assert(offsetof(UInteractionIconComponent, OnInteractCancel) == 0x0005D0, "Member 'UInteractionIconComponent::OnInteractCancel' has a wrong offset!");
static_assert(offsetof(UInteractionIconComponent, OnTextChanged) == 0x0005E0, "Member 'UInteractionIconComponent::OnTextChanged' has a wrong offset!");
static_assert(offsetof(UInteractionIconComponent, OnCustomEventTriggered) == 0x0005F0, "Member 'UInteractionIconComponent::OnCustomEventTriggered' has a wrong offset!");
static_assert(offsetof(UInteractionIconComponent, bHideWhenConditionsNotMet) == 0x000600, "Member 'UInteractionIconComponent::bHideWhenConditionsNotMet' has a wrong offset!");

// Class DeceiveInc.DISaveGame
// 0x0380 (0x03A8 - 0x0028)
class UDISaveGame final : public USaveGame
{
public:
	class FString                                 BanditId;                                          // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBetaAccess;                                    // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDISerializedAccessories               Accessories;                                       // 0x0040(0x0098)(NativeAccessSpecifierPublic)
	struct FDISerializedAgentSelection            AgentSelection;                                    // 0x00D8(0x0068)(NativeAccessSpecifierPublic)
	struct FDISerializedInventory                 Inventory;                                         // 0x0140(0x0050)(NativeAccessSpecifierPublic)
	struct FDISerializedProgression               Progression;                                       // 0x0190(0x0020)(NativeAccessSpecifierPublic)
	struct FDISerializedPlayerSettings            PlayerSettings;                                    // 0x01B0(0x0158)(NativeAccessSpecifierPublic)
	struct FDISerializedPlayerKeybindings         PlayerKeybindings;                                 // 0x0308(0x0048)(NativeAccessSpecifierPublic)
	struct FDISerializedDecks                     PlayerDecks;                                       // 0x0350(0x0028)(NativeAccessSpecifierPublic)
	struct FDISerializedLocalSaveData             LocalSaveData;                                     // 0x0378(0x0028)(NativeAccessSpecifierPublic)
	int32                                         SavedDataVersion;                                  // 0x03A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DISaveGame">();
	}
	static class UDISaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDISaveGame>();
	}
};
static_assert(alignof(UDISaveGame) == 0x000008, "Wrong alignment on UDISaveGame");
static_assert(sizeof(UDISaveGame) == 0x0003A8, "Wrong size on UDISaveGame");
static_assert(offsetof(UDISaveGame, BanditId) == 0x000028, "Member 'UDISaveGame::BanditId' has a wrong offset!");
static_assert(offsetof(UDISaveGame, bHasBetaAccess) == 0x000038, "Member 'UDISaveGame::bHasBetaAccess' has a wrong offset!");
static_assert(offsetof(UDISaveGame, Accessories) == 0x000040, "Member 'UDISaveGame::Accessories' has a wrong offset!");
static_assert(offsetof(UDISaveGame, AgentSelection) == 0x0000D8, "Member 'UDISaveGame::AgentSelection' has a wrong offset!");
static_assert(offsetof(UDISaveGame, Inventory) == 0x000140, "Member 'UDISaveGame::Inventory' has a wrong offset!");
static_assert(offsetof(UDISaveGame, Progression) == 0x000190, "Member 'UDISaveGame::Progression' has a wrong offset!");
static_assert(offsetof(UDISaveGame, PlayerSettings) == 0x0001B0, "Member 'UDISaveGame::PlayerSettings' has a wrong offset!");
static_assert(offsetof(UDISaveGame, PlayerKeybindings) == 0x000308, "Member 'UDISaveGame::PlayerKeybindings' has a wrong offset!");
static_assert(offsetof(UDISaveGame, PlayerDecks) == 0x000350, "Member 'UDISaveGame::PlayerDecks' has a wrong offset!");
static_assert(offsetof(UDISaveGame, LocalSaveData) == 0x000378, "Member 'UDISaveGame::LocalSaveData' has a wrong offset!");
static_assert(offsetof(UDISaveGame, SavedDataVersion) == 0x0003A0, "Member 'UDISaveGame::SavedDataVersion' has a wrong offset!");

// Class DeceiveInc.AutoSpectateAIComponent
// 0x00C8 (0x0178 - 0x00B0)
class UAutoSpectateAIComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0xC8];                                      // 0x00B0(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoSpectateAIComponent">();
	}
	static class UAutoSpectateAIComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoSpectateAIComponent>();
	}
};
static_assert(alignof(UAutoSpectateAIComponent) == 0x000008, "Wrong alignment on UAutoSpectateAIComponent");
static_assert(sizeof(UAutoSpectateAIComponent) == 0x000178, "Wrong size on UAutoSpectateAIComponent");

// Class DeceiveInc.AvatarDataAsset
// 0x0060 (0x0098 - 0x0038)
class UAvatarDataAsset final : public UDIPrimaryDataAsset
{
public:
	class FText                                   AvatarDisplayName;                                 // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   AvatarUnlockDescription;                           // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         AvatarRarity;                                      // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              Avatar;                                            // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AvatarDataAsset">();
	}
	static class UAvatarDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAvatarDataAsset>();
	}
};
static_assert(alignof(UAvatarDataAsset) == 0x000008, "Wrong alignment on UAvatarDataAsset");
static_assert(sizeof(UAvatarDataAsset) == 0x000098, "Wrong size on UAvatarDataAsset");
static_assert(offsetof(UAvatarDataAsset, AvatarDisplayName) == 0x000038, "Member 'UAvatarDataAsset::AvatarDisplayName' has a wrong offset!");
static_assert(offsetof(UAvatarDataAsset, AvatarUnlockDescription) == 0x000050, "Member 'UAvatarDataAsset::AvatarUnlockDescription' has a wrong offset!");
static_assert(offsetof(UAvatarDataAsset, AvatarRarity) == 0x000068, "Member 'UAvatarDataAsset::AvatarRarity' has a wrong offset!");
static_assert(offsetof(UAvatarDataAsset, Avatar) == 0x000070, "Member 'UAvatarDataAsset::Avatar' has a wrong offset!");

// Class DeceiveInc.DIMenuUserWidget
// 0x00A0 (0x0300 - 0x0260)
class UDIMenuUserWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MenuName;                                          // 0x0268(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDiMenuPageNavigationWidget*            MenuPageNavigation;                                // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        MenuSwitcher;                                      // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           PreviousPageAction;                                // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           NextPageAction;                                    // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class UInputAction*>                     CustomHandledActions;                              // 0x0290(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bShowCursor;                                       // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableMenuInput;                                  // 0x02E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableAnalogCursor;                               // 0x02E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCloseMenuOnBackKey;                               // 0x02E3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMouseLockMode                                MouseLockMode;                                     // 0x02E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInputMode                                    InputMode;                                         // 0x02E5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNotifyPawn;                                       // 0x02E6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E7[0x1];                                      // 0x02E7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPregameTimerCloseMenu;                           // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnBackActionTriggered();
	void BP_OnCustomActionTriggered(const class UInputAction* TriggeredAction, float Value);
	void BP_OnGotoMenuCommand(const TArray<class FString>& CommandParams);
	void BP_OnMenuRemoved();
	void BP_OnMenuShown();
	void DisplayMenuPage(int32 PageIndex);
	class UDiMenuPageNavigationWidget* GetMenuPageNavigation();
	class UWidgetSwitcher* GetMenuSwitcher();
	void HandleGOTOMENUCommandAction(const TArray<class FString>& CommandParams);
	void HandlePhaseTick(int32 TimeRemainingInSeconds);
	void RemoveThisMenuFromScreen();
	void SetMenuName(class FName InMenuName);
	void SignalInputHandled();

	class FName GetMenuName() const;
	bool IsMenuShown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIMenuUserWidget">();
	}
	static class UDIMenuUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIMenuUserWidget>();
	}
};
static_assert(alignof(UDIMenuUserWidget) == 0x000008, "Wrong alignment on UDIMenuUserWidget");
static_assert(sizeof(UDIMenuUserWidget) == 0x000300, "Wrong size on UDIMenuUserWidget");
static_assert(offsetof(UDIMenuUserWidget, MenuName) == 0x000268, "Member 'UDIMenuUserWidget::MenuName' has a wrong offset!");
static_assert(offsetof(UDIMenuUserWidget, MenuPageNavigation) == 0x000270, "Member 'UDIMenuUserWidget::MenuPageNavigation' has a wrong offset!");
static_assert(offsetof(UDIMenuUserWidget, MenuSwitcher) == 0x000278, "Member 'UDIMenuUserWidget::MenuSwitcher' has a wrong offset!");
static_assert(offsetof(UDIMenuUserWidget, PreviousPageAction) == 0x000280, "Member 'UDIMenuUserWidget::PreviousPageAction' has a wrong offset!");
static_assert(offsetof(UDIMenuUserWidget, NextPageAction) == 0x000288, "Member 'UDIMenuUserWidget::NextPageAction' has a wrong offset!");
static_assert(offsetof(UDIMenuUserWidget, CustomHandledActions) == 0x000290, "Member 'UDIMenuUserWidget::CustomHandledActions' has a wrong offset!");
static_assert(offsetof(UDIMenuUserWidget, bShowCursor) == 0x0002E0, "Member 'UDIMenuUserWidget::bShowCursor' has a wrong offset!");
static_assert(offsetof(UDIMenuUserWidget, bEnableMenuInput) == 0x0002E1, "Member 'UDIMenuUserWidget::bEnableMenuInput' has a wrong offset!");
static_assert(offsetof(UDIMenuUserWidget, bEnableAnalogCursor) == 0x0002E2, "Member 'UDIMenuUserWidget::bEnableAnalogCursor' has a wrong offset!");
static_assert(offsetof(UDIMenuUserWidget, bCloseMenuOnBackKey) == 0x0002E3, "Member 'UDIMenuUserWidget::bCloseMenuOnBackKey' has a wrong offset!");
static_assert(offsetof(UDIMenuUserWidget, MouseLockMode) == 0x0002E4, "Member 'UDIMenuUserWidget::MouseLockMode' has a wrong offset!");
static_assert(offsetof(UDIMenuUserWidget, InputMode) == 0x0002E5, "Member 'UDIMenuUserWidget::InputMode' has a wrong offset!");
static_assert(offsetof(UDIMenuUserWidget, bNotifyPawn) == 0x0002E6, "Member 'UDIMenuUserWidget::bNotifyPawn' has a wrong offset!");
static_assert(offsetof(UDIMenuUserWidget, OnPregameTimerCloseMenu) == 0x0002E8, "Member 'UDIMenuUserWidget::OnPregameTimerCloseMenu' has a wrong offset!");

// Class DeceiveInc.DIMenuStoreShowcaseWidget
// 0x0020 (0x0320 - 0x0300)
class UDIMenuStoreShowcaseWidget final : public UDIMenuUserWidget
{
public:
	bool                                          bHasVariation;                                     // 0x0300(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasMutipleItems;                                  // 0x0301(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_302[0xE];                                      // 0x0302(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDIItem*>                        ShowcaseItems;                                     // 0x0310(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void BP_ShowItemInMenu(class UDIItem* NewItem);
	void PrepareItemShowcase(class UDIItem* ShowcaseItem);
	void ShowNextItem();
	void ShowNextVariation();
	void ShowPreviousItem();
	void ShowPreviousVariation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIMenuStoreShowcaseWidget">();
	}
	static class UDIMenuStoreShowcaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIMenuStoreShowcaseWidget>();
	}
};
static_assert(alignof(UDIMenuStoreShowcaseWidget) == 0x000008, "Wrong alignment on UDIMenuStoreShowcaseWidget");
static_assert(sizeof(UDIMenuStoreShowcaseWidget) == 0x000320, "Wrong size on UDIMenuStoreShowcaseWidget");
static_assert(offsetof(UDIMenuStoreShowcaseWidget, bHasVariation) == 0x000300, "Member 'UDIMenuStoreShowcaseWidget::bHasVariation' has a wrong offset!");
static_assert(offsetof(UDIMenuStoreShowcaseWidget, bHasMutipleItems) == 0x000301, "Member 'UDIMenuStoreShowcaseWidget::bHasMutipleItems' has a wrong offset!");
static_assert(offsetof(UDIMenuStoreShowcaseWidget, ShowcaseItems) == 0x000310, "Member 'UDIMenuStoreShowcaseWidget::ShowcaseItems' has a wrong offset!");

// Class DeceiveInc.AwsPingHandler
// 0x0088 (0x00B0 - 0x0028)
class UAwsPingHandler final : public UObject
{
public:
	class UGameInstance*                          GameInstance;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x70];                                      // 0x0030(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPingEstimateStabilized;                          // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	void DoPing();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AwsPingHandler">();
	}
	static class UAwsPingHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAwsPingHandler>();
	}
};
static_assert(alignof(UAwsPingHandler) == 0x000008, "Wrong alignment on UAwsPingHandler");
static_assert(sizeof(UAwsPingHandler) == 0x0000B0, "Wrong size on UAwsPingHandler");
static_assert(offsetof(UAwsPingHandler, GameInstance) == 0x000028, "Member 'UAwsPingHandler::GameInstance' has a wrong offset!");
static_assert(offsetof(UAwsPingHandler, OnPingEstimateStabilized) == 0x0000A0, "Member 'UAwsPingHandler::OnPingEstimateStabilized' has a wrong offset!");

// Class DeceiveInc.DeceiveIncDedicatedStartupGameState
// 0x0000 (0x0528 - 0x0528)
class ADeceiveIncDedicatedStartupGameState final : public ADeceiveIncGameStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeceiveIncDedicatedStartupGameState">();
	}
	static class ADeceiveIncDedicatedStartupGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeceiveIncDedicatedStartupGameState>();
	}
};
static_assert(alignof(ADeceiveIncDedicatedStartupGameState) == 0x000008, "Wrong alignment on ADeceiveIncDedicatedStartupGameState");
static_assert(sizeof(ADeceiveIncDedicatedStartupGameState) == 0x000528, "Wrong size on ADeceiveIncDedicatedStartupGameState");

// Class DeceiveInc.AYumiPassiveAbilityMod1_2
// 0x0008 (0x0538 - 0x0530)
class AAYumiPassiveAbilityMod1_2 final : public ABaseSpyPassiveAbility
{
public:
	float                                         PercentRefunded;                                   // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_534[0x4];                                      // 0x0534(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleHitConfirmed(const struct FHitConfirmData& HitConfirmData);
	void HandleMeleeDamageConfirmed(class AActor* Victim, const struct FVector& ImpactPoint, int32 ChargeLevel, float DamageDone, float ResultingHealthPercentage, EHitType HitType, const struct FMeleeHitConfirmedData& HitConfirmedData);
	void HandleSpyToolLoadComplete(class UToolLoadoutComponent* ToolLoadout);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AYumiPassiveAbilityMod1_2">();
	}
	static class AAYumiPassiveAbilityMod1_2* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAYumiPassiveAbilityMod1_2>();
	}
};
static_assert(alignof(AAYumiPassiveAbilityMod1_2) == 0x000008, "Wrong alignment on AAYumiPassiveAbilityMod1_2");
static_assert(sizeof(AAYumiPassiveAbilityMod1_2) == 0x000538, "Wrong size on AAYumiPassiveAbilityMod1_2");
static_assert(offsetof(AAYumiPassiveAbilityMod1_2, PercentRefunded) == 0x000530, "Member 'AAYumiPassiveAbilityMod1_2::PercentRefunded' has a wrong offset!");

// Class DeceiveInc.BaseAoEActor
// 0x0108 (0x0328 - 0x0220)
class ABaseAoEActor : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnAddActorInRange;                                 // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemoveActorInRange;                              // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAddEffectVictimInRange;                          // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemoveEffectVictimInRange;                       // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDestroyedAfterApplyingEffect;                    // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAoEUpdateInterval;                               // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_280[0x20];                                     // 0x0280(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsInRange;                                     // 0x02A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         EffectVictimInRange;                               // 0x02B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           VictimEffectClassToApply;                          // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           VictimEffectClassToApplySpies;                     // 0x02E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bIsFinite;                                         // 0x02F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawnWithUpVectorToZero;                          // 0x02F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplySpyVictimEffectToUndercoverSpies;            // 0x02F2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanAffectFaction;                                 // 0x02F3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanAffectDeadActor;                               // 0x02F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTargetableByTurret;                               // 0x02F5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMakeRaycastCheck;                                 // 0x02F6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F7[0x1];                                      // 0x02F7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PenetrationThreshold;                              // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxRaycastCheckForIgnoredBlocking;                 // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             TestCollisionChannel;                              // 0x0300(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDestroyAfterApplyingEffect;                       // 0x0301(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_302[0x2];                                      // 0x0302(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AoEDuration;                                       // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AoEInterval;                                       // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReapplyVictimEffectOnEachInterval;                // 0x030C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             AOECollisionChannel;                               // 0x030D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30E[0x2];                                      // 0x030E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HalfHeight;                                        // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                HalfExtents;                                       // 0x0318(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAoEShapeType                                 AoEShapeType;                                      // 0x0324(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowDebugDraw;                                    // 0x0325(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_326[0x2];                                      // 0x0326(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnAoEUpdateInterval(const TArray<class AActor*>& AddedActors, const TArray<class AActor*>& RemovedActors);
	void BP_OnDestroyedAfterApplyingEffect();
	void EnableAoE(bool bEnableIn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseAoEActor">();
	}
	static class ABaseAoEActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseAoEActor>();
	}
};
static_assert(alignof(ABaseAoEActor) == 0x000008, "Wrong alignment on ABaseAoEActor");
static_assert(sizeof(ABaseAoEActor) == 0x000328, "Wrong size on ABaseAoEActor");
static_assert(offsetof(ABaseAoEActor, OnAddActorInRange) == 0x000220, "Member 'ABaseAoEActor::OnAddActorInRange' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, OnRemoveActorInRange) == 0x000230, "Member 'ABaseAoEActor::OnRemoveActorInRange' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, OnAddEffectVictimInRange) == 0x000240, "Member 'ABaseAoEActor::OnAddEffectVictimInRange' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, OnRemoveEffectVictimInRange) == 0x000250, "Member 'ABaseAoEActor::OnRemoveEffectVictimInRange' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, OnDestroyedAfterApplyingEffect) == 0x000260, "Member 'ABaseAoEActor::OnDestroyedAfterApplyingEffect' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, OnAoEUpdateInterval) == 0x000270, "Member 'ABaseAoEActor::OnAoEUpdateInterval' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, ActorsInRange) == 0x0002A0, "Member 'ABaseAoEActor::ActorsInRange' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, EffectVictimInRange) == 0x0002B0, "Member 'ABaseAoEActor::EffectVictimInRange' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, VictimEffectClassToApply) == 0x0002D0, "Member 'ABaseAoEActor::VictimEffectClassToApply' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, VictimEffectClassToApplySpies) == 0x0002E0, "Member 'ABaseAoEActor::VictimEffectClassToApplySpies' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, bIsFinite) == 0x0002F0, "Member 'ABaseAoEActor::bIsFinite' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, bSpawnWithUpVectorToZero) == 0x0002F1, "Member 'ABaseAoEActor::bSpawnWithUpVectorToZero' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, bApplySpyVictimEffectToUndercoverSpies) == 0x0002F2, "Member 'ABaseAoEActor::bApplySpyVictimEffectToUndercoverSpies' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, bCanAffectFaction) == 0x0002F3, "Member 'ABaseAoEActor::bCanAffectFaction' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, bCanAffectDeadActor) == 0x0002F4, "Member 'ABaseAoEActor::bCanAffectDeadActor' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, bTargetableByTurret) == 0x0002F5, "Member 'ABaseAoEActor::bTargetableByTurret' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, bMakeRaycastCheck) == 0x0002F6, "Member 'ABaseAoEActor::bMakeRaycastCheck' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, PenetrationThreshold) == 0x0002F8, "Member 'ABaseAoEActor::PenetrationThreshold' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, MaxRaycastCheckForIgnoredBlocking) == 0x0002FC, "Member 'ABaseAoEActor::MaxRaycastCheckForIgnoredBlocking' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, TestCollisionChannel) == 0x000300, "Member 'ABaseAoEActor::TestCollisionChannel' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, bDestroyAfterApplyingEffect) == 0x000301, "Member 'ABaseAoEActor::bDestroyAfterApplyingEffect' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, AoEDuration) == 0x000304, "Member 'ABaseAoEActor::AoEDuration' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, AoEInterval) == 0x000308, "Member 'ABaseAoEActor::AoEInterval' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, bReapplyVictimEffectOnEachInterval) == 0x00030C, "Member 'ABaseAoEActor::bReapplyVictimEffectOnEachInterval' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, AOECollisionChannel) == 0x00030D, "Member 'ABaseAoEActor::AOECollisionChannel' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, Radius) == 0x000310, "Member 'ABaseAoEActor::Radius' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, HalfHeight) == 0x000314, "Member 'ABaseAoEActor::HalfHeight' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, HalfExtents) == 0x000318, "Member 'ABaseAoEActor::HalfExtents' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, AoEShapeType) == 0x000324, "Member 'ABaseAoEActor::AoEShapeType' has a wrong offset!");
static_assert(offsetof(ABaseAoEActor, bShowDebugDraw) == 0x000325, "Member 'ABaseAoEActor::bShowDebugDraw' has a wrong offset!");

// Class DeceiveInc.BaseBreadcrumbsActor
// 0x0038 (0x0258 - 0x0220)
class ABaseBreadcrumbsActor final : public AActor
{
public:
	uint8                                         Pad_220[0x10];                                     // 0x0220(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableComponent*                 InteractableComp;                                  // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractableType                             InteractableType;                                  // 0x0238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_239[0x3];                                      // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FReplicateBlueprintData                NetData;                                           // 0x023C(0x0014)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnBreacrumbEnd();
	void BP_OnBreacrumbStart(float Lifetime, const struct FVector& NewPosition);
	void HandleLifetimeDone();
	bool IsUsable();
	void OnRep_Data();
	void SetupForCavaliere();

	EInteractableType GetInteractableType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseBreadcrumbsActor">();
	}
	static class ABaseBreadcrumbsActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseBreadcrumbsActor>();
	}
};
static_assert(alignof(ABaseBreadcrumbsActor) == 0x000008, "Wrong alignment on ABaseBreadcrumbsActor");
static_assert(sizeof(ABaseBreadcrumbsActor) == 0x000258, "Wrong size on ABaseBreadcrumbsActor");
static_assert(offsetof(ABaseBreadcrumbsActor, InteractableComp) == 0x000230, "Member 'ABaseBreadcrumbsActor::InteractableComp' has a wrong offset!");
static_assert(offsetof(ABaseBreadcrumbsActor, InteractableType) == 0x000238, "Member 'ABaseBreadcrumbsActor::InteractableType' has a wrong offset!");
static_assert(offsetof(ABaseBreadcrumbsActor, NetData) == 0x00023C, "Member 'ABaseBreadcrumbsActor::NetData' has a wrong offset!");

// Class DeceiveInc.CheckRuleApply_Base
// 0x0000 (0x0028 - 0x0028)
class UCheckRuleApply_Base : public UObject
{
public:
	bool IsActiveForCurrentRules();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheckRuleApply_Base">();
	}
	static class UCheckRuleApply_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheckRuleApply_Base>();
	}
};
static_assert(alignof(UCheckRuleApply_Base) == 0x000008, "Wrong alignment on UCheckRuleApply_Base");
static_assert(sizeof(UCheckRuleApply_Base) == 0x000028, "Wrong size on UCheckRuleApply_Base");

// Class DeceiveInc.CheckRuleApply_DisabledByRule
// 0x0008 (0x0030 - 0x0028)
class UCheckRuleApply_DisabledByRule final : public UCheckRuleApply_Base
{
public:
	int32                                         DisabledByRules;                                   // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheckRuleApply_DisabledByRule">();
	}
	static class UCheckRuleApply_DisabledByRule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheckRuleApply_DisabledByRule>();
	}
};
static_assert(alignof(UCheckRuleApply_DisabledByRule) == 0x000008, "Wrong alignment on UCheckRuleApply_DisabledByRule");
static_assert(sizeof(UCheckRuleApply_DisabledByRule) == 0x000030, "Wrong size on UCheckRuleApply_DisabledByRule");
static_assert(offsetof(UCheckRuleApply_DisabledByRule, DisabledByRules) == 0x000028, "Member 'UCheckRuleApply_DisabledByRule::DisabledByRules' has a wrong offset!");

// Class DeceiveInc.BaseInteractableActor
// 0x0098 (0x02B8 - 0x0220)
class ABaseInteractableActor : public AActor
{
public:
	uint8                                         Pad_220[0x10];                                     // 0x0220(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       RegistrationCollisionShapeComp;                    // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 InteractableComp;                                  // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractableType                             InteractableType;                                  // 0x0240(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ConditionMetText;                                  // 0x0248(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EConditionType, class FText>             ConditionNotMetTextMap;                            // 0x0260(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bHiddenInContainer;                                // 0x02B0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnHiddenInContainerChange(bool bNowHidden);
	void BP_OnInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void BP_SetCanBePing(bool bCanBePingIn);
	void HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	bool IsUsable();
	void OnRep_HiddenInContainer();
	bool SetHiddenInContainer(bool InHidden);

	class UInteractableComponent* GetInteractableComponent() const;
	EInteractableType GetInteractableType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseInteractableActor">();
	}
	static class ABaseInteractableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseInteractableActor>();
	}
};
static_assert(alignof(ABaseInteractableActor) == 0x000008, "Wrong alignment on ABaseInteractableActor");
static_assert(sizeof(ABaseInteractableActor) == 0x0002B8, "Wrong size on ABaseInteractableActor");
static_assert(offsetof(ABaseInteractableActor, RegistrationCollisionShapeComp) == 0x000230, "Member 'ABaseInteractableActor::RegistrationCollisionShapeComp' has a wrong offset!");
static_assert(offsetof(ABaseInteractableActor, InteractableComp) == 0x000238, "Member 'ABaseInteractableActor::InteractableComp' has a wrong offset!");
static_assert(offsetof(ABaseInteractableActor, InteractableType) == 0x000240, "Member 'ABaseInteractableActor::InteractableType' has a wrong offset!");
static_assert(offsetof(ABaseInteractableActor, ConditionMetText) == 0x000248, "Member 'ABaseInteractableActor::ConditionMetText' has a wrong offset!");
static_assert(offsetof(ABaseInteractableActor, ConditionNotMetTextMap) == 0x000260, "Member 'ABaseInteractableActor::ConditionNotMetTextMap' has a wrong offset!");
static_assert(offsetof(ABaseInteractableActor, bHiddenInContainer) == 0x0002B0, "Member 'ABaseInteractableActor::bHiddenInContainer' has a wrong offset!");

// Class DeceiveInc.InteractionAuthorityComponent
// 0x0030 (0x00E0 - 0x00B0)
class UInteractionAuthorityComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnInteractionStart;                                // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractionCancel;                               // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractionComplete;                             // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void NetMulticastCancelInteraction(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void NetMulticastCompleteInteraction(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void NetMulticastStartInteraction(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionAuthorityComponent">();
	}
	static class UInteractionAuthorityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionAuthorityComponent>();
	}
};
static_assert(alignof(UInteractionAuthorityComponent) == 0x000008, "Wrong alignment on UInteractionAuthorityComponent");
static_assert(sizeof(UInteractionAuthorityComponent) == 0x0000E0, "Wrong size on UInteractionAuthorityComponent");
static_assert(offsetof(UInteractionAuthorityComponent, OnInteractionStart) == 0x0000B0, "Member 'UInteractionAuthorityComponent::OnInteractionStart' has a wrong offset!");
static_assert(offsetof(UInteractionAuthorityComponent, OnInteractionCancel) == 0x0000C0, "Member 'UInteractionAuthorityComponent::OnInteractionCancel' has a wrong offset!");
static_assert(offsetof(UInteractionAuthorityComponent, OnInteractionComplete) == 0x0000D0, "Member 'UInteractionAuthorityComponent::OnInteractionComplete' has a wrong offset!");

// Class DeceiveInc.BaseContainerActor
// 0x0050 (0x0308 - 0x02B8)
class ABaseContainerActor : public ABaseInteractableActor
{
public:
	bool                                          bAllowNPCInteraction;                              // 0x02B8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         MovablePart;                                       // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EContainerState                               ContainerState;                                    // 0x02C8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OpenTime;                                          // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FContainerGeneratedData                GeneratedData;                                     // 0x02D0(0x0020)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x10];                                     // 0x02F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UNPCContainerInteraction*               NPCInteraction;                                    // 0x0300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BP_OnContainerClosing();
	void BP_OnContainerOpening();
	void OnPostInitRooms(class UWorld* World);
	void OnRep_ContainerState(EContainerState PreviousState);
	void OnTimeToEnableInteract();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseContainerActor">();
	}
	static class ABaseContainerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseContainerActor>();
	}
};
static_assert(alignof(ABaseContainerActor) == 0x000008, "Wrong alignment on ABaseContainerActor");
static_assert(sizeof(ABaseContainerActor) == 0x000308, "Wrong size on ABaseContainerActor");
static_assert(offsetof(ABaseContainerActor, bAllowNPCInteraction) == 0x0002B8, "Member 'ABaseContainerActor::bAllowNPCInteraction' has a wrong offset!");
static_assert(offsetof(ABaseContainerActor, MovablePart) == 0x0002C0, "Member 'ABaseContainerActor::MovablePart' has a wrong offset!");
static_assert(offsetof(ABaseContainerActor, ContainerState) == 0x0002C8, "Member 'ABaseContainerActor::ContainerState' has a wrong offset!");
static_assert(offsetof(ABaseContainerActor, OpenTime) == 0x0002CC, "Member 'ABaseContainerActor::OpenTime' has a wrong offset!");
static_assert(offsetof(ABaseContainerActor, GeneratedData) == 0x0002D0, "Member 'ABaseContainerActor::GeneratedData' has a wrong offset!");
static_assert(offsetof(ABaseContainerActor, NPCInteraction) == 0x000300, "Member 'ABaseContainerActor::NPCInteraction' has a wrong offset!");

// Class DeceiveInc.LarcinActiveMod1Ability
// 0x0070 (0x0600 - 0x0590)
class ALarcinActiveMod1Ability final : public ABaseSpyActiveAbility
{
public:
	float                                         TriggerDelay;                                      // 0x0590(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_594[0x4];                                      // 0x0594(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   SmokeBombClass;                                    // 0x0598(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SmokeBombDuration;                                 // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C4[0x4];                                      // 0x05C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AActor>                  SmokeBombClassInstance;                            // 0x05C8(0x0028)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F0[0x10];                                     // 0x05F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnLarcinActiveEffectBegin();
	void BP_OnLarcinActiveEffectBeginLocal();
	void BP_OnLarcinActiveEffectBeginReplicated();
	void OnSmokeBombTimerEnd();
	void OnTriggerDelayTimer();
	void TriggerAbilityEffectNetMulticast();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LarcinActiveMod1Ability">();
	}
	static class ALarcinActiveMod1Ability* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALarcinActiveMod1Ability>();
	}
};
static_assert(alignof(ALarcinActiveMod1Ability) == 0x000008, "Wrong alignment on ALarcinActiveMod1Ability");
static_assert(sizeof(ALarcinActiveMod1Ability) == 0x000600, "Wrong size on ALarcinActiveMod1Ability");
static_assert(offsetof(ALarcinActiveMod1Ability, TriggerDelay) == 0x000590, "Member 'ALarcinActiveMod1Ability::TriggerDelay' has a wrong offset!");
static_assert(offsetof(ALarcinActiveMod1Ability, SmokeBombClass) == 0x000598, "Member 'ALarcinActiveMod1Ability::SmokeBombClass' has a wrong offset!");
static_assert(offsetof(ALarcinActiveMod1Ability, SmokeBombDuration) == 0x0005C0, "Member 'ALarcinActiveMod1Ability::SmokeBombDuration' has a wrong offset!");
static_assert(offsetof(ALarcinActiveMod1Ability, SmokeBombClassInstance) == 0x0005C8, "Member 'ALarcinActiveMod1Ability::SmokeBombClassInstance' has a wrong offset!");

// Class DeceiveInc.DICustomGameUserWidget
// 0x0000 (0x0300 - 0x0300)
class UDICustomGameUserWidget final : public UDIMenuUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DICustomGameUserWidget">();
	}
	static class UDICustomGameUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDICustomGameUserWidget>();
	}
};
static_assert(alignof(UDICustomGameUserWidget) == 0x000008, "Wrong alignment on UDICustomGameUserWidget");
static_assert(sizeof(UDICustomGameUserWidget) == 0x000300, "Wrong size on UDICustomGameUserWidget");

// Class DeceiveInc.HansActiveAbilityMod2
// 0x0040 (0x05D0 - 0x0590)
class AHansActiveAbilityMod2 final : public ABaseSpyActiveAbility
{
public:
	float                                         TriggerDelay;                                      // 0x0590(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_594[0x4];                                      // 0x0594(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   CageZoneClass;                                     // 0x0598(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CageZoneInstance;                                  // 0x05C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C8[0x8];                                      // 0x05C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTriggerDelayTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HansActiveAbilityMod2">();
	}
	static class AHansActiveAbilityMod2* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHansActiveAbilityMod2>();
	}
};
static_assert(alignof(AHansActiveAbilityMod2) == 0x000008, "Wrong alignment on AHansActiveAbilityMod2");
static_assert(sizeof(AHansActiveAbilityMod2) == 0x0005D0, "Wrong size on AHansActiveAbilityMod2");
static_assert(offsetof(AHansActiveAbilityMod2, TriggerDelay) == 0x000590, "Member 'AHansActiveAbilityMod2::TriggerDelay' has a wrong offset!");
static_assert(offsetof(AHansActiveAbilityMod2, CageZoneClass) == 0x000598, "Member 'AHansActiveAbilityMod2::CageZoneClass' has a wrong offset!");
static_assert(offsetof(AHansActiveAbilityMod2, CageZoneInstance) == 0x0005C0, "Member 'AHansActiveAbilityMod2::CageZoneInstance' has a wrong offset!");

// Class DeceiveInc.BaseDispenserActor
// 0x0048 (0x0300 - 0x02B8)
class ABaseDispenserActor final : public ABaseInteractableActor
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EGameplayResourcesType                        ResourceTypeToGive;                                // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ResourceCountToGive;                               // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCooldownOnUsage;                                  // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCooldownComponent*                     PostUsageCooldownComponent;                        // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCooldownConditionComponent*            CooldownConditionComponent;                        // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         FactionJammingActors;                              // 0x02E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         JammingActors;                                     // 0x02F0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void BP_OnLocalDispenserJammed(bool bIsJammed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseDispenserActor">();
	}
	static class ABaseDispenserActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseDispenserActor>();
	}
};
static_assert(alignof(ABaseDispenserActor) == 0x000008, "Wrong alignment on ABaseDispenserActor");
static_assert(sizeof(ABaseDispenserActor) == 0x000300, "Wrong size on ABaseDispenserActor");
static_assert(offsetof(ABaseDispenserActor, ResourceTypeToGive) == 0x0002C0, "Member 'ABaseDispenserActor::ResourceTypeToGive' has a wrong offset!");
static_assert(offsetof(ABaseDispenserActor, ResourceCountToGive) == 0x0002C4, "Member 'ABaseDispenserActor::ResourceCountToGive' has a wrong offset!");
static_assert(offsetof(ABaseDispenserActor, bCooldownOnUsage) == 0x0002C8, "Member 'ABaseDispenserActor::bCooldownOnUsage' has a wrong offset!");
static_assert(offsetof(ABaseDispenserActor, PostUsageCooldownComponent) == 0x0002D0, "Member 'ABaseDispenserActor::PostUsageCooldownComponent' has a wrong offset!");
static_assert(offsetof(ABaseDispenserActor, CooldownConditionComponent) == 0x0002D8, "Member 'ABaseDispenserActor::CooldownConditionComponent' has a wrong offset!");
static_assert(offsetof(ABaseDispenserActor, FactionJammingActors) == 0x0002E0, "Member 'ABaseDispenserActor::FactionJammingActors' has a wrong offset!");
static_assert(offsetof(ABaseDispenserActor, JammingActors) == 0x0002F0, "Member 'ABaseDispenserActor::JammingActors' has a wrong offset!");

// Class DeceiveInc.HitLocationData
// 0x0050 (0x0088 - 0x0038)
class UHitLocationData final : public UDIPrimaryDataAsset
{
public:
	TMap<class FName, EHitType>                   BoneHitType;                                       // 0x0038(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitLocationData">();
	}
	static class UHitLocationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitLocationData>();
	}
};
static_assert(alignof(UHitLocationData) == 0x000008, "Wrong alignment on UHitLocationData");
static_assert(sizeof(UHitLocationData) == 0x000088, "Wrong size on UHitLocationData");
static_assert(offsetof(UHitLocationData, BoneHitType) == 0x000038, "Member 'UHitLocationData::BoneHitType' has a wrong offset!");

// Class DeceiveInc.BaseDoorActor
// 0x00A8 (0x0360 - 0x02B8)
class ABaseDoorActor final : public ABaseInteractableActor
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAppearAsLocallyUnlocked;                          // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDoorState                                    DoorState;                                         // 0x02C1(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESecurityLevel                                SecurityLevel;                                     // 0x02C2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanNPCsOpenDoor;                                  // 0x02C3(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanAggroedGuardsOpenDoor;                         // 0x02C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C5[0x3];                                      // 0x02C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ConditionMetIntelText;                             // 0x02C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   SecondaryResourceText;                             // 0x02E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   SingleCountText;                                   // 0x02F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         ClosingTime;                                       // 0x0310(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OverlapClosingTime;                                // 0x0314(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          OverlapCollisionBoxCheck;                          // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDoorClosedConditionComponent*          DoorClosedCondition;                               // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         FactionJammingActors;                              // 0x0330(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         JammingActors;                                     // 0x0340(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x10];                                     // 0x0350(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BP_IsDoorJammedForActor(class AActor* Actor);
	void BP_OnDoorClosing();
	void BP_OnDoorClosingFromBack();
	void BP_OnDoorClosingFromFront();
	void BP_OnDoorLocked();
	void BP_OnDoorOpening();
	void BP_OnDoorOpeningFromBack();
	void BP_OnDoorOpeningFromFront();
	void BP_OnDoorUnlocked();
	void BP_OnLocalDoorJammed(bool bIsJammed);
	void BP_OpenDoor(class AActor* ActorOpening, bool bValidate, float KeepOpenDuration);
	void DoDoorStuckChecks();
	void HandleDoorUnlocked(int32 PlayerIndex);
	void HandleLocalSpyResourcesNewAmount(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, EGameplayResourcesType AffectedResource, int32 NewResourceCount);
	void HandleResourceSpent(class UInteracterComponent* Interacter, EGameplayResourcesType ResourceType, int32 Amount);
	void OnRep_DoorState(EDoorState PreviousState);
	void OnTimeToTryClose();

	ESecurityLevel GetSecurityLevel() const;
	bool IsActorBehindDoor(class AActor* Actor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseDoorActor">();
	}
	static class ABaseDoorActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseDoorActor>();
	}
};
static_assert(alignof(ABaseDoorActor) == 0x000008, "Wrong alignment on ABaseDoorActor");
static_assert(sizeof(ABaseDoorActor) == 0x000360, "Wrong size on ABaseDoorActor");
static_assert(offsetof(ABaseDoorActor, bAppearAsLocallyUnlocked) == 0x0002C0, "Member 'ABaseDoorActor::bAppearAsLocallyUnlocked' has a wrong offset!");
static_assert(offsetof(ABaseDoorActor, DoorState) == 0x0002C1, "Member 'ABaseDoorActor::DoorState' has a wrong offset!");
static_assert(offsetof(ABaseDoorActor, SecurityLevel) == 0x0002C2, "Member 'ABaseDoorActor::SecurityLevel' has a wrong offset!");
static_assert(offsetof(ABaseDoorActor, bCanNPCsOpenDoor) == 0x0002C3, "Member 'ABaseDoorActor::bCanNPCsOpenDoor' has a wrong offset!");
static_assert(offsetof(ABaseDoorActor, bCanAggroedGuardsOpenDoor) == 0x0002C4, "Member 'ABaseDoorActor::bCanAggroedGuardsOpenDoor' has a wrong offset!");
static_assert(offsetof(ABaseDoorActor, ConditionMetIntelText) == 0x0002C8, "Member 'ABaseDoorActor::ConditionMetIntelText' has a wrong offset!");
static_assert(offsetof(ABaseDoorActor, SecondaryResourceText) == 0x0002E0, "Member 'ABaseDoorActor::SecondaryResourceText' has a wrong offset!");
static_assert(offsetof(ABaseDoorActor, SingleCountText) == 0x0002F8, "Member 'ABaseDoorActor::SingleCountText' has a wrong offset!");
static_assert(offsetof(ABaseDoorActor, ClosingTime) == 0x000310, "Member 'ABaseDoorActor::ClosingTime' has a wrong offset!");
static_assert(offsetof(ABaseDoorActor, OverlapClosingTime) == 0x000314, "Member 'ABaseDoorActor::OverlapClosingTime' has a wrong offset!");
static_assert(offsetof(ABaseDoorActor, OverlapCollisionBoxCheck) == 0x000318, "Member 'ABaseDoorActor::OverlapCollisionBoxCheck' has a wrong offset!");
static_assert(offsetof(ABaseDoorActor, DoorClosedCondition) == 0x000320, "Member 'ABaseDoorActor::DoorClosedCondition' has a wrong offset!");
static_assert(offsetof(ABaseDoorActor, FactionJammingActors) == 0x000330, "Member 'ABaseDoorActor::FactionJammingActors' has a wrong offset!");
static_assert(offsetof(ABaseDoorActor, JammingActors) == 0x000340, "Member 'ABaseDoorActor::JammingActors' has a wrong offset!");

// Class DeceiveInc.DIOnlinePartyInvite
// 0x0018 (0x0040 - 0x0028)
class UDIOnlinePartyInvite final : public UObject
{
public:
	class UDIOnlineFriendInfo*                    Sender;                                            // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIOnlinePartyInvite">();
	}
	static class UDIOnlinePartyInvite* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIOnlinePartyInvite>();
	}
};
static_assert(alignof(UDIOnlinePartyInvite) == 0x000008, "Wrong alignment on UDIOnlinePartyInvite");
static_assert(sizeof(UDIOnlinePartyInvite) == 0x000040, "Wrong size on UDIOnlinePartyInvite");
static_assert(offsetof(UDIOnlinePartyInvite, Sender) == 0x000028, "Member 'UDIOnlinePartyInvite::Sender' has a wrong offset!");

// Class DeceiveInc.YumiPassiveAbility
// 0x0008 (0x0538 - 0x0530)
class AYumiPassiveAbility final : public ABaseSpyPassiveAbility
{
public:
	float                                         GadgetsPercentCooldownReduction;                   // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_534[0x4];                                      // 0x0534(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSpyToolLoadComplete(class UToolLoadoutComponent* ToolLoadout);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"YumiPassiveAbility">();
	}
	static class AYumiPassiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<AYumiPassiveAbility>();
	}
};
static_assert(alignof(AYumiPassiveAbility) == 0x000008, "Wrong alignment on AYumiPassiveAbility");
static_assert(sizeof(AYumiPassiveAbility) == 0x000538, "Wrong size on AYumiPassiveAbility");
static_assert(offsetof(AYumiPassiveAbility, GadgetsPercentCooldownReduction) == 0x000530, "Member 'AYumiPassiveAbility::GadgetsPercentCooldownReduction' has a wrong offset!");

// Class DeceiveInc.BaseIntelActor
// 0x0058 (0x0310 - 0x02B8)
class ABaseIntelActor : public ABaseInteractableActor
{
public:
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnIntelHackedBy;                                   // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EGameplayResourcesType                        ResourceTypeToGive;                                // 0x02D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0x3];                                      // 0x02D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ResourceCountToGive;                               // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHackTrapScannableComponent*            HackTrapScannableComp;                             // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         FactionJammingActors;                              // 0x02F0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         JammingActors;                                     // 0x0300(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	bool BP_IsJammedForActor(class AActor* Actor);
	void BP_OnIntelEffectedByDrainChange(bool bEffectedByDrain, bool bEffectedByEnemy);
	void BP_OnIntelRebooted(class AActor* Instigater);
	void BP_OnLocalActorJammed(bool bIsJammed);
	bool IsDisabledByExternalSourceForActor(class AActor* Actor);
	bool IsDisabledByExternalSourceForLocalPlayer();
	bool IsJammedForLocalPlayer();

	int32 GetResourceCountToGive() const;
	EGameplayResourcesType GetResourceTypeToGive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseIntelActor">();
	}
	static class ABaseIntelActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseIntelActor>();
	}
};
static_assert(alignof(ABaseIntelActor) == 0x000008, "Wrong alignment on ABaseIntelActor");
static_assert(sizeof(ABaseIntelActor) == 0x000310, "Wrong size on ABaseIntelActor");
static_assert(offsetof(ABaseIntelActor, OnIntelHackedBy) == 0x0002C8, "Member 'ABaseIntelActor::OnIntelHackedBy' has a wrong offset!");
static_assert(offsetof(ABaseIntelActor, ResourceTypeToGive) == 0x0002D8, "Member 'ABaseIntelActor::ResourceTypeToGive' has a wrong offset!");
static_assert(offsetof(ABaseIntelActor, ResourceCountToGive) == 0x0002DC, "Member 'ABaseIntelActor::ResourceCountToGive' has a wrong offset!");
static_assert(offsetof(ABaseIntelActor, HackTrapScannableComp) == 0x0002E0, "Member 'ABaseIntelActor::HackTrapScannableComp' has a wrong offset!");
static_assert(offsetof(ABaseIntelActor, FactionJammingActors) == 0x0002F0, "Member 'ABaseIntelActor::FactionJammingActors' has a wrong offset!");
static_assert(offsetof(ABaseIntelActor, JammingActors) == 0x000300, "Member 'ABaseIntelActor::JammingActors' has a wrong offset!");

// Class DeceiveInc.ExtractionArrivingPhaseInfo
// 0x00E8 (0x0110 - 0x0028)
class UExtractionArrivingPhaseInfo final : public USpyGamePhaseInfo
{
public:
	struct FExtractionArrivingPhaseData           DefaultPhaseData;                                  // 0x0028(0x00E8)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	class FText GetObjectiveDescCarrier();
	class FText GetObjectiveDescNonCarrier();
	class FText GetObjectiveDescNonCarrierTeammate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExtractionArrivingPhaseInfo">();
	}
	static class UExtractionArrivingPhaseInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExtractionArrivingPhaseInfo>();
	}
};
static_assert(alignof(UExtractionArrivingPhaseInfo) == 0x000008, "Wrong alignment on UExtractionArrivingPhaseInfo");
static_assert(sizeof(UExtractionArrivingPhaseInfo) == 0x000110, "Wrong size on UExtractionArrivingPhaseInfo");
static_assert(offsetof(UExtractionArrivingPhaseInfo, DefaultPhaseData) == 0x000028, "Member 'UExtractionArrivingPhaseInfo::DefaultPhaseData' has a wrong offset!");

// Class DeceiveInc.BaseGenericChestActor
// 0x0048 (0x0358 - 0x0310)
class ABaseGenericChestActor final : public ABaseIntelActor
{
public:
	class UObjectSpawnComponent*                  ObjectSpawnComp;                                   // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URayCastConditionComponent*             RayCastCond;                                       // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UResourceConditionComponent*            ResourceCond;                                      // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaxUseConditionComponent*              MaxUseCond;                                        // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USingleUserConditionComponent*          SingleUserCond;                                    // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   AlreadyOwnedPowerup;                               // 0x0338(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EGameplayResourcesType                        PowerupRessources;                                 // 0x0350(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_CloseDoor();
	void HandleResourceSpent(class UInteracterComponent* Interacter, EGameplayResourcesType ResourceType, int32 Amount);
	void HandleSpawnSetupedComplete();
	void Multicast_CloseDoor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseGenericChestActor">();
	}
	static class ABaseGenericChestActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseGenericChestActor>();
	}
};
static_assert(alignof(ABaseGenericChestActor) == 0x000008, "Wrong alignment on ABaseGenericChestActor");
static_assert(sizeof(ABaseGenericChestActor) == 0x000358, "Wrong size on ABaseGenericChestActor");
static_assert(offsetof(ABaseGenericChestActor, ObjectSpawnComp) == 0x000310, "Member 'ABaseGenericChestActor::ObjectSpawnComp' has a wrong offset!");
static_assert(offsetof(ABaseGenericChestActor, RayCastCond) == 0x000318, "Member 'ABaseGenericChestActor::RayCastCond' has a wrong offset!");
static_assert(offsetof(ABaseGenericChestActor, ResourceCond) == 0x000320, "Member 'ABaseGenericChestActor::ResourceCond' has a wrong offset!");
static_assert(offsetof(ABaseGenericChestActor, MaxUseCond) == 0x000328, "Member 'ABaseGenericChestActor::MaxUseCond' has a wrong offset!");
static_assert(offsetof(ABaseGenericChestActor, SingleUserCond) == 0x000330, "Member 'ABaseGenericChestActor::SingleUserCond' has a wrong offset!");
static_assert(offsetof(ABaseGenericChestActor, AlreadyOwnedPowerup) == 0x000338, "Member 'ABaseGenericChestActor::AlreadyOwnedPowerup' has a wrong offset!");
static_assert(offsetof(ABaseGenericChestActor, PowerupRessources) == 0x000350, "Member 'ABaseGenericChestActor::PowerupRessources' has a wrong offset!");

// Class DeceiveInc.BaseMeleeAttack
// 0x02C8 (0x07F8 - 0x0530)
class ABaseMeleeAttack : public ABaseSpyTool
{
public:
	FMulticastInlineDelegateProperty_             OnMeleeAttackHit;                                  // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMeleeAttackEvent;                                // 0x0540(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMeleeAttackDamageDoneServer;                     // 0x0550(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMeleeAttackLocalDoMelee;                         // 0x0560(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMeleeAttackEnvironmentHit;                       // 0x0570(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMeleeAttackCogOffsetChange;                      // 0x0580(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bFullBodyMeleeAnimation1P;                         // 0x0590(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_591[0x3];                                      // 0x0591(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CogOffsetHeight;                                   // 0x0594(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectiveConnectRange;                             // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ConnectRadius;                                     // 0x059C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseBoxSweep;                                      // 0x05A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A1[0x3];                                      // 0x05A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoxHalfExtents;                                    // 0x05A4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowMultiHit;                                    // 0x05B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B1[0x3];                                      // 0x05B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseImpactForce;                                   // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseDamage;                                        // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlockWhenSpyAndDisguiseInvisible;                 // 0x05BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5BD[0x3];                                      // 0x05BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CooldownBetweenStrikes;                            // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CooldownBeforeShooting;                            // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CooldownBetweenStrikesChargeLevel1;                // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5CC[0x4];                                      // 0x05CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 CooldownBeforeShootingChargeLevel;                 // 0x05D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bBlockWeaponOnMelee;                               // 0x05E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlockRunOnMelee;                                  // 0x05E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E2[0x6];                                      // 0x05E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMeleeChargeLevel>              ChargeLevels;                                      // 0x05E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	ECollisionChannel                             HitCollisionChannel;                               // 0x05F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoImpulseOnMeleeAttack;                           // 0x05F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5FA[0x2];                                      // 0x05FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpulseSpeed;                                      // 0x05FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistToStopFromTarget;                              // 0x0600(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoImpulseOnTargetOnly;                            // 0x0604(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_605[0x3];                                      // 0x0605(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Max2DDistance;                                     // 0x0608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Max3DDistance;                                     // 0x060C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxRightDistance;                                  // 0x0610(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetMaxAngle;                                    // 0x0614(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetingHeight;                                   // 0x0618(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetingRotationDuration;                         // 0x061C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetingPitchPrecision;                           // 0x0620(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetingYawPrecision;                             // 0x0624(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTargetingOnImpulseEndOnly;                        // 0x0628(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMustBeInCamera;                                   // 0x0629(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_62A[0x2];                                      // 0x062A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MustBeInCameraRenderedTolerance;                   // 0x062C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BalancingName;                                     // 0x0630(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             BalancingDataTable;                                // 0x0638(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_640[0x128];                                    // 0x0640(0x0128)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UObject*>                          DamageOutputModifiers;                             // 0x0768(0x0050)(Protected, NativeAccessSpecifierProtected)
	class AActor*                                 MeleeTarget;                                       // 0x07B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int8                                          CurrentChargeLevel;                                // 0x07C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C1[0x1];                                      // 0x07C1(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bBlowCoverOnHit;                                   // 0x07C2(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoDamage;                                         // 0x07C3(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C4[0x4];                                      // 0x07C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   EffectOnPawnHit;                                   // 0x07C8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DoEffectOnEnemyFactionOnly;                        // 0x07F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckForEnvHitOnMiss;                             // 0x07F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F2[0x6];                                      // 0x07F2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool GetWeaponBalancingDataForClass(class UClass* WeaponClass, float* BaseDamage_0);

	void BP_OnChargeLevelChange(int32 NewChargeLevel);
	void BP_OnMeleeAttack(int32 ChargeLevel);
	void BP_OnMeleeAttackHit(class AActor* Victim, const struct FVector& ImpactPoint, int32 ChargeLevel, float Damage, float ResultingHealthPercentage, EHitType HitType, const struct FMeleeHitConfirmedData& HitConfirmedData);
	void BP_OnMeleeCancel();
	void Multicast_CancelMelee();
	void Multicast_DoImpulseMelee(const struct FVector_NetQuantize& OriginPos, const struct FVector_NetQuantize& DestinationPos, int8 ChargeLevel, const TArray<struct FHitResult>& ActorHit);
	void Multicast_DoStrike(const struct FVector_NetQuantize& DestinationPos, int8 ChargeLevel);
	void Multicast_EnvHit(const struct FMeleeHitConfirmedData& HitConfirmedData);
	void Multicast_HitConfirmed(const struct FMeleeHitConfirmedData& HitConfirmedData);
	void NetMulticast_SetupTargetInfo(class AActor* Target, bool bImpulse);
	void OnCooldownTimerComplete();
	void OnDisableWeaponTimerComplete();
	void OnImpulseCooldownTimerComplete();
	void OnRep_CurrentChargeLevel(int8 OldChargeLevel);
	void Server_BeginCharge();
	void Server_DoImpulseMelee(const struct FVector_NetQuantize& OriginPos, const struct FVector_NetQuantize& DestinationPos, const TArray<struct FHitResult>& HitTargets, int8 ChargeLevel);
	void Server_DoStrike(const struct FVector_NetQuantize& OriginPos, const struct FVector_NetQuantize& DestinationPos, const TArray<struct FHitResult>& HitTargets, int8 ChargeLevel);
	void Server_ExternalSetOnCooldown();
	void Server_ResetCharge(bool bIsCancel);
	void Server_SetupTargetInfo(class AActor* Target, bool bImpulse);

	int32 GetChargeLevel() const;
	float GetCooldownBeforeShooting(int32 ChargeLevel) const;
	float GetCooldownBetweenStrikes(int32 ChargeLevel) const;
	float GetLastAttackCooldownBetweenStrikes() const;
	int32 GetLastAttckChargeLevel() const;
	float GetMaxChargeTime() const;
	float GetMeleeCogOffset() const;
	bool IsCanCancelMelee() const;
	bool IsCharging() const;
	bool IsFullyCharge() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseMeleeAttack">();
	}
	static class ABaseMeleeAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseMeleeAttack>();
	}
};
static_assert(alignof(ABaseMeleeAttack) == 0x000008, "Wrong alignment on ABaseMeleeAttack");
static_assert(sizeof(ABaseMeleeAttack) == 0x0007F8, "Wrong size on ABaseMeleeAttack");
static_assert(offsetof(ABaseMeleeAttack, OnMeleeAttackHit) == 0x000530, "Member 'ABaseMeleeAttack::OnMeleeAttackHit' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, OnMeleeAttackEvent) == 0x000540, "Member 'ABaseMeleeAttack::OnMeleeAttackEvent' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, OnMeleeAttackDamageDoneServer) == 0x000550, "Member 'ABaseMeleeAttack::OnMeleeAttackDamageDoneServer' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, OnMeleeAttackLocalDoMelee) == 0x000560, "Member 'ABaseMeleeAttack::OnMeleeAttackLocalDoMelee' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, OnMeleeAttackEnvironmentHit) == 0x000570, "Member 'ABaseMeleeAttack::OnMeleeAttackEnvironmentHit' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, OnMeleeAttackCogOffsetChange) == 0x000580, "Member 'ABaseMeleeAttack::OnMeleeAttackCogOffsetChange' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, bFullBodyMeleeAnimation1P) == 0x000590, "Member 'ABaseMeleeAttack::bFullBodyMeleeAnimation1P' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, CogOffsetHeight) == 0x000594, "Member 'ABaseMeleeAttack::CogOffsetHeight' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, EffectiveConnectRange) == 0x000598, "Member 'ABaseMeleeAttack::EffectiveConnectRange' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, ConnectRadius) == 0x00059C, "Member 'ABaseMeleeAttack::ConnectRadius' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, bUseBoxSweep) == 0x0005A0, "Member 'ABaseMeleeAttack::bUseBoxSweep' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, BoxHalfExtents) == 0x0005A4, "Member 'ABaseMeleeAttack::BoxHalfExtents' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, bAllowMultiHit) == 0x0005B0, "Member 'ABaseMeleeAttack::bAllowMultiHit' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, BaseImpactForce) == 0x0005B4, "Member 'ABaseMeleeAttack::BaseImpactForce' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, BaseDamage) == 0x0005B8, "Member 'ABaseMeleeAttack::BaseDamage' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, bBlockWhenSpyAndDisguiseInvisible) == 0x0005BC, "Member 'ABaseMeleeAttack::bBlockWhenSpyAndDisguiseInvisible' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, CooldownBetweenStrikes) == 0x0005C0, "Member 'ABaseMeleeAttack::CooldownBetweenStrikes' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, CooldownBeforeShooting) == 0x0005C4, "Member 'ABaseMeleeAttack::CooldownBeforeShooting' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, CooldownBetweenStrikesChargeLevel1) == 0x0005C8, "Member 'ABaseMeleeAttack::CooldownBetweenStrikesChargeLevel1' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, CooldownBeforeShootingChargeLevel) == 0x0005D0, "Member 'ABaseMeleeAttack::CooldownBeforeShootingChargeLevel' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, bBlockWeaponOnMelee) == 0x0005E0, "Member 'ABaseMeleeAttack::bBlockWeaponOnMelee' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, bBlockRunOnMelee) == 0x0005E1, "Member 'ABaseMeleeAttack::bBlockRunOnMelee' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, ChargeLevels) == 0x0005E8, "Member 'ABaseMeleeAttack::ChargeLevels' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, HitCollisionChannel) == 0x0005F8, "Member 'ABaseMeleeAttack::HitCollisionChannel' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, bDoImpulseOnMeleeAttack) == 0x0005F9, "Member 'ABaseMeleeAttack::bDoImpulseOnMeleeAttack' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, ImpulseSpeed) == 0x0005FC, "Member 'ABaseMeleeAttack::ImpulseSpeed' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, DistToStopFromTarget) == 0x000600, "Member 'ABaseMeleeAttack::DistToStopFromTarget' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, bDoImpulseOnTargetOnly) == 0x000604, "Member 'ABaseMeleeAttack::bDoImpulseOnTargetOnly' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, Max2DDistance) == 0x000608, "Member 'ABaseMeleeAttack::Max2DDistance' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, Max3DDistance) == 0x00060C, "Member 'ABaseMeleeAttack::Max3DDistance' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, MaxRightDistance) == 0x000610, "Member 'ABaseMeleeAttack::MaxRightDistance' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, TargetMaxAngle) == 0x000614, "Member 'ABaseMeleeAttack::TargetMaxAngle' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, TargetingHeight) == 0x000618, "Member 'ABaseMeleeAttack::TargetingHeight' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, TargetingRotationDuration) == 0x00061C, "Member 'ABaseMeleeAttack::TargetingRotationDuration' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, TargetingPitchPrecision) == 0x000620, "Member 'ABaseMeleeAttack::TargetingPitchPrecision' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, TargetingYawPrecision) == 0x000624, "Member 'ABaseMeleeAttack::TargetingYawPrecision' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, bTargetingOnImpulseEndOnly) == 0x000628, "Member 'ABaseMeleeAttack::bTargetingOnImpulseEndOnly' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, bMustBeInCamera) == 0x000629, "Member 'ABaseMeleeAttack::bMustBeInCamera' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, MustBeInCameraRenderedTolerance) == 0x00062C, "Member 'ABaseMeleeAttack::MustBeInCameraRenderedTolerance' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, BalancingName) == 0x000630, "Member 'ABaseMeleeAttack::BalancingName' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, BalancingDataTable) == 0x000638, "Member 'ABaseMeleeAttack::BalancingDataTable' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, DamageOutputModifiers) == 0x000768, "Member 'ABaseMeleeAttack::DamageOutputModifiers' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, MeleeTarget) == 0x0007B8, "Member 'ABaseMeleeAttack::MeleeTarget' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, CurrentChargeLevel) == 0x0007C0, "Member 'ABaseMeleeAttack::CurrentChargeLevel' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, bBlowCoverOnHit) == 0x0007C2, "Member 'ABaseMeleeAttack::bBlowCoverOnHit' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, bDoDamage) == 0x0007C3, "Member 'ABaseMeleeAttack::bDoDamage' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, EffectOnPawnHit) == 0x0007C8, "Member 'ABaseMeleeAttack::EffectOnPawnHit' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, DoEffectOnEnemyFactionOnly) == 0x0007F0, "Member 'ABaseMeleeAttack::DoEffectOnEnemyFactionOnly' has a wrong offset!");
static_assert(offsetof(ABaseMeleeAttack, bCheckForEnvHitOnMiss) == 0x0007F1, "Member 'ABaseMeleeAttack::bCheckForEnvHitOnMiss' has a wrong offset!");

// Class DeceiveInc.BaseScannableActor
// 0x0008 (0x0228 - 0x0220)
class ABaseScannableActor : public AActor
{
public:
	class USphereComponent*                       RegistrationCollisionShapeComp;                    // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseScannableActor">();
	}
	static class ABaseScannableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseScannableActor>();
	}
};
static_assert(alignof(ABaseScannableActor) == 0x000008, "Wrong alignment on ABaseScannableActor");
static_assert(sizeof(ABaseScannableActor) == 0x000228, "Wrong size on ABaseScannableActor");
static_assert(offsetof(ABaseScannableActor, RegistrationCollisionShapeComp) == 0x000220, "Member 'ABaseScannableActor::RegistrationCollisionShapeComp' has a wrong offset!");

// Class DeceiveInc.BaseMimicScannableActor
// 0x00A8 (0x02D0 - 0x0228)
class ABaseMimicScannableActor final : public ABaseScannableActor
{
public:
	FMulticastInlineDelegateProperty_             OnMimicTransform;                                  // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMimicPositioned;                                 // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMimicVisibility;                                 // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_258[0x20];                                     // 0x0258(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class ASpy*                                   SpyOwner;                                          // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPrimitiveComponent*>            ActorsInRange;                                     // 0x0280(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CamSpringArmLocation;                              // 0x0298(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               InMimicAdditionalRotation;                         // 0x02A4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UMimicScannableComponent*               MimicScannableComp;                                // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHealthComponent*                       HealthComp;                                        // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNPCInteractionComponent*               NPCInteract;                                       // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SweepRadius;                                       // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             SweepCollisionChannel;                             // 0x02CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             CollisionChannelToIgnoreWhenMoving;                // 0x02CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CE[0x2];                                      // 0x02CE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleLocalSpyMovingChanged(class ASpy* Spy, bool bMoving);
	void HandleSpectatingPlayerChangeEvent(class ADeceiveIncPlayerController* PlayerController, class AActor* SpectatingActor, class ADIPlayerState* SpectatingPlayerState);
	void NetMulticast_EnableInteract(bool bEnable);
	void Server_EnableInteract(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseMimicScannableActor">();
	}
	static class ABaseMimicScannableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseMimicScannableActor>();
	}
};
static_assert(alignof(ABaseMimicScannableActor) == 0x000008, "Wrong alignment on ABaseMimicScannableActor");
static_assert(sizeof(ABaseMimicScannableActor) == 0x0002D0, "Wrong size on ABaseMimicScannableActor");
static_assert(offsetof(ABaseMimicScannableActor, OnMimicTransform) == 0x000228, "Member 'ABaseMimicScannableActor::OnMimicTransform' has a wrong offset!");
static_assert(offsetof(ABaseMimicScannableActor, OnMimicPositioned) == 0x000238, "Member 'ABaseMimicScannableActor::OnMimicPositioned' has a wrong offset!");
static_assert(offsetof(ABaseMimicScannableActor, OnMimicVisibility) == 0x000248, "Member 'ABaseMimicScannableActor::OnMimicVisibility' has a wrong offset!");
static_assert(offsetof(ABaseMimicScannableActor, SpyOwner) == 0x000278, "Member 'ABaseMimicScannableActor::SpyOwner' has a wrong offset!");
static_assert(offsetof(ABaseMimicScannableActor, ActorsInRange) == 0x000280, "Member 'ABaseMimicScannableActor::ActorsInRange' has a wrong offset!");
static_assert(offsetof(ABaseMimicScannableActor, CamSpringArmLocation) == 0x000298, "Member 'ABaseMimicScannableActor::CamSpringArmLocation' has a wrong offset!");
static_assert(offsetof(ABaseMimicScannableActor, InMimicAdditionalRotation) == 0x0002A4, "Member 'ABaseMimicScannableActor::InMimicAdditionalRotation' has a wrong offset!");
static_assert(offsetof(ABaseMimicScannableActor, MimicScannableComp) == 0x0002B0, "Member 'ABaseMimicScannableActor::MimicScannableComp' has a wrong offset!");
static_assert(offsetof(ABaseMimicScannableActor, HealthComp) == 0x0002B8, "Member 'ABaseMimicScannableActor::HealthComp' has a wrong offset!");
static_assert(offsetof(ABaseMimicScannableActor, NPCInteract) == 0x0002C0, "Member 'ABaseMimicScannableActor::NPCInteract' has a wrong offset!");
static_assert(offsetof(ABaseMimicScannableActor, SweepRadius) == 0x0002C8, "Member 'ABaseMimicScannableActor::SweepRadius' has a wrong offset!");
static_assert(offsetof(ABaseMimicScannableActor, SweepCollisionChannel) == 0x0002CC, "Member 'ABaseMimicScannableActor::SweepCollisionChannel' has a wrong offset!");
static_assert(offsetof(ABaseMimicScannableActor, CollisionChannelToIgnoreWhenMoving) == 0x0002CD, "Member 'ABaseMimicScannableActor::CollisionChannelToIgnoreWhenMoving' has a wrong offset!");

// Class DeceiveInc.LarcinActiveAbility
// 0x0040 (0x05D0 - 0x0590)
class ALarcinActiveAbility final : public ABaseSpyActiveAbility
{
public:
	float                                         TriggerDelay;                                      // 0x0590(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_594[0x4];                                      // 0x0594(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ImmaterialEffect;                                  // 0x0598(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AVictimEffect*                          ImmaterialEffectInstance;                          // 0x05C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C8[0x8];                                      // 0x05C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnLarcinActiveEffectBegin();
	void BP_OnLarcinActiveEffectBeginLocal();
	void BP_OnLarcinActiveEffectBeginReplicated();
	void OnTriggerDelayTimer();
	void TriggerAbilityEffectNetMulticast();

	bool BP_IsLarcinActiveTriggered() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LarcinActiveAbility">();
	}
	static class ALarcinActiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALarcinActiveAbility>();
	}
};
static_assert(alignof(ALarcinActiveAbility) == 0x000008, "Wrong alignment on ALarcinActiveAbility");
static_assert(sizeof(ALarcinActiveAbility) == 0x0005D0, "Wrong size on ALarcinActiveAbility");
static_assert(offsetof(ALarcinActiveAbility, TriggerDelay) == 0x000590, "Member 'ALarcinActiveAbility::TriggerDelay' has a wrong offset!");
static_assert(offsetof(ALarcinActiveAbility, ImmaterialEffect) == 0x000598, "Member 'ALarcinActiveAbility::ImmaterialEffect' has a wrong offset!");
static_assert(offsetof(ALarcinActiveAbility, ImmaterialEffectInstance) == 0x0005C0, "Member 'ALarcinActiveAbility::ImmaterialEffectInstance' has a wrong offset!");

// Class DeceiveInc.BasePickableActor
// 0x0038 (0x02F0 - 0x02B8)
class ABasePickableActor : public ABaseInteractableActor
{
public:
	class FText                                   SingleCountText;                                   // 0x02B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UMeshComponent*                         PickableMesh;                                      // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshComponent*                         ResidualMesh;                                      // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameplayResourcesType                        ResourceTypeToGive;                                // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E1[0x3];                                      // 0x02E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ResourceCountToGive;                               // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HideResidualBeforeCollection;                      // 0x02E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCollected;                                        // 0x02E9(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKillOnCollect;                                    // 0x02EA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHideBaseIfUnusable;                               // 0x02EB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAffectChildrenVisibility;                         // 0x02EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCached;                                         // 0x02ED(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EE[0x2];                                      // 0x02EE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleMaxUseChanged();
	void OnRep_Collected(bool PreviousCollected);

	void BP_OverrideGivenRessource(class AActor* Interacter, EGameplayResourcesType* OverrideRessourceType, int32* OverrideRessourceCount) const;
	int32 GetResourceCountToGive(class AActor* Interacter) const;
	EGameplayResourcesType GetResourceTypeToGive(class AActor* Interacter) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePickableActor">();
	}
	static class ABasePickableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABasePickableActor>();
	}
};
static_assert(alignof(ABasePickableActor) == 0x000008, "Wrong alignment on ABasePickableActor");
static_assert(sizeof(ABasePickableActor) == 0x0002F0, "Wrong size on ABasePickableActor");
static_assert(offsetof(ABasePickableActor, SingleCountText) == 0x0002B8, "Member 'ABasePickableActor::SingleCountText' has a wrong offset!");
static_assert(offsetof(ABasePickableActor, PickableMesh) == 0x0002D0, "Member 'ABasePickableActor::PickableMesh' has a wrong offset!");
static_assert(offsetof(ABasePickableActor, ResidualMesh) == 0x0002D8, "Member 'ABasePickableActor::ResidualMesh' has a wrong offset!");
static_assert(offsetof(ABasePickableActor, ResourceTypeToGive) == 0x0002E0, "Member 'ABasePickableActor::ResourceTypeToGive' has a wrong offset!");
static_assert(offsetof(ABasePickableActor, ResourceCountToGive) == 0x0002E4, "Member 'ABasePickableActor::ResourceCountToGive' has a wrong offset!");
static_assert(offsetof(ABasePickableActor, HideResidualBeforeCollection) == 0x0002E8, "Member 'ABasePickableActor::HideResidualBeforeCollection' has a wrong offset!");
static_assert(offsetof(ABasePickableActor, bCollected) == 0x0002E9, "Member 'ABasePickableActor::bCollected' has a wrong offset!");
static_assert(offsetof(ABasePickableActor, bKillOnCollect) == 0x0002EA, "Member 'ABasePickableActor::bKillOnCollect' has a wrong offset!");
static_assert(offsetof(ABasePickableActor, bHideBaseIfUnusable) == 0x0002EB, "Member 'ABasePickableActor::bHideBaseIfUnusable' has a wrong offset!");
static_assert(offsetof(ABasePickableActor, bAffectChildrenVisibility) == 0x0002EC, "Member 'ABasePickableActor::bAffectChildrenVisibility' has a wrong offset!");
static_assert(offsetof(ABasePickableActor, bIsCached) == 0x0002ED, "Member 'ABasePickableActor::bIsCached' has a wrong offset!");

// Class DeceiveInc.DICameraLense
// 0x0040 (0x07F0 - 0x07B0)
class ADICameraLense : public ACameraActor
{
public:
	uint8                                         Pad_7B0[0x40];                                     // 0x07B0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DICameraLense">();
	}
	static class ADICameraLense* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADICameraLense>();
	}
};
static_assert(alignof(ADICameraLense) == 0x000010, "Wrong alignment on ADICameraLense");
static_assert(sizeof(ADICameraLense) == 0x0007F0, "Wrong size on ADICameraLense");

// Class DeceiveInc.SweetAimAssistInputModifierYaw1D
// 0x0000 (0x0038 - 0x0038)
class USweetAimAssistInputModifierYaw1D : public USweetAimAssistInputModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SweetAimAssistInputModifierYaw1D">();
	}
	static class USweetAimAssistInputModifierYaw1D* GetDefaultObj()
	{
		return GetDefaultObjImpl<USweetAimAssistInputModifierYaw1D>();
	}
};
static_assert(alignof(USweetAimAssistInputModifierYaw1D) == 0x000008, "Wrong alignment on USweetAimAssistInputModifierYaw1D");
static_assert(sizeof(USweetAimAssistInputModifierYaw1D) == 0x000038, "Wrong size on USweetAimAssistInputModifierYaw1D");

// Class DeceiveInc.BasePickableToolActor
// 0x0040 (0x02F8 - 0x02B8)
class ABasePickableToolActor final : public ABaseInteractableActor
{
public:
	class UMeshComponent*                         PickableMesh;                                      // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshComponent*                         ResidualMesh;                                      // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   InHandEquipmentToSpawn;                            // 0x02C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPickableToolSlot                             TargetSlot;                                        // 0x02F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HideResidualBeforeCollection;                      // 0x02F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DestroyAfterCollection;                            // 0x02F2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCollected;                                        // 0x02F3(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Collected(bool PreviousCollected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePickableToolActor">();
	}
	static class ABasePickableToolActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABasePickableToolActor>();
	}
};
static_assert(alignof(ABasePickableToolActor) == 0x000008, "Wrong alignment on ABasePickableToolActor");
static_assert(sizeof(ABasePickableToolActor) == 0x0002F8, "Wrong size on ABasePickableToolActor");
static_assert(offsetof(ABasePickableToolActor, PickableMesh) == 0x0002B8, "Member 'ABasePickableToolActor::PickableMesh' has a wrong offset!");
static_assert(offsetof(ABasePickableToolActor, ResidualMesh) == 0x0002C0, "Member 'ABasePickableToolActor::ResidualMesh' has a wrong offset!");
static_assert(offsetof(ABasePickableToolActor, InHandEquipmentToSpawn) == 0x0002C8, "Member 'ABasePickableToolActor::InHandEquipmentToSpawn' has a wrong offset!");
static_assert(offsetof(ABasePickableToolActor, TargetSlot) == 0x0002F0, "Member 'ABasePickableToolActor::TargetSlot' has a wrong offset!");
static_assert(offsetof(ABasePickableToolActor, HideResidualBeforeCollection) == 0x0002F1, "Member 'ABasePickableToolActor::HideResidualBeforeCollection' has a wrong offset!");
static_assert(offsetof(ABasePickableToolActor, DestroyAfterCollection) == 0x0002F2, "Member 'ABasePickableToolActor::DestroyAfterCollection' has a wrong offset!");
static_assert(offsetof(ABasePickableToolActor, bCollected) == 0x0002F3, "Member 'ABasePickableToolActor::bCollected' has a wrong offset!");

// Class DeceiveInc.InteracterComponent
// 0x0240 (0x02F0 - 0x00B0)
class UInteracterComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnLocalInteractionStart;                           // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLocalInteractionCancel;                          // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLocalInteractionComplete;                        // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNewFocusedInteractable;                          // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRegisterInteractable;                            // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUnregisterInteractable;                          // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAddInRangeInteractable;                          // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemoveInRangeInteractable;                       // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAddInteractionTimeReduction;                     // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemoveInteractionTimeReduction;                  // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bValidateConditions;                               // 0x0150(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInteractableState>             InteractableList;                                  // 0x0158(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UInteractableComponent*>         InRangeInteractableList;                           // 0x0168(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UInteractableComponent*>         InteractableToIgnore;                              // 0x0178(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class UInteractableComponent*, EInteractableState> InteractableStateMap;                              // 0x0188(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 InteractingWith;                                   // 0x01D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 ContinuousInteractingWith;                         // 0x01E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 OldBestInteractble;                                // 0x01E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 FocusedInteractable;                               // 0x01F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FInteractableTypeBlockRequest>  BlockInteractableTypeRequest;                      // 0x01F8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         InteractionTimeReduction;                          // 0x0208(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CustomInteractionDuration;                         // 0x020C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractTimeDefaultMultiplier;                     // 0x0210(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_214[0x4];                                      // 0x0214(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EInteractableType>                     InteractableInteractTypeList;                      // 0x0218(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bAffectInteractIcon;                               // 0x0228(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseOnlyRayCastCondition;                          // 0x0229(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverwriteInteractionCallback;                     // 0x022A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22B[0x5];                                      // 0x022B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EInteractCancelType>                   InteractCancelTypeToIgnore;                        // 0x0230(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   InteractWidgetIconClass;                           // 0x0240(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InteractWidgetIconPriority;                        // 0x0268(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FrustumTestRadius;                                 // 0x026C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFrustumTestInteracts;                             // 0x0270(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanTriggerBotSuspiciousness;                      // 0x0271(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_272[0x16];                                     // 0x0272(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SpyOwner;                                          // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 SpyActor;                                          // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AActor*, int32>                    DisableRequest;                                    // 0x02A0(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void BlockAllInteractableTypes(const TArray<EInteractableType>& TypesToNotBlock, class AActor* Requester);
	void BlockInteractableTypes(const TArray<EInteractableType>& TypesToBlock, class AActor* Requester);
	void EnableInteracter(bool bEnable, class AActor* Requester);
	void ExternalServerCompleteInteraction(class UInteractableComponent* InteractableComp);
	void HandleBooleanPlayerSettingChange(EPlayerSettingsType SettingType, bool NewValue);
	void HandleInteractCancelEvent(class ADeceiveIncPlayerController* Spy, EInteractCancelType InteractCancelType);
	void ServerCancelInteraction(class UInteractableComponent* InteractableComp);
	void ServerCompleteInteraction(class UInteractableComponent* InteractableComp, EConditionType ConditionType);
	void ServerStartInteraction(class UInteractableComponent* InteractableComp);
	void UnblockAllInteractableTypesForRequester(class AActor* Requester);
	void UnblockInteractableTypesForRequester(const TArray<EInteractableType>& TypesToUnblock, class AActor* Requester);

	float GetCurrentInteractionDuration() const;
	float GetCustomInteractionDuration() const;
	TArray<class UInteractableComponent*> GetInRangeInteractableList() const;
	TArray<struct FInteractableState> GetInteractableList() const;
	float GetInteractionDistance() const;
	float GetInteractionDuration(class UInteractableComponent* InteractableComp) const;
	float GetInteractionDurationWithReduction(float InteractableDuration, bool AllowPowerupReduction) const;
	float GetInteractionTimePercent() const;
	class AActor* GetSpyActor() const;
	class AActor* GetSpyOwner() const;
	class ADIPlayerState* GetSpyOwnerPlayerState() const;
	bool IsBot() const;
	bool IsInteracting() const;
	bool IsInteractTypeBlocked(class UInteractableComponent* InteractableComp) const;
	bool IsLocalInteracter() const;
	bool IsValidInteractCancelType(EInteractCancelType InteractCancelType) const;
	bool IsValidInteractType(class UInteractableComponent* InteractableComp, bool bCheckIfBlocked) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteracterComponent">();
	}
	static class UInteracterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteracterComponent>();
	}
};
static_assert(alignof(UInteracterComponent) == 0x000008, "Wrong alignment on UInteracterComponent");
static_assert(sizeof(UInteracterComponent) == 0x0002F0, "Wrong size on UInteracterComponent");
static_assert(offsetof(UInteracterComponent, OnLocalInteractionStart) == 0x0000B0, "Member 'UInteracterComponent::OnLocalInteractionStart' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, OnLocalInteractionCancel) == 0x0000C0, "Member 'UInteracterComponent::OnLocalInteractionCancel' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, OnLocalInteractionComplete) == 0x0000D0, "Member 'UInteracterComponent::OnLocalInteractionComplete' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, OnNewFocusedInteractable) == 0x0000E0, "Member 'UInteracterComponent::OnNewFocusedInteractable' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, OnRegisterInteractable) == 0x0000F0, "Member 'UInteracterComponent::OnRegisterInteractable' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, OnUnregisterInteractable) == 0x000100, "Member 'UInteracterComponent::OnUnregisterInteractable' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, OnAddInRangeInteractable) == 0x000110, "Member 'UInteracterComponent::OnAddInRangeInteractable' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, OnRemoveInRangeInteractable) == 0x000120, "Member 'UInteracterComponent::OnRemoveInRangeInteractable' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, OnAddInteractionTimeReduction) == 0x000130, "Member 'UInteracterComponent::OnAddInteractionTimeReduction' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, OnRemoveInteractionTimeReduction) == 0x000140, "Member 'UInteracterComponent::OnRemoveInteractionTimeReduction' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, bValidateConditions) == 0x000150, "Member 'UInteracterComponent::bValidateConditions' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, InteractableList) == 0x000158, "Member 'UInteracterComponent::InteractableList' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, InRangeInteractableList) == 0x000168, "Member 'UInteracterComponent::InRangeInteractableList' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, InteractableToIgnore) == 0x000178, "Member 'UInteracterComponent::InteractableToIgnore' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, InteractableStateMap) == 0x000188, "Member 'UInteracterComponent::InteractableStateMap' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, InteractingWith) == 0x0001D8, "Member 'UInteracterComponent::InteractingWith' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, ContinuousInteractingWith) == 0x0001E0, "Member 'UInteracterComponent::ContinuousInteractingWith' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, OldBestInteractble) == 0x0001E8, "Member 'UInteracterComponent::OldBestInteractble' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, FocusedInteractable) == 0x0001F0, "Member 'UInteracterComponent::FocusedInteractable' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, BlockInteractableTypeRequest) == 0x0001F8, "Member 'UInteracterComponent::BlockInteractableTypeRequest' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, InteractionTimeReduction) == 0x000208, "Member 'UInteracterComponent::InteractionTimeReduction' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, CustomInteractionDuration) == 0x00020C, "Member 'UInteracterComponent::CustomInteractionDuration' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, InteractTimeDefaultMultiplier) == 0x000210, "Member 'UInteracterComponent::InteractTimeDefaultMultiplier' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, InteractableInteractTypeList) == 0x000218, "Member 'UInteracterComponent::InteractableInteractTypeList' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, bAffectInteractIcon) == 0x000228, "Member 'UInteracterComponent::bAffectInteractIcon' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, bUseOnlyRayCastCondition) == 0x000229, "Member 'UInteracterComponent::bUseOnlyRayCastCondition' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, bOverwriteInteractionCallback) == 0x00022A, "Member 'UInteracterComponent::bOverwriteInteractionCallback' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, InteractCancelTypeToIgnore) == 0x000230, "Member 'UInteracterComponent::InteractCancelTypeToIgnore' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, InteractWidgetIconClass) == 0x000240, "Member 'UInteracterComponent::InteractWidgetIconClass' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, InteractWidgetIconPriority) == 0x000268, "Member 'UInteracterComponent::InteractWidgetIconPriority' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, FrustumTestRadius) == 0x00026C, "Member 'UInteracterComponent::FrustumTestRadius' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, bFrustumTestInteracts) == 0x000270, "Member 'UInteracterComponent::bFrustumTestInteracts' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, bCanTriggerBotSuspiciousness) == 0x000271, "Member 'UInteracterComponent::bCanTriggerBotSuspiciousness' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, SpyOwner) == 0x000288, "Member 'UInteracterComponent::SpyOwner' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, SpyActor) == 0x000290, "Member 'UInteracterComponent::SpyActor' has a wrong offset!");
static_assert(offsetof(UInteracterComponent, DisableRequest) == 0x0002A0, "Member 'UInteracterComponent::DisableRequest' has a wrong offset!");

// Class DeceiveInc.RangeInteracterComponent
// 0x0030 (0x0320 - 0x02F0)
class URangeInteracterComponent : public UInteracterComponent
{
public:
	float                                         RangeInteractDistance;                             // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeDetectionDistance;                            // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F8[0x10];                                     // 0x02F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         InteractsInRange;                                  // 0x0308(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void HandleComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangeInteracterComponent">();
	}
	static class URangeInteracterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URangeInteracterComponent>();
	}
};
static_assert(alignof(URangeInteracterComponent) == 0x000008, "Wrong alignment on URangeInteracterComponent");
static_assert(sizeof(URangeInteracterComponent) == 0x000320, "Wrong size on URangeInteracterComponent");
static_assert(offsetof(URangeInteracterComponent, RangeInteractDistance) == 0x0002F0, "Member 'URangeInteracterComponent::RangeInteractDistance' has a wrong offset!");
static_assert(offsetof(URangeInteracterComponent, RangeDetectionDistance) == 0x0002F4, "Member 'URangeInteracterComponent::RangeDetectionDistance' has a wrong offset!");
static_assert(offsetof(URangeInteracterComponent, InteractsInRange) == 0x000308, "Member 'URangeInteracterComponent::InteractsInRange' has a wrong offset!");

// Class DeceiveInc.BasePlaceableSpyTool
// 0x0158 (0x0688 - 0x0530)
class ABasePlaceableSpyTool : public ABaseSpyTool
{
public:
	FMulticastInlineDelegateProperty_             OnNewValidPlaceableSpawned;                        // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOwnedPlacedToolDestroyed;                        // 0x0540(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNewValidPlaceableDestroyed;                      // 0x0550(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlaceableSpyToolThrowDelayEnd;                   // 0x0560(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlaceableSpyToolFullThrowEnd;                    // 0x0570(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         RecycleTime;                                       // 0x0580(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsUsingRangePlacement;                            // 0x0584(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_585[0x3];                                      // 0x0585(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxPlacedPlaceable;                                // 0x0588(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58C[0x4];                                      // 0x058C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCooldownComponent*                     CooldownComp;                                      // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URangePlacementComponent*               RangePlacementComp;                                // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   PlaceableToolPrimaryActionText;                    // 0x05A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   PlaceableToolSecondaryActionText;                  // 0x05B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         ThrowDelay1P;                                      // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowOutTime1P;                                    // 0x05D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowOutToPoudrierTime1P;                          // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowDelay3P;                                      // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowOutlTime3P;                                   // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowOutToPoudrierTime3P;                          // 0x05E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayResourcesComponent*            GameplayResource;                                  // 0x05E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ABasePlaceable*>                 PlaceableActors;                                   // 0x05F0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class ASpy*                                   SpyOwner;                                          // 0x0600(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FToolAssetsId                          PlaceableAssetsId;                                 // 0x0608(0x0024)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_62C[0x5C];                                     // 0x062C(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_OnDeployedToolDestroyed(bool bRecycled);
	TArray<class ABasePlaceable*> GetPlaceableActor();
	void HandleChargeAmountChange(int32 Amount);
	void HandleIsEnableChanged(bool bIsEnabled);
	void OnCooldownChange(bool bOnCooldown);
	void OnPlaceableActorDestroyed(class AActor* DestroyedActor);
	void OnPlaceableSpawned(class ABasePlaceable* NewPlaceable);
	void OnRecycleTimerEnd();
	void OnRep_NewPlaceableAssetsId();
	void OnThrowDelayTimerEnd();
	void OnThrowTimerEnd();
	void Server_OnRecycleTimerEnd();

	bool IsToolOrPlaceableEnable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePlaceableSpyTool">();
	}
	static class ABasePlaceableSpyTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABasePlaceableSpyTool>();
	}
};
static_assert(alignof(ABasePlaceableSpyTool) == 0x000008, "Wrong alignment on ABasePlaceableSpyTool");
static_assert(sizeof(ABasePlaceableSpyTool) == 0x000688, "Wrong size on ABasePlaceableSpyTool");
static_assert(offsetof(ABasePlaceableSpyTool, OnNewValidPlaceableSpawned) == 0x000530, "Member 'ABasePlaceableSpyTool::OnNewValidPlaceableSpawned' has a wrong offset!");
static_assert(offsetof(ABasePlaceableSpyTool, OnOwnedPlacedToolDestroyed) == 0x000540, "Member 'ABasePlaceableSpyTool::OnOwnedPlacedToolDestroyed' has a wrong offset!");
static_assert(offsetof(ABasePlaceableSpyTool, OnNewValidPlaceableDestroyed) == 0x000550, "Member 'ABasePlaceableSpyTool::OnNewValidPlaceableDestroyed' has a wrong offset!");
static_assert(offsetof(ABasePlaceableSpyTool, OnPlaceableSpyToolThrowDelayEnd) == 0x000560, "Member 'ABasePlaceableSpyTool::OnPlaceableSpyToolThrowDelayEnd' has a wrong offset!");
static_assert(offsetof(ABasePlaceableSpyTool, OnPlaceableSpyToolFullThrowEnd) == 0x000570, "Member 'ABasePlaceableSpyTool::OnPlaceableSpyToolFullThrowEnd' has a wrong offset!");
static_assert(offsetof(ABasePlaceableSpyTool, RecycleTime) == 0x000580, "Member 'ABasePlaceableSpyTool::RecycleTime' has a wrong offset!");
static_assert(offsetof(ABasePlaceableSpyTool, bIsUsingRangePlacement) == 0x000584, "Member 'ABasePlaceableSpyTool::bIsUsingRangePlacement' has a wrong offset!");
static_assert(offsetof(ABasePlaceableSpyTool, MaxPlacedPlaceable) == 0x000588, "Member 'ABasePlaceableSpyTool::MaxPlacedPlaceable' has a wrong offset!");
static_assert(offsetof(ABasePlaceableSpyTool, CooldownComp) == 0x000590, "Member 'ABasePlaceableSpyTool::CooldownComp' has a wrong offset!");
static_assert(offsetof(ABasePlaceableSpyTool, RangePlacementComp) == 0x000598, "Member 'ABasePlaceableSpyTool::RangePlacementComp' has a wrong offset!");
static_assert(offsetof(ABasePlaceableSpyTool, PlaceableToolPrimaryActionText) == 0x0005A0, "Member 'ABasePlaceableSpyTool::PlaceableToolPrimaryActionText' has a wrong offset!");
static_assert(offsetof(ABasePlaceableSpyTool, PlaceableToolSecondaryActionText) == 0x0005B8, "Member 'ABasePlaceableSpyTool::PlaceableToolSecondaryActionText' has a wrong offset!");
static_assert(offsetof(ABasePlaceableSpyTool, ThrowDelay1P) == 0x0005D0, "Member 'ABasePlaceableSpyTool::ThrowDelay1P' has a wrong offset!");
static_assert(offsetof(ABasePlaceableSpyTool, ThrowOutTime1P) == 0x0005D4, "Member 'ABasePlaceableSpyTool::ThrowOutTime1P' has a wrong offset!");
static_assert(offsetof(ABasePlaceableSpyTool, ThrowOutToPoudrierTime1P) == 0x0005D8, "Member 'ABasePlaceableSpyTool::ThrowOutToPoudrierTime1P' has a wrong offset!");
static_assert(offsetof(ABasePlaceableSpyTool, ThrowDelay3P) == 0x0005DC, "Member 'ABasePlaceableSpyTool::ThrowDelay3P' has a wrong offset!");
static_assert(offsetof(ABasePlaceableSpyTool, ThrowOutlTime3P) == 0x0005E0, "Member 'ABasePlaceableSpyTool::ThrowOutlTime3P' has a wrong offset!");
static_assert(offsetof(ABasePlaceableSpyTool, ThrowOutToPoudrierTime3P) == 0x0005E4, "Member 'ABasePlaceableSpyTool::ThrowOutToPoudrierTime3P' has a wrong offset!");
static_assert(offsetof(ABasePlaceableSpyTool, GameplayResource) == 0x0005E8, "Member 'ABasePlaceableSpyTool::GameplayResource' has a wrong offset!");
static_assert(offsetof(ABasePlaceableSpyTool, PlaceableActors) == 0x0005F0, "Member 'ABasePlaceableSpyTool::PlaceableActors' has a wrong offset!");
static_assert(offsetof(ABasePlaceableSpyTool, SpyOwner) == 0x000600, "Member 'ABasePlaceableSpyTool::SpyOwner' has a wrong offset!");
static_assert(offsetof(ABasePlaceableSpyTool, PlaceableAssetsId) == 0x000608, "Member 'ABasePlaceableSpyTool::PlaceableAssetsId' has a wrong offset!");

// Class DeceiveInc.SquirePassiveAbilityMod1
// 0x0040 (0x0570 - 0x0530)
class ASquirePassiveAbilityMod1 final : public ABaseSpyPassiveAbility
{
public:
	float                                         PingDuration;                                      // 0x0530(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_534[0x4];                                      // 0x0534(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   PingVictimEffect;                                  // 0x0538(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCooldownComponent*                     PingDurationTimer;                                 // 0x0560(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HudToShowOnPing;                                   // 0x0568(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandlePingDurationCooldownChange(bool OnCooldown);
	void HandleUnderCoverChanged(bool bUndercover);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquirePassiveAbilityMod1">();
	}
	static class ASquirePassiveAbilityMod1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASquirePassiveAbilityMod1>();
	}
};
static_assert(alignof(ASquirePassiveAbilityMod1) == 0x000008, "Wrong alignment on ASquirePassiveAbilityMod1");
static_assert(sizeof(ASquirePassiveAbilityMod1) == 0x000570, "Wrong size on ASquirePassiveAbilityMod1");
static_assert(offsetof(ASquirePassiveAbilityMod1, PingDuration) == 0x000530, "Member 'ASquirePassiveAbilityMod1::PingDuration' has a wrong offset!");
static_assert(offsetof(ASquirePassiveAbilityMod1, PingVictimEffect) == 0x000538, "Member 'ASquirePassiveAbilityMod1::PingVictimEffect' has a wrong offset!");
static_assert(offsetof(ASquirePassiveAbilityMod1, PingDurationTimer) == 0x000560, "Member 'ASquirePassiveAbilityMod1::PingDurationTimer' has a wrong offset!");
static_assert(offsetof(ASquirePassiveAbilityMod1, HudToShowOnPing) == 0x000568, "Member 'ASquirePassiveAbilityMod1::HudToShowOnPing' has a wrong offset!");

// Class DeceiveInc.BasePositionerComponent
// 0x0070 (0x0120 - 0x00B0)
class UBasePositionerComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnVisibilityChanged;                               // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPositionerNewOwner;                              // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PositioningActorClass;                             // 0x00D0(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMustUpdatePositionWhilePositioning;               // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlacementRange;                                    // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PointingRayRadius;                                 // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallOffset;                                        // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInvertPlacementDirection;                         // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPositionerSourceReference                    PositionSource;                                    // 0x0109(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10A[0x6];                                      // 0x010A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 PositioningActor;                                  // 0x0110(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowEverySurface;                                // 0x0118(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnPositioningActorSpawned(class AActor* ActorSpawned);

	bool IsPositioningActorVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePositionerComponent">();
	}
	static class UBasePositionerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePositionerComponent>();
	}
};
static_assert(alignof(UBasePositionerComponent) == 0x000008, "Wrong alignment on UBasePositionerComponent");
static_assert(sizeof(UBasePositionerComponent) == 0x000120, "Wrong size on UBasePositionerComponent");
static_assert(offsetof(UBasePositionerComponent, OnVisibilityChanged) == 0x0000B0, "Member 'UBasePositionerComponent::OnVisibilityChanged' has a wrong offset!");
static_assert(offsetof(UBasePositionerComponent, OnPositionerNewOwner) == 0x0000C0, "Member 'UBasePositionerComponent::OnPositionerNewOwner' has a wrong offset!");
static_assert(offsetof(UBasePositionerComponent, PositioningActorClass) == 0x0000D0, "Member 'UBasePositionerComponent::PositioningActorClass' has a wrong offset!");
static_assert(offsetof(UBasePositionerComponent, bMustUpdatePositionWhilePositioning) == 0x0000F8, "Member 'UBasePositionerComponent::bMustUpdatePositionWhilePositioning' has a wrong offset!");
static_assert(offsetof(UBasePositionerComponent, PlacementRange) == 0x0000FC, "Member 'UBasePositionerComponent::PlacementRange' has a wrong offset!");
static_assert(offsetof(UBasePositionerComponent, PointingRayRadius) == 0x000100, "Member 'UBasePositionerComponent::PointingRayRadius' has a wrong offset!");
static_assert(offsetof(UBasePositionerComponent, WallOffset) == 0x000104, "Member 'UBasePositionerComponent::WallOffset' has a wrong offset!");
static_assert(offsetof(UBasePositionerComponent, bInvertPlacementDirection) == 0x000108, "Member 'UBasePositionerComponent::bInvertPlacementDirection' has a wrong offset!");
static_assert(offsetof(UBasePositionerComponent, PositionSource) == 0x000109, "Member 'UBasePositionerComponent::PositionSource' has a wrong offset!");
static_assert(offsetof(UBasePositionerComponent, PositioningActor) == 0x000110, "Member 'UBasePositionerComponent::PositioningActor' has a wrong offset!");
static_assert(offsetof(UBasePositionerComponent, bAllowEverySurface) == 0x000118, "Member 'UBasePositionerComponent::bAllowEverySurface' has a wrong offset!");

// Class DeceiveInc.BasePowerupActor
// 0x0010 (0x0300 - 0x02F0)
class ABasePowerupActor : public ABasePickableActor
{
public:
	class URayCastConditionComponent*             RayCastCondition;                                  // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaxResourceConditionComponent*         MaxResourceCondition;                              // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePowerupActor">();
	}
	static class ABasePowerupActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABasePowerupActor>();
	}
};
static_assert(alignof(ABasePowerupActor) == 0x000008, "Wrong alignment on ABasePowerupActor");
static_assert(sizeof(ABasePowerupActor) == 0x000300, "Wrong size on ABasePowerupActor");
static_assert(offsetof(ABasePowerupActor, RayCastCondition) == 0x0002F0, "Member 'ABasePowerupActor::RayCastCondition' has a wrong offset!");
static_assert(offsetof(ABasePowerupActor, MaxResourceCondition) == 0x0002F8, "Member 'ABasePowerupActor::MaxResourceCondition' has a wrong offset!");

// Class DeceiveInc.CallingCardDataAsset
// 0x0070 (0x00A8 - 0x0038)
class UCallingCardDataAsset final : public UDIPrimaryDataAsset
{
public:
	class FText                                   CallingCardDisplayName;                            // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         CallingCardRarity;                                 // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              CallingCardMenuTexture;                            // 0x0058(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInstance>       CallingCardMaterial;                               // 0x0080(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CallingCardDataAsset">();
	}
	static class UCallingCardDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCallingCardDataAsset>();
	}
};
static_assert(alignof(UCallingCardDataAsset) == 0x000008, "Wrong alignment on UCallingCardDataAsset");
static_assert(sizeof(UCallingCardDataAsset) == 0x0000A8, "Wrong size on UCallingCardDataAsset");
static_assert(offsetof(UCallingCardDataAsset, CallingCardDisplayName) == 0x000038, "Member 'UCallingCardDataAsset::CallingCardDisplayName' has a wrong offset!");
static_assert(offsetof(UCallingCardDataAsset, CallingCardRarity) == 0x000050, "Member 'UCallingCardDataAsset::CallingCardRarity' has a wrong offset!");
static_assert(offsetof(UCallingCardDataAsset, CallingCardMenuTexture) == 0x000058, "Member 'UCallingCardDataAsset::CallingCardMenuTexture' has a wrong offset!");
static_assert(offsetof(UCallingCardDataAsset, CallingCardMaterial) == 0x000080, "Member 'UCallingCardDataAsset::CallingCardMaterial' has a wrong offset!");

// Class DeceiveInc.BasePowerupChestActor
// 0x0048 (0x0358 - 0x0310)
class ABasePowerupChestActor final : public ABaseIntelActor
{
public:
	class UObjectSpawnComponent*                  ObjectSpawnComp;                                   // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URayCastConditionComponent*             RayCastCond;                                       // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UResourceConditionComponent*            ResourceCond;                                      // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaxUseConditionComponent*              MaxUseCond;                                        // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USingleUserConditionComponent*          SingleUserCond;                                    // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   AlreadyOwnedPowerup;                               // 0x0338(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EGameplayResourcesType                        PowerupRessources;                                 // 0x0350(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsChestOpen;                                      // 0x0351(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_352[0x6];                                      // 0x0352(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnChestOpen();
	void HandleResourceSpent(class UInteracterComponent* Interacter, EGameplayResourcesType ResourceType, int32 Amount);
	void HandleSpawnSetupedComplete();
	void OnRep_OpenChest();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePowerupChestActor">();
	}
	static class ABasePowerupChestActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABasePowerupChestActor>();
	}
};
static_assert(alignof(ABasePowerupChestActor) == 0x000008, "Wrong alignment on ABasePowerupChestActor");
static_assert(sizeof(ABasePowerupChestActor) == 0x000358, "Wrong size on ABasePowerupChestActor");
static_assert(offsetof(ABasePowerupChestActor, ObjectSpawnComp) == 0x000310, "Member 'ABasePowerupChestActor::ObjectSpawnComp' has a wrong offset!");
static_assert(offsetof(ABasePowerupChestActor, RayCastCond) == 0x000318, "Member 'ABasePowerupChestActor::RayCastCond' has a wrong offset!");
static_assert(offsetof(ABasePowerupChestActor, ResourceCond) == 0x000320, "Member 'ABasePowerupChestActor::ResourceCond' has a wrong offset!");
static_assert(offsetof(ABasePowerupChestActor, MaxUseCond) == 0x000328, "Member 'ABasePowerupChestActor::MaxUseCond' has a wrong offset!");
static_assert(offsetof(ABasePowerupChestActor, SingleUserCond) == 0x000330, "Member 'ABasePowerupChestActor::SingleUserCond' has a wrong offset!");
static_assert(offsetof(ABasePowerupChestActor, AlreadyOwnedPowerup) == 0x000338, "Member 'ABasePowerupChestActor::AlreadyOwnedPowerup' has a wrong offset!");
static_assert(offsetof(ABasePowerupChestActor, PowerupRessources) == 0x000350, "Member 'ABasePowerupChestActor::PowerupRessources' has a wrong offset!");
static_assert(offsetof(ABasePowerupChestActor, bIsChestOpen) == 0x000351, "Member 'ABasePowerupChestActor::bIsChestOpen' has a wrong offset!");

// Class DeceiveInc.BaseScannerTool
// 0x0080 (0x05B0 - 0x0530)
class ABaseScannerTool : public ABaseSpyTool
{
public:
	FMulticastInlineDelegateProperty_             OnLocalScanStart;                                  // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLocalScanStop;                                   // 0x0540(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLocalScanComplete;                               // 0x0550(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_560[0x8];                                      // 0x0560(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UScannableComponent*                    BestScanable;                                      // 0x0568(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScannableComponent*                    FocusedScanable;                                   // 0x0570(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScannableComponent*                    ScanningScannable;                                 // 0x0578(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UScannableComponent*>            InRangeScanableList;                               // 0x0580(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UScannableComponent*>            ScannableList;                                     // 0x0590(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         ScanDuration;                                      // 0x05A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScanDistance;                                      // 0x05A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A8[0x8];                                      // 0x05A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_CompleteScan(class UScannableComponent* Scannable);

	float GetScanDistance() const;
	float GetScanDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseScannerTool">();
	}
	static class ABaseScannerTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseScannerTool>();
	}
};
static_assert(alignof(ABaseScannerTool) == 0x000008, "Wrong alignment on ABaseScannerTool");
static_assert(sizeof(ABaseScannerTool) == 0x0005B0, "Wrong size on ABaseScannerTool");
static_assert(offsetof(ABaseScannerTool, OnLocalScanStart) == 0x000530, "Member 'ABaseScannerTool::OnLocalScanStart' has a wrong offset!");
static_assert(offsetof(ABaseScannerTool, OnLocalScanStop) == 0x000540, "Member 'ABaseScannerTool::OnLocalScanStop' has a wrong offset!");
static_assert(offsetof(ABaseScannerTool, OnLocalScanComplete) == 0x000550, "Member 'ABaseScannerTool::OnLocalScanComplete' has a wrong offset!");
static_assert(offsetof(ABaseScannerTool, BestScanable) == 0x000568, "Member 'ABaseScannerTool::BestScanable' has a wrong offset!");
static_assert(offsetof(ABaseScannerTool, FocusedScanable) == 0x000570, "Member 'ABaseScannerTool::FocusedScanable' has a wrong offset!");
static_assert(offsetof(ABaseScannerTool, ScanningScannable) == 0x000578, "Member 'ABaseScannerTool::ScanningScannable' has a wrong offset!");
static_assert(offsetof(ABaseScannerTool, InRangeScanableList) == 0x000580, "Member 'ABaseScannerTool::InRangeScanableList' has a wrong offset!");
static_assert(offsetof(ABaseScannerTool, ScannableList) == 0x000590, "Member 'ABaseScannerTool::ScannableList' has a wrong offset!");
static_assert(offsetof(ABaseScannerTool, ScanDuration) == 0x0005A0, "Member 'ABaseScannerTool::ScanDuration' has a wrong offset!");
static_assert(offsetof(ABaseScannerTool, ScanDistance) == 0x0005A4, "Member 'ABaseScannerTool::ScanDistance' has a wrong offset!");

// Class DeceiveInc.BaseSittableActor
// 0x0020 (0x0250 - 0x0230)
class ABaseSittableActor final : public AStaticMeshActor
{
public:
	class UInMimicConditionComponent*             InMimicCond;                                       // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URayCastConditionComponent*             RayCastCond;                                       // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USocialInteractConditionComponent*      SocialInteractCond;                                // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActiveAbilityConditionComponent*       ActiveCond;                                        // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseSittableActor">();
	}
	static class ABaseSittableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseSittableActor>();
	}
};
static_assert(alignof(ABaseSittableActor) == 0x000008, "Wrong alignment on ABaseSittableActor");
static_assert(sizeof(ABaseSittableActor) == 0x000250, "Wrong size on ABaseSittableActor");
static_assert(offsetof(ABaseSittableActor, InMimicCond) == 0x000230, "Member 'ABaseSittableActor::InMimicCond' has a wrong offset!");
static_assert(offsetof(ABaseSittableActor, RayCastCond) == 0x000238, "Member 'ABaseSittableActor::RayCastCond' has a wrong offset!");
static_assert(offsetof(ABaseSittableActor, SocialInteractCond) == 0x000240, "Member 'ABaseSittableActor::SocialInteractCond' has a wrong offset!");
static_assert(offsetof(ABaseSittableActor, ActiveCond) == 0x000248, "Member 'ABaseSittableActor::ActiveCond' has a wrong offset!");

// Class DeceiveInc.DiCheckBox
// 0x0048 (0x07B8 - 0x0770)
class UDiCheckBox : public UCheckBox
{
public:
	uint8                                         Pad_770[0x8];                                      // 0x0770(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnActionStarted;                                   // 0x0778(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActionCompleted;                                 // 0x0788(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActionTriggered;                                 // 0x0798(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UInputAction*                           InputAction;                                       // 0x07A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimulateClickOnActionStarted;                     // 0x07B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimulateClickOnActionTriggered;                   // 0x07B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B2[0x6];                                      // 0x07B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiCheckBox">();
	}
	static class UDiCheckBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiCheckBox>();
	}
};
static_assert(alignof(UDiCheckBox) == 0x000008, "Wrong alignment on UDiCheckBox");
static_assert(sizeof(UDiCheckBox) == 0x0007B8, "Wrong size on UDiCheckBox");
static_assert(offsetof(UDiCheckBox, OnActionStarted) == 0x000778, "Member 'UDiCheckBox::OnActionStarted' has a wrong offset!");
static_assert(offsetof(UDiCheckBox, OnActionCompleted) == 0x000788, "Member 'UDiCheckBox::OnActionCompleted' has a wrong offset!");
static_assert(offsetof(UDiCheckBox, OnActionTriggered) == 0x000798, "Member 'UDiCheckBox::OnActionTriggered' has a wrong offset!");
static_assert(offsetof(UDiCheckBox, InputAction) == 0x0007A8, "Member 'UDiCheckBox::InputAction' has a wrong offset!");
static_assert(offsetof(UDiCheckBox, bSimulateClickOnActionStarted) == 0x0007B0, "Member 'UDiCheckBox::bSimulateClickOnActionStarted' has a wrong offset!");
static_assert(offsetof(UDiCheckBox, bSimulateClickOnActionTriggered) == 0x0007B1, "Member 'UDiCheckBox::bSimulateClickOnActionTriggered' has a wrong offset!");

// Class DeceiveInc.DiCharacterSelectCheckBox
// 0x0008 (0x07C0 - 0x07B8)
class UDiCharacterSelectCheckBox final : public UDiCheckBox
{
public:
	class UAgentData*                             AgentData;                                         // 0x07B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	ECharacterSelectAgentAvailability GetAgentAvailabilityState();
	void SetAgentData(class UAgentData* InAgentData);

	class UAgentData* GetAgentData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiCharacterSelectCheckBox">();
	}
	static class UDiCharacterSelectCheckBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiCharacterSelectCheckBox>();
	}
};
static_assert(alignof(UDiCharacterSelectCheckBox) == 0x000008, "Wrong alignment on UDiCharacterSelectCheckBox");
static_assert(sizeof(UDiCharacterSelectCheckBox) == 0x0007C0, "Wrong size on UDiCharacterSelectCheckBox");
static_assert(offsetof(UDiCharacterSelectCheckBox, AgentData) == 0x0007B8, "Member 'UDiCharacterSelectCheckBox::AgentData' has a wrong offset!");

// Class DeceiveInc.SweetPawnAudioComponent
// 0x00A0 (0x0150 - 0x00B0)
class USweetPawnAudioComponent final : public UActorComponent
{
public:
	TSet<class AActor*>                           ManagedSubActors;                                  // 0x00B0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x50];                                     // 0x0100(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SweetPawnAudioComponent">();
	}
	static class USweetPawnAudioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USweetPawnAudioComponent>();
	}
};
static_assert(alignof(USweetPawnAudioComponent) == 0x000008, "Wrong alignment on USweetPawnAudioComponent");
static_assert(sizeof(USweetPawnAudioComponent) == 0x000150, "Wrong size on USweetPawnAudioComponent");
static_assert(offsetof(USweetPawnAudioComponent, ManagedSubActors) == 0x0000B0, "Member 'USweetPawnAudioComponent::ManagedSubActors' has a wrong offset!");

// Class DeceiveInc.BaseSphereActor
// 0x0010 (0x0230 - 0x0220)
class ABaseSphereActor : public AActor
{
public:
	float                                         SphereDuration;                                    // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNotifyYumiActive;                                 // 0x0224(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_225[0xB];                                      // 0x0225(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseSphereActor">();
	}
	static class ABaseSphereActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseSphereActor>();
	}
};
static_assert(alignof(ABaseSphereActor) == 0x000008, "Wrong alignment on ABaseSphereActor");
static_assert(sizeof(ABaseSphereActor) == 0x000230, "Wrong size on ABaseSphereActor");
static_assert(offsetof(ABaseSphereActor, SphereDuration) == 0x000220, "Member 'ABaseSphereActor::SphereDuration' has a wrong offset!");
static_assert(offsetof(ABaseSphereActor, bNotifyYumiActive) == 0x000224, "Member 'ABaseSphereActor::bNotifyYumiActive' has a wrong offset!");

// Class DeceiveInc.DeceiveIncSettings
// 0x0180 (0x01B8 - 0x0038)
class UDeceiveIncSettings final : public UDeveloperSettings
{
public:
	bool                                          bIsPlaytestBuild;                                  // 0x0038(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NetworkCompatibilityVersion;                       // 0x003C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDIClientConfigSettings                ClientConfig;                                      // 0x0040(0x00A0)(Edit, Config, NativeAccessSpecifierPrivate)
	struct FDIServerConfigSettings                ServerConfigSettings;                              // 0x00E0(0x0028)(Edit, Config, NativeAccessSpecifierPrivate)
	struct FDIFanartSettings                      FanartSettings;                                    // 0x0108(0x0010)(Edit, Config, NativeAccessSpecifierPrivate)
	struct FChromaticFeedbackSettings             ChromaticFeedback;                                 // 0x0118(0x0050)(Edit, Config, NativeAccessSpecifierPrivate)
	TMap<class UInputAction*, struct FLinearColor> ActionKeyColors;                                   // 0x0168(0x0050)(Edit, Config, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeceiveIncSettings">();
	}
	static class UDeceiveIncSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeceiveIncSettings>();
	}
};
static_assert(alignof(UDeceiveIncSettings) == 0x000008, "Wrong alignment on UDeceiveIncSettings");
static_assert(sizeof(UDeceiveIncSettings) == 0x0001B8, "Wrong size on UDeceiveIncSettings");
static_assert(offsetof(UDeceiveIncSettings, bIsPlaytestBuild) == 0x000038, "Member 'UDeceiveIncSettings::bIsPlaytestBuild' has a wrong offset!");
static_assert(offsetof(UDeceiveIncSettings, NetworkCompatibilityVersion) == 0x00003C, "Member 'UDeceiveIncSettings::NetworkCompatibilityVersion' has a wrong offset!");
static_assert(offsetof(UDeceiveIncSettings, ClientConfig) == 0x000040, "Member 'UDeceiveIncSettings::ClientConfig' has a wrong offset!");
static_assert(offsetof(UDeceiveIncSettings, ServerConfigSettings) == 0x0000E0, "Member 'UDeceiveIncSettings::ServerConfigSettings' has a wrong offset!");
static_assert(offsetof(UDeceiveIncSettings, FanartSettings) == 0x000108, "Member 'UDeceiveIncSettings::FanartSettings' has a wrong offset!");
static_assert(offsetof(UDeceiveIncSettings, ChromaticFeedback) == 0x000118, "Member 'UDeceiveIncSettings::ChromaticFeedback' has a wrong offset!");
static_assert(offsetof(UDeceiveIncSettings, ActionKeyColors) == 0x000168, "Member 'UDeceiveIncSettings::ActionKeyColors' has a wrong offset!");

// Class DeceiveInc.BaseSpyWeapon
// 0x0000 (0x0530 - 0x0530)
class ABaseSpyWeapon : public ABaseSpyTool
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseSpyWeapon">();
	}
	static class ABaseSpyWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseSpyWeapon>();
	}
};
static_assert(alignof(ABaseSpyWeapon) == 0x000008, "Wrong alignment on ABaseSpyWeapon");
static_assert(sizeof(ABaseSpyWeapon) == 0x000530, "Wrong size on ABaseSpyWeapon");

// Class DeceiveInc.SweetBPLibrary
// 0x0000 (0x0028 - 0x0028)
class USweetBPLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CHEATGetHideFriendlyGadgetOverlay();
	static void DisableParticleSystemNom(class UFXSystemComponent* ParticleSystem);
	static void EnableDrawActorMeshCollisions(class AActor* TargetActor, bool bEnableDraw);
	static class FString EnumToIETFTag(ELocalizationLanguage LocEnum);
	static class UMapData* GetCurrentMapData(class UObject* Context);
	static class FString GetCurrentMapName();
	static TArray<class UMapData*> GetCustomGamesAvailableMaps();
	static class AGameStateBase* GetDeceiveIncGameState(const class AActor* ContextActor);
	static class ADeceiveIncPlayerController* GetDIPlayerControllerFromState(const class ADIPlayerState* PlayerState);
	static class FString GetEditorDecryptedGUID(const class FString& GuidToDecrypt);
	static class FString GetEditorEncryptedGUID(const class FString& GuidToEncrypt);
	static class ADeceiveIncPlayerController* GetFirstLocalDIPlayerController();
	static void GetKeysForAction(class UInputAction* Action, float AxisScale, TArray<struct FKey>* Bindings, EInputDeviceType DeviceType);
	static void GetKeysForActionName(class FName ActionName, float AxisScale, TArray<struct FKey>* Bindings, EInputDeviceType DeviceType);
	static EInputDeviceType GetLastUsedInputDeviceType();
	static class ADeceiveIncPlayerController* GetLocalDIPlayerController(class UObject* Context);
	static class FText GetLocalisedValueInEnumMap(const TMap<ELocalizationLanguage, class FText>& LocalisedMap);
	static class FText GetLocalisedValueInMap(const TMap<class FString, class FString>& LocalisedMap);
	static class FString GetNameOfKey(const struct FKey& TheKey);
	static class FString GetRandomlyGeneratedUserName();
	static int64 GetUtcNowInSeconds();
	static void GoToMainMenu();
	static ELocalizationLanguage IETFTagToEnum(const class FString& IETFTag);
	static bool IsAllowingCheats();
	static bool IsBodyHit(const EHitType& HitType);
	static bool IsConsoleBuild();
	static bool IsCriticalHit(const EHitType& HitType);
	static bool IsDebugBuild();
	static bool IsEditorBuild();
	static bool IsInKillcamReplay(const class UObject* WorldContextObject);
	static bool IsInMainMenuLevel();
	static bool IsLimbHit(const EHitType& HitType);
	static bool IsLockheartConsole();
	static bool IsMapDisabledForPrivateLobby(const class FString& MapName);
	static bool IsOfflineBuild();
	static bool IsShippingBuild();
	static void MinimizeWindow();
	static float SB_ApplyZoomFactorToFOV(float BaseFOV, float ZoomFactor);
	static void SB_AttachActorBoneToBone(class USceneComponent* ToAttach, class AActor* ToAttachActor, class FName Socket, class USceneComponent* Parent, class FName ParentSocket, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies);
	static void SB_AttachToActorValidateSocket(class AActor* ToAttach, class AActor* ParentActor, class FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies);
	static void SB_FindScreenEdgeLocationForWorldLocation(class UObject* WorldContextObject, const struct FVector& InLocation, class APlayerController* InPlayerController, const float EdgePercent, const struct FVector2D& ViewportCenterLoc, struct FVector2D* OutScreenPosition, float* OutRotationAngleDegrees, bool* bIsOnScreen);
	static bool SB_IsInPregame(const class UObject* WorldContextObject);
	static void SB_SpawnProjectilesInSpray(const struct FTransform& ProjectileTransform, class AActor* OwnerActor, class AActor* SpawnerWeapon, class UClass* ProjectileClass, class UWeaponSprayDataAsset* SprayData, float SprayPlaneDepth, float SprayPlaneWidth, float SprayPlaneHeight, bool bIsSimulated);
	static void SBDevPrint(const class FString& InString);
	static void SBPerfBookmark(const class FString& InString);
	static void SetMontageDefaultLength(class UAnimMontage* Montage);
	static void SetupPostProcessSystem(class UPostProcessComponent* PPComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SweetBPLibrary">();
	}
	static class USweetBPLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USweetBPLibrary>();
	}
};
static_assert(alignof(USweetBPLibrary) == 0x000008, "Wrong alignment on USweetBPLibrary");
static_assert(sizeof(USweetBPLibrary) == 0x000028, "Wrong size on USweetBPLibrary");

// Class DeceiveInc.BehaviorMachineComponent
// 0x0020 (0x00D0 - 0x00B0)
class UBehaviorMachineComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x20];                                      // 0x00B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BehaviorMachineComponent">();
	}
	static class UBehaviorMachineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBehaviorMachineComponent>();
	}
};
static_assert(alignof(UBehaviorMachineComponent) == 0x000008, "Wrong alignment on UBehaviorMachineComponent");
static_assert(sizeof(UBehaviorMachineComponent) == 0x0000D0, "Wrong size on UBehaviorMachineComponent");

// Class DeceiveInc.BehindConditionComponent
// 0x0008 (0x00D8 - 0x00D0)
class UBehindConditionComponent final : public UBaseConditionComponent
{
public:
	bool                                          bInvert;                                           // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BehindConditionComponent">();
	}
	static class UBehindConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBehindConditionComponent>();
	}
};
static_assert(alignof(UBehindConditionComponent) == 0x000008, "Wrong alignment on UBehindConditionComponent");
static_assert(sizeof(UBehindConditionComponent) == 0x0000D8, "Wrong size on UBehindConditionComponent");
static_assert(offsetof(UBehindConditionComponent, bInvert) == 0x0000D0, "Member 'UBehindConditionComponent::bInvert' has a wrong offset!");

// Class DeceiveInc.CameraSubsystemPropertiesDAsset
// 0x0008 (0x0040 - 0x0038)
class UCameraSubsystemPropertiesDAsset final : public UDIPrimaryDataAsset
{
public:
	TSubclassOf<class ACameraActor>               CameraLenseBPClass;                                // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraSubsystemPropertiesDAsset">();
	}
	static class UCameraSubsystemPropertiesDAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraSubsystemPropertiesDAsset>();
	}
};
static_assert(alignof(UCameraSubsystemPropertiesDAsset) == 0x000008, "Wrong alignment on UCameraSubsystemPropertiesDAsset");
static_assert(sizeof(UCameraSubsystemPropertiesDAsset) == 0x000040, "Wrong size on UCameraSubsystemPropertiesDAsset");
static_assert(offsetof(UCameraSubsystemPropertiesDAsset, CameraLenseBPClass) == 0x000038, "Member 'UCameraSubsystemPropertiesDAsset::CameraLenseBPClass' has a wrong offset!");

// Class DeceiveInc.DeceiveIncMenuGameModeBase
// 0x0000 (0x02C0 - 0x02C0)
class ADeceiveIncMenuGameModeBase : public AGameModeBase
{
public:
	void HostCustomMatch(const class FString& LevelToPlay);
	void JoinCustomMatch(const class FString& HostUrl);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeceiveIncMenuGameModeBase">();
	}
	static class ADeceiveIncMenuGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeceiveIncMenuGameModeBase>();
	}
};
static_assert(alignof(ADeceiveIncMenuGameModeBase) == 0x000008, "Wrong alignment on ADeceiveIncMenuGameModeBase");
static_assert(sizeof(ADeceiveIncMenuGameModeBase) == 0x0002C0, "Wrong size on ADeceiveIncMenuGameModeBase");

// Class DeceiveInc.BotActionChangeCover
// 0x0068 (0x00B0 - 0x0048)
class UBotActionChangeCover final : public UBotAction
{
public:
	uint8                                         Pad_48[0x68];                                      // 0x0048(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLocaInteractionCompleted(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void OnReceiveMoveCompleted(const struct FAIRequestID& RequestId, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotActionChangeCover">();
	}
	static class UBotActionChangeCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotActionChangeCover>();
	}
};
static_assert(alignof(UBotActionChangeCover) == 0x000008, "Wrong alignment on UBotActionChangeCover");
static_assert(sizeof(UBotActionChangeCover) == 0x0000B0, "Wrong size on UBotActionChangeCover");

// Class DeceiveInc.ToolWrapData
// 0x00A0 (0x00D8 - 0x0038)
class UToolWrapData final : public UDIPrimaryDataAsset
{
public:
	TMap<class UMenuWrapData*, TSoftObjectPtr<class UMaterialInstance>> ToolWrapMaterial;                                  // 0x0038(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class UMenuWrapData*, struct FAdditionalWrapMaterial> ToolWrapAdditionalMaterial;                        // 0x0088(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToolWrapData">();
	}
	static class UToolWrapData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UToolWrapData>();
	}
};
static_assert(alignof(UToolWrapData) == 0x000008, "Wrong alignment on UToolWrapData");
static_assert(sizeof(UToolWrapData) == 0x0000D8, "Wrong size on UToolWrapData");
static_assert(offsetof(UToolWrapData, ToolWrapMaterial) == 0x000038, "Member 'UToolWrapData::ToolWrapMaterial' has a wrong offset!");
static_assert(offsetof(UToolWrapData, ToolWrapAdditionalMaterial) == 0x000088, "Member 'UToolWrapData::ToolWrapAdditionalMaterial' has a wrong offset!");

// Class DeceiveInc.BotActionUnstuck
// 0x0028 (0x0070 - 0x0048)
class UBotActionUnstuck final : public UBotAction
{
public:
	uint8                                         Pad_48[0x28];                                      // 0x0048(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotActionUnstuck">();
	}
	static class UBotActionUnstuck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotActionUnstuck>();
	}
};
static_assert(alignof(UBotActionUnstuck) == 0x000008, "Wrong alignment on UBotActionUnstuck");
static_assert(sizeof(UBotActionUnstuck) == 0x000070, "Wrong size on UBotActionUnstuck");

// Class DeceiveInc.DiAnimInstance
// 0x0000 (0x02C0 - 0x02C0)
class UDiAnimInstance : public UAnimInstance
{
public:
	class UDiAnimationMotionSet*                  CurrentMotionSet;                                  // 0x02B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool ApplyMotionSet(const class UDiAnimationMotionSet* MotionSet);
	void BP_OnApplyMotionSet(const class UDiAnimationMotionSet* MotionSet);

	class UBlendSpaceBase* GetAnimMotionBlendspace(class FName MotionName) const;
	class UAnimSequence* GetAnimMotionSequence(class FName MotionName) const;
	bool HasAnimMotion(class FName MotionName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiAnimInstance">();
	}
	static class UDiAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiAnimInstance>();
	}
};
static_assert(alignof(UDiAnimInstance) == 0x000010, "Wrong alignment on UDiAnimInstance");
static_assert(sizeof(UDiAnimInstance) == 0x0002C0, "Wrong size on UDiAnimInstance");
static_assert(offsetof(UDiAnimInstance, CurrentMotionSet) == 0x0002B8, "Member 'UDiAnimInstance::CurrentMotionSet' has a wrong offset!");

// Class DeceiveInc.BotBrain
// 0x0050 (0x0078 - 0x0028)
class UBotBrain : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBotAction*>                     ActionQueue;                                       // 0x0038(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBotAction*                             TempAction;                                        // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x28];                                      // 0x0050(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnObjectivePing(class ASpy* PingingSpy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotBrain">();
	}
	static class UBotBrain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotBrain>();
	}
};
static_assert(alignof(UBotBrain) == 0x000008, "Wrong alignment on UBotBrain");
static_assert(sizeof(UBotBrain) == 0x000078, "Wrong size on UBotBrain");
static_assert(offsetof(UBotBrain, ActionQueue) == 0x000038, "Member 'UBotBrain::ActionQueue' has a wrong offset!");
static_assert(offsetof(UBotBrain, TempAction) == 0x000048, "Member 'UBotBrain::TempAction' has a wrong offset!");

// Class DeceiveInc.TargetPracticeDummy
// 0x0038 (0x0258 - 0x0220)
class ATargetPracticeDummy final : public AActor
{
public:
	uint8                                         Pad_220[0x18];                                     // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHealthComponent*                       HealthComponent;                                   // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ADamageNumber>              DebugNumberClass;                                  // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleTakePointDamage(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& ShotFromDirection, const class UDamageType* DamageType, class AActor* DamageCauser);
	void MulticastTakeDamage(float Damage, const struct FVector& HitLocation, class FName BoneName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetPracticeDummy">();
	}
	static class ATargetPracticeDummy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATargetPracticeDummy>();
	}
};
static_assert(alignof(ATargetPracticeDummy) == 0x000008, "Wrong alignment on ATargetPracticeDummy");
static_assert(sizeof(ATargetPracticeDummy) == 0x000258, "Wrong size on ATargetPracticeDummy");
static_assert(offsetof(ATargetPracticeDummy, Mesh) == 0x000238, "Member 'ATargetPracticeDummy::Mesh' has a wrong offset!");
static_assert(offsetof(ATargetPracticeDummy, HealthComponent) == 0x000240, "Member 'ATargetPracticeDummy::HealthComponent' has a wrong offset!");
static_assert(offsetof(ATargetPracticeDummy, CapsuleComponent) == 0x000248, "Member 'ATargetPracticeDummy::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(ATargetPracticeDummy, DebugNumberClass) == 0x000250, "Member 'ATargetPracticeDummy::DebugNumberClass' has a wrong offset!");

// Class DeceiveInc.BotObjective
// 0x0020 (0x0048 - 0x0028)
class UBotObjective : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBotObjective*                          FallBackObjective;                                 // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBotObjectiveRequirement*>       Requirements;                                      // 0x0038(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjective">();
	}
	static class UBotObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjective>();
	}
};
static_assert(alignof(UBotObjective) == 0x000008, "Wrong alignment on UBotObjective");
static_assert(sizeof(UBotObjective) == 0x000048, "Wrong size on UBotObjective");
static_assert(offsetof(UBotObjective, FallBackObjective) == 0x000030, "Member 'UBotObjective::FallBackObjective' has a wrong offset!");
static_assert(offsetof(UBotObjective, Requirements) == 0x000038, "Member 'UBotObjective::Requirements' has a wrong offset!");

// Class DeceiveInc.BotObjectiveBriefcaseInVault
// 0x0000 (0x0048 - 0x0048)
class UBotObjectiveBriefcaseInVault final : public UBotObjective
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjectiveBriefcaseInVault">();
	}
	static class UBotObjectiveBriefcaseInVault* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjectiveBriefcaseInVault>();
	}
};
static_assert(alignof(UBotObjectiveBriefcaseInVault) == 0x000008, "Wrong alignment on UBotObjectiveBriefcaseInVault");
static_assert(sizeof(UBotObjectiveBriefcaseInVault) == 0x000048, "Wrong size on UBotObjectiveBriefcaseInVault");

// Class DeceiveInc.CavalierePassiveAbilityMod1
// 0x0018 (0x0548 - 0x0530)
class ACavalierePassiveAbilityMod1 final : public ABaseSpyPassiveAbility
{
public:
	FMulticastInlineDelegateProperty_             OnFillUpMagazine;                                  // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         MinMeleeChargeLevel;                               // 0x0540(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_544[0x4];                                      // 0x0544(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleMeleeAttackDamageDoneServer(class AActor* Victim, const struct FVector& ImpactPoint, int32 ChargeLevel, float DamageDone, float ResultingHealthPercentage, EHitType HitType, const struct FMeleeHitConfirmedData& HitConfirmedData);
	void HandleMeleeAttackLoadComplete(class UToolLoadoutComponent* LoadoutComponent);
	void NetMulticast_OnFillUpMagazine(class AProjectileWeapon* Weapon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CavalierePassiveAbilityMod1">();
	}
	static class ACavalierePassiveAbilityMod1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACavalierePassiveAbilityMod1>();
	}
};
static_assert(alignof(ACavalierePassiveAbilityMod1) == 0x000008, "Wrong alignment on ACavalierePassiveAbilityMod1");
static_assert(sizeof(ACavalierePassiveAbilityMod1) == 0x000548, "Wrong size on ACavalierePassiveAbilityMod1");
static_assert(offsetof(ACavalierePassiveAbilityMod1, OnFillUpMagazine) == 0x000530, "Member 'ACavalierePassiveAbilityMod1::OnFillUpMagazine' has a wrong offset!");
static_assert(offsetof(ACavalierePassiveAbilityMod1, MinMeleeChargeLevel) == 0x000540, "Member 'ACavalierePassiveAbilityMod1::MinMeleeChargeLevel' has a wrong offset!");

// Class DeceiveInc.BotObjectiveCallExtraction
// 0x0000 (0x0048 - 0x0048)
class UBotObjectiveCallExtraction final : public UBotObjective
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjectiveCallExtraction">();
	}
	static class UBotObjectiveCallExtraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjectiveCallExtraction>();
	}
};
static_assert(alignof(UBotObjectiveCallExtraction) == 0x000008, "Wrong alignment on UBotObjectiveCallExtraction");
static_assert(sizeof(UBotObjectiveCallExtraction) == 0x000048, "Wrong size on UBotObjectiveCallExtraction");

// Class DeceiveInc.BotObjectiveExtract
// 0x0000 (0x0048 - 0x0048)
class UBotObjectiveExtract final : public UBotObjective
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjectiveExtract">();
	}
	static class UBotObjectiveExtract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjectiveExtract>();
	}
};
static_assert(alignof(UBotObjectiveExtract) == 0x000008, "Wrong alignment on UBotObjectiveExtract");
static_assert(sizeof(UBotObjectiveExtract) == 0x000048, "Wrong size on UBotObjectiveExtract");

// Class DeceiveInc.BotObjectiveGetBriefcase
// 0x0000 (0x0048 - 0x0048)
class UBotObjectiveGetBriefcase final : public UBotObjective
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjectiveGetBriefcase">();
	}
	static class UBotObjectiveGetBriefcase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjectiveGetBriefcase>();
	}
};
static_assert(alignof(UBotObjectiveGetBriefcase) == 0x000008, "Wrong alignment on UBotObjectiveGetBriefcase");
static_assert(sizeof(UBotObjectiveGetBriefcase) == 0x000048, "Wrong size on UBotObjectiveGetBriefcase");

// Class DeceiveInc.BotObjectiveKillCarrier
// 0x0000 (0x0048 - 0x0048)
class UBotObjectiveKillCarrier final : public UBotObjective
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjectiveKillCarrier">();
	}
	static class UBotObjectiveKillCarrier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjectiveKillCarrier>();
	}
};
static_assert(alignof(UBotObjectiveKillCarrier) == 0x000008, "Wrong alignment on UBotObjectiveKillCarrier");
static_assert(sizeof(UBotObjectiveKillCarrier) == 0x000048, "Wrong size on UBotObjectiveKillCarrier");

// Class DeceiveInc.DeceiveIncEngine
// 0x0000 (0x0D70 - 0x0D70)
class UDeceiveIncEngine final : public UGameEngine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeceiveIncEngine">();
	}
	static class UDeceiveIncEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeceiveIncEngine>();
	}
};
static_assert(alignof(UDeceiveIncEngine) == 0x000008, "Wrong alignment on UDeceiveIncEngine");
static_assert(sizeof(UDeceiveIncEngine) == 0x000D70, "Wrong size on UDeceiveIncEngine");

// Class DeceiveInc.BotObjectiveOpenVault
// 0x0000 (0x0048 - 0x0048)
class UBotObjectiveOpenVault final : public UBotObjective
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjectiveOpenVault">();
	}
	static class UBotObjectiveOpenVault* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjectiveOpenVault>();
	}
};
static_assert(alignof(UBotObjectiveOpenVault) == 0x000008, "Wrong alignment on UBotObjectiveOpenVault");
static_assert(sizeof(UBotObjectiveOpenVault) == 0x000048, "Wrong size on UBotObjectiveOpenVault");

// Class DeceiveInc.DiButton
// 0x0048 (0x0470 - 0x0428)
class UDiButton final : public UButton
{
public:
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnActionStarted;                                   // 0x0430(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActionCompleted;                                 // 0x0440(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActionTriggered;                                 // 0x0450(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UInputAction*                           InputAction;                                       // 0x0460(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimulateClickOnActionStarted;                     // 0x0468(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimulateClickOnActionTriggered;                   // 0x0469(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46A[0x6];                                      // 0x046A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiButton">();
	}
	static class UDiButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiButton>();
	}
};
static_assert(alignof(UDiButton) == 0x000008, "Wrong alignment on UDiButton");
static_assert(sizeof(UDiButton) == 0x000470, "Wrong size on UDiButton");
static_assert(offsetof(UDiButton, OnActionStarted) == 0x000430, "Member 'UDiButton::OnActionStarted' has a wrong offset!");
static_assert(offsetof(UDiButton, OnActionCompleted) == 0x000440, "Member 'UDiButton::OnActionCompleted' has a wrong offset!");
static_assert(offsetof(UDiButton, OnActionTriggered) == 0x000450, "Member 'UDiButton::OnActionTriggered' has a wrong offset!");
static_assert(offsetof(UDiButton, InputAction) == 0x000460, "Member 'UDiButton::InputAction' has a wrong offset!");
static_assert(offsetof(UDiButton, bSimulateClickOnActionStarted) == 0x000468, "Member 'UDiButton::bSimulateClickOnActionStarted' has a wrong offset!");
static_assert(offsetof(UDiButton, bSimulateClickOnActionTriggered) == 0x000469, "Member 'UDiButton::bSimulateClickOnActionTriggered' has a wrong offset!");

// Class DeceiveInc.BotObjectivePickUpBriefcase
// 0x0000 (0x0048 - 0x0048)
class UBotObjectivePickUpBriefcase final : public UBotObjective
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjectivePickUpBriefcase">();
	}
	static class UBotObjectivePickUpBriefcase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjectivePickUpBriefcase>();
	}
};
static_assert(alignof(UBotObjectivePickUpBriefcase) == 0x000008, "Wrong alignment on UBotObjectivePickUpBriefcase");
static_assert(sizeof(UBotObjectivePickUpBriefcase) == 0x000048, "Wrong size on UBotObjectivePickUpBriefcase");

// Class DeceiveInc.TrainingBotBrain
// 0x0008 (0x0080 - 0x0078)
class UTrainingBotBrain final : public UBotBrain
{
public:
	class UBotPlanFight*                          PlanFight;                                         // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnFightTargetLost(class UBotPlanFight* BotPlanFight, class ASpy* LostTarget);
	void OnUndercoverChange(bool bUndercover);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrainingBotBrain">();
	}
	static class UTrainingBotBrain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrainingBotBrain>();
	}
};
static_assert(alignof(UTrainingBotBrain) == 0x000008, "Wrong alignment on UTrainingBotBrain");
static_assert(sizeof(UTrainingBotBrain) == 0x000080, "Wrong size on UTrainingBotBrain");
static_assert(offsetof(UTrainingBotBrain, PlanFight) == 0x000078, "Member 'UTrainingBotBrain::PlanFight' has a wrong offset!");

// Class DeceiveInc.BotObjectivePrintKeycard
// 0x0000 (0x0048 - 0x0048)
class UBotObjectivePrintKeycard final : public UBotObjective
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjectivePrintKeycard">();
	}
	static class UBotObjectivePrintKeycard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjectivePrintKeycard>();
	}
};
static_assert(alignof(UBotObjectivePrintKeycard) == 0x000008, "Wrong alignment on UBotObjectivePrintKeycard");
static_assert(sizeof(UBotObjectivePrintKeycard) == 0x000048, "Wrong size on UBotObjectivePrintKeycard");

// Class DeceiveInc.DIAnimationBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UDIAnimationBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float GetAnimationNotifyTime(const class UAnimSequence* AnimationSequence, class FName NotifyName, bool ReturnAnimationDurationOnNotifyNotFound);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIAnimationBlueprintLibrary">();
	}
	static class UDIAnimationBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIAnimationBlueprintLibrary>();
	}
};
static_assert(alignof(UDIAnimationBlueprintLibrary) == 0x000008, "Wrong alignment on UDIAnimationBlueprintLibrary");
static_assert(sizeof(UDIAnimationBlueprintLibrary) == 0x000028, "Wrong size on UDIAnimationBlueprintLibrary");

// Class DeceiveInc.BotObjectiveRequirementBriefcaseCarried
// 0x0000 (0x0030 - 0x0030)
class UBotObjectiveRequirementBriefcaseCarried final : public UBotObjectiveRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjectiveRequirementBriefcaseCarried">();
	}
	static class UBotObjectiveRequirementBriefcaseCarried* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjectiveRequirementBriefcaseCarried>();
	}
};
static_assert(alignof(UBotObjectiveRequirementBriefcaseCarried) == 0x000008, "Wrong alignment on UBotObjectiveRequirementBriefcaseCarried");
static_assert(sizeof(UBotObjectiveRequirementBriefcaseCarried) == 0x000030, "Wrong size on UBotObjectiveRequirementBriefcaseCarried");

// Class DeceiveInc.OutOfBoundsEntity
// 0x0000 (0x0028 - 0x0028)
class IOutOfBoundsEntity final : public IInterface
{
public:
	void OnOutOfBoundsActorBeginOverlap(class AActor* InOutOfBoundsActor);
	void OnOutOfBoundsActorEndOverlap(class AActor* InOutOfBoundsActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutOfBoundsEntity">();
	}
	static class IOutOfBoundsEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOutOfBoundsEntity>();
	}
};
static_assert(alignof(IOutOfBoundsEntity) == 0x000008, "Wrong alignment on IOutOfBoundsEntity");
static_assert(sizeof(IOutOfBoundsEntity) == 0x000028, "Wrong size on IOutOfBoundsEntity");

// Class DeceiveInc.BotObjectiveRequirementExtractionCalled
// 0x0000 (0x0030 - 0x0030)
class UBotObjectiveRequirementExtractionCalled final : public UBotObjectiveRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjectiveRequirementExtractionCalled">();
	}
	static class UBotObjectiveRequirementExtractionCalled* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjectiveRequirementExtractionCalled>();
	}
};
static_assert(alignof(UBotObjectiveRequirementExtractionCalled) == 0x000008, "Wrong alignment on UBotObjectiveRequirementExtractionCalled");
static_assert(sizeof(UBotObjectiveRequirementExtractionCalled) == 0x000030, "Wrong size on UBotObjectiveRequirementExtractionCalled");

// Class DeceiveInc.BotObjectiveRequirementGamePhase
// 0x0008 (0x0038 - 0x0030)
class UBotObjectiveRequirementGamePhase final : public UBotObjectiveRequirement
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjectiveRequirementGamePhase">();
	}
	static class UBotObjectiveRequirementGamePhase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjectiveRequirementGamePhase>();
	}
};
static_assert(alignof(UBotObjectiveRequirementGamePhase) == 0x000008, "Wrong alignment on UBotObjectiveRequirementGamePhase");
static_assert(sizeof(UBotObjectiveRequirementGamePhase) == 0x000038, "Wrong size on UBotObjectiveRequirementGamePhase");

// Class DeceiveInc.OctoIntelDrainZonesSubsystem
// 0x0050 (0x0080 - 0x0030)
class UOctoIntelDrainZonesSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OctoIntelDrainZonesSubsystem">();
	}
	static class UOctoIntelDrainZonesSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOctoIntelDrainZonesSubsystem>();
	}
};
static_assert(alignof(UOctoIntelDrainZonesSubsystem) == 0x000008, "Wrong alignment on UOctoIntelDrainZonesSubsystem");
static_assert(sizeof(UOctoIntelDrainZonesSubsystem) == 0x000080, "Wrong size on UOctoIntelDrainZonesSubsystem");

// Class DeceiveInc.BotObjectiveRequirementHasBriefcase
// 0x0000 (0x0030 - 0x0030)
class UBotObjectiveRequirementHasBriefcase final : public UBotObjectiveRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjectiveRequirementHasBriefcase">();
	}
	static class UBotObjectiveRequirementHasBriefcase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjectiveRequirementHasBriefcase>();
	}
};
static_assert(alignof(UBotObjectiveRequirementHasBriefcase) == 0x000008, "Wrong alignment on UBotObjectiveRequirementHasBriefcase");
static_assert(sizeof(UBotObjectiveRequirementHasBriefcase) == 0x000030, "Wrong size on UBotObjectiveRequirementHasBriefcase");

// Class DeceiveInc.OctoBaseActiveAbility
// 0x0018 (0x05A8 - 0x0590)
class AOctoBaseActiveAbility : public ABaseSpyActiveAbility
{
public:
	float                                         OctoEffectDelay;                                   // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_594[0x14];                                     // 0x0594(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnOctoEffectStart();
	void BP_OnOctoEffectStartLocal();
	void BP_OnTriggerLocalDetection();
	void OnEffectDelayTimerEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OctoBaseActiveAbility">();
	}
	static class AOctoBaseActiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOctoBaseActiveAbility>();
	}
};
static_assert(alignof(AOctoBaseActiveAbility) == 0x000008, "Wrong alignment on AOctoBaseActiveAbility");
static_assert(sizeof(AOctoBaseActiveAbility) == 0x0005A8, "Wrong size on AOctoBaseActiveAbility");
static_assert(offsetof(AOctoBaseActiveAbility, OctoEffectDelay) == 0x000590, "Member 'AOctoBaseActiveAbility::OctoEffectDelay' has a wrong offset!");

// Class DeceiveInc.OctoActiveAbility
// 0x0080 (0x0628 - 0x05A8)
class AOctoActiveAbility final : public AOctoBaseActiveAbility
{
public:
	float                                         DetectionRange;                                    // 0x05A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetectionAngle;                                    // 0x05AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ActiveFeedbackDuration;                            // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B4[0x4];                                      // 0x05B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionChannel>                     DetectionCollisionChannels;                        // 0x05B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<EInteractableType, uint8>                DepthStencilValuePerType;                          // 0x05C8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class URangeInteracterComponent*              RangeInteracterComp;                               // 0x0618(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_620[0x8];                                      // 0x0620(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnActiveFeedbackEnd();
	void BP_OnActiveFeedbackEndLocal();
	void BP_OnHackableHacked(class AActor* InteractableActor, EInteractableType InteractableType, uint8 StencilValue);
	void BP_OnHackableRebooted(class AActor* InteractableActor, EInteractableType InteractableType, uint8 StencilValue);
	void MulticastActiveResult(const struct FOctoActiveAbilityResultReplication& InteractableComp);
	void OnActiveFeedbackEndTimerEnd();
	void ServerActiveResult(const struct FOctoActiveAbilityResultReplication& InteractableComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OctoActiveAbility">();
	}
	static class AOctoActiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOctoActiveAbility>();
	}
};
static_assert(alignof(AOctoActiveAbility) == 0x000008, "Wrong alignment on AOctoActiveAbility");
static_assert(sizeof(AOctoActiveAbility) == 0x000628, "Wrong size on AOctoActiveAbility");
static_assert(offsetof(AOctoActiveAbility, DetectionRange) == 0x0005A8, "Member 'AOctoActiveAbility::DetectionRange' has a wrong offset!");
static_assert(offsetof(AOctoActiveAbility, DetectionAngle) == 0x0005AC, "Member 'AOctoActiveAbility::DetectionAngle' has a wrong offset!");
static_assert(offsetof(AOctoActiveAbility, ActiveFeedbackDuration) == 0x0005B0, "Member 'AOctoActiveAbility::ActiveFeedbackDuration' has a wrong offset!");
static_assert(offsetof(AOctoActiveAbility, DetectionCollisionChannels) == 0x0005B8, "Member 'AOctoActiveAbility::DetectionCollisionChannels' has a wrong offset!");
static_assert(offsetof(AOctoActiveAbility, DepthStencilValuePerType) == 0x0005C8, "Member 'AOctoActiveAbility::DepthStencilValuePerType' has a wrong offset!");
static_assert(offsetof(AOctoActiveAbility, RangeInteracterComp) == 0x000618, "Member 'AOctoActiveAbility::RangeInteracterComp' has a wrong offset!");

// Class DeceiveInc.BotPlan
// 0x0008 (0x0030 - 0x0028)
class UBotPlan : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotPlan">();
	}
	static class UBotPlan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotPlan>();
	}
};
static_assert(alignof(UBotPlan) == 0x000008, "Wrong alignment on UBotPlan");
static_assert(sizeof(UBotPlan) == 0x000030, "Wrong size on UBotPlan");

// Class DeceiveInc.BotPlanFight
// 0x0180 (0x01B0 - 0x0030)
class UBotPlanFight final : public UBotPlan
{
public:
	FMulticastInlineDelegateProperty_             OnTargetLost;                                      // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x170];                                     // 0x0040(0x0170)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInstantLoseAggroFromBots(class ASpy* Spy);
	void OnMoveActionEnd(class UBotAction* ActionEnding, EBotActionResult ActionResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotPlanFight">();
	}
	static class UBotPlanFight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotPlanFight>();
	}
};
static_assert(alignof(UBotPlanFight) == 0x000008, "Wrong alignment on UBotPlanFight");
static_assert(sizeof(UBotPlanFight) == 0x0001B0, "Wrong size on UBotPlanFight");
static_assert(offsetof(UBotPlanFight, OnTargetLost) == 0x000030, "Member 'UBotPlanFight::OnTargetLost' has a wrong offset!");

// Class DeceiveInc.OctoPassiveAbilityLuckBased
// 0x0080 (0x05B0 - 0x0530)
class AOctoPassiveAbilityLuckBased : public ABaseSpyPassiveAbility
{
public:
	bool                                          bTriggersOnIntelSpent;                             // 0x0530(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTriggersOnIntelGained;                            // 0x0531(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_532[0x2];                                      // 0x0532(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConfirmLuckDelay;                                  // 0x0534(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShowConfirmationDuration;                          // 0x0538(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NextStackedEventDelay;                             // 0x053C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxStackedEvent;                                   // 0x0540(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_544[0x4];                                      // 0x0544(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStartOctoLuckEvent;                              // 0x0548(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnOctoLuckEventresult;                             // 0x0558(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnStopOctoLuckEvent;                               // 0x0568(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UGameplayResourcesComponent*            GameplayResourceComponent;                         // 0x0578(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_580[0x30];                                     // 0x0580(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_LuckEventResult(int32 IntelChangeAmount, bool bSucesssful);
	void BP_StartLuckEvent(int32 IntelChangeAmount);
	void BP_StopLuckEvent();
	void NetMulticast_OctoLuckEventResult(bool bSuccessful, int32 AmountIn);
	void OnLuckEventConfirmationTimerEnd();
	void OnLuckEventInProgressTimerEnd();
	void OnLuckEventStopTimerEnd();
	void OnResourceChange(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 Amount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OctoPassiveAbilityLuckBased">();
	}
	static class AOctoPassiveAbilityLuckBased* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOctoPassiveAbilityLuckBased>();
	}
};
static_assert(alignof(AOctoPassiveAbilityLuckBased) == 0x000008, "Wrong alignment on AOctoPassiveAbilityLuckBased");
static_assert(sizeof(AOctoPassiveAbilityLuckBased) == 0x0005B0, "Wrong size on AOctoPassiveAbilityLuckBased");
static_assert(offsetof(AOctoPassiveAbilityLuckBased, bTriggersOnIntelSpent) == 0x000530, "Member 'AOctoPassiveAbilityLuckBased::bTriggersOnIntelSpent' has a wrong offset!");
static_assert(offsetof(AOctoPassiveAbilityLuckBased, bTriggersOnIntelGained) == 0x000531, "Member 'AOctoPassiveAbilityLuckBased::bTriggersOnIntelGained' has a wrong offset!");
static_assert(offsetof(AOctoPassiveAbilityLuckBased, ConfirmLuckDelay) == 0x000534, "Member 'AOctoPassiveAbilityLuckBased::ConfirmLuckDelay' has a wrong offset!");
static_assert(offsetof(AOctoPassiveAbilityLuckBased, ShowConfirmationDuration) == 0x000538, "Member 'AOctoPassiveAbilityLuckBased::ShowConfirmationDuration' has a wrong offset!");
static_assert(offsetof(AOctoPassiveAbilityLuckBased, NextStackedEventDelay) == 0x00053C, "Member 'AOctoPassiveAbilityLuckBased::NextStackedEventDelay' has a wrong offset!");
static_assert(offsetof(AOctoPassiveAbilityLuckBased, MaxStackedEvent) == 0x000540, "Member 'AOctoPassiveAbilityLuckBased::MaxStackedEvent' has a wrong offset!");
static_assert(offsetof(AOctoPassiveAbilityLuckBased, OnStartOctoLuckEvent) == 0x000548, "Member 'AOctoPassiveAbilityLuckBased::OnStartOctoLuckEvent' has a wrong offset!");
static_assert(offsetof(AOctoPassiveAbilityLuckBased, OnOctoLuckEventresult) == 0x000558, "Member 'AOctoPassiveAbilityLuckBased::OnOctoLuckEventresult' has a wrong offset!");
static_assert(offsetof(AOctoPassiveAbilityLuckBased, OnStopOctoLuckEvent) == 0x000568, "Member 'AOctoPassiveAbilityLuckBased::OnStopOctoLuckEvent' has a wrong offset!");
static_assert(offsetof(AOctoPassiveAbilityLuckBased, GameplayResourceComponent) == 0x000578, "Member 'AOctoPassiveAbilityLuckBased::GameplayResourceComponent' has a wrong offset!");

// Class DeceiveInc.OctoPassiveAbilityMod1
// 0x0010 (0x05C0 - 0x05B0)
class AOctoPassiveAbilityMod1 final : public AOctoPassiveAbilityLuckBased
{
public:
	float                                         PercentChances_IntelMissing1;                      // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentChances_IntelMissing10;                     // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentChances_IntelMissing20;                     // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5BC[0x4];                                      // 0x05BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OctoPassiveAbilityMod1">();
	}
	static class AOctoPassiveAbilityMod1* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOctoPassiveAbilityMod1>();
	}
};
static_assert(alignof(AOctoPassiveAbilityMod1) == 0x000008, "Wrong alignment on AOctoPassiveAbilityMod1");
static_assert(sizeof(AOctoPassiveAbilityMod1) == 0x0005C0, "Wrong size on AOctoPassiveAbilityMod1");
static_assert(offsetof(AOctoPassiveAbilityMod1, PercentChances_IntelMissing1) == 0x0005B0, "Member 'AOctoPassiveAbilityMod1::PercentChances_IntelMissing1' has a wrong offset!");
static_assert(offsetof(AOctoPassiveAbilityMod1, PercentChances_IntelMissing10) == 0x0005B4, "Member 'AOctoPassiveAbilityMod1::PercentChances_IntelMissing10' has a wrong offset!");
static_assert(offsetof(AOctoPassiveAbilityMod1, PercentChances_IntelMissing20) == 0x0005B8, "Member 'AOctoPassiveAbilityMod1::PercentChances_IntelMissing20' has a wrong offset!");

// Class DeceiveInc.BotPlanFightDataAsset
// 0x0030 (0x0060 - 0x0030)
class UBotPlanFightDataAsset final : public UPrimaryDataAsset
{
public:
	float                                         AllowShotAtInCoverWhileChasingDuration;            // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinChaseDuration;                                  // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlwaysMissDurationAfterAggroing;                   // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlwaysMissBeforeKillingTarget;                     // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GetCloserWhenLosingLoS;                            // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResetRangeDelay;                                   // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FightRangeTooClose;                                // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FightRangeTooFar;                                  // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookingForLostTargetMinDuration;                   // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookingForLostTargetMaxDuration;                   // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookingForLostTarget_ChangeMovementDelayMin;       // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookingForLostTarget_ChangeMovementDelayMax;       // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotPlanFightDataAsset">();
	}
	static class UBotPlanFightDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotPlanFightDataAsset>();
	}
};
static_assert(alignof(UBotPlanFightDataAsset) == 0x000008, "Wrong alignment on UBotPlanFightDataAsset");
static_assert(sizeof(UBotPlanFightDataAsset) == 0x000060, "Wrong size on UBotPlanFightDataAsset");
static_assert(offsetof(UBotPlanFightDataAsset, AllowShotAtInCoverWhileChasingDuration) == 0x000030, "Member 'UBotPlanFightDataAsset::AllowShotAtInCoverWhileChasingDuration' has a wrong offset!");
static_assert(offsetof(UBotPlanFightDataAsset, MinChaseDuration) == 0x000034, "Member 'UBotPlanFightDataAsset::MinChaseDuration' has a wrong offset!");
static_assert(offsetof(UBotPlanFightDataAsset, AlwaysMissDurationAfterAggroing) == 0x000038, "Member 'UBotPlanFightDataAsset::AlwaysMissDurationAfterAggroing' has a wrong offset!");
static_assert(offsetof(UBotPlanFightDataAsset, AlwaysMissBeforeKillingTarget) == 0x00003C, "Member 'UBotPlanFightDataAsset::AlwaysMissBeforeKillingTarget' has a wrong offset!");
static_assert(offsetof(UBotPlanFightDataAsset, GetCloserWhenLosingLoS) == 0x000040, "Member 'UBotPlanFightDataAsset::GetCloserWhenLosingLoS' has a wrong offset!");
static_assert(offsetof(UBotPlanFightDataAsset, ResetRangeDelay) == 0x000044, "Member 'UBotPlanFightDataAsset::ResetRangeDelay' has a wrong offset!");
static_assert(offsetof(UBotPlanFightDataAsset, FightRangeTooClose) == 0x000048, "Member 'UBotPlanFightDataAsset::FightRangeTooClose' has a wrong offset!");
static_assert(offsetof(UBotPlanFightDataAsset, FightRangeTooFar) == 0x00004C, "Member 'UBotPlanFightDataAsset::FightRangeTooFar' has a wrong offset!");
static_assert(offsetof(UBotPlanFightDataAsset, LookingForLostTargetMinDuration) == 0x000050, "Member 'UBotPlanFightDataAsset::LookingForLostTargetMinDuration' has a wrong offset!");
static_assert(offsetof(UBotPlanFightDataAsset, LookingForLostTargetMaxDuration) == 0x000054, "Member 'UBotPlanFightDataAsset::LookingForLostTargetMaxDuration' has a wrong offset!");
static_assert(offsetof(UBotPlanFightDataAsset, LookingForLostTarget_ChangeMovementDelayMin) == 0x000058, "Member 'UBotPlanFightDataAsset::LookingForLostTarget_ChangeMovementDelayMin' has a wrong offset!");
static_assert(offsetof(UBotPlanFightDataAsset, LookingForLostTarget_ChangeMovementDelayMax) == 0x00005C, "Member 'UBotPlanFightDataAsset::LookingForLostTarget_ChangeMovementDelayMax' has a wrong offset!");

// Class DeceiveInc.BotPlanProgressFlow
// 0x0088 (0x00B8 - 0x0030)
class UBotPlanProgressFlow final : public UBotPlan
{
public:
	uint8                                         Pad_30[0x60];                                      // 0x0030(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class ARoomVolume*                            GoalRoom;                                          // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARoomVolume*                            PingRoom;                                          // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARoomVolume*                            MoveToRoom;                                        // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCurrentGoalChanged(class UBotObjective* PrevGoal, class UBotObjective* NewGoal);
	void OnDelayedFindNewActionTimerEnd();
	void OnDontMoveTimerEnd();
	void OnExtractionArrived();
	void OnExtractionOnTheWay();
	void OnGamePhaseChange(ESpyGamePhase NewGamePhase);
	void OnMoveActionEnd(class UBotAction* ActionEnding, EBotActionResult ActionResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotPlanProgressFlow">();
	}
	static class UBotPlanProgressFlow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotPlanProgressFlow>();
	}
};
static_assert(alignof(UBotPlanProgressFlow) == 0x000008, "Wrong alignment on UBotPlanProgressFlow");
static_assert(sizeof(UBotPlanProgressFlow) == 0x0000B8, "Wrong size on UBotPlanProgressFlow");
static_assert(offsetof(UBotPlanProgressFlow, GoalRoom) == 0x000090, "Member 'UBotPlanProgressFlow::GoalRoom' has a wrong offset!");
static_assert(offsetof(UBotPlanProgressFlow, PingRoom) == 0x000098, "Member 'UBotPlanProgressFlow::PingRoom' has a wrong offset!");
static_assert(offsetof(UBotPlanProgressFlow, MoveToRoom) == 0x0000A0, "Member 'UBotPlanProgressFlow::MoveToRoom' has a wrong offset!");

// Class DeceiveInc.PlayerInfoWidget
// 0x0010 (0x0270 - 0x0260)
class UPlayerInfoWidget : public UUserWidget
{
public:
	class ADIPlayerState*                         PlayerState;                                       // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDIOnlinePartyMemberInfo*               PartyMemberInfo;                                   // 0x0268(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Init(class ADIPlayerState* InPlayerState);
	void InitWithPartyMemberInfo(class UDIOnlinePartyMemberInfo* OnlinePartyMemberInfo);
	void InitWithSpy(class ASpy* Spy);
	void OnPlayerInfoUpdated();

	class ADIPlayerState* GetPlayerState() const;
	class FString GetUserName() const;
	EPlatformType GetUserPlatform() const;
	bool IsInitialized() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInfoWidget">();
	}
	static class UPlayerInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerInfoWidget>();
	}
};
static_assert(alignof(UPlayerInfoWidget) == 0x000008, "Wrong alignment on UPlayerInfoWidget");
static_assert(sizeof(UPlayerInfoWidget) == 0x000270, "Wrong size on UPlayerInfoWidget");
static_assert(offsetof(UPlayerInfoWidget, PlayerState) == 0x000260, "Member 'UPlayerInfoWidget::PlayerState' has a wrong offset!");
static_assert(offsetof(UPlayerInfoWidget, PartyMemberInfo) == 0x000268, "Member 'UPlayerInfoWidget::PartyMemberInfo' has a wrong offset!");

// Class DeceiveInc.BotPlanProgressFlowDataAsset
// 0x0040 (0x0070 - 0x0030)
class UBotPlanProgressFlowDataAsset final : public UPrimaryDataAsset
{
public:
	float                                         IdlingMinDuration;                                 // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdlingMaxDuration;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PercentChanceToRunWhenMoving;                      // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WantToChangeCoverIntervalMin;                      // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WantToChangeCoverIntervalMax;                      // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoSomethingStupidIntervalMin;                      // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoSomethingStupidIntervalMax;                      // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtractDistanceMin;                                // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtractDistanceMax;                                // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtractRunTimeMin;                                 // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtractRunTimeMax;                                 // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtractWalkTimeMin;                                // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtractWalkTimeMax;                                // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactToLeaderActionDelayMin;                       // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactToLeaderActionDelayMax;                       // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotPlanProgressFlowDataAsset">();
	}
	static class UBotPlanProgressFlowDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotPlanProgressFlowDataAsset>();
	}
};
static_assert(alignof(UBotPlanProgressFlowDataAsset) == 0x000008, "Wrong alignment on UBotPlanProgressFlowDataAsset");
static_assert(sizeof(UBotPlanProgressFlowDataAsset) == 0x000070, "Wrong size on UBotPlanProgressFlowDataAsset");
static_assert(offsetof(UBotPlanProgressFlowDataAsset, IdlingMinDuration) == 0x000030, "Member 'UBotPlanProgressFlowDataAsset::IdlingMinDuration' has a wrong offset!");
static_assert(offsetof(UBotPlanProgressFlowDataAsset, IdlingMaxDuration) == 0x000034, "Member 'UBotPlanProgressFlowDataAsset::IdlingMaxDuration' has a wrong offset!");
static_assert(offsetof(UBotPlanProgressFlowDataAsset, PercentChanceToRunWhenMoving) == 0x000038, "Member 'UBotPlanProgressFlowDataAsset::PercentChanceToRunWhenMoving' has a wrong offset!");
static_assert(offsetof(UBotPlanProgressFlowDataAsset, WantToChangeCoverIntervalMin) == 0x00003C, "Member 'UBotPlanProgressFlowDataAsset::WantToChangeCoverIntervalMin' has a wrong offset!");
static_assert(offsetof(UBotPlanProgressFlowDataAsset, WantToChangeCoverIntervalMax) == 0x000040, "Member 'UBotPlanProgressFlowDataAsset::WantToChangeCoverIntervalMax' has a wrong offset!");
static_assert(offsetof(UBotPlanProgressFlowDataAsset, DoSomethingStupidIntervalMin) == 0x000044, "Member 'UBotPlanProgressFlowDataAsset::DoSomethingStupidIntervalMin' has a wrong offset!");
static_assert(offsetof(UBotPlanProgressFlowDataAsset, DoSomethingStupidIntervalMax) == 0x000048, "Member 'UBotPlanProgressFlowDataAsset::DoSomethingStupidIntervalMax' has a wrong offset!");
static_assert(offsetof(UBotPlanProgressFlowDataAsset, ExtractDistanceMin) == 0x00004C, "Member 'UBotPlanProgressFlowDataAsset::ExtractDistanceMin' has a wrong offset!");
static_assert(offsetof(UBotPlanProgressFlowDataAsset, ExtractDistanceMax) == 0x000050, "Member 'UBotPlanProgressFlowDataAsset::ExtractDistanceMax' has a wrong offset!");
static_assert(offsetof(UBotPlanProgressFlowDataAsset, ExtractRunTimeMin) == 0x000054, "Member 'UBotPlanProgressFlowDataAsset::ExtractRunTimeMin' has a wrong offset!");
static_assert(offsetof(UBotPlanProgressFlowDataAsset, ExtractRunTimeMax) == 0x000058, "Member 'UBotPlanProgressFlowDataAsset::ExtractRunTimeMax' has a wrong offset!");
static_assert(offsetof(UBotPlanProgressFlowDataAsset, ExtractWalkTimeMin) == 0x00005C, "Member 'UBotPlanProgressFlowDataAsset::ExtractWalkTimeMin' has a wrong offset!");
static_assert(offsetof(UBotPlanProgressFlowDataAsset, ExtractWalkTimeMax) == 0x000060, "Member 'UBotPlanProgressFlowDataAsset::ExtractWalkTimeMax' has a wrong offset!");
static_assert(offsetof(UBotPlanProgressFlowDataAsset, ReactToLeaderActionDelayMin) == 0x000064, "Member 'UBotPlanProgressFlowDataAsset::ReactToLeaderActionDelayMin' has a wrong offset!");
static_assert(offsetof(UBotPlanProgressFlowDataAsset, ReactToLeaderActionDelayMax) == 0x000068, "Member 'UBotPlanProgressFlowDataAsset::ReactToLeaderActionDelayMax' has a wrong offset!");

// Class DeceiveInc.BotSpawner
// 0x0030 (0x0250 - 0x0220)
class ABotSpawner final : public AActor
{
public:
	bool                                          bAutoSpawnOnStart;                                 // 0x0220(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x3];                                      // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetId                        AgentDataId;                                       // 0x0224(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ANPCCharacter>              DisguiseNPC;                                       // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBotBrainType                                 BotBrain;                                          // 0x0240(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241[0xF];                                      // 0x0241(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DespawnLastSpawnedBot();
	class ADeceiveIncBotController* SpawnBot();

	class ADeceiveIncBotController* GetLastSpawnedBot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotSpawner">();
	}
	static class ABotSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABotSpawner>();
	}
};
static_assert(alignof(ABotSpawner) == 0x000008, "Wrong alignment on ABotSpawner");
static_assert(sizeof(ABotSpawner) == 0x000250, "Wrong size on ABotSpawner");
static_assert(offsetof(ABotSpawner, bAutoSpawnOnStart) == 0x000220, "Member 'ABotSpawner::bAutoSpawnOnStart' has a wrong offset!");
static_assert(offsetof(ABotSpawner, AgentDataId) == 0x000224, "Member 'ABotSpawner::AgentDataId' has a wrong offset!");
static_assert(offsetof(ABotSpawner, DisguiseNPC) == 0x000238, "Member 'ABotSpawner::DisguiseNPC' has a wrong offset!");
static_assert(offsetof(ABotSpawner, BotBrain) == 0x000240, "Member 'ABotSpawner::BotBrain' has a wrong offset!");

// Class DeceiveInc.PingInGameUserWidget
// 0x0018 (0x0318 - 0x0300)
class UPingInGameUserWidget final : public UDIMenuUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnPingSelection;                                   // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SelectPingIndex(int32 Index_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PingInGameUserWidget">();
	}
	static class UPingInGameUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPingInGameUserWidget>();
	}
};
static_assert(alignof(UPingInGameUserWidget) == 0x000008, "Wrong alignment on UPingInGameUserWidget");
static_assert(sizeof(UPingInGameUserWidget) == 0x000318, "Wrong size on UPingInGameUserWidget");
static_assert(offsetof(UPingInGameUserWidget, OnPingSelection) == 0x000300, "Member 'UPingInGameUserWidget::OnPingSelection' has a wrong offset!");

// Class DeceiveInc.BounceableEntity
// 0x0000 (0x0028 - 0x0028)
class IBounceableEntity final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BounceableEntity">();
	}
	static class IBounceableEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBounceableEntity>();
	}
};
static_assert(alignof(IBounceableEntity) == 0x000008, "Wrong alignment on IBounceableEntity");
static_assert(sizeof(IBounceableEntity) == 0x000028, "Wrong size on IBounceableEntity");

// Class DeceiveInc.OctoPassiveAbility
// 0x0028 (0x0558 - 0x0530)
class AOctoPassiveAbility final : public ABaseSpyPassiveAbility
{
public:
	EGameplayResourcesType                        ResourceTypeToCheck;                               // 0x0530(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_531[0x3];                                      // 0x0531(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IntelToGainBeforeUpgrade;                          // 0x0534(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxIntelAddedPerUpgrade;                           // 0x0538(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxUpgradeGiven;                                   // 0x053C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_540[0x10];                                     // 0x0540(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayResourcesComponent*            GameplayResourceComponent;                         // 0x0550(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleResourceChange(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 DeltaAmount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OctoPassiveAbility">();
	}
	static class AOctoPassiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOctoPassiveAbility>();
	}
};
static_assert(alignof(AOctoPassiveAbility) == 0x000008, "Wrong alignment on AOctoPassiveAbility");
static_assert(sizeof(AOctoPassiveAbility) == 0x000558, "Wrong size on AOctoPassiveAbility");
static_assert(offsetof(AOctoPassiveAbility, ResourceTypeToCheck) == 0x000530, "Member 'AOctoPassiveAbility::ResourceTypeToCheck' has a wrong offset!");
static_assert(offsetof(AOctoPassiveAbility, IntelToGainBeforeUpgrade) == 0x000534, "Member 'AOctoPassiveAbility::IntelToGainBeforeUpgrade' has a wrong offset!");
static_assert(offsetof(AOctoPassiveAbility, MaxIntelAddedPerUpgrade) == 0x000538, "Member 'AOctoPassiveAbility::MaxIntelAddedPerUpgrade' has a wrong offset!");
static_assert(offsetof(AOctoPassiveAbility, MaxUpgradeGiven) == 0x00053C, "Member 'AOctoPassiveAbility::MaxUpgradeGiven' has a wrong offset!");
static_assert(offsetof(AOctoPassiveAbility, GameplayResourceComponent) == 0x000550, "Member 'AOctoPassiveAbility::GameplayResourceComponent' has a wrong offset!");

// Class DeceiveInc.BouncingMatTool
// 0x0038 (0x06C0 - 0x0688)
class ABouncingMatTool final : public ABasePlaceableSpyTool
{
public:
	uint8                                         Pad_688[0x8];                                      // 0x0688(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABouncingMat*                           BouncingMatActor;                                  // 0x0690(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   PlaceableToolSecondaryAlternativeActionText;       // 0x0698(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bAllowManualDeflate;                               // 0x06B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B1[0x3];                                      // 0x06B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InflateCooldown;                                   // 0x06B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B8[0x8];                                      // 0x06B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleNotifyDeflate(class ABouncingMat* DeflatingBounceMat);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BouncingMatTool">();
	}
	static class ABouncingMatTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABouncingMatTool>();
	}
};
static_assert(alignof(ABouncingMatTool) == 0x000008, "Wrong alignment on ABouncingMatTool");
static_assert(sizeof(ABouncingMatTool) == 0x0006C0, "Wrong size on ABouncingMatTool");
static_assert(offsetof(ABouncingMatTool, BouncingMatActor) == 0x000690, "Member 'ABouncingMatTool::BouncingMatActor' has a wrong offset!");
static_assert(offsetof(ABouncingMatTool, PlaceableToolSecondaryAlternativeActionText) == 0x000698, "Member 'ABouncingMatTool::PlaceableToolSecondaryAlternativeActionText' has a wrong offset!");
static_assert(offsetof(ABouncingMatTool, bAllowManualDeflate) == 0x0006B0, "Member 'ABouncingMatTool::bAllowManualDeflate' has a wrong offset!");
static_assert(offsetof(ABouncingMatTool, InflateCooldown) == 0x0006B4, "Member 'ABouncingMatTool::InflateCooldown' has a wrong offset!");

// Class DeceiveInc.BriefcaseLoot
// 0x0090 (0x02B0 - 0x0220)
class ABriefcaseLoot final : public AActor
{
public:
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       CameraComponent;                                   // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ALootItemShowcase>>  LootItemShowcaseClassByRarity;                     // 0x0230(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class FName>                           PedestalSockets;                                   // 0x0240(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector                                PedestalAttachRotation;                            // 0x0250(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnBriefcaseLootScaleChanged;                       // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_270[0x40];                                     // 0x0270(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnLootClaimError(const class FString& ErrorMessage);
	void BP_OnLootClaimResponseSet(const struct FLootClaimResponse& NewLootClaimResponse);
	void BP_OnPedestalsSpawned(const TArray<class ALootItemShowcase*>& SpawnedPedestals);
	void BriefcaseLootSpawnPedestals();
	void BringBackFromDespawn();
	void DestroyPedestals();
	TArray<class ALootItemShowcase*> GetPedestals();
	void OnClaimLootBundleResponse(const class FString& LootBundleId, const struct FLootClaimResponse& Response, const class FString& Error, bool bSuccess);
	void ShowcaseItemsOnPedestals();
	void StartDespawn(float DespawnDurationIn);

	struct FLootClaimResponse GetLootClaimResponse() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BriefcaseLoot">();
	}
	static class ABriefcaseLoot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABriefcaseLoot>();
	}
};
static_assert(alignof(ABriefcaseLoot) == 0x000008, "Wrong alignment on ABriefcaseLoot");
static_assert(sizeof(ABriefcaseLoot) == 0x0002B0, "Wrong size on ABriefcaseLoot");
static_assert(offsetof(ABriefcaseLoot, SkeletalMesh) == 0x000220, "Member 'ABriefcaseLoot::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(ABriefcaseLoot, CameraComponent) == 0x000228, "Member 'ABriefcaseLoot::CameraComponent' has a wrong offset!");
static_assert(offsetof(ABriefcaseLoot, LootItemShowcaseClassByRarity) == 0x000230, "Member 'ABriefcaseLoot::LootItemShowcaseClassByRarity' has a wrong offset!");
static_assert(offsetof(ABriefcaseLoot, PedestalSockets) == 0x000240, "Member 'ABriefcaseLoot::PedestalSockets' has a wrong offset!");
static_assert(offsetof(ABriefcaseLoot, PedestalAttachRotation) == 0x000250, "Member 'ABriefcaseLoot::PedestalAttachRotation' has a wrong offset!");
static_assert(offsetof(ABriefcaseLoot, OnBriefcaseLootScaleChanged) == 0x000260, "Member 'ABriefcaseLoot::OnBriefcaseLootScaleChanged' has a wrong offset!");

// Class DeceiveInc.PlayerBotsSubsystem
// 0x0060 (0x0090 - 0x0030)
class UPlayerBotsSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBotObjective*                          RootBotGoal;                                       // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x40];                                      // 0x0050(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGamePhaseChanged(ESpyGamePhase NewGamePhase);
	void OnSpyBotDeath(class ASpy* Spy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerBotsSubsystem">();
	}
	static class UPlayerBotsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerBotsSubsystem>();
	}
};
static_assert(alignof(UPlayerBotsSubsystem) == 0x000008, "Wrong alignment on UPlayerBotsSubsystem");
static_assert(sizeof(UPlayerBotsSubsystem) == 0x000090, "Wrong size on UPlayerBotsSubsystem");
static_assert(offsetof(UPlayerBotsSubsystem, RootBotGoal) == 0x000048, "Member 'UPlayerBotsSubsystem::RootBotGoal' has a wrong offset!");

// Class DeceiveInc.BuildMetadataSubsystem
// 0x0000 (0x0030 - 0x0030)
class UBuildMetadataSubsystem final : public UGameInstanceSubsystem
{
public:
	TArray<class FString> GetFilteredReleaseNoteLines(bool bRemoveBuildNumberLines, bool bRemoveHashtagRN) const;
	TArray<class FString> GetFilteredReleaseNoteLinesForBuild(int32 buildChangelist, bool bRemoveBuildNumberLines, bool bRemoveHashtagRN) const;
	TArray<class FString> GetRawReleaseNoteLines() const;
	TArray<int32> GetReleaseNoteBuildChangelistNumbers() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildMetadataSubsystem">();
	}
	static class UBuildMetadataSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildMetadataSubsystem>();
	}
};
static_assert(alignof(UBuildMetadataSubsystem) == 0x000008, "Wrong alignment on UBuildMetadataSubsystem");
static_assert(sizeof(UBuildMetadataSubsystem) == 0x000030, "Wrong size on UBuildMetadataSubsystem");

// Class DeceiveInc.DIPopulationManagerNpcSpawnDataAsset
// 0x00B8 (0x00F0 - 0x0038)
class UDIPopulationManagerNpcSpawnDataAsset final : public UDIPrimaryDataAsset
{
public:
	struct FSpawnNPCLevelData                     SpawnNPCLevelData[0x7];                            // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)
	float                                         GuardsPercentageSpawningInVault;                   // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EliteGuardsPercentageSpawningInVault;              // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaffsPercentageSpawningInVault;                   // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NPCsEnteringVaultCount;                            // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIPopulationManagerNpcSpawnDataAsset">();
	}
	static class UDIPopulationManagerNpcSpawnDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIPopulationManagerNpcSpawnDataAsset>();
	}
};
static_assert(alignof(UDIPopulationManagerNpcSpawnDataAsset) == 0x000008, "Wrong alignment on UDIPopulationManagerNpcSpawnDataAsset");
static_assert(sizeof(UDIPopulationManagerNpcSpawnDataAsset) == 0x0000F0, "Wrong size on UDIPopulationManagerNpcSpawnDataAsset");
static_assert(offsetof(UDIPopulationManagerNpcSpawnDataAsset, SpawnNPCLevelData) == 0x000038, "Member 'UDIPopulationManagerNpcSpawnDataAsset::SpawnNPCLevelData' has a wrong offset!");
static_assert(offsetof(UDIPopulationManagerNpcSpawnDataAsset, GuardsPercentageSpawningInVault) == 0x0000E0, "Member 'UDIPopulationManagerNpcSpawnDataAsset::GuardsPercentageSpawningInVault' has a wrong offset!");
static_assert(offsetof(UDIPopulationManagerNpcSpawnDataAsset, EliteGuardsPercentageSpawningInVault) == 0x0000E4, "Member 'UDIPopulationManagerNpcSpawnDataAsset::EliteGuardsPercentageSpawningInVault' has a wrong offset!");
static_assert(offsetof(UDIPopulationManagerNpcSpawnDataAsset, StaffsPercentageSpawningInVault) == 0x0000E8, "Member 'UDIPopulationManagerNpcSpawnDataAsset::StaffsPercentageSpawningInVault' has a wrong offset!");
static_assert(offsetof(UDIPopulationManagerNpcSpawnDataAsset, NPCsEnteringVaultCount) == 0x0000EC, "Member 'UDIPopulationManagerNpcSpawnDataAsset::NPCsEnteringVaultCount' has a wrong offset!");

// Class DeceiveInc.DropAtBehavior
// 0x0050 (0x0078 - 0x0028)
class UDropAtBehavior : public UObject
{
public:
	float                                         Gravity;                                           // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AddHeightToDrop;                                   // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ActorToDrop;                                       // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x30];                                      // 0x0048(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DropAtBehavior">();
	}
	static class UDropAtBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDropAtBehavior>();
	}
};
static_assert(alignof(UDropAtBehavior) == 0x000008, "Wrong alignment on UDropAtBehavior");
static_assert(sizeof(UDropAtBehavior) == 0x000078, "Wrong size on UDropAtBehavior");
static_assert(offsetof(UDropAtBehavior, Gravity) == 0x000028, "Member 'UDropAtBehavior::Gravity' has a wrong offset!");
static_assert(offsetof(UDropAtBehavior, AddHeightToDrop) == 0x00002C, "Member 'UDropAtBehavior::AddHeightToDrop' has a wrong offset!");
static_assert(offsetof(UDropAtBehavior, ActorToDrop) == 0x000040, "Member 'UDropAtBehavior::ActorToDrop' has a wrong offset!");

// Class DeceiveInc.CallingCardDropAtBehavior
// 0x00F0 (0x0168 - 0x0078)
class UCallingCardDropAtBehavior final : public UDropAtBehavior
{
public:
	uint8                                         Pad_78[0x3C];                                      // 0x0078(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThrowRightOffset;                                  // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WobbleSpring;                                      // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WobbleDecel;                                       // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WobbleTime;                                        // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4[0xA4];                                      // 0x00C4(0x00A4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CallingCardDropAtBehavior">();
	}
	static class UCallingCardDropAtBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCallingCardDropAtBehavior>();
	}
};
static_assert(alignof(UCallingCardDropAtBehavior) == 0x000008, "Wrong alignment on UCallingCardDropAtBehavior");
static_assert(sizeof(UCallingCardDropAtBehavior) == 0x000168, "Wrong size on UCallingCardDropAtBehavior");
static_assert(offsetof(UCallingCardDropAtBehavior, ThrowRightOffset) == 0x0000B4, "Member 'UCallingCardDropAtBehavior::ThrowRightOffset' has a wrong offset!");
static_assert(offsetof(UCallingCardDropAtBehavior, WobbleSpring) == 0x0000B8, "Member 'UCallingCardDropAtBehavior::WobbleSpring' has a wrong offset!");
static_assert(offsetof(UCallingCardDropAtBehavior, WobbleDecel) == 0x0000BC, "Member 'UCallingCardDropAtBehavior::WobbleDecel' has a wrong offset!");
static_assert(offsetof(UCallingCardDropAtBehavior, WobbleTime) == 0x0000C0, "Member 'UCallingCardDropAtBehavior::WobbleTime' has a wrong offset!");

// Class DeceiveInc.PlayerOwnedConditionComponent
// 0x0008 (0x00D8 - 0x00D0)
class UPlayerOwnedConditionComponent final : public UBaseConditionComponent
{
public:
	bool                                          bMustBePlayerOwned;                                // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerOwnedConditionComponent">();
	}
	static class UPlayerOwnedConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerOwnedConditionComponent>();
	}
};
static_assert(alignof(UPlayerOwnedConditionComponent) == 0x000008, "Wrong alignment on UPlayerOwnedConditionComponent");
static_assert(sizeof(UPlayerOwnedConditionComponent) == 0x0000D8, "Wrong size on UPlayerOwnedConditionComponent");
static_assert(offsetof(UPlayerOwnedConditionComponent, bMustBePlayerOwned) == 0x0000D0, "Member 'UPlayerOwnedConditionComponent::bMustBePlayerOwned' has a wrong offset!");

// Class DeceiveInc.CallingCardInGameUserWidget
// 0x0028 (0x0328 - 0x0300)
class UCallingCardInGameUserWidget final : public UDIMenuUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnCardSelectionChange;                             // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ECallingCardPosition                          CurrentSelection;                                  // 0x0310(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ADeceiveIncPlayerController*            LocalController;                                   // 0x0318(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseInputActionForQuadrantSelection;               // 0x0320(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_321[0x7];                                      // 0x0321(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SelectCallingcard(ECallingCardPosition CardPosition);
	void SelectCallingcardIndex(int32 Index_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CallingCardInGameUserWidget">();
	}
	static class UCallingCardInGameUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCallingCardInGameUserWidget>();
	}
};
static_assert(alignof(UCallingCardInGameUserWidget) == 0x000008, "Wrong alignment on UCallingCardInGameUserWidget");
static_assert(sizeof(UCallingCardInGameUserWidget) == 0x000328, "Wrong size on UCallingCardInGameUserWidget");
static_assert(offsetof(UCallingCardInGameUserWidget, OnCardSelectionChange) == 0x000300, "Member 'UCallingCardInGameUserWidget::OnCardSelectionChange' has a wrong offset!");
static_assert(offsetof(UCallingCardInGameUserWidget, CurrentSelection) == 0x000310, "Member 'UCallingCardInGameUserWidget::CurrentSelection' has a wrong offset!");
static_assert(offsetof(UCallingCardInGameUserWidget, LocalController) == 0x000318, "Member 'UCallingCardInGameUserWidget::LocalController' has a wrong offset!");
static_assert(offsetof(UCallingCardInGameUserWidget, bUseInputActionForQuadrantSelection) == 0x000320, "Member 'UCallingCardInGameUserWidget::bUseInputActionForQuadrantSelection' has a wrong offset!");

// Class DeceiveInc.PlatformDataAsset
// 0x00A0 (0x00D8 - 0x0038)
class UPlatformDataAsset final : public UDIPrimaryDataAsset
{
public:
	TMap<class FString, EPlatformType>            PlatformType;                                      // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EPlatformType, struct FPlatformInfo>     PlatformInfos;                                     // 0x0088(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	class FString GetCurrentPlatformName();
	EPlatformType GetCurrentPlatformType();
	EPlatformType GetPlatformType(const class FString& PlateformName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformDataAsset">();
	}
	static class UPlatformDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformDataAsset>();
	}
};
static_assert(alignof(UPlatformDataAsset) == 0x000008, "Wrong alignment on UPlatformDataAsset");
static_assert(sizeof(UPlatformDataAsset) == 0x0000D8, "Wrong size on UPlatformDataAsset");
static_assert(offsetof(UPlatformDataAsset, PlatformType) == 0x000038, "Member 'UPlatformDataAsset::PlatformType' has a wrong offset!");
static_assert(offsetof(UPlatformDataAsset, PlatformInfos) == 0x000088, "Member 'UPlatformDataAsset::PlatformInfos' has a wrong offset!");

// Class DeceiveInc.CallingCardPlaceable
// 0x0008 (0x0228 - 0x0220)
class ACallingCardPlaceable final : public AActor
{
public:
	class UStaticMeshComponent*                   CallingCardMesh;                                   // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CallingCardPlaceable">();
	}
	static class ACallingCardPlaceable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACallingCardPlaceable>();
	}
};
static_assert(alignof(ACallingCardPlaceable) == 0x000008, "Wrong alignment on ACallingCardPlaceable");
static_assert(sizeof(ACallingCardPlaceable) == 0x000228, "Wrong size on ACallingCardPlaceable");
static_assert(offsetof(ACallingCardPlaceable, CallingCardMesh) == 0x000220, "Member 'ACallingCardPlaceable::CallingCardMesh' has a wrong offset!");

// Class DeceiveInc.CallingCardPlaceableTool
// 0x00D8 (0x0608 - 0x0530)
class ACallingCardPlaceableTool final : public ABaseSpyTool
{
public:
	FMulticastInlineDelegateProperty_             OnCallingCardToolThrowStart;                       // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCallingCardToolThrowDelayEnd;                    // 0x0540(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCallingCardToolFullThrowEnd;                     // 0x0550(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstance*>              CallingCardsMaterials;                             // 0x0560(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class URangePlacementComponent*               RangePlacementComp;                                // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxCallingCards;                                   // 0x0578(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinDistanceToDespawn;                              // 0x057C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CallingCardSelectionHudName;                       // 0x0580(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDIMenuUserWidget>          CardSelectionMenuClass;                            // 0x0588(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowDelay1P;                                      // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowOutTime1P;                                    // 0x0594(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowDelay3P;                                      // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowOutlTime3P;                                   // 0x059C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A0[0x8];                                      // 0x05A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LastLocalCallingCard;                              // 0x05A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 LastCallingCard;                                   // 0x05B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ACallingCardPlaceable*>          CallingCardActors;                                 // 0x05B8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UDIMenuUserWidget*                      ActiveMenu;                                        // 0x05C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D0[0x38];                                     // 0x05D0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleOnNewDropActorDropped(class AActor* ServerActorToDrop, class AActor* LocalActorToDrop, const struct FVector& EndLocation, const struct FRotator& EndRotation);
	void NetMulticast_OnNewSelectedCallingCard(int32 NewSelectedCallingCard);
	void NetMulticast_ThrowCard();
	void OnThrowDelayTimerEnd();
	void OnThrowTimerEnd();
	void Server_OnNewSelectedCallingCard(int32 NewSelectedCallingCard);
	void Server_ThrowCard();

	bool IsThrowingCard() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CallingCardPlaceableTool">();
	}
	static class ACallingCardPlaceableTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACallingCardPlaceableTool>();
	}
};
static_assert(alignof(ACallingCardPlaceableTool) == 0x000008, "Wrong alignment on ACallingCardPlaceableTool");
static_assert(sizeof(ACallingCardPlaceableTool) == 0x000608, "Wrong size on ACallingCardPlaceableTool");
static_assert(offsetof(ACallingCardPlaceableTool, OnCallingCardToolThrowStart) == 0x000530, "Member 'ACallingCardPlaceableTool::OnCallingCardToolThrowStart' has a wrong offset!");
static_assert(offsetof(ACallingCardPlaceableTool, OnCallingCardToolThrowDelayEnd) == 0x000540, "Member 'ACallingCardPlaceableTool::OnCallingCardToolThrowDelayEnd' has a wrong offset!");
static_assert(offsetof(ACallingCardPlaceableTool, OnCallingCardToolFullThrowEnd) == 0x000550, "Member 'ACallingCardPlaceableTool::OnCallingCardToolFullThrowEnd' has a wrong offset!");
static_assert(offsetof(ACallingCardPlaceableTool, CallingCardsMaterials) == 0x000560, "Member 'ACallingCardPlaceableTool::CallingCardsMaterials' has a wrong offset!");
static_assert(offsetof(ACallingCardPlaceableTool, RangePlacementComp) == 0x000570, "Member 'ACallingCardPlaceableTool::RangePlacementComp' has a wrong offset!");
static_assert(offsetof(ACallingCardPlaceableTool, MaxCallingCards) == 0x000578, "Member 'ACallingCardPlaceableTool::MaxCallingCards' has a wrong offset!");
static_assert(offsetof(ACallingCardPlaceableTool, MinDistanceToDespawn) == 0x00057C, "Member 'ACallingCardPlaceableTool::MinDistanceToDespawn' has a wrong offset!");
static_assert(offsetof(ACallingCardPlaceableTool, CallingCardSelectionHudName) == 0x000580, "Member 'ACallingCardPlaceableTool::CallingCardSelectionHudName' has a wrong offset!");
static_assert(offsetof(ACallingCardPlaceableTool, CardSelectionMenuClass) == 0x000588, "Member 'ACallingCardPlaceableTool::CardSelectionMenuClass' has a wrong offset!");
static_assert(offsetof(ACallingCardPlaceableTool, ThrowDelay1P) == 0x000590, "Member 'ACallingCardPlaceableTool::ThrowDelay1P' has a wrong offset!");
static_assert(offsetof(ACallingCardPlaceableTool, ThrowOutTime1P) == 0x000594, "Member 'ACallingCardPlaceableTool::ThrowOutTime1P' has a wrong offset!");
static_assert(offsetof(ACallingCardPlaceableTool, ThrowDelay3P) == 0x000598, "Member 'ACallingCardPlaceableTool::ThrowDelay3P' has a wrong offset!");
static_assert(offsetof(ACallingCardPlaceableTool, ThrowOutlTime3P) == 0x00059C, "Member 'ACallingCardPlaceableTool::ThrowOutlTime3P' has a wrong offset!");
static_assert(offsetof(ACallingCardPlaceableTool, LastLocalCallingCard) == 0x0005A8, "Member 'ACallingCardPlaceableTool::LastLocalCallingCard' has a wrong offset!");
static_assert(offsetof(ACallingCardPlaceableTool, LastCallingCard) == 0x0005B0, "Member 'ACallingCardPlaceableTool::LastCallingCard' has a wrong offset!");
static_assert(offsetof(ACallingCardPlaceableTool, CallingCardActors) == 0x0005B8, "Member 'ACallingCardPlaceableTool::CallingCardActors' has a wrong offset!");
static_assert(offsetof(ACallingCardPlaceableTool, ActiveMenu) == 0x0005C8, "Member 'ACallingCardPlaceableTool::ActiveMenu' has a wrong offset!");

// Class DeceiveInc.PoisonAoEActor
// 0x0020 (0x0348 - 0x0328)
class APoisonAoEActor final : public ABaseAoEActor
{
public:
	float                                         DamagePerDelay;                                    // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageDelay;                                       // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDamageOnlySpys;                                   // 0x0330(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPoisonAffectInteractable;                         // 0x0331(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_332[0x16];                                     // 0x0332(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleLoadoutSpawnComplete(class UToolLoadoutComponent* ToolLoadout);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoisonAoEActor">();
	}
	static class APoisonAoEActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APoisonAoEActor>();
	}
};
static_assert(alignof(APoisonAoEActor) == 0x000008, "Wrong alignment on APoisonAoEActor");
static_assert(sizeof(APoisonAoEActor) == 0x000348, "Wrong size on APoisonAoEActor");
static_assert(offsetof(APoisonAoEActor, DamagePerDelay) == 0x000328, "Member 'APoisonAoEActor::DamagePerDelay' has a wrong offset!");
static_assert(offsetof(APoisonAoEActor, DamageDelay) == 0x00032C, "Member 'APoisonAoEActor::DamageDelay' has a wrong offset!");
static_assert(offsetof(APoisonAoEActor, bDamageOnlySpys) == 0x000330, "Member 'APoisonAoEActor::bDamageOnlySpys' has a wrong offset!");
static_assert(offsetof(APoisonAoEActor, bPoisonAffectInteractable) == 0x000331, "Member 'APoisonAoEActor::bPoisonAffectInteractable' has a wrong offset!");

// Class DeceiveInc.CallingCardPositionerComponent
// 0x0010 (0x0130 - 0x0120)
class UCallingCardPositionerComponent final : public UBasePositionerComponent
{
public:
	ETraceTypeQuery                               RaycastCollisionChannel;                           // 0x0120(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WallAtOffsetRadAngle;                              // 0x0124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GroundOffset;                                      // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CallingCardPositionerComponent">();
	}
	static class UCallingCardPositionerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCallingCardPositionerComponent>();
	}
};
static_assert(alignof(UCallingCardPositionerComponent) == 0x000008, "Wrong alignment on UCallingCardPositionerComponent");
static_assert(sizeof(UCallingCardPositionerComponent) == 0x000130, "Wrong size on UCallingCardPositionerComponent");
static_assert(offsetof(UCallingCardPositionerComponent, RaycastCollisionChannel) == 0x000120, "Member 'UCallingCardPositionerComponent::RaycastCollisionChannel' has a wrong offset!");
static_assert(offsetof(UCallingCardPositionerComponent, WallAtOffsetRadAngle) == 0x000124, "Member 'UCallingCardPositionerComponent::WallAtOffsetRadAngle' has a wrong offset!");
static_assert(offsetof(UCallingCardPositionerComponent, GroundOffset) == 0x000128, "Member 'UCallingCardPositionerComponent::GroundOffset' has a wrong offset!");

// Class DeceiveInc.CavActiveInteracterComponent
// 0x0078 (0x0398 - 0x0320)
class UCavActiveInteracterComponent final : public URangeInteracterComponent
{
public:
	FMulticastInlineDelegateProperty_             OnInteractableNewHotness;                          // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCavActiveInteractionComplete;                    // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCavActiveRegisterInteractable;                   // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCavActiveUnregisterInteractable;                 // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<int64>                                 HotnessLevelMaxTime;                               // 0x0360(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bOnlyRegisterDeadInteract;                         // 0x0370(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckRayConditionForHotness;                      // 0x0371(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_372[0x6];                                      // 0x0372(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInteractableData>              InteractableDataList;                              // 0x0378(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FInteractableData>              ScannedClues;                                      // 0x0388(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CavActiveInteracterComponent">();
	}
	static class UCavActiveInteracterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCavActiveInteracterComponent>();
	}
};
static_assert(alignof(UCavActiveInteracterComponent) == 0x000008, "Wrong alignment on UCavActiveInteracterComponent");
static_assert(sizeof(UCavActiveInteracterComponent) == 0x000398, "Wrong size on UCavActiveInteracterComponent");
static_assert(offsetof(UCavActiveInteracterComponent, OnInteractableNewHotness) == 0x000320, "Member 'UCavActiveInteracterComponent::OnInteractableNewHotness' has a wrong offset!");
static_assert(offsetof(UCavActiveInteracterComponent, OnCavActiveInteractionComplete) == 0x000330, "Member 'UCavActiveInteracterComponent::OnCavActiveInteractionComplete' has a wrong offset!");
static_assert(offsetof(UCavActiveInteracterComponent, OnCavActiveRegisterInteractable) == 0x000340, "Member 'UCavActiveInteracterComponent::OnCavActiveRegisterInteractable' has a wrong offset!");
static_assert(offsetof(UCavActiveInteracterComponent, OnCavActiveUnregisterInteractable) == 0x000350, "Member 'UCavActiveInteracterComponent::OnCavActiveUnregisterInteractable' has a wrong offset!");
static_assert(offsetof(UCavActiveInteracterComponent, HotnessLevelMaxTime) == 0x000360, "Member 'UCavActiveInteracterComponent::HotnessLevelMaxTime' has a wrong offset!");
static_assert(offsetof(UCavActiveInteracterComponent, bOnlyRegisterDeadInteract) == 0x000370, "Member 'UCavActiveInteracterComponent::bOnlyRegisterDeadInteract' has a wrong offset!");
static_assert(offsetof(UCavActiveInteracterComponent, bCheckRayConditionForHotness) == 0x000371, "Member 'UCavActiveInteracterComponent::bCheckRayConditionForHotness' has a wrong offset!");
static_assert(offsetof(UCavActiveInteracterComponent, InteractableDataList) == 0x000378, "Member 'UCavActiveInteracterComponent::InteractableDataList' has a wrong offset!");
static_assert(offsetof(UCavActiveInteracterComponent, ScannedClues) == 0x000388, "Member 'UCavActiveInteracterComponent::ScannedClues' has a wrong offset!");

// Class DeceiveInc.CavaliereActiveAbility
// 0x0210 (0x07A0 - 0x0590)
class ACavaliereActiveAbility final : public ABaseSpyActiveAbility
{
public:
	FMulticastInlineDelegateProperty_             OnNewClueData;                                     // 0x0590(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHudNewText;                                      // 0x05A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNewExposingPercent;                              // 0x05B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChaseStart;                                      // 0x05C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActiveInteractionStart;                          // 0x05D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActiveInteractionCancel;                         // 0x05E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActiveInteractionComplete;                       // 0x05F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UCavActiveInteracterComponent*          CavInteracterComp;                                 // 0x0600(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   AbilityVictimEffect;                               // 0x0608(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ActiveTimeToAddOnCluePickUp;                       // 0x0630(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_634[0x4];                                      // 0x0634(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   CavHudAsset;                                       // 0x0638(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   HudInvestigationText;                              // 0x0660(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   HudExposingText;                                   // 0x0678(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         MinExposingToPing;                                 // 0x0690(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_694[0x4];                                      // 0x0694(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 HotnessLevelExposingPercentToGive;                 // 0x0698(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<float, float>                            ChaseLevelDurationMap;                             // 0x06A8(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UUserWidget*                            CavHud;                                            // 0x06F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_700[0x68];                                     // 0x0700(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class ADIPlayerState*                         ChasedDIPS;                                        // 0x0768(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASpy*                                   ChasedSpy;                                         // 0x0770(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_778[0x28];                                     // 0x0778(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleCavActiveInteractionCancel(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void HandleCavActiveInteractionComplete(const struct FInteractableData& InteractableData);
	void HandleCavActiveInteractionStart(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void HandleCavActiveRegisterInteractable(const struct FInteractableData& InteractableData);
	void HandleNewFocusedInteractable(class UInteractableComponent* NewFocusedInteractable);
	void NetMulticast_OnChasingEnd(class AActor* Victim);
	void NetMulticast_OnChasingStart(class AActor* Victim);
	void OnChasingEnd(class AActor* Victim);
	void Server_OnCavActiveInteractionCancel(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void Server_OnCavActiveInteractionComplete(class UInteractableComponent* Interactable, int64 TimeOfRequest);
	void Server_OnCavActiveInteractionStart(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void SetInteractionProgressBar(class UProgressBar* ProgressBar);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CavaliereActiveAbility">();
	}
	static class ACavaliereActiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACavaliereActiveAbility>();
	}
};
static_assert(alignof(ACavaliereActiveAbility) == 0x000008, "Wrong alignment on ACavaliereActiveAbility");
static_assert(sizeof(ACavaliereActiveAbility) == 0x0007A0, "Wrong size on ACavaliereActiveAbility");
static_assert(offsetof(ACavaliereActiveAbility, OnNewClueData) == 0x000590, "Member 'ACavaliereActiveAbility::OnNewClueData' has a wrong offset!");
static_assert(offsetof(ACavaliereActiveAbility, OnHudNewText) == 0x0005A0, "Member 'ACavaliereActiveAbility::OnHudNewText' has a wrong offset!");
static_assert(offsetof(ACavaliereActiveAbility, OnNewExposingPercent) == 0x0005B0, "Member 'ACavaliereActiveAbility::OnNewExposingPercent' has a wrong offset!");
static_assert(offsetof(ACavaliereActiveAbility, OnChaseStart) == 0x0005C0, "Member 'ACavaliereActiveAbility::OnChaseStart' has a wrong offset!");
static_assert(offsetof(ACavaliereActiveAbility, OnActiveInteractionStart) == 0x0005D0, "Member 'ACavaliereActiveAbility::OnActiveInteractionStart' has a wrong offset!");
static_assert(offsetof(ACavaliereActiveAbility, OnActiveInteractionCancel) == 0x0005E0, "Member 'ACavaliereActiveAbility::OnActiveInteractionCancel' has a wrong offset!");
static_assert(offsetof(ACavaliereActiveAbility, OnActiveInteractionComplete) == 0x0005F0, "Member 'ACavaliereActiveAbility::OnActiveInteractionComplete' has a wrong offset!");
static_assert(offsetof(ACavaliereActiveAbility, CavInteracterComp) == 0x000600, "Member 'ACavaliereActiveAbility::CavInteracterComp' has a wrong offset!");
static_assert(offsetof(ACavaliereActiveAbility, AbilityVictimEffect) == 0x000608, "Member 'ACavaliereActiveAbility::AbilityVictimEffect' has a wrong offset!");
static_assert(offsetof(ACavaliereActiveAbility, ActiveTimeToAddOnCluePickUp) == 0x000630, "Member 'ACavaliereActiveAbility::ActiveTimeToAddOnCluePickUp' has a wrong offset!");
static_assert(offsetof(ACavaliereActiveAbility, CavHudAsset) == 0x000638, "Member 'ACavaliereActiveAbility::CavHudAsset' has a wrong offset!");
static_assert(offsetof(ACavaliereActiveAbility, HudInvestigationText) == 0x000660, "Member 'ACavaliereActiveAbility::HudInvestigationText' has a wrong offset!");
static_assert(offsetof(ACavaliereActiveAbility, HudExposingText) == 0x000678, "Member 'ACavaliereActiveAbility::HudExposingText' has a wrong offset!");
static_assert(offsetof(ACavaliereActiveAbility, MinExposingToPing) == 0x000690, "Member 'ACavaliereActiveAbility::MinExposingToPing' has a wrong offset!");
static_assert(offsetof(ACavaliereActiveAbility, HotnessLevelExposingPercentToGive) == 0x000698, "Member 'ACavaliereActiveAbility::HotnessLevelExposingPercentToGive' has a wrong offset!");
static_assert(offsetof(ACavaliereActiveAbility, ChaseLevelDurationMap) == 0x0006A8, "Member 'ACavaliereActiveAbility::ChaseLevelDurationMap' has a wrong offset!");
static_assert(offsetof(ACavaliereActiveAbility, CavHud) == 0x0006F8, "Member 'ACavaliereActiveAbility::CavHud' has a wrong offset!");
static_assert(offsetof(ACavaliereActiveAbility, ChasedDIPS) == 0x000768, "Member 'ACavaliereActiveAbility::ChasedDIPS' has a wrong offset!");
static_assert(offsetof(ACavaliereActiveAbility, ChasedSpy) == 0x000770, "Member 'ACavaliereActiveAbility::ChasedSpy' has a wrong offset!");

// Class DeceiveInc.PointOfInterestComponent
// 0x0010 (0x0210 - 0x0200)
class UPointOfInterestComponent final : public USceneComponent
{
public:
	bool                                          bStartEnabled;                                     // 0x01F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x3];                                      // 0x01F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookDistance;                                      // 0x01FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0200(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFPCamera;                                         // 0x0204(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_205[0xB];                                      // 0x0205(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnablePOI(bool bEnableIn);

	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PointOfInterestComponent">();
	}
	static class UPointOfInterestComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPointOfInterestComponent>();
	}
};
static_assert(alignof(UPointOfInterestComponent) == 0x000010, "Wrong alignment on UPointOfInterestComponent");
static_assert(sizeof(UPointOfInterestComponent) == 0x000210, "Wrong size on UPointOfInterestComponent");
static_assert(offsetof(UPointOfInterestComponent, bStartEnabled) == 0x0001F8, "Member 'UPointOfInterestComponent::bStartEnabled' has a wrong offset!");
static_assert(offsetof(UPointOfInterestComponent, LookDistance) == 0x0001FC, "Member 'UPointOfInterestComponent::LookDistance' has a wrong offset!");
static_assert(offsetof(UPointOfInterestComponent, Priority) == 0x000200, "Member 'UPointOfInterestComponent::Priority' has a wrong offset!");
static_assert(offsetof(UPointOfInterestComponent, bFPCamera) == 0x000204, "Member 'UPointOfInterestComponent::bFPCamera' has a wrong offset!");

// Class DeceiveInc.CavaliereActiveAbilityMod2
// 0x0038 (0x05C8 - 0x0590)
class ACavaliereActiveAbilityMod2 final : public ABaseSpyActiveAbility
{
public:
	FMulticastInlineDelegateProperty_             OnInvestigateSpyStart;                             // 0x0590(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class URangePlacementComponent*               RangePlacementComp;                                // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayResourcesComponent*            GameplayResource;                                  // 0x05A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VictimEffectDuration;                              // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B4[0x4];                                      // 0x05B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AInvestigationZoneActor*                InvestigationZone;                                 // 0x05B8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C0[0x8];                                      // 0x05C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_OnSpyTrapped(class AActor* TrappedSpy);
	void HandleMiscToolSpawned(class AActor* SpawnedTool);
	void HandleTrappedSpy(class AActor* TrappedSpy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CavaliereActiveAbilityMod2">();
	}
	static class ACavaliereActiveAbilityMod2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACavaliereActiveAbilityMod2>();
	}
};
static_assert(alignof(ACavaliereActiveAbilityMod2) == 0x000008, "Wrong alignment on ACavaliereActiveAbilityMod2");
static_assert(sizeof(ACavaliereActiveAbilityMod2) == 0x0005C8, "Wrong size on ACavaliereActiveAbilityMod2");
static_assert(offsetof(ACavaliereActiveAbilityMod2, OnInvestigateSpyStart) == 0x000590, "Member 'ACavaliereActiveAbilityMod2::OnInvestigateSpyStart' has a wrong offset!");
static_assert(offsetof(ACavaliereActiveAbilityMod2, RangePlacementComp) == 0x0005A0, "Member 'ACavaliereActiveAbilityMod2::RangePlacementComp' has a wrong offset!");
static_assert(offsetof(ACavaliereActiveAbilityMod2, GameplayResource) == 0x0005A8, "Member 'ACavaliereActiveAbilityMod2::GameplayResource' has a wrong offset!");
static_assert(offsetof(ACavaliereActiveAbilityMod2, VictimEffectDuration) == 0x0005B0, "Member 'ACavaliereActiveAbilityMod2::VictimEffectDuration' has a wrong offset!");
static_assert(offsetof(ACavaliereActiveAbilityMod2, InvestigationZone) == 0x0005B8, "Member 'ACavaliereActiveAbilityMod2::InvestigationZone' has a wrong offset!");

// Class DeceiveInc.CavaliereMeleeAttack
// 0x0000 (0x07F8 - 0x07F8)
class ACavaliereMeleeAttack final : public ABaseMeleeAttack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CavaliereMeleeAttack">();
	}
	static class ACavaliereMeleeAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACavaliereMeleeAttack>();
	}
};
static_assert(alignof(ACavaliereMeleeAttack) == 0x000008, "Wrong alignment on ACavaliereMeleeAttack");
static_assert(sizeof(ACavaliereMeleeAttack) == 0x0007F8, "Wrong size on ACavaliereMeleeAttack");

// Class DeceiveInc.CavalierePassiveAbility
// 0x0048 (0x0578 - 0x0530)
class ACavalierePassiveAbility final : public ABaseSpyPassiveAbility
{
public:
	uint8                                         Pad_530[0x20];                                     // 0x0530(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          CollisionBox;                                      // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CollisionBoxOffset;                                // 0x0558(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxMeleeRange;                                     // 0x055C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ImpulseSpeed;                                      // 0x0560(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistToStopFromTarget;                              // 0x0564(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoImpulseOnTargetOnly;                            // 0x0568(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_569[0x3];                                      // 0x0569(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinChargeLevelForImpulse;                          // 0x056C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTargetingOnImpulseEndOnly;                        // 0x0570(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_571[0x7];                                      // 0x0571(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnMeleeAttackEvent(ESpyMeleeAttackEvent EventType, class ABaseMeleeAttack* MeleeAttack);
	void HandleMeleeAttackEvent(ESpyMeleeAttackEvent EventType, class ABaseMeleeAttack* MeleeAttack);
	void HandleMeleeAttackLoadComplete(class UToolLoadoutComponent* LoadoutComponent);
	void NonLocalClientHandleMeleeAttackEvent(ESpyMeleeAttackEvent EventType, class ABaseMeleeAttack* MeleeAttack);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CavalierePassiveAbility">();
	}
	static class ACavalierePassiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACavalierePassiveAbility>();
	}
};
static_assert(alignof(ACavalierePassiveAbility) == 0x000008, "Wrong alignment on ACavalierePassiveAbility");
static_assert(sizeof(ACavalierePassiveAbility) == 0x000578, "Wrong size on ACavalierePassiveAbility");
static_assert(offsetof(ACavalierePassiveAbility, CollisionBox) == 0x000550, "Member 'ACavalierePassiveAbility::CollisionBox' has a wrong offset!");
static_assert(offsetof(ACavalierePassiveAbility, CollisionBoxOffset) == 0x000558, "Member 'ACavalierePassiveAbility::CollisionBoxOffset' has a wrong offset!");
static_assert(offsetof(ACavalierePassiveAbility, MaxMeleeRange) == 0x00055C, "Member 'ACavalierePassiveAbility::MaxMeleeRange' has a wrong offset!");
static_assert(offsetof(ACavalierePassiveAbility, ImpulseSpeed) == 0x000560, "Member 'ACavalierePassiveAbility::ImpulseSpeed' has a wrong offset!");
static_assert(offsetof(ACavalierePassiveAbility, DistToStopFromTarget) == 0x000564, "Member 'ACavalierePassiveAbility::DistToStopFromTarget' has a wrong offset!");
static_assert(offsetof(ACavalierePassiveAbility, bDoImpulseOnTargetOnly) == 0x000568, "Member 'ACavalierePassiveAbility::bDoImpulseOnTargetOnly' has a wrong offset!");
static_assert(offsetof(ACavalierePassiveAbility, MinChargeLevelForImpulse) == 0x00056C, "Member 'ACavalierePassiveAbility::MinChargeLevelForImpulse' has a wrong offset!");
static_assert(offsetof(ACavalierePassiveAbility, bTargetingOnImpulseEndOnly) == 0x000570, "Member 'ACavalierePassiveAbility::bTargetingOnImpulseEndOnly' has a wrong offset!");

// Class DeceiveInc.RayCastConditionComponent
// 0x00F8 (0x01C8 - 0x00D0)
class URayCastConditionComponent final : public UBaseConditionComponent
{
public:
	bool                                          bIgnoreOwner;                                      // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PenetrationThreshold;                              // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxRaycastCheckForIgnoredBlocking;                 // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             TestCollisionChannel;                              // 0x00DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         SpecificActorsToIgnore;                            // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSet<class AActor*>                           IgnoredActors;                                     // 0x00F0(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_140[0x88];                                     // 0x0140(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RayCastConditionComponent">();
	}
	static class URayCastConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URayCastConditionComponent>();
	}
};
static_assert(alignof(URayCastConditionComponent) == 0x000008, "Wrong alignment on URayCastConditionComponent");
static_assert(sizeof(URayCastConditionComponent) == 0x0001C8, "Wrong size on URayCastConditionComponent");
static_assert(offsetof(URayCastConditionComponent, bIgnoreOwner) == 0x0000D0, "Member 'URayCastConditionComponent::bIgnoreOwner' has a wrong offset!");
static_assert(offsetof(URayCastConditionComponent, PenetrationThreshold) == 0x0000D4, "Member 'URayCastConditionComponent::PenetrationThreshold' has a wrong offset!");
static_assert(offsetof(URayCastConditionComponent, MaxRaycastCheckForIgnoredBlocking) == 0x0000D8, "Member 'URayCastConditionComponent::MaxRaycastCheckForIgnoredBlocking' has a wrong offset!");
static_assert(offsetof(URayCastConditionComponent, TestCollisionChannel) == 0x0000DC, "Member 'URayCastConditionComponent::TestCollisionChannel' has a wrong offset!");
static_assert(offsetof(URayCastConditionComponent, SpecificActorsToIgnore) == 0x0000E0, "Member 'URayCastConditionComponent::SpecificActorsToIgnore' has a wrong offset!");
static_assert(offsetof(URayCastConditionComponent, IgnoredActors) == 0x0000F0, "Member 'URayCastConditionComponent::IgnoredActors' has a wrong offset!");

// Class DeceiveInc.CavalierePassiveAbilityMod2
// 0x0030 (0x0560 - 0x0530)
class ACavalierePassiveAbilityMod2 final : public ABaseSpyPassiveAbility
{
public:
	int32                                         MinMeleeChargeLevel;                               // 0x0530(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_534[0x4];                                      // 0x0534(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   MeleeAttackVictimEffectClass;                      // 0x0538(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleMeleeAttackDamageDoneServer(class AActor* Victim, const struct FVector& ImpactPoint, int32 ChargeLevel, float DamageDone, float ResultingHealthPercentage, EHitType HitType, const struct FMeleeHitConfirmedData& HitConfirmedData);
	void HandleMeleeAttackLoadComplete(class UToolLoadoutComponent* LoadoutComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CavalierePassiveAbilityMod2">();
	}
	static class ACavalierePassiveAbilityMod2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACavalierePassiveAbilityMod2>();
	}
};
static_assert(alignof(ACavalierePassiveAbilityMod2) == 0x000008, "Wrong alignment on ACavalierePassiveAbilityMod2");
static_assert(sizeof(ACavalierePassiveAbilityMod2) == 0x000560, "Wrong size on ACavalierePassiveAbilityMod2");
static_assert(offsetof(ACavalierePassiveAbilityMod2, MinMeleeChargeLevel) == 0x000530, "Member 'ACavalierePassiveAbilityMod2::MinMeleeChargeLevel' has a wrong offset!");
static_assert(offsetof(ACavalierePassiveAbilityMod2, MeleeAttackVictimEffectClass) == 0x000538, "Member 'ACavalierePassiveAbilityMod2::MeleeAttackVictimEffectClass' has a wrong offset!");

// Class DeceiveInc.ChangePhaseComponent
// 0x0008 (0x00B8 - 0x00B0)
class UChangePhaseComponent final : public UActorComponent
{
public:
	ESpyGamePhase                                 NextPhase;                                         // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangePhaseComponent">();
	}
	static class UChangePhaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChangePhaseComponent>();
	}
};
static_assert(alignof(UChangePhaseComponent) == 0x000008, "Wrong alignment on UChangePhaseComponent");
static_assert(sizeof(UChangePhaseComponent) == 0x0000B8, "Wrong size on UChangePhaseComponent");
static_assert(offsetof(UChangePhaseComponent, NextPhase) == 0x0000B0, "Member 'UChangePhaseComponent::NextPhase' has a wrong offset!");

// Class DeceiveInc.PregameLobbyMapData
// 0x0058 (0x0090 - 0x0038)
class UPregameLobbyMapData final : public UDIPrimaryDataAsset
{
public:
	struct FPregameLobbyPhaseData                 PregameLobbyPhaseData;                             // 0x0038(0x0058)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PregameLobbyMapData">();
	}
	static class UPregameLobbyMapData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPregameLobbyMapData>();
	}
};
static_assert(alignof(UPregameLobbyMapData) == 0x000008, "Wrong alignment on UPregameLobbyMapData");
static_assert(sizeof(UPregameLobbyMapData) == 0x000090, "Wrong size on UPregameLobbyMapData");
static_assert(offsetof(UPregameLobbyMapData, PregameLobbyPhaseData) == 0x000038, "Member 'UPregameLobbyMapData::PregameLobbyPhaseData' has a wrong offset!");

// Class DeceiveInc.ChargeLevelsWeaponComponent
// 0x0058 (0x0108 - 0x00B0)
class UChargeLevelsWeaponComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChargeLevelWeaponChange;                         // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         AmmoCostPerChargeLevel;                            // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FChargeLevelWeaponData>         ChargeLevels;                                      // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bDealExplosionAOEDamage;                           // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AOctoPassiveAbilityLuckBased*           OctoPassive;                                       // 0x00E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AOctoPassiveAbility*                    OctoDefaultPassive;                                // 0x00F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x4];                                       // 0x00F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChargeLevel;                                       // 0x00FC(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetCurrentChargeLevel();
	void HandleWeaponProjectileImpact(const struct FWeaponImpactData& WeaponImpactData);
	void OnChargeChanged(bool bIsCharging, class AChargeSpawnerWeapon* ChargeWeapon);
	void OnLoadoutSpawnComplete(class UToolLoadoutComponent* ToolLoadout);
	void OnProjectilesReleased(const struct FVector& AimedPosition);
	void OnRep_ChargeLevel(int32 PrevChargeLevel);
	void Server_AOEDamage(const struct FWeaponImpactData& WeaponImpactData, int32 ChargeLevelIn);

	const struct FChargeLevelWeaponData GetChargeLevelData(int32 ChargeLevelDataIn) const;
	const struct FChargeLevelWeaponData GetCurrentChargeLevelData() const;
	const struct FChargeLevelWeaponData GetProjectileChargeLevelData(class ASpawnerWeaponRound* RoundIn) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeLevelsWeaponComponent">();
	}
	static class UChargeLevelsWeaponComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargeLevelsWeaponComponent>();
	}
};
static_assert(alignof(UChargeLevelsWeaponComponent) == 0x000008, "Wrong alignment on UChargeLevelsWeaponComponent");
static_assert(sizeof(UChargeLevelsWeaponComponent) == 0x000108, "Wrong size on UChargeLevelsWeaponComponent");
static_assert(offsetof(UChargeLevelsWeaponComponent, OnChargeLevelWeaponChange) == 0x0000B8, "Member 'UChargeLevelsWeaponComponent::OnChargeLevelWeaponChange' has a wrong offset!");
static_assert(offsetof(UChargeLevelsWeaponComponent, AmmoCostPerChargeLevel) == 0x0000C8, "Member 'UChargeLevelsWeaponComponent::AmmoCostPerChargeLevel' has a wrong offset!");
static_assert(offsetof(UChargeLevelsWeaponComponent, ChargeLevels) == 0x0000D0, "Member 'UChargeLevelsWeaponComponent::ChargeLevels' has a wrong offset!");
static_assert(offsetof(UChargeLevelsWeaponComponent, bDealExplosionAOEDamage) == 0x0000E0, "Member 'UChargeLevelsWeaponComponent::bDealExplosionAOEDamage' has a wrong offset!");
static_assert(offsetof(UChargeLevelsWeaponComponent, OctoPassive) == 0x0000E8, "Member 'UChargeLevelsWeaponComponent::OctoPassive' has a wrong offset!");
static_assert(offsetof(UChargeLevelsWeaponComponent, OctoDefaultPassive) == 0x0000F0, "Member 'UChargeLevelsWeaponComponent::OctoDefaultPassive' has a wrong offset!");
static_assert(offsetof(UChargeLevelsWeaponComponent, ChargeLevel) == 0x0000FC, "Member 'UChargeLevelsWeaponComponent::ChargeLevel' has a wrong offset!");

// Class DeceiveInc.ProjectileWeapon
// 0x03E0 (0x0910 - 0x0530)
class AProjectileWeapon : public ABaseSpyWeapon
{
public:
	FMulticastInlineDelegateProperty_             OnShotFired;                                       // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBurstFirstShot;                                  // 0x0540(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShotCycleBegin;                                  // 0x0550(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShotCycleEnd;                                    // 0x0560(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDryShotCycleBegin;                               // 0x0570(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDryShotCycleEnd;                                 // 0x0580(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReloadStart;                                     // 0x0590(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInstantReload;                                   // 0x05A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLocalInstantReload;                              // 0x05B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnProjectileImpact;                                // 0x05C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHitConfirmed;                                    // 0x05D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnServerHitConfirmed;                              // 0x05E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnADSChanged;                                      // 0x05F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFillUpMagazine;                                  // 0x0600(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnResourceTypeChanged;                             // 0x0610(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnResourceAmountChanged;                           // 0x0620(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponDisabledChanged;                           // 0x0630(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_640[0x10];                                     // 0x0640(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAmmoCountRefreshed;                              // 0x0650(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USBAimAssistConfigDataAsset*            ADSAimAssistConfig;                                // 0x0660(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_668[0x4];                                      // 0x0668(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bADSPressed;                                       // 0x066C(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_66D[0x33];                                     // 0x066D(0x0033)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Mesh1P;                                            // 0x06A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 Mesh3P;                                            // 0x06A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceMesh3pForMuzzle;                             // 0x06B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B1[0x3];                                      // 0x06B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MuzzleSocketName;                                  // 0x06B4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttachRoundsToSpy;                                // 0x06BC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6BD[0x3];                                      // 0x06BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MagazineSize;                                      // 0x06C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseAllAmmosAsMagazine;                            // 0x06C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C5[0x3];                                      // 0x06C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ResourcesSpentPerShot;                             // 0x06C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaximumRateOfFire;                                 // 0x06CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            RateOfFireCurve;                                   // 0x06D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurveEffectiveTime;                                // 0x06D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurveNormalizedResetDuration;                      // 0x06DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReloadTime;                                        // 0x06E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMakeReloadTimeSameAsFireRate;                     // 0x06E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6E5[0x3];                                      // 0x06E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EffectiveAimRange;                                 // 0x06E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFiringMode                                   FiringMode;                                        // 0x06EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6ED[0x3];                                      // 0x06ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ShotRequestedPerBurst;                             // 0x06F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShotDelayAfterBurst;                               // 0x06F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAddShotDelayOnlyOnPrimaryEnd;                     // 0x06F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6F9[0x3];                                      // 0x06F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ResourcesPerFullAmmoPack;                          // 0x06FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ResourcesPerDispenserAmmoPack;                     // 0x0700(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ResourcesAtMaximumAmmo;                            // 0x0704(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoReloadWhenEmpty;                              // 0x0708(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStopADSOnReload;                                  // 0x0709(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanAutofireWithAccesibilitySetting;               // 0x070A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanUseToggleADSSetting;                           // 0x070B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoReloadOnDryFire;                              // 0x070C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70D[0x3];                                      // 0x070D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EarlyShotRequestTolerance;                         // 0x0710(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlowCoverOnFire;                                  // 0x0714(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_715[0x3];                                      // 0x0715(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CooldownBeforeMelee;                               // 0x0718(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71C[0x4];                                      // 0x071C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   EffectOnPawnHit;                                   // 0x0720(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEffectOnHitRefreshBehavior                   EffectOnHitRefreshBehavior;                        // 0x0748(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DoEffectOnEnemyFactionOnly;                        // 0x0749(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHideWhenNoAmmoInMagazine;                         // 0x074A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowManualReload;                                // 0x074B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasRecoil;                                        // 0x074C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74D[0x3];                                      // 0x074D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRecoilData                            RecoilStats;                                       // 0x0750(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRecoilData                            RecoilADSStats;                                    // 0x0780(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bFireBothWeaponOnFire;                             // 0x07B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlternateFireWithSecondaryWeapon;                 // 0x07B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bADSShootWithSecondaryWeapon;                      // 0x07B2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bADSHitPlayerInstantReload;                        // 0x07B3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bADSUsesSecondaryWeaponFireMode;                   // 0x07B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHideWeaponWhenSwappingToSecondary;                // 0x07B5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHideToolOnSwitchToIfInADS;                        // 0x07B6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSecondaryUseOwnClip;                              // 0x07B7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseMainWeaponForMuzzle;                           // 0x07B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B9[0x3];                                      // 0x07B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LowAmmoAmount;                                     // 0x07BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutoReloadRateOfFireRatio;                         // 0x07C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OverwriteBlockShootingAfterMelee;                  // 0x07C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 OverwriteBlockShootingAfterMeleeChargeLevel;       // 0x07C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bBlockLeftHandFlavorAnimationsOnReload;            // 0x07D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlockLeftHandFlavorAnimationsOnShoot;             // 0x07D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7DA[0x2];                                      // 0x07DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MovementSet3PInADS;                                // 0x07DC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDamageVariesForEachProjectiles;                   // 0x07E4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSecondaryIsADS;                                   // 0x07E5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E6[0x2];                                      // 0x07E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZoomFactorInADS;                                   // 0x07E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomInterpolationTimeIn;                           // 0x07EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomInterpolationTimeOut;                          // 0x07F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ZoomModifierName;                                  // 0x07F4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bZoomAffects3P;                                    // 0x07FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bZoomRequests1P;                                   // 0x07FD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7FE[0x2];                                      // 0x07FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ADSDelay;                                          // 0x0800(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ADSMinDuration;                                    // 0x0804(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSwapSensitivityInAds;                             // 0x0808(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStopADSOnShootingBlocked;                         // 0x0809(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowSecondaryADSWeaponQueueWhenBlocked;          // 0x080A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTriggersDangerOnFire;                             // 0x080B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTriggersDangerOnImpact;                           // 0x080C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_80D[0x3];                                      // 0x080D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDamageBehavior>                DamageBehaviors;                                   // 0x0810(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   DefaultDamageBehaviorName;                         // 0x0820(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMeshComponent*>                 HideInADSMesh;                                     // 0x0828(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       ADSWidgetComponent;                                // 0x0838(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayResourcesComponent*            GameplayResourceComponent;                         // 0x0840(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ADamageNumber>              DebugNumberClass;                                  // 0x0848(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class UObject*>                          DamageOutputModifiers;                             // 0x0850(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_8A0[0x4C];                                     // 0x08A0(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	EWeaponAmmoState                              AmmoState;                                         // 0x08EC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8ED[0x1F];                                     // 0x08ED(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReplicatedAmmoCount;                               // 0x090C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static bool GetBurstInfoForWeaponClass(class UClass* WeaponClass, int32* BurstPerShot, float* BurstShotDelay);
	static bool GetWeaponBalancingDataForClass(class UClass* WeaponClass, struct FProjectileWeaponBalancingData* Result);

	struct FDamageBehavior AddOrReplaceDamageBehavior(class FName BehaviorName);
	void BP_OnADSBegin();
	void BP_OnADSEnd();
	void BP_OnADSReached();
	void BP_OnBurstFirstShot(const struct FVector& ShotEndPoint, class AProjectileWeapon* Weapon);
	void BP_OnDryShotCycleBegin();
	void BP_OnDryShotCycleEnd();
	void BP_OnHitConfirmed(const struct FHitConfirmData& HitConfirmedData);
	void BP_OnLocalInstantReload();
	void BP_OnProjectileImpact(const struct FWeaponImpactData& WeaponImpactData);
	void BP_OnShotCycleBegin();
	void BP_OnShotCycleEnd();
	void BP_OnShotFired(const struct FVector& ShotEndPoint, class AProjectileWeapon* Weapon);
	float GetDelayBetweenShots();
	void HandleBooleanPlayerSettingChange(EPlayerSettingsType SettingType, bool NewValue);
	void HideADSMesh(bool bHideIn);
	void Multicast_HitConfirmed(const struct FHitConfirmData& HitConfirmedData);
	void MulticastFireMissingShot(const struct FVector_NetQuantize& DestinationPos);
	void MulticastFireShot(const struct FVector_NetQuantize& DestinationPos);
	void MulticastReleaseTrigger(const struct FVector_NetQuantize& OriginPos, const struct FVector_NetQuantize& DestinationPos);
	void MulticastReload();
	void NetMulticast_FillUpMagazine();
	void OnAutoReloadTimerEnd();
	void OnBlockADSTimerEnd();
	void OnBlockLeftHandWhileShootingTimerEnd();
	void OnBlockShotsBySecondaryTimerEnd();
	void OnConsumedAmmoRecentlyTimerEnd();
	void OnDisabledForADurationTimerEnd();
	void OnDisarmedChange(bool bDisarmed);
	void OnKillCamDelayedADSTimerEnd();
	void OnRep_ADSPressed(bool PrevADSPressed);
	void OnRep_ClientAmmoCount();
	void OnResourceChange(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 DeltaAmount);
	void OnResourceNewMaxAmount(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 MaxAmount);
	void OnResrouceNewAmount(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 Amount);
	void OnSpyOwnerRevived(class ASpy* SpyIn);
	void Server_ADSInputChange(bool bADSPressedIn);
	void ServerFireShot(const struct FVector_NetQuantize& OriginPos, const struct FVector_NetQuantize& DestinationPos);
	void ServerInformOfDirectHit(const struct FVector_NetQuantize& OriginPos, const struct FHitResult& Hit, float Damage, EHitType HitType, const struct FDamageContextData& DamageContext, class ASpawnerWeaponRound* HittingProjectile);
	void ServerReleaseTrigger(const struct FVector_NetQuantize& OriginPos, const struct FVector_NetQuantize& DestinationPos);
	void ServerReload();
	void SetDefaultDamageBehaviorName(class FName BehaviorName);
	void SetWeaponBuffs(float ReloadBuff, float ROFBuff);
	void UpdateRoF(float NewRoF);

	struct FVector GetAimedPosition() const;
	int32 GetBulletsInCurrentMagazine() const;
	float GetCooldownBeforeMelee() const;
	class FName GetDefaultDamageBehaviorName() const;
	struct FVector GetMuzzlePosition() const;
	int32 GetResourcesAtMaximumAmmo() const;
	int32 GetResourcesPerDispenserAmmoPack() const;
	int32 GetResourcesPerFullAmmoPack() const;
	bool GetWeaponBalancingData(struct FProjectileWeaponBalancingData* Result) const;
	bool HasDamageBehavior(class FName BehaviorName) const;
	bool IsClipEmpty() const;
	bool IsInADS() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileWeapon">();
	}
	static class AProjectileWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectileWeapon>();
	}
};
static_assert(alignof(AProjectileWeapon) == 0x000008, "Wrong alignment on AProjectileWeapon");
static_assert(sizeof(AProjectileWeapon) == 0x000910, "Wrong size on AProjectileWeapon");
static_assert(offsetof(AProjectileWeapon, OnShotFired) == 0x000530, "Member 'AProjectileWeapon::OnShotFired' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, OnBurstFirstShot) == 0x000540, "Member 'AProjectileWeapon::OnBurstFirstShot' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, OnShotCycleBegin) == 0x000550, "Member 'AProjectileWeapon::OnShotCycleBegin' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, OnShotCycleEnd) == 0x000560, "Member 'AProjectileWeapon::OnShotCycleEnd' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, OnDryShotCycleBegin) == 0x000570, "Member 'AProjectileWeapon::OnDryShotCycleBegin' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, OnDryShotCycleEnd) == 0x000580, "Member 'AProjectileWeapon::OnDryShotCycleEnd' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, OnReloadStart) == 0x000590, "Member 'AProjectileWeapon::OnReloadStart' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, OnInstantReload) == 0x0005A0, "Member 'AProjectileWeapon::OnInstantReload' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, OnLocalInstantReload) == 0x0005B0, "Member 'AProjectileWeapon::OnLocalInstantReload' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, OnProjectileImpact) == 0x0005C0, "Member 'AProjectileWeapon::OnProjectileImpact' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, OnHitConfirmed) == 0x0005D0, "Member 'AProjectileWeapon::OnHitConfirmed' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, OnServerHitConfirmed) == 0x0005E0, "Member 'AProjectileWeapon::OnServerHitConfirmed' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, OnADSChanged) == 0x0005F0, "Member 'AProjectileWeapon::OnADSChanged' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, OnFillUpMagazine) == 0x000600, "Member 'AProjectileWeapon::OnFillUpMagazine' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, OnResourceTypeChanged) == 0x000610, "Member 'AProjectileWeapon::OnResourceTypeChanged' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, OnResourceAmountChanged) == 0x000620, "Member 'AProjectileWeapon::OnResourceAmountChanged' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, OnWeaponDisabledChanged) == 0x000630, "Member 'AProjectileWeapon::OnWeaponDisabledChanged' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, OnAmmoCountRefreshed) == 0x000650, "Member 'AProjectileWeapon::OnAmmoCountRefreshed' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, ADSAimAssistConfig) == 0x000660, "Member 'AProjectileWeapon::ADSAimAssistConfig' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bADSPressed) == 0x00066C, "Member 'AProjectileWeapon::bADSPressed' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, Mesh1P) == 0x0006A0, "Member 'AProjectileWeapon::Mesh1P' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, Mesh3P) == 0x0006A8, "Member 'AProjectileWeapon::Mesh3P' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bForceMesh3pForMuzzle) == 0x0006B0, "Member 'AProjectileWeapon::bForceMesh3pForMuzzle' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, MuzzleSocketName) == 0x0006B4, "Member 'AProjectileWeapon::MuzzleSocketName' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bAttachRoundsToSpy) == 0x0006BC, "Member 'AProjectileWeapon::bAttachRoundsToSpy' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, MagazineSize) == 0x0006C0, "Member 'AProjectileWeapon::MagazineSize' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bUseAllAmmosAsMagazine) == 0x0006C4, "Member 'AProjectileWeapon::bUseAllAmmosAsMagazine' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, ResourcesSpentPerShot) == 0x0006C8, "Member 'AProjectileWeapon::ResourcesSpentPerShot' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, MaximumRateOfFire) == 0x0006CC, "Member 'AProjectileWeapon::MaximumRateOfFire' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, RateOfFireCurve) == 0x0006D0, "Member 'AProjectileWeapon::RateOfFireCurve' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, CurveEffectiveTime) == 0x0006D8, "Member 'AProjectileWeapon::CurveEffectiveTime' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, CurveNormalizedResetDuration) == 0x0006DC, "Member 'AProjectileWeapon::CurveNormalizedResetDuration' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, ReloadTime) == 0x0006E0, "Member 'AProjectileWeapon::ReloadTime' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bMakeReloadTimeSameAsFireRate) == 0x0006E4, "Member 'AProjectileWeapon::bMakeReloadTimeSameAsFireRate' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, EffectiveAimRange) == 0x0006E8, "Member 'AProjectileWeapon::EffectiveAimRange' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, FiringMode) == 0x0006EC, "Member 'AProjectileWeapon::FiringMode' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, ShotRequestedPerBurst) == 0x0006F0, "Member 'AProjectileWeapon::ShotRequestedPerBurst' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, ShotDelayAfterBurst) == 0x0006F4, "Member 'AProjectileWeapon::ShotDelayAfterBurst' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bAddShotDelayOnlyOnPrimaryEnd) == 0x0006F8, "Member 'AProjectileWeapon::bAddShotDelayOnlyOnPrimaryEnd' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, ResourcesPerFullAmmoPack) == 0x0006FC, "Member 'AProjectileWeapon::ResourcesPerFullAmmoPack' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, ResourcesPerDispenserAmmoPack) == 0x000700, "Member 'AProjectileWeapon::ResourcesPerDispenserAmmoPack' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, ResourcesAtMaximumAmmo) == 0x000704, "Member 'AProjectileWeapon::ResourcesAtMaximumAmmo' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bAutoReloadWhenEmpty) == 0x000708, "Member 'AProjectileWeapon::bAutoReloadWhenEmpty' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bStopADSOnReload) == 0x000709, "Member 'AProjectileWeapon::bStopADSOnReload' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bCanAutofireWithAccesibilitySetting) == 0x00070A, "Member 'AProjectileWeapon::bCanAutofireWithAccesibilitySetting' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bCanUseToggleADSSetting) == 0x00070B, "Member 'AProjectileWeapon::bCanUseToggleADSSetting' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bAutoReloadOnDryFire) == 0x00070C, "Member 'AProjectileWeapon::bAutoReloadOnDryFire' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, EarlyShotRequestTolerance) == 0x000710, "Member 'AProjectileWeapon::EarlyShotRequestTolerance' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bBlowCoverOnFire) == 0x000714, "Member 'AProjectileWeapon::bBlowCoverOnFire' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, CooldownBeforeMelee) == 0x000718, "Member 'AProjectileWeapon::CooldownBeforeMelee' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, EffectOnPawnHit) == 0x000720, "Member 'AProjectileWeapon::EffectOnPawnHit' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, EffectOnHitRefreshBehavior) == 0x000748, "Member 'AProjectileWeapon::EffectOnHitRefreshBehavior' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, DoEffectOnEnemyFactionOnly) == 0x000749, "Member 'AProjectileWeapon::DoEffectOnEnemyFactionOnly' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bHideWhenNoAmmoInMagazine) == 0x00074A, "Member 'AProjectileWeapon::bHideWhenNoAmmoInMagazine' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bAllowManualReload) == 0x00074B, "Member 'AProjectileWeapon::bAllowManualReload' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bHasRecoil) == 0x00074C, "Member 'AProjectileWeapon::bHasRecoil' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, RecoilStats) == 0x000750, "Member 'AProjectileWeapon::RecoilStats' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, RecoilADSStats) == 0x000780, "Member 'AProjectileWeapon::RecoilADSStats' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bFireBothWeaponOnFire) == 0x0007B0, "Member 'AProjectileWeapon::bFireBothWeaponOnFire' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bAlternateFireWithSecondaryWeapon) == 0x0007B1, "Member 'AProjectileWeapon::bAlternateFireWithSecondaryWeapon' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bADSShootWithSecondaryWeapon) == 0x0007B2, "Member 'AProjectileWeapon::bADSShootWithSecondaryWeapon' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bADSHitPlayerInstantReload) == 0x0007B3, "Member 'AProjectileWeapon::bADSHitPlayerInstantReload' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bADSUsesSecondaryWeaponFireMode) == 0x0007B4, "Member 'AProjectileWeapon::bADSUsesSecondaryWeaponFireMode' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bHideWeaponWhenSwappingToSecondary) == 0x0007B5, "Member 'AProjectileWeapon::bHideWeaponWhenSwappingToSecondary' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bHideToolOnSwitchToIfInADS) == 0x0007B6, "Member 'AProjectileWeapon::bHideToolOnSwitchToIfInADS' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bSecondaryUseOwnClip) == 0x0007B7, "Member 'AProjectileWeapon::bSecondaryUseOwnClip' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bUseMainWeaponForMuzzle) == 0x0007B8, "Member 'AProjectileWeapon::bUseMainWeaponForMuzzle' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, LowAmmoAmount) == 0x0007BC, "Member 'AProjectileWeapon::LowAmmoAmount' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, AutoReloadRateOfFireRatio) == 0x0007C0, "Member 'AProjectileWeapon::AutoReloadRateOfFireRatio' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, OverwriteBlockShootingAfterMelee) == 0x0007C4, "Member 'AProjectileWeapon::OverwriteBlockShootingAfterMelee' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, OverwriteBlockShootingAfterMeleeChargeLevel) == 0x0007C8, "Member 'AProjectileWeapon::OverwriteBlockShootingAfterMeleeChargeLevel' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bBlockLeftHandFlavorAnimationsOnReload) == 0x0007D8, "Member 'AProjectileWeapon::bBlockLeftHandFlavorAnimationsOnReload' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bBlockLeftHandFlavorAnimationsOnShoot) == 0x0007D9, "Member 'AProjectileWeapon::bBlockLeftHandFlavorAnimationsOnShoot' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, MovementSet3PInADS) == 0x0007DC, "Member 'AProjectileWeapon::MovementSet3PInADS' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bDamageVariesForEachProjectiles) == 0x0007E4, "Member 'AProjectileWeapon::bDamageVariesForEachProjectiles' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bSecondaryIsADS) == 0x0007E5, "Member 'AProjectileWeapon::bSecondaryIsADS' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, ZoomFactorInADS) == 0x0007E8, "Member 'AProjectileWeapon::ZoomFactorInADS' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, ZoomInterpolationTimeIn) == 0x0007EC, "Member 'AProjectileWeapon::ZoomInterpolationTimeIn' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, ZoomInterpolationTimeOut) == 0x0007F0, "Member 'AProjectileWeapon::ZoomInterpolationTimeOut' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, ZoomModifierName) == 0x0007F4, "Member 'AProjectileWeapon::ZoomModifierName' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bZoomAffects3P) == 0x0007FC, "Member 'AProjectileWeapon::bZoomAffects3P' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bZoomRequests1P) == 0x0007FD, "Member 'AProjectileWeapon::bZoomRequests1P' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, ADSDelay) == 0x000800, "Member 'AProjectileWeapon::ADSDelay' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, ADSMinDuration) == 0x000804, "Member 'AProjectileWeapon::ADSMinDuration' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bSwapSensitivityInAds) == 0x000808, "Member 'AProjectileWeapon::bSwapSensitivityInAds' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bStopADSOnShootingBlocked) == 0x000809, "Member 'AProjectileWeapon::bStopADSOnShootingBlocked' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bAllowSecondaryADSWeaponQueueWhenBlocked) == 0x00080A, "Member 'AProjectileWeapon::bAllowSecondaryADSWeaponQueueWhenBlocked' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bTriggersDangerOnFire) == 0x00080B, "Member 'AProjectileWeapon::bTriggersDangerOnFire' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, bTriggersDangerOnImpact) == 0x00080C, "Member 'AProjectileWeapon::bTriggersDangerOnImpact' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, DamageBehaviors) == 0x000810, "Member 'AProjectileWeapon::DamageBehaviors' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, DefaultDamageBehaviorName) == 0x000820, "Member 'AProjectileWeapon::DefaultDamageBehaviorName' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, HideInADSMesh) == 0x000828, "Member 'AProjectileWeapon::HideInADSMesh' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, ADSWidgetComponent) == 0x000838, "Member 'AProjectileWeapon::ADSWidgetComponent' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, GameplayResourceComponent) == 0x000840, "Member 'AProjectileWeapon::GameplayResourceComponent' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, DebugNumberClass) == 0x000848, "Member 'AProjectileWeapon::DebugNumberClass' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, DamageOutputModifiers) == 0x000850, "Member 'AProjectileWeapon::DamageOutputModifiers' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, AmmoState) == 0x0008EC, "Member 'AProjectileWeapon::AmmoState' has a wrong offset!");
static_assert(offsetof(AProjectileWeapon, ReplicatedAmmoCount) == 0x00090C, "Member 'AProjectileWeapon::ReplicatedAmmoCount' has a wrong offset!");

// Class DeceiveInc.PosingSpy
// 0x00F0 (0x0310 - 0x0220)
class APosingSpy final : public AActor
{
public:
	class UAnimSequence*                          DefaultMenuAnimation;                              // 0x0220(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              CustomSkin_Class;                                  // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayIndex;                                      // 0x0230(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        DisplayAgentId;                                    // 0x0234(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        DisplayWrapId;                                     // 0x0244(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationAsset*                        ResultOutroDriver;                                 // 0x0260(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAnimationPropData>             ResultOutroDriverProps;                            // 0x0268(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UAnimationAsset*                        ResultOutroPassenger;                              // 0x0278(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAnimationPropData>             ResultOutroPassengerProps;                         // 0x0280(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UAnimationAsset*                        ResultOutroBackseat;                               // 0x0290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAnimationPropData>             ResultOutroBackseatProps;                          // 0x0298(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         AnimationProps;                                    // 0x02A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class AActor*>              NamedAnimationProps;                               // 0x02B8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearAnimationProps();
	void CreateAnimationProp(const struct FAnimationPropData& PropIn, bool bLooping);
	void CreateAnimationProps(const TArray<struct FAnimationPropData>& PropsIn, bool bLooping);
	void DestroyAnimationProp(class FName NameID);
	void NotifyCharacterSelected();
	void NotifyHideWeaponWraps();
	void NotifyIntroPoseAnimationLooped();
	void NotifyIntroPoseAnimationStart(class UAgentIntroPoseDataAsset* IntroPose);
	void NotifyShowWeaponWraps();
	void OnCharacterSelected();
	void OnHideWeaponWraps();
	void OnShowWeaponWraps();
	void ShowWeapon(bool bShow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PosingSpy">();
	}
	static class APosingSpy* GetDefaultObj()
	{
		return GetDefaultObjImpl<APosingSpy>();
	}
};
static_assert(alignof(APosingSpy) == 0x000008, "Wrong alignment on APosingSpy");
static_assert(sizeof(APosingSpy) == 0x000310, "Wrong size on APosingSpy");
static_assert(offsetof(APosingSpy, DefaultMenuAnimation) == 0x000220, "Member 'APosingSpy::DefaultMenuAnimation' has a wrong offset!");
static_assert(offsetof(APosingSpy, CustomSkin_Class) == 0x000228, "Member 'APosingSpy::CustomSkin_Class' has a wrong offset!");
static_assert(offsetof(APosingSpy, DisplayIndex) == 0x000230, "Member 'APosingSpy::DisplayIndex' has a wrong offset!");
static_assert(offsetof(APosingSpy, DisplayAgentId) == 0x000234, "Member 'APosingSpy::DisplayAgentId' has a wrong offset!");
static_assert(offsetof(APosingSpy, DisplayWrapId) == 0x000244, "Member 'APosingSpy::DisplayWrapId' has a wrong offset!");
static_assert(offsetof(APosingSpy, Mesh) == 0x000258, "Member 'APosingSpy::Mesh' has a wrong offset!");
static_assert(offsetof(APosingSpy, ResultOutroDriver) == 0x000260, "Member 'APosingSpy::ResultOutroDriver' has a wrong offset!");
static_assert(offsetof(APosingSpy, ResultOutroDriverProps) == 0x000268, "Member 'APosingSpy::ResultOutroDriverProps' has a wrong offset!");
static_assert(offsetof(APosingSpy, ResultOutroPassenger) == 0x000278, "Member 'APosingSpy::ResultOutroPassenger' has a wrong offset!");
static_assert(offsetof(APosingSpy, ResultOutroPassengerProps) == 0x000280, "Member 'APosingSpy::ResultOutroPassengerProps' has a wrong offset!");
static_assert(offsetof(APosingSpy, ResultOutroBackseat) == 0x000290, "Member 'APosingSpy::ResultOutroBackseat' has a wrong offset!");
static_assert(offsetof(APosingSpy, ResultOutroBackseatProps) == 0x000298, "Member 'APosingSpy::ResultOutroBackseatProps' has a wrong offset!");
static_assert(offsetof(APosingSpy, AnimationProps) == 0x0002A8, "Member 'APosingSpy::AnimationProps' has a wrong offset!");
static_assert(offsetof(APosingSpy, NamedAnimationProps) == 0x0002B8, "Member 'APosingSpy::NamedAnimationProps' has a wrong offset!");

// Class DeceiveInc.SpawnerWeapon
// 0x00F0 (0x0A00 - 0x0910)
class ASpawnerWeapon : public AProjectileWeapon
{
public:
	uint8                                         Pad_910[0x8];                                      // 0x0910(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnProjectileSpawnAndActivate;                      // 0x0918(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnProjectileReleased;                              // 0x0928(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnProjectilesReleased;                             // 0x0938(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnProjectilesAbort;                                // 0x0948(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnShowProjectiles;                                 // 0x0958(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnSwitchedAmmo;                                    // 0x0968(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class FName                                   ProjectileSocketName;                              // 0x0978(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWeaponSprayDataAsset*                  SplitSprayData;                                    // 0x0980(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   DefaultFireShotClass;                              // 0x0988(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTriggersDangerOnRelease;                          // 0x09B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlowCoverOnRelease;                               // 0x09B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9B2[0x6];                                      // 0x09B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   CurrentFireShotClass;                              // 0x09B8(0x0028)(BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9E0[0x18];                                     // 0x09E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ASpawnerWeaponRound*                    LastProjectileFired;                               // 0x09F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void NetMulticast_SwitchRound(class UClass* NewFireShotClass, EGameplayResourcesType NewRoundResource);
	void OnCheckBreadcrumbTickTimerEnd();
	void OnISTTimerEnd();
	void OnRetrySPACOTimerEnd(const struct FVector& Pos);
	void Server_NotifyProjectileReleased();
	void Server_SpawnOnHitActor(class UClass* ActorToSpawnClass, const struct FHitResult& HitResult, const struct FVector& HitDirection);
	void Server_SwitchRound(class UClass* NewFireShotClass, EGameplayResourcesType NewRoundResource);
	void ShowProjectile();

	class ASpawnerWeaponRound* GetHeldProjectile() const;
	bool HasHeldProjectile() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerWeapon">();
	}
	static class ASpawnerWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpawnerWeapon>();
	}
};
static_assert(alignof(ASpawnerWeapon) == 0x000008, "Wrong alignment on ASpawnerWeapon");
static_assert(sizeof(ASpawnerWeapon) == 0x000A00, "Wrong size on ASpawnerWeapon");
static_assert(offsetof(ASpawnerWeapon, OnProjectileSpawnAndActivate) == 0x000918, "Member 'ASpawnerWeapon::OnProjectileSpawnAndActivate' has a wrong offset!");
static_assert(offsetof(ASpawnerWeapon, OnProjectileReleased) == 0x000928, "Member 'ASpawnerWeapon::OnProjectileReleased' has a wrong offset!");
static_assert(offsetof(ASpawnerWeapon, OnProjectilesReleased) == 0x000938, "Member 'ASpawnerWeapon::OnProjectilesReleased' has a wrong offset!");
static_assert(offsetof(ASpawnerWeapon, OnProjectilesAbort) == 0x000948, "Member 'ASpawnerWeapon::OnProjectilesAbort' has a wrong offset!");
static_assert(offsetof(ASpawnerWeapon, OnShowProjectiles) == 0x000958, "Member 'ASpawnerWeapon::OnShowProjectiles' has a wrong offset!");
static_assert(offsetof(ASpawnerWeapon, OnSwitchedAmmo) == 0x000968, "Member 'ASpawnerWeapon::OnSwitchedAmmo' has a wrong offset!");
static_assert(offsetof(ASpawnerWeapon, ProjectileSocketName) == 0x000978, "Member 'ASpawnerWeapon::ProjectileSocketName' has a wrong offset!");
static_assert(offsetof(ASpawnerWeapon, SplitSprayData) == 0x000980, "Member 'ASpawnerWeapon::SplitSprayData' has a wrong offset!");
static_assert(offsetof(ASpawnerWeapon, DefaultFireShotClass) == 0x000988, "Member 'ASpawnerWeapon::DefaultFireShotClass' has a wrong offset!");
static_assert(offsetof(ASpawnerWeapon, bTriggersDangerOnRelease) == 0x0009B0, "Member 'ASpawnerWeapon::bTriggersDangerOnRelease' has a wrong offset!");
static_assert(offsetof(ASpawnerWeapon, bBlowCoverOnRelease) == 0x0009B1, "Member 'ASpawnerWeapon::bBlowCoverOnRelease' has a wrong offset!");
static_assert(offsetof(ASpawnerWeapon, CurrentFireShotClass) == 0x0009B8, "Member 'ASpawnerWeapon::CurrentFireShotClass' has a wrong offset!");
static_assert(offsetof(ASpawnerWeapon, LastProjectileFired) == 0x0009F8, "Member 'ASpawnerWeapon::LastProjectileFired' has a wrong offset!");

// Class DeceiveInc.ChargeSpawnerWeapon
// 0x0068 (0x0A68 - 0x0A00)
class AChargeSpawnerWeapon : public ASpawnerWeapon
{
public:
	FMulticastInlineDelegateProperty_             OnChargeChanged;                                   // 0x0A00(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFullyChargeChanged;                              // 0x0A10(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         FullyChargeMinTime;                                // 0x0A20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FChargeStateInfo                       ChargeInfo;                                        // 0x0A24(0x0002)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsFullyCharged;                                   // 0x0A26(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A27[0x9];                                      // 0x0A27(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bADSToCharge;                                      // 0x0A30(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStopChargeOnADS;                                  // 0x0A31(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceADSOnPrimaryInput;                           // 0x0A32(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlwaysSpawnProjectileOnStartCharging;             // 0x0A33(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChargeTimeDelay;                                   // 0x0A34(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bResetDelayIfNoShotWasFired;                       // 0x0A38(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A39[0x3];                                      // 0x0A39(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NoChargeAfterShotDelay;                            // 0x0A3C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanStartChargingOnReloadComplete;                 // 0x0A40(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A41[0x27];                                     // 0x0A41(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool GetChargedSpawnerWeaponBalancingDataForClass(class UClass* WeaponClass, struct FSpawnerWeaponBalancingData* Result);

	float GetChargeRatio();
	bool IsFullyCharged();
	void OnBlockChargingTimerEnd();
	void OnKillCamDelayedChargingTimerEnd();
	void OnMainWeaponADSChanged(bool bInADS);
	void OnRep_IsCharging(const struct FChargeStateInfo& PrevInfo);
	void OnRep_IsFullyCharged(bool bPrevIsCharging);
	void Server_StartCharging();
	void Server_StopCharging(bool bIsCancel);

	bool GetChargedSpawnerWeaponBalancingData(struct FSpawnerWeaponBalancingData* Result) const;
	bool IsCharging() const;
	float TimeLeftToFullyCharged() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeSpawnerWeapon">();
	}
	static class AChargeSpawnerWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChargeSpawnerWeapon>();
	}
};
static_assert(alignof(AChargeSpawnerWeapon) == 0x000008, "Wrong alignment on AChargeSpawnerWeapon");
static_assert(sizeof(AChargeSpawnerWeapon) == 0x000A68, "Wrong size on AChargeSpawnerWeapon");
static_assert(offsetof(AChargeSpawnerWeapon, OnChargeChanged) == 0x000A00, "Member 'AChargeSpawnerWeapon::OnChargeChanged' has a wrong offset!");
static_assert(offsetof(AChargeSpawnerWeapon, OnFullyChargeChanged) == 0x000A10, "Member 'AChargeSpawnerWeapon::OnFullyChargeChanged' has a wrong offset!");
static_assert(offsetof(AChargeSpawnerWeapon, FullyChargeMinTime) == 0x000A20, "Member 'AChargeSpawnerWeapon::FullyChargeMinTime' has a wrong offset!");
static_assert(offsetof(AChargeSpawnerWeapon, ChargeInfo) == 0x000A24, "Member 'AChargeSpawnerWeapon::ChargeInfo' has a wrong offset!");
static_assert(offsetof(AChargeSpawnerWeapon, bIsFullyCharged) == 0x000A26, "Member 'AChargeSpawnerWeapon::bIsFullyCharged' has a wrong offset!");
static_assert(offsetof(AChargeSpawnerWeapon, bADSToCharge) == 0x000A30, "Member 'AChargeSpawnerWeapon::bADSToCharge' has a wrong offset!");
static_assert(offsetof(AChargeSpawnerWeapon, bStopChargeOnADS) == 0x000A31, "Member 'AChargeSpawnerWeapon::bStopChargeOnADS' has a wrong offset!");
static_assert(offsetof(AChargeSpawnerWeapon, bForceADSOnPrimaryInput) == 0x000A32, "Member 'AChargeSpawnerWeapon::bForceADSOnPrimaryInput' has a wrong offset!");
static_assert(offsetof(AChargeSpawnerWeapon, bAlwaysSpawnProjectileOnStartCharging) == 0x000A33, "Member 'AChargeSpawnerWeapon::bAlwaysSpawnProjectileOnStartCharging' has a wrong offset!");
static_assert(offsetof(AChargeSpawnerWeapon, ChargeTimeDelay) == 0x000A34, "Member 'AChargeSpawnerWeapon::ChargeTimeDelay' has a wrong offset!");
static_assert(offsetof(AChargeSpawnerWeapon, bResetDelayIfNoShotWasFired) == 0x000A38, "Member 'AChargeSpawnerWeapon::bResetDelayIfNoShotWasFired' has a wrong offset!");
static_assert(offsetof(AChargeSpawnerWeapon, NoChargeAfterShotDelay) == 0x000A3C, "Member 'AChargeSpawnerWeapon::NoChargeAfterShotDelay' has a wrong offset!");
static_assert(offsetof(AChargeSpawnerWeapon, bCanStartChargingOnReloadComplete) == 0x000A40, "Member 'AChargeSpawnerWeapon::bCanStartChargingOnReloadComplete' has a wrong offset!");

// Class DeceiveInc.ProjectileSpawnedActorInterface
// 0x0000 (0x0028 - 0x0028)
class IProjectileSpawnedActorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileSpawnedActorInterface">();
	}
	static class IProjectileSpawnedActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IProjectileSpawnedActorInterface>();
	}
};
static_assert(alignof(IProjectileSpawnedActorInterface) == 0x000008, "Wrong alignment on IProjectileSpawnedActorInterface");
static_assert(sizeof(IProjectileSpawnedActorInterface) == 0x000028, "Wrong size on IProjectileSpawnedActorInterface");

// Class DeceiveInc.RewardBundleDataAsset
// 0x0010 (0x0048 - 0x0038)
class URewardBundleDataAsset final : public UDIPrimaryDataAsset
{
public:
	TArray<struct FRewardBundleInfo>              RewardBundleInfo;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	struct FRewardBundleInfo GetBundleForAssetData(class UDIPrimaryDataAsset* DataAsset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RewardBundleDataAsset">();
	}
	static class URewardBundleDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URewardBundleDataAsset>();
	}
};
static_assert(alignof(URewardBundleDataAsset) == 0x000008, "Wrong alignment on URewardBundleDataAsset");
static_assert(sizeof(URewardBundleDataAsset) == 0x000048, "Wrong size on URewardBundleDataAsset");
static_assert(offsetof(URewardBundleDataAsset, RewardBundleInfo) == 0x000038, "Member 'URewardBundleDataAsset::RewardBundleInfo' has a wrong offset!");

// Class DeceiveInc.ChavezActiveAbilityMod2
// 0x0040 (0x05D0 - 0x0590)
class AChavezActiveAbilityMod2 final : public ABaseSpyActiveAbility
{
public:
	float                                         TriggerDelay;                                      // 0x0590(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_594[0x4];                                      // 0x0594(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ShieldZoneClass;                                   // 0x0598(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 ShieldZoneInstance;                                // 0x05C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C8[0x8];                                      // 0x05C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTriggerDelayTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChavezActiveAbilityMod2">();
	}
	static class AChavezActiveAbilityMod2* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChavezActiveAbilityMod2>();
	}
};
static_assert(alignof(AChavezActiveAbilityMod2) == 0x000008, "Wrong alignment on AChavezActiveAbilityMod2");
static_assert(sizeof(AChavezActiveAbilityMod2) == 0x0005D0, "Wrong size on AChavezActiveAbilityMod2");
static_assert(offsetof(AChavezActiveAbilityMod2, TriggerDelay) == 0x000590, "Member 'AChavezActiveAbilityMod2::TriggerDelay' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod2, ShieldZoneClass) == 0x000598, "Member 'AChavezActiveAbilityMod2::ShieldZoneClass' has a wrong offset!");
static_assert(offsetof(AChavezActiveAbilityMod2, ShieldZoneInstance) == 0x0005C0, "Member 'AChavezActiveAbilityMod2::ShieldZoneInstance' has a wrong offset!");

// Class DeceiveInc.RemoteTurretAIComponent
// 0x01E8 (0x0298 - 0x00B0)
class URemoteTurretAIComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnStateChange;                                     // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAggroTargetChange;                               // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAggroTargetLost;                                 // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShotCycleBegin;                                  // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShotCycleEnd;                                    // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         TimeToDeploy;                                      // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToCharge;                                      // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FireRateInterval;                                  // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HittingShotInterval;                               // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurretRotationSpeed;                               // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurretGiveUpTime;                                  // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MissingShotOffset;                                 // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERemoteTurretAIState                          TurretState;                                       // 0x011C(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCheckLoSComponent*                     LoSComponent;                                      // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHitscanWeapon*                         ProjectileWeapon;                                  // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 AggroTarget;                                       // 0x0130(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_138[0x20];                                     // 0x0138(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReplicatedTarget;                                  // 0x0158(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0x138];                                    // 0x0160(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnShotCycleBegin();
	void BP_OnShotCycleEnd();
	void OnRep_NewTurretAState(ERemoteTurretAIState OldState);
	void OnRep_Target();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemoteTurretAIComponent">();
	}
	static class URemoteTurretAIComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemoteTurretAIComponent>();
	}
};
static_assert(alignof(URemoteTurretAIComponent) == 0x000008, "Wrong alignment on URemoteTurretAIComponent");
static_assert(sizeof(URemoteTurretAIComponent) == 0x000298, "Wrong size on URemoteTurretAIComponent");
static_assert(offsetof(URemoteTurretAIComponent, OnStateChange) == 0x0000B0, "Member 'URemoteTurretAIComponent::OnStateChange' has a wrong offset!");
static_assert(offsetof(URemoteTurretAIComponent, OnAggroTargetChange) == 0x0000C0, "Member 'URemoteTurretAIComponent::OnAggroTargetChange' has a wrong offset!");
static_assert(offsetof(URemoteTurretAIComponent, OnAggroTargetLost) == 0x0000D0, "Member 'URemoteTurretAIComponent::OnAggroTargetLost' has a wrong offset!");
static_assert(offsetof(URemoteTurretAIComponent, OnShotCycleBegin) == 0x0000E0, "Member 'URemoteTurretAIComponent::OnShotCycleBegin' has a wrong offset!");
static_assert(offsetof(URemoteTurretAIComponent, OnShotCycleEnd) == 0x0000F0, "Member 'URemoteTurretAIComponent::OnShotCycleEnd' has a wrong offset!");
static_assert(offsetof(URemoteTurretAIComponent, TimeToDeploy) == 0x000100, "Member 'URemoteTurretAIComponent::TimeToDeploy' has a wrong offset!");
static_assert(offsetof(URemoteTurretAIComponent, TimeToCharge) == 0x000104, "Member 'URemoteTurretAIComponent::TimeToCharge' has a wrong offset!");
static_assert(offsetof(URemoteTurretAIComponent, FireRateInterval) == 0x000108, "Member 'URemoteTurretAIComponent::FireRateInterval' has a wrong offset!");
static_assert(offsetof(URemoteTurretAIComponent, HittingShotInterval) == 0x00010C, "Member 'URemoteTurretAIComponent::HittingShotInterval' has a wrong offset!");
static_assert(offsetof(URemoteTurretAIComponent, TurretRotationSpeed) == 0x000110, "Member 'URemoteTurretAIComponent::TurretRotationSpeed' has a wrong offset!");
static_assert(offsetof(URemoteTurretAIComponent, TurretGiveUpTime) == 0x000114, "Member 'URemoteTurretAIComponent::TurretGiveUpTime' has a wrong offset!");
static_assert(offsetof(URemoteTurretAIComponent, MissingShotOffset) == 0x000118, "Member 'URemoteTurretAIComponent::MissingShotOffset' has a wrong offset!");
static_assert(offsetof(URemoteTurretAIComponent, TurretState) == 0x00011C, "Member 'URemoteTurretAIComponent::TurretState' has a wrong offset!");
static_assert(offsetof(URemoteTurretAIComponent, LoSComponent) == 0x000120, "Member 'URemoteTurretAIComponent::LoSComponent' has a wrong offset!");
static_assert(offsetof(URemoteTurretAIComponent, ProjectileWeapon) == 0x000128, "Member 'URemoteTurretAIComponent::ProjectileWeapon' has a wrong offset!");
static_assert(offsetof(URemoteTurretAIComponent, AggroTarget) == 0x000130, "Member 'URemoteTurretAIComponent::AggroTarget' has a wrong offset!");
static_assert(offsetof(URemoteTurretAIComponent, ReplicatedTarget) == 0x000158, "Member 'URemoteTurretAIComponent::ReplicatedTarget' has a wrong offset!");

// Class DeceiveInc.ChavezPassiveAbility
// 0x0068 (0x0598 - 0x0530)
class AChavezPassiveAbility final : public ABaseSpyPassiveAbility
{
public:
	FMulticastInlineDelegateProperty_             OnDamageTaken;                                     // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRegenStarted;                                    // 0x0540(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRegenFinished;                                   // 0x0550(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         DamageHealingRatio;                                // 0x0560(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageHealingCapRatio;                             // 0x0564(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealingDuration;                                   // 0x0568(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealingDelay;                                      // 0x056C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealingRatio;                                      // 0x0570(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_574[0x4];                                      // 0x0574(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHealthComponent*                       HealthComponent;                                   // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetHealth;                                      // 0x0580(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_584[0x14];                                     // 0x0584(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MulticastDamageTaken(class ASpy* Spy);
	void MulticastRegenCompleted(class ASpy* Spy);
	void MulticastRegenStarted(class ASpy* Spy);
	void OnHealthChanged(class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, float RawDamage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChavezPassiveAbility">();
	}
	static class AChavezPassiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChavezPassiveAbility>();
	}
};
static_assert(alignof(AChavezPassiveAbility) == 0x000008, "Wrong alignment on AChavezPassiveAbility");
static_assert(sizeof(AChavezPassiveAbility) == 0x000598, "Wrong size on AChavezPassiveAbility");
static_assert(offsetof(AChavezPassiveAbility, OnDamageTaken) == 0x000530, "Member 'AChavezPassiveAbility::OnDamageTaken' has a wrong offset!");
static_assert(offsetof(AChavezPassiveAbility, OnRegenStarted) == 0x000540, "Member 'AChavezPassiveAbility::OnRegenStarted' has a wrong offset!");
static_assert(offsetof(AChavezPassiveAbility, OnRegenFinished) == 0x000550, "Member 'AChavezPassiveAbility::OnRegenFinished' has a wrong offset!");
static_assert(offsetof(AChavezPassiveAbility, DamageHealingRatio) == 0x000560, "Member 'AChavezPassiveAbility::DamageHealingRatio' has a wrong offset!");
static_assert(offsetof(AChavezPassiveAbility, DamageHealingCapRatio) == 0x000564, "Member 'AChavezPassiveAbility::DamageHealingCapRatio' has a wrong offset!");
static_assert(offsetof(AChavezPassiveAbility, HealingDuration) == 0x000568, "Member 'AChavezPassiveAbility::HealingDuration' has a wrong offset!");
static_assert(offsetof(AChavezPassiveAbility, HealingDelay) == 0x00056C, "Member 'AChavezPassiveAbility::HealingDelay' has a wrong offset!");
static_assert(offsetof(AChavezPassiveAbility, HealingRatio) == 0x000570, "Member 'AChavezPassiveAbility::HealingRatio' has a wrong offset!");
static_assert(offsetof(AChavezPassiveAbility, HealthComponent) == 0x000578, "Member 'AChavezPassiveAbility::HealthComponent' has a wrong offset!");
static_assert(offsetof(AChavezPassiveAbility, TargetHealth) == 0x000580, "Member 'AChavezPassiveAbility::TargetHealth' has a wrong offset!");

// Class DeceiveInc.ChavezPassiveAbilityMod1
// 0x0010 (0x0540 - 0x0530)
class AChavezPassiveAbilityMod1 final : public ABaseSpyPassiveAbility
{
public:
	float                                         MaxOverhealAmmount;                                // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealDecayDelay;                                    // 0x0534(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageDecayDelay;                                  // 0x0538(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecayRatio;                                        // 0x053C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChavezPassiveAbilityMod1">();
	}
	static class AChavezPassiveAbilityMod1* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChavezPassiveAbilityMod1>();
	}
};
static_assert(alignof(AChavezPassiveAbilityMod1) == 0x000008, "Wrong alignment on AChavezPassiveAbilityMod1");
static_assert(sizeof(AChavezPassiveAbilityMod1) == 0x000540, "Wrong size on AChavezPassiveAbilityMod1");
static_assert(offsetof(AChavezPassiveAbilityMod1, MaxOverhealAmmount) == 0x000530, "Member 'AChavezPassiveAbilityMod1::MaxOverhealAmmount' has a wrong offset!");
static_assert(offsetof(AChavezPassiveAbilityMod1, HealDecayDelay) == 0x000534, "Member 'AChavezPassiveAbilityMod1::HealDecayDelay' has a wrong offset!");
static_assert(offsetof(AChavezPassiveAbilityMod1, DamageDecayDelay) == 0x000538, "Member 'AChavezPassiveAbilityMod1::DamageDecayDelay' has a wrong offset!");
static_assert(offsetof(AChavezPassiveAbilityMod1, DecayRatio) == 0x00053C, "Member 'AChavezPassiveAbilityMod1::DecayRatio' has a wrong offset!");

// Class DeceiveInc.PrivateLobbySubsystem
// 0x01E8 (0x0218 - 0x0030)
class UPrivateLobbySubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnPrivateLobbyGameModeChange;                      // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPrivateLobbyOperationChange;                     // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPrivateLobbyServerRegionChange;                  // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPrivateLobbySandboxModeChange;                   // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPrivateLobbyFillWithBotsChange;                  // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPrivateLobbyNPCPOpulationChange;                 // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPrivateLobbyObjectToSpawnCountChange;            // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHeatSettingsChange;                              // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBotsDifficultyChange;                            // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBotsAmountChange;                                // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPartyChange;                                     // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDIPrivateLobbyInfo                    PrivateLobbyInfo;                                  // 0x00E8(0x00C8)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class UMapData*                               OperationmapData;                                  // 0x01B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B8[0x60];                                     // 0x01B8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AutoselectBestServerRegion();
	void CancelPrivateLobbyMatchmaking();
	float GetLatencyForRegion(const class FString& Region);
	float GetLatencyForRegionIndex(int32 RegionIndex);
	void HandlePartyCreatedOrJoined();
	void HandlePartyUpdated();
	void HandlePlayerSettingChange(EPlayerSettingsType SettingChanged);
	void OnLobbyPartyDataUpdateRequested();
	void RandomizeTeams();
	void SetAllObjectsToSpawnCount(const TArray<struct FObjectToSpawnCount>& ObjectsToSpawnCount);
	void SetLobbyBotsAmount(int32 BotsAmount);
	void SetLobbyBotsDifficulty(EBotsDifficulty BotsDifficulty);
	void SetLobbyFillWithBots(bool bFillWithBots);
	void SetLobbyGameMode(EDIGameMode NewGameMode);
	void SetLobbyHeatSettings(const struct FHeatSetupData& HeatSettings);
	void SetLobbyOperationMap(class UMapData* NewOperationMapData);
	void SetLobbySandboxMode(bool bSandboxMode);
	void SetNPCPopulation(const TArray<int32>& NPCPopulation);
	void SetNPCPopulationByPool(int32 NPCPool, int32 NPCAmount);
	void SetObjectsToSpawnCount(const struct FObjectToSpawnCount& ObjectsToSpawnCount);
	void SetSelectedRegionIndex(int32 NewSelectedRegion);
	void StartPrivateLobbyMatchmaking();
	bool TrySetTeamForLocaPlayer(int32 TeamIndex);
	bool TrySetTeamForPlayer(class UDIOnlinePartyMemberInfo* Player, int32 TeamIndex);

	bool CanLocalPlayerEditLobbyData() const;
	TArray<class UDIOnlinePartyMemberInfo*> GetAssignedMembers() const;
	TArray<class UMapData*> GetAvailableOperationMaps() const;
	TArray<class FString> GetAvailableRegions() const;
	struct FHeatSetupData GetHeatSettings() const;
	EDIGameMode GetLobbyGameMode() const;
	class UMapData* GetLobbyOperationMap() const;
	TArray<int32> GetNPCPopulation() const;
	int32 GetNPCPopulationByType(int32 NPCPool) const;
	TArray<struct FObjectToSpawnCount> GetObjectsToSpawnCount() const;
	struct FObjectToSpawnCount GetObjectsToSpawnCountByObjectType(const class FString& ObjectType) const;
	TArray<class UDIOnlinePartyMemberInfo*> GetPartyMembers() const;
	TArray<class UDIOnlinePartyMemberInfo*> GetPartyMembersForTeam(int32 TeamIndex) const;
	class FString GetSelectedRegion() const;
	int32 GetSelectedRegionIndex() const;
	TArray<class UDIOnlinePartyMemberInfo*> GetSpectatingMembers() const;
	int32 GetTeamForPlayer(class UDIOnlinePartyMemberInfo* Player) const;
	TArray<class UDIOnlinePartyMemberInfo*> GetUnassignedMembers() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrivateLobbySubsystem">();
	}
	static class UPrivateLobbySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPrivateLobbySubsystem>();
	}
};
static_assert(alignof(UPrivateLobbySubsystem) == 0x000008, "Wrong alignment on UPrivateLobbySubsystem");
static_assert(sizeof(UPrivateLobbySubsystem) == 0x000218, "Wrong size on UPrivateLobbySubsystem");
static_assert(offsetof(UPrivateLobbySubsystem, OnPrivateLobbyGameModeChange) == 0x000030, "Member 'UPrivateLobbySubsystem::OnPrivateLobbyGameModeChange' has a wrong offset!");
static_assert(offsetof(UPrivateLobbySubsystem, OnPrivateLobbyOperationChange) == 0x000040, "Member 'UPrivateLobbySubsystem::OnPrivateLobbyOperationChange' has a wrong offset!");
static_assert(offsetof(UPrivateLobbySubsystem, OnPrivateLobbyServerRegionChange) == 0x000050, "Member 'UPrivateLobbySubsystem::OnPrivateLobbyServerRegionChange' has a wrong offset!");
static_assert(offsetof(UPrivateLobbySubsystem, OnPrivateLobbySandboxModeChange) == 0x000060, "Member 'UPrivateLobbySubsystem::OnPrivateLobbySandboxModeChange' has a wrong offset!");
static_assert(offsetof(UPrivateLobbySubsystem, OnPrivateLobbyFillWithBotsChange) == 0x000070, "Member 'UPrivateLobbySubsystem::OnPrivateLobbyFillWithBotsChange' has a wrong offset!");
static_assert(offsetof(UPrivateLobbySubsystem, OnPrivateLobbyNPCPOpulationChange) == 0x000080, "Member 'UPrivateLobbySubsystem::OnPrivateLobbyNPCPOpulationChange' has a wrong offset!");
static_assert(offsetof(UPrivateLobbySubsystem, OnPrivateLobbyObjectToSpawnCountChange) == 0x000090, "Member 'UPrivateLobbySubsystem::OnPrivateLobbyObjectToSpawnCountChange' has a wrong offset!");
static_assert(offsetof(UPrivateLobbySubsystem, OnHeatSettingsChange) == 0x0000A0, "Member 'UPrivateLobbySubsystem::OnHeatSettingsChange' has a wrong offset!");
static_assert(offsetof(UPrivateLobbySubsystem, OnBotsDifficultyChange) == 0x0000B0, "Member 'UPrivateLobbySubsystem::OnBotsDifficultyChange' has a wrong offset!");
static_assert(offsetof(UPrivateLobbySubsystem, OnBotsAmountChange) == 0x0000C0, "Member 'UPrivateLobbySubsystem::OnBotsAmountChange' has a wrong offset!");
static_assert(offsetof(UPrivateLobbySubsystem, OnPartyChange) == 0x0000D0, "Member 'UPrivateLobbySubsystem::OnPartyChange' has a wrong offset!");
static_assert(offsetof(UPrivateLobbySubsystem, PrivateLobbyInfo) == 0x0000E8, "Member 'UPrivateLobbySubsystem::PrivateLobbyInfo' has a wrong offset!");
static_assert(offsetof(UPrivateLobbySubsystem, OperationmapData) == 0x0001B0, "Member 'UPrivateLobbySubsystem::OperationmapData' has a wrong offset!");

// Class DeceiveInc.ChavezPassiveAbilityMod2
// 0x0050 (0x0580 - 0x0530)
class AChavezPassiveAbilityMod2 final : public ABaseSpyPassiveAbility
{
public:
	FMulticastInlineDelegateProperty_             OnDamageTaken;                                     // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHeal;                                            // 0x0540(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         DamageHealingRatio;                                // 0x0550(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageHealingCapRatio;                             // 0x0554(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealingRatioPerDamageDone;                         // 0x0558(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55C[0x4];                                      // 0x055C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHealthComponent*                       HealthComponent;                                   // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetHealth;                                      // 0x0568(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_56C[0x4];                                      // 0x056C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OwnerWeaponActor;                                  // 0x0570(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_578[0x8];                                      // 0x0578(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleConfirmedDamageDealt(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);
	void HandleHealthChanged(class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, float RawDamage);
	void MulticastDamageTaken(class ASpy* Spy);
	void MulticastHeal(float HealAmount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChavezPassiveAbilityMod2">();
	}
	static class AChavezPassiveAbilityMod2* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChavezPassiveAbilityMod2>();
	}
};
static_assert(alignof(AChavezPassiveAbilityMod2) == 0x000008, "Wrong alignment on AChavezPassiveAbilityMod2");
static_assert(sizeof(AChavezPassiveAbilityMod2) == 0x000580, "Wrong size on AChavezPassiveAbilityMod2");
static_assert(offsetof(AChavezPassiveAbilityMod2, OnDamageTaken) == 0x000530, "Member 'AChavezPassiveAbilityMod2::OnDamageTaken' has a wrong offset!");
static_assert(offsetof(AChavezPassiveAbilityMod2, OnHeal) == 0x000540, "Member 'AChavezPassiveAbilityMod2::OnHeal' has a wrong offset!");
static_assert(offsetof(AChavezPassiveAbilityMod2, DamageHealingRatio) == 0x000550, "Member 'AChavezPassiveAbilityMod2::DamageHealingRatio' has a wrong offset!");
static_assert(offsetof(AChavezPassiveAbilityMod2, DamageHealingCapRatio) == 0x000554, "Member 'AChavezPassiveAbilityMod2::DamageHealingCapRatio' has a wrong offset!");
static_assert(offsetof(AChavezPassiveAbilityMod2, HealingRatioPerDamageDone) == 0x000558, "Member 'AChavezPassiveAbilityMod2::HealingRatioPerDamageDone' has a wrong offset!");
static_assert(offsetof(AChavezPassiveAbilityMod2, HealthComponent) == 0x000560, "Member 'AChavezPassiveAbilityMod2::HealthComponent' has a wrong offset!");
static_assert(offsetof(AChavezPassiveAbilityMod2, TargetHealth) == 0x000568, "Member 'AChavezPassiveAbilityMod2::TargetHealth' has a wrong offset!");
static_assert(offsetof(AChavezPassiveAbilityMod2, OwnerWeaponActor) == 0x000570, "Member 'AChavezPassiveAbilityMod2::OwnerWeaponActor' has a wrong offset!");

// Class DeceiveInc.CheckLoSComponent
// 0x00A0 (0x0150 - 0x00B0)
class UCheckLoSComponent final : public UActorComponent
{
public:
	TMap<class AActor*, TWeakObjectPtr<class AActor>> ActiveLoS;                                         // 0x00B0(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class ASpy*                                   SpyOwner;                                          // 0x0100(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LoSDistance;                                       // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LoSMaxAngle;                                       // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         SpecificActorsToTrack;                             // 0x0110(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bTrackNPCs;                                        // 0x0120(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTrackSpies;                                       // 0x0121(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTrackAggroed;                                     // 0x0122(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTrackBots;                                        // 0x0123(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTrackTools;                                       // 0x0124(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ManualActorsToTrack;                               // 0x0128(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLoSChange;                                       // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheckLoSComponent">();
	}
	static class UCheckLoSComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheckLoSComponent>();
	}
};
static_assert(alignof(UCheckLoSComponent) == 0x000008, "Wrong alignment on UCheckLoSComponent");
static_assert(sizeof(UCheckLoSComponent) == 0x000150, "Wrong size on UCheckLoSComponent");
static_assert(offsetof(UCheckLoSComponent, ActiveLoS) == 0x0000B0, "Member 'UCheckLoSComponent::ActiveLoS' has a wrong offset!");
static_assert(offsetof(UCheckLoSComponent, SpyOwner) == 0x000100, "Member 'UCheckLoSComponent::SpyOwner' has a wrong offset!");
static_assert(offsetof(UCheckLoSComponent, LoSDistance) == 0x000108, "Member 'UCheckLoSComponent::LoSDistance' has a wrong offset!");
static_assert(offsetof(UCheckLoSComponent, LoSMaxAngle) == 0x00010C, "Member 'UCheckLoSComponent::LoSMaxAngle' has a wrong offset!");
static_assert(offsetof(UCheckLoSComponent, SpecificActorsToTrack) == 0x000110, "Member 'UCheckLoSComponent::SpecificActorsToTrack' has a wrong offset!");
static_assert(offsetof(UCheckLoSComponent, bTrackNPCs) == 0x000120, "Member 'UCheckLoSComponent::bTrackNPCs' has a wrong offset!");
static_assert(offsetof(UCheckLoSComponent, bTrackSpies) == 0x000121, "Member 'UCheckLoSComponent::bTrackSpies' has a wrong offset!");
static_assert(offsetof(UCheckLoSComponent, bTrackAggroed) == 0x000122, "Member 'UCheckLoSComponent::bTrackAggroed' has a wrong offset!");
static_assert(offsetof(UCheckLoSComponent, bTrackBots) == 0x000123, "Member 'UCheckLoSComponent::bTrackBots' has a wrong offset!");
static_assert(offsetof(UCheckLoSComponent, bTrackTools) == 0x000124, "Member 'UCheckLoSComponent::bTrackTools' has a wrong offset!");
static_assert(offsetof(UCheckLoSComponent, ManualActorsToTrack) == 0x000128, "Member 'UCheckLoSComponent::ManualActorsToTrack' has a wrong offset!");
static_assert(offsetof(UCheckLoSComponent, OnLoSChange) == 0x000138, "Member 'UCheckLoSComponent::OnLoSChange' has a wrong offset!");

// Class DeceiveInc.RevivePartyComponent
// 0x0010 (0x00E0 - 0x00D0)
class URevivePartyComponent final : public UBaseConditionComponent
{
public:
	int32                                         IntelCost;                                         // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractDuration;                                  // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	ERevivePartyFailedCause GetFailureCause();
	void HandleInteractionBegin(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void HandleInteractionCancel(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RevivePartyComponent">();
	}
	static class URevivePartyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URevivePartyComponent>();
	}
};
static_assert(alignof(URevivePartyComponent) == 0x000008, "Wrong alignment on URevivePartyComponent");
static_assert(sizeof(URevivePartyComponent) == 0x0000E0, "Wrong size on URevivePartyComponent");
static_assert(offsetof(URevivePartyComponent, IntelCost) == 0x0000D0, "Member 'URevivePartyComponent::IntelCost' has a wrong offset!");
static_assert(offsetof(URevivePartyComponent, InteractDuration) == 0x0000D4, "Member 'URevivePartyComponent::InteractDuration' has a wrong offset!");

// Class DeceiveInc.ChromaticFeedbackSubsystem
// 0x0340 (0x0370 - 0x0030)
class UChromaticFeedbackSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x338];                                     // 0x0030(0x0338)(Fixing Size After Last Property [ Dumper-7 ])
	class UDeceiveIncSettings*                    DeceiveIncSettings;                                // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddEffect(const class FString& EffectNameToPlay, EChromaticFeedbackPriority Priority, bool bLoop, bool bHighlightMappedKeys);
	void EnableChromaticFeedback(bool bEnable);
	void HandleAnimationStop();
	void HandleBooleanPlayerSettingChange(EPlayerSettingsType SettingType, bool NewValue);
	void RemoveEffect(const class FString& EffectNameToRemove, EChromaticFeedbackPriority Priority);
	void RemoveEffectAtPriority(EChromaticFeedbackPriority Priority);
	void StartEvent(EChromaFeedbackEventType EventType);
	void StopEvent(EChromaFeedbackEventType EventType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChromaticFeedbackSubsystem">();
	}
	static class UChromaticFeedbackSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChromaticFeedbackSubsystem>();
	}
};
static_assert(alignof(UChromaticFeedbackSubsystem) == 0x000008, "Wrong alignment on UChromaticFeedbackSubsystem");
static_assert(sizeof(UChromaticFeedbackSubsystem) == 0x000370, "Wrong size on UChromaticFeedbackSubsystem");
static_assert(offsetof(UChromaticFeedbackSubsystem, DeceiveIncSettings) == 0x000368, "Member 'UChromaticFeedbackSubsystem::DeceiveIncSettings' has a wrong offset!");

// Class DeceiveInc.ClientInformation
// 0x0000 (0x0028 - 0x0028)
class UClientInformation final : public UObject
{
public:
	static int32 GetBuildChangelist();
	static class FString GetBuildClientBranch();
	static class FString GetBuildVersion();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientInformation">();
	}
	static class UClientInformation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientInformation>();
	}
};
static_assert(alignof(UClientInformation) == 0x000008, "Wrong alignment on UClientInformation");
static_assert(sizeof(UClientInformation) == 0x000028, "Wrong size on UClientInformation");

// Class DeceiveInc.RoomNavArea_Base
// 0x0000 (0x0048 - 0x0048)
class URoomNavArea_Base : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoomNavArea_Base">();
	}
	static class URoomNavArea_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoomNavArea_Base>();
	}
};
static_assert(alignof(URoomNavArea_Base) == 0x000008, "Wrong alignment on URoomNavArea_Base");
static_assert(sizeof(URoomNavArea_Base) == 0x000048, "Wrong size on URoomNavArea_Base");

// Class DeceiveInc.RoomNavArea_VIP
// 0x0000 (0x0048 - 0x0048)
class URoomNavArea_VIP final : public URoomNavArea_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoomNavArea_VIP">();
	}
	static class URoomNavArea_VIP* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoomNavArea_VIP>();
	}
};
static_assert(alignof(URoomNavArea_VIP) == 0x000008, "Wrong alignment on URoomNavArea_VIP");
static_assert(sizeof(URoomNavArea_VIP) == 0x000048, "Wrong size on URoomNavArea_VIP");

// Class DeceiveInc.ConsumableData
// 0x0018 (0x0050 - 0x0038)
class UConsumableData final : public UDIPrimaryDataAsset
{
public:
	class FText                                   ConsumableName;                                    // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsumableData">();
	}
	static class UConsumableData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsumableData>();
	}
};
static_assert(alignof(UConsumableData) == 0x000008, "Wrong alignment on UConsumableData");
static_assert(sizeof(UConsumableData) == 0x000050, "Wrong size on UConsumableData");
static_assert(offsetof(UConsumableData, ConsumableName) == 0x000038, "Member 'UConsumableData::ConsumableName' has a wrong offset!");

// Class DeceiveInc.CooldownComponent
// 0x0038 (0x00E8 - 0x00B0)
class UCooldownComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x4];                                       // 0x00B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ServerCooldownEndTime;                             // 0x00B4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CooldownRefunded;                                  // 0x00B8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentReduction;                                  // 0x00BC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnIsOnCooldownChange;                              // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         CooldownDuration;                                  // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelCooldownMulticast();
	void OnRep_CooldownRefunded();
	void OnRep_ServerCooldownEndTime(float PreviousServerCooldownEndTime);

	float GetCooldownDuration() const;
	float GetCooldownRatio() const;
	float GetCooldownTimeLeft() const;
	bool IsOnCooldown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CooldownComponent">();
	}
	static class UCooldownComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCooldownComponent>();
	}
};
static_assert(alignof(UCooldownComponent) == 0x000008, "Wrong alignment on UCooldownComponent");
static_assert(sizeof(UCooldownComponent) == 0x0000E8, "Wrong size on UCooldownComponent");
static_assert(offsetof(UCooldownComponent, ServerCooldownEndTime) == 0x0000B4, "Member 'UCooldownComponent::ServerCooldownEndTime' has a wrong offset!");
static_assert(offsetof(UCooldownComponent, CooldownRefunded) == 0x0000B8, "Member 'UCooldownComponent::CooldownRefunded' has a wrong offset!");
static_assert(offsetof(UCooldownComponent, PercentReduction) == 0x0000BC, "Member 'UCooldownComponent::PercentReduction' has a wrong offset!");
static_assert(offsetof(UCooldownComponent, OnIsOnCooldownChange) == 0x0000D0, "Member 'UCooldownComponent::OnIsOnCooldownChange' has a wrong offset!");
static_assert(offsetof(UCooldownComponent, CooldownDuration) == 0x0000E0, "Member 'UCooldownComponent::CooldownDuration' has a wrong offset!");

// Class DeceiveInc.CooldownConditionComponent
// 0x0000 (0x00D0 - 0x00D0)
class UCooldownConditionComponent final : public UBaseConditionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CooldownConditionComponent">();
	}
	static class UCooldownConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCooldownConditionComponent>();
	}
};
static_assert(alignof(UCooldownConditionComponent) == 0x000008, "Wrong alignment on UCooldownConditionComponent");
static_assert(sizeof(UCooldownConditionComponent) == 0x0000D0, "Wrong size on UCooldownConditionComponent");

// Class DeceiveInc.ReplicatedDebugDraws
// 0x0000 (0x0220 - 0x0220)
class AReplicatedDebugDraws final : public AActor
{
public:
	void NetMulticast_DrawDebugAACross(const struct FVector& CrossCenter, float CrossSize, const struct FColor& Color, bool bPersistentLines, float Lifetime, uint8 DepthPriority, float Thickness);
	void NetMulticast_DrawDebugLine(const struct FVector& LineStart, const struct FVector& LineEnd, const struct FColor& Color, bool bPersistentLines, float Lifetime, uint8 DepthPriority, float Thickness);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplicatedDebugDraws">();
	}
	static class AReplicatedDebugDraws* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReplicatedDebugDraws>();
	}
};
static_assert(alignof(AReplicatedDebugDraws) == 0x000008, "Wrong alignment on AReplicatedDebugDraws");
static_assert(sizeof(AReplicatedDebugDraws) == 0x000220, "Wrong size on AReplicatedDebugDraws");

// Class DeceiveInc.CoverAffectingSourceDataAsset
// 0x0010 (0x0048 - 0x0038)
class UCoverAffectingSourceDataAsset final : public UDIPrimaryDataAsset
{
public:
	TArray<struct FCoverAffectingSourceInfo>      CoverAffectingSourceInfo;                          // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoverAffectingSourceDataAsset">();
	}
	static class UCoverAffectingSourceDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoverAffectingSourceDataAsset>();
	}
};
static_assert(alignof(UCoverAffectingSourceDataAsset) == 0x000008, "Wrong alignment on UCoverAffectingSourceDataAsset");
static_assert(sizeof(UCoverAffectingSourceDataAsset) == 0x000048, "Wrong size on UCoverAffectingSourceDataAsset");
static_assert(offsetof(UCoverAffectingSourceDataAsset, CoverAffectingSourceInfo) == 0x000038, "Member 'UCoverAffectingSourceDataAsset::CoverAffectingSourceInfo' has a wrong offset!");

// Class DeceiveInc.CustomDedicatedServerManager
// 0x0188 (0x0288 - 0x0100)
class UCustomDedicatedServerManager final : public UDIDedicatedServerManager
{
public:
	uint8                                         Pad_100[0x188];                                    // 0x0100(0x0188)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomDedicatedServerManager">();
	}
	static class UCustomDedicatedServerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomDedicatedServerManager>();
	}
};
static_assert(alignof(UCustomDedicatedServerManager) == 0x000008, "Wrong alignment on UCustomDedicatedServerManager");
static_assert(sizeof(UCustomDedicatedServerManager) == 0x000288, "Wrong size on UCustomDedicatedServerManager");

// Class DeceiveInc.RoomNavArea_Staff
// 0x0000 (0x0048 - 0x0048)
class URoomNavArea_Staff final : public URoomNavArea_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoomNavArea_Staff">();
	}
	static class URoomNavArea_Staff* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoomNavArea_Staff>();
	}
};
static_assert(alignof(URoomNavArea_Staff) == 0x000008, "Wrong alignment on URoomNavArea_Staff");
static_assert(sizeof(URoomNavArea_Staff) == 0x000048, "Wrong size on URoomNavArea_Staff");

// Class DeceiveInc.DamageAoEActor
// 0x0018 (0x0340 - 0x0328)
class ADamageAoEActor final : public ABaseAoEActor
{
public:
	FMulticastInlineDelegateProperty_             OnDamageActor;                                     // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         AOEDamage;                                         // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnDoDamageToActor(class AActor* ActorToDamage);
	void NetMulticast_OnDoDamage(class AActor* ActorToDamage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageAoEActor">();
	}
	static class ADamageAoEActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADamageAoEActor>();
	}
};
static_assert(alignof(ADamageAoEActor) == 0x000008, "Wrong alignment on ADamageAoEActor");
static_assert(sizeof(ADamageAoEActor) == 0x000340, "Wrong size on ADamageAoEActor");
static_assert(offsetof(ADamageAoEActor, OnDamageActor) == 0x000328, "Member 'ADamageAoEActor::OnDamageActor' has a wrong offset!");
static_assert(offsetof(ADamageAoEActor, AOEDamage) == 0x000338, "Member 'ADamageAoEActor::AOEDamage' has a wrong offset!");

// Class DeceiveInc.DamageDealerInterface
// 0x0000 (0x0028 - 0x0028)
class IDamageDealerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageDealerInterface">();
	}
	static class IDamageDealerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDamageDealerInterface>();
	}
};
static_assert(alignof(IDamageDealerInterface) == 0x000008, "Wrong alignment on IDamageDealerInterface");
static_assert(sizeof(IDamageDealerInterface) == 0x000028, "Wrong size on IDamageDealerInterface");

// Class DeceiveInc.OctoHackingZone
// 0x0028 (0x0248 - 0x0220)
class AOctoHackingZone final : public AActor
{
public:
	float                                         GroundCheckRadius;                                 // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundCheckHeight;                                 // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundCheckHeightLowerMovementSpeed;               // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundCheckHeightHigherMovementSpeed;              // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      RegistrationCollisionShapeComp;                    // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_238[0x10];                                     // 0x0238(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OctoHackingZone">();
	}
	static class AOctoHackingZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOctoHackingZone>();
	}
};
static_assert(alignof(AOctoHackingZone) == 0x000008, "Wrong alignment on AOctoHackingZone");
static_assert(sizeof(AOctoHackingZone) == 0x000248, "Wrong size on AOctoHackingZone");
static_assert(offsetof(AOctoHackingZone, GroundCheckRadius) == 0x000220, "Member 'AOctoHackingZone::GroundCheckRadius' has a wrong offset!");
static_assert(offsetof(AOctoHackingZone, GroundCheckHeight) == 0x000224, "Member 'AOctoHackingZone::GroundCheckHeight' has a wrong offset!");
static_assert(offsetof(AOctoHackingZone, GroundCheckHeightLowerMovementSpeed) == 0x000228, "Member 'AOctoHackingZone::GroundCheckHeightLowerMovementSpeed' has a wrong offset!");
static_assert(offsetof(AOctoHackingZone, GroundCheckHeightHigherMovementSpeed) == 0x00022C, "Member 'AOctoHackingZone::GroundCheckHeightHigherMovementSpeed' has a wrong offset!");
static_assert(offsetof(AOctoHackingZone, RegistrationCollisionShapeComp) == 0x000230, "Member 'AOctoHackingZone::RegistrationCollisionShapeComp' has a wrong offset!");

// Class DeceiveInc.DamageModifier
// 0x0028 (0x0050 - 0x0028)
class UDamageModifier final : public UObject
{
public:
	float                                         Multipliers;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AffectsHealing;                                    // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNegateHeadshots;                                  // 0x002D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsEnvironmentDamage;                         // 0x002E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F[0x1];                                       // 0x002F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DamageModified;                                    // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bAffectFriendlyOnly;                               // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0xB];                                       // 0x0041(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	EHitType                                      HitTypeOverride;                                   // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageModifier">();
	}
	static class UDamageModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageModifier>();
	}
};
static_assert(alignof(UDamageModifier) == 0x000008, "Wrong alignment on UDamageModifier");
static_assert(sizeof(UDamageModifier) == 0x000050, "Wrong size on UDamageModifier");
static_assert(offsetof(UDamageModifier, Multipliers) == 0x000028, "Member 'UDamageModifier::Multipliers' has a wrong offset!");
static_assert(offsetof(UDamageModifier, AffectsHealing) == 0x00002C, "Member 'UDamageModifier::AffectsHealing' has a wrong offset!");
static_assert(offsetof(UDamageModifier, bNegateHeadshots) == 0x00002D, "Member 'UDamageModifier::bNegateHeadshots' has a wrong offset!");
static_assert(offsetof(UDamageModifier, bAffectsEnvironmentDamage) == 0x00002E, "Member 'UDamageModifier::bAffectsEnvironmentDamage' has a wrong offset!");
static_assert(offsetof(UDamageModifier, DamageModified) == 0x000030, "Member 'UDamageModifier::DamageModified' has a wrong offset!");
static_assert(offsetof(UDamageModifier, bAffectFriendlyOnly) == 0x000040, "Member 'UDamageModifier::bAffectFriendlyOnly' has a wrong offset!");
static_assert(offsetof(UDamageModifier, HitTypeOverride) == 0x00004C, "Member 'UDamageModifier::HitTypeOverride' has a wrong offset!");

// Class DeceiveInc.DamageModifiers
// 0x0050 (0x0078 - 0x0028)
class UDamageModifiers final : public UObject
{
public:
	TSet<class UDamageModifier*>                  ActiveModifiers;                                   // 0x0028(0x0050)(Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageModifiers">();
	}
	static class UDamageModifiers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageModifiers>();
	}
};
static_assert(alignof(UDamageModifiers) == 0x000008, "Wrong alignment on UDamageModifiers");
static_assert(sizeof(UDamageModifiers) == 0x000078, "Wrong size on UDamageModifiers");
static_assert(offsetof(UDamageModifiers, ActiveModifiers) == 0x000028, "Member 'UDamageModifiers::ActiveModifiers' has a wrong offset!");

// Class DeceiveInc.ObjectSpawnInterface
// 0x0000 (0x0028 - 0x0028)
class IObjectSpawnInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectSpawnInterface">();
	}
	static class IObjectSpawnInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IObjectSpawnInterface>();
	}
};
static_assert(alignof(IObjectSpawnInterface) == 0x000008, "Wrong alignment on IObjectSpawnInterface");
static_assert(sizeof(IObjectSpawnInterface) == 0x000028, "Wrong size on IObjectSpawnInterface");

// Class DeceiveInc.DamageNumber
// 0x0018 (0x0238 - 0x0220)
class ADamageNumber final : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageValue;                                       // 0x0228(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHitType                                      HitType;                                           // 0x022C(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22D[0x3];                                      // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lifetime;                                          // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageNumber">();
	}
	static class ADamageNumber* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADamageNumber>();
	}
};
static_assert(alignof(ADamageNumber) == 0x000008, "Wrong alignment on ADamageNumber");
static_assert(sizeof(ADamageNumber) == 0x000238, "Wrong size on ADamageNumber");
static_assert(offsetof(ADamageNumber, DamageValue) == 0x000228, "Member 'ADamageNumber::DamageValue' has a wrong offset!");
static_assert(offsetof(ADamageNumber, HitType) == 0x00022C, "Member 'ADamageNumber::HitType' has a wrong offset!");
static_assert(offsetof(ADamageNumber, Lifetime) == 0x000230, "Member 'ADamageNumber::Lifetime' has a wrong offset!");

// Class DeceiveInc.DamageOutputModifierInterface
// 0x0000 (0x0028 - 0x0028)
class IDamageOutputModifierInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageOutputModifierInterface">();
	}
	static class IDamageOutputModifierInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDamageOutputModifierInterface>();
	}
};
static_assert(alignof(IDamageOutputModifierInterface) == 0x000008, "Wrong alignment on IDamageOutputModifierInterface");
static_assert(sizeof(IDamageOutputModifierInterface) == 0x000028, "Wrong size on IDamageOutputModifierInterface");

// Class DeceiveInc.DebugFreecam
// 0x0030 (0x02D8 - 0x02A8)
class ADebugFreecam final : public ADefaultPawn
{
public:
	uint8                                         Pad_2A8[0x18];                                     // 0x02A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       CameraComponent;                                   // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputMappingContext*                   InputMappingContext;                               // 0x02C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InputContextPriority;                              // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugFreecam">();
	}
	static class ADebugFreecam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugFreecam>();
	}
};
static_assert(alignof(ADebugFreecam) == 0x000008, "Wrong alignment on ADebugFreecam");
static_assert(sizeof(ADebugFreecam) == 0x0002D8, "Wrong size on ADebugFreecam");
static_assert(offsetof(ADebugFreecam, CameraComponent) == 0x0002C0, "Member 'ADebugFreecam::CameraComponent' has a wrong offset!");
static_assert(offsetof(ADebugFreecam, InputMappingContext) == 0x0002C8, "Member 'ADebugFreecam::InputMappingContext' has a wrong offset!");
static_assert(offsetof(ADebugFreecam, InputContextPriority) == 0x0002D0, "Member 'ADebugFreecam::InputContextPriority' has a wrong offset!");

// Class DeceiveInc.OctoDrainingActiveAbility
// 0x0068 (0x0610 - 0x05A8)
class AOctoDrainingActiveAbility : public AOctoBaseActiveAbility
{
public:
	float                                         IntelDrainInterval;                                // 0x05A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntelDrainAmount;                                  // 0x05AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayResourcesType                        DrainResourceType;                                 // 0x05B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B1[0x7];                                      // 0x05B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FTimerHandle, class ASpy*>        DrainTimers;                                       // 0x05B8(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bDrainingSomeone;                                  // 0x0608(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_609[0x7];                                      // 0x0609(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnLocalAlliedOctoPlayerDrainedAnotherPlayer();
	void BP_OnLocalAlliedPlayerDrainingChange(bool bDraining);
	void BP_OnLocalOctoPlayerDrainedAnotherPlayer();
	void BP_OnLocalPlayerDrainingChange(bool bDraining);
	void BP_OnLocalVictimPlayerBeingDrainedChange(bool bDrained, class ABaseIntelActor* BeingDrainedByHackableIntel);
	void BP_OnLocalVictimPlayerDrained(class ABaseIntelActor* DrainedByHackableIntel);
	void NetMulticast_NotifyPlayerBeingDrained(class ASpy* PlayerBeingDrained, class ABaseIntelActor* DrainedByHackableIntel, bool bDrained);
	void NetMulticast_NotifyPlayerDrained(class ASpy* PlayerDrained, class ABaseIntelActor* DrainedByHackableIntel);
	void OnDrainTimerEnd();
	void OnRep_DrainingSomeone();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OctoDrainingActiveAbility">();
	}
	static class AOctoDrainingActiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOctoDrainingActiveAbility>();
	}
};
static_assert(alignof(AOctoDrainingActiveAbility) == 0x000008, "Wrong alignment on AOctoDrainingActiveAbility");
static_assert(sizeof(AOctoDrainingActiveAbility) == 0x000610, "Wrong size on AOctoDrainingActiveAbility");
static_assert(offsetof(AOctoDrainingActiveAbility, IntelDrainInterval) == 0x0005A8, "Member 'AOctoDrainingActiveAbility::IntelDrainInterval' has a wrong offset!");
static_assert(offsetof(AOctoDrainingActiveAbility, IntelDrainAmount) == 0x0005AC, "Member 'AOctoDrainingActiveAbility::IntelDrainAmount' has a wrong offset!");
static_assert(offsetof(AOctoDrainingActiveAbility, DrainResourceType) == 0x0005B0, "Member 'AOctoDrainingActiveAbility::DrainResourceType' has a wrong offset!");
static_assert(offsetof(AOctoDrainingActiveAbility, DrainTimers) == 0x0005B8, "Member 'AOctoDrainingActiveAbility::DrainTimers' has a wrong offset!");
static_assert(offsetof(AOctoDrainingActiveAbility, bDrainingSomeone) == 0x000608, "Member 'AOctoDrainingActiveAbility::bDrainingSomeone' has a wrong offset!");

// Class DeceiveInc.OctoActiveAbilityMod1
// 0x01E0 (0x07F0 - 0x0610)
class AOctoActiveAbilityMod1 final : public AOctoDrainingActiveAbility
{
public:
	TSoftClassPtr<class UClass>                   OctoHackingZoneClass;                              // 0x0610(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   OctoIntelDrainZoneClass;                           // 0x0638(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   OctoIntelDrainZoneVisualFeedbackClass;             // 0x0660(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HackingZoneRadius;                                 // 0x0688(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HackingZoneHeight;                                 // 0x068C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrainEnemyHackPercent;                             // 0x0690(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OctoIntelSharePercent;                             // 0x0694(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeammateIntelSharePercent;                         // 0x0698(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69C[0x4];                                      // 0x069C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AOctoHackingZone*                       CurrentHackingZone;                                // 0x06A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class AActor*>                           HackablesInZone;                                   // 0x06A8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class ASpy*, class AOctoIntelDrainZone*> SpiesInDrainZones;                                 // 0x06F8(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSet<class ASpy*>                             FriendlySpiesInZone;                               // 0x0748(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class AActor*, class AOctoIntelDrainZone*> DrainZonesOnHackables;                             // 0x0798(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E8[0x8];                                      // 0x07E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAffectedHackableHacked(class ASpy* Spy, class ABaseIntelActor* IntelActor, EGameplayResourcesType ResourceType, int32 ResourceAmount);
	void OnHackedIntel(class ASpy* Spy, class ABaseIntelActor* IntelActor, EGameplayResourcesType ResourceType, int32 ResourceAmount);

	class AOctoHackingZone* GetCurrentHackingZone() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OctoActiveAbilityMod1">();
	}
	static class AOctoActiveAbilityMod1* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOctoActiveAbilityMod1>();
	}
};
static_assert(alignof(AOctoActiveAbilityMod1) == 0x000008, "Wrong alignment on AOctoActiveAbilityMod1");
static_assert(sizeof(AOctoActiveAbilityMod1) == 0x0007F0, "Wrong size on AOctoActiveAbilityMod1");
static_assert(offsetof(AOctoActiveAbilityMod1, OctoHackingZoneClass) == 0x000610, "Member 'AOctoActiveAbilityMod1::OctoHackingZoneClass' has a wrong offset!");
static_assert(offsetof(AOctoActiveAbilityMod1, OctoIntelDrainZoneClass) == 0x000638, "Member 'AOctoActiveAbilityMod1::OctoIntelDrainZoneClass' has a wrong offset!");
static_assert(offsetof(AOctoActiveAbilityMod1, OctoIntelDrainZoneVisualFeedbackClass) == 0x000660, "Member 'AOctoActiveAbilityMod1::OctoIntelDrainZoneVisualFeedbackClass' has a wrong offset!");
static_assert(offsetof(AOctoActiveAbilityMod1, HackingZoneRadius) == 0x000688, "Member 'AOctoActiveAbilityMod1::HackingZoneRadius' has a wrong offset!");
static_assert(offsetof(AOctoActiveAbilityMod1, HackingZoneHeight) == 0x00068C, "Member 'AOctoActiveAbilityMod1::HackingZoneHeight' has a wrong offset!");
static_assert(offsetof(AOctoActiveAbilityMod1, DrainEnemyHackPercent) == 0x000690, "Member 'AOctoActiveAbilityMod1::DrainEnemyHackPercent' has a wrong offset!");
static_assert(offsetof(AOctoActiveAbilityMod1, OctoIntelSharePercent) == 0x000694, "Member 'AOctoActiveAbilityMod1::OctoIntelSharePercent' has a wrong offset!");
static_assert(offsetof(AOctoActiveAbilityMod1, TeammateIntelSharePercent) == 0x000698, "Member 'AOctoActiveAbilityMod1::TeammateIntelSharePercent' has a wrong offset!");
static_assert(offsetof(AOctoActiveAbilityMod1, CurrentHackingZone) == 0x0006A0, "Member 'AOctoActiveAbilityMod1::CurrentHackingZone' has a wrong offset!");
static_assert(offsetof(AOctoActiveAbilityMod1, HackablesInZone) == 0x0006A8, "Member 'AOctoActiveAbilityMod1::HackablesInZone' has a wrong offset!");
static_assert(offsetof(AOctoActiveAbilityMod1, SpiesInDrainZones) == 0x0006F8, "Member 'AOctoActiveAbilityMod1::SpiesInDrainZones' has a wrong offset!");
static_assert(offsetof(AOctoActiveAbilityMod1, FriendlySpiesInZone) == 0x000748, "Member 'AOctoActiveAbilityMod1::FriendlySpiesInZone' has a wrong offset!");
static_assert(offsetof(AOctoActiveAbilityMod1, DrainZonesOnHackables) == 0x000798, "Member 'AOctoActiveAbilityMod1::DrainZonesOnHackables' has a wrong offset!");

// Class DeceiveInc.DebugFreezeSubsystem
// 0x0000 (0x0030 - 0x0030)
class UDebugFreezeSubsystem final : public UGameInstanceSubsystem
{
public:
	void OnNextFrameTimerEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugFreezeSubsystem">();
	}
	static class UDebugFreezeSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugFreezeSubsystem>();
	}
};
static_assert(alignof(UDebugFreezeSubsystem) == 0x000008, "Wrong alignment on UDebugFreezeSubsystem");
static_assert(sizeof(UDebugFreezeSubsystem) == 0x000030, "Wrong size on UDebugFreezeSubsystem");

// Class DeceiveInc.SasoriBaseActiveAbility
// 0x0058 (0x05E8 - 0x0590)
class ASasoriBaseActiveAbility : public ABaseSpyActiveAbility
{
public:
	FMulticastInlineDelegateProperty_             OnInteractableRegister;                            // 0x0590(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractableUnregister;                          // 0x05A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         PoisonTimeOnInteractable;                          // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B4[0x4];                                      // 0x05B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           PoisonVictimEffectClass;                           // 0x05B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           PoisonVictimEffectClassSpies;                      // 0x05C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FPoisonedInteractable>          PoisonedInteractables;                             // 0x05D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SasoriBaseActiveAbility">();
	}
	static class ASasoriBaseActiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASasoriBaseActiveAbility>();
	}
};
static_assert(alignof(ASasoriBaseActiveAbility) == 0x000008, "Wrong alignment on ASasoriBaseActiveAbility");
static_assert(sizeof(ASasoriBaseActiveAbility) == 0x0005E8, "Wrong size on ASasoriBaseActiveAbility");
static_assert(offsetof(ASasoriBaseActiveAbility, OnInteractableRegister) == 0x000590, "Member 'ASasoriBaseActiveAbility::OnInteractableRegister' has a wrong offset!");
static_assert(offsetof(ASasoriBaseActiveAbility, OnInteractableUnregister) == 0x0005A0, "Member 'ASasoriBaseActiveAbility::OnInteractableUnregister' has a wrong offset!");
static_assert(offsetof(ASasoriBaseActiveAbility, PoisonTimeOnInteractable) == 0x0005B0, "Member 'ASasoriBaseActiveAbility::PoisonTimeOnInteractable' has a wrong offset!");
static_assert(offsetof(ASasoriBaseActiveAbility, PoisonVictimEffectClass) == 0x0005B8, "Member 'ASasoriBaseActiveAbility::PoisonVictimEffectClass' has a wrong offset!");
static_assert(offsetof(ASasoriBaseActiveAbility, PoisonVictimEffectClassSpies) == 0x0005C8, "Member 'ASasoriBaseActiveAbility::PoisonVictimEffectClassSpies' has a wrong offset!");
static_assert(offsetof(ASasoriBaseActiveAbility, PoisonedInteractables) == 0x0005D8, "Member 'ASasoriBaseActiveAbility::PoisonedInteractables' has a wrong offset!");

// Class DeceiveInc.SasoriActiveAbilityMod1
// 0x00A8 (0x0690 - 0x05E8)
class ASasoriActiveAbilityMod1 final : public ASasoriBaseActiveAbility
{
public:
	uint8                                         Pad_5E8[0x8];                                      // 0x05E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnProjectilesReleased;                             // 0x05F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnProjectilesAbort;                                // 0x0600(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShowProjectiles;                                 // 0x0610(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WeaponRoundClass;                                  // 0x0620(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MuzzleSocketName;                                  // 0x0648(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EffectiveAimRange;                                 // 0x0650(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SwitchAwayOutroTime;                               // 0x0654(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShootDelay;                                        // 0x0658(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_65C[0x4];                                      // 0x065C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APoisonAoEActor*                        LastPoisonedAoEActor;                              // 0x0660(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASpawnerWeaponRound*                    LastProjectile;                                    // 0x0668(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_670[0x1C];                                     // 0x0670(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bServerUseSync;                                    // 0x068C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68D[0x3];                                      // 0x068D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleProjectileEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);
	void HandleShootDelayEnd();
	void MulticastFireShot(const struct FVector_NetQuantize& DestinationPos);
	void NotifyAnimSwitchAwayFrom();
	void ShootVialServer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SasoriActiveAbilityMod1">();
	}
	static class ASasoriActiveAbilityMod1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASasoriActiveAbilityMod1>();
	}
};
static_assert(alignof(ASasoriActiveAbilityMod1) == 0x000008, "Wrong alignment on ASasoriActiveAbilityMod1");
static_assert(sizeof(ASasoriActiveAbilityMod1) == 0x000690, "Wrong size on ASasoriActiveAbilityMod1");
static_assert(offsetof(ASasoriActiveAbilityMod1, OnProjectilesReleased) == 0x0005F0, "Member 'ASasoriActiveAbilityMod1::OnProjectilesReleased' has a wrong offset!");
static_assert(offsetof(ASasoriActiveAbilityMod1, OnProjectilesAbort) == 0x000600, "Member 'ASasoriActiveAbilityMod1::OnProjectilesAbort' has a wrong offset!");
static_assert(offsetof(ASasoriActiveAbilityMod1, OnShowProjectiles) == 0x000610, "Member 'ASasoriActiveAbilityMod1::OnShowProjectiles' has a wrong offset!");
static_assert(offsetof(ASasoriActiveAbilityMod1, WeaponRoundClass) == 0x000620, "Member 'ASasoriActiveAbilityMod1::WeaponRoundClass' has a wrong offset!");
static_assert(offsetof(ASasoriActiveAbilityMod1, MuzzleSocketName) == 0x000648, "Member 'ASasoriActiveAbilityMod1::MuzzleSocketName' has a wrong offset!");
static_assert(offsetof(ASasoriActiveAbilityMod1, EffectiveAimRange) == 0x000650, "Member 'ASasoriActiveAbilityMod1::EffectiveAimRange' has a wrong offset!");
static_assert(offsetof(ASasoriActiveAbilityMod1, SwitchAwayOutroTime) == 0x000654, "Member 'ASasoriActiveAbilityMod1::SwitchAwayOutroTime' has a wrong offset!");
static_assert(offsetof(ASasoriActiveAbilityMod1, ShootDelay) == 0x000658, "Member 'ASasoriActiveAbilityMod1::ShootDelay' has a wrong offset!");
static_assert(offsetof(ASasoriActiveAbilityMod1, LastPoisonedAoEActor) == 0x000660, "Member 'ASasoriActiveAbilityMod1::LastPoisonedAoEActor' has a wrong offset!");
static_assert(offsetof(ASasoriActiveAbilityMod1, LastProjectile) == 0x000668, "Member 'ASasoriActiveAbilityMod1::LastProjectile' has a wrong offset!");
static_assert(offsetof(ASasoriActiveAbilityMod1, bServerUseSync) == 0x00068C, "Member 'ASasoriActiveAbilityMod1::bServerUseSync' has a wrong offset!");

// Class DeceiveInc.DeceiveIncControllerInterface
// 0x0000 (0x0028 - 0x0028)
class IDeceiveIncControllerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeceiveIncControllerInterface">();
	}
	static class IDeceiveIncControllerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDeceiveIncControllerInterface>();
	}
};
static_assert(alignof(IDeceiveIncControllerInterface) == 0x000008, "Wrong alignment on IDeceiveIncControllerInterface");
static_assert(sizeof(IDeceiveIncControllerInterface) == 0x000028, "Wrong size on IDeceiveIncControllerInterface");

// Class DeceiveInc.SBAimAssistConfigDataAsset
// 0x0328 (0x0358 - 0x0030)
class USBAimAssistConfigDataAsset final : public UDataAsset
{
public:
	float                                         UpdateTargetsRate;                                 // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumExtraInfluenceMagnitude;                    // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimAreaExtents;                                    // 0x0038(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAimInputAssistMode                           InputAssistMode;                                   // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSBFrictionZoneConfig                  FrictionZoneConfig;                                // 0x0048(0x0118)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSBMagnetismZoneConfig                 MagnetismZoneConfig;                               // 0x0160(0x0128)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bBulletMagnetismZoneConfig;                        // 0x0288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x3];                                      // 0x0289(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSBBulletMagnetismZoneConfig           BulletMagnetismZoneConfig;                         // 0x028C(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bScalingZoneConfig;                                // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSBZonesScalingConfig                  ZonesScalingConfig;                                // 0x02A0(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bAutoAimConfig;                                    // 0x0328(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_329[0x3];                                      // 0x0329(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSBAutoAimConfig                       AutoAimConfig;                                     // 0x032C(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              CrosshairOffset;                                   // 0x034C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SBAimAssistConfigDataAsset">();
	}
	static class USBAimAssistConfigDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USBAimAssistConfigDataAsset>();
	}
};
static_assert(alignof(USBAimAssistConfigDataAsset) == 0x000008, "Wrong alignment on USBAimAssistConfigDataAsset");
static_assert(sizeof(USBAimAssistConfigDataAsset) == 0x000358, "Wrong size on USBAimAssistConfigDataAsset");
static_assert(offsetof(USBAimAssistConfigDataAsset, UpdateTargetsRate) == 0x000030, "Member 'USBAimAssistConfigDataAsset::UpdateTargetsRate' has a wrong offset!");
static_assert(offsetof(USBAimAssistConfigDataAsset, MaximumExtraInfluenceMagnitude) == 0x000034, "Member 'USBAimAssistConfigDataAsset::MaximumExtraInfluenceMagnitude' has a wrong offset!");
static_assert(offsetof(USBAimAssistConfigDataAsset, AimAreaExtents) == 0x000038, "Member 'USBAimAssistConfigDataAsset::AimAreaExtents' has a wrong offset!");
static_assert(offsetof(USBAimAssistConfigDataAsset, InputAssistMode) == 0x000044, "Member 'USBAimAssistConfigDataAsset::InputAssistMode' has a wrong offset!");
static_assert(offsetof(USBAimAssistConfigDataAsset, FrictionZoneConfig) == 0x000048, "Member 'USBAimAssistConfigDataAsset::FrictionZoneConfig' has a wrong offset!");
static_assert(offsetof(USBAimAssistConfigDataAsset, MagnetismZoneConfig) == 0x000160, "Member 'USBAimAssistConfigDataAsset::MagnetismZoneConfig' has a wrong offset!");
static_assert(offsetof(USBAimAssistConfigDataAsset, bBulletMagnetismZoneConfig) == 0x000288, "Member 'USBAimAssistConfigDataAsset::bBulletMagnetismZoneConfig' has a wrong offset!");
static_assert(offsetof(USBAimAssistConfigDataAsset, BulletMagnetismZoneConfig) == 0x00028C, "Member 'USBAimAssistConfigDataAsset::BulletMagnetismZoneConfig' has a wrong offset!");
static_assert(offsetof(USBAimAssistConfigDataAsset, bScalingZoneConfig) == 0x000298, "Member 'USBAimAssistConfigDataAsset::bScalingZoneConfig' has a wrong offset!");
static_assert(offsetof(USBAimAssistConfigDataAsset, ZonesScalingConfig) == 0x0002A0, "Member 'USBAimAssistConfigDataAsset::ZonesScalingConfig' has a wrong offset!");
static_assert(offsetof(USBAimAssistConfigDataAsset, bAutoAimConfig) == 0x000328, "Member 'USBAimAssistConfigDataAsset::bAutoAimConfig' has a wrong offset!");
static_assert(offsetof(USBAimAssistConfigDataAsset, AutoAimConfig) == 0x00032C, "Member 'USBAimAssistConfigDataAsset::AutoAimConfig' has a wrong offset!");
static_assert(offsetof(USBAimAssistConfigDataAsset, CrosshairOffset) == 0x00034C, "Member 'USBAimAssistConfigDataAsset::CrosshairOffset' has a wrong offset!");

// Class DeceiveInc.IntroPhaseInfo
// 0x0058 (0x0080 - 0x0028)
class UIntroPhaseInfo final : public USpyGamePhaseInfo
{
public:
	struct FIntroPhaseData                        DefaultPhaseData;                                  // 0x0028(0x0058)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IntroPhaseInfo">();
	}
	static class UIntroPhaseInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIntroPhaseInfo>();
	}
};
static_assert(alignof(UIntroPhaseInfo) == 0x000008, "Wrong alignment on UIntroPhaseInfo");
static_assert(sizeof(UIntroPhaseInfo) == 0x000080, "Wrong size on UIntroPhaseInfo");
static_assert(offsetof(UIntroPhaseInfo, DefaultPhaseData) == 0x000028, "Member 'UIntroPhaseInfo::DefaultPhaseData' has a wrong offset!");

// Class DeceiveInc.VaultLockedPhaseInfo
// 0x0098 (0x00C0 - 0x0028)
class UVaultLockedPhaseInfo final : public USpyGamePhaseInfo
{
public:
	struct FVaultLockedPhaseData                  DefaultPhaseData;                                  // 0x0028(0x0098)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	class FText GetObjectiveDesc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VaultLockedPhaseInfo">();
	}
	static class UVaultLockedPhaseInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVaultLockedPhaseInfo>();
	}
};
static_assert(alignof(UVaultLockedPhaseInfo) == 0x000008, "Wrong alignment on UVaultLockedPhaseInfo");
static_assert(sizeof(UVaultLockedPhaseInfo) == 0x0000C0, "Wrong size on UVaultLockedPhaseInfo");
static_assert(offsetof(UVaultLockedPhaseInfo, DefaultPhaseData) == 0x000028, "Member 'UVaultLockedPhaseInfo::DefaultPhaseData' has a wrong offset!");

// Class DeceiveInc.VaultUnlockedPhaseInfo
// 0x00C8 (0x00F0 - 0x0028)
class UVaultUnlockedPhaseInfo final : public USpyGamePhaseInfo
{
public:
	struct FVaultUnlockedPhaseData                DefaultPhaseData;                                  // 0x0028(0x00C8)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	class FText GetObjectiveDescInsideVault();
	class FText GetObjectiveDescOutsideVault();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VaultUnlockedPhaseInfo">();
	}
	static class UVaultUnlockedPhaseInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVaultUnlockedPhaseInfo>();
	}
};
static_assert(alignof(UVaultUnlockedPhaseInfo) == 0x000008, "Wrong alignment on UVaultUnlockedPhaseInfo");
static_assert(sizeof(UVaultUnlockedPhaseInfo) == 0x0000F0, "Wrong size on UVaultUnlockedPhaseInfo");
static_assert(offsetof(UVaultUnlockedPhaseInfo, DefaultPhaseData) == 0x000028, "Member 'UVaultUnlockedPhaseInfo::DefaultPhaseData' has a wrong offset!");

// Class DeceiveInc.ExtractionArrivedPhaseInfo
// 0x00C0 (0x00E8 - 0x0028)
class UExtractionArrivedPhaseInfo final : public USpyGamePhaseInfo
{
public:
	struct FExtractionArrivedPhaseData            DefaultPhaseData;                                  // 0x0028(0x00C0)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	class FText GetObjectiveDescCarrier();
	class FText GetObjectiveDescNonCarrier();
	class FText GetObjectiveDescNonCarrierTeammate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExtractionArrivedPhaseInfo">();
	}
	static class UExtractionArrivedPhaseInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExtractionArrivedPhaseInfo>();
	}
};
static_assert(alignof(UExtractionArrivedPhaseInfo) == 0x000008, "Wrong alignment on UExtractionArrivedPhaseInfo");
static_assert(sizeof(UExtractionArrivedPhaseInfo) == 0x0000E8, "Wrong size on UExtractionArrivedPhaseInfo");
static_assert(offsetof(UExtractionArrivedPhaseInfo, DefaultPhaseData) == 0x000028, "Member 'UExtractionArrivedPhaseInfo::DefaultPhaseData' has a wrong offset!");

// Class DeceiveInc.PregameLobbyPhaseInfo
// 0x0058 (0x0080 - 0x0028)
class UPregameLobbyPhaseInfo final : public UBaseGamePhaseInfo
{
public:
	struct FPregameLobbyPhaseData                 DefaultPhaseData;                                  // 0x0028(0x0058)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PregameLobbyPhaseInfo">();
	}
	static class UPregameLobbyPhaseInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPregameLobbyPhaseInfo>();
	}
};
static_assert(alignof(UPregameLobbyPhaseInfo) == 0x000008, "Wrong alignment on UPregameLobbyPhaseInfo");
static_assert(sizeof(UPregameLobbyPhaseInfo) == 0x000080, "Wrong size on UPregameLobbyPhaseInfo");
static_assert(offsetof(UPregameLobbyPhaseInfo, DefaultPhaseData) == 0x000028, "Member 'UPregameLobbyPhaseInfo::DefaultPhaseData' has a wrong offset!");

// Class DeceiveInc.DeceiveIncGameModeBase
// 0x0268 (0x0570 - 0x0308)
class ADeceiveIncGameModeBase final : public AGameMode
{
public:
	FMulticastInlineDelegateProperty_             OnPostLogin;                                       // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLogout;                                          // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNewBotPlayerController;                          // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBotPlayersSpawnDone;                             // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ESpawningRule                                 DefaultSpawningRule;                               // 0x0348(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_349[0x57];                                     // 0x0349(0x0057)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGameState>                 PregameLobbyGameStateClass;                        // 0x03A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AGameState>                 SpyGameStateClass;                                 // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AGameState>                 MatchGameStateClass;                               // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AGameState>                 DedicatedMapPickerStateClass;                      // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ADeceiveIncBotController>   BotControllerClass;                                // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AGameMode>                  DIGameSessionClass;                                // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGeneralVoiceChatEnabled;                          // 0x03D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D1[0x7];                                      // 0x03D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDiChatRoom*                            GeneralChatroom;                                   // 0x03D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UDiFactionChatRoom*>             FactionChatrooms;                                  // 0x03E0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ADeceiveIncPlayerController*>    LoggedPlayers;                                     // 0x03F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ADeceiveIncPlayerBotController*> BotPlayers;                                        // 0x0400(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_410[0x50];                                     // 0x0410(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class ADeceiveIncPlayerController*> PUIDToPC;                                          // 0x0460(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class ADeceiveIncPlayerController*, class FString> PCToPUID;                                          // 0x04B0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class USmokeTestBotsManager*                  SmokeTestBotsManager;                              // 0x0500(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportsKillcamReplay;                            // 0x0508(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_509[0x17];                                     // 0x0509(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FPlayerEACData>    PlayerEACData;                                     // 0x0520(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void ClearPS5MatchId();
	void ClearPS5MatchResponsiblePlayer();
	void EAC_Heartbeat();
	void OnSpawnBotPlayerTimerEnd();
	void SetGeneralVoicechatEnabled(bool bEnabled);
	void SetPS5MatchId(const class FString& NewPS5MatchId);
	void SetPS5MatchResponsiblePlayer(class ADIPlayerState* NewPlayerState);
	void SetSpawningRule(ESpawningRule NewRule);
	void UpdatePS5MatchResponsibility(class APlayerController* ExcludePlayer);

	TArray<class ASpy*> GetAllActiveSpies() const;
	ESpawningRule GetSpawningRule() const;
	bool IsGeneralVoicechatEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeceiveIncGameModeBase">();
	}
	static class ADeceiveIncGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeceiveIncGameModeBase>();
	}
};
static_assert(alignof(ADeceiveIncGameModeBase) == 0x000008, "Wrong alignment on ADeceiveIncGameModeBase");
static_assert(sizeof(ADeceiveIncGameModeBase) == 0x000570, "Wrong size on ADeceiveIncGameModeBase");
static_assert(offsetof(ADeceiveIncGameModeBase, OnPostLogin) == 0x000308, "Member 'ADeceiveIncGameModeBase::OnPostLogin' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameModeBase, OnLogout) == 0x000318, "Member 'ADeceiveIncGameModeBase::OnLogout' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameModeBase, OnNewBotPlayerController) == 0x000328, "Member 'ADeceiveIncGameModeBase::OnNewBotPlayerController' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameModeBase, OnBotPlayersSpawnDone) == 0x000338, "Member 'ADeceiveIncGameModeBase::OnBotPlayersSpawnDone' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameModeBase, DefaultSpawningRule) == 0x000348, "Member 'ADeceiveIncGameModeBase::DefaultSpawningRule' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameModeBase, PregameLobbyGameStateClass) == 0x0003A0, "Member 'ADeceiveIncGameModeBase::PregameLobbyGameStateClass' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameModeBase, SpyGameStateClass) == 0x0003A8, "Member 'ADeceiveIncGameModeBase::SpyGameStateClass' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameModeBase, MatchGameStateClass) == 0x0003B0, "Member 'ADeceiveIncGameModeBase::MatchGameStateClass' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameModeBase, DedicatedMapPickerStateClass) == 0x0003B8, "Member 'ADeceiveIncGameModeBase::DedicatedMapPickerStateClass' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameModeBase, BotControllerClass) == 0x0003C0, "Member 'ADeceiveIncGameModeBase::BotControllerClass' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameModeBase, DIGameSessionClass) == 0x0003C8, "Member 'ADeceiveIncGameModeBase::DIGameSessionClass' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameModeBase, bGeneralVoiceChatEnabled) == 0x0003D0, "Member 'ADeceiveIncGameModeBase::bGeneralVoiceChatEnabled' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameModeBase, GeneralChatroom) == 0x0003D8, "Member 'ADeceiveIncGameModeBase::GeneralChatroom' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameModeBase, FactionChatrooms) == 0x0003E0, "Member 'ADeceiveIncGameModeBase::FactionChatrooms' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameModeBase, LoggedPlayers) == 0x0003F0, "Member 'ADeceiveIncGameModeBase::LoggedPlayers' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameModeBase, BotPlayers) == 0x000400, "Member 'ADeceiveIncGameModeBase::BotPlayers' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameModeBase, PUIDToPC) == 0x000460, "Member 'ADeceiveIncGameModeBase::PUIDToPC' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameModeBase, PCToPUID) == 0x0004B0, "Member 'ADeceiveIncGameModeBase::PCToPUID' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameModeBase, SmokeTestBotsManager) == 0x000500, "Member 'ADeceiveIncGameModeBase::SmokeTestBotsManager' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameModeBase, bSupportsKillcamReplay) == 0x000508, "Member 'ADeceiveIncGameModeBase::bSupportsKillcamReplay' has a wrong offset!");
static_assert(offsetof(ADeceiveIncGameModeBase, PlayerEACData) == 0x000520, "Member 'ADeceiveIncGameModeBase::PlayerEACData' has a wrong offset!");

// Class DeceiveInc.DeceiveIncGameSession
// 0x0000 (0x0238 - 0x0238)
class ADeceiveIncGameSession final : public AGameSession
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeceiveIncGameSession">();
	}
	static class ADeceiveIncGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeceiveIncGameSession>();
	}
};
static_assert(alignof(ADeceiveIncGameSession) == 0x000008, "Wrong alignment on ADeceiveIncGameSession");
static_assert(sizeof(ADeceiveIncGameSession) == 0x000238, "Wrong size on ADeceiveIncGameSession");

// Class DeceiveInc.DeceiveIncMainGameState
// 0x0000 (0x0848 - 0x0848)
class ADeceiveIncMainGameState final : public ADeceiveIncMatchGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeceiveIncMainGameState">();
	}
	static class ADeceiveIncMainGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeceiveIncMainGameState>();
	}
};
static_assert(alignof(ADeceiveIncMainGameState) == 0x000008, "Wrong alignment on ADeceiveIncMainGameState");
static_assert(sizeof(ADeceiveIncMainGameState) == 0x000848, "Wrong size on ADeceiveIncMainGameState");

// Class DeceiveInc.DeceiveIncPlayerController
// 0x03A0 (0x0920 - 0x0580)
class ADeceiveIncPlayerController : public APlayerController
{
public:
	uint8                                         Pad_580[0x88];                                     // 0x0580(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAgentSelectionFailed;                            // 0x0608(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInputPressed;                                    // 0x0618(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_628[0x188];                                    // 0x0628(0x0188)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRecoilInfo>                    ActiveRecoil;                                      // 0x07B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FRollKickInfo>                  ActiveRollKick;                                    // 0x07C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D0[0x24];                                     // 0x07D0(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsAutoSpectating;                                 // 0x07F4(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F5[0x23];                                     // 0x07F5(0x0023)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsReady;                                          // 0x0818(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_819[0x7];                                      // 0x0819(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USBAimAssistComponent*                  ControllerAimAssistComponent;                      // 0x0820(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_828[0x8];                                      // 0x0828(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            PlayerVoiceHud;                                    // 0x0830(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNetworkInfoWidget*                     NetworkInfoHud;                                    // 0x0838(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PlayerVoicechatHudAsset;                           // 0x0840(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   NetworkInfoWidgetAsset;                            // 0x0868(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_890[0x90];                                     // 0x0890(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_AgentSelectionFailed(ESelectionValidationResult Reason, const struct FPrimaryAssetId& RecommendedAgentId);
	void Client_IncomingEACMessage(const TArray<uint8>& Data, const class FString& SourceId, const class FString& TargetId);
	void Client_JoinVoiceChannel(const class FString& ChannelName, const class FString& ChannelCredentials);
	void ClientAttemptSetupKillcam();
	void ClientKillcamTimeout(bool bTriggerSetup);
	void ClientRecordKillcamFocusData(class AActor* InActor, class APlayerState* InPlayerState);
	void ClientReportServerTime(float RequestWorldTime, float ServerTime);
	void ClientStartKillcam(float TimeToRewind, float ServerTimestamp);
	void DEBUG_Randomize_CallingCardSelection(bool bCommitSelectionToSavegame);
	void DEBUG_Randomize_CharacterSelection(bool bCommitSelectionToSavegame);
	void DEBUG_Randomize_GadgetSelection(bool bCommitSelectionToSavegame);
	void DEBUG_Randomize_Powerups(bool bCommitSelectionToSavegame);
	void DEBUG_Randomize_ProfileSelection(bool bCommitSelectionToSavegame);
	void ForceKillcam();
	void ForceKillcamFlow();
	struct FPrimaryAssetId GetAgentId();
	TArray<class ADIPlayerState*> GetAliveTeammates();
	bool GetKillcamViewTargetInfo(class ADIPlayerState** DIPlayerState, class AActor** KillingActor);
	class ASpy* GetOwnedSpyPawn();
	TArray<TSoftObjectPtr<class UMaterialInstance>> GetPlaceableWrapMaterial(ELoadoutSlot ToolSlot);
	TArray<TSoftObjectPtr<class UMaterialInstance>> GetToolWrapMaterial(ELoadoutSlot ToolSlot);
	void GoToMainMenu();
	void HandleBooleanPlayerSettingChange(EPlayerSettingsType SettingType, bool NewValue);
	void HandleGamePhaseChange(ESpyGamePhase NewPhase, const class ADeceiveIncMatchGameState* GameState);
	void HandleInputMappingChanged();
	void HandleIntegerPlayerSettingChange(EPlayerSettingsType SettingType, int32 NewValue);
	bool IsKillcamPlaying();
	bool IsKillcamStartingUp();
	bool IsTeamAlive();
	void OnKillcamFadeStart();
	void OnKillcamStartCompleted(bool bSuccessful);
	void OnKillcamStopCompleted(bool bTriggerSetup);
	void OnRep_IsAutoSpectating();
	void OnSessionSelectionsModified(const class UDISessionSelections* SessionSelection);
	void OnStabilizeServerTimeOffset();
	void PlayerReadyForSpawn(bool bForceSpawn);
	void RequestJoinTeamVoicechat();
	void RequestLeaveTeamVoicechat();
	void RPC_ClientInformOfEvent(EClientEvent ClientEvent);
	void RPC_SpectateActor(class AActor* ActorToSpectate, class ADIPlayerState* PlayerStateToSpectate);
	void Server_AskForNextSpectatedActor(bool bNext);
	void Server_ClientIsReady(const class FString& Payload);
	void Server_DEBUGToggleFreecam();
	void Server_IncomingEACMessage(const TArray<uint8>& Data, const class FString& SourceId, const class FString& TargetId);
	void Server_RequestJoinTeamVoiceChannel();
	void Server_SetKillcamIsPlaying(bool bIsPlaying);
	void Server_SetPlayerName(const class FString& Username);
	void Server_ToggleAutoSpectate();
	void ServerClearPS5MatchId();
	void ServerForceKillcam(bool bReviveAfterKillcamIn);
	void ServerInitAccelByte(const struct FAccelByteUniqueIdComposite& UniqueNetId, const class FString& InMatchId);
	void ServerInitPlayerInfos(const class FString& BanditIdIn, const class FString& GameLiftPlayerSessionIdIn, const struct FPlayerAgentSelectionInfo& AgentSelectionIn, const struct FDISerializedAccessories& AccessoriesIn, const struct FDISerializedDeckEntry& DeckIn, EPlatformType PlateformType, const TArray<class UDIOnlinePartyMemberInfo*>& PartyMembers);
	void ServerRequestServerTime(float RequestWorldTime);
	void ServerSelectAgent(const struct FPlayerAgentSelectionInfo& AgentSelectionIn, const struct FDISerializedAccessories& AccessoriesIn, const struct FDISerializedDeckEntry& NewDeck, bool bForceSpawn);
	void ServerSetPS5MatchId(const class FString& NewPS5MatchId);
	bool TryTogglePauseMenu();
	bool WantsToPlayKillcam();

	bool IsInTeamVoicechat() const;
	bool IsJoiningTeamVoicechat() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeceiveIncPlayerController">();
	}
	static class ADeceiveIncPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeceiveIncPlayerController>();
	}
};
static_assert(alignof(ADeceiveIncPlayerController) == 0x000008, "Wrong alignment on ADeceiveIncPlayerController");
static_assert(sizeof(ADeceiveIncPlayerController) == 0x000920, "Wrong size on ADeceiveIncPlayerController");
static_assert(offsetof(ADeceiveIncPlayerController, OnAgentSelectionFailed) == 0x000608, "Member 'ADeceiveIncPlayerController::OnAgentSelectionFailed' has a wrong offset!");
static_assert(offsetof(ADeceiveIncPlayerController, OnInputPressed) == 0x000618, "Member 'ADeceiveIncPlayerController::OnInputPressed' has a wrong offset!");
static_assert(offsetof(ADeceiveIncPlayerController, ActiveRecoil) == 0x0007B0, "Member 'ADeceiveIncPlayerController::ActiveRecoil' has a wrong offset!");
static_assert(offsetof(ADeceiveIncPlayerController, ActiveRollKick) == 0x0007C0, "Member 'ADeceiveIncPlayerController::ActiveRollKick' has a wrong offset!");
static_assert(offsetof(ADeceiveIncPlayerController, bIsAutoSpectating) == 0x0007F4, "Member 'ADeceiveIncPlayerController::bIsAutoSpectating' has a wrong offset!");
static_assert(offsetof(ADeceiveIncPlayerController, bIsReady) == 0x000818, "Member 'ADeceiveIncPlayerController::bIsReady' has a wrong offset!");
static_assert(offsetof(ADeceiveIncPlayerController, ControllerAimAssistComponent) == 0x000820, "Member 'ADeceiveIncPlayerController::ControllerAimAssistComponent' has a wrong offset!");
static_assert(offsetof(ADeceiveIncPlayerController, PlayerVoiceHud) == 0x000830, "Member 'ADeceiveIncPlayerController::PlayerVoiceHud' has a wrong offset!");
static_assert(offsetof(ADeceiveIncPlayerController, NetworkInfoHud) == 0x000838, "Member 'ADeceiveIncPlayerController::NetworkInfoHud' has a wrong offset!");
static_assert(offsetof(ADeceiveIncPlayerController, PlayerVoicechatHudAsset) == 0x000840, "Member 'ADeceiveIncPlayerController::PlayerVoicechatHudAsset' has a wrong offset!");
static_assert(offsetof(ADeceiveIncPlayerController, NetworkInfoWidgetAsset) == 0x000868, "Member 'ADeceiveIncPlayerController::NetworkInfoWidgetAsset' has a wrong offset!");

// Class DeceiveInc.DeceiveIncPlayerVoiceChat
// 0x00B8 (0x02D8 - 0x0220)
class ADeceiveIncPlayerVoiceChat : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnJoinedChannelsChanged;                           // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnParticipantsChanged;                             // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAudioDevicesChanged;                             // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVoiceChatChannelJoined;                          // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVoiceChatChannelExited;                          // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVoiceChatPlayerAdded;                            // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVoiceChatPlayerRemoved;                          // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVoiceChatPlayerMuteUpdated;                      // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVoiceChatPlayerTalkingUpdated;                   // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVoiceChatPlayerTalkingUpdatedV2;                 // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLocalPlayerTalkingUpdate;                        // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool JoinVoiceChannel(const class FString& ChannelName, const class FString& ChannelCredentials);
	bool LeaveAllVoiceChannels();
	bool LeaveVoiceChannel(const class FString& ChannelName);
	void SetInputMuted(bool bMuted);
	void SetInputVolume(const float& Volume);
	void SetLocalVoiceActivationThreshold(float FNormalizedThreshold);
	void SetOutputMuted(bool bMuted);
	void SetOutputVolume(const float& Volume);
	void SetPlayerMuted(const class FString& PlayerName, bool bAudioMuted);
	void SetPlayerVolume(const class FString& PlayerName, float Volume);
	void SetTransmitMode(EPlayerVoiceChatTransmitMode TransmitMode);

	bool GetInputMuted() const;
	float GetInputVolume() const;
	TArray<class FString> GetJoinedChannels() const;
	float GetLocalVoiceActivationThreshold() const;
	class FString GetLoggedInPlayerName() const;
	bool GetOutputMuted() const;
	float GetOutputVolume() const;
	TArray<class FString> GetPlayersInChannel(const class FString& ChannelName) const;
	float GetPlayerVolume(const class FString& PlayerName) const;
	EPlayerVoiceChatTransmitMode GetTransmitMode() const;
	bool IsLocalPlayerTalking() const;
	bool IsPlayerMuted(const class FString& PlayerName) const;
	bool IsPlayerTalking(const class FString& PlayerName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeceiveIncPlayerVoiceChat">();
	}
	static class ADeceiveIncPlayerVoiceChat* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeceiveIncPlayerVoiceChat>();
	}
};
static_assert(alignof(ADeceiveIncPlayerVoiceChat) == 0x000008, "Wrong alignment on ADeceiveIncPlayerVoiceChat");
static_assert(sizeof(ADeceiveIncPlayerVoiceChat) == 0x0002D8, "Wrong size on ADeceiveIncPlayerVoiceChat");
static_assert(offsetof(ADeceiveIncPlayerVoiceChat, OnJoinedChannelsChanged) == 0x000220, "Member 'ADeceiveIncPlayerVoiceChat::OnJoinedChannelsChanged' has a wrong offset!");
static_assert(offsetof(ADeceiveIncPlayerVoiceChat, OnParticipantsChanged) == 0x000230, "Member 'ADeceiveIncPlayerVoiceChat::OnParticipantsChanged' has a wrong offset!");
static_assert(offsetof(ADeceiveIncPlayerVoiceChat, OnAudioDevicesChanged) == 0x000240, "Member 'ADeceiveIncPlayerVoiceChat::OnAudioDevicesChanged' has a wrong offset!");
static_assert(offsetof(ADeceiveIncPlayerVoiceChat, OnVoiceChatChannelJoined) == 0x000250, "Member 'ADeceiveIncPlayerVoiceChat::OnVoiceChatChannelJoined' has a wrong offset!");
static_assert(offsetof(ADeceiveIncPlayerVoiceChat, OnVoiceChatChannelExited) == 0x000260, "Member 'ADeceiveIncPlayerVoiceChat::OnVoiceChatChannelExited' has a wrong offset!");
static_assert(offsetof(ADeceiveIncPlayerVoiceChat, OnVoiceChatPlayerAdded) == 0x000270, "Member 'ADeceiveIncPlayerVoiceChat::OnVoiceChatPlayerAdded' has a wrong offset!");
static_assert(offsetof(ADeceiveIncPlayerVoiceChat, OnVoiceChatPlayerRemoved) == 0x000280, "Member 'ADeceiveIncPlayerVoiceChat::OnVoiceChatPlayerRemoved' has a wrong offset!");
static_assert(offsetof(ADeceiveIncPlayerVoiceChat, OnVoiceChatPlayerMuteUpdated) == 0x000290, "Member 'ADeceiveIncPlayerVoiceChat::OnVoiceChatPlayerMuteUpdated' has a wrong offset!");
static_assert(offsetof(ADeceiveIncPlayerVoiceChat, OnVoiceChatPlayerTalkingUpdated) == 0x0002A0, "Member 'ADeceiveIncPlayerVoiceChat::OnVoiceChatPlayerTalkingUpdated' has a wrong offset!");
static_assert(offsetof(ADeceiveIncPlayerVoiceChat, OnVoiceChatPlayerTalkingUpdatedV2) == 0x0002B0, "Member 'ADeceiveIncPlayerVoiceChat::OnVoiceChatPlayerTalkingUpdatedV2' has a wrong offset!");
static_assert(offsetof(ADeceiveIncPlayerVoiceChat, OnLocalPlayerTalkingUpdate) == 0x0002C0, "Member 'ADeceiveIncPlayerVoiceChat::OnLocalPlayerTalkingUpdate' has a wrong offset!");

// Class DeceiveInc.DeceiveIncPrivateLobbyGameMode
// 0x0000 (0x02C0 - 0x02C0)
class ADeceiveIncPrivateLobbyGameMode final : public AGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeceiveIncPrivateLobbyGameMode">();
	}
	static class ADeceiveIncPrivateLobbyGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeceiveIncPrivateLobbyGameMode>();
	}
};
static_assert(alignof(ADeceiveIncPrivateLobbyGameMode) == 0x000008, "Wrong alignment on ADeceiveIncPrivateLobbyGameMode");
static_assert(sizeof(ADeceiveIncPrivateLobbyGameMode) == 0x0002C0, "Wrong size on ADeceiveIncPrivateLobbyGameMode");

// Class DeceiveInc.DedicatedServerLiveOpsConfig
// 0x0028 (0x0060 - 0x0038)
class UDedicatedServerLiveOpsConfig final : public UDIPrimaryDataAsset
{
public:
	TArray<class UMapData*>                       DisabledMaps;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                DisabledAgents;                                    // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUploadAllSaved;                                   // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKickCheaters;                                     // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDIGameRuleset                                ActiveRuleset;                                     // 0x005A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B[0x5];                                       // 0x005B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReadCommandLineArgs();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DedicatedServerLiveOpsConfig">();
	}
	static class UDedicatedServerLiveOpsConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDedicatedServerLiveOpsConfig>();
	}
};
static_assert(alignof(UDedicatedServerLiveOpsConfig) == 0x000008, "Wrong alignment on UDedicatedServerLiveOpsConfig");
static_assert(sizeof(UDedicatedServerLiveOpsConfig) == 0x000060, "Wrong size on UDedicatedServerLiveOpsConfig");
static_assert(offsetof(UDedicatedServerLiveOpsConfig, DisabledMaps) == 0x000038, "Member 'UDedicatedServerLiveOpsConfig::DisabledMaps' has a wrong offset!");
static_assert(offsetof(UDedicatedServerLiveOpsConfig, DisabledAgents) == 0x000048, "Member 'UDedicatedServerLiveOpsConfig::DisabledAgents' has a wrong offset!");
static_assert(offsetof(UDedicatedServerLiveOpsConfig, bUploadAllSaved) == 0x000058, "Member 'UDedicatedServerLiveOpsConfig::bUploadAllSaved' has a wrong offset!");
static_assert(offsetof(UDedicatedServerLiveOpsConfig, bKickCheaters) == 0x000059, "Member 'UDedicatedServerLiveOpsConfig::bKickCheaters' has a wrong offset!");
static_assert(offsetof(UDedicatedServerLiveOpsConfig, ActiveRuleset) == 0x00005A, "Member 'UDedicatedServerLiveOpsConfig::ActiveRuleset' has a wrong offset!");

// Class DeceiveInc.DefaultInventoryData
// 0x00B0 (0x00E8 - 0x0038)
class UDefaultInventoryData final : public UDIPrimaryDataAsset
{
public:
	TArray<class UAgentData*>                     DefaultAgents;                                     // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAgentSkinData*>                 DefaultAgentSkins;                                 // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UGadgetData*>                    DefaultGadgets;                                    // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAgentIntroPoseDataAsset*>       DefaultIntroPoses;                                 // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMenuWrapData*>                  DefaultWraps;                                      // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAgentWeaponData*>               DefaultWeaponMods;                                 // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAgentExpertiseSkillData*>       DefaultExpertiseMods;                              // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAgentPassiveSkillData*>         DefaultPassiveMods;                                // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAvatarDataAsset*>               DefaultAvatars;                                    // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UTitleDataAsset*>                DefaultTitles;                                     // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCallingCardDataAsset*>          DefaultCallingCards;                               // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefaultInventoryData">();
	}
	static class UDefaultInventoryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDefaultInventoryData>();
	}
};
static_assert(alignof(UDefaultInventoryData) == 0x000008, "Wrong alignment on UDefaultInventoryData");
static_assert(sizeof(UDefaultInventoryData) == 0x0000E8, "Wrong size on UDefaultInventoryData");
static_assert(offsetof(UDefaultInventoryData, DefaultAgents) == 0x000038, "Member 'UDefaultInventoryData::DefaultAgents' has a wrong offset!");
static_assert(offsetof(UDefaultInventoryData, DefaultAgentSkins) == 0x000048, "Member 'UDefaultInventoryData::DefaultAgentSkins' has a wrong offset!");
static_assert(offsetof(UDefaultInventoryData, DefaultGadgets) == 0x000058, "Member 'UDefaultInventoryData::DefaultGadgets' has a wrong offset!");
static_assert(offsetof(UDefaultInventoryData, DefaultIntroPoses) == 0x000068, "Member 'UDefaultInventoryData::DefaultIntroPoses' has a wrong offset!");
static_assert(offsetof(UDefaultInventoryData, DefaultWraps) == 0x000078, "Member 'UDefaultInventoryData::DefaultWraps' has a wrong offset!");
static_assert(offsetof(UDefaultInventoryData, DefaultWeaponMods) == 0x000088, "Member 'UDefaultInventoryData::DefaultWeaponMods' has a wrong offset!");
static_assert(offsetof(UDefaultInventoryData, DefaultExpertiseMods) == 0x000098, "Member 'UDefaultInventoryData::DefaultExpertiseMods' has a wrong offset!");
static_assert(offsetof(UDefaultInventoryData, DefaultPassiveMods) == 0x0000A8, "Member 'UDefaultInventoryData::DefaultPassiveMods' has a wrong offset!");
static_assert(offsetof(UDefaultInventoryData, DefaultAvatars) == 0x0000B8, "Member 'UDefaultInventoryData::DefaultAvatars' has a wrong offset!");
static_assert(offsetof(UDefaultInventoryData, DefaultTitles) == 0x0000C8, "Member 'UDefaultInventoryData::DefaultTitles' has a wrong offset!");
static_assert(offsetof(UDefaultInventoryData, DefaultCallingCards) == 0x0000D8, "Member 'UDefaultInventoryData::DefaultCallingCards' has a wrong offset!");

// Class DeceiveInc.DeployedShieldbrella
// 0x0010 (0x0328 - 0x0318)
class ADeployedShieldbrella final : public ABasePickablePlaceable
{
public:
	float                                         Lifetime;                                          // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31C[0xC];                                      // 0x031C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnShieldActivate(bool bActive);
	bool IsShieldActive();
	void NetMulticast_EnableShield(bool bEnable);
	void OnEMPIsAffectedChanged(bool bIsAffected, class AActor* AffectedActor);
	void OnLifeTimerEnd();
	void OnScramblerIsAffectedChanged(bool bIsAffected, class AActor* AffectedActor);
	void Server_EnableShield(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployedShieldbrella">();
	}
	static class ADeployedShieldbrella* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeployedShieldbrella>();
	}
};
static_assert(alignof(ADeployedShieldbrella) == 0x000008, "Wrong alignment on ADeployedShieldbrella");
static_assert(sizeof(ADeployedShieldbrella) == 0x000328, "Wrong size on ADeployedShieldbrella");
static_assert(offsetof(ADeployedShieldbrella, Lifetime) == 0x000318, "Member 'ADeployedShieldbrella::Lifetime' has a wrong offset!");

// Class DeceiveInc.DIAllowedGameModesHandler
// 0x0020 (0x0048 - 0x0028)
class UDIAllowedGameModesHandler final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FDescribeAllowedGameModesResponse GetAllowedGameModes();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIAllowedGameModesHandler">();
	}
	static class UDIAllowedGameModesHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIAllowedGameModesHandler>();
	}
};
static_assert(alignof(UDIAllowedGameModesHandler) == 0x000008, "Wrong alignment on UDIAllowedGameModesHandler");
static_assert(sizeof(UDIAllowedGameModesHandler) == 0x000048, "Wrong size on UDIAllowedGameModesHandler");

// Class DeceiveInc.DiAnimationMotionSet
// 0x00A0 (0x00D8 - 0x0038)
class UDiAnimationMotionSet : public UDIPrimaryDataAsset
{
public:
	TMap<class FName, class UAnimationAsset*>     AnimMotionSet;                                     // 0x0038(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class UBlendSpaceBase*>     AnimBlendSpaceSet;                                 // 0x0088(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	class UAnimationAsset* GetAnimMotionAsset(class FName MotionName) const;
	bool HasAnimMotion(class FName MotionName) const;
	bool TryGetAnimMotionBlendSpace(class FName MotionName, class UBlendSpaceBase** Destination) const;
	bool TryGetAnimMotionSequence(class FName MotionName, class UAnimSequence** Destination) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiAnimationMotionSet">();
	}
	static class UDiAnimationMotionSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiAnimationMotionSet>();
	}
};
static_assert(alignof(UDiAnimationMotionSet) == 0x000008, "Wrong alignment on UDiAnimationMotionSet");
static_assert(sizeof(UDiAnimationMotionSet) == 0x0000D8, "Wrong size on UDiAnimationMotionSet");
static_assert(offsetof(UDiAnimationMotionSet, AnimMotionSet) == 0x000038, "Member 'UDiAnimationMotionSet::AnimMotionSet' has a wrong offset!");
static_assert(offsetof(UDiAnimationMotionSet, AnimBlendSpaceSet) == 0x000088, "Member 'UDiAnimationMotionSet::AnimBlendSpaceSet' has a wrong offset!");

// Class DeceiveInc.DIAsyncLoadWrapper
// 0x0088 (0x00B0 - 0x0028)
class UDIAsyncLoadWrapper final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        AssetPath;                                         // 0x0038(0x0018)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SoftObjPtr;                                        // 0x0050(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 ClassHolder;                                       // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ObjectHolder;                                      // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x20];                                      // 0x0088(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OwnerActor;                                        // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIAsyncLoadWrapper">();
	}
	static class UDIAsyncLoadWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIAsyncLoadWrapper>();
	}
};
static_assert(alignof(UDIAsyncLoadWrapper) == 0x000008, "Wrong alignment on UDIAsyncLoadWrapper");
static_assert(sizeof(UDIAsyncLoadWrapper) == 0x0000B0, "Wrong size on UDIAsyncLoadWrapper");
static_assert(offsetof(UDIAsyncLoadWrapper, AssetPath) == 0x000038, "Member 'UDIAsyncLoadWrapper::AssetPath' has a wrong offset!");
static_assert(offsetof(UDIAsyncLoadWrapper, SoftObjPtr) == 0x000050, "Member 'UDIAsyncLoadWrapper::SoftObjPtr' has a wrong offset!");
static_assert(offsetof(UDIAsyncLoadWrapper, ClassHolder) == 0x000078, "Member 'UDIAsyncLoadWrapper::ClassHolder' has a wrong offset!");
static_assert(offsetof(UDIAsyncLoadWrapper, ObjectHolder) == 0x000080, "Member 'UDIAsyncLoadWrapper::ObjectHolder' has a wrong offset!");
static_assert(offsetof(UDIAsyncLoadWrapper, OwnerActor) == 0x0000A8, "Member 'UDIAsyncLoadWrapper::OwnerActor' has a wrong offset!");

// Class DeceiveInc.DIAssetManager
// 0x0198 (0x0610 - 0x0478)
class UDIAssetManager final : public UAssetManager
{
public:
	class USecurityLevelData*                     PreloadedSecurityLevelData;                        // 0x0478(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayResourcesData*                 PreloadedGameplayResourceData;                     // 0x0480(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStoreItemMappingData*                  PreloadedStoreItemMappingData;                     // 0x0488(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMenuData*                              PreloadedMenuData;                                 // 0x0490(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEncounterDataAsset*                    PreloadedEncounterData;                            // 0x0498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDefaultInventoryData*                  PreloadedDefaultInventoryData;                     // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDedicatedServerLiveOpsConfig*          PreloadedDedicatedServerLiveOpsConfig;             // 0x04A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraSubsystemPropertiesDAsset*       PreloadedCameraSubsystemProperties;                // 0x04B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIStyleDataAsset*                      PreloadedUIStyleData;                              // 0x04B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHitLocationData*                       PreloadedHitLocationData;                          // 0x04C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPeripheralChromaPatternDataAsset*      PreloadedPeripheralChromaPatternData;              // 0x04C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNavModeData*                           PreloadedNavModeData;                              // 0x04D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDILoadingSystemDataAsset*              PreloadedLoadingData;                              // 0x04D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPowerupData*                           PreloadedPowerupData;                              // 0x04E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObjectiveProximityData*                PreloadedObjectiveProximityData;                   // 0x04E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDIPlayerSettingsDataAsset*             PreloadedDIPlayerSettingsDataAsset;                // 0x04F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlatformDataAsset*                     PreloadedPlatformData;                             // 0x04F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCoverAffectingSourceDataAsset*         PreloadedCoverAffectingSourceData;                 // 0x0500(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTeamDataAsset*                         PreloadedTeamData;                                 // 0x0508(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDIStoreDataAsset*                      PreloadedStoreData;                                // 0x0510(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelInventoryData*                    PreloadedLevelInventoryData;                       // 0x0518(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDIXpEventDataAsset*                    PreloadedXpEventData;                              // 0x0520(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URewardBundleDataAsset*                 PreloadedRewardBundleData;                         // 0x0528(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_530[0x18];                                     // 0x0530(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDIAsyncLoadWrapper*>            LoadRequests;                                      // 0x0548(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UPrimaryDataAsset*>              MapDatas;                                          // 0x0558(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UInputAction*>                   InputActionDatas;                                  // 0x0568(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UDIMapList*                             GameMapLists;                                      // 0x0578(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPrimaryDataAsset*>              ModeData;                                          // 0x0580(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UPrimaryDataAsset*>              ProgressionData;                                   // 0x0590(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UPrimaryDataAsset*>              RewardData;                                        // 0x05A0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UDICurrencyType*>                CurrencyData;                                      // 0x05B0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UDIBalancingData*                       BalancingData;                                     // 0x05C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPingSystemDataAsset*                   PingSystemData;                                    // 0x05C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USBColPatchMetadata*                    ColPatchMeta;                                      // 0x05D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayableAgentList*                     PlayableAgents;                                    // 0x05D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAgentData*>                     AllAgentData;                                      // 0x05E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ULimitedEventItemsDataAsset*            LimitedEventItemsData;                             // 0x05F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ULimitedEventXpProgressionData*> LimitedEventsList;                                 // 0x05F8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_608[0x8];                                      // 0x0608(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ULimitedEventItemsDataAsset* GetLimitedEventItemsDataAsset();
	static class ULimitedEventXpProgressionData* GetLimitedEventProgression();
	static class UPingSystemDataAsset* GetPingSystemDataAsset();
	static class UProgressionRewardData* GetProgressionRewardByXpType(const class FString& XpType);

	void HandleActorEndPlay(class AActor* EndingActor, const EEndPlayReason EndPlayReason);

	bool NecessaryAssetLoadCompleted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIAssetManager">();
	}
	static class UDIAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIAssetManager>();
	}
};
static_assert(alignof(UDIAssetManager) == 0x000008, "Wrong alignment on UDIAssetManager");
static_assert(sizeof(UDIAssetManager) == 0x000610, "Wrong size on UDIAssetManager");
static_assert(offsetof(UDIAssetManager, PreloadedSecurityLevelData) == 0x000478, "Member 'UDIAssetManager::PreloadedSecurityLevelData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PreloadedGameplayResourceData) == 0x000480, "Member 'UDIAssetManager::PreloadedGameplayResourceData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PreloadedStoreItemMappingData) == 0x000488, "Member 'UDIAssetManager::PreloadedStoreItemMappingData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PreloadedMenuData) == 0x000490, "Member 'UDIAssetManager::PreloadedMenuData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PreloadedEncounterData) == 0x000498, "Member 'UDIAssetManager::PreloadedEncounterData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PreloadedDefaultInventoryData) == 0x0004A0, "Member 'UDIAssetManager::PreloadedDefaultInventoryData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PreloadedDedicatedServerLiveOpsConfig) == 0x0004A8, "Member 'UDIAssetManager::PreloadedDedicatedServerLiveOpsConfig' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PreloadedCameraSubsystemProperties) == 0x0004B0, "Member 'UDIAssetManager::PreloadedCameraSubsystemProperties' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PreloadedUIStyleData) == 0x0004B8, "Member 'UDIAssetManager::PreloadedUIStyleData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PreloadedHitLocationData) == 0x0004C0, "Member 'UDIAssetManager::PreloadedHitLocationData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PreloadedPeripheralChromaPatternData) == 0x0004C8, "Member 'UDIAssetManager::PreloadedPeripheralChromaPatternData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PreloadedNavModeData) == 0x0004D0, "Member 'UDIAssetManager::PreloadedNavModeData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PreloadedLoadingData) == 0x0004D8, "Member 'UDIAssetManager::PreloadedLoadingData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PreloadedPowerupData) == 0x0004E0, "Member 'UDIAssetManager::PreloadedPowerupData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PreloadedObjectiveProximityData) == 0x0004E8, "Member 'UDIAssetManager::PreloadedObjectiveProximityData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PreloadedDIPlayerSettingsDataAsset) == 0x0004F0, "Member 'UDIAssetManager::PreloadedDIPlayerSettingsDataAsset' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PreloadedPlatformData) == 0x0004F8, "Member 'UDIAssetManager::PreloadedPlatformData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PreloadedCoverAffectingSourceData) == 0x000500, "Member 'UDIAssetManager::PreloadedCoverAffectingSourceData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PreloadedTeamData) == 0x000508, "Member 'UDIAssetManager::PreloadedTeamData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PreloadedStoreData) == 0x000510, "Member 'UDIAssetManager::PreloadedStoreData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PreloadedLevelInventoryData) == 0x000518, "Member 'UDIAssetManager::PreloadedLevelInventoryData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PreloadedXpEventData) == 0x000520, "Member 'UDIAssetManager::PreloadedXpEventData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PreloadedRewardBundleData) == 0x000528, "Member 'UDIAssetManager::PreloadedRewardBundleData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, LoadRequests) == 0x000548, "Member 'UDIAssetManager::LoadRequests' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, MapDatas) == 0x000558, "Member 'UDIAssetManager::MapDatas' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, InputActionDatas) == 0x000568, "Member 'UDIAssetManager::InputActionDatas' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, GameMapLists) == 0x000578, "Member 'UDIAssetManager::GameMapLists' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, ModeData) == 0x000580, "Member 'UDIAssetManager::ModeData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, ProgressionData) == 0x000590, "Member 'UDIAssetManager::ProgressionData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, RewardData) == 0x0005A0, "Member 'UDIAssetManager::RewardData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, CurrencyData) == 0x0005B0, "Member 'UDIAssetManager::CurrencyData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, BalancingData) == 0x0005C0, "Member 'UDIAssetManager::BalancingData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PingSystemData) == 0x0005C8, "Member 'UDIAssetManager::PingSystemData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, ColPatchMeta) == 0x0005D0, "Member 'UDIAssetManager::ColPatchMeta' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, PlayableAgents) == 0x0005D8, "Member 'UDIAssetManager::PlayableAgents' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, AllAgentData) == 0x0005E0, "Member 'UDIAssetManager::AllAgentData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, LimitedEventItemsData) == 0x0005F0, "Member 'UDIAssetManager::LimitedEventItemsData' has a wrong offset!");
static_assert(offsetof(UDIAssetManager, LimitedEventsList) == 0x0005F8, "Member 'UDIAssetManager::LimitedEventsList' has a wrong offset!");

// Class DeceiveInc.DIAutomatedBotManager
// 0x0008 (0x0030 - 0x0028)
class UDIAutomatedBotManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIAutomatedBotManager">();
	}
	static class UDIAutomatedBotManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIAutomatedBotManager>();
	}
};
static_assert(alignof(UDIAutomatedBotManager) == 0x000008, "Wrong alignment on UDIAutomatedBotManager");
static_assert(sizeof(UDIAutomatedBotManager) == 0x000030, "Wrong size on UDIAutomatedBotManager");

// Class DeceiveInc.DIBalancingData
// 0x0030 (0x0068 - 0x0038)
class UDIBalancingData final : public UDIPrimaryDataAsset
{
public:
	TArray<class UDataTable*>                     BalancingTables;                                   // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         BalancingTablesScanPaths;                          // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           IgnoredAssets;                                     // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIBalancingData">();
	}
	static class UDIBalancingData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIBalancingData>();
	}
};
static_assert(alignof(UDIBalancingData) == 0x000008, "Wrong alignment on UDIBalancingData");
static_assert(sizeof(UDIBalancingData) == 0x000068, "Wrong size on UDIBalancingData");
static_assert(offsetof(UDIBalancingData, BalancingTables) == 0x000038, "Member 'UDIBalancingData::BalancingTables' has a wrong offset!");
static_assert(offsetof(UDIBalancingData, BalancingTablesScanPaths) == 0x000048, "Member 'UDIBalancingData::BalancingTablesScanPaths' has a wrong offset!");
static_assert(offsetof(UDIBalancingData, IgnoredAssets) == 0x000058, "Member 'UDIBalancingData::IgnoredAssets' has a wrong offset!");

// Class DeceiveInc.DICameraSubsystem
// 0x0168 (0x0198 - 0x0030)
class UDICameraSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x140];                                     // 0x0030(0x0140)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ADICameraLense>             CameraLenseBP;                                     // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADICameraLense*                         CameraLense;                                       // 0x0178(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_180[0x8];                                      // 0x0180(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                LastMenuWorldContextObject;                        // 0x0188(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                LastMenuCameraRef;                                 // 0x0190(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class ADICameraLense* GetCameraLense(const class UWorld* WorldIn);
	static void SB_RegisterCamera(class UObject* WorldContextObject, class UObject* CameraRefIn, ECameraPriority PriorityIn);
	static void SB_RegisterCameraWithTransition(class UObject* WorldContextObject, class UObject* CameraRefIn, ECameraPriority PriorityIn, float TransitionDuration, float InterpolationExp);
	static void SB_UnregisterCamera(class UObject* WorldContextObject, class UObject* CameraRefIn, ECameraPriority PriorityIn);
	static void SB_UnregisterCameraWithTransition(class UObject* WorldContextObject, class UObject* CameraRefIn, ECameraPriority PriorityIn, float TransitionDuration, float InterpolationExp);

	void OnCameraChangeEvent__DelegateSignature(class UObject* NewActiveCamera, ECameraPriority NewCameraPriority);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DICameraSubsystem">();
	}
	static class UDICameraSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDICameraSubsystem>();
	}
};
static_assert(alignof(UDICameraSubsystem) == 0x000008, "Wrong alignment on UDICameraSubsystem");
static_assert(sizeof(UDICameraSubsystem) == 0x000198, "Wrong size on UDICameraSubsystem");
static_assert(offsetof(UDICameraSubsystem, CameraLenseBP) == 0x000170, "Member 'UDICameraSubsystem::CameraLenseBP' has a wrong offset!");
static_assert(offsetof(UDICameraSubsystem, CameraLense) == 0x000178, "Member 'UDICameraSubsystem::CameraLense' has a wrong offset!");
static_assert(offsetof(UDICameraSubsystem, LastMenuWorldContextObject) == 0x000188, "Member 'UDICameraSubsystem::LastMenuWorldContextObject' has a wrong offset!");
static_assert(offsetof(UDICameraSubsystem, LastMenuCameraRef) == 0x000190, "Member 'UDICameraSubsystem::LastMenuCameraRef' has a wrong offset!");

// Class DeceiveInc.DiCharacterAnimInstance
// 0x00A0 (0x0360 - 0x02C0)
#pragma pack(push, 0x1)
class alignas(0x10) UDiCharacterAnimInstance : public UDiAnimInstance
{
public:
	class UAnimSequence*                          CrouchIdleMotion;                                  // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          IdleMotion;                                        // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          HurtMotion;                                        // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          DeathMotion;                                       // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          JumpStartMotion;                                   // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          JumpLandMotion;                                    // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          JumpInMotion;                                      // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          JumpFallLoopMotion;                                // 0x02F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          JumpFallInMotion;                                  // 0x0300(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          RotateRightMotion;                                 // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          RotateLeftMotion;                                  // 0x0310(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          MeleeInMotion;                                     // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          MeleeHitMotion;                                    // 0x0320(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          MeleeChargeInMotion;                               // 0x0328(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          MeleeChargeLoopMotion;                             // 0x0330(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          MeleeBeyondChargeHitMotion;                        // 0x0338(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          MeleeBeyondChargeInMotion;                         // 0x0340(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          MeleeBeyondChargeLoopMotion;                       // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpaceBase*                        MoveGroundBlendSpace;                              // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class ACharacter* TryGetCharacterOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiCharacterAnimInstance">();
	}
	static class UDiCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiCharacterAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UDiCharacterAnimInstance) == 0x000010, "Wrong alignment on UDiCharacterAnimInstance");
static_assert(sizeof(UDiCharacterAnimInstance) == 0x000360, "Wrong size on UDiCharacterAnimInstance");
static_assert(offsetof(UDiCharacterAnimInstance, CrouchIdleMotion) == 0x0002C0, "Member 'UDiCharacterAnimInstance::CrouchIdleMotion' has a wrong offset!");
static_assert(offsetof(UDiCharacterAnimInstance, IdleMotion) == 0x0002C8, "Member 'UDiCharacterAnimInstance::IdleMotion' has a wrong offset!");
static_assert(offsetof(UDiCharacterAnimInstance, HurtMotion) == 0x0002D0, "Member 'UDiCharacterAnimInstance::HurtMotion' has a wrong offset!");
static_assert(offsetof(UDiCharacterAnimInstance, DeathMotion) == 0x0002D8, "Member 'UDiCharacterAnimInstance::DeathMotion' has a wrong offset!");
static_assert(offsetof(UDiCharacterAnimInstance, JumpStartMotion) == 0x0002E0, "Member 'UDiCharacterAnimInstance::JumpStartMotion' has a wrong offset!");
static_assert(offsetof(UDiCharacterAnimInstance, JumpLandMotion) == 0x0002E8, "Member 'UDiCharacterAnimInstance::JumpLandMotion' has a wrong offset!");
static_assert(offsetof(UDiCharacterAnimInstance, JumpInMotion) == 0x0002F0, "Member 'UDiCharacterAnimInstance::JumpInMotion' has a wrong offset!");
static_assert(offsetof(UDiCharacterAnimInstance, JumpFallLoopMotion) == 0x0002F8, "Member 'UDiCharacterAnimInstance::JumpFallLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiCharacterAnimInstance, JumpFallInMotion) == 0x000300, "Member 'UDiCharacterAnimInstance::JumpFallInMotion' has a wrong offset!");
static_assert(offsetof(UDiCharacterAnimInstance, RotateRightMotion) == 0x000308, "Member 'UDiCharacterAnimInstance::RotateRightMotion' has a wrong offset!");
static_assert(offsetof(UDiCharacterAnimInstance, RotateLeftMotion) == 0x000310, "Member 'UDiCharacterAnimInstance::RotateLeftMotion' has a wrong offset!");
static_assert(offsetof(UDiCharacterAnimInstance, MeleeInMotion) == 0x000318, "Member 'UDiCharacterAnimInstance::MeleeInMotion' has a wrong offset!");
static_assert(offsetof(UDiCharacterAnimInstance, MeleeHitMotion) == 0x000320, "Member 'UDiCharacterAnimInstance::MeleeHitMotion' has a wrong offset!");
static_assert(offsetof(UDiCharacterAnimInstance, MeleeChargeInMotion) == 0x000328, "Member 'UDiCharacterAnimInstance::MeleeChargeInMotion' has a wrong offset!");
static_assert(offsetof(UDiCharacterAnimInstance, MeleeChargeLoopMotion) == 0x000330, "Member 'UDiCharacterAnimInstance::MeleeChargeLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiCharacterAnimInstance, MeleeBeyondChargeHitMotion) == 0x000338, "Member 'UDiCharacterAnimInstance::MeleeBeyondChargeHitMotion' has a wrong offset!");
static_assert(offsetof(UDiCharacterAnimInstance, MeleeBeyondChargeInMotion) == 0x000340, "Member 'UDiCharacterAnimInstance::MeleeBeyondChargeInMotion' has a wrong offset!");
static_assert(offsetof(UDiCharacterAnimInstance, MeleeBeyondChargeLoopMotion) == 0x000348, "Member 'UDiCharacterAnimInstance::MeleeBeyondChargeLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiCharacterAnimInstance, MoveGroundBlendSpace) == 0x000350, "Member 'UDiCharacterAnimInstance::MoveGroundBlendSpace' has a wrong offset!");

// Class DeceiveInc.SasoriPassiveAbility
// 0x0028 (0x0558 - 0x0530)
class ASasoriPassiveAbility : public ABaseSpyPassiveAbility
{
public:
	TArray<TSoftClassPtr<class UClass>>           PoisonVictimEffectClass;                           // 0x0530(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           PoisonVictimEffectClassSpies;                      // 0x0540(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bReplacesEffect;                                   // 0x0550(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_551[0x7];                                      // 0x0551(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SasoriPassiveAbility">();
	}
	static class ASasoriPassiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASasoriPassiveAbility>();
	}
};
static_assert(alignof(ASasoriPassiveAbility) == 0x000008, "Wrong alignment on ASasoriPassiveAbility");
static_assert(sizeof(ASasoriPassiveAbility) == 0x000558, "Wrong size on ASasoriPassiveAbility");
static_assert(offsetof(ASasoriPassiveAbility, PoisonVictimEffectClass) == 0x000530, "Member 'ASasoriPassiveAbility::PoisonVictimEffectClass' has a wrong offset!");
static_assert(offsetof(ASasoriPassiveAbility, PoisonVictimEffectClassSpies) == 0x000540, "Member 'ASasoriPassiveAbility::PoisonVictimEffectClassSpies' has a wrong offset!");
static_assert(offsetof(ASasoriPassiveAbility, bReplacesEffect) == 0x000550, "Member 'ASasoriPassiveAbility::bReplacesEffect' has a wrong offset!");

// Class DeceiveInc.DICharacterMovementComponent
// 0x01E0 (0x0310 - 0x0130)
#pragma pack(push, 0x1)
class alignas(0x10) UDICharacterMovementComponent : public UNavMovementComponent
{
public:
	class ANPCCharacter*                          CharacterOwner;                                    // 0x0130(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        DeferredUpdatedMoveComponent;                      // 0x0138(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENPCMovementStatus                            MovementStatus;                                    // 0x0140(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_141[0x3];                                      // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNPCFindFloorResult                    CurrentFloor;                                      // 0x0144(0x0094)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         MaxStepHeight;                                     // 0x01D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSimulationTimeStep;                             // 0x01DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAlwaysCheckFloor : 1;                             // 0x01E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bJustTeleported : 1;                               // 0x01E0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bForceNextFloorCheck : 1;                          // 0x01E0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bForceMaxAccel : 1;                                // 0x01E0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1E1[0x3];                                      // 0x01E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnalogInputModifier;                               // 0x01E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrakingFrictionFactor;                             // 0x01E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrakingSubStepTime;                                // 0x01EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GroundFriction;                                    // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Acceleration;                                      // 0x01F4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FQuat                                  LastUpdateRotation;                                // 0x0200(0x0010)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                LastUpdateLocation;                                // 0x0210(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LastUpdateVelocity;                                // 0x021C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PendingImpulseToApply;                             // 0x0228(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PendingForceToApply;                               // 0x0234(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PendingLaunchVelocity;                             // 0x0240(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WalkableFloorAngle;                                // 0x024C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WalkableFloorZ;                                    // 0x0250(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUseFlatBaseForFloorChecks : 1;                    // 0x0254(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_255[0x3];                                      // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PerchRadiusThreshold;                              // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PerchAdditionalHeight;                             // 0x025C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bMaintainHorizontalGroundVelocity : 1;             // 0x0260(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bImpartBaseVelocityX : 1;                          // 0x0260(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bImpartBaseVelocityY : 1;                          // 0x0260(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bImpartBaseVelocityZ : 1;                          // 0x0260(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bImpartBaseAngularVelocity : 1;                    // 0x0260(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bMovementInProgress : 1;                           // 0x0260(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDeferUpdateMoveComponent : 1;                     // 0x0260(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnablePhysicsInteraction : 1;                     // 0x0260(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_261[0x3];                                      // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TouchForceFactor;                                  // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTouchForce;                                     // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxTouchForce;                                     // 0x026C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RepulsionForce;                                    // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxSimulationIterations;                           // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAcceleration;                                   // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AirControl;                                        // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AirControlBoostMultiplier;                         // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AirControlBoostVelocityThreshold;                  // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FallingLateralFriction;                            // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bNotifyApex : 1;                                   // 0x028C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_28D[0x3];                                      // 0x028D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialPushForceFactor;                            // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PushForceFactor;                                   // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpZVelocity;                                     // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Mass;                                              // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0[0x68];                                     // 0x02A0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddImpulse(const struct FVector& Impulse, bool bVelocityChange);
	void AddSlowSource(class AActor* NewSlowSource, float NewSlowPercent);
	void CalcVelocity(float DeltaTime, float Friction, bool bFluid, float BrakingDeceleration);
	void CapsuleTouched(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void ClearAccumulatedForces();
	void ClearVelocityAndAccumulatedForces();
	void RemoveSlowSource(class AActor* SlowSourceToRemove);
	void SetWalkableFloorAngle(float InWalkableFloorAngle);
	void SetWalkableFloorZ(float InWalkableFloorZ);

	struct FVector GetImpartedMovementBaseVelocity() const;
	float GetMaxAcceleration() const;
	float GetMaxBrakingDeceleration() const;
	float GetPerchRadiusThreshold() const;
	float GetValidPerchRadius() const;
	bool IsWalkable(const struct FHitResult& Hit) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DICharacterMovementComponent">();
	}
	static class UDICharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDICharacterMovementComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UDICharacterMovementComponent) == 0x000010, "Wrong alignment on UDICharacterMovementComponent");
static_assert(sizeof(UDICharacterMovementComponent) == 0x000310, "Wrong size on UDICharacterMovementComponent");
static_assert(offsetof(UDICharacterMovementComponent, CharacterOwner) == 0x000130, "Member 'UDICharacterMovementComponent::CharacterOwner' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, DeferredUpdatedMoveComponent) == 0x000138, "Member 'UDICharacterMovementComponent::DeferredUpdatedMoveComponent' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, MovementStatus) == 0x000140, "Member 'UDICharacterMovementComponent::MovementStatus' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, CurrentFloor) == 0x000144, "Member 'UDICharacterMovementComponent::CurrentFloor' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, MaxStepHeight) == 0x0001D8, "Member 'UDICharacterMovementComponent::MaxStepHeight' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, MaxSimulationTimeStep) == 0x0001DC, "Member 'UDICharacterMovementComponent::MaxSimulationTimeStep' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, AnalogInputModifier) == 0x0001E4, "Member 'UDICharacterMovementComponent::AnalogInputModifier' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, BrakingFrictionFactor) == 0x0001E8, "Member 'UDICharacterMovementComponent::BrakingFrictionFactor' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, BrakingSubStepTime) == 0x0001EC, "Member 'UDICharacterMovementComponent::BrakingSubStepTime' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, GroundFriction) == 0x0001F0, "Member 'UDICharacterMovementComponent::GroundFriction' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, Acceleration) == 0x0001F4, "Member 'UDICharacterMovementComponent::Acceleration' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, LastUpdateRotation) == 0x000200, "Member 'UDICharacterMovementComponent::LastUpdateRotation' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, LastUpdateLocation) == 0x000210, "Member 'UDICharacterMovementComponent::LastUpdateLocation' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, LastUpdateVelocity) == 0x00021C, "Member 'UDICharacterMovementComponent::LastUpdateVelocity' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, PendingImpulseToApply) == 0x000228, "Member 'UDICharacterMovementComponent::PendingImpulseToApply' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, PendingForceToApply) == 0x000234, "Member 'UDICharacterMovementComponent::PendingForceToApply' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, PendingLaunchVelocity) == 0x000240, "Member 'UDICharacterMovementComponent::PendingLaunchVelocity' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, WalkableFloorAngle) == 0x00024C, "Member 'UDICharacterMovementComponent::WalkableFloorAngle' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, WalkableFloorZ) == 0x000250, "Member 'UDICharacterMovementComponent::WalkableFloorZ' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, PerchRadiusThreshold) == 0x000258, "Member 'UDICharacterMovementComponent::PerchRadiusThreshold' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, PerchAdditionalHeight) == 0x00025C, "Member 'UDICharacterMovementComponent::PerchAdditionalHeight' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, TouchForceFactor) == 0x000264, "Member 'UDICharacterMovementComponent::TouchForceFactor' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, MinTouchForce) == 0x000268, "Member 'UDICharacterMovementComponent::MinTouchForce' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, MaxTouchForce) == 0x00026C, "Member 'UDICharacterMovementComponent::MaxTouchForce' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, RepulsionForce) == 0x000270, "Member 'UDICharacterMovementComponent::RepulsionForce' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, MaxSimulationIterations) == 0x000274, "Member 'UDICharacterMovementComponent::MaxSimulationIterations' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, MaxAcceleration) == 0x000278, "Member 'UDICharacterMovementComponent::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, AirControl) == 0x00027C, "Member 'UDICharacterMovementComponent::AirControl' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, AirControlBoostMultiplier) == 0x000280, "Member 'UDICharacterMovementComponent::AirControlBoostMultiplier' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, AirControlBoostVelocityThreshold) == 0x000284, "Member 'UDICharacterMovementComponent::AirControlBoostVelocityThreshold' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, FallingLateralFriction) == 0x000288, "Member 'UDICharacterMovementComponent::FallingLateralFriction' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, InitialPushForceFactor) == 0x000290, "Member 'UDICharacterMovementComponent::InitialPushForceFactor' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, PushForceFactor) == 0x000294, "Member 'UDICharacterMovementComponent::PushForceFactor' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, JumpZVelocity) == 0x000298, "Member 'UDICharacterMovementComponent::JumpZVelocity' has a wrong offset!");
static_assert(offsetof(UDICharacterMovementComponent, Mass) == 0x00029C, "Member 'UDICharacterMovementComponent::Mass' has a wrong offset!");

// Class DeceiveInc.DiChatRoom
// 0x0038 (0x0060 - 0x0028)
class UDiChatRoom : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMembershipChange;                                // 0x0038(0x0010)(ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 CachedGameWorld;                                   // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiChatRoom">();
	}
	static class UDiChatRoom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiChatRoom>();
	}
};
static_assert(alignof(UDiChatRoom) == 0x000008, "Wrong alignment on UDiChatRoom");
static_assert(sizeof(UDiChatRoom) == 0x000060, "Wrong size on UDiChatRoom");
static_assert(offsetof(UDiChatRoom, OnMembershipChange) == 0x000038, "Member 'UDiChatRoom::OnMembershipChange' has a wrong offset!");
static_assert(offsetof(UDiChatRoom, CachedGameWorld) == 0x000058, "Member 'UDiChatRoom::CachedGameWorld' has a wrong offset!");

// Class DeceiveInc.DiFactionChatRoom
// 0x0000 (0x0060 - 0x0060)
class UDiFactionChatRoom final : public UDiChatRoom
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiFactionChatRoom">();
	}
	static class UDiFactionChatRoom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiFactionChatRoom>();
	}
};
static_assert(alignof(UDiFactionChatRoom) == 0x000008, "Wrong alignment on UDiFactionChatRoom");
static_assert(sizeof(UDiFactionChatRoom) == 0x000060, "Wrong size on UDiFactionChatRoom");

// Class DeceiveInc.SasoriActiveInterface
// 0x0000 (0x0028 - 0x0028)
class ISasoriActiveInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SasoriActiveInterface">();
	}
	static class ISasoriActiveInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISasoriActiveInterface>();
	}
};
static_assert(alignof(ISasoriActiveInterface) == 0x000008, "Wrong alignment on ISasoriActiveInterface");
static_assert(sizeof(ISasoriActiveInterface) == 0x000028, "Wrong size on ISasoriActiveInterface");

// Class DeceiveInc.CheckRuleApply_EnabledByRule
// 0x0008 (0x0030 - 0x0028)
class UCheckRuleApply_EnabledByRule final : public UCheckRuleApply_Base
{
public:
	int32                                         EnabledByRules;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheckRuleApply_EnabledByRule">();
	}
	static class UCheckRuleApply_EnabledByRule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheckRuleApply_EnabledByRule>();
	}
};
static_assert(alignof(UCheckRuleApply_EnabledByRule) == 0x000008, "Wrong alignment on UCheckRuleApply_EnabledByRule");
static_assert(sizeof(UCheckRuleApply_EnabledByRule) == 0x000030, "Wrong size on UCheckRuleApply_EnabledByRule");
static_assert(offsetof(UCheckRuleApply_EnabledByRule, EnabledByRules) == 0x000028, "Member 'UCheckRuleApply_EnabledByRule::EnabledByRules' has a wrong offset!");

// Class DeceiveInc.JammableEntity
// 0x0000 (0x0028 - 0x0028)
class IJammableEntity final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JammableEntity">();
	}
	static class IJammableEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJammableEntity>();
	}
};
static_assert(alignof(IJammableEntity) == 0x000008, "Wrong alignment on IJammableEntity");
static_assert(sizeof(IJammableEntity) == 0x000028, "Wrong size on IJammableEntity");

// Class DeceiveInc.DIClientSession
// 0x0028 (0x0050 - 0x0028)
class UDIClientSession final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIClientSession">();
	}
	static class UDIClientSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIClientSession>();
	}
};
static_assert(alignof(UDIClientSession) == 0x000008, "Wrong alignment on UDIClientSession");
static_assert(sizeof(UDIClientSession) == 0x000050, "Wrong size on UDIClientSession");

// Class DeceiveInc.MatchmakerImpl
// 0x0038 (0x0068 - 0x0030)
class UMatchmakerImpl : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMatchmakingStarted;                              // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMatchmakingError;                                // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSessionMatchmakingStatusChanged;                 // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchmakerImpl">();
	}
	static class UMatchmakerImpl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchmakerImpl>();
	}
};
static_assert(alignof(UMatchmakerImpl) == 0x000008, "Wrong alignment on UMatchmakerImpl");
static_assert(sizeof(UMatchmakerImpl) == 0x000068, "Wrong size on UMatchmakerImpl");
static_assert(offsetof(UMatchmakerImpl, OnMatchmakingStarted) == 0x000038, "Member 'UMatchmakerImpl::OnMatchmakingStarted' has a wrong offset!");
static_assert(offsetof(UMatchmakerImpl, OnMatchmakingError) == 0x000048, "Member 'UMatchmakerImpl::OnMatchmakingError' has a wrong offset!");
static_assert(offsetof(UMatchmakerImpl, OnSessionMatchmakingStatusChanged) == 0x000058, "Member 'UMatchmakerImpl::OnSessionMatchmakingStatusChanged' has a wrong offset!");

// Class DeceiveInc.EncounterParticipant
// 0x0048 (0x0070 - 0x0028)
class UEncounterParticipant final : public UObject
{
public:
	uint8                                         Pad_28[0x40];                                      // 0x0028(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UEncounter*                             Encounter;                                         // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EncounterParticipant">();
	}
	static class UEncounterParticipant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEncounterParticipant>();
	}
};
static_assert(alignof(UEncounterParticipant) == 0x000008, "Wrong alignment on UEncounterParticipant");
static_assert(sizeof(UEncounterParticipant) == 0x000070, "Wrong size on UEncounterParticipant");
static_assert(offsetof(UEncounterParticipant, Encounter) == 0x000068, "Member 'UEncounterParticipant::Encounter' has a wrong offset!");

// Class DeceiveInc.DIClientWebServiceSession
// 0x0348 (0x03B0 - 0x0068)
class UDIClientWebServiceSession final : public UMatchmakerImpl
{
public:
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDIMatchmakingTokenHandler*             MatchmakingTokenHandler;                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UDIMatchmakingTokenHandler*>     OldHandlers;                                       // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x90];                                      // 0x0090(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsLoggedInAsGuest;                                // 0x0120(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDIClientSession*                       Session;                                           // 0x0128(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDIClientSession*>               OldSessions;                                       // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UDIAllowedGameModesHandler*             AllowedGameModesHandler;                           // 0x0140(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSessionLoginCompleted;                           // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDoSignAgreementResponse;                         // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDoFetchAgreementResponse;                        // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnClaimLootBundleResponseDelegate;                 // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnConsumeItemResponseDelegate;                     // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBuyItemResponse;                                 // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStoreQueryCompleteDelegate;                      // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B8[0x20];                                     // 0x01B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDIPrivateLobbyInfo                    CachedPrivateLobbyInfo;                            // 0x01D8(0x00C8)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0[0x110];                                    // 0x02A0(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsErrorStatus(EDescribeMatchmakingStatus StatusToCheck);
	static bool IsSearchEndedStatus(EDescribeMatchmakingStatus StatusToCheck);
	static bool IsSearchingStatus(EDescribeMatchmakingStatus StatusToCheck);

	void BuyItem(const class FString& ItemId, const class FString& CurrencyId);
	void BuyItemNoConf(const class FString& ItemId, const class FString& CurrencyId);
	void CheatClaimFakeLootBundle();
	void ClaimLootBundle(const class FString& LootBundleId);
	void ConsumeItem(const class FString& ItemId);
	void ConsumeXPBooster();
	void DoFetchAgreement(const class FString& AgreementName);
	void DoRefresh();
	void DoSignAgreement(const class FString& AgreementName);
	void FetchBalancingData();
	void FetchClientConfig();
	void FetchClock();
	void FetchItemsConfig();
	void FetchShopConfig();
	struct FBuyItemInfo GetCurrentItemToBuy();
	bool GetPlatformPurchaseItemMap(const class FString& Key, struct FPlatformPurchaseMapping* OutResult);
	class FString GetSesssionId();
	void HandleBooleanPlayerSettingChange(EPlayerSettingsType SettingType, bool NewValue);
	void HandleIntegerPlayerSettingChange(EPlayerSettingsType SettingType, int32 NewValue);
	void HandleMatchmakingStatusChanged(EDescribeMatchmakingStatus NewState);
	void HandleMenuEvent(const class FString& EventName, bool AnswerValue);
	bool IsClientSessionValid();
	void OnMatchmakingFailed(EMatchmakingError MatchmakingError);
	void OnMatchmakingSuccess(const struct FDescribeMatchmakingResponse& MatchDescription);
	void OnMatchmakingTokenChanged(const class FString& MatchmakingToken);
	void OnPartyMatchmakingTicketReceived(const class FString& MatchmakingTicketId);
	void OnPartyMembersChanged();
	void OnSessionLogin(const struct FLoginResponse& LoginResponse);
	void OnSessionRefresh(const struct FSessionRefreshResponse& SessionRefreshResponse);
	void PostLoadMapDelegate(class UWorld* World);
	void SendReport(const class FString& Reporter, const class FString& ReporteeAccelbyteId, const class FString& Message, const class FString& MatchId);
	void StartPlatformTransaction(const class FString& KeyMap);
	void StartSteamTransaction(int32 SteamShopItemId);
	void StartTwitchOauthFlow();
	void UnlinkTwitchAccount();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIClientWebServiceSession">();
	}
	static class UDIClientWebServiceSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIClientWebServiceSession>();
	}
};
static_assert(alignof(UDIClientWebServiceSession) == 0x000008, "Wrong alignment on UDIClientWebServiceSession");
static_assert(sizeof(UDIClientWebServiceSession) == 0x0003B0, "Wrong size on UDIClientWebServiceSession");
static_assert(offsetof(UDIClientWebServiceSession, MatchmakingTokenHandler) == 0x000078, "Member 'UDIClientWebServiceSession::MatchmakingTokenHandler' has a wrong offset!");
static_assert(offsetof(UDIClientWebServiceSession, OldHandlers) == 0x000080, "Member 'UDIClientWebServiceSession::OldHandlers' has a wrong offset!");
static_assert(offsetof(UDIClientWebServiceSession, bIsLoggedInAsGuest) == 0x000120, "Member 'UDIClientWebServiceSession::bIsLoggedInAsGuest' has a wrong offset!");
static_assert(offsetof(UDIClientWebServiceSession, Session) == 0x000128, "Member 'UDIClientWebServiceSession::Session' has a wrong offset!");
static_assert(offsetof(UDIClientWebServiceSession, OldSessions) == 0x000130, "Member 'UDIClientWebServiceSession::OldSessions' has a wrong offset!");
static_assert(offsetof(UDIClientWebServiceSession, AllowedGameModesHandler) == 0x000140, "Member 'UDIClientWebServiceSession::AllowedGameModesHandler' has a wrong offset!");
static_assert(offsetof(UDIClientWebServiceSession, OnSessionLoginCompleted) == 0x000148, "Member 'UDIClientWebServiceSession::OnSessionLoginCompleted' has a wrong offset!");
static_assert(offsetof(UDIClientWebServiceSession, OnDoSignAgreementResponse) == 0x000158, "Member 'UDIClientWebServiceSession::OnDoSignAgreementResponse' has a wrong offset!");
static_assert(offsetof(UDIClientWebServiceSession, OnDoFetchAgreementResponse) == 0x000168, "Member 'UDIClientWebServiceSession::OnDoFetchAgreementResponse' has a wrong offset!");
static_assert(offsetof(UDIClientWebServiceSession, OnClaimLootBundleResponseDelegate) == 0x000178, "Member 'UDIClientWebServiceSession::OnClaimLootBundleResponseDelegate' has a wrong offset!");
static_assert(offsetof(UDIClientWebServiceSession, OnConsumeItemResponseDelegate) == 0x000188, "Member 'UDIClientWebServiceSession::OnConsumeItemResponseDelegate' has a wrong offset!");
static_assert(offsetof(UDIClientWebServiceSession, OnBuyItemResponse) == 0x000198, "Member 'UDIClientWebServiceSession::OnBuyItemResponse' has a wrong offset!");
static_assert(offsetof(UDIClientWebServiceSession, OnStoreQueryCompleteDelegate) == 0x0001A8, "Member 'UDIClientWebServiceSession::OnStoreQueryCompleteDelegate' has a wrong offset!");
static_assert(offsetof(UDIClientWebServiceSession, CachedPrivateLobbyInfo) == 0x0001D8, "Member 'UDIClientWebServiceSession::CachedPrivateLobbyInfo' has a wrong offset!");

// Class DeceiveInc.DICurrencyType
// 0x0038 (0x0070 - 0x0038)
class UDICurrencyType final : public UDIPrimaryDataAsset
{
public:
	class FText                                   CurrencyName;                                      // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CurrencyDescription;                               // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         CurrencyMaxAmount;                                 // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DICurrencyType">();
	}
	static class UDICurrencyType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDICurrencyType>();
	}
};
static_assert(alignof(UDICurrencyType) == 0x000008, "Wrong alignment on UDICurrencyType");
static_assert(sizeof(UDICurrencyType) == 0x000070, "Wrong size on UDICurrencyType");
static_assert(offsetof(UDICurrencyType, CurrencyName) == 0x000038, "Member 'UDICurrencyType::CurrencyName' has a wrong offset!");
static_assert(offsetof(UDICurrencyType, CurrencyDescription) == 0x000050, "Member 'UDICurrencyType::CurrencyDescription' has a wrong offset!");
static_assert(offsetof(UDICurrencyType, CurrencyMaxAmount) == 0x000068, "Member 'UDICurrencyType::CurrencyMaxAmount' has a wrong offset!");

// Class DeceiveInc.DIDataStoreBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UDIDataStoreBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetAccountXpType();
	static struct FPingInfo GetActorPingInfo(class AActor* PingedActor);
	static class UAgentData* GetAgentDataById(const struct FPrimaryAssetId& PrimaryAssetId);
	static class UAgentData* GetAgentDataByPrimaryAssetName(const class FString& PrimaryAssetName);
	static class UAgentIntroPoseDataAsset* GetAgentIntroPoseDataById(const struct FPrimaryAssetId& PrimaryAssetId);
	static class UAgentSkinData* GetAgentSkinDataById(const struct FPrimaryAssetId& PrimaryAssetId);
	static TArray<class UAgentData*> GetAllAgentData();
	static class UAvatarDataAsset* GetAvatarDataById(const struct FPrimaryAssetId& PrimaryAssetId);
	static class FString GetCatalogueXpType();
	static class UCoverAffectingSourceDataAsset* GetCoverAffectingSourceData();
	static class UDICurrencyType* GetCurrencyData(const struct FPrimaryAssetId& PrimaryAssetId);
	static class UAgentExpertiseSkillData* GetExpertiseSkillDataById(const struct FPrimaryAssetId& PrimaryAssetId);
	static class UGadgetData* GetGadgetDataById(const struct FPrimaryAssetId& PrimaryAssetId);
	static class ULevelInventoryData* GetLevelInventoryData();
	static class UAgentPassiveSkillData* GetPassiveSkillDataById(const struct FPrimaryAssetId& PrimaryAssetId);
	static class UPlatformDataAsset* GetPlatformData();
	static struct FPingInfo GetRadialPingInfoByIndex(int32 Index_0);
	static struct FColor GetSecurityLevelColor(const ESecurityLevel& SecurityLevel);
	static class UTeamDataAsset* GetTeamData();
	static class UTitleDataAsset* GetTitleDataById(const struct FPrimaryAssetId& PrimaryAssetId);
	static class UAgentWeaponData* GetWeaponDataById(const struct FPrimaryAssetId& PrimaryAssetId);
	static class UDIXpEventDataAsset* GetXpEventData();
	static class UXpProgressionData* GetXpProgressionData(EXpProgressionType ProgressionType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIDataStoreBlueprintLibrary">();
	}
	static class UDIDataStoreBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIDataStoreBlueprintLibrary>();
	}
};
static_assert(alignof(UDIDataStoreBlueprintLibrary) == 0x000008, "Wrong alignment on UDIDataStoreBlueprintLibrary");
static_assert(sizeof(UDIDataStoreBlueprintLibrary) == 0x000028, "Wrong size on UDIDataStoreBlueprintLibrary");

// Class DeceiveInc.DIDemoNetDriver
// 0x0010 (0x12E8 - 0x12D8)
class UDIDemoNetDriver final : public UDemoNetDriver
{
public:
	uint8                                         Pad_12D8[0x10];                                    // 0x12D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIDemoNetDriver">();
	}
	static class UDIDemoNetDriver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIDemoNetDriver>();
	}
};
static_assert(alignof(UDIDemoNetDriver) == 0x000008, "Wrong alignment on UDIDemoNetDriver");
static_assert(sizeof(UDIDemoNetDriver) == 0x0012E8, "Wrong size on UDIDemoNetDriver");

// Class DeceiveInc.EMPSphere
// 0x0050 (0x0280 - 0x0230)
class AEMPSphere final : public ABaseSphereActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAttachToVictim;                                  // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USphereComponent*                       RegistrationCollisionShapeComp;                    // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlowPercent;                                       // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoverDrainSpeed;                                   // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAffectFriends;                                    // 0x0258(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanAttachToVictim;                                // 0x0259(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25A[0x2];                                      // 0x025A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   VictimSocketName;                                  // 0x025C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EMPDurationWhenAttach;                             // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 HitVictim;                                         // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleActorDamaged(class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, float RawDamage);
	void NetMulticast_OnAttachToVictim(class AActor* Victim);
	void OnEMPSphereBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEMPSphereEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void SetVictim(class AActor* NewOwner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EMPSphere">();
	}
	static class AEMPSphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEMPSphere>();
	}
};
static_assert(alignof(AEMPSphere) == 0x000008, "Wrong alignment on AEMPSphere");
static_assert(sizeof(AEMPSphere) == 0x000280, "Wrong size on AEMPSphere");
static_assert(offsetof(AEMPSphere, OnAttachToVictim) == 0x000238, "Member 'AEMPSphere::OnAttachToVictim' has a wrong offset!");
static_assert(offsetof(AEMPSphere, RegistrationCollisionShapeComp) == 0x000248, "Member 'AEMPSphere::RegistrationCollisionShapeComp' has a wrong offset!");
static_assert(offsetof(AEMPSphere, SlowPercent) == 0x000250, "Member 'AEMPSphere::SlowPercent' has a wrong offset!");
static_assert(offsetof(AEMPSphere, CoverDrainSpeed) == 0x000254, "Member 'AEMPSphere::CoverDrainSpeed' has a wrong offset!");
static_assert(offsetof(AEMPSphere, bAffectFriends) == 0x000258, "Member 'AEMPSphere::bAffectFriends' has a wrong offset!");
static_assert(offsetof(AEMPSphere, bCanAttachToVictim) == 0x000259, "Member 'AEMPSphere::bCanAttachToVictim' has a wrong offset!");
static_assert(offsetof(AEMPSphere, VictimSocketName) == 0x00025C, "Member 'AEMPSphere::VictimSocketName' has a wrong offset!");
static_assert(offsetof(AEMPSphere, EMPDurationWhenAttach) == 0x000264, "Member 'AEMPSphere::EMPDurationWhenAttach' has a wrong offset!");
static_assert(offsetof(AEMPSphere, HitVictim) == 0x000268, "Member 'AEMPSphere::HitVictim' has a wrong offset!");

// Class DeceiveInc.DIEndScreenMenuUserWidget
// 0x0010 (0x0310 - 0x0300)
class UDIEndScreenMenuUserWidget final : public UDIMenuUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnTriggerExfilCarAnim;                             // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	void TriggerCarExfil();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIEndScreenMenuUserWidget">();
	}
	static class UDIEndScreenMenuUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIEndScreenMenuUserWidget>();
	}
};
static_assert(alignof(UDIEndScreenMenuUserWidget) == 0x000008, "Wrong alignment on UDIEndScreenMenuUserWidget");
static_assert(sizeof(UDIEndScreenMenuUserWidget) == 0x000310, "Wrong size on UDIEndScreenMenuUserWidget");
static_assert(offsetof(UDIEndScreenMenuUserWidget, OnTriggerExfilCarAnim) == 0x000300, "Member 'UDIEndScreenMenuUserWidget::OnTriggerExfilCarAnim' has a wrong offset!");

// Class DeceiveInc.DIFactionsManager
// 0x0058 (0x0088 - 0x0030)
class UDIFactionsManager final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnFactionDataUpdate;                               // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FFactionData                           InternalData;                                      // 0x0040(0x0028)(Protected, NativeAccessSpecifierProtected)
	struct FFactionPlan                           FactionPlan;                                       // 0x0068(0x0018)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool BP_IsFreeForAll(class UObject* WorldContextObject);
	static int32 GetFactionId(const class AActor* ToCheck);

	TArray<class ADIPlayerState*> GetFactionMembers(uint8 FactionID);
	int32 GetFactionMembersIndex(class ADIPlayerState* Player);
	uint8 GetFactionSize();
	TArray<class ADIPlayerState*> GetPlayerFactionMembers(class ADIPlayerState* Player);
	void HandleNameChange(class AController* PlayerController, const class FString& PlayerName);
	bool HasAliveTeammates(class ADIPlayerState* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIFactionsManager">();
	}
	static class UDIFactionsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIFactionsManager>();
	}
};
static_assert(alignof(UDIFactionsManager) == 0x000008, "Wrong alignment on UDIFactionsManager");
static_assert(sizeof(UDIFactionsManager) == 0x000088, "Wrong size on UDIFactionsManager");
static_assert(offsetof(UDIFactionsManager, OnFactionDataUpdate) == 0x000030, "Member 'UDIFactionsManager::OnFactionDataUpdate' has a wrong offset!");
static_assert(offsetof(UDIFactionsManager, InternalData) == 0x000040, "Member 'UDIFactionsManager::InternalData' has a wrong offset!");
static_assert(offsetof(UDIFactionsManager, FactionPlan) == 0x000068, "Member 'UDIFactionsManager::FactionPlan' has a wrong offset!");

// Class DeceiveInc.DIUserWidget
// 0x0040 (0x02A0 - 0x0260)
class UDIUserWidget : public UUserWidget
{
public:
	bool                                          bFollowPosition;                                   // 0x0260(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStayInScreen;                                     // 0x0261(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAdjustPositionForSize;                            // 0x0262(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_263[0x1];                                      // 0x0263(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScreenPercent;                                     // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFadeWhenCentered;                                 // 0x0268(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_269[0x3];                                      // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeCenterScreenRatio;                             // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CenterMaxFade;                                     // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Offset;                                            // 0x0274(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                WorldPosition;                                     // 0x0280(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ActorToFollow;                                     // 0x0290(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleHideLocalWidget(bool bHideHuds);
	void SetActorToFollow(class AActor* Actor);
	void SetOffset(const struct FVector& NewOfsset);
	void SetPosToFollow(const struct FVector& Position);

	float GetCurrentWidgetFade() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIUserWidget">();
	}
	static class UDIUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIUserWidget>();
	}
};
static_assert(alignof(UDIUserWidget) == 0x000008, "Wrong alignment on UDIUserWidget");
static_assert(sizeof(UDIUserWidget) == 0x0002A0, "Wrong size on UDIUserWidget");
static_assert(offsetof(UDIUserWidget, bFollowPosition) == 0x000260, "Member 'UDIUserWidget::bFollowPosition' has a wrong offset!");
static_assert(offsetof(UDIUserWidget, bStayInScreen) == 0x000261, "Member 'UDIUserWidget::bStayInScreen' has a wrong offset!");
static_assert(offsetof(UDIUserWidget, bAdjustPositionForSize) == 0x000262, "Member 'UDIUserWidget::bAdjustPositionForSize' has a wrong offset!");
static_assert(offsetof(UDIUserWidget, ScreenPercent) == 0x000264, "Member 'UDIUserWidget::ScreenPercent' has a wrong offset!");
static_assert(offsetof(UDIUserWidget, bFadeWhenCentered) == 0x000268, "Member 'UDIUserWidget::bFadeWhenCentered' has a wrong offset!");
static_assert(offsetof(UDIUserWidget, FadeCenterScreenRatio) == 0x00026C, "Member 'UDIUserWidget::FadeCenterScreenRatio' has a wrong offset!");
static_assert(offsetof(UDIUserWidget, CenterMaxFade) == 0x000270, "Member 'UDIUserWidget::CenterMaxFade' has a wrong offset!");
static_assert(offsetof(UDIUserWidget, Offset) == 0x000274, "Member 'UDIUserWidget::Offset' has a wrong offset!");
static_assert(offsetof(UDIUserWidget, WorldPosition) == 0x000280, "Member 'UDIUserWidget::WorldPosition' has a wrong offset!");
static_assert(offsetof(UDIUserWidget, ActorToFollow) == 0x000290, "Member 'UDIUserWidget::ActorToFollow' has a wrong offset!");

// Class DeceiveInc.NavigationUserWidget
// 0x0020 (0x02C0 - 0x02A0)
class UNavigationUserWidget : public UDIUserWidget
{
public:
	class AActor*                                 OwnerActor;                                        // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bScaleIconOnDistance;                              // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDistanceForScale;                               // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDistanceForScale;                               // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinScalePercent;                                   // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxScalePercent;                                   // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AActor* GetOwnerActor();
	void OnNewDistance(float Distance);
	void OnNewOwnerActor();
	void SetOwnerActor(class AActor* NewOwner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationUserWidget">();
	}
	static class UNavigationUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationUserWidget>();
	}
};
static_assert(alignof(UNavigationUserWidget) == 0x000008, "Wrong alignment on UNavigationUserWidget");
static_assert(sizeof(UNavigationUserWidget) == 0x0002C0, "Wrong size on UNavigationUserWidget");
static_assert(offsetof(UNavigationUserWidget, OwnerActor) == 0x0002A0, "Member 'UNavigationUserWidget::OwnerActor' has a wrong offset!");
static_assert(offsetof(UNavigationUserWidget, bScaleIconOnDistance) == 0x0002A8, "Member 'UNavigationUserWidget::bScaleIconOnDistance' has a wrong offset!");
static_assert(offsetof(UNavigationUserWidget, MinDistanceForScale) == 0x0002AC, "Member 'UNavigationUserWidget::MinDistanceForScale' has a wrong offset!");
static_assert(offsetof(UNavigationUserWidget, MaxDistanceForScale) == 0x0002B0, "Member 'UNavigationUserWidget::MaxDistanceForScale' has a wrong offset!");
static_assert(offsetof(UNavigationUserWidget, MinScalePercent) == 0x0002B4, "Member 'UNavigationUserWidget::MinScalePercent' has a wrong offset!");
static_assert(offsetof(UNavigationUserWidget, MaxScalePercent) == 0x0002B8, "Member 'UNavigationUserWidget::MaxScalePercent' has a wrong offset!");

// Class DeceiveInc.FacingUserWidget
// 0x0008 (0x02C8 - 0x02C0)
class UFacingUserWidget final : public UNavigationUserWidget
{
public:
	class AActor*                                 Owner;                                             // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnNewOwner(class AActor* NewOwner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FacingUserWidget">();
	}
	static class UFacingUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFacingUserWidget>();
	}
};
static_assert(alignof(UFacingUserWidget) == 0x000008, "Wrong alignment on UFacingUserWidget");
static_assert(sizeof(UFacingUserWidget) == 0x0002C8, "Wrong size on UFacingUserWidget");
static_assert(offsetof(UFacingUserWidget, Owner) == 0x0002C0, "Member 'UFacingUserWidget::Owner' has a wrong offset!");

// Class DeceiveInc.DIFreecamSettingsMenuUserWidget
// 0x0008 (0x0308 - 0x0300)
class UDIFreecamSettingsMenuUserWidget final : public UDIMenuUserWidget
{
public:
	class ADebugFreecam*                          FreecamInstance;                                   // 0x0300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UCameraComponent* GetCameraComponent();
	void SetAcceleration(float NewValue);
	void SetCollisionsEnabled(bool NewValue);
	void SetDeceleration(float NewValue);
	void SetElevationLock(bool NewValue);
	void SetFOV(float NewValue);
	void SetMaxSpeed(float NewValue);

	float GetAcceleration() const;
	float GetAccelerationLimit() const;
	float GetDeceleration() const;
	float GetDecelerationLimit() const;
	bool GetElevationLock() const;
	float GetFOV() const;
	float GetMaxSpeed() const;
	float GetMaxSpeedLimit() const;
	bool IsCollisionEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIFreecamSettingsMenuUserWidget">();
	}
	static class UDIFreecamSettingsMenuUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIFreecamSettingsMenuUserWidget>();
	}
};
static_assert(alignof(UDIFreecamSettingsMenuUserWidget) == 0x000008, "Wrong alignment on UDIFreecamSettingsMenuUserWidget");
static_assert(sizeof(UDIFreecamSettingsMenuUserWidget) == 0x000308, "Wrong size on UDIFreecamSettingsMenuUserWidget");
static_assert(offsetof(UDIFreecamSettingsMenuUserWidget, FreecamInstance) == 0x000300, "Member 'UDIFreecamSettingsMenuUserWidget::FreecamInstance' has a wrong offset!");

// Class DeceiveInc.EncounterManager
// 0x0020 (0x0240 - 0x0220)
class AEncounterManager final : public AActor
{
public:
	class UEncounterDataAsset*                    EncounterData;                                     // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UEncounter*>                     ActiveEncounters;                                  // 0x0230(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EncounterManager">();
	}
	static class AEncounterManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEncounterManager>();
	}
};
static_assert(alignof(AEncounterManager) == 0x000008, "Wrong alignment on AEncounterManager");
static_assert(sizeof(AEncounterManager) == 0x000240, "Wrong size on AEncounterManager");
static_assert(offsetof(AEncounterManager, EncounterData) == 0x000220, "Member 'AEncounterManager::EncounterData' has a wrong offset!");
static_assert(offsetof(AEncounterManager, ActiveEncounters) == 0x000230, "Member 'AEncounterManager::ActiveEncounters' has a wrong offset!");

// Class DeceiveInc.DIFreeSpectator
// 0x0050 (0x02F8 - 0x02A8)
class ADIFreeSpectator final : public ASpectatorPawn
{
public:
	uint8                                         Pad_2A8[0x38];                                     // 0x02A8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       CameraSpectate;                                    // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APawn*                                  OriginalBody;                                      // 0x02E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ServerReturnToPlayer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIFreeSpectator">();
	}
	static class ADIFreeSpectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADIFreeSpectator>();
	}
};
static_assert(alignof(ADIFreeSpectator) == 0x000008, "Wrong alignment on ADIFreeSpectator");
static_assert(sizeof(ADIFreeSpectator) == 0x0002F8, "Wrong size on ADIFreeSpectator");
static_assert(offsetof(ADIFreeSpectator, CameraSpectate) == 0x0002E0, "Member 'ADIFreeSpectator::CameraSpectate' has a wrong offset!");
static_assert(offsetof(ADIFreeSpectator, OriginalBody) == 0x0002E8, "Member 'ADIFreeSpectator::OriginalBody' has a wrong offset!");

// Class DeceiveInc.DIGameInstanceBase
// 0x1128 (0x12D0 - 0x01A8)
class UDIGameInstanceBase : public UGameInstance
{
public:
	FMulticastInlineDelegateProperty_             OnIntentToJoinSession;                             // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnClientConfigSettingsUpdated;                     // 0x01B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             StateChanged;                                      // 0x01C8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class UDIDedicatedServerManager*              DedicatedServerManager;                            // 0x01D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDIAutomatedBotManager*                 AutomatedBotManager;                               // 0x01E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E8[0x50];                                     // 0x01E8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAgreementInfo>                 AggreementToCheck;                                 // 0x0238(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x23];                                     // 0x0248(0x0023)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIntentToJoingGame;                                // 0x026B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26C[0x1064];                                   // 0x026C(0x1064)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClientInformation* GetClientInformation();
	static class UGameplayEventBus* GetGameplayEventBus(const class AActor* Requester);
	static class ULocalSpyEventBus* GetLocalSpyEventBus(const class AActor* Requester);
	static bool IsCertTestingMode();
	static bool IsDedicatedServerInstance();
	static bool IsPlaytestBuild();
	static bool IsTrialApp();

	void DebugAddNativePlayer(const class FString& ABId);
	void DebugDoEOSConnect();
	void DebugGetPUID();
	void DebugStartProtectedSession();
	void DoClientStartup();
	void FlagLegalScreenShown();
	void FlashTaskbarIcon();
	class FText GetEULAAgreementText(const class FText& AgreementText);
	class FString GetPlayerNickname();
	void HandleDoFetchAgreementResponse(const class FString& AgreementName, const struct FAgreementResponse& Response, const class FString& Error, bool bWasAlreadySigned);
	void HandleDoSignAgreementResponse(const class FString& AgreementName, const struct FAgreementResponse& Response, const class FString& Error, bool bHasBeenSigned);
	void HandleMenuEvent(const class FString& EventName, bool AnswerValue);
	bool IsAppOwned();
	bool IsInLoginState(EClientLoginStateFlags LoginState);
	bool IsInMainMenuMap();
	bool IsInPlayableMap();
	bool IsLinuxCL();
	void LogoutFromOnlineServices();
	void OnDIWebServiceLoginCompleted(const struct FLoginResponse& LoginResponse);
	void QuitGame();
	void SetCurrentState(const class FName& NewState);
	void ShowPlatformSpecificPlayerDetails(class UDIOnlineFriendInfo* Player);
	void ShowPlatformSpecificPlayerDetailsForPlayer(class ADIPlayerState* Player);
	void StartAccelByteServiceLogin();
	void StartClientOnlineServicesLogin();
	void TestTrophyEvents(const class FString& TrophyId, int32 Progress);
	bool TryRefreshClientSettings();
	void TryUpsellFullGame();
	void UnlinkEOSConnect();

	TArray<class FString> GetAvailablePrivateLobbyRegions() const;
	EAvaliableFeatureLevel GetCurrentFeatureLevel() const;
	const class FName GetCurrentState() const;
	int32 GetMaximumXPBoosterCount() const;
	const struct FDINetInfoClientSettings GetNetInfoClientSettings() const;
	const struct FDIVersionedClientConfigSettings GetVersionnedClientConfigSettings() const;
	bool IsFeatureLevelAvailable(EAvaliableFeatureLevel InFeatureLevel) const;
	bool IsGameModeAvailable(EModeAvaliability InMode) const;
	bool WasLegalScreenShown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIGameInstanceBase">();
	}
	static class UDIGameInstanceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIGameInstanceBase>();
	}
};
static_assert(alignof(UDIGameInstanceBase) == 0x000008, "Wrong alignment on UDIGameInstanceBase");
static_assert(sizeof(UDIGameInstanceBase) == 0x0012D0, "Wrong size on UDIGameInstanceBase");
static_assert(offsetof(UDIGameInstanceBase, OnIntentToJoinSession) == 0x0001A8, "Member 'UDIGameInstanceBase::OnIntentToJoinSession' has a wrong offset!");
static_assert(offsetof(UDIGameInstanceBase, OnClientConfigSettingsUpdated) == 0x0001B8, "Member 'UDIGameInstanceBase::OnClientConfigSettingsUpdated' has a wrong offset!");
static_assert(offsetof(UDIGameInstanceBase, StateChanged) == 0x0001C8, "Member 'UDIGameInstanceBase::StateChanged' has a wrong offset!");
static_assert(offsetof(UDIGameInstanceBase, DedicatedServerManager) == 0x0001D8, "Member 'UDIGameInstanceBase::DedicatedServerManager' has a wrong offset!");
static_assert(offsetof(UDIGameInstanceBase, AutomatedBotManager) == 0x0001E0, "Member 'UDIGameInstanceBase::AutomatedBotManager' has a wrong offset!");
static_assert(offsetof(UDIGameInstanceBase, AggreementToCheck) == 0x000238, "Member 'UDIGameInstanceBase::AggreementToCheck' has a wrong offset!");
static_assert(offsetof(UDIGameInstanceBase, bIntentToJoingGame) == 0x00026B, "Member 'UDIGameInstanceBase::bIntentToJoingGame' has a wrong offset!");

// Class DeceiveInc.DropAtComponent
// 0x00D8 (0x0188 - 0x00B0)
class UDropAtComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnDropDone;                                        // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   DropAtBehaviorClass;                               // 0x00D0(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   DropAtActorClass;                                  // 0x00F8(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 DropAtActorClassHolder;                            // 0x0120(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDropAtBehavior*                        DropAtBehaviorInstance;                            // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 DropAtActorInstance;                               // 0x0130(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDropReplicatedData                    ReplicatedDropData;                                // 0x0138(0x0040)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_178[0x10];                                     // 0x0178(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDropAtTimerEnd(const struct FVector& EndPos, const struct FRotator& EndRotation);
	void OnRep_DropData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DropAtComponent">();
	}
	static class UDropAtComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDropAtComponent>();
	}
};
static_assert(alignof(UDropAtComponent) == 0x000008, "Wrong alignment on UDropAtComponent");
static_assert(sizeof(UDropAtComponent) == 0x000188, "Wrong size on UDropAtComponent");
static_assert(offsetof(UDropAtComponent, OnDropDone) == 0x0000B0, "Member 'UDropAtComponent::OnDropDone' has a wrong offset!");
static_assert(offsetof(UDropAtComponent, DropAtBehaviorClass) == 0x0000D0, "Member 'UDropAtComponent::DropAtBehaviorClass' has a wrong offset!");
static_assert(offsetof(UDropAtComponent, DropAtActorClass) == 0x0000F8, "Member 'UDropAtComponent::DropAtActorClass' has a wrong offset!");
static_assert(offsetof(UDropAtComponent, DropAtActorClassHolder) == 0x000120, "Member 'UDropAtComponent::DropAtActorClassHolder' has a wrong offset!");
static_assert(offsetof(UDropAtComponent, DropAtBehaviorInstance) == 0x000128, "Member 'UDropAtComponent::DropAtBehaviorInstance' has a wrong offset!");
static_assert(offsetof(UDropAtComponent, DropAtActorInstance) == 0x000130, "Member 'UDropAtComponent::DropAtActorInstance' has a wrong offset!");
static_assert(offsetof(UDropAtComponent, ReplicatedDropData) == 0x000138, "Member 'UDropAtComponent::ReplicatedDropData' has a wrong offset!");

// Class DeceiveInc.DIGameRulesSubsystem
// 0x0108 (0x0138 - 0x0030)
class UDIGameRulesSubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnGameRulesChanged;                                // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0xA8];                                      // 0x0040(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UObject*>                          PreloadedRefs;                                     // 0x00E8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void SetActiveRuleset(EDIGameRuleset InNewRuleset, bool bBroadcastChange);

	EDIGameRuleset GetActiveRuleset() const;
	class UDataAsset* GetCorrespondingDataAsset(class UDataAsset* InDataAsset, EDIGameRuleset InRuleset) const;
	class UDataTable* GetCorrespondingDataTable(class UDataTable* InDataTable, EDIGameRuleset InRuleset) const;
	class UObject* GetCorrespondingObject(class UObject* InObject, EDIGameRuleset InRuleset) const;
	bool IsAtLeastOneSpecialRuleInUse(EDISpecialRules InSpecialRule) const;
	bool IsSpecialRuleInUse(EDISpecialRules InSpecialRule) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIGameRulesSubsystem">();
	}
	static class UDIGameRulesSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIGameRulesSubsystem>();
	}
};
static_assert(alignof(UDIGameRulesSubsystem) == 0x000008, "Wrong alignment on UDIGameRulesSubsystem");
static_assert(sizeof(UDIGameRulesSubsystem) == 0x000138, "Wrong size on UDIGameRulesSubsystem");
static_assert(offsetof(UDIGameRulesSubsystem, OnGameRulesChanged) == 0x000030, "Member 'UDIGameRulesSubsystem::OnGameRulesChanged' has a wrong offset!");
static_assert(offsetof(UDIGameRulesSubsystem, PreloadedRefs) == 0x0000E8, "Member 'UDIGameRulesSubsystem::PreloadedRefs' has a wrong offset!");

// Class DeceiveInc.DeceiveIncGameRulesSettings
// 0x00A0 (0x00D8 - 0x0038)
class UDeceiveIncGameRulesSettings final : public UDeveloperSettings
{
public:
	TMap<EDIGameRuleset, struct FDIRuleDefinition> RuleOverrides;                                     // 0x0038(0x0050)(Edit, Config, AdvancedDisplay, NativeAccessSpecifierPrivate)
	TMap<EDIGameMode, EDIGameRuleset>             RulesetPerGamemode;                                // 0x0088(0x0050)(Edit, Config, AdvancedDisplay, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeceiveIncGameRulesSettings">();
	}
	static class UDeceiveIncGameRulesSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeceiveIncGameRulesSettings>();
	}
};
static_assert(alignof(UDeceiveIncGameRulesSettings) == 0x000008, "Wrong alignment on UDeceiveIncGameRulesSettings");
static_assert(sizeof(UDeceiveIncGameRulesSettings) == 0x0000D8, "Wrong size on UDeceiveIncGameRulesSettings");
static_assert(offsetof(UDeceiveIncGameRulesSettings, RuleOverrides) == 0x000038, "Member 'UDeceiveIncGameRulesSettings::RuleOverrides' has a wrong offset!");
static_assert(offsetof(UDeceiveIncGameRulesSettings, RulesetPerGamemode) == 0x000088, "Member 'UDeceiveIncGameRulesSettings::RulesetPerGamemode' has a wrong offset!");

// Class DeceiveInc.ExtractionTerminal
// 0x0090 (0x0348 - 0x02B8)
class AExtractionTerminal final : public ABaseInteractableActor
{
public:
	class UHackTrapScannableComponent*            HackTrapScannableComp;                             // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URevivePartyComponent*                  RevivePartyComp;                                   // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UValidateExtractionComponent*           ValidateExtractComp;                               // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ReviveTeamAvailableText;                           // 0x02D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ReviveTeamNoDeadText;                              // 0x02E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ReviveTeamCannotReviveText;                        // 0x0300(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ReviveTeamNoRessourceText;                         // 0x0318(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ExtractionCallText;                                // 0x0330(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExtractionTerminal">();
	}
	static class AExtractionTerminal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AExtractionTerminal>();
	}
};
static_assert(alignof(AExtractionTerminal) == 0x000008, "Wrong alignment on AExtractionTerminal");
static_assert(sizeof(AExtractionTerminal) == 0x000348, "Wrong size on AExtractionTerminal");
static_assert(offsetof(AExtractionTerminal, HackTrapScannableComp) == 0x0002B8, "Member 'AExtractionTerminal::HackTrapScannableComp' has a wrong offset!");
static_assert(offsetof(AExtractionTerminal, RevivePartyComp) == 0x0002C0, "Member 'AExtractionTerminal::RevivePartyComp' has a wrong offset!");
static_assert(offsetof(AExtractionTerminal, ValidateExtractComp) == 0x0002C8, "Member 'AExtractionTerminal::ValidateExtractComp' has a wrong offset!");
static_assert(offsetof(AExtractionTerminal, ReviveTeamAvailableText) == 0x0002D0, "Member 'AExtractionTerminal::ReviveTeamAvailableText' has a wrong offset!");
static_assert(offsetof(AExtractionTerminal, ReviveTeamNoDeadText) == 0x0002E8, "Member 'AExtractionTerminal::ReviveTeamNoDeadText' has a wrong offset!");
static_assert(offsetof(AExtractionTerminal, ReviveTeamCannotReviveText) == 0x000300, "Member 'AExtractionTerminal::ReviveTeamCannotReviveText' has a wrong offset!");
static_assert(offsetof(AExtractionTerminal, ReviveTeamNoRessourceText) == 0x000318, "Member 'AExtractionTerminal::ReviveTeamNoRessourceText' has a wrong offset!");
static_assert(offsetof(AExtractionTerminal, ExtractionCallText) == 0x000330, "Member 'AExtractionTerminal::ExtractionCallText' has a wrong offset!");

// Class DeceiveInc.DIGameServerSession
// 0x0020 (0x0048 - 0x0028)
class UDIGameServerSession final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIGameServerSession">();
	}
	static class UDIGameServerSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIGameServerSession>();
	}
};
static_assert(alignof(UDIGameServerSession) == 0x000008, "Wrong alignment on UDIGameServerSession");
static_assert(sizeof(UDIGameServerSession) == 0x000048, "Wrong size on UDIGameServerSession");

// Class DeceiveInc.DIGameServerWebServiceSession
// 0x0030 (0x0060 - 0x0030)
class UDIGameServerWebServiceSession final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UDIGameServerSession*                   Session;                                           // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SendReport(const class FString& Reporter, const class FString& Reportee, const class FString& Message, const class FString& MatchId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIGameServerWebServiceSession">();
	}
	static class UDIGameServerWebServiceSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIGameServerWebServiceSession>();
	}
};
static_assert(alignof(UDIGameServerWebServiceSession) == 0x000008, "Wrong alignment on UDIGameServerWebServiceSession");
static_assert(sizeof(UDIGameServerWebServiceSession) == 0x000060, "Wrong size on UDIGameServerWebServiceSession");
static_assert(offsetof(UDIGameServerWebServiceSession, Session) == 0x000058, "Member 'UDIGameServerWebServiceSession::Session' has a wrong offset!");

// Class DeceiveInc.GamePhaseConditionComponent
// 0x0010 (0x00E0 - 0x00D0)
class UGamePhaseConditionComponent final : public UBaseConditionComponent
{
public:
	TArray<ESpyGamePhase>                         ValidPhases;                                       // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamePhaseConditionComponent">();
	}
	static class UGamePhaseConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamePhaseConditionComponent>();
	}
};
static_assert(alignof(UGamePhaseConditionComponent) == 0x000008, "Wrong alignment on UGamePhaseConditionComponent");
static_assert(sizeof(UGamePhaseConditionComponent) == 0x0000E0, "Wrong size on UGamePhaseConditionComponent");
static_assert(offsetof(UGamePhaseConditionComponent, ValidPhases) == 0x0000D0, "Member 'UGamePhaseConditionComponent::ValidPhases' has a wrong offset!");

// Class DeceiveInc.DIInteractWidgetSubsystem
// 0x0098 (0x00C8 - 0x0030)
class UDIInteractWidgetSubsystem final : public ULocalPlayerSubsystem
{
public:
	class UClass*                                 WidgetHolderClass;                                 // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 SpawnWorld;                                        // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AActor>>          UserWidgetPool;                                    // 0x0048(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AActor>>          FreeWidgets;                                       // 0x0058(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<TWeakObjectPtr<class UActorComponent>, struct FWidgetRequestInfo> ReservedWidgets;                                   // 0x0068(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDILoadingSystemDataAsset*              SystemData;                                        // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIInteractWidgetSubsystem">();
	}
	static class UDIInteractWidgetSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIInteractWidgetSubsystem>();
	}
};
static_assert(alignof(UDIInteractWidgetSubsystem) == 0x000008, "Wrong alignment on UDIInteractWidgetSubsystem");
static_assert(sizeof(UDIInteractWidgetSubsystem) == 0x0000C8, "Wrong size on UDIInteractWidgetSubsystem");
static_assert(offsetof(UDIInteractWidgetSubsystem, WidgetHolderClass) == 0x000030, "Member 'UDIInteractWidgetSubsystem::WidgetHolderClass' has a wrong offset!");
static_assert(offsetof(UDIInteractWidgetSubsystem, SpawnWorld) == 0x000040, "Member 'UDIInteractWidgetSubsystem::SpawnWorld' has a wrong offset!");
static_assert(offsetof(UDIInteractWidgetSubsystem, UserWidgetPool) == 0x000048, "Member 'UDIInteractWidgetSubsystem::UserWidgetPool' has a wrong offset!");
static_assert(offsetof(UDIInteractWidgetSubsystem, FreeWidgets) == 0x000058, "Member 'UDIInteractWidgetSubsystem::FreeWidgets' has a wrong offset!");
static_assert(offsetof(UDIInteractWidgetSubsystem, ReservedWidgets) == 0x000068, "Member 'UDIInteractWidgetSubsystem::ReservedWidgets' has a wrong offset!");
static_assert(offsetof(UDIInteractWidgetSubsystem, SystemData) == 0x0000C0, "Member 'UDIInteractWidgetSubsystem::SystemData' has a wrong offset!");

// Class DeceiveInc.DiKeybindActionEntryWidget
// 0x00A8 (0x0308 - 0x0260)
class UDiKeybindActionEntryWidget final : public UUserWidget
{
public:
	class FText                                   PrimaryBoundKey;                                   // 0x0260(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class FText                                   SecondaryBoundKey;                                 // 0x0278(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	EInputDeviceType                              InputDevice;                                       // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDIPopupUserWidget*                     BindingPopup;                                      // 0x0298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBindableKeyEntry                      BindableKeyEntry;                                  // 0x02A0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x18];                                     // 0x02F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ListenForKeyBinding(int32 KeySlot);
	void Redraw();
	void SetFromBindableKeyEntry(const struct FBindableKeyEntry& Src);
	void SetInputDeviceType(EInputDeviceType InInputDevice);
	void UnbindKeys();

	class FString GetActionName() const;
	EKeybindContext GetCategory() const;
	class FText GetDisplayName() const;
	float GetScale() const;
	bool IsTapAction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiKeybindActionEntryWidget">();
	}
	static class UDiKeybindActionEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiKeybindActionEntryWidget>();
	}
};
static_assert(alignof(UDiKeybindActionEntryWidget) == 0x000008, "Wrong alignment on UDiKeybindActionEntryWidget");
static_assert(sizeof(UDiKeybindActionEntryWidget) == 0x000308, "Wrong size on UDiKeybindActionEntryWidget");
static_assert(offsetof(UDiKeybindActionEntryWidget, PrimaryBoundKey) == 0x000260, "Member 'UDiKeybindActionEntryWidget::PrimaryBoundKey' has a wrong offset!");
static_assert(offsetof(UDiKeybindActionEntryWidget, SecondaryBoundKey) == 0x000278, "Member 'UDiKeybindActionEntryWidget::SecondaryBoundKey' has a wrong offset!");
static_assert(offsetof(UDiKeybindActionEntryWidget, InputDevice) == 0x000290, "Member 'UDiKeybindActionEntryWidget::InputDevice' has a wrong offset!");
static_assert(offsetof(UDiKeybindActionEntryWidget, BindingPopup) == 0x000298, "Member 'UDiKeybindActionEntryWidget::BindingPopup' has a wrong offset!");
static_assert(offsetof(UDiKeybindActionEntryWidget, BindableKeyEntry) == 0x0002A0, "Member 'UDiKeybindActionEntryWidget::BindableKeyEntry' has a wrong offset!");

// Class DeceiveInc.FakeMovementComponent
// 0x0040 (0x00F0 - 0x00B0)
class UFakeMovementComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x4];                                       // 0x00B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Velocity;                                          // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Gravity;                                           // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IgnoreCollisionWhenMoving;                         // 0x00BC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFakeMovementRepData                   MovementData;                                      // 0x00C0(0x001C)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector_NetQuantize                    FinalPosition;                                     // 0x00DC(0x000C)(Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_FinalPos();
	void OnRep_MovementEnabled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FakeMovementComponent">();
	}
	static class UFakeMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFakeMovementComponent>();
	}
};
static_assert(alignof(UFakeMovementComponent) == 0x000008, "Wrong alignment on UFakeMovementComponent");
static_assert(sizeof(UFakeMovementComponent) == 0x0000F0, "Wrong size on UFakeMovementComponent");
static_assert(offsetof(UFakeMovementComponent, Velocity) == 0x0000B4, "Member 'UFakeMovementComponent::Velocity' has a wrong offset!");
static_assert(offsetof(UFakeMovementComponent, Gravity) == 0x0000B8, "Member 'UFakeMovementComponent::Gravity' has a wrong offset!");
static_assert(offsetof(UFakeMovementComponent, IgnoreCollisionWhenMoving) == 0x0000BC, "Member 'UFakeMovementComponent::IgnoreCollisionWhenMoving' has a wrong offset!");
static_assert(offsetof(UFakeMovementComponent, MovementData) == 0x0000C0, "Member 'UFakeMovementComponent::MovementData' has a wrong offset!");
static_assert(offsetof(UFakeMovementComponent, FinalPosition) == 0x0000DC, "Member 'UFakeMovementComponent::FinalPosition' has a wrong offset!");

// Class DeceiveInc.DiKeybindActionWidget
// 0x0070 (0x02D0 - 0x0260)
class UDiKeybindActionWidget final : public UUserWidget
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BindingName;                                       // 0x0268(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   DisplayName;                                       // 0x0270(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class FText                                   PrimaryBoundKey;                                   // 0x0288(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class FText                                   SecondaryBoundKey;                                 // 0x02A0(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          bKeyboardOnly;                                     // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAxis;                                           // 0x02B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsGamepadMapping;                                 // 0x02BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BB[0x1];                                      // 0x02BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDIPopupUserWidget*                     BindingPopup;                                      // 0x02C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ListenForKeyBinding(int32 KeySlot);
	void Redraw();
	void SetFromBindableKeyEntry(const struct FBindableKeyEntry& Src);
	void SetFromDiKeybindActionWidget(const class UDiKeybindActionWidget* Src);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiKeybindActionWidget">();
	}
	static class UDiKeybindActionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiKeybindActionWidget>();
	}
};
static_assert(alignof(UDiKeybindActionWidget) == 0x000008, "Wrong alignment on UDiKeybindActionWidget");
static_assert(sizeof(UDiKeybindActionWidget) == 0x0002D0, "Wrong size on UDiKeybindActionWidget");
static_assert(offsetof(UDiKeybindActionWidget, BindingName) == 0x000268, "Member 'UDiKeybindActionWidget::BindingName' has a wrong offset!");
static_assert(offsetof(UDiKeybindActionWidget, DisplayName) == 0x000270, "Member 'UDiKeybindActionWidget::DisplayName' has a wrong offset!");
static_assert(offsetof(UDiKeybindActionWidget, PrimaryBoundKey) == 0x000288, "Member 'UDiKeybindActionWidget::PrimaryBoundKey' has a wrong offset!");
static_assert(offsetof(UDiKeybindActionWidget, SecondaryBoundKey) == 0x0002A0, "Member 'UDiKeybindActionWidget::SecondaryBoundKey' has a wrong offset!");
static_assert(offsetof(UDiKeybindActionWidget, bKeyboardOnly) == 0x0002B8, "Member 'UDiKeybindActionWidget::bKeyboardOnly' has a wrong offset!");
static_assert(offsetof(UDiKeybindActionWidget, bIsAxis) == 0x0002B9, "Member 'UDiKeybindActionWidget::bIsAxis' has a wrong offset!");
static_assert(offsetof(UDiKeybindActionWidget, bIsGamepadMapping) == 0x0002BA, "Member 'UDiKeybindActionWidget::bIsGamepadMapping' has a wrong offset!");
static_assert(offsetof(UDiKeybindActionWidget, Scale) == 0x0002BC, "Member 'UDiKeybindActionWidget::Scale' has a wrong offset!");
static_assert(offsetof(UDiKeybindActionWidget, BindingPopup) == 0x0002C0, "Member 'UDiKeybindActionWidget::BindingPopup' has a wrong offset!");

// Class DeceiveInc.DIKillcamPlaybackManager
// 0x0078 (0x00A0 - 0x0028)
class UDIKillcamPlaybackManager final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class ADIPlayerState*                         CachedKillingPlayerState;                          // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x40];                                      // 0x0060(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKillcamPlaybackComplete(class UWorld* PlaybackWorld);
	void OnTimerFadeInCamera();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIKillcamPlaybackManager">();
	}
	static class UDIKillcamPlaybackManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIKillcamPlaybackManager>();
	}
};
static_assert(alignof(UDIKillcamPlaybackManager) == 0x000008, "Wrong alignment on UDIKillcamPlaybackManager");
static_assert(sizeof(UDIKillcamPlaybackManager) == 0x0000A0, "Wrong size on UDIKillcamPlaybackManager");
static_assert(offsetof(UDIKillcamPlaybackManager, CachedKillingPlayerState) == 0x000058, "Member 'UDIKillcamPlaybackManager::CachedKillingPlayerState' has a wrong offset!");

// Class DeceiveInc.EOSVoiceChatHandler
// 0x0058 (0x0330 - 0x02D8)
class AEOSVoiceChatHandler final : public ADeceiveIncPlayerVoiceChat
{
public:
	uint8                                         Pad_2D8[0x58];                                     // 0x02D8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EOSVoiceChatHandler">();
	}
	static class AEOSVoiceChatHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEOSVoiceChatHandler>();
	}
};
static_assert(alignof(AEOSVoiceChatHandler) == 0x000008, "Wrong alignment on AEOSVoiceChatHandler");
static_assert(sizeof(AEOSVoiceChatHandler) == 0x000330, "Wrong size on AEOSVoiceChatHandler");

// Class DeceiveInc.DILoadingScreenWidget
// 0x0000 (0x0260 - 0x0260)
class UDILoadingScreenWidget : public UUserWidget
{
public:
	void BP_RemoveMapTexture();
	void BP_SetMapFlavor(const class FText& FlavorText);
	void BP_SetMapName(const class FText& Name_0);
	void BP_SetMapSubtext(const class FText& Subtext);
	void BP_SetMapTexture(const TSoftObjectPtr<class UTexture2D>& MapTexture);
	void BP_SetMapTexture2(const class UTexture2D* MapTexture);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DILoadingScreenWidget">();
	}
	static class UDILoadingScreenWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDILoadingScreenWidget>();
	}
};
static_assert(alignof(UDILoadingScreenWidget) == 0x000008, "Wrong alignment on UDILoadingScreenWidget");
static_assert(sizeof(UDILoadingScreenWidget) == 0x000260, "Wrong size on UDILoadingScreenWidget");

// Class DeceiveInc.DILoadingSystemDataAsset
// 0x0070 (0x00A8 - 0x0038)
class UDILoadingSystemDataAsset final : public UDIPrimaryDataAsset
{
public:
	TSubclassOf<class UDILoadingScreenWidget>     LoadingScreenAsset;                                // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           Tips;                                              // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   DefaultMapName;                                    // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DefaultFlavorText;                                 // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WidgetContainerAssetClass;                         // 0x0080(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DILoadingSystemDataAsset">();
	}
	static class UDILoadingSystemDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDILoadingSystemDataAsset>();
	}
};
static_assert(alignof(UDILoadingSystemDataAsset) == 0x000008, "Wrong alignment on UDILoadingSystemDataAsset");
static_assert(sizeof(UDILoadingSystemDataAsset) == 0x0000A8, "Wrong size on UDILoadingSystemDataAsset");
static_assert(offsetof(UDILoadingSystemDataAsset, LoadingScreenAsset) == 0x000038, "Member 'UDILoadingSystemDataAsset::LoadingScreenAsset' has a wrong offset!");
static_assert(offsetof(UDILoadingSystemDataAsset, Tips) == 0x000040, "Member 'UDILoadingSystemDataAsset::Tips' has a wrong offset!");
static_assert(offsetof(UDILoadingSystemDataAsset, DefaultMapName) == 0x000050, "Member 'UDILoadingSystemDataAsset::DefaultMapName' has a wrong offset!");
static_assert(offsetof(UDILoadingSystemDataAsset, DefaultFlavorText) == 0x000068, "Member 'UDILoadingSystemDataAsset::DefaultFlavorText' has a wrong offset!");
static_assert(offsetof(UDILoadingSystemDataAsset, WidgetContainerAssetClass) == 0x000080, "Member 'UDILoadingSystemDataAsset::WidgetContainerAssetClass' has a wrong offset!");

// Class DeceiveInc.GadgetInterface
// 0x0000 (0x0028 - 0x0028)
class IGadgetInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetInterface">();
	}
	static class IGadgetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGadgetInterface>();
	}
};
static_assert(alignof(IGadgetInterface) == 0x000008, "Wrong alignment on IGadgetInterface");
static_assert(sizeof(IGadgetInterface) == 0x000028, "Wrong size on IGadgetInterface");

// Class DeceiveInc.DILoadSubsystem
// 0x0028 (0x0058 - 0x0030)
class UDILoadSubsystem final : public UGameInstanceSubsystem
{
public:
	class UPackage*                               PreloadedMap;                                      // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDILoadingSystemDataAsset*              SystemData;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDILoadingScreenWidget*                 LoadingSreenWidget;                                // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void BP_HideLoadingScreen(const class UObject* WorldContextObject);
	static void BP_ShowLoadingScreen(const class UObject* WorldContextObject);

	void HideLoadingSreen();
	void PrepareLoading(const class UMapData* MapData);
	void PrepareMovieLoadscreen();
	void ShowLoadingSreen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DILoadSubsystem">();
	}
	static class UDILoadSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDILoadSubsystem>();
	}
};
static_assert(alignof(UDILoadSubsystem) == 0x000008, "Wrong alignment on UDILoadSubsystem");
static_assert(sizeof(UDILoadSubsystem) == 0x000058, "Wrong size on UDILoadSubsystem");
static_assert(offsetof(UDILoadSubsystem, PreloadedMap) == 0x000030, "Member 'UDILoadSubsystem::PreloadedMap' has a wrong offset!");
static_assert(offsetof(UDILoadSubsystem, SystemData) == 0x000038, "Member 'UDILoadSubsystem::SystemData' has a wrong offset!");
static_assert(offsetof(UDILoadSubsystem, LoadingSreenWidget) == 0x000040, "Member 'UDILoadSubsystem::LoadingSreenWidget' has a wrong offset!");

// Class DeceiveInc.DILocalPlayer
// 0x0058 (0x02B0 - 0x0258)
class UDILocalPlayer final : public ULocalPlayer
{
public:
	uint8                                         Pad_258[0x50];                                     // 0x0258(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UDIKillcamPlaybackManager*              KillcamPlayback;                                   // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool IsInKillcam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DILocalPlayer">();
	}
	static class UDILocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDILocalPlayer>();
	}
};
static_assert(alignof(UDILocalPlayer) == 0x000008, "Wrong alignment on UDILocalPlayer");
static_assert(sizeof(UDILocalPlayer) == 0x0002B0, "Wrong size on UDILocalPlayer");
static_assert(offsetof(UDILocalPlayer, KillcamPlayback) == 0x0002A8, "Member 'UDILocalPlayer::KillcamPlayback' has a wrong offset!");

// Class DeceiveInc.GooPod
// 0x0028 (0x0340 - 0x0318)
class AGooPod final : public ABasePickablePlaceable
{
public:
	FMulticastInlineDelegateProperty_             OnToggleGoo;                                       // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBoxComponent*                          CollisionBox;                                      // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GooSlowPercent;                                    // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableJump;                                      // 0x0334(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableRunning;                                   // 0x0335(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableSpeedBoost;                                // 0x0336(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGooWantsToBeActive;                               // 0x0337(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnToggleGoo(bool bActive);
	void HandleCollisionBoxBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void HandleCollisionBoxEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	bool IsGooActive();
	void NetMulticast_ToggleGoo(bool bActive);
	void OnPreDropConfirmation(bool* CanDropOut);
	void OnRep_GooWantsToBeActive();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GooPod">();
	}
	static class AGooPod* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGooPod>();
	}
};
static_assert(alignof(AGooPod) == 0x000008, "Wrong alignment on AGooPod");
static_assert(sizeof(AGooPod) == 0x000340, "Wrong size on AGooPod");
static_assert(offsetof(AGooPod, OnToggleGoo) == 0x000318, "Member 'AGooPod::OnToggleGoo' has a wrong offset!");
static_assert(offsetof(AGooPod, CollisionBox) == 0x000328, "Member 'AGooPod::CollisionBox' has a wrong offset!");
static_assert(offsetof(AGooPod, GooSlowPercent) == 0x000330, "Member 'AGooPod::GooSlowPercent' has a wrong offset!");
static_assert(offsetof(AGooPod, bDisableJump) == 0x000334, "Member 'AGooPod::bDisableJump' has a wrong offset!");
static_assert(offsetof(AGooPod, bDisableRunning) == 0x000335, "Member 'AGooPod::bDisableRunning' has a wrong offset!");
static_assert(offsetof(AGooPod, bDisableSpeedBoost) == 0x000336, "Member 'AGooPod::bDisableSpeedBoost' has a wrong offset!");
static_assert(offsetof(AGooPod, bGooWantsToBeActive) == 0x000337, "Member 'AGooPod::bGooWantsToBeActive' has a wrong offset!");

// Class DeceiveInc.DIMainMenuUserWidget
// 0x0000 (0x0300 - 0x0300)
class UDIMainMenuUserWidget final : public UDIMenuUserWidget
{
public:
	void DisplayMenuPageByEnum(EMainMenuPages MenuPage);
	class UUserWidget* GetIrisSubtitleWidget();
	EMainMenuPages GetOpenedMenuPage();
	class UUserWidget* GetSubtitleWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIMainMenuUserWidget">();
	}
	static class UDIMainMenuUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIMainMenuUserWidget>();
	}
};
static_assert(alignof(UDIMainMenuUserWidget) == 0x000008, "Wrong alignment on UDIMainMenuUserWidget");
static_assert(sizeof(UDIMainMenuUserWidget) == 0x000300, "Wrong size on UDIMainMenuUserWidget");

// Class DeceiveInc.DIMapList
// 0x0048 (0x0080 - 0x0038)
class UDIMapList final : public UDIPrimaryDataAsset
{
public:
	TArray<class UMapData*>                       PlayableMaps;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UMapData*>                       CustomGameMaps;                                    // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UMapData*>                       MatchmakingMaps;                                   // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UMapData*                               TutorialMapData;                                   // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMapData*                               TrainingRangeMapData;                              // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMapData*                               PrivateLobbyMapData;                               // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIMapList">();
	}
	static class UDIMapList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIMapList>();
	}
};
static_assert(alignof(UDIMapList) == 0x000008, "Wrong alignment on UDIMapList");
static_assert(sizeof(UDIMapList) == 0x000080, "Wrong size on UDIMapList");
static_assert(offsetof(UDIMapList, PlayableMaps) == 0x000038, "Member 'UDIMapList::PlayableMaps' has a wrong offset!");
static_assert(offsetof(UDIMapList, CustomGameMaps) == 0x000048, "Member 'UDIMapList::CustomGameMaps' has a wrong offset!");
static_assert(offsetof(UDIMapList, MatchmakingMaps) == 0x000058, "Member 'UDIMapList::MatchmakingMaps' has a wrong offset!");
static_assert(offsetof(UDIMapList, TutorialMapData) == 0x000068, "Member 'UDIMapList::TutorialMapData' has a wrong offset!");
static_assert(offsetof(UDIMapList, TrainingRangeMapData) == 0x000070, "Member 'UDIMapList::TrainingRangeMapData' has a wrong offset!");
static_assert(offsetof(UDIMapList, PrivateLobbyMapData) == 0x000078, "Member 'UDIMapList::PrivateLobbyMapData' has a wrong offset!");

// Class DeceiveInc.GameplayBotBrainDataAsset
// 0x0038 (0x0068 - 0x0030)
class UGameplayBotBrainDataAsset final : public UPrimaryDataAsset
{
public:
	float                                         PercentChanceToPanicWhenCoverBlown;                // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PanicCooldownDuration;                             // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AggroOtherSpyDelayMin;                             // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AggroOtherSpyDelayMax;                             // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AggroMaxRangeWhenInCover;                          // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoNotAggroOtherBotsDelay;                          // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnstuckTeleportFallbackTime;                       // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LingeringExtractingSpyDuration;                    // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultLocked_StallProgressDurationMin;              // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultLocked_StallProgressDurationMax;              // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultLocked_ExtraStallProgressDurationMin;         // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultLocked_ExtraStallProgressDurationMax;         // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultOpened_StallProgressDurationMin;              // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultOpened_StallProgressDurationMax;              // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayBotBrainDataAsset">();
	}
	static class UGameplayBotBrainDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayBotBrainDataAsset>();
	}
};
static_assert(alignof(UGameplayBotBrainDataAsset) == 0x000008, "Wrong alignment on UGameplayBotBrainDataAsset");
static_assert(sizeof(UGameplayBotBrainDataAsset) == 0x000068, "Wrong size on UGameplayBotBrainDataAsset");
static_assert(offsetof(UGameplayBotBrainDataAsset, PercentChanceToPanicWhenCoverBlown) == 0x000030, "Member 'UGameplayBotBrainDataAsset::PercentChanceToPanicWhenCoverBlown' has a wrong offset!");
static_assert(offsetof(UGameplayBotBrainDataAsset, PanicCooldownDuration) == 0x000034, "Member 'UGameplayBotBrainDataAsset::PanicCooldownDuration' has a wrong offset!");
static_assert(offsetof(UGameplayBotBrainDataAsset, AggroOtherSpyDelayMin) == 0x000038, "Member 'UGameplayBotBrainDataAsset::AggroOtherSpyDelayMin' has a wrong offset!");
static_assert(offsetof(UGameplayBotBrainDataAsset, AggroOtherSpyDelayMax) == 0x00003C, "Member 'UGameplayBotBrainDataAsset::AggroOtherSpyDelayMax' has a wrong offset!");
static_assert(offsetof(UGameplayBotBrainDataAsset, AggroMaxRangeWhenInCover) == 0x000040, "Member 'UGameplayBotBrainDataAsset::AggroMaxRangeWhenInCover' has a wrong offset!");
static_assert(offsetof(UGameplayBotBrainDataAsset, DoNotAggroOtherBotsDelay) == 0x000044, "Member 'UGameplayBotBrainDataAsset::DoNotAggroOtherBotsDelay' has a wrong offset!");
static_assert(offsetof(UGameplayBotBrainDataAsset, UnstuckTeleportFallbackTime) == 0x000048, "Member 'UGameplayBotBrainDataAsset::UnstuckTeleportFallbackTime' has a wrong offset!");
static_assert(offsetof(UGameplayBotBrainDataAsset, LingeringExtractingSpyDuration) == 0x00004C, "Member 'UGameplayBotBrainDataAsset::LingeringExtractingSpyDuration' has a wrong offset!");
static_assert(offsetof(UGameplayBotBrainDataAsset, VaultLocked_StallProgressDurationMin) == 0x000050, "Member 'UGameplayBotBrainDataAsset::VaultLocked_StallProgressDurationMin' has a wrong offset!");
static_assert(offsetof(UGameplayBotBrainDataAsset, VaultLocked_StallProgressDurationMax) == 0x000054, "Member 'UGameplayBotBrainDataAsset::VaultLocked_StallProgressDurationMax' has a wrong offset!");
static_assert(offsetof(UGameplayBotBrainDataAsset, VaultLocked_ExtraStallProgressDurationMin) == 0x000058, "Member 'UGameplayBotBrainDataAsset::VaultLocked_ExtraStallProgressDurationMin' has a wrong offset!");
static_assert(offsetof(UGameplayBotBrainDataAsset, VaultLocked_ExtraStallProgressDurationMax) == 0x00005C, "Member 'UGameplayBotBrainDataAsset::VaultLocked_ExtraStallProgressDurationMax' has a wrong offset!");
static_assert(offsetof(UGameplayBotBrainDataAsset, VaultOpened_StallProgressDurationMin) == 0x000060, "Member 'UGameplayBotBrainDataAsset::VaultOpened_StallProgressDurationMin' has a wrong offset!");
static_assert(offsetof(UGameplayBotBrainDataAsset, VaultOpened_StallProgressDurationMax) == 0x000064, "Member 'UGameplayBotBrainDataAsset::VaultOpened_StallProgressDurationMax' has a wrong offset!");

// Class DeceiveInc.DIMatchesSubsystem
// 0x0090 (0x00C0 - 0x0030)
class UDIMatchesSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x90];                                      // 0x0030(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MatchUpdate(bool bForceMatchEnded);
	void MatchUpdateTimer();
	void OnGameStateSetEvent(class AGameStateBase* GameState);
	void OnMatchResultsPosted();
	void OnMatchStateChanged(class FName NewMatchState);
	void OnPostLoadMap(class UWorld* LoadedWorld);
	void OnPreLoadMap(const class FString& MapName);
	void OnPS5MatchIdChanged(const class FString& MatchId);
	void OnPS5MatchResponsiblePlayerUpdated(const struct FUniqueNetIdRepl& Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIMatchesSubsystem">();
	}
	static class UDIMatchesSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIMatchesSubsystem>();
	}
};
static_assert(alignof(UDIMatchesSubsystem) == 0x000008, "Wrong alignment on UDIMatchesSubsystem");
static_assert(sizeof(UDIMatchesSubsystem) == 0x0000C0, "Wrong size on UDIMatchesSubsystem");

// Class DeceiveInc.DIMatchmakingRequestHandler
// 0x00B0 (0x00D8 - 0x0028)
class UDIMatchmakingRequestHandler final : public UObject
{
public:
	class UDIClientSession*                       Session;                                           // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameInstance*                          GameInstance;                                      // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMatchmakingErrorDelegate;                        // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMatchmakingSuccessDelegate;                      // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDescribeMatchmakingDelegate;                     // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMatchmakingStatusChanged;                        // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDescribeMatchmakingResponse           LatestDescribeMatchmakingResponse;                 // 0x00A0(0x0030)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EDIMenuGameModes GetMatchmakingGameMode();
	void LeaveMatchmaking();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIMatchmakingRequestHandler">();
	}
	static class UDIMatchmakingRequestHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIMatchmakingRequestHandler>();
	}
};
static_assert(alignof(UDIMatchmakingRequestHandler) == 0x000008, "Wrong alignment on UDIMatchmakingRequestHandler");
static_assert(sizeof(UDIMatchmakingRequestHandler) == 0x0000D8, "Wrong size on UDIMatchmakingRequestHandler");
static_assert(offsetof(UDIMatchmakingRequestHandler, Session) == 0x000028, "Member 'UDIMatchmakingRequestHandler::Session' has a wrong offset!");
static_assert(offsetof(UDIMatchmakingRequestHandler, GameInstance) == 0x000030, "Member 'UDIMatchmakingRequestHandler::GameInstance' has a wrong offset!");
static_assert(offsetof(UDIMatchmakingRequestHandler, OnMatchmakingErrorDelegate) == 0x000060, "Member 'UDIMatchmakingRequestHandler::OnMatchmakingErrorDelegate' has a wrong offset!");
static_assert(offsetof(UDIMatchmakingRequestHandler, OnMatchmakingSuccessDelegate) == 0x000070, "Member 'UDIMatchmakingRequestHandler::OnMatchmakingSuccessDelegate' has a wrong offset!");
static_assert(offsetof(UDIMatchmakingRequestHandler, OnDescribeMatchmakingDelegate) == 0x000080, "Member 'UDIMatchmakingRequestHandler::OnDescribeMatchmakingDelegate' has a wrong offset!");
static_assert(offsetof(UDIMatchmakingRequestHandler, OnMatchmakingStatusChanged) == 0x000090, "Member 'UDIMatchmakingRequestHandler::OnMatchmakingStatusChanged' has a wrong offset!");
static_assert(offsetof(UDIMatchmakingRequestHandler, LatestDescribeMatchmakingResponse) == 0x0000A0, "Member 'UDIMatchmakingRequestHandler::LatestDescribeMatchmakingResponse' has a wrong offset!");

// Class DeceiveInc.FanartSubsystem
// 0x0020 (0x0050 - 0x0030)
class UFanartSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AWebStreamedFanartAsset*>        RegisteredFanartTargets;                           // 0x0040(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FanartSubsystem">();
	}
	static class UFanartSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFanartSubsystem>();
	}
};
static_assert(alignof(UFanartSubsystem) == 0x000008, "Wrong alignment on UFanartSubsystem");
static_assert(sizeof(UFanartSubsystem) == 0x000050, "Wrong size on UFanartSubsystem");
static_assert(offsetof(UFanartSubsystem, RegisteredFanartTargets) == 0x000040, "Member 'UFanartSubsystem::RegisteredFanartTargets' has a wrong offset!");

// Class DeceiveInc.DIMatchmakingTokenHandler
// 0x0058 (0x0080 - 0x0028)
class UDIMatchmakingTokenHandler final : public UObject
{
public:
	class UDIClientSession*                       Session;                                           // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameInstance*                          GameInstance;                                      // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAwsPingHandler*>                PingHandlers;                                      // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UAwsPingHandler*>                OldPingHandlers;                                   // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnMatchmakingTokenChanged;                         // 0x0070(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	void OnPingHandlerStabilized();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIMatchmakingTokenHandler">();
	}
	static class UDIMatchmakingTokenHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIMatchmakingTokenHandler>();
	}
};
static_assert(alignof(UDIMatchmakingTokenHandler) == 0x000008, "Wrong alignment on UDIMatchmakingTokenHandler");
static_assert(sizeof(UDIMatchmakingTokenHandler) == 0x000080, "Wrong size on UDIMatchmakingTokenHandler");
static_assert(offsetof(UDIMatchmakingTokenHandler, Session) == 0x000028, "Member 'UDIMatchmakingTokenHandler::Session' has a wrong offset!");
static_assert(offsetof(UDIMatchmakingTokenHandler, GameInstance) == 0x000030, "Member 'UDIMatchmakingTokenHandler::GameInstance' has a wrong offset!");
static_assert(offsetof(UDIMatchmakingTokenHandler, PingHandlers) == 0x000050, "Member 'UDIMatchmakingTokenHandler::PingHandlers' has a wrong offset!");
static_assert(offsetof(UDIMatchmakingTokenHandler, OldPingHandlers) == 0x000060, "Member 'UDIMatchmakingTokenHandler::OldPingHandlers' has a wrong offset!");
static_assert(offsetof(UDIMatchmakingTokenHandler, OnMatchmakingTokenChanged) == 0x000070, "Member 'UDIMatchmakingTokenHandler::OnMatchmakingTokenChanged' has a wrong offset!");

// Class DeceiveInc.DiMenuButtonInterface
// 0x0000 (0x0028 - 0x0028)
class IDiMenuButtonInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiMenuButtonInterface">();
	}
	static class IDiMenuButtonInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDiMenuButtonInterface>();
	}
};
static_assert(alignof(IDiMenuButtonInterface) == 0x000008, "Wrong alignment on IDiMenuButtonInterface");
static_assert(sizeof(IDiMenuButtonInterface) == 0x000028, "Wrong size on IDiMenuButtonInterface");

// Class DeceiveInc.DIMenuKeybindingsWidget
// 0x0000 (0x0300 - 0x0300)
class UDIMenuKeybindingsWidget final : public UDIMenuUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIMenuKeybindingsWidget">();
	}
	static class UDIMenuKeybindingsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIMenuKeybindingsWidget>();
	}
};
static_assert(alignof(UDIMenuKeybindingsWidget) == 0x000008, "Wrong alignment on UDIMenuKeybindingsWidget");
static_assert(sizeof(UDIMenuKeybindingsWidget) == 0x000300, "Wrong size on UDIMenuKeybindingsWidget");

// Class DeceiveInc.DiMenuPageNavigationWidget
// 0x0008 (0x0268 - 0x0260)
class UDiMenuPageNavigationWidget final : public UUserWidget
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiMenuPageNavigationWidget">();
	}
	static class UDiMenuPageNavigationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiMenuPageNavigationWidget>();
	}
};
static_assert(alignof(UDiMenuPageNavigationWidget) == 0x000008, "Wrong alignment on UDiMenuPageNavigationWidget");
static_assert(sizeof(UDiMenuPageNavigationWidget) == 0x000268, "Wrong size on UDiMenuPageNavigationWidget");

// Class DeceiveInc.DIMenuSubsystem
// 0x01B8 (0x01E8 - 0x0030)
class UDIMenuSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x68];                                      // 0x0030(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class APosingSpy*                             LocalPlayerPosingSpy;                              // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UDIMenuUserWidget*>              ActiveMenus;                                       // 0x00A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UDIPopupUserWidget*                     PopupWidget;                                       // 0x00B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDIPopupAnnouncementUserWidget*         SpecialAnnouncementWidget;                         // 0x00B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActiveMenuPageChanged;                           // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMenuEvent;                                       // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDisplayedAgentChangedEvent;                      // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDisplayedIntroPoseChangedEvent;                  // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDisplayedWrapChangedEvent;                       // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMenuInputActionStarted;                          // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMenuInputActionCompleted;                        // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMenuInputActionTriggered;                        // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDisplayedAvatarChangedEvent;                     // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDisplayedTitleChangedEvent;                      // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShowMenu;                                        // 0x0160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMenuModeChange;                                  // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDisplayPopup;                                    // 0x0180(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLocalMenuPosingSpyChanged;                       // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A0[0x20];                                     // 0x01A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            TitlebarInstance;                                  // 0x01C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            TitlebarSpaceInstance;                             // 0x01C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UInputAction*>                   InputsHandledByPopup;                              // 0x01D0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E0[0x8];                                      // 0x01E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FName GetMenuName(EMenuType Menu);
	static EMenuType GetMenuTypeFromName(const class FString& MenuName);

	class UDIMenuUserWidget* AddNewMenuToScreen(TSubclassOf<class UDIMenuUserWidget> MenuClass, class FName MenuName);
	bool AppHasFocus();
	void ClearDisplayedAgent(int32 DisplayedIndex);
	void ClearDisplayedWrap(int32 DisplayedIndex);
	void DisplayAgentSelectionMenu();
	void DisplayGamepadKeybindingsMenu();
	void DisplayKeybindingsMenu();
	void DisplayLegalMenu();
	void DisplayLoginMenu();
	void DisplayMainMenu();
	void DisplayMenu(EMenuType MenuToDisplay);
	void DisplayPauseMenu();
	void DisplayPhaseMenu();
	class UDIPopupUserWidget* DisplayPopup(const class FText& TextToDisplay, const class FString& EventName, EPopupType PopupType);
	class UDIPopupUserWidget* DisplayPopupInternal(const class FText& TitleToDisplay, const class FText& TextToDisplay, const class FString& EventName, EPopupType PopupType);
	void DisplaySettingsMenu();
	void DisplaySpectatorMenu();
	void DisplaySubMenu(ESubMenuPages MenuPage);
	EDIMenuGameModes GetCurrentGameMode();
	struct FPrimaryAssetId GetDisplayedAgent(int32 DisplayedIndex);
	struct FPrimaryAssetId GetDisplayedAvatar(int32 DisplayedIndex);
	struct FPrimaryAssetId GetDisplayedTitle(int32 DisplayedIndex);
	void GetDisplayedWrap(struct FPrimaryAssetId* WeaponId, struct FPrimaryAssetId* WeaponWrapId, int32 DisplayedIndex);
	class APosingSpy* GetLocalPosingSpy();
	TArray<class UGadgetData*> GetOrderedGadgetList();
	class UDIMenuUserWidget* GetOwningMenu(class UUserWidget* UserWidget);
	class UMenuWrapData* GetWrapData(const struct FPrimaryAssetId& WrapId);
	void GoToMainMenu();
	class UDIMenuUserWidget* GoToMenu(class FName MenuName);
	void HandleMatchmakingStarted();
	void HandleMenuEvent(const class FString& EventName, bool AnswerValue);
	void HandlePopupAnswered(const class FString& EventName, bool AnswerValue);
	void HideCursor();
	bool IsCursorShown();
	bool IsGameModeSelectable(EDIMenuGameModes GameMode);
	bool IsMenuGameModeOffered(EDIMenuGameModes GameMode);
	void OnPartyMembersUpdated();
	void PlayDefaultMenuAnim(int32 DisplayedIndex);
	bool PopSpecialAnnouncements();
	void RemoveAgentSelectionMenu();
	void RemoveAllMenusFromScreen();
	void RemoveAllPopupOfEventName(const class FString& EventName);
	void RemoveAllPopupOfType(EPopupType PopupType);
	void RemoveGamepadKeybindingsMenu();
	void RemoveKeybindingsMenu();
	void RemoveLegalMenu();
	void RemoveLoginMenu();
	void RemoveMainMenu();
	void RemoveMenu(EMenuType MenuToRemove);
	bool RemoveMenuFromScreen(class FName MenuName);
	bool RemoveMenuInstanceFromScreen(class UDIMenuUserWidget* Menu);
	bool RemovePauseMenu();
	bool RemovePhaseMenu();
	void RemoveSettingsMenu();
	void RemoveSpectatorMenu();
	void SetDisplayedAgent(const struct FPrimaryAssetId& AgentSkinId, int32 DisplayedIndex);
	void SetDisplayedAvatar(const struct FPrimaryAssetId& AvatarId, int32 DisplayedIndex);
	void SetDisplayedIntroPose(const struct FPrimaryAssetId& IntroPoseId, int32 DisplayedIndex);
	void SetDisplayedIntroPoseToDefault(int32 DisplayedIndex);
	void SetDisplayedTitle(const struct FPrimaryAssetId& TitleId, int32 DisplayedIndex);
	void SetDisplayedWrap(const struct FPrimaryAssetId& WeaponId, const struct FPrimaryAssetId& WrapId, int32 DisplayedIndex);
	void SetMenuGameMode(EDIMenuGameModes NewGameMode);
	bool ShouldButtonPromptsBeDisplayed();
	void ShowCursor(class UDIMenuUserWidget* UserWidget);
	void StartPlayGameMode();
	bool TogglePauseMenu();
	bool TogglePhaseMenu();

	class FText GetDataAssetDisplayDesc(class UDIPrimaryDataAsset* DataAsset) const;
	class UObject* GetDataAssetDisplayIcon(class UDIPrimaryDataAsset* DataAsset) const;
	class FText GetDataAssetDisplayName(class UDIPrimaryDataAsset* DataAsset) const;
	class FText GetDataAssetRewardDesc(class UDIPrimaryDataAsset* DataAsset) const;
	class UObject* GetDataAssetRewardIcon(class UDIPrimaryDataAsset* DataAsset) const;
	class FText GetDataAssetRewardName(class UDIPrimaryDataAsset* DataAsset) const;
	class UDIMenuUserWidget* GetMenuFromName(class FName InName) const;
	TArray<class UMessageUserWidget*> GetMOTDWidgets() const;
	class UDIMenuUserWidget* GetTopmostMenu() const;
	class FName GetTopmostMenuName() const;
	bool HasActiveMenus() const;
	bool HasActiveMenusOrPopup() const;
	bool IsGamepadUsableForMenus() const;
	bool IsInActiveMenu(class FName InName) const;
	bool IsInActiveMenuInstance(class UDIMenuUserWidget* InMenu) const;
	bool IsMenuBackKeyHeld() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIMenuSubsystem">();
	}
	static class UDIMenuSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIMenuSubsystem>();
	}
};
static_assert(alignof(UDIMenuSubsystem) == 0x000008, "Wrong alignment on UDIMenuSubsystem");
static_assert(sizeof(UDIMenuSubsystem) == 0x0001E8, "Wrong size on UDIMenuSubsystem");
static_assert(offsetof(UDIMenuSubsystem, LocalPlayerPosingSpy) == 0x000098, "Member 'UDIMenuSubsystem::LocalPlayerPosingSpy' has a wrong offset!");
static_assert(offsetof(UDIMenuSubsystem, ActiveMenus) == 0x0000A0, "Member 'UDIMenuSubsystem::ActiveMenus' has a wrong offset!");
static_assert(offsetof(UDIMenuSubsystem, PopupWidget) == 0x0000B0, "Member 'UDIMenuSubsystem::PopupWidget' has a wrong offset!");
static_assert(offsetof(UDIMenuSubsystem, SpecialAnnouncementWidget) == 0x0000B8, "Member 'UDIMenuSubsystem::SpecialAnnouncementWidget' has a wrong offset!");
static_assert(offsetof(UDIMenuSubsystem, OnActiveMenuPageChanged) == 0x0000C0, "Member 'UDIMenuSubsystem::OnActiveMenuPageChanged' has a wrong offset!");
static_assert(offsetof(UDIMenuSubsystem, OnMenuEvent) == 0x0000D0, "Member 'UDIMenuSubsystem::OnMenuEvent' has a wrong offset!");
static_assert(offsetof(UDIMenuSubsystem, OnDisplayedAgentChangedEvent) == 0x0000E0, "Member 'UDIMenuSubsystem::OnDisplayedAgentChangedEvent' has a wrong offset!");
static_assert(offsetof(UDIMenuSubsystem, OnDisplayedIntroPoseChangedEvent) == 0x0000F0, "Member 'UDIMenuSubsystem::OnDisplayedIntroPoseChangedEvent' has a wrong offset!");
static_assert(offsetof(UDIMenuSubsystem, OnDisplayedWrapChangedEvent) == 0x000100, "Member 'UDIMenuSubsystem::OnDisplayedWrapChangedEvent' has a wrong offset!");
static_assert(offsetof(UDIMenuSubsystem, OnMenuInputActionStarted) == 0x000110, "Member 'UDIMenuSubsystem::OnMenuInputActionStarted' has a wrong offset!");
static_assert(offsetof(UDIMenuSubsystem, OnMenuInputActionCompleted) == 0x000120, "Member 'UDIMenuSubsystem::OnMenuInputActionCompleted' has a wrong offset!");
static_assert(offsetof(UDIMenuSubsystem, OnMenuInputActionTriggered) == 0x000130, "Member 'UDIMenuSubsystem::OnMenuInputActionTriggered' has a wrong offset!");
static_assert(offsetof(UDIMenuSubsystem, OnDisplayedAvatarChangedEvent) == 0x000140, "Member 'UDIMenuSubsystem::OnDisplayedAvatarChangedEvent' has a wrong offset!");
static_assert(offsetof(UDIMenuSubsystem, OnDisplayedTitleChangedEvent) == 0x000150, "Member 'UDIMenuSubsystem::OnDisplayedTitleChangedEvent' has a wrong offset!");
static_assert(offsetof(UDIMenuSubsystem, OnShowMenu) == 0x000160, "Member 'UDIMenuSubsystem::OnShowMenu' has a wrong offset!");
static_assert(offsetof(UDIMenuSubsystem, OnMenuModeChange) == 0x000170, "Member 'UDIMenuSubsystem::OnMenuModeChange' has a wrong offset!");
static_assert(offsetof(UDIMenuSubsystem, OnDisplayPopup) == 0x000180, "Member 'UDIMenuSubsystem::OnDisplayPopup' has a wrong offset!");
static_assert(offsetof(UDIMenuSubsystem, OnLocalMenuPosingSpyChanged) == 0x000190, "Member 'UDIMenuSubsystem::OnLocalMenuPosingSpyChanged' has a wrong offset!");
static_assert(offsetof(UDIMenuSubsystem, TitlebarInstance) == 0x0001C0, "Member 'UDIMenuSubsystem::TitlebarInstance' has a wrong offset!");
static_assert(offsetof(UDIMenuSubsystem, TitlebarSpaceInstance) == 0x0001C8, "Member 'UDIMenuSubsystem::TitlebarSpaceInstance' has a wrong offset!");
static_assert(offsetof(UDIMenuSubsystem, InputsHandledByPopup) == 0x0001D0, "Member 'UDIMenuSubsystem::InputsHandledByPopup' has a wrong offset!");

// Class DeceiveInc.DINavigationSystem
// 0x0000 (0x15E0 - 0x15E0)
class UDINavigationSystem final : public UNavigationSystemV1
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DINavigationSystem">();
	}
	static class UDINavigationSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDINavigationSystem>();
	}
};
static_assert(alignof(UDINavigationSystem) == 0x000008, "Wrong alignment on UDINavigationSystem");
static_assert(sizeof(UDINavigationSystem) == 0x0015E0, "Wrong size on UDINavigationSystem");

// Class DeceiveInc.HansActiveAbilityMod1
// 0x01B8 (0x0748 - 0x0590)
class AHansActiveAbilityMod1 final : public ABaseSpyActiveAbility
{
public:
	uint8                                         Pad_590[0x8];                                      // 0x0590(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EffectiveAimRange;                                 // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MuzzleSocketName;                                  // 0x059C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A4[0x4];                                      // 0x05A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   HansVictimEffectSpy;                               // 0x05A8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   HansVictimEffectGuard;                             // 0x05D0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnOProjectileDelay;                             // 0x05F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AfterSpawnProjectileDelay;                         // 0x05FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NbOfSpread;                                        // 0x0600(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayBetweenSpread;                                // 0x0604(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpreadDistance;                                    // 0x0608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60C[0x4];                                      // 0x060C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ASpawnerWeaponRound>        WeaponRoundClass;                                  // 0x0610(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHansActiveProjectileHit;                         // 0x0618(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnProjectilesReleased;                             // 0x0628(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnProjectilesAbort;                                // 0x0638(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnShowProjectiles;                                 // 0x0648(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_658[0xA8];                                     // 0x0658(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         AlreadyHitList;                                    // 0x0700(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 LastVictim;                                        // 0x0710(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_718[0x30];                                     // 0x0718(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnHansActiveProjectileHit(class AActor* Victim, const struct FVector& ImpactPoint, const struct FVector& ImpactNormal);
	void BP_OnHansTargetInfected(class AActor* LastInfectedVictim, class AActor* NewInfectedVictim);
	void BP_OnLocalHansActiveEnd();
	void BP_OnLocalHansActiveStart();
	void HandleDelayedSpreadInfection();
	void MulticastFireShot(const struct FVector_NetQuantize& DestinationPos);
	void MulticastNewInfectedVictim(class AActor* LastInfectedVictim, class AActor* NewInfectedVictim);
	void MulticastProjectileHit(class AActor* Victim, const struct FVector_NetQuantize& ImpactPos, const struct FVector_NetQuantizeNormal& ImpactNormal);
	void OnAfterShotTimerEnd();
	void OnServerHansActiveEnd();
	void Server_StartHansActive();

	struct FVector GetMuzzlePosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HansActiveAbilityMod1">();
	}
	static class AHansActiveAbilityMod1* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHansActiveAbilityMod1>();
	}
};
static_assert(alignof(AHansActiveAbilityMod1) == 0x000008, "Wrong alignment on AHansActiveAbilityMod1");
static_assert(sizeof(AHansActiveAbilityMod1) == 0x000748, "Wrong size on AHansActiveAbilityMod1");
static_assert(offsetof(AHansActiveAbilityMod1, EffectiveAimRange) == 0x000598, "Member 'AHansActiveAbilityMod1::EffectiveAimRange' has a wrong offset!");
static_assert(offsetof(AHansActiveAbilityMod1, MuzzleSocketName) == 0x00059C, "Member 'AHansActiveAbilityMod1::MuzzleSocketName' has a wrong offset!");
static_assert(offsetof(AHansActiveAbilityMod1, HansVictimEffectSpy) == 0x0005A8, "Member 'AHansActiveAbilityMod1::HansVictimEffectSpy' has a wrong offset!");
static_assert(offsetof(AHansActiveAbilityMod1, HansVictimEffectGuard) == 0x0005D0, "Member 'AHansActiveAbilityMod1::HansVictimEffectGuard' has a wrong offset!");
static_assert(offsetof(AHansActiveAbilityMod1, SpawnOProjectileDelay) == 0x0005F8, "Member 'AHansActiveAbilityMod1::SpawnOProjectileDelay' has a wrong offset!");
static_assert(offsetof(AHansActiveAbilityMod1, AfterSpawnProjectileDelay) == 0x0005FC, "Member 'AHansActiveAbilityMod1::AfterSpawnProjectileDelay' has a wrong offset!");
static_assert(offsetof(AHansActiveAbilityMod1, NbOfSpread) == 0x000600, "Member 'AHansActiveAbilityMod1::NbOfSpread' has a wrong offset!");
static_assert(offsetof(AHansActiveAbilityMod1, DelayBetweenSpread) == 0x000604, "Member 'AHansActiveAbilityMod1::DelayBetweenSpread' has a wrong offset!");
static_assert(offsetof(AHansActiveAbilityMod1, SpreadDistance) == 0x000608, "Member 'AHansActiveAbilityMod1::SpreadDistance' has a wrong offset!");
static_assert(offsetof(AHansActiveAbilityMod1, WeaponRoundClass) == 0x000610, "Member 'AHansActiveAbilityMod1::WeaponRoundClass' has a wrong offset!");
static_assert(offsetof(AHansActiveAbilityMod1, OnHansActiveProjectileHit) == 0x000618, "Member 'AHansActiveAbilityMod1::OnHansActiveProjectileHit' has a wrong offset!");
static_assert(offsetof(AHansActiveAbilityMod1, OnProjectilesReleased) == 0x000628, "Member 'AHansActiveAbilityMod1::OnProjectilesReleased' has a wrong offset!");
static_assert(offsetof(AHansActiveAbilityMod1, OnProjectilesAbort) == 0x000638, "Member 'AHansActiveAbilityMod1::OnProjectilesAbort' has a wrong offset!");
static_assert(offsetof(AHansActiveAbilityMod1, OnShowProjectiles) == 0x000648, "Member 'AHansActiveAbilityMod1::OnShowProjectiles' has a wrong offset!");
static_assert(offsetof(AHansActiveAbilityMod1, AlreadyHitList) == 0x000700, "Member 'AHansActiveAbilityMod1::AlreadyHitList' has a wrong offset!");
static_assert(offsetof(AHansActiveAbilityMod1, LastVictim) == 0x000710, "Member 'AHansActiveAbilityMod1::LastVictim' has a wrong offset!");

// Class DeceiveInc.DiNavigationWidgetCheckBox
// 0x0008 (0x07C0 - 0x07B8)
class UDiNavigationWidgetCheckBox final : public UDiCheckBox
{
public:
	int32                                         MatchingPageIndex;                                 // 0x07B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7BC[0x4];                                      // 0x07BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiNavigationWidgetCheckBox">();
	}
	static class UDiNavigationWidgetCheckBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiNavigationWidgetCheckBox>();
	}
};
static_assert(alignof(UDiNavigationWidgetCheckBox) == 0x000008, "Wrong alignment on UDiNavigationWidgetCheckBox");
static_assert(sizeof(UDiNavigationWidgetCheckBox) == 0x0007C0, "Wrong size on UDiNavigationWidgetCheckBox");
static_assert(offsetof(UDiNavigationWidgetCheckBox, MatchingPageIndex) == 0x0007B8, "Member 'UDiNavigationWidgetCheckBox::MatchingPageIndex' has a wrong offset!");

// Class DeceiveInc.DIOnlinePartyMemberInfo
// 0x00D0 (0x00F8 - 0x0028)
class UDIOnlinePartyMemberInfo final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayName;                                       // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SubsystemName;                                     // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccountLevel;                                      // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AgentLevel;                                        // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SelectedAgentSkin;                                 // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SelectedAgentWeapon;                               // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SelectedWeaponWrap;                                // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SelectedAvatar;                                    // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SelectedTitle;                                     // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchmakingToken;                                  // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BanditId;                                          // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LevelName;                                         // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDIPartyExtraDataContainer             ExtraData;                                         // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsOnline;                                         // 0x00F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIOnlinePartyMemberInfo">();
	}
	static class UDIOnlinePartyMemberInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIOnlinePartyMemberInfo>();
	}
};
static_assert(alignof(UDIOnlinePartyMemberInfo) == 0x000008, "Wrong alignment on UDIOnlinePartyMemberInfo");
static_assert(sizeof(UDIOnlinePartyMemberInfo) == 0x0000F8, "Wrong size on UDIOnlinePartyMemberInfo");
static_assert(offsetof(UDIOnlinePartyMemberInfo, DisplayName) == 0x000038, "Member 'UDIOnlinePartyMemberInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(UDIOnlinePartyMemberInfo, SubsystemName) == 0x000048, "Member 'UDIOnlinePartyMemberInfo::SubsystemName' has a wrong offset!");
static_assert(offsetof(UDIOnlinePartyMemberInfo, AccountLevel) == 0x000058, "Member 'UDIOnlinePartyMemberInfo::AccountLevel' has a wrong offset!");
static_assert(offsetof(UDIOnlinePartyMemberInfo, AgentLevel) == 0x00005C, "Member 'UDIOnlinePartyMemberInfo::AgentLevel' has a wrong offset!");
static_assert(offsetof(UDIOnlinePartyMemberInfo, SelectedAgentSkin) == 0x000060, "Member 'UDIOnlinePartyMemberInfo::SelectedAgentSkin' has a wrong offset!");
static_assert(offsetof(UDIOnlinePartyMemberInfo, SelectedAgentWeapon) == 0x000070, "Member 'UDIOnlinePartyMemberInfo::SelectedAgentWeapon' has a wrong offset!");
static_assert(offsetof(UDIOnlinePartyMemberInfo, SelectedWeaponWrap) == 0x000080, "Member 'UDIOnlinePartyMemberInfo::SelectedWeaponWrap' has a wrong offset!");
static_assert(offsetof(UDIOnlinePartyMemberInfo, SelectedAvatar) == 0x000090, "Member 'UDIOnlinePartyMemberInfo::SelectedAvatar' has a wrong offset!");
static_assert(offsetof(UDIOnlinePartyMemberInfo, SelectedTitle) == 0x0000A0, "Member 'UDIOnlinePartyMemberInfo::SelectedTitle' has a wrong offset!");
static_assert(offsetof(UDIOnlinePartyMemberInfo, MatchmakingToken) == 0x0000B0, "Member 'UDIOnlinePartyMemberInfo::MatchmakingToken' has a wrong offset!");
static_assert(offsetof(UDIOnlinePartyMemberInfo, BanditId) == 0x0000C0, "Member 'UDIOnlinePartyMemberInfo::BanditId' has a wrong offset!");
static_assert(offsetof(UDIOnlinePartyMemberInfo, LevelName) == 0x0000D0, "Member 'UDIOnlinePartyMemberInfo::LevelName' has a wrong offset!");
static_assert(offsetof(UDIOnlinePartyMemberInfo, ExtraData) == 0x0000E0, "Member 'UDIOnlinePartyMemberInfo::ExtraData' has a wrong offset!");
static_assert(offsetof(UDIOnlinePartyMemberInfo, bIsOnline) == 0x0000F0, "Member 'UDIOnlinePartyMemberInfo::bIsOnline' has a wrong offset!");

// Class DeceiveInc.DIPartySubsystem
// 0x0358 (0x0388 - 0x0030)
class UDIPartySubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0xE0];                                      // 0x0030(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMatchmakingTicketChanged;                        // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGameModeChanged;                                 // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPartyMembersUpdated;                             // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPartyMembersCountChanged;                        // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UDIOnlinePartyMemberInfo*>       PartyMembers;                                      // 0x0150(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UDIOnlinePartyMemberInfo*               LocalPartyMember;                                  // 0x0160(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_168[0x118];                                    // 0x0168(0x0118)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnInvitationsChanged;                              // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPartyCreatedEvent;                               // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnKickedByPartyLeader;                             // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPartyJoinedEvent;                                // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class FString>                         PendingInviteNames;                                // 0x02C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0xB8];                                     // 0x02D0(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 GetMaxPartySizeForGameMode(EDIGameMode NewMode);
	static int32 GetMinPartySizeForGameMode(EDIGameMode NewMode);

	void AcceptPartyInviteFrom(const class FString& InviteSourceName);
	bool CanInviteToParty();
	bool CanStartMatchmaking();
	void CreateParty();
	void EnsurePartyAndGameModeCompatibility();
	class FString GetInviteeName();
	int32 GetNbrPendingInvites();
	class UDIOnlinePartyMemberInfo* GetPartyMemberByDisplayIndex(int32 DisplayIndex);
	void InviteFriend(const class UDIOnlineFriendInfo* FriendInfo);
	void InvitePlayer(const class FString& PlayerUId);
	bool IsAllowedCrossplay();
	bool IsGameCompatibleWithCurrentParty(EDIGameMode GameMode);
	bool IsGameModeSelectable(EDIGameMode GameMode);
	bool IsInSoloPartyOrNotInParty();
	bool IsPartyMemberLeader(class UDIOnlinePartyMemberInfo* PartyMember);
	void KickMember(class UDIOnlinePartyMemberInfo* PartyMember);
	void LeaveParty(bool bSynchronized);
	void RejectPartyInviteFrom(const class FString& InviteSourceName);
	EDIGameMode TrySetCurrentGameMode(EDIGameMode NewMode);
	bool TryStartMatchmaking();
	void WritePartyData();

	EDIGameMode GetCurrentGameMode() const;
	class UDIOnlinePartyInvite* GetInvitationForDIOnlineFriend(const class UDIOnlineFriendInfo* FriendInfo) const;
	class UDIOnlinePartyMemberInfo* GetLocalPartyMember() const;
	EMatchmakingAvailability GetMatchmakingAvailabilityForCurrentMode() const;
	EMatchmakingAvailability GetMatchmakingAvailabilityForMode(EDIGameMode GameMode) const;
	int32 GetNumberOfPlayersInPartyIncludingSelf() const;
	bool IsAllPartyMembersReady() const;
	bool IsBeginnerProtectionEnabledForCurrentGameMode() const;
	bool IsGameModeOffered(EDIGameMode GameMode) const;
	bool IsInParty() const;
	bool IsLocalPartyMember(class UDIOnlinePartyMemberInfo* Member) const;
	bool IsPartyLeader() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIPartySubsystem">();
	}
	static class UDIPartySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIPartySubsystem>();
	}
};
static_assert(alignof(UDIPartySubsystem) == 0x000008, "Wrong alignment on UDIPartySubsystem");
static_assert(sizeof(UDIPartySubsystem) == 0x000388, "Wrong size on UDIPartySubsystem");
static_assert(offsetof(UDIPartySubsystem, OnMatchmakingTicketChanged) == 0x000110, "Member 'UDIPartySubsystem::OnMatchmakingTicketChanged' has a wrong offset!");
static_assert(offsetof(UDIPartySubsystem, OnGameModeChanged) == 0x000120, "Member 'UDIPartySubsystem::OnGameModeChanged' has a wrong offset!");
static_assert(offsetof(UDIPartySubsystem, OnPartyMembersUpdated) == 0x000130, "Member 'UDIPartySubsystem::OnPartyMembersUpdated' has a wrong offset!");
static_assert(offsetof(UDIPartySubsystem, OnPartyMembersCountChanged) == 0x000140, "Member 'UDIPartySubsystem::OnPartyMembersCountChanged' has a wrong offset!");
static_assert(offsetof(UDIPartySubsystem, PartyMembers) == 0x000150, "Member 'UDIPartySubsystem::PartyMembers' has a wrong offset!");
static_assert(offsetof(UDIPartySubsystem, LocalPartyMember) == 0x000160, "Member 'UDIPartySubsystem::LocalPartyMember' has a wrong offset!");
static_assert(offsetof(UDIPartySubsystem, OnInvitationsChanged) == 0x000280, "Member 'UDIPartySubsystem::OnInvitationsChanged' has a wrong offset!");
static_assert(offsetof(UDIPartySubsystem, OnPartyCreatedEvent) == 0x000290, "Member 'UDIPartySubsystem::OnPartyCreatedEvent' has a wrong offset!");
static_assert(offsetof(UDIPartySubsystem, OnKickedByPartyLeader) == 0x0002A0, "Member 'UDIPartySubsystem::OnKickedByPartyLeader' has a wrong offset!");
static_assert(offsetof(UDIPartySubsystem, OnPartyJoinedEvent) == 0x0002B0, "Member 'UDIPartySubsystem::OnPartyJoinedEvent' has a wrong offset!");
static_assert(offsetof(UDIPartySubsystem, PendingInviteNames) == 0x0002C0, "Member 'UDIPartySubsystem::PendingInviteNames' has a wrong offset!");

// Class DeceiveInc.HackTrapScannerTool
// 0x0150 (0x0700 - 0x05B0)
class AHackTrapScannerTool final : public ABaseScannerTool
{
public:
	FMulticastInlineDelegateProperty_             OnTrapTriggerEvent;                                // 0x05B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTrapDeactivateEvent;                             // 0x05C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTrapClearedEvent;                                // 0x05D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         MaxActiveTrap;                                     // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E4[0x4];                                      // 0x05E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   HackTrapVictimEffect;                              // 0x05E8(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameplayResourcesType                        TrapResourceTypeGain;                              // 0x0610(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_611[0x3];                                      // 0x0611(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TrapResourceAmountGain;                            // 0x0614(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VictimAnnouncementDelay;                           // 0x0618(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AnnouncementPriority;                              // 0x061C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnnouncementDuration;                              // 0x0620(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_624[0x4];                                      // 0x0624(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   OwnerAnnouncementText;                             // 0x0628(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class FText                                   VictimAnnouncementText;                            // 0x0640(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class FName                                   HackTrapReticuleHudName;                           // 0x0658(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCooldownComponent*                     CooldownComp;                                      // 0x0660(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayResourcesComponent*            GameplayResource;                                  // 0x0668(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_670[0x8];                                      // 0x0670(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UHackTrapScannableComponent>> ActiveTrap;                                        // 0x0678(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<TWeakObjectPtr<class UHackTrapScannableComponent>, class AActor*> ActiveTrapVisual;                                  // 0x0688(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ActiveVisualRef;                                   // 0x06D8(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void NetMulticast_OnNewAnnouncement(class AActor* Victim);
	void NetMulticast_OnTrapTrigger(class UHackTrapScannableComponent* Trap, class AActor* Victim);
	void OnAnnouncementTimerEnd(class AActor* Victim);
	void OnCooldownChange(bool bOnCooldown);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HackTrapScannerTool">();
	}
	static class AHackTrapScannerTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHackTrapScannerTool>();
	}
};
static_assert(alignof(AHackTrapScannerTool) == 0x000008, "Wrong alignment on AHackTrapScannerTool");
static_assert(sizeof(AHackTrapScannerTool) == 0x000700, "Wrong size on AHackTrapScannerTool");
static_assert(offsetof(AHackTrapScannerTool, OnTrapTriggerEvent) == 0x0005B0, "Member 'AHackTrapScannerTool::OnTrapTriggerEvent' has a wrong offset!");
static_assert(offsetof(AHackTrapScannerTool, OnTrapDeactivateEvent) == 0x0005C0, "Member 'AHackTrapScannerTool::OnTrapDeactivateEvent' has a wrong offset!");
static_assert(offsetof(AHackTrapScannerTool, OnTrapClearedEvent) == 0x0005D0, "Member 'AHackTrapScannerTool::OnTrapClearedEvent' has a wrong offset!");
static_assert(offsetof(AHackTrapScannerTool, MaxActiveTrap) == 0x0005E0, "Member 'AHackTrapScannerTool::MaxActiveTrap' has a wrong offset!");
static_assert(offsetof(AHackTrapScannerTool, HackTrapVictimEffect) == 0x0005E8, "Member 'AHackTrapScannerTool::HackTrapVictimEffect' has a wrong offset!");
static_assert(offsetof(AHackTrapScannerTool, TrapResourceTypeGain) == 0x000610, "Member 'AHackTrapScannerTool::TrapResourceTypeGain' has a wrong offset!");
static_assert(offsetof(AHackTrapScannerTool, TrapResourceAmountGain) == 0x000614, "Member 'AHackTrapScannerTool::TrapResourceAmountGain' has a wrong offset!");
static_assert(offsetof(AHackTrapScannerTool, VictimAnnouncementDelay) == 0x000618, "Member 'AHackTrapScannerTool::VictimAnnouncementDelay' has a wrong offset!");
static_assert(offsetof(AHackTrapScannerTool, AnnouncementPriority) == 0x00061C, "Member 'AHackTrapScannerTool::AnnouncementPriority' has a wrong offset!");
static_assert(offsetof(AHackTrapScannerTool, AnnouncementDuration) == 0x000620, "Member 'AHackTrapScannerTool::AnnouncementDuration' has a wrong offset!");
static_assert(offsetof(AHackTrapScannerTool, OwnerAnnouncementText) == 0x000628, "Member 'AHackTrapScannerTool::OwnerAnnouncementText' has a wrong offset!");
static_assert(offsetof(AHackTrapScannerTool, VictimAnnouncementText) == 0x000640, "Member 'AHackTrapScannerTool::VictimAnnouncementText' has a wrong offset!");
static_assert(offsetof(AHackTrapScannerTool, HackTrapReticuleHudName) == 0x000658, "Member 'AHackTrapScannerTool::HackTrapReticuleHudName' has a wrong offset!");
static_assert(offsetof(AHackTrapScannerTool, CooldownComp) == 0x000660, "Member 'AHackTrapScannerTool::CooldownComp' has a wrong offset!");
static_assert(offsetof(AHackTrapScannerTool, GameplayResource) == 0x000668, "Member 'AHackTrapScannerTool::GameplayResource' has a wrong offset!");
static_assert(offsetof(AHackTrapScannerTool, ActiveTrap) == 0x000678, "Member 'AHackTrapScannerTool::ActiveTrap' has a wrong offset!");
static_assert(offsetof(AHackTrapScannerTool, ActiveTrapVisual) == 0x000688, "Member 'AHackTrapScannerTool::ActiveTrapVisual' has a wrong offset!");
static_assert(offsetof(AHackTrapScannerTool, ActiveVisualRef) == 0x0006D8, "Member 'AHackTrapScannerTool::ActiveVisualRef' has a wrong offset!");

// Class DeceiveInc.DIPingWidget
// 0x0000 (0x02A0 - 0x02A0)
class UDIPingWidget final : public UDIUserWidget
{
public:
	void BP_SetupPingData(const struct FPingData& PingData);
	void BP_SetupTeamIndex(int32 TeamIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIPingWidget">();
	}
	static class UDIPingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIPingWidget>();
	}
};
static_assert(alignof(UDIPingWidget) == 0x000008, "Wrong alignment on UDIPingWidget");
static_assert(sizeof(UDIPingWidget) == 0x0002A0, "Wrong size on UDIPingWidget");

// Class DeceiveInc.DIPlayerSettingsDataAsset
// 0x0258 (0x0290 - 0x0038)
class UDIPlayerSettingsDataAsset final : public UDIPrimaryDataAsset
{
public:
	TMap<EPlayerSettingsType, struct FPlayerSettingDefinition_Boolean> BooleanSettingsDefinitions;                        // 0x0038(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EPlayerSettingsType, struct FPlayerSettingDefinition_Integer> IntegerSettingsDefinitions;                        // 0x0088(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EPlayerSettingsType, struct FPlayerSettingDefinition_Float> FloatSettingsDefinitions;                          // 0x00D8(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EPlayerSettingsType, struct FPlayerSettingDefinition_String> StringSettingsDefinitions;                         // 0x0128(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<class FText>                           DLSSQualityOptionsKeys;                            // 0x0178(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int8>                                  DLSSQualityOptionsValues;                          // 0x0188(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           XeSSQualityOptionsKeys;                            // 0x0198(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int8>                                  XeSSQualityOptionsValues;                          // 0x01A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     ReticleTextureValues;                              // 0x01B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           BotsDifficulty;                                    // 0x01C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<EPlayerSettingsType, struct FSettingsTextOptions> SettingsTextOptions;                               // 0x01D8(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FBindableKeyEntry>              BindableActions;                                   // 0x0228(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UInputMappingContext*                   DefaultSpyKeyboardContext;                         // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputMappingContext*                   DefaultSpyGamepadContext;                          // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputMappingContext*                   DefaultSpyGamepadContext_PS5;                      // 0x0248(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputMappingContext*                   DefaultControllerKeyboardContext;                  // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputMappingContext*                   DefaultControllerGamepadContext;                   // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputMappingContext*                   DefaultMenuKeyboardContext;                        // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputMappingContext*                   DefaultMenuGamepadContext;                         // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputMappingContext*                   DefaultSpectatorKeyboardContext;                   // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputMappingContext*                   DefaultSpectatorGamepadContext;                    // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UInputAction*>                   AllInputActions;                                   // 0x0280(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIPlayerSettingsDataAsset">();
	}
	static class UDIPlayerSettingsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIPlayerSettingsDataAsset>();
	}
};
static_assert(alignof(UDIPlayerSettingsDataAsset) == 0x000008, "Wrong alignment on UDIPlayerSettingsDataAsset");
static_assert(sizeof(UDIPlayerSettingsDataAsset) == 0x000290, "Wrong size on UDIPlayerSettingsDataAsset");
static_assert(offsetof(UDIPlayerSettingsDataAsset, BooleanSettingsDefinitions) == 0x000038, "Member 'UDIPlayerSettingsDataAsset::BooleanSettingsDefinitions' has a wrong offset!");
static_assert(offsetof(UDIPlayerSettingsDataAsset, IntegerSettingsDefinitions) == 0x000088, "Member 'UDIPlayerSettingsDataAsset::IntegerSettingsDefinitions' has a wrong offset!");
static_assert(offsetof(UDIPlayerSettingsDataAsset, FloatSettingsDefinitions) == 0x0000D8, "Member 'UDIPlayerSettingsDataAsset::FloatSettingsDefinitions' has a wrong offset!");
static_assert(offsetof(UDIPlayerSettingsDataAsset, StringSettingsDefinitions) == 0x000128, "Member 'UDIPlayerSettingsDataAsset::StringSettingsDefinitions' has a wrong offset!");
static_assert(offsetof(UDIPlayerSettingsDataAsset, DLSSQualityOptionsKeys) == 0x000178, "Member 'UDIPlayerSettingsDataAsset::DLSSQualityOptionsKeys' has a wrong offset!");
static_assert(offsetof(UDIPlayerSettingsDataAsset, DLSSQualityOptionsValues) == 0x000188, "Member 'UDIPlayerSettingsDataAsset::DLSSQualityOptionsValues' has a wrong offset!");
static_assert(offsetof(UDIPlayerSettingsDataAsset, XeSSQualityOptionsKeys) == 0x000198, "Member 'UDIPlayerSettingsDataAsset::XeSSQualityOptionsKeys' has a wrong offset!");
static_assert(offsetof(UDIPlayerSettingsDataAsset, XeSSQualityOptionsValues) == 0x0001A8, "Member 'UDIPlayerSettingsDataAsset::XeSSQualityOptionsValues' has a wrong offset!");
static_assert(offsetof(UDIPlayerSettingsDataAsset, ReticleTextureValues) == 0x0001B8, "Member 'UDIPlayerSettingsDataAsset::ReticleTextureValues' has a wrong offset!");
static_assert(offsetof(UDIPlayerSettingsDataAsset, BotsDifficulty) == 0x0001C8, "Member 'UDIPlayerSettingsDataAsset::BotsDifficulty' has a wrong offset!");
static_assert(offsetof(UDIPlayerSettingsDataAsset, SettingsTextOptions) == 0x0001D8, "Member 'UDIPlayerSettingsDataAsset::SettingsTextOptions' has a wrong offset!");
static_assert(offsetof(UDIPlayerSettingsDataAsset, BindableActions) == 0x000228, "Member 'UDIPlayerSettingsDataAsset::BindableActions' has a wrong offset!");
static_assert(offsetof(UDIPlayerSettingsDataAsset, DefaultSpyKeyboardContext) == 0x000238, "Member 'UDIPlayerSettingsDataAsset::DefaultSpyKeyboardContext' has a wrong offset!");
static_assert(offsetof(UDIPlayerSettingsDataAsset, DefaultSpyGamepadContext) == 0x000240, "Member 'UDIPlayerSettingsDataAsset::DefaultSpyGamepadContext' has a wrong offset!");
static_assert(offsetof(UDIPlayerSettingsDataAsset, DefaultSpyGamepadContext_PS5) == 0x000248, "Member 'UDIPlayerSettingsDataAsset::DefaultSpyGamepadContext_PS5' has a wrong offset!");
static_assert(offsetof(UDIPlayerSettingsDataAsset, DefaultControllerKeyboardContext) == 0x000250, "Member 'UDIPlayerSettingsDataAsset::DefaultControllerKeyboardContext' has a wrong offset!");
static_assert(offsetof(UDIPlayerSettingsDataAsset, DefaultControllerGamepadContext) == 0x000258, "Member 'UDIPlayerSettingsDataAsset::DefaultControllerGamepadContext' has a wrong offset!");
static_assert(offsetof(UDIPlayerSettingsDataAsset, DefaultMenuKeyboardContext) == 0x000260, "Member 'UDIPlayerSettingsDataAsset::DefaultMenuKeyboardContext' has a wrong offset!");
static_assert(offsetof(UDIPlayerSettingsDataAsset, DefaultMenuGamepadContext) == 0x000268, "Member 'UDIPlayerSettingsDataAsset::DefaultMenuGamepadContext' has a wrong offset!");
static_assert(offsetof(UDIPlayerSettingsDataAsset, DefaultSpectatorKeyboardContext) == 0x000270, "Member 'UDIPlayerSettingsDataAsset::DefaultSpectatorKeyboardContext' has a wrong offset!");
static_assert(offsetof(UDIPlayerSettingsDataAsset, DefaultSpectatorGamepadContext) == 0x000278, "Member 'UDIPlayerSettingsDataAsset::DefaultSpectatorGamepadContext' has a wrong offset!");
static_assert(offsetof(UDIPlayerSettingsDataAsset, AllInputActions) == 0x000280, "Member 'UDIPlayerSettingsDataAsset::AllInputActions' has a wrong offset!");

// Class DeceiveInc.HealthConditionComponent
// 0x0008 (0x00D8 - 0x00D0)
class UHealthConditionComponent final : public UBaseConditionComponent
{
public:
	float                                         HealthAmount;                                      // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          GreaterThan;                                       // 0x00D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Equals;                                            // 0x00D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          LessThan;                                          // 0x00D6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D7[0x1];                                       // 0x00D7(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealthConditionComponent">();
	}
	static class UHealthConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealthConditionComponent>();
	}
};
static_assert(alignof(UHealthConditionComponent) == 0x000008, "Wrong alignment on UHealthConditionComponent");
static_assert(sizeof(UHealthConditionComponent) == 0x0000D8, "Wrong size on UHealthConditionComponent");
static_assert(offsetof(UHealthConditionComponent, HealthAmount) == 0x0000D0, "Member 'UHealthConditionComponent::HealthAmount' has a wrong offset!");
static_assert(offsetof(UHealthConditionComponent, GreaterThan) == 0x0000D4, "Member 'UHealthConditionComponent::GreaterThan' has a wrong offset!");
static_assert(offsetof(UHealthConditionComponent, Equals) == 0x0000D5, "Member 'UHealthConditionComponent::Equals' has a wrong offset!");
static_assert(offsetof(UHealthConditionComponent, LessThan) == 0x0000D6, "Member 'UHealthConditionComponent::LessThan' has a wrong offset!");

// Class DeceiveInc.DiPlayerSettingsSubsystem
// 0x0170 (0x01A0 - 0x0030)
class UDiPlayerSettingsSubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnPlayerSettingsBooleanChange;                     // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerSettingsIntegerChange;                     // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerSettingsFloatChange;                       // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerSettingsStringChange;                      // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSettingAction;                                   // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSettingChange;                                   // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnKeybindingsChanged;                              // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x60];                                      // 0x00A0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EKeybindContext, class UInputMappingContext*> KeyboardInputContexts;                             // 0x0100(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<EKeybindContext, class UInputMappingContext*> GamepadInputContexts;                              // 0x0150(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	static bool IsDX12Enabled();

	bool AddKeyForEnhancedAction(const class UInputAction* InputAction, const struct FKey& Binding, EKeybindContext Context, float AxisScale, EInputDeviceType DeviceType);
	void ApplyDefaultInputMappings(EInputDeviceType DeviceType);
	void CallSettingAction(EPlayerSettingsType SettingType);
	void CommitKeybindingChanges();
	TArray<struct FBindableKeyEntry> GetActionsForCategory(EKeybindContext Category);
	TArray<struct FBindableKeyEntry> GetAxesForCategory(EKeybindContext Category);
	const TArray<struct FBindableKeyEntry> GetBindableActions();
	TArray<EKeybindContext> GetBindingCategories();
	void GetDefaultKeysForEnhancedAction(const class UInputAction* InputAction, TArray<struct FKey>* OutBindings, EKeybindContext Context, float AxisScale, EInputDeviceType DeviceType);
	class UInputMappingContext* GetFirstMappingContext(EKeybindContext Context, EInputDeviceType DeviceType);
	void GetKeysForEnhancedAction(const class UInputAction* InputAction, TArray<struct FKey>* OutBindings, EKeybindContext Context, float AxisScale, EInputDeviceType DeviceType);
	TArray<class UInputMappingContext*> GetMappingContexts(EKeybindContext Context, EInputDeviceType DeviceType);
	bool RemoveKeyFromEnhancedAction(const class UInputAction* InputAction, const struct FKey& Binding, EKeybindContext Context, float AxisScale, EInputDeviceType DeviceType);
	void ResetToDefaultKeysForEnhancedAction(const class UInputAction* InputAction, EKeybindContext Context, EInputDeviceType DeviceType);
	void SetContextuallyDisabledSetting(EPlayerSettingsType SettingType, bool bDisabled);
	bool SetSettingCurrentValue_Boolean(EPlayerSettingsType SettingType, bool NewValue);
	bool SetSettingCurrentValue_Float(EPlayerSettingsType SettingType, float NewValue);
	bool SetSettingCurrentValue_Integer(EPlayerSettingsType SettingType, int32 NewValue);
	bool SetSettingCurrentValue_String(EPlayerSettingsType SettingType, const class FString& NewValue);

	bool GetSettingCurrentValue_Boolean(EPlayerSettingsType SettingType) const;
	float GetSettingCurrentValue_Float(EPlayerSettingsType SettingType) const;
	int32 GetSettingCurrentValue_Integer(EPlayerSettingsType SettingType) const;
	class FString GetSettingCurrentValue_String(EPlayerSettingsType SettingType) const;
	class FText GetSettingDisabledReasonTooltip(EPlayerSettingsType SettingType) const;
	class FText GetSettingLongDescription(EPlayerSettingsType SettingType) const;
	int32 GetSettingMaxLength_String(EPlayerSettingsType SettingType) const;
	float GetSettingMaxValue_Float(EPlayerSettingsType SettingType) const;
	int32 GetSettingMaxValue_Integer(EPlayerSettingsType SettingType) const;
	int32 GetSettingMinLength_String(EPlayerSettingsType SettingType) const;
	float GetSettingMinValue_Float(EPlayerSettingsType SettingType) const;
	int32 GetSettingMinValue_Integer(EPlayerSettingsType SettingType) const;
	TArray<class FString> GetSettingPossibleValues_String(EPlayerSettingsType SettingType) const;
	TArray<class FText> GetSettingPossibleValues_Text(EPlayerSettingsType SettingType) const;
	class FText GetSettingShortDescription(EPlayerSettingsType SettingType) const;
	class FText GetSettingTooltipDecription(EPlayerSettingsType SettingType) const;
	bool IsContextuallyDisabledSetting(EPlayerSettingsType SettingType) const;
	bool IsGameplayTipsEnabled() const;
	bool IsSeparatorSetting(EPlayerSettingsType SettingType) const;
	bool IsSettingAllowedOnThisPlatform(EPlayerSettingsType SettingType) const;
	bool IsSettingEnabled(EPlayerSettingsType SettingType) const;
	bool IsSettingTooltipAvailable(EPlayerSettingsType SettingType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiPlayerSettingsSubsystem">();
	}
	static class UDiPlayerSettingsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiPlayerSettingsSubsystem>();
	}
};
static_assert(alignof(UDiPlayerSettingsSubsystem) == 0x000008, "Wrong alignment on UDiPlayerSettingsSubsystem");
static_assert(sizeof(UDiPlayerSettingsSubsystem) == 0x0001A0, "Wrong size on UDiPlayerSettingsSubsystem");
static_assert(offsetof(UDiPlayerSettingsSubsystem, OnPlayerSettingsBooleanChange) == 0x000030, "Member 'UDiPlayerSettingsSubsystem::OnPlayerSettingsBooleanChange' has a wrong offset!");
static_assert(offsetof(UDiPlayerSettingsSubsystem, OnPlayerSettingsIntegerChange) == 0x000040, "Member 'UDiPlayerSettingsSubsystem::OnPlayerSettingsIntegerChange' has a wrong offset!");
static_assert(offsetof(UDiPlayerSettingsSubsystem, OnPlayerSettingsFloatChange) == 0x000050, "Member 'UDiPlayerSettingsSubsystem::OnPlayerSettingsFloatChange' has a wrong offset!");
static_assert(offsetof(UDiPlayerSettingsSubsystem, OnPlayerSettingsStringChange) == 0x000060, "Member 'UDiPlayerSettingsSubsystem::OnPlayerSettingsStringChange' has a wrong offset!");
static_assert(offsetof(UDiPlayerSettingsSubsystem, OnSettingAction) == 0x000070, "Member 'UDiPlayerSettingsSubsystem::OnSettingAction' has a wrong offset!");
static_assert(offsetof(UDiPlayerSettingsSubsystem, OnSettingChange) == 0x000080, "Member 'UDiPlayerSettingsSubsystem::OnSettingChange' has a wrong offset!");
static_assert(offsetof(UDiPlayerSettingsSubsystem, OnKeybindingsChanged) == 0x000090, "Member 'UDiPlayerSettingsSubsystem::OnKeybindingsChanged' has a wrong offset!");
static_assert(offsetof(UDiPlayerSettingsSubsystem, KeyboardInputContexts) == 0x000100, "Member 'UDiPlayerSettingsSubsystem::KeyboardInputContexts' has a wrong offset!");
static_assert(offsetof(UDiPlayerSettingsSubsystem, GamepadInputContexts) == 0x000150, "Member 'UDiPlayerSettingsSubsystem::GamepadInputContexts' has a wrong offset!");

// Class DeceiveInc.DIPlayerStart
// 0x0018 (0x0268 - 0x0250)
class ADIPlayerStart final : public APlayerStart
{
public:
	struct FPrimaryAssetId                        ForceAgentDataId;                                  // 0x0250(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ANPCCharacter>              DisguiseNPC;                                       // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BP_OnSpySpawnedOnStartPoint(class ASpy* Spy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIPlayerStart">();
	}
	static class ADIPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADIPlayerStart>();
	}
};
static_assert(alignof(ADIPlayerStart) == 0x000008, "Wrong alignment on ADIPlayerStart");
static_assert(sizeof(ADIPlayerStart) == 0x000268, "Wrong size on ADIPlayerStart");
static_assert(offsetof(ADIPlayerStart, ForceAgentDataId) == 0x000250, "Member 'ADIPlayerStart::ForceAgentDataId' has a wrong offset!");
static_assert(offsetof(ADIPlayerStart, DisguiseNPC) == 0x000260, "Member 'ADIPlayerStart::DisguiseNPC' has a wrong offset!");

// Class DeceiveInc.DIPlayerState
// 0x0328 (0x0648 - 0x0320)
class ADIPlayerState final : public APlayerState
{
public:
	FMulticastInlineDelegateProperty_             OnPlayerNameChanged;                               // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAgentSelectionChanged;                           // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEquippedDeckChanged;                             // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyPawnChanged;                                  // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNewLevelGained;                                  // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FXpHolder                              XpData;                                            // 0x0370(0x0040)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	bool                                          bWon;                                              // 0x03B0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPlayerStateFactionChanged;                       // 0x03B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnXpDataChanged;                                   // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyRevivePingEvent;                              // 0x03D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UDIPrimaryDataAsset*>            CachedDAS;                                         // 0x03E8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F8[0x38];                                     // 0x03F8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNewLevelInfo                          LastLevelInfo;                                     // 0x0430(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FNewLevelRewardInfo>            LastLevelRewardInfo;                               // 0x0440(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsFactionEliminated;                              // 0x0450(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         FactionID;                                         // 0x0451(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_452[0x2];                                      // 0x0452(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetId                        AvatarId;                                          // 0x0454(0x0010)(Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPrimaryAssetId                        TitleId;                                           // 0x0464(0x0010)(Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPlayerAgentSelectionInfo              AgentSelection;                                    // 0x0474(0x00B4)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FDISerializedDeckEntry                 EquippedDeck;                                      // 0x0528(0x0010)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FDISerializedAccessories               EquippedAccessories;                               // 0x0538(0x0098)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	int32                                         BanditIDCRC;                                       // 0x05D0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D4[0x4];                                      // 0x05D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerDisplayName;                                 // 0x05D8(0x0010)(Net, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAnonymizePlayerNameType                      HidePlayerName;                                    // 0x05E8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlatformType                                 PlatformType;                                      // 0x05E9(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5EA[0x6];                                      // 0x05EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerProgression                     PlayerProgression;                                 // 0x05F0(0x0020)(Net, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsDead;                                           // 0x0610(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bJustSpawned;                                      // 0x0611(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSpySelected;                                    // 0x0612(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         VCSoundAmplitude;                                  // 0x0613(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_614[0x4];                                      // 0x0614(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         LastDeathTime;                                     // 0x0618(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_620[0x10];                                     // 0x0620(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ASpy*                                   OwnedSpy;                                          // 0x0630(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UDIOnlinePartyMemberInfo*>       PartyMembers;                                      // 0x0638(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void Client_AddWinGamesAchievementProgress();
	void Client_ReceivedXPEvent(EDIXPEvent XPEventType, int32 AddedXP);
	void Client_UpdateAchievement(const class FString& AchievementName, float Progress, bool Increment);
	TArray<class ADIPlayerState*> GetAliveTeammates();
	TArray<struct FPlayerXpTypeEventInfo> GetAllXpDataEventInfo();
	int32 GetMatchGainedCurrency();
	void IncrementMatchCountAchievements();
	bool IsTeamAlive();
	void NetMulticast_TriggerSpectateRevivePing();
	void OnRep_AccessoriesSelection(const struct FDISerializedAccessories& OldVal);
	void OnRep_AgentSelection(const struct FPlayerAgentSelectionInfo& OldVal);
	void OnRep_EquippedDeck(const struct FDISerializedDeckEntry& OldVal);
	void OnRep_FactionEliminated(bool OldVal);
	void OnRep_FactionID(uint8 OldVal);
	void OnRep_LastLevelInfo();
	void OnRep_XpData(const struct FXpHolder& OldXpData);
	void ReviveSpy_Srv();
	void Server_SetHidePlayerName(EAnonymizePlayerNameType InHidePlayerName);
	void Server_SetIsSpySelected(bool bIsSpySelectedIn);
	void Server_TriggerSpectateRevivePing();
	void SetupAsDedicatedSpectator();

	struct FPrimaryAssetId GetActiveID() const;
	struct FPrimaryAssetId GetAgentExpertiseSkillId() const;
	struct FPrimaryAssetId GetAgentGadget1Id() const;
	struct FPrimaryAssetId GetAgentGadget2Id() const;
	struct FPrimaryAssetId GetAgentId() const;
	struct FPrimaryAssetId GetAgentPassiveSkillId() const;
	struct FPrimaryAssetId GetAgentSkinId() const;
	struct FPrimaryAssetId GetAgentWeaponId() const;
	struct FPrimaryAssetId GetAvatarId() const;
	class FText GetDataAssetDisplayName(class UDIPrimaryDataAsset* DataAsset) const;
	class UObject* GetDataAssetRewardIcon(class UDIPrimaryDataAsset* DataAsset) const;
	struct FDISerializedDeckEntry GetEquippedPowerupDeck() const;
	struct FPrimaryAssetId GetIntroPoseId() const;
	int32 GetMatchGainedXP() const;
	int32 GetMatchGainedXPForSpecificXpType(const class FString& XpType) const;
	int32 GetMatchStartCatalogueToken() const;
	struct FPrimaryAssetId GetPassiveID() const;
	EPlatformType GetPlatformType() const;
	class FString GetPlayerDisplayName() const;
	struct FPlayerProgression GetPlayerProgression() const;
	struct FPrimaryAssetId GetTitleId() const;
	struct FPrimaryAssetId GetWeaponWrapID() const;
	bool IsSameFactionAsLocalPlayer() const;
	bool ShouldShowRealNameToLocalPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIPlayerState">();
	}
	static class ADIPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADIPlayerState>();
	}
};
static_assert(alignof(ADIPlayerState) == 0x000008, "Wrong alignment on ADIPlayerState");
static_assert(sizeof(ADIPlayerState) == 0x000648, "Wrong size on ADIPlayerState");
static_assert(offsetof(ADIPlayerState, OnPlayerNameChanged) == 0x000320, "Member 'ADIPlayerState::OnPlayerNameChanged' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, OnAgentSelectionChanged) == 0x000330, "Member 'ADIPlayerState::OnAgentSelectionChanged' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, OnEquippedDeckChanged) == 0x000340, "Member 'ADIPlayerState::OnEquippedDeckChanged' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, OnSpyPawnChanged) == 0x000350, "Member 'ADIPlayerState::OnSpyPawnChanged' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, OnNewLevelGained) == 0x000360, "Member 'ADIPlayerState::OnNewLevelGained' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, XpData) == 0x000370, "Member 'ADIPlayerState::XpData' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, bWon) == 0x0003B0, "Member 'ADIPlayerState::bWon' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, OnPlayerStateFactionChanged) == 0x0003B8, "Member 'ADIPlayerState::OnPlayerStateFactionChanged' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, OnXpDataChanged) == 0x0003C8, "Member 'ADIPlayerState::OnXpDataChanged' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, OnSpyRevivePingEvent) == 0x0003D8, "Member 'ADIPlayerState::OnSpyRevivePingEvent' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, CachedDAS) == 0x0003E8, "Member 'ADIPlayerState::CachedDAS' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, LastLevelInfo) == 0x000430, "Member 'ADIPlayerState::LastLevelInfo' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, LastLevelRewardInfo) == 0x000440, "Member 'ADIPlayerState::LastLevelRewardInfo' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, bIsFactionEliminated) == 0x000450, "Member 'ADIPlayerState::bIsFactionEliminated' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, FactionID) == 0x000451, "Member 'ADIPlayerState::FactionID' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, AvatarId) == 0x000454, "Member 'ADIPlayerState::AvatarId' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, TitleId) == 0x000464, "Member 'ADIPlayerState::TitleId' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, AgentSelection) == 0x000474, "Member 'ADIPlayerState::AgentSelection' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, EquippedDeck) == 0x000528, "Member 'ADIPlayerState::EquippedDeck' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, EquippedAccessories) == 0x000538, "Member 'ADIPlayerState::EquippedAccessories' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, BanditIDCRC) == 0x0005D0, "Member 'ADIPlayerState::BanditIDCRC' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, PlayerDisplayName) == 0x0005D8, "Member 'ADIPlayerState::PlayerDisplayName' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, HidePlayerName) == 0x0005E8, "Member 'ADIPlayerState::HidePlayerName' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, PlatformType) == 0x0005E9, "Member 'ADIPlayerState::PlatformType' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, PlayerProgression) == 0x0005F0, "Member 'ADIPlayerState::PlayerProgression' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, bIsDead) == 0x000610, "Member 'ADIPlayerState::bIsDead' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, bJustSpawned) == 0x000611, "Member 'ADIPlayerState::bJustSpawned' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, bIsSpySelected) == 0x000612, "Member 'ADIPlayerState::bIsSpySelected' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, VCSoundAmplitude) == 0x000613, "Member 'ADIPlayerState::VCSoundAmplitude' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, LastDeathTime) == 0x000618, "Member 'ADIPlayerState::LastDeathTime' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, OwnedSpy) == 0x000630, "Member 'ADIPlayerState::OwnedSpy' has a wrong offset!");
static_assert(offsetof(ADIPlayerState, PartyMembers) == 0x000638, "Member 'ADIPlayerState::PartyMembers' has a wrong offset!");

// Class DeceiveInc.HealTeamComponent
// 0x0008 (0x00B8 - 0x00B0)
class UHealTeamComponent final : public UActorComponent
{
public:
	bool                                          bEnabled;                                          // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealTeamComponent">();
	}
	static class UHealTeamComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealTeamComponent>();
	}
};
static_assert(alignof(UHealTeamComponent) == 0x000008, "Wrong alignment on UHealTeamComponent");
static_assert(sizeof(UHealTeamComponent) == 0x0000B8, "Wrong size on UHealTeamComponent");
static_assert(offsetof(UHealTeamComponent, bEnabled) == 0x0000B0, "Member 'UHealTeamComponent::bEnabled' has a wrong offset!");

// Class DeceiveInc.DIPopupUserWidget
// 0x0068 (0x0368 - 0x0300)
class UDIPopupUserWidget : public UDIMenuUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnPopupAnsweredEvent;                              // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 PopupEventName;                                    // 0x0310(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x48];                                     // 0x0320(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNewTextToDisplay(const class FText& TextToDisplay);
	void OnNewTitleToDisplay(const class FText& TitleToDisplay);
	void OnPopupAnswered(bool bAnswerValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIPopupUserWidget">();
	}
	static class UDIPopupUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIPopupUserWidget>();
	}
};
static_assert(alignof(UDIPopupUserWidget) == 0x000008, "Wrong alignment on UDIPopupUserWidget");
static_assert(sizeof(UDIPopupUserWidget) == 0x000368, "Wrong size on UDIPopupUserWidget");
static_assert(offsetof(UDIPopupUserWidget, OnPopupAnsweredEvent) == 0x000300, "Member 'UDIPopupUserWidget::OnPopupAnsweredEvent' has a wrong offset!");
static_assert(offsetof(UDIPopupUserWidget, PopupEventName) == 0x000310, "Member 'UDIPopupUserWidget::PopupEventName' has a wrong offset!");

// Class DeceiveInc.DIPopupAnnouncementUserWidget
// 0x0138 (0x04A0 - 0x0368)
class UDIPopupAnnouncementUserWidget final : public UDIPopupUserWidget
{
public:
	struct FDISpecialAnnouncmentSettings          SpecialAnnouncmentSettings;                        // 0x0368(0x0130)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bShouldStayOnScreenWhenAnswered;                   // 0x0498(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_499[0x7];                                      // 0x0499(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNewImageToDisplay(const class UTexture* NewImage);
	void Redraw();
	void SetImageToDisplay(const TSoftObjectPtr<class UTexture> NewImage);
	void SetShouldStayOnScreenWhenAnswered(bool InShouldStayOnScreenWhenAnswered);
	void SetSpecialAnnouncmentSettings(const struct FDISpecialAnnouncmentSettings& InMessageSettings);

	TSoftObjectPtr<class UTexture> GetImageAsset() const;
	class FText GetText() const;
	class FText GetTitle() const;
	bool IsShouldStayOnScreenWhenAnswered() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIPopupAnnouncementUserWidget">();
	}
	static class UDIPopupAnnouncementUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIPopupAnnouncementUserWidget>();
	}
};
static_assert(alignof(UDIPopupAnnouncementUserWidget) == 0x000008, "Wrong alignment on UDIPopupAnnouncementUserWidget");
static_assert(sizeof(UDIPopupAnnouncementUserWidget) == 0x0004A0, "Wrong size on UDIPopupAnnouncementUserWidget");
static_assert(offsetof(UDIPopupAnnouncementUserWidget, SpecialAnnouncmentSettings) == 0x000368, "Member 'UDIPopupAnnouncementUserWidget::SpecialAnnouncmentSettings' has a wrong offset!");
static_assert(offsetof(UDIPopupAnnouncementUserWidget, bShouldStayOnScreenWhenAnswered) == 0x000498, "Member 'UDIPopupAnnouncementUserWidget::bShouldStayOnScreenWhenAnswered' has a wrong offset!");

// Class DeceiveInc.InputCaptureWidget
// 0x0000 (0x0368 - 0x0368)
class UInputCaptureWidget final : public UDIPopupUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputCaptureWidget">();
	}
	static class UInputCaptureWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputCaptureWidget>();
	}
};
static_assert(alignof(UInputCaptureWidget) == 0x000008, "Wrong alignment on UInputCaptureWidget");
static_assert(sizeof(UInputCaptureWidget) == 0x000368, "Wrong size on UInputCaptureWidget");

// Class DeceiveInc.DIPrivateLobbyMenuUserWidget
// 0x0020 (0x0320 - 0x0300)
class UDIPrivateLobbyMenuUserWidget final : public UDIMenuUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnPrivateLobbyWidgetPlayerSelectionChange;         // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_310[0x10];                                     // 0x0310(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnPlayerSelectionChange();
	void ClearPlayerSelection();
	TArray<class UDIOnlinePartyMemberInfo*> GetSelectedPlayers();
	bool IsSelectedPlayer(class UDIOnlinePartyMemberInfo* Player);
	void SetSelectedPlayer(class UDIOnlinePartyMemberInfo* Player, bool Selected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIPrivateLobbyMenuUserWidget">();
	}
	static class UDIPrivateLobbyMenuUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIPrivateLobbyMenuUserWidget>();
	}
};
static_assert(alignof(UDIPrivateLobbyMenuUserWidget) == 0x000008, "Wrong alignment on UDIPrivateLobbyMenuUserWidget");
static_assert(sizeof(UDIPrivateLobbyMenuUserWidget) == 0x000320, "Wrong size on UDIPrivateLobbyMenuUserWidget");
static_assert(offsetof(UDIPrivateLobbyMenuUserWidget, OnPrivateLobbyWidgetPlayerSelectionChange) == 0x000300, "Member 'UDIPrivateLobbyMenuUserWidget::OnPrivateLobbyWidgetPlayerSelectionChange' has a wrong offset!");

// Class DeceiveInc.DirectionalDamageIndicatorWidget
// 0x0020 (0x0280 - 0x0260)
class UDirectionalDamageIndicatorWidget : public UUserWidget
{
public:
	class AController*                            OwnerController;                                   // 0x0260(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              NormalizedDirectionToShotOrigin;                   // 0x0268(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Damage;                                            // 0x0270(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHitType                                      HitType;                                           // 0x0274(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_275[0x3];                                      // 0x0275(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxLifetimeInSeconds;                              // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnAddedToScreen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DirectionalDamageIndicatorWidget">();
	}
	static class UDirectionalDamageIndicatorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDirectionalDamageIndicatorWidget>();
	}
};
static_assert(alignof(UDirectionalDamageIndicatorWidget) == 0x000008, "Wrong alignment on UDirectionalDamageIndicatorWidget");
static_assert(sizeof(UDirectionalDamageIndicatorWidget) == 0x000280, "Wrong size on UDirectionalDamageIndicatorWidget");
static_assert(offsetof(UDirectionalDamageIndicatorWidget, OwnerController) == 0x000260, "Member 'UDirectionalDamageIndicatorWidget::OwnerController' has a wrong offset!");
static_assert(offsetof(UDirectionalDamageIndicatorWidget, NormalizedDirectionToShotOrigin) == 0x000268, "Member 'UDirectionalDamageIndicatorWidget::NormalizedDirectionToShotOrigin' has a wrong offset!");
static_assert(offsetof(UDirectionalDamageIndicatorWidget, Damage) == 0x000270, "Member 'UDirectionalDamageIndicatorWidget::Damage' has a wrong offset!");
static_assert(offsetof(UDirectionalDamageIndicatorWidget, HitType) == 0x000274, "Member 'UDirectionalDamageIndicatorWidget::HitType' has a wrong offset!");
static_assert(offsetof(UDirectionalDamageIndicatorWidget, MaxLifetimeInSeconds) == 0x000278, "Member 'UDirectionalDamageIndicatorWidget::MaxLifetimeInSeconds' has a wrong offset!");

// Class DeceiveInc.KeycardPrinterActor
// 0x0010 (0x02C8 - 0x02B8)
class AKeycardPrinterActor final : public ABaseInteractableActor
{
public:
	class UActorAffectedComponent*                ScramblerAffectedComponent;                        // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnScrambleStateChanged(bool bScrambled);
	class AActor* GetPrintedKeycard();
	void HandleScramblerIsAffectedChanged(bool bIsAffected, class AActor* AffectedActor);
	void SetPrintedKeycard(class AActor* PrintedKeycardIn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeycardPrinterActor">();
	}
	static class AKeycardPrinterActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKeycardPrinterActor>();
	}
};
static_assert(alignof(AKeycardPrinterActor) == 0x000008, "Wrong alignment on AKeycardPrinterActor");
static_assert(sizeof(AKeycardPrinterActor) == 0x0002C8, "Wrong size on AKeycardPrinterActor");
static_assert(offsetof(AKeycardPrinterActor, ScramblerAffectedComponent) == 0x0002B8, "Member 'AKeycardPrinterActor::ScramblerAffectedComponent' has a wrong offset!");

// Class DeceiveInc.DIResultScreenMenuUserWidget
// 0x0000 (0x0300 - 0x0300)
class UDIResultScreenMenuUserWidget final : public UDIMenuUserWidget
{
public:
	class UUserWidget* GetSubtitleWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIResultScreenMenuUserWidget">();
	}
	static class UDIResultScreenMenuUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIResultScreenMenuUserWidget>();
	}
};
static_assert(alignof(UDIResultScreenMenuUserWidget) == 0x000008, "Wrong alignment on UDIResultScreenMenuUserWidget");
static_assert(sizeof(UDIResultScreenMenuUserWidget) == 0x000300, "Wrong size on UDIResultScreenMenuUserWidget");

// Class DeceiveInc.DISaveGameSubsystem
// 0x0038 (0x0068 - 0x0030)
class UDISaveGameSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDISaveGame*                            CurrentSaveGame;                                   // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SaveUserIndex;                                     // 0x0060(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCurrentlySaving;                                  // 0x0064(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPendingSaveRequested;                             // 0x0065(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedsBenchmarkRun;                                // 0x0066(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_67[0x1];                                       // 0x0067(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTutorialToCompleted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DISaveGameSubsystem">();
	}
	static class UDISaveGameSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDISaveGameSubsystem>();
	}
};
static_assert(alignof(UDISaveGameSubsystem) == 0x000008, "Wrong alignment on UDISaveGameSubsystem");
static_assert(sizeof(UDISaveGameSubsystem) == 0x000068, "Wrong size on UDISaveGameSubsystem");
static_assert(offsetof(UDISaveGameSubsystem, CurrentSaveGame) == 0x000048, "Member 'UDISaveGameSubsystem::CurrentSaveGame' has a wrong offset!");
static_assert(offsetof(UDISaveGameSubsystem, SaveUserIndex) == 0x000060, "Member 'UDISaveGameSubsystem::SaveUserIndex' has a wrong offset!");
static_assert(offsetof(UDISaveGameSubsystem, bCurrentlySaving) == 0x000064, "Member 'UDISaveGameSubsystem::bCurrentlySaving' has a wrong offset!");
static_assert(offsetof(UDISaveGameSubsystem, bPendingSaveRequested) == 0x000065, "Member 'UDISaveGameSubsystem::bPendingSaveRequested' has a wrong offset!");
static_assert(offsetof(UDISaveGameSubsystem, bNeedsBenchmarkRun) == 0x000066, "Member 'UDISaveGameSubsystem::bNeedsBenchmarkRun' has a wrong offset!");

// Class DeceiveInc.InMimicConditionComponent
// 0x0000 (0x00D0 - 0x00D0)
class UInMimicConditionComponent final : public UBaseConditionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InMimicConditionComponent">();
	}
	static class UInMimicConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInMimicConditionComponent>();
	}
};
static_assert(alignof(UInMimicConditionComponent) == 0x000008, "Wrong alignment on UInMimicConditionComponent");
static_assert(sizeof(UInMimicConditionComponent) == 0x0000D0, "Wrong size on UInMimicConditionComponent");

// Class DeceiveInc.DiscardableComponent
// 0x0028 (0x00D8 - 0x00B0)
class UDiscardableComponent final : public UActorComponent
{
public:
	TSoftClassPtr<class UClass>                   DiscardActorClass;                                 // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiscardableComponent">();
	}
	static class UDiscardableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiscardableComponent>();
	}
};
static_assert(alignof(UDiscardableComponent) == 0x000008, "Wrong alignment on UDiscardableComponent");
static_assert(sizeof(UDiscardableComponent) == 0x0000D8, "Wrong size on UDiscardableComponent");
static_assert(offsetof(UDiscardableComponent, DiscardActorClass) == 0x0000B0, "Member 'UDiscardableComponent::DiscardActorClass' has a wrong offset!");

// Class DeceiveInc.DIPosessionResolver
// 0x0068 (0x0090 - 0x0028)
class UDIPosessionResolver final : public UObject
{
public:
	uint8                                         Pad_28[0x68];                                      // 0x0028(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIPosessionResolver">();
	}
	static class UDIPosessionResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIPosessionResolver>();
	}
};
static_assert(alignof(UDIPosessionResolver) == 0x000008, "Wrong alignment on UDIPosessionResolver");
static_assert(sizeof(UDIPosessionResolver) == 0x000090, "Wrong size on UDIPosessionResolver");

// Class DeceiveInc.ObjectiveProximitySubsystem
// 0x0040 (0x0070 - 0x0030)
class UObjectiveProximitySubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnObjectiveProximityLevelChange;                   // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExtractionCalled;                                // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnObjectiveCarrierFactionChange;                   // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UObjectiveProximityData*                CachedProximityData;                               // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleExtractionArrivedEvent(class UExtractionArrivedPhaseInfo* PhaseInfo);
	void HandleExtractionArrivingEvent(class UExtractionArrivingPhaseInfo* PhaseInfo);
	void HandleExtractionPointSetEvent();
	void HandleProximityCheckTimeTick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveProximitySubsystem">();
	}
	static class UObjectiveProximitySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveProximitySubsystem>();
	}
};
static_assert(alignof(UObjectiveProximitySubsystem) == 0x000008, "Wrong alignment on UObjectiveProximitySubsystem");
static_assert(sizeof(UObjectiveProximitySubsystem) == 0x000070, "Wrong size on UObjectiveProximitySubsystem");
static_assert(offsetof(UObjectiveProximitySubsystem, OnObjectiveProximityLevelChange) == 0x000030, "Member 'UObjectiveProximitySubsystem::OnObjectiveProximityLevelChange' has a wrong offset!");
static_assert(offsetof(UObjectiveProximitySubsystem, OnExtractionCalled) == 0x000040, "Member 'UObjectiveProximitySubsystem::OnExtractionCalled' has a wrong offset!");
static_assert(offsetof(UObjectiveProximitySubsystem, OnObjectiveCarrierFactionChange) == 0x000050, "Member 'UObjectiveProximitySubsystem::OnObjectiveCarrierFactionChange' has a wrong offset!");
static_assert(offsetof(UObjectiveProximitySubsystem, CachedProximityData) == 0x000060, "Member 'UObjectiveProximitySubsystem::CachedProximityData' has a wrong offset!");

// Class DeceiveInc.DISessionInventory
// 0x0020 (0x0048 - 0x0028)
class UDISessionInventory final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPosessionResolverInit;                           // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UDIPosessionResolver*                   PosessionResolver;                                 // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DISessionInventory">();
	}
	static class UDISessionInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDISessionInventory>();
	}
};
static_assert(alignof(UDISessionInventory) == 0x000008, "Wrong alignment on UDISessionInventory");
static_assert(sizeof(UDISessionInventory) == 0x000048, "Wrong size on UDISessionInventory");
static_assert(offsetof(UDISessionInventory, OnPosessionResolverInit) == 0x000030, "Member 'UDISessionInventory::OnPosessionResolverInit' has a wrong offset!");
static_assert(offsetof(UDISessionInventory, PosessionResolver) == 0x000040, "Member 'UDISessionInventory::PosessionResolver' has a wrong offset!");

// Class DeceiveInc.DISessionLoot
// 0x0018 (0x0040 - 0x0028)
class UDISessionLoot final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLootDefinition>                LootBundles;                                       // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DISessionLoot">();
	}
	static class UDISessionLoot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDISessionLoot>();
	}
};
static_assert(alignof(UDISessionLoot) == 0x000008, "Wrong alignment on UDISessionLoot");
static_assert(sizeof(UDISessionLoot) == 0x000040, "Wrong size on UDISessionLoot");
static_assert(offsetof(UDISessionLoot, LootBundles) == 0x000030, "Member 'UDISessionLoot::LootBundles' has a wrong offset!");

// Class DeceiveInc.LevelAreaManager
// 0x0088 (0x00B0 - 0x0028)
class ULevelAreaManager final : public UObject
{
public:
	uint8                                         Pad_28[0x88];                                      // 0x0028(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelAreaManager">();
	}
	static class ULevelAreaManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelAreaManager>();
	}
};
static_assert(alignof(ULevelAreaManager) == 0x000008, "Wrong alignment on ULevelAreaManager");
static_assert(sizeof(ULevelAreaManager) == 0x0000B0, "Wrong size on ULevelAreaManager");

// Class DeceiveInc.DISessionProgression
// 0x0030 (0x0058 - 0x0028)
class UDISessionProgression final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerXpTypeDefinition>        PlayerXpTypes;                                     // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FPlayerXpTypeDefinition GetAgentLevelByXpType(const struct FPrimaryAssetId& XpType);
	struct FPlayerXpTypeDefinition GetAgentMasteryByXpType(const struct FPrimaryAssetId& XpType);
	struct FPlayerXpTypeDefinition GetXpInfoByXpType(const struct FPrimaryAssetId& XpType);

	struct FPlayerXpTypeDefinition GetAgentLevelByString(const class FString& XpType) const;
	struct FPlayerXpTypeDefinition GetAgentMasteryByString(const class FString& XpType) const;
	struct FPlayerXpTypeDefinition GetXpInfoByString(const class FString& XpType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DISessionProgression">();
	}
	static class UDISessionProgression* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDISessionProgression>();
	}
};
static_assert(alignof(UDISessionProgression) == 0x000008, "Wrong alignment on UDISessionProgression");
static_assert(sizeof(UDISessionProgression) == 0x000058, "Wrong size on UDISessionProgression");
static_assert(offsetof(UDISessionProgression, PlayerXpTypes) == 0x000030, "Member 'UDISessionProgression::PlayerXpTypes' has a wrong offset!");

// Class DeceiveInc.SessionAgentSelectionInfo
// 0x0060 (0x0088 - 0x0028)
class USessionAgentSelectionInfo final : public UObject
{
public:
	class UAgentData*                             Agent;                                             // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAgentSkinData*                         AgentSkin;                                         // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAgentIntroPoseDataAsset*               IntroPoseId;                                       // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMenuWrapData*                          WeaponWrapId;                                      // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGadgetData*                            Gadget1;                                           // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMenuWrapData*                          Gadget1WrapId;                                     // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGadgetData*                            Gadget2;                                           // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMenuWrapData*                          Gadget2WrapId;                                     // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAgentWeaponData*                       AgentWeapon;                                       // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAgentExpertiseSkillData*               AgentExpertiseSkill;                               // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAgentPassiveSkillData*                 AgentPassiveSkill;                                 // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EquippedDeck;                                      // 0x0080(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SessionAgentSelectionInfo">();
	}
	static class USessionAgentSelectionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<USessionAgentSelectionInfo>();
	}
};
static_assert(alignof(USessionAgentSelectionInfo) == 0x000008, "Wrong alignment on USessionAgentSelectionInfo");
static_assert(sizeof(USessionAgentSelectionInfo) == 0x000088, "Wrong size on USessionAgentSelectionInfo");
static_assert(offsetof(USessionAgentSelectionInfo, Agent) == 0x000028, "Member 'USessionAgentSelectionInfo::Agent' has a wrong offset!");
static_assert(offsetof(USessionAgentSelectionInfo, AgentSkin) == 0x000030, "Member 'USessionAgentSelectionInfo::AgentSkin' has a wrong offset!");
static_assert(offsetof(USessionAgentSelectionInfo, IntroPoseId) == 0x000038, "Member 'USessionAgentSelectionInfo::IntroPoseId' has a wrong offset!");
static_assert(offsetof(USessionAgentSelectionInfo, WeaponWrapId) == 0x000040, "Member 'USessionAgentSelectionInfo::WeaponWrapId' has a wrong offset!");
static_assert(offsetof(USessionAgentSelectionInfo, Gadget1) == 0x000048, "Member 'USessionAgentSelectionInfo::Gadget1' has a wrong offset!");
static_assert(offsetof(USessionAgentSelectionInfo, Gadget1WrapId) == 0x000050, "Member 'USessionAgentSelectionInfo::Gadget1WrapId' has a wrong offset!");
static_assert(offsetof(USessionAgentSelectionInfo, Gadget2) == 0x000058, "Member 'USessionAgentSelectionInfo::Gadget2' has a wrong offset!");
static_assert(offsetof(USessionAgentSelectionInfo, Gadget2WrapId) == 0x000060, "Member 'USessionAgentSelectionInfo::Gadget2WrapId' has a wrong offset!");
static_assert(offsetof(USessionAgentSelectionInfo, AgentWeapon) == 0x000068, "Member 'USessionAgentSelectionInfo::AgentWeapon' has a wrong offset!");
static_assert(offsetof(USessionAgentSelectionInfo, AgentExpertiseSkill) == 0x000070, "Member 'USessionAgentSelectionInfo::AgentExpertiseSkill' has a wrong offset!");
static_assert(offsetof(USessionAgentSelectionInfo, AgentPassiveSkill) == 0x000078, "Member 'USessionAgentSelectionInfo::AgentPassiveSkill' has a wrong offset!");
static_assert(offsetof(USessionAgentSelectionInfo, EquippedDeck) == 0x000080, "Member 'USessionAgentSelectionInfo::EquippedDeck' has a wrong offset!");

// Class DeceiveInc.DIObjectsToSpawnCountDataAsset
// 0x0010 (0x0048 - 0x0038)
class UDIObjectsToSpawnCountDataAsset final : public UDIPrimaryDataAsset
{
public:
	TArray<struct FObjectToSpawnCount>            ObjectsToSpawnCount;                               // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIObjectsToSpawnCountDataAsset">();
	}
	static class UDIObjectsToSpawnCountDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIObjectsToSpawnCountDataAsset>();
	}
};
static_assert(alignof(UDIObjectsToSpawnCountDataAsset) == 0x000008, "Wrong alignment on UDIObjectsToSpawnCountDataAsset");
static_assert(sizeof(UDIObjectsToSpawnCountDataAsset) == 0x000048, "Wrong size on UDIObjectsToSpawnCountDataAsset");
static_assert(offsetof(UDIObjectsToSpawnCountDataAsset, ObjectsToSpawnCount) == 0x000038, "Member 'UDIObjectsToSpawnCountDataAsset::ObjectsToSpawnCount' has a wrong offset!");

// Class DeceiveInc.SessionAccessoriesSelectionInfo
// 0x0020 (0x0048 - 0x0028)
class USessionAccessoriesSelectionInfo final : public UObject
{
public:
	class UAvatarDataAsset*                       AvatarId;                                          // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTitleDataAsset*                        TitleId;                                           // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UCallingCardDataAsset*>          SelectedCallingCards;                              // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	TArray<class UCallingCardDataAsset*> GetSelectedCallingCards() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SessionAccessoriesSelectionInfo">();
	}
	static class USessionAccessoriesSelectionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<USessionAccessoriesSelectionInfo>();
	}
};
static_assert(alignof(USessionAccessoriesSelectionInfo) == 0x000008, "Wrong alignment on USessionAccessoriesSelectionInfo");
static_assert(sizeof(USessionAccessoriesSelectionInfo) == 0x000048, "Wrong size on USessionAccessoriesSelectionInfo");
static_assert(offsetof(USessionAccessoriesSelectionInfo, AvatarId) == 0x000028, "Member 'USessionAccessoriesSelectionInfo::AvatarId' has a wrong offset!");
static_assert(offsetof(USessionAccessoriesSelectionInfo, TitleId) == 0x000030, "Member 'USessionAccessoriesSelectionInfo::TitleId' has a wrong offset!");
static_assert(offsetof(USessionAccessoriesSelectionInfo, SelectedCallingCards) == 0x000038, "Member 'USessionAccessoriesSelectionInfo::SelectedCallingCards' has a wrong offset!");

// Class DeceiveInc.DISessionSelections
// 0x00C0 (0x00E8 - 0x0028)
class UDISessionSelections final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDISessionSubsystem*                    SessionSubsystem;                                  // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetId                        SelectedAgentId;                                   // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, class USessionAgentSelectionInfo*> AgentSelection;                                    // 0x0070(0x0050)(NativeAccessSpecifierPublic)
	class USessionAccessoriesSelectionInfo*       AccessoriesSelection;                              // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDISerializedDeckEntry>         SetupedDecks;                                      // 0x00C8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         SetupedDecksName;                                  // 0x00D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	TArray<class UAgentSkinData*> DEBUG_GetAllAgentSkinDatasByAgentSkinData(const class UAgentSkinData* AgentSkinData, int32* CurrentIndex);
	TArray<class UAgentIntroPoseDataAsset*> GetAgentIntroPoseDatasByAgentData(const class UAgentData* AgentData);
	TArray<class UAgentSkinData*> GetAgentSkinDatasByAgentData(const class UAgentData* AgentData);
	TArray<class UAvatarDataAsset*> GetAvatarSelection();
	TArray<class UCallingCardDataAsset*> GetCallingCardSelection();
	void GetDeckName(int32 DeckIndex, class FString* DeckName);
	void GetEquippedDeckName(class FString* DeckName);
	void GetSavedPowerupDecksInfos(struct FDISerializedDecks* PlayerDecks);
	TArray<class UTitleDataAsset*> GetTitleSelection();
	TArray<class UMenuWrapData*> GetToolMenuWrapSelection(const struct FPrimaryAssetId& ToolAssetId);
	class UMenuWrapData* GetToolSelectedWrap(const struct FPrimaryAssetId& ToolAssetId);
	bool IsAgentSelectable(const struct FPrimaryAssetId& AgentId);
	bool IsAgentSkinSelectable(const struct FPrimaryAssetId& AgentSkinId);
	void SetAgentIntroPoseIdByAgentId(const struct FPrimaryAssetId& AgentId, const struct FPrimaryAssetId& IntroPoseId);
	void SetAgentSkinIdByAgentId(const struct FPrimaryAssetId& AgentId, const struct FPrimaryAssetId& SkinId);
	void SetCallingCard(const struct FPrimaryAssetId& CallingCardId, ECallingCardPosition CalingCardPosition);
	void SetDeckName(int32 DeckIndex, const class FString& NewDeckName);
	void SetDeckPowerupToSlot(int32 SlotIndex, int32 PowerupUpIndex);
	void SetPowerupDeckToEquip(int32 NewDeckIndex);
	void SetSelectedAgent(const struct FPrimaryAssetId& AgentId, bool bSaveToStorage);
	void SetSelectedAgentSkin(class UAgentSkinData* AgentSkinData);
	void SetSelectedAvatar(const struct FPrimaryAssetId& AvatarId);
	void SetSelectedExpertiseSkillOnSelectedAgent(const struct FPrimaryAssetId& ExpertiseSkillId);
	void SetSelectedGadgetOnSelectedAgent(const struct FPrimaryAssetId& GadgetId, int32 GadgetIndex);
	void SetSelectedPassiveSkillOnSelectedAgent(const struct FPrimaryAssetId& PassiveSkillId);
	void SetSelectedTitle(const struct FPrimaryAssetId& TitleId);
	void SetSelectedWeaponOnSelectedAgent(const struct FPrimaryAssetId& WeaponId);
	void SetSelectedWrapOnTool(class UMenuWrapData* WrapId, const struct FPrimaryAssetId& ToolAssetId);

	class USessionAccessoriesSelectionInfo* GetAccessoriesInfos() const;
	class USessionAgentSelectionInfo* GetAgentSelectionInfosByAgentId(const struct FPrimaryAssetId& AgentId) const;
	struct FDISerializedDeckEntry GetEquippedDeck() const;
	int32 GetEquippedDeckIndex() const;
	class USessionAgentSelectionInfo* GetSelectedAgentSelectionInfos() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DISessionSelections">();
	}
	static class UDISessionSelections* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDISessionSelections>();
	}
};
static_assert(alignof(UDISessionSelections) == 0x000008, "Wrong alignment on UDISessionSelections");
static_assert(sizeof(UDISessionSelections) == 0x0000E8, "Wrong size on UDISessionSelections");
static_assert(offsetof(UDISessionSelections, SessionSubsystem) == 0x000040, "Member 'UDISessionSelections::SessionSubsystem' has a wrong offset!");
static_assert(offsetof(UDISessionSelections, SelectedAgentId) == 0x000060, "Member 'UDISessionSelections::SelectedAgentId' has a wrong offset!");
static_assert(offsetof(UDISessionSelections, AgentSelection) == 0x000070, "Member 'UDISessionSelections::AgentSelection' has a wrong offset!");
static_assert(offsetof(UDISessionSelections, AccessoriesSelection) == 0x0000C0, "Member 'UDISessionSelections::AccessoriesSelection' has a wrong offset!");
static_assert(offsetof(UDISessionSelections, SetupedDecks) == 0x0000C8, "Member 'UDISessionSelections::SetupedDecks' has a wrong offset!");
static_assert(offsetof(UDISessionSelections, SetupedDecksName) == 0x0000D8, "Member 'UDISessionSelections::SetupedDecksName' has a wrong offset!");

// Class DeceiveInc.VictimEffect
// 0x0238 (0x0458 - 0x0220)
class AVictimEffect : public AActor
{
public:
	EVictimEffectPositioningType                  EffectPositioningRule;                             // 0x0220(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221[0x3];                                      // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   VictimSocketName;                                  // 0x0224(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ActivateEffectOnSpawn;                             // 0x022C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEndOnVictimDeath;                                 // 0x022D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFiniteDuration;                                   // 0x022E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPositiveEffect;                                   // 0x022F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCannotBeCleansed;                                 // 0x0230(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, uint32>                   VariantDataDefinition;                             // 0x0238(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 VariantData;                                       // 0x0288(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         EffectFadeOutDuration;                             // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTriggerAnnoncementOnNewTempEffectDuration;        // 0x029C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29D[0x3];                                      // 0x029D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   DamageModifierClass;                               // 0x02A0(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   TickEffectClass;                                   // 0x02C8(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EffectTickPeriod;                                  // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyActiveEffectOnStart;                         // 0x02F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTickEffectEnabled;                                // 0x02F5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F6[0x2];                                      // 0x02F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   EffectStartAnnouncementText;                       // 0x02F8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   EffectEndAnnouncementText;                         // 0x0310(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	EAnnouncementType                             EffectAnnouncementType;                            // 0x0328(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAnnouncementGroup                            EffectAnnouncementGroup;                           // 0x0329(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32A[0x2];                                      // 0x032A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EffectAnnouncementPriority;                        // 0x032C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EffectAnnouncementDuration;                        // 0x0330(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   EffectHudAsset;                                    // 0x0338(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   FollowEffectHudAsset;                              // 0x0360(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFollowWidgetInstigatorOnly;                       // 0x0388(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFollowWidgetFactionOnly;                          // 0x0389(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFollowWidgetHandleImmaterialSpies;                // 0x038A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFollowWidgetVisibleOnSpiesOnly;                   // 0x038B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bValidateWidgetVisibility;                         // 0x038C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38D[0x3];                                      // 0x038D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 EffectHudAssetHolder;                              // 0x0390(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 FollowEffectHudAssetHolder;                        // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 DamageModifierClassHolder;                         // 0x03A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDamageModifier*                        DamageModifierInstance;                            // 0x03A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVictimEffectUserWidget*                FollowEffectHudWidget;                             // 0x03B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVictimEffectUserWidget*                StatusEffectHudWidget;                             // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentLifetime;                                   // 0x03C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C4[0x14];                                     // 0x03C4(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UVictimEffectTickBehavior*              EffectDataInstance;                                // 0x03D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 EffectInstigator;                                  // 0x03E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 EffectVictim;                                      // 0x03E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  TestSafety;                                        // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EffectDuration;                                    // 0x03F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ForceAnimUpdateOnDisguise;                         // 0x03FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3FD[0xB];                                      // 0x03FD(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEffectInfo                            EffectInfo;                                        // 0x0408(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnVictimEffectStart;                               // 0x0428(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnVictimEffectEnd;                                 // 0x0438(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnAnnouncementRefresh;                             // 0x0448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	void ActivateEffect();
	void BP_InitializeDamageModifier(class UDamageModifier* DamageModifier);
	void BP_InitializeTickEffect(class UVictimEffectTickBehavior* TickEffect);
	void BP_OnAnnouncementRefresh();
	void BP_OnDurationChanged();
	void BP_OnEffectEnd(class AVictimEffect* Effect, class AActor* Victim);
	void BP_OnEffectFadeOutEnd(class AVictimEffect* Effect);
	void BP_OnEffectFadeOutStart(class AVictimEffect* Effect);
	void BP_OnEffectStart(class AVictimEffect* Effect, class AActor* Victim);
	void BP_OnEffectTick(class AVictimEffect* Effect, class AActor* Victim);
	void BP_OnEffectTriggered(class AVictimEffect* Effect, class AActor* Victim);
	void BP_OnNewEffectInstigator(class AActor* NewEffectInstigator);
	void BP_OnVictimChanged(class AActor* NewVictim);
	void BP_OnWidgetReady(class UVictimEffectUserWidget* NewWidget);
	bool CanBeCleansed();
	void DeactivateEffect();
	void DoEffectTickOnVictim();
	void FadeAndDeactivateEffect();
	class AActor* GetEffectInstigator();
	float GetEffectTickLeftPercentage();
	float GetEffectTimeLeftPercentage();
	float GetLifetime();
	int32 GetVariantData(const class FString& ID);
	void HandleVictimCoverChange(bool CoverState);
	void HandleVictimCoverSwitch(class ANPCCharacter* NewCover);
	bool IsPositiveEffect();
	void NetMulticast_DoAnnouncementRefresh();
	void OnRep_EffectInfo(const struct FEffectInfo& OldEffectInfo);
	void OnRep_Lifetime();
	void PauseTickEffect(bool bPause);
	void SetEffectDuration(float NewEffectDuration);
	void SetEffectPositioningType(EVictimEffectPositioningType PositioningType);
	void SetEffectPositioningTypeWithSocket(EVictimEffectPositioningType PositioningType, class FName SocketName);
	void SetInstigator(class AActor* CausingActor);
	void SetTickEffectEnabled(bool bEnabled);
	void SetupEffect(class AActor* NewVictim, class AActor* NewInstigator, bool bStartEffect, float NewDuration);
	void SetVariantData(const class FString& ID, int32 Value);
	void SetVictim(class AActor* Victim);

	float GetEffectTimeLeft() const;
	bool IsActive() const;
	bool IsSameFactionFromInstigator() const;
	bool IsSameFactionFromInstigatorPawn(class APawn* PawnToCheck) const;
	bool ShouldShowFollowEffectHud() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VictimEffect">();
	}
	static class AVictimEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVictimEffect>();
	}
};
static_assert(alignof(AVictimEffect) == 0x000008, "Wrong alignment on AVictimEffect");
static_assert(sizeof(AVictimEffect) == 0x000458, "Wrong size on AVictimEffect");
static_assert(offsetof(AVictimEffect, EffectPositioningRule) == 0x000220, "Member 'AVictimEffect::EffectPositioningRule' has a wrong offset!");
static_assert(offsetof(AVictimEffect, VictimSocketName) == 0x000224, "Member 'AVictimEffect::VictimSocketName' has a wrong offset!");
static_assert(offsetof(AVictimEffect, ActivateEffectOnSpawn) == 0x00022C, "Member 'AVictimEffect::ActivateEffectOnSpawn' has a wrong offset!");
static_assert(offsetof(AVictimEffect, bEndOnVictimDeath) == 0x00022D, "Member 'AVictimEffect::bEndOnVictimDeath' has a wrong offset!");
static_assert(offsetof(AVictimEffect, bFiniteDuration) == 0x00022E, "Member 'AVictimEffect::bFiniteDuration' has a wrong offset!");
static_assert(offsetof(AVictimEffect, bPositiveEffect) == 0x00022F, "Member 'AVictimEffect::bPositiveEffect' has a wrong offset!");
static_assert(offsetof(AVictimEffect, bCannotBeCleansed) == 0x000230, "Member 'AVictimEffect::bCannotBeCleansed' has a wrong offset!");
static_assert(offsetof(AVictimEffect, VariantDataDefinition) == 0x000238, "Member 'AVictimEffect::VariantDataDefinition' has a wrong offset!");
static_assert(offsetof(AVictimEffect, VariantData) == 0x000288, "Member 'AVictimEffect::VariantData' has a wrong offset!");
static_assert(offsetof(AVictimEffect, EffectFadeOutDuration) == 0x000298, "Member 'AVictimEffect::EffectFadeOutDuration' has a wrong offset!");
static_assert(offsetof(AVictimEffect, bTriggerAnnoncementOnNewTempEffectDuration) == 0x00029C, "Member 'AVictimEffect::bTriggerAnnoncementOnNewTempEffectDuration' has a wrong offset!");
static_assert(offsetof(AVictimEffect, DamageModifierClass) == 0x0002A0, "Member 'AVictimEffect::DamageModifierClass' has a wrong offset!");
static_assert(offsetof(AVictimEffect, TickEffectClass) == 0x0002C8, "Member 'AVictimEffect::TickEffectClass' has a wrong offset!");
static_assert(offsetof(AVictimEffect, EffectTickPeriod) == 0x0002F0, "Member 'AVictimEffect::EffectTickPeriod' has a wrong offset!");
static_assert(offsetof(AVictimEffect, bApplyActiveEffectOnStart) == 0x0002F4, "Member 'AVictimEffect::bApplyActiveEffectOnStart' has a wrong offset!");
static_assert(offsetof(AVictimEffect, bTickEffectEnabled) == 0x0002F5, "Member 'AVictimEffect::bTickEffectEnabled' has a wrong offset!");
static_assert(offsetof(AVictimEffect, EffectStartAnnouncementText) == 0x0002F8, "Member 'AVictimEffect::EffectStartAnnouncementText' has a wrong offset!");
static_assert(offsetof(AVictimEffect, EffectEndAnnouncementText) == 0x000310, "Member 'AVictimEffect::EffectEndAnnouncementText' has a wrong offset!");
static_assert(offsetof(AVictimEffect, EffectAnnouncementType) == 0x000328, "Member 'AVictimEffect::EffectAnnouncementType' has a wrong offset!");
static_assert(offsetof(AVictimEffect, EffectAnnouncementGroup) == 0x000329, "Member 'AVictimEffect::EffectAnnouncementGroup' has a wrong offset!");
static_assert(offsetof(AVictimEffect, EffectAnnouncementPriority) == 0x00032C, "Member 'AVictimEffect::EffectAnnouncementPriority' has a wrong offset!");
static_assert(offsetof(AVictimEffect, EffectAnnouncementDuration) == 0x000330, "Member 'AVictimEffect::EffectAnnouncementDuration' has a wrong offset!");
static_assert(offsetof(AVictimEffect, EffectHudAsset) == 0x000338, "Member 'AVictimEffect::EffectHudAsset' has a wrong offset!");
static_assert(offsetof(AVictimEffect, FollowEffectHudAsset) == 0x000360, "Member 'AVictimEffect::FollowEffectHudAsset' has a wrong offset!");
static_assert(offsetof(AVictimEffect, bFollowWidgetInstigatorOnly) == 0x000388, "Member 'AVictimEffect::bFollowWidgetInstigatorOnly' has a wrong offset!");
static_assert(offsetof(AVictimEffect, bFollowWidgetFactionOnly) == 0x000389, "Member 'AVictimEffect::bFollowWidgetFactionOnly' has a wrong offset!");
static_assert(offsetof(AVictimEffect, bFollowWidgetHandleImmaterialSpies) == 0x00038A, "Member 'AVictimEffect::bFollowWidgetHandleImmaterialSpies' has a wrong offset!");
static_assert(offsetof(AVictimEffect, bFollowWidgetVisibleOnSpiesOnly) == 0x00038B, "Member 'AVictimEffect::bFollowWidgetVisibleOnSpiesOnly' has a wrong offset!");
static_assert(offsetof(AVictimEffect, bValidateWidgetVisibility) == 0x00038C, "Member 'AVictimEffect::bValidateWidgetVisibility' has a wrong offset!");
static_assert(offsetof(AVictimEffect, EffectHudAssetHolder) == 0x000390, "Member 'AVictimEffect::EffectHudAssetHolder' has a wrong offset!");
static_assert(offsetof(AVictimEffect, FollowEffectHudAssetHolder) == 0x000398, "Member 'AVictimEffect::FollowEffectHudAssetHolder' has a wrong offset!");
static_assert(offsetof(AVictimEffect, DamageModifierClassHolder) == 0x0003A0, "Member 'AVictimEffect::DamageModifierClassHolder' has a wrong offset!");
static_assert(offsetof(AVictimEffect, DamageModifierInstance) == 0x0003A8, "Member 'AVictimEffect::DamageModifierInstance' has a wrong offset!");
static_assert(offsetof(AVictimEffect, FollowEffectHudWidget) == 0x0003B0, "Member 'AVictimEffect::FollowEffectHudWidget' has a wrong offset!");
static_assert(offsetof(AVictimEffect, StatusEffectHudWidget) == 0x0003B8, "Member 'AVictimEffect::StatusEffectHudWidget' has a wrong offset!");
static_assert(offsetof(AVictimEffect, CurrentLifetime) == 0x0003C0, "Member 'AVictimEffect::CurrentLifetime' has a wrong offset!");
static_assert(offsetof(AVictimEffect, EffectDataInstance) == 0x0003D8, "Member 'AVictimEffect::EffectDataInstance' has a wrong offset!");
static_assert(offsetof(AVictimEffect, EffectInstigator) == 0x0003E0, "Member 'AVictimEffect::EffectInstigator' has a wrong offset!");
static_assert(offsetof(AVictimEffect, EffectVictim) == 0x0003E8, "Member 'AVictimEffect::EffectVictim' has a wrong offset!");
static_assert(offsetof(AVictimEffect, TestSafety) == 0x0003F0, "Member 'AVictimEffect::TestSafety' has a wrong offset!");
static_assert(offsetof(AVictimEffect, EffectDuration) == 0x0003F8, "Member 'AVictimEffect::EffectDuration' has a wrong offset!");
static_assert(offsetof(AVictimEffect, ForceAnimUpdateOnDisguise) == 0x0003FC, "Member 'AVictimEffect::ForceAnimUpdateOnDisguise' has a wrong offset!");
static_assert(offsetof(AVictimEffect, EffectInfo) == 0x000408, "Member 'AVictimEffect::EffectInfo' has a wrong offset!");
static_assert(offsetof(AVictimEffect, OnVictimEffectStart) == 0x000428, "Member 'AVictimEffect::OnVictimEffectStart' has a wrong offset!");
static_assert(offsetof(AVictimEffect, OnVictimEffectEnd) == 0x000438, "Member 'AVictimEffect::OnVictimEffectEnd' has a wrong offset!");
static_assert(offsetof(AVictimEffect, OnAnnouncementRefresh) == 0x000448, "Member 'AVictimEffect::OnAnnouncementRefresh' has a wrong offset!");

// Class DeceiveInc.ObjectiveCarrierVictimEffect
// 0x0030 (0x0488 - 0x0458)
class AObjectiveCarrierVictimEffect final : public AVictimEffect
{
public:
	float                                         PostPingCooldown;                                  // 0x0458(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeBetweenPings;                                  // 0x045C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PingVisibleTime;                                   // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RunIncrementModifier;                              // 0x0464(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         XiuTeleportIncrementModifier;                      // 0x0468(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CavKickIncrementModifier;                          // 0x046C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EmpoweredModeIncrementModifier;                    // 0x0470(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DisablePingOnEmpoweredNavmode;                     // 0x0474(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_475[0x3];                                      // 0x0475(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CooldownLeft;                                      // 0x0478(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToNextPing;                                    // 0x047C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeVisible;                                       // 0x0480(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_484[0x4];                                      // 0x0484(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_DoPingEffect();
	void BP_HidePingEffect();
	float GetPingRatio();
	bool IsInCooldown();
	void NotifyPingMulticast();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveCarrierVictimEffect">();
	}
	static class AObjectiveCarrierVictimEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AObjectiveCarrierVictimEffect>();
	}
};
static_assert(alignof(AObjectiveCarrierVictimEffect) == 0x000008, "Wrong alignment on AObjectiveCarrierVictimEffect");
static_assert(sizeof(AObjectiveCarrierVictimEffect) == 0x000488, "Wrong size on AObjectiveCarrierVictimEffect");
static_assert(offsetof(AObjectiveCarrierVictimEffect, PostPingCooldown) == 0x000458, "Member 'AObjectiveCarrierVictimEffect::PostPingCooldown' has a wrong offset!");
static_assert(offsetof(AObjectiveCarrierVictimEffect, TimeBetweenPings) == 0x00045C, "Member 'AObjectiveCarrierVictimEffect::TimeBetweenPings' has a wrong offset!");
static_assert(offsetof(AObjectiveCarrierVictimEffect, PingVisibleTime) == 0x000460, "Member 'AObjectiveCarrierVictimEffect::PingVisibleTime' has a wrong offset!");
static_assert(offsetof(AObjectiveCarrierVictimEffect, RunIncrementModifier) == 0x000464, "Member 'AObjectiveCarrierVictimEffect::RunIncrementModifier' has a wrong offset!");
static_assert(offsetof(AObjectiveCarrierVictimEffect, XiuTeleportIncrementModifier) == 0x000468, "Member 'AObjectiveCarrierVictimEffect::XiuTeleportIncrementModifier' has a wrong offset!");
static_assert(offsetof(AObjectiveCarrierVictimEffect, CavKickIncrementModifier) == 0x00046C, "Member 'AObjectiveCarrierVictimEffect::CavKickIncrementModifier' has a wrong offset!");
static_assert(offsetof(AObjectiveCarrierVictimEffect, EmpoweredModeIncrementModifier) == 0x000470, "Member 'AObjectiveCarrierVictimEffect::EmpoweredModeIncrementModifier' has a wrong offset!");
static_assert(offsetof(AObjectiveCarrierVictimEffect, DisablePingOnEmpoweredNavmode) == 0x000474, "Member 'AObjectiveCarrierVictimEffect::DisablePingOnEmpoweredNavmode' has a wrong offset!");
static_assert(offsetof(AObjectiveCarrierVictimEffect, CooldownLeft) == 0x000478, "Member 'AObjectiveCarrierVictimEffect::CooldownLeft' has a wrong offset!");
static_assert(offsetof(AObjectiveCarrierVictimEffect, TimeToNextPing) == 0x00047C, "Member 'AObjectiveCarrierVictimEffect::TimeToNextPing' has a wrong offset!");
static_assert(offsetof(AObjectiveCarrierVictimEffect, TimeVisible) == 0x000480, "Member 'AObjectiveCarrierVictimEffect::TimeVisible' has a wrong offset!");

// Class DeceiveInc.DISessionStats
// 0x0008 (0x0030 - 0x0028)
class UDISessionStats final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<struct FClassPlayTimeDefinition> ClassPlayTime();
	int32 DeathsSolo();
	int32 DeathsTeam();
	int32 KillsSolo();
	int32 KillsTeam();
	int32 MatchesPlayedDuo();
	int32 MatchesPlayedSolo();
	int32 MatchesPlayedTeam();
	int32 MatchesWonDuo();
	int32 MatchesWonSolo();
	int32 MatchesWonTeam();
	TArray<struct FAgentPlayTimeDefinition> TopPlayedAgents();
	int32 TotalGames();
	int32 TotalPlayTime();
	int32 VictoryPercentage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DISessionStats">();
	}
	static class UDISessionStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDISessionStats>();
	}
};
static_assert(alignof(UDISessionStats) == 0x000008, "Wrong alignment on UDISessionStats");
static_assert(sizeof(UDISessionStats) == 0x000030, "Wrong size on UDISessionStats");

// Class DeceiveInc.Level3DPortraitSpot
// 0x0008 (0x0228 - 0x0220)
class ALevel3DPortraitSpot final : public AActor
{
public:
	bool                                          bDisablePortraitSpot;                              // 0x0220(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Level3DPortraitSpot">();
	}
	static class ALevel3DPortraitSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevel3DPortraitSpot>();
	}
};
static_assert(alignof(ALevel3DPortraitSpot) == 0x000008, "Wrong alignment on ALevel3DPortraitSpot");
static_assert(sizeof(ALevel3DPortraitSpot) == 0x000228, "Wrong size on ALevel3DPortraitSpot");
static_assert(offsetof(ALevel3DPortraitSpot, bDisablePortraitSpot) == 0x000220, "Member 'ALevel3DPortraitSpot::bDisablePortraitSpot' has a wrong offset!");

// Class DeceiveInc.DISettingsMenuUserWidget
// 0x0000 (0x0300 - 0x0300)
class UDISettingsMenuUserWidget final : public UDIMenuUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DISettingsMenuUserWidget">();
	}
	static class UDISettingsMenuUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDISettingsMenuUserWidget>();
	}
};
static_assert(alignof(UDISettingsMenuUserWidget) == 0x000008, "Wrong alignment on UDISettingsMenuUserWidget");
static_assert(sizeof(UDISettingsMenuUserWidget) == 0x000300, "Wrong size on UDISettingsMenuUserWidget");

// Class DeceiveInc.DisguiseAsNPCConditionComponent
// 0x0000 (0x00D0 - 0x00D0)
class UDisguiseAsNPCConditionComponent final : public UBaseConditionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisguiseAsNPCConditionComponent">();
	}
	static class UDisguiseAsNPCConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisguiseAsNPCConditionComponent>();
	}
};
static_assert(alignof(UDisguiseAsNPCConditionComponent) == 0x000008, "Wrong alignment on UDisguiseAsNPCConditionComponent");
static_assert(sizeof(UDisguiseAsNPCConditionComponent) == 0x0000D0, "Wrong size on UDisguiseAsNPCConditionComponent");

// Class DeceiveInc.LoginMenuUserWidget
// 0x0000 (0x0300 - 0x0300)
class ULoginMenuUserWidget final : public UDIMenuUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoginMenuUserWidget">();
	}
	static class ULoginMenuUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoginMenuUserWidget>();
	}
};
static_assert(alignof(ULoginMenuUserWidget) == 0x000008, "Wrong alignment on ULoginMenuUserWidget");
static_assert(sizeof(ULoginMenuUserWidget) == 0x000300, "Wrong size on ULoginMenuUserWidget");

// Class DeceiveInc.DisguiseShieldComponent
// 0x0090 (0x0140 - 0x00B0)
class UDisguiseShieldComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnDisguiseShieldInitDone;                          // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHealthComponent*                       HealthComponent;                                   // 0x00C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ShieldDisguiseDamageModifier;                      // 0x00D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDamageModifier*                        ShieldDisguiseDamageModifierInstance;              // 0x00F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ShieldDamageModifier;                              // 0x0100(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDamageModifier*                        ShieldDamageModifierInstance;                      // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageReductionDuration;                           // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_134[0xC];                                      // 0x0134(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleCoverChange(bool Undercover);
	void HandleNewDisguise(class ANPCCharacter* Disguise);
	void HandleRemoveDisguise(class ANPCCharacter* Disguise);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisguiseShieldComponent">();
	}
	static class UDisguiseShieldComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisguiseShieldComponent>();
	}
};
static_assert(alignof(UDisguiseShieldComponent) == 0x000008, "Wrong alignment on UDisguiseShieldComponent");
static_assert(sizeof(UDisguiseShieldComponent) == 0x000140, "Wrong size on UDisguiseShieldComponent");
static_assert(offsetof(UDisguiseShieldComponent, OnDisguiseShieldInitDone) == 0x0000B0, "Member 'UDisguiseShieldComponent::OnDisguiseShieldInitDone' has a wrong offset!");
static_assert(offsetof(UDisguiseShieldComponent, HealthComponent) == 0x0000C8, "Member 'UDisguiseShieldComponent::HealthComponent' has a wrong offset!");
static_assert(offsetof(UDisguiseShieldComponent, ShieldDisguiseDamageModifier) == 0x0000D0, "Member 'UDisguiseShieldComponent::ShieldDisguiseDamageModifier' has a wrong offset!");
static_assert(offsetof(UDisguiseShieldComponent, ShieldDisguiseDamageModifierInstance) == 0x0000F8, "Member 'UDisguiseShieldComponent::ShieldDisguiseDamageModifierInstance' has a wrong offset!");
static_assert(offsetof(UDisguiseShieldComponent, ShieldDamageModifier) == 0x000100, "Member 'UDisguiseShieldComponent::ShieldDamageModifier' has a wrong offset!");
static_assert(offsetof(UDisguiseShieldComponent, ShieldDamageModifierInstance) == 0x000128, "Member 'UDisguiseShieldComponent::ShieldDamageModifierInstance' has a wrong offset!");
static_assert(offsetof(UDisguiseShieldComponent, DamageReductionDuration) == 0x000130, "Member 'UDisguiseShieldComponent::DamageReductionDuration' has a wrong offset!");

// Class DeceiveInc.DIOnlineFriendPresence
// 0x0028 (0x0050 - 0x0028)
class UDIOnlineFriendPresence final : public UObject
{
public:
	bool                                          bIsOnline;                                         // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlaying;                                        // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayingThisGame;                                // 0x002A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsJoinable;                                       // 0x002B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasVoiceSupport;                                  // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              LastOnline;                                        // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StatusStr;                                         // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDIOnlinePresenceType                         OnlinePresenceType;                                // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIOnlineFriendPresence">();
	}
	static class UDIOnlineFriendPresence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIOnlineFriendPresence>();
	}
};
static_assert(alignof(UDIOnlineFriendPresence) == 0x000008, "Wrong alignment on UDIOnlineFriendPresence");
static_assert(sizeof(UDIOnlineFriendPresence) == 0x000050, "Wrong size on UDIOnlineFriendPresence");
static_assert(offsetof(UDIOnlineFriendPresence, bIsOnline) == 0x000028, "Member 'UDIOnlineFriendPresence::bIsOnline' has a wrong offset!");
static_assert(offsetof(UDIOnlineFriendPresence, bIsPlaying) == 0x000029, "Member 'UDIOnlineFriendPresence::bIsPlaying' has a wrong offset!");
static_assert(offsetof(UDIOnlineFriendPresence, bIsPlayingThisGame) == 0x00002A, "Member 'UDIOnlineFriendPresence::bIsPlayingThisGame' has a wrong offset!");
static_assert(offsetof(UDIOnlineFriendPresence, bIsJoinable) == 0x00002B, "Member 'UDIOnlineFriendPresence::bIsJoinable' has a wrong offset!");
static_assert(offsetof(UDIOnlineFriendPresence, bHasVoiceSupport) == 0x00002C, "Member 'UDIOnlineFriendPresence::bHasVoiceSupport' has a wrong offset!");
static_assert(offsetof(UDIOnlineFriendPresence, LastOnline) == 0x000030, "Member 'UDIOnlineFriendPresence::LastOnline' has a wrong offset!");
static_assert(offsetof(UDIOnlineFriendPresence, StatusStr) == 0x000038, "Member 'UDIOnlineFriendPresence::StatusStr' has a wrong offset!");
static_assert(offsetof(UDIOnlineFriendPresence, OnlinePresenceType) == 0x000048, "Member 'UDIOnlineFriendPresence::OnlinePresenceType' has a wrong offset!");

// Class DeceiveInc.LevelInventoryData
// 0x0050 (0x0088 - 0x0038)
class ULevelInventoryData final : public UDIPrimaryDataAsset
{
public:
	TMap<class FString, struct FXpTypeInventory>  LevelInventoryMap;                                 // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelInventoryData">();
	}
	static class ULevelInventoryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelInventoryData>();
	}
};
static_assert(alignof(ULevelInventoryData) == 0x000008, "Wrong alignment on ULevelInventoryData");
static_assert(sizeof(ULevelInventoryData) == 0x000088, "Wrong size on ULevelInventoryData");
static_assert(offsetof(ULevelInventoryData, LevelInventoryMap) == 0x000038, "Member 'ULevelInventoryData::LevelInventoryMap' has a wrong offset!");

// Class DeceiveInc.DIOnlineFriendInfo
// 0x0050 (0x0078 - 0x0028)
class UDIOnlineFriendInfo final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayName;                                       // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SubsystemName;                                     // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDIOnlineFriendPresence*                OnlinePresence;                                    // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERelationshipStatusCode                       Status;                                            // 0x0070(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const class FString GetSubsystemName() const;
	const class FString GetUserIdString() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIOnlineFriendInfo">();
	}
	static class UDIOnlineFriendInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIOnlineFriendInfo>();
	}
};
static_assert(alignof(UDIOnlineFriendInfo) == 0x000008, "Wrong alignment on UDIOnlineFriendInfo");
static_assert(sizeof(UDIOnlineFriendInfo) == 0x000078, "Wrong size on UDIOnlineFriendInfo");
static_assert(offsetof(UDIOnlineFriendInfo, DisplayName) == 0x000048, "Member 'UDIOnlineFriendInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(UDIOnlineFriendInfo, SubsystemName) == 0x000058, "Member 'UDIOnlineFriendInfo::SubsystemName' has a wrong offset!");
static_assert(offsetof(UDIOnlineFriendInfo, OnlinePresence) == 0x000068, "Member 'UDIOnlineFriendInfo::OnlinePresence' has a wrong offset!");
static_assert(offsetof(UDIOnlineFriendInfo, Status) == 0x000070, "Member 'UDIOnlineFriendInfo::Status' has a wrong offset!");

// Class DeceiveInc.FriendRelationshipActivity
// 0x0030 (0x0058 - 0x0028)
class UFriendRelationshipActivity final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayName;                                       // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Activity;                                          // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendRelationshipActivity">();
	}
	static class UFriendRelationshipActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendRelationshipActivity>();
	}
};
static_assert(alignof(UFriendRelationshipActivity) == 0x000008, "Wrong alignment on UFriendRelationshipActivity");
static_assert(sizeof(UFriendRelationshipActivity) == 0x000058, "Wrong size on UFriendRelationshipActivity");
static_assert(offsetof(UFriendRelationshipActivity, DisplayName) == 0x000038, "Member 'UFriendRelationshipActivity::DisplayName' has a wrong offset!");
static_assert(offsetof(UFriendRelationshipActivity, Activity) == 0x000048, "Member 'UFriendRelationshipActivity::Activity' has a wrong offset!");

// Class DeceiveInc.LarcinPassiveMod1Ability
// 0x0028 (0x0558 - 0x0530)
class ALarcinPassiveMod1Ability final : public ABaseSpyPassiveAbility
{
public:
	TSoftClassPtr<class UClass>                   MeleeTagEffectClass;                               // 0x0530(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleLoadoutSpawnCompleteEvent(class UToolLoadoutComponent* LoadoutComponent);
	void HandleMeleeAttackImpactEvent(class AActor* Victim, const struct FVector& ImpactPoint, int32 ChargeLevel, float Damage, float ResultingHealthPercentage, EHitType HitType, const struct FMeleeHitConfirmedData& HitConfirmedData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LarcinPassiveMod1Ability">();
	}
	static class ALarcinPassiveMod1Ability* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALarcinPassiveMod1Ability>();
	}
};
static_assert(alignof(ALarcinPassiveMod1Ability) == 0x000008, "Wrong alignment on ALarcinPassiveMod1Ability");
static_assert(sizeof(ALarcinPassiveMod1Ability) == 0x000558, "Wrong size on ALarcinPassiveMod1Ability");
static_assert(offsetof(ALarcinPassiveMod1Ability, MeleeTagEffectClass) == 0x000530, "Member 'ALarcinPassiveMod1Ability::MeleeTagEffectClass' has a wrong offset!");

// Class DeceiveInc.DISocialSubsystem
// 0x00B8 (0x00E8 - 0x0030)
class UDISocialSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnFriendListUpdated;                               // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFriendInviteReceived;                            // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlockListUpdated;                                // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSearchUserComplete;                              // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UDIOnlineFriendInfo*>            OnlineFriends;                                     // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UDIOnlineFriendInfo*>            SearchedUsers;                                     // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UDIOnlineFriendInfo*>            BlockedPlayers;                                    // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UFriendRelationshipActivity*>    RelationshipActivities;                            // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AcceptFriendRequest(class UDIOnlineFriendInfo* FriendInfo);
	int32 ApplyReportFlag(bool ShouldAdd, int32 ApplyBitmask, int32 CurrentBitmask);
	void BlockPlayer(class UDIOnlineFriendInfo* FriendInfo);
	void CancelFriendRequest(class UDIOnlineFriendInfo* FriendInfo);
	void OnDIWebServiceLoginCompleted(const struct FLoginResponse& LoginResponse);
	void OnMapChange(class UWorld* LoadedWorld);
	void OnReadFriendsListComplete(int32 LocalUserNum, bool bWasSuccessful, const class FString& ListName, const class FString& ErrorStr);
	void RejectFriendRequest(class UDIOnlineFriendInfo* FriendInfo);
	void RemoveFriend(class UDIOnlineFriendInfo* FriendInfo);
	void SearchFriendByDisplayName(const class FString& SearchDisplayName);
	void SendFriendRequest(class UDIOnlineFriendInfo* FriendInfo);
	void SendPlayerReport(class UDIOnlineFriendInfo* FriendInfo, int32 CategoryId, const class FString& SessionID, const class FString& Message);
	void SendPlayerReportPlayerState(class ADIPlayerState* PlayerState, int32 CategoryId, const class FString& SessionID, const class FString& Message);
	void StartPollingFriendsList();
	void StopPollingFriendsList();
	void TriggerFriendsListOpenChanged(bool bOpen);
	void UnblockPlayer(class UDIOnlineFriendInfo* FriendInfo);

	TArray<class UDIOnlineFriendInfo*> GetBlockedPlayersList() const;
	TArray<class UDIOnlineFriendInfo*> GetFriendInbounds() const;
	TArray<class UDIOnlineFriendInfo*> GetFriendOutbounds() const;
	TArray<class UDIOnlineFriendInfo*> GetSortedFriendList() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DISocialSubsystem">();
	}
	static class UDISocialSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDISocialSubsystem>();
	}
};
static_assert(alignof(UDISocialSubsystem) == 0x000008, "Wrong alignment on UDISocialSubsystem");
static_assert(sizeof(UDISocialSubsystem) == 0x0000E8, "Wrong size on UDISocialSubsystem");
static_assert(offsetof(UDISocialSubsystem, OnFriendListUpdated) == 0x000060, "Member 'UDISocialSubsystem::OnFriendListUpdated' has a wrong offset!");
static_assert(offsetof(UDISocialSubsystem, OnFriendInviteReceived) == 0x000070, "Member 'UDISocialSubsystem::OnFriendInviteReceived' has a wrong offset!");
static_assert(offsetof(UDISocialSubsystem, OnBlockListUpdated) == 0x000080, "Member 'UDISocialSubsystem::OnBlockListUpdated' has a wrong offset!");
static_assert(offsetof(UDISocialSubsystem, OnSearchUserComplete) == 0x000090, "Member 'UDISocialSubsystem::OnSearchUserComplete' has a wrong offset!");
static_assert(offsetof(UDISocialSubsystem, OnlineFriends) == 0x0000A0, "Member 'UDISocialSubsystem::OnlineFriends' has a wrong offset!");
static_assert(offsetof(UDISocialSubsystem, SearchedUsers) == 0x0000B0, "Member 'UDISocialSubsystem::SearchedUsers' has a wrong offset!");
static_assert(offsetof(UDISocialSubsystem, BlockedPlayers) == 0x0000C0, "Member 'UDISocialSubsystem::BlockedPlayers' has a wrong offset!");
static_assert(offsetof(UDISocialSubsystem, RelationshipActivities) == 0x0000D0, "Member 'UDISocialSubsystem::RelationshipActivities' has a wrong offset!");

// Class DeceiveInc.LocalDedicatedServerManager
// 0x0020 (0x0120 - 0x0100)
class ULocalDedicatedServerManager final : public UDIDedicatedServerManager
{
public:
	uint8                                         Pad_100[0x20];                                     // 0x0100(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalDedicatedServerManager">();
	}
	static class ULocalDedicatedServerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalDedicatedServerManager>();
	}
};
static_assert(alignof(ULocalDedicatedServerManager) == 0x000008, "Wrong alignment on ULocalDedicatedServerManager");
static_assert(sizeof(ULocalDedicatedServerManager) == 0x000120, "Wrong size on ULocalDedicatedServerManager");

// Class DeceiveInc.DiSpy3PMovementSet
// 0x0050 (0x0088 - 0x0038)
class UDiSpy3PMovementSet final : public UDIPrimaryDataAsset
{
public:
	class UAnimSequence*                          GroundIdleAnim;                                    // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpaceBase*                        GroundMoveBlendSpace;                              // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          CrouchIdleAnim;                                    // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          CrouchWalkAnim;                                    // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          JumpStartAnim;                                     // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          JumpInAnim;                                        // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          FallInAnim;                                        // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          FallLoopAnim;                                      // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          LandAnim;                                          // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverwriteUpperBody;                               // 0x0080(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiSpy3PMovementSet">();
	}
	static class UDiSpy3PMovementSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiSpy3PMovementSet>();
	}
};
static_assert(alignof(UDiSpy3PMovementSet) == 0x000008, "Wrong alignment on UDiSpy3PMovementSet");
static_assert(sizeof(UDiSpy3PMovementSet) == 0x000088, "Wrong size on UDiSpy3PMovementSet");
static_assert(offsetof(UDiSpy3PMovementSet, GroundIdleAnim) == 0x000038, "Member 'UDiSpy3PMovementSet::GroundIdleAnim' has a wrong offset!");
static_assert(offsetof(UDiSpy3PMovementSet, GroundMoveBlendSpace) == 0x000040, "Member 'UDiSpy3PMovementSet::GroundMoveBlendSpace' has a wrong offset!");
static_assert(offsetof(UDiSpy3PMovementSet, CrouchIdleAnim) == 0x000048, "Member 'UDiSpy3PMovementSet::CrouchIdleAnim' has a wrong offset!");
static_assert(offsetof(UDiSpy3PMovementSet, CrouchWalkAnim) == 0x000050, "Member 'UDiSpy3PMovementSet::CrouchWalkAnim' has a wrong offset!");
static_assert(offsetof(UDiSpy3PMovementSet, JumpStartAnim) == 0x000058, "Member 'UDiSpy3PMovementSet::JumpStartAnim' has a wrong offset!");
static_assert(offsetof(UDiSpy3PMovementSet, JumpInAnim) == 0x000060, "Member 'UDiSpy3PMovementSet::JumpInAnim' has a wrong offset!");
static_assert(offsetof(UDiSpy3PMovementSet, FallInAnim) == 0x000068, "Member 'UDiSpy3PMovementSet::FallInAnim' has a wrong offset!");
static_assert(offsetof(UDiSpy3PMovementSet, FallLoopAnim) == 0x000070, "Member 'UDiSpy3PMovementSet::FallLoopAnim' has a wrong offset!");
static_assert(offsetof(UDiSpy3PMovementSet, LandAnim) == 0x000078, "Member 'UDiSpy3PMovementSet::LandAnim' has a wrong offset!");
static_assert(offsetof(UDiSpy3PMovementSet, bOverwriteUpperBody) == 0x000080, "Member 'UDiSpy3PMovementSet::bOverwriteUpperBody' has a wrong offset!");

// Class DeceiveInc.DiSpyAnimationMotionSet
// 0x0000 (0x00D8 - 0x00D8)
class UDiSpyAnimationMotionSet final : public UDiAnimationMotionSet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiSpyAnimationMotionSet">();
	}
	static class UDiSpyAnimationMotionSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiSpyAnimationMotionSet>();
	}
};
static_assert(alignof(UDiSpyAnimationMotionSet) == 0x000008, "Wrong alignment on UDiSpyAnimationMotionSet");
static_assert(sizeof(UDiSpyAnimationMotionSet) == 0x0000D8, "Wrong size on UDiSpyAnimationMotionSet");

// Class DeceiveInc.VictimEffectTickBehavior
// 0x0008 (0x0030 - 0x0028)
class UVictimEffectTickBehavior : public UObject
{
public:
	class AVictimEffect*                          ParentVictimEffect;                                // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ApplyEffectToVictim(class AActor* Victim, class AActor* Instigator);
	void BP_OnEffectTick(class UVictimEffectTickBehavior* EffectTick, class AActor* Victim);
	bool IsPositiveEffect();
	void SetParentVictimEffect(class AVictimEffect* InParentVictimEffect);
	void StopEffect();

	EVictimEffectType GetEffectType() const;
	class AVictimEffect* GetParentVictimEffect() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VictimEffectTickBehavior">();
	}
	static class UVictimEffectTickBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVictimEffectTickBehavior>();
	}
};
static_assert(alignof(UVictimEffectTickBehavior) == 0x000008, "Wrong alignment on UVictimEffectTickBehavior");
static_assert(sizeof(UVictimEffectTickBehavior) == 0x000030, "Wrong size on UVictimEffectTickBehavior");
static_assert(offsetof(UVictimEffectTickBehavior, ParentVictimEffect) == 0x000028, "Member 'UVictimEffectTickBehavior::ParentVictimEffect' has a wrong offset!");

// Class DeceiveInc.VictimEffectTickBehavior_Cleanse
// 0x0000 (0x0030 - 0x0030)
class UVictimEffectTickBehavior_Cleanse final : public UVictimEffectTickBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VictimEffectTickBehavior_Cleanse">();
	}
	static class UVictimEffectTickBehavior_Cleanse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVictimEffectTickBehavior_Cleanse>();
	}
};
static_assert(alignof(UVictimEffectTickBehavior_Cleanse) == 0x000008, "Wrong alignment on UVictimEffectTickBehavior_Cleanse");
static_assert(sizeof(UVictimEffectTickBehavior_Cleanse) == 0x000030, "Wrong size on UVictimEffectTickBehavior_Cleanse");

// Class DeceiveInc.MeleeWeapon
// 0x0010 (0x0808 - 0x07F8)
class AMeleeWeapon final : public ABaseMeleeAttack
{
public:
	uint8                                         Pad_7F8[0x9];                                      // 0x07F8(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDisableBaseMeleeOnUse;                            // 0x0801(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bChargeWhenSelected;                               // 0x0802(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_803[0x1];                                      // 0x0803(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CooldownAfterMainWeaponFireShot;                   // 0x0804(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeleeWeapon">();
	}
	static class AMeleeWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMeleeWeapon>();
	}
};
static_assert(alignof(AMeleeWeapon) == 0x000008, "Wrong alignment on AMeleeWeapon");
static_assert(sizeof(AMeleeWeapon) == 0x000808, "Wrong size on AMeleeWeapon");
static_assert(offsetof(AMeleeWeapon, bDisableBaseMeleeOnUse) == 0x000801, "Member 'AMeleeWeapon::bDisableBaseMeleeOnUse' has a wrong offset!");
static_assert(offsetof(AMeleeWeapon, bChargeWhenSelected) == 0x000802, "Member 'AMeleeWeapon::bChargeWhenSelected' has a wrong offset!");
static_assert(offsetof(AMeleeWeapon, CooldownAfterMainWeaponFireShot) == 0x000804, "Member 'AMeleeWeapon::CooldownAfterMainWeaponFireShot' has a wrong offset!");

// Class DeceiveInc.DiSpyAnimInstance1P
// 0x0310 (0x05D0 - 0x02C0)
class UDiSpyAnimInstance1P final : public UDiAnimInstance
{
public:
	class UAnimSequence*                          WalkMotion;                                        // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          RunMotion;                                         // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          IdleMotion;                                        // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          DeathMotion;                                       // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          OpenDoorMotion;                                    // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GrabMotion;                                        // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WatchOutMotion;                                    // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WatchInMotion;                                     // 0x02F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WatchIdleLoopMotion;                               // 0x0300(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WatchHackOutMotion;                                // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WatchHackLoopMotion;                               // 0x0310(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WatchHackInMotion;                                 // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WatchCostumeMotion;                                // 0x0320(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WatchConfirmMotion;                                // 0x0328(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          MeleeInMotion;                                     // 0x0330(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          MeleeHitBeyondChargedMotion;                       // 0x0338(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          MeleeHitChargedMotion;                             // 0x0340(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          MeleeHitChargedConfirmedMotion;                    // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          MeleeHitMotion;                                    // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          MeleeChargeLoopMotion;                             // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          MeleeChargeInMotion;                               // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          MeleeBeyondChargeLoopMotion;                       // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          MeleeBeyondChargeInMotion;                         // 0x0370(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          MeleeImpulseMotion;                                // 0x0378(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetGenericUseOutMotion;                         // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetGenericUseInMotion;                          // 0x0388(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetGenericUseMotion;                            // 0x0390(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetGenericHoldInMotion;                         // 0x0398(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetGenericHoldMotion;                           // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetUmbrellaOpenedLoopMotion;                    // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetUmbrellaOpenMotion;                          // 0x03B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetUmbrellaInMotion;                            // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetUmbrellaClosedLoopMotion;                    // 0x03C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetUmbrellaCloseMotion;                         // 0x03C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetUmbrellaThrowMotion;                         // 0x03D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetScanUseOutMotion;                            // 0x03D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetScanUseLoopMotion;                           // 0x03E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetScanUseInMotion;                             // 0x03E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetScanHoldLoopMotion;                          // 0x03F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetScanHoldInMotion;                            // 0x03F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetDroneThrowMotion;                            // 0x0400(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetDroneHoldInMotion;                           // 0x0408(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetDroneHoldMotion;                             // 0x0410(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetDroneHoldShootMotion;                        // 0x0418(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetBouncematTriggerOutMotion;                   // 0x0420(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetBouncematTriggerIdleMotion;                  // 0x0428(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetBouncematTriggerMotion;                      // 0x0430(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetBouncematThrowMotion;                        // 0x0438(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetBouncematInMotion;                           // 0x0440(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetBouncematHoldMotion;                         // 0x0448(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetCompoudrierHoldInMotion;                     // 0x0450(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetCompoudrierHoldLoopMotion;                   // 0x0458(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetCompoudrierHoldOutMotion;                    // 0x0460(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetCompoudrierUseLongMotion;                    // 0x0468(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetCompoudrierUseOutMotion;                     // 0x0470(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetCompoudrierUseShortMotion;                   // 0x0478(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetCompoudrierUseUnableMotion;                  // 0x0480(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetGoopodHoldLoopMotion;                        // 0x0488(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetGoopodInMotion;                              // 0x0490(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetGoopodThrowMotion;                           // 0x0498(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetHackTrapHoldInMotion;                        // 0x04A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetHackTrapHoldLoopMotion;                      // 0x04A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetHackTrapUseInMotion;                         // 0x04B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetHackTrapUseLoopMotion;                       // 0x04B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetHackTrapUseOutMotion;                        // 0x04C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetMimicHoldInMotion;                           // 0x04C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetMimicHoldLoopMotion;                         // 0x04D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetMimicUseInMotion;                            // 0x04D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetMimicUseLoopMotion;                          // 0x04E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetMimicUseOutMotion;                           // 0x04E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetRemoteTurretHoldLoopMotion;                  // 0x04F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetRemoteTurretInMotion;                        // 0x04F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetRemoteTurretThrowMotion;                     // 0x0500(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetScramblerHoldLoopMotion;                     // 0x0508(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetScramblerInMotion;                           // 0x0510(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetScramblerThrowMotion;                        // 0x0518(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetScramblerUseMotion;                          // 0x0520(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetSpyGlassHoldInMotion;                        // 0x0528(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetSpyGlassHoldLoopMotion;                      // 0x0530(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetSpyGlassUseInMotion;                         // 0x0538(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetSpyGlassUseLoopMotion;                       // 0x0540(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetSpyGlassUseOutMotion;                        // 0x0548(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetTripwireHoldLoopMotion;                      // 0x0550(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetTripwireInMotion;                            // 0x0558(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetTripwireThrowMotion;                         // 0x0560(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WeaponShootNoAmmoMotion;                           // 0x0568(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WeaponShootMotion;                                 // 0x0570(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WeaponReloadMotion;                                // 0x0578(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WeaponInMotion;                                    // 0x0580(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WeaponIdleMotion;                                  // 0x0588(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WeaponCoverInMotion;                               // 0x0590(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WeaponCoverIdleMotion;                             // 0x0598(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WeaponToCoverMotion;                               // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WeaponAdsShootNoAmmoMotion;                        // 0x05A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WeaponAdsShootMotion;                              // 0x05B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WeaponAdsOutMotion;                                // 0x05B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WeaponAdsInMotion;                                 // 0x05C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WeaponAdsIdleMotion;                               // 0x05C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class ASpy* TryGetSpyOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiSpyAnimInstance1P">();
	}
	static class UDiSpyAnimInstance1P* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiSpyAnimInstance1P>();
	}
};
static_assert(alignof(UDiSpyAnimInstance1P) == 0x000010, "Wrong alignment on UDiSpyAnimInstance1P");
static_assert(sizeof(UDiSpyAnimInstance1P) == 0x0005D0, "Wrong size on UDiSpyAnimInstance1P");
static_assert(offsetof(UDiSpyAnimInstance1P, WalkMotion) == 0x0002C0, "Member 'UDiSpyAnimInstance1P::WalkMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, RunMotion) == 0x0002C8, "Member 'UDiSpyAnimInstance1P::RunMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, IdleMotion) == 0x0002D0, "Member 'UDiSpyAnimInstance1P::IdleMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, DeathMotion) == 0x0002D8, "Member 'UDiSpyAnimInstance1P::DeathMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, OpenDoorMotion) == 0x0002E0, "Member 'UDiSpyAnimInstance1P::OpenDoorMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GrabMotion) == 0x0002E8, "Member 'UDiSpyAnimInstance1P::GrabMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, WatchOutMotion) == 0x0002F0, "Member 'UDiSpyAnimInstance1P::WatchOutMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, WatchInMotion) == 0x0002F8, "Member 'UDiSpyAnimInstance1P::WatchInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, WatchIdleLoopMotion) == 0x000300, "Member 'UDiSpyAnimInstance1P::WatchIdleLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, WatchHackOutMotion) == 0x000308, "Member 'UDiSpyAnimInstance1P::WatchHackOutMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, WatchHackLoopMotion) == 0x000310, "Member 'UDiSpyAnimInstance1P::WatchHackLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, WatchHackInMotion) == 0x000318, "Member 'UDiSpyAnimInstance1P::WatchHackInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, WatchCostumeMotion) == 0x000320, "Member 'UDiSpyAnimInstance1P::WatchCostumeMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, WatchConfirmMotion) == 0x000328, "Member 'UDiSpyAnimInstance1P::WatchConfirmMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, MeleeInMotion) == 0x000330, "Member 'UDiSpyAnimInstance1P::MeleeInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, MeleeHitBeyondChargedMotion) == 0x000338, "Member 'UDiSpyAnimInstance1P::MeleeHitBeyondChargedMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, MeleeHitChargedMotion) == 0x000340, "Member 'UDiSpyAnimInstance1P::MeleeHitChargedMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, MeleeHitChargedConfirmedMotion) == 0x000348, "Member 'UDiSpyAnimInstance1P::MeleeHitChargedConfirmedMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, MeleeHitMotion) == 0x000350, "Member 'UDiSpyAnimInstance1P::MeleeHitMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, MeleeChargeLoopMotion) == 0x000358, "Member 'UDiSpyAnimInstance1P::MeleeChargeLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, MeleeChargeInMotion) == 0x000360, "Member 'UDiSpyAnimInstance1P::MeleeChargeInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, MeleeBeyondChargeLoopMotion) == 0x000368, "Member 'UDiSpyAnimInstance1P::MeleeBeyondChargeLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, MeleeBeyondChargeInMotion) == 0x000370, "Member 'UDiSpyAnimInstance1P::MeleeBeyondChargeInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, MeleeImpulseMotion) == 0x000378, "Member 'UDiSpyAnimInstance1P::MeleeImpulseMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetGenericUseOutMotion) == 0x000380, "Member 'UDiSpyAnimInstance1P::GadgetGenericUseOutMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetGenericUseInMotion) == 0x000388, "Member 'UDiSpyAnimInstance1P::GadgetGenericUseInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetGenericUseMotion) == 0x000390, "Member 'UDiSpyAnimInstance1P::GadgetGenericUseMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetGenericHoldInMotion) == 0x000398, "Member 'UDiSpyAnimInstance1P::GadgetGenericHoldInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetGenericHoldMotion) == 0x0003A0, "Member 'UDiSpyAnimInstance1P::GadgetGenericHoldMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetUmbrellaOpenedLoopMotion) == 0x0003A8, "Member 'UDiSpyAnimInstance1P::GadgetUmbrellaOpenedLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetUmbrellaOpenMotion) == 0x0003B0, "Member 'UDiSpyAnimInstance1P::GadgetUmbrellaOpenMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetUmbrellaInMotion) == 0x0003B8, "Member 'UDiSpyAnimInstance1P::GadgetUmbrellaInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetUmbrellaClosedLoopMotion) == 0x0003C0, "Member 'UDiSpyAnimInstance1P::GadgetUmbrellaClosedLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetUmbrellaCloseMotion) == 0x0003C8, "Member 'UDiSpyAnimInstance1P::GadgetUmbrellaCloseMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetUmbrellaThrowMotion) == 0x0003D0, "Member 'UDiSpyAnimInstance1P::GadgetUmbrellaThrowMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetScanUseOutMotion) == 0x0003D8, "Member 'UDiSpyAnimInstance1P::GadgetScanUseOutMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetScanUseLoopMotion) == 0x0003E0, "Member 'UDiSpyAnimInstance1P::GadgetScanUseLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetScanUseInMotion) == 0x0003E8, "Member 'UDiSpyAnimInstance1P::GadgetScanUseInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetScanHoldLoopMotion) == 0x0003F0, "Member 'UDiSpyAnimInstance1P::GadgetScanHoldLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetScanHoldInMotion) == 0x0003F8, "Member 'UDiSpyAnimInstance1P::GadgetScanHoldInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetDroneThrowMotion) == 0x000400, "Member 'UDiSpyAnimInstance1P::GadgetDroneThrowMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetDroneHoldInMotion) == 0x000408, "Member 'UDiSpyAnimInstance1P::GadgetDroneHoldInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetDroneHoldMotion) == 0x000410, "Member 'UDiSpyAnimInstance1P::GadgetDroneHoldMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetDroneHoldShootMotion) == 0x000418, "Member 'UDiSpyAnimInstance1P::GadgetDroneHoldShootMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetBouncematTriggerOutMotion) == 0x000420, "Member 'UDiSpyAnimInstance1P::GadgetBouncematTriggerOutMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetBouncematTriggerIdleMotion) == 0x000428, "Member 'UDiSpyAnimInstance1P::GadgetBouncematTriggerIdleMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetBouncematTriggerMotion) == 0x000430, "Member 'UDiSpyAnimInstance1P::GadgetBouncematTriggerMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetBouncematThrowMotion) == 0x000438, "Member 'UDiSpyAnimInstance1P::GadgetBouncematThrowMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetBouncematInMotion) == 0x000440, "Member 'UDiSpyAnimInstance1P::GadgetBouncematInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetBouncematHoldMotion) == 0x000448, "Member 'UDiSpyAnimInstance1P::GadgetBouncematHoldMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetCompoudrierHoldInMotion) == 0x000450, "Member 'UDiSpyAnimInstance1P::GadgetCompoudrierHoldInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetCompoudrierHoldLoopMotion) == 0x000458, "Member 'UDiSpyAnimInstance1P::GadgetCompoudrierHoldLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetCompoudrierHoldOutMotion) == 0x000460, "Member 'UDiSpyAnimInstance1P::GadgetCompoudrierHoldOutMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetCompoudrierUseLongMotion) == 0x000468, "Member 'UDiSpyAnimInstance1P::GadgetCompoudrierUseLongMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetCompoudrierUseOutMotion) == 0x000470, "Member 'UDiSpyAnimInstance1P::GadgetCompoudrierUseOutMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetCompoudrierUseShortMotion) == 0x000478, "Member 'UDiSpyAnimInstance1P::GadgetCompoudrierUseShortMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetCompoudrierUseUnableMotion) == 0x000480, "Member 'UDiSpyAnimInstance1P::GadgetCompoudrierUseUnableMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetGoopodHoldLoopMotion) == 0x000488, "Member 'UDiSpyAnimInstance1P::GadgetGoopodHoldLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetGoopodInMotion) == 0x000490, "Member 'UDiSpyAnimInstance1P::GadgetGoopodInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetGoopodThrowMotion) == 0x000498, "Member 'UDiSpyAnimInstance1P::GadgetGoopodThrowMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetHackTrapHoldInMotion) == 0x0004A0, "Member 'UDiSpyAnimInstance1P::GadgetHackTrapHoldInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetHackTrapHoldLoopMotion) == 0x0004A8, "Member 'UDiSpyAnimInstance1P::GadgetHackTrapHoldLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetHackTrapUseInMotion) == 0x0004B0, "Member 'UDiSpyAnimInstance1P::GadgetHackTrapUseInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetHackTrapUseLoopMotion) == 0x0004B8, "Member 'UDiSpyAnimInstance1P::GadgetHackTrapUseLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetHackTrapUseOutMotion) == 0x0004C0, "Member 'UDiSpyAnimInstance1P::GadgetHackTrapUseOutMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetMimicHoldInMotion) == 0x0004C8, "Member 'UDiSpyAnimInstance1P::GadgetMimicHoldInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetMimicHoldLoopMotion) == 0x0004D0, "Member 'UDiSpyAnimInstance1P::GadgetMimicHoldLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetMimicUseInMotion) == 0x0004D8, "Member 'UDiSpyAnimInstance1P::GadgetMimicUseInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetMimicUseLoopMotion) == 0x0004E0, "Member 'UDiSpyAnimInstance1P::GadgetMimicUseLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetMimicUseOutMotion) == 0x0004E8, "Member 'UDiSpyAnimInstance1P::GadgetMimicUseOutMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetRemoteTurretHoldLoopMotion) == 0x0004F0, "Member 'UDiSpyAnimInstance1P::GadgetRemoteTurretHoldLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetRemoteTurretInMotion) == 0x0004F8, "Member 'UDiSpyAnimInstance1P::GadgetRemoteTurretInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetRemoteTurretThrowMotion) == 0x000500, "Member 'UDiSpyAnimInstance1P::GadgetRemoteTurretThrowMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetScramblerHoldLoopMotion) == 0x000508, "Member 'UDiSpyAnimInstance1P::GadgetScramblerHoldLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetScramblerInMotion) == 0x000510, "Member 'UDiSpyAnimInstance1P::GadgetScramblerInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetScramblerThrowMotion) == 0x000518, "Member 'UDiSpyAnimInstance1P::GadgetScramblerThrowMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetScramblerUseMotion) == 0x000520, "Member 'UDiSpyAnimInstance1P::GadgetScramblerUseMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetSpyGlassHoldInMotion) == 0x000528, "Member 'UDiSpyAnimInstance1P::GadgetSpyGlassHoldInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetSpyGlassHoldLoopMotion) == 0x000530, "Member 'UDiSpyAnimInstance1P::GadgetSpyGlassHoldLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetSpyGlassUseInMotion) == 0x000538, "Member 'UDiSpyAnimInstance1P::GadgetSpyGlassUseInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetSpyGlassUseLoopMotion) == 0x000540, "Member 'UDiSpyAnimInstance1P::GadgetSpyGlassUseLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetSpyGlassUseOutMotion) == 0x000548, "Member 'UDiSpyAnimInstance1P::GadgetSpyGlassUseOutMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetTripwireHoldLoopMotion) == 0x000550, "Member 'UDiSpyAnimInstance1P::GadgetTripwireHoldLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetTripwireInMotion) == 0x000558, "Member 'UDiSpyAnimInstance1P::GadgetTripwireInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, GadgetTripwireThrowMotion) == 0x000560, "Member 'UDiSpyAnimInstance1P::GadgetTripwireThrowMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, WeaponShootNoAmmoMotion) == 0x000568, "Member 'UDiSpyAnimInstance1P::WeaponShootNoAmmoMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, WeaponShootMotion) == 0x000570, "Member 'UDiSpyAnimInstance1P::WeaponShootMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, WeaponReloadMotion) == 0x000578, "Member 'UDiSpyAnimInstance1P::WeaponReloadMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, WeaponInMotion) == 0x000580, "Member 'UDiSpyAnimInstance1P::WeaponInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, WeaponIdleMotion) == 0x000588, "Member 'UDiSpyAnimInstance1P::WeaponIdleMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, WeaponCoverInMotion) == 0x000590, "Member 'UDiSpyAnimInstance1P::WeaponCoverInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, WeaponCoverIdleMotion) == 0x000598, "Member 'UDiSpyAnimInstance1P::WeaponCoverIdleMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, WeaponToCoverMotion) == 0x0005A0, "Member 'UDiSpyAnimInstance1P::WeaponToCoverMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, WeaponAdsShootNoAmmoMotion) == 0x0005A8, "Member 'UDiSpyAnimInstance1P::WeaponAdsShootNoAmmoMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, WeaponAdsShootMotion) == 0x0005B0, "Member 'UDiSpyAnimInstance1P::WeaponAdsShootMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, WeaponAdsOutMotion) == 0x0005B8, "Member 'UDiSpyAnimInstance1P::WeaponAdsOutMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, WeaponAdsInMotion) == 0x0005C0, "Member 'UDiSpyAnimInstance1P::WeaponAdsInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance1P, WeaponAdsIdleMotion) == 0x0005C8, "Member 'UDiSpyAnimInstance1P::WeaponAdsIdleMotion' has a wrong offset!");

// Class DeceiveInc.DiSpyAnimInstance3P
// 0x0290 (0x05F0 - 0x0360)
class UDiSpyAnimInstance3P final : public UDiCharacterAnimInstance
{
public:
	class UDiSpy3PMovementSet*                    DefaultMovementSet;                                // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCustomSpy3PMovementSet>        CustomMovementSets;                                // 0x0360(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UAnimSequence*                          MeleeImpulseMotion;                                // 0x0370(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          MeleePreImpulseMotion;                             // 0x0378(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetGenericMotion;                               // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetUmbrellaOpenedLoopMotion;                    // 0x0388(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetUmbrellaOpenMotion;                          // 0x0390(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetUmbrellaClosedLoopMotion;                    // 0x0398(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetUmbrellaCloseMotion;                         // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetUmbrellaInMotion;                            // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetUmbrellaThrowMotion;                         // 0x03B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetBouncematInMotion;                           // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetBounceMatHoldLoopMotion;                     // 0x03C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetBouncematThrowMotion;                        // 0x03C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetCompoudrierHoldInMotion;                     // 0x03D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetCompoudrierHoldLoopMotion;                   // 0x03D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetCompoudrierHoldOutMotion;                    // 0x03E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetCompoudrierUseLongMotion;                    // 0x03E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetCompoudrierUseOutMotion;                     // 0x03F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetCompoudrierUseShortMotion;                   // 0x03F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetCompoudrierUseUnableMotion;                  // 0x0400(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetDroneHoldLoopMotion;                         // 0x0408(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetDroneHoldShootMotion;                        // 0x0410(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetDroneInMotion;                               // 0x0418(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetDroneThrowMotion;                            // 0x0420(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetGoopodHoldLoopMotion;                        // 0x0428(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetGoopodInMotion;                              // 0x0430(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetGoopodThrowMotion;                           // 0x0438(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetHackTrapHoldInMotion;                        // 0x0440(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetHackTrapHoldLoopMotion;                      // 0x0448(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetHackTrapUseInMotion;                         // 0x0450(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetHackTrapUseLoopMotion;                       // 0x0458(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetHackTrapUseOutMotion;                        // 0x0460(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetMimicHoldInMotion;                           // 0x0468(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetMimicHoldLoopMotion;                         // 0x0470(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetMimicUseInMotion;                            // 0x0478(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetMimicUseLoopMotion;                          // 0x0480(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetMimicUseOutMotion;                           // 0x0488(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetRemoteTurretHoldLoopMotion;                  // 0x0490(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetRemoteTurretInMotion;                        // 0x0498(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetRemoteTurretThrowMotion;                     // 0x04A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetScramblerHoldLoopMotion;                     // 0x04A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetScramblerInMotion;                           // 0x04B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetScramblerThrowMotion;                        // 0x04B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetScramblerUseMotion;                          // 0x04C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetSpyGlassHoldInMotion;                        // 0x04C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetSpyGlassHoldLoopMotion;                      // 0x04D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetSpyGlassUseInMotion;                         // 0x04D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetSpyGlassUseLoopMotion;                       // 0x04E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetSpyGlassUseOutMotion;                        // 0x04E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetTripwireHoldLoopMotion;                      // 0x04F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetTripwireInMotion;                            // 0x04F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          GadgetTripwireThrowMotion;                         // 0x0500(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WeaponShootNoAmmoMotion;                           // 0x0508(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WeaponShootMotion;                                 // 0x0510(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WeaponReloadMotion;                                // 0x0518(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpaceBase*                        AimWeaponBlendSpace;                               // 0x0520(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpaceBase*                        AimWeaponAdsBlendSpace;                            // 0x0528(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpaceBase*                        AimGadgetUmbrellaBlendSpace;                       // 0x0530(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpaceBase*                        WeaponMoveGroundBlendSpace;                        // 0x0538(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpaceBase*                        MoveGroundBlendSpace3PFirst;                       // 0x0540(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpaceBase*                        MoveGroundBlendSpace3PSecond;                      // 0x0548(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          IdleAnim3PFirst;                                   // 0x0550(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          IdleAnim3PSecond;                                  // 0x0558(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          CrouchIdleAnim3PFirst;                             // 0x0560(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          CrouchIdleAnim3PSecond;                            // 0x0568(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          CrouchWalkAnim3PFirst;                             // 0x0570(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          CrouchWalkAnim3PSecond;                            // 0x0578(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          JumpStartAnim3PFirst;                              // 0x0580(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          JumpStartAnim3PSecond;                             // 0x0588(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          JumpInAnim3PFirst;                                 // 0x0590(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          JumpInAnim3PSecond;                                // 0x0598(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          FallInAnim3PFirst;                                 // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          FallInAnim3PSecond;                                // 0x05A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          FallLoopAnim3PFirst;                               // 0x05B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          FallLoopAnim3PSecond;                              // 0x05B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          LandAnim3PFirst;                                   // 0x05C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          LandAnim3PSecond;                                  // 0x05C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSecondMovementAnimations;                         // 0x05D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCur3PMovementSetOverwriteUpperBody;             // 0x05D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D2[0x1E];                                     // 0x05D2(0x001E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SwapTo3PDefaultMovementSet();
	void SwapTo3PMovementSet(class FName MovementSetName);

	class ASpy* TryGetSpyOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiSpyAnimInstance3P">();
	}
	static class UDiSpyAnimInstance3P* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiSpyAnimInstance3P>();
	}
};
static_assert(alignof(UDiSpyAnimInstance3P) == 0x000010, "Wrong alignment on UDiSpyAnimInstance3P");
static_assert(sizeof(UDiSpyAnimInstance3P) == 0x0005F0, "Wrong size on UDiSpyAnimInstance3P");
static_assert(offsetof(UDiSpyAnimInstance3P, DefaultMovementSet) == 0x000358, "Member 'UDiSpyAnimInstance3P::DefaultMovementSet' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, CustomMovementSets) == 0x000360, "Member 'UDiSpyAnimInstance3P::CustomMovementSets' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, MeleeImpulseMotion) == 0x000370, "Member 'UDiSpyAnimInstance3P::MeleeImpulseMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, MeleePreImpulseMotion) == 0x000378, "Member 'UDiSpyAnimInstance3P::MeleePreImpulseMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetGenericMotion) == 0x000380, "Member 'UDiSpyAnimInstance3P::GadgetGenericMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetUmbrellaOpenedLoopMotion) == 0x000388, "Member 'UDiSpyAnimInstance3P::GadgetUmbrellaOpenedLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetUmbrellaOpenMotion) == 0x000390, "Member 'UDiSpyAnimInstance3P::GadgetUmbrellaOpenMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetUmbrellaClosedLoopMotion) == 0x000398, "Member 'UDiSpyAnimInstance3P::GadgetUmbrellaClosedLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetUmbrellaCloseMotion) == 0x0003A0, "Member 'UDiSpyAnimInstance3P::GadgetUmbrellaCloseMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetUmbrellaInMotion) == 0x0003A8, "Member 'UDiSpyAnimInstance3P::GadgetUmbrellaInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetUmbrellaThrowMotion) == 0x0003B0, "Member 'UDiSpyAnimInstance3P::GadgetUmbrellaThrowMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetBouncematInMotion) == 0x0003B8, "Member 'UDiSpyAnimInstance3P::GadgetBouncematInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetBounceMatHoldLoopMotion) == 0x0003C0, "Member 'UDiSpyAnimInstance3P::GadgetBounceMatHoldLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetBouncematThrowMotion) == 0x0003C8, "Member 'UDiSpyAnimInstance3P::GadgetBouncematThrowMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetCompoudrierHoldInMotion) == 0x0003D0, "Member 'UDiSpyAnimInstance3P::GadgetCompoudrierHoldInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetCompoudrierHoldLoopMotion) == 0x0003D8, "Member 'UDiSpyAnimInstance3P::GadgetCompoudrierHoldLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetCompoudrierHoldOutMotion) == 0x0003E0, "Member 'UDiSpyAnimInstance3P::GadgetCompoudrierHoldOutMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetCompoudrierUseLongMotion) == 0x0003E8, "Member 'UDiSpyAnimInstance3P::GadgetCompoudrierUseLongMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetCompoudrierUseOutMotion) == 0x0003F0, "Member 'UDiSpyAnimInstance3P::GadgetCompoudrierUseOutMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetCompoudrierUseShortMotion) == 0x0003F8, "Member 'UDiSpyAnimInstance3P::GadgetCompoudrierUseShortMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetCompoudrierUseUnableMotion) == 0x000400, "Member 'UDiSpyAnimInstance3P::GadgetCompoudrierUseUnableMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetDroneHoldLoopMotion) == 0x000408, "Member 'UDiSpyAnimInstance3P::GadgetDroneHoldLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetDroneHoldShootMotion) == 0x000410, "Member 'UDiSpyAnimInstance3P::GadgetDroneHoldShootMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetDroneInMotion) == 0x000418, "Member 'UDiSpyAnimInstance3P::GadgetDroneInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetDroneThrowMotion) == 0x000420, "Member 'UDiSpyAnimInstance3P::GadgetDroneThrowMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetGoopodHoldLoopMotion) == 0x000428, "Member 'UDiSpyAnimInstance3P::GadgetGoopodHoldLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetGoopodInMotion) == 0x000430, "Member 'UDiSpyAnimInstance3P::GadgetGoopodInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetGoopodThrowMotion) == 0x000438, "Member 'UDiSpyAnimInstance3P::GadgetGoopodThrowMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetHackTrapHoldInMotion) == 0x000440, "Member 'UDiSpyAnimInstance3P::GadgetHackTrapHoldInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetHackTrapHoldLoopMotion) == 0x000448, "Member 'UDiSpyAnimInstance3P::GadgetHackTrapHoldLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetHackTrapUseInMotion) == 0x000450, "Member 'UDiSpyAnimInstance3P::GadgetHackTrapUseInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetHackTrapUseLoopMotion) == 0x000458, "Member 'UDiSpyAnimInstance3P::GadgetHackTrapUseLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetHackTrapUseOutMotion) == 0x000460, "Member 'UDiSpyAnimInstance3P::GadgetHackTrapUseOutMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetMimicHoldInMotion) == 0x000468, "Member 'UDiSpyAnimInstance3P::GadgetMimicHoldInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetMimicHoldLoopMotion) == 0x000470, "Member 'UDiSpyAnimInstance3P::GadgetMimicHoldLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetMimicUseInMotion) == 0x000478, "Member 'UDiSpyAnimInstance3P::GadgetMimicUseInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetMimicUseLoopMotion) == 0x000480, "Member 'UDiSpyAnimInstance3P::GadgetMimicUseLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetMimicUseOutMotion) == 0x000488, "Member 'UDiSpyAnimInstance3P::GadgetMimicUseOutMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetRemoteTurretHoldLoopMotion) == 0x000490, "Member 'UDiSpyAnimInstance3P::GadgetRemoteTurretHoldLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetRemoteTurretInMotion) == 0x000498, "Member 'UDiSpyAnimInstance3P::GadgetRemoteTurretInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetRemoteTurretThrowMotion) == 0x0004A0, "Member 'UDiSpyAnimInstance3P::GadgetRemoteTurretThrowMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetScramblerHoldLoopMotion) == 0x0004A8, "Member 'UDiSpyAnimInstance3P::GadgetScramblerHoldLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetScramblerInMotion) == 0x0004B0, "Member 'UDiSpyAnimInstance3P::GadgetScramblerInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetScramblerThrowMotion) == 0x0004B8, "Member 'UDiSpyAnimInstance3P::GadgetScramblerThrowMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetScramblerUseMotion) == 0x0004C0, "Member 'UDiSpyAnimInstance3P::GadgetScramblerUseMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetSpyGlassHoldInMotion) == 0x0004C8, "Member 'UDiSpyAnimInstance3P::GadgetSpyGlassHoldInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetSpyGlassHoldLoopMotion) == 0x0004D0, "Member 'UDiSpyAnimInstance3P::GadgetSpyGlassHoldLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetSpyGlassUseInMotion) == 0x0004D8, "Member 'UDiSpyAnimInstance3P::GadgetSpyGlassUseInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetSpyGlassUseLoopMotion) == 0x0004E0, "Member 'UDiSpyAnimInstance3P::GadgetSpyGlassUseLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetSpyGlassUseOutMotion) == 0x0004E8, "Member 'UDiSpyAnimInstance3P::GadgetSpyGlassUseOutMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetTripwireHoldLoopMotion) == 0x0004F0, "Member 'UDiSpyAnimInstance3P::GadgetTripwireHoldLoopMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetTripwireInMotion) == 0x0004F8, "Member 'UDiSpyAnimInstance3P::GadgetTripwireInMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, GadgetTripwireThrowMotion) == 0x000500, "Member 'UDiSpyAnimInstance3P::GadgetTripwireThrowMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, WeaponShootNoAmmoMotion) == 0x000508, "Member 'UDiSpyAnimInstance3P::WeaponShootNoAmmoMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, WeaponShootMotion) == 0x000510, "Member 'UDiSpyAnimInstance3P::WeaponShootMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, WeaponReloadMotion) == 0x000518, "Member 'UDiSpyAnimInstance3P::WeaponReloadMotion' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, AimWeaponBlendSpace) == 0x000520, "Member 'UDiSpyAnimInstance3P::AimWeaponBlendSpace' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, AimWeaponAdsBlendSpace) == 0x000528, "Member 'UDiSpyAnimInstance3P::AimWeaponAdsBlendSpace' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, AimGadgetUmbrellaBlendSpace) == 0x000530, "Member 'UDiSpyAnimInstance3P::AimGadgetUmbrellaBlendSpace' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, WeaponMoveGroundBlendSpace) == 0x000538, "Member 'UDiSpyAnimInstance3P::WeaponMoveGroundBlendSpace' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, MoveGroundBlendSpace3PFirst) == 0x000540, "Member 'UDiSpyAnimInstance3P::MoveGroundBlendSpace3PFirst' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, MoveGroundBlendSpace3PSecond) == 0x000548, "Member 'UDiSpyAnimInstance3P::MoveGroundBlendSpace3PSecond' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, IdleAnim3PFirst) == 0x000550, "Member 'UDiSpyAnimInstance3P::IdleAnim3PFirst' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, IdleAnim3PSecond) == 0x000558, "Member 'UDiSpyAnimInstance3P::IdleAnim3PSecond' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, CrouchIdleAnim3PFirst) == 0x000560, "Member 'UDiSpyAnimInstance3P::CrouchIdleAnim3PFirst' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, CrouchIdleAnim3PSecond) == 0x000568, "Member 'UDiSpyAnimInstance3P::CrouchIdleAnim3PSecond' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, CrouchWalkAnim3PFirst) == 0x000570, "Member 'UDiSpyAnimInstance3P::CrouchWalkAnim3PFirst' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, CrouchWalkAnim3PSecond) == 0x000578, "Member 'UDiSpyAnimInstance3P::CrouchWalkAnim3PSecond' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, JumpStartAnim3PFirst) == 0x000580, "Member 'UDiSpyAnimInstance3P::JumpStartAnim3PFirst' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, JumpStartAnim3PSecond) == 0x000588, "Member 'UDiSpyAnimInstance3P::JumpStartAnim3PSecond' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, JumpInAnim3PFirst) == 0x000590, "Member 'UDiSpyAnimInstance3P::JumpInAnim3PFirst' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, JumpInAnim3PSecond) == 0x000598, "Member 'UDiSpyAnimInstance3P::JumpInAnim3PSecond' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, FallInAnim3PFirst) == 0x0005A0, "Member 'UDiSpyAnimInstance3P::FallInAnim3PFirst' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, FallInAnim3PSecond) == 0x0005A8, "Member 'UDiSpyAnimInstance3P::FallInAnim3PSecond' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, FallLoopAnim3PFirst) == 0x0005B0, "Member 'UDiSpyAnimInstance3P::FallLoopAnim3PFirst' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, FallLoopAnim3PSecond) == 0x0005B8, "Member 'UDiSpyAnimInstance3P::FallLoopAnim3PSecond' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, LandAnim3PFirst) == 0x0005C0, "Member 'UDiSpyAnimInstance3P::LandAnim3PFirst' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, LandAnim3PSecond) == 0x0005C8, "Member 'UDiSpyAnimInstance3P::LandAnim3PSecond' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, bSecondMovementAnimations) == 0x0005D0, "Member 'UDiSpyAnimInstance3P::bSecondMovementAnimations' has a wrong offset!");
static_assert(offsetof(UDiSpyAnimInstance3P, bIsCur3PMovementSetOverwriteUpperBody) == 0x0005D1, "Member 'UDiSpyAnimInstance3P::bIsCur3PMovementSetOverwriteUpperBody' has a wrong offset!");

// Class DeceiveInc.LootRewardPoolDataAsset
// 0x0010 (0x0048 - 0x0038)
class ULootRewardPoolDataAsset final : public UDIPrimaryDataAsset
{
public:
	TArray<struct FLootRewardInfo>                LootRewards;                                       // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LootRewardPoolDataAsset">();
	}
	static class ULootRewardPoolDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULootRewardPoolDataAsset>();
	}
};
static_assert(alignof(ULootRewardPoolDataAsset) == 0x000008, "Wrong alignment on ULootRewardPoolDataAsset");
static_assert(sizeof(ULootRewardPoolDataAsset) == 0x000048, "Wrong size on ULootRewardPoolDataAsset");
static_assert(offsetof(ULootRewardPoolDataAsset, LootRewards) == 0x000038, "Member 'ULootRewardPoolDataAsset::LootRewards' has a wrong offset!");

// Class DeceiveInc.DIStoreMenuPageUserWidget
// 0x0008 (0x0288 - 0x0280)
class UDIStoreMenuPageUserWidget final : public UDiMenuPageUserWidget
{
public:
	float                                         StoreRefreshDelay;                                 // 0x0280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_RefreshSchedule();
	class UDIItem* GetItemForSlot(int32 SlotIndex, int32* ReducedPrice);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIStoreMenuPageUserWidget">();
	}
	static class UDIStoreMenuPageUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIStoreMenuPageUserWidget>();
	}
};
static_assert(alignof(UDIStoreMenuPageUserWidget) == 0x000008, "Wrong alignment on UDIStoreMenuPageUserWidget");
static_assert(sizeof(UDIStoreMenuPageUserWidget) == 0x000288, "Wrong size on UDIStoreMenuPageUserWidget");
static_assert(offsetof(UDIStoreMenuPageUserWidget, StoreRefreshDelay) == 0x000280, "Member 'UDIStoreMenuPageUserWidget::StoreRefreshDelay' has a wrong offset!");

// Class DeceiveInc.DIItem
// 0x00F0 (0x0120 - 0x0030)
class UDIItem : public UDataAsset
{
public:
	int32                                         ItemId;                                            // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemName;                                          // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ItemImage;                                         // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemRarity;                                        // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ItemAsset;                                         // 0x007C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDIPrimaryDataAsset>     ItemAssetPtr;                                      // 0x0090(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBundleItemEntry>               BundledItems;                                      // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bShowWhenNotOwned;                                 // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCannotBePurchased;                                // 0x00C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShopExclusive;                                  // 0x00CA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlagAsNew;                                        // 0x00CB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlagAsPopular;                                    // 0x00CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDIITemStoreCategoryOverride                  CategoryOverride;                                  // 0x00CD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CE[0x2];                                       // 0x00CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemCostEntry>                 Costs;                                             // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FItemCostEntry>                 BaseCosts;                                         // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FItemCostEntry>                 RarityCostInfos;                                   // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)
	class UDICatalogueItem*                       RequiredCatalog;                                   // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredCatalogID;                                 // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDIItem*                                VoucherItem;                                       // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VoucherItemID;                                     // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetDisplayRarity() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIItem">();
	}
	static class UDIItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIItem>();
	}
};
static_assert(alignof(UDIItem) == 0x000008, "Wrong alignment on UDIItem");
static_assert(sizeof(UDIItem) == 0x000120, "Wrong size on UDIItem");
static_assert(offsetof(UDIItem, ItemId) == 0x000030, "Member 'UDIItem::ItemId' has a wrong offset!");
static_assert(offsetof(UDIItem, ItemName) == 0x000038, "Member 'UDIItem::ItemName' has a wrong offset!");
static_assert(offsetof(UDIItem, ItemImage) == 0x000050, "Member 'UDIItem::ItemImage' has a wrong offset!");
static_assert(offsetof(UDIItem, ItemRarity) == 0x000078, "Member 'UDIItem::ItemRarity' has a wrong offset!");
static_assert(offsetof(UDIItem, ItemAsset) == 0x00007C, "Member 'UDIItem::ItemAsset' has a wrong offset!");
static_assert(offsetof(UDIItem, ItemAssetPtr) == 0x000090, "Member 'UDIItem::ItemAssetPtr' has a wrong offset!");
static_assert(offsetof(UDIItem, BundledItems) == 0x0000B8, "Member 'UDIItem::BundledItems' has a wrong offset!");
static_assert(offsetof(UDIItem, bShowWhenNotOwned) == 0x0000C8, "Member 'UDIItem::bShowWhenNotOwned' has a wrong offset!");
static_assert(offsetof(UDIItem, bCannotBePurchased) == 0x0000C9, "Member 'UDIItem::bCannotBePurchased' has a wrong offset!");
static_assert(offsetof(UDIItem, bIsShopExclusive) == 0x0000CA, "Member 'UDIItem::bIsShopExclusive' has a wrong offset!");
static_assert(offsetof(UDIItem, bFlagAsNew) == 0x0000CB, "Member 'UDIItem::bFlagAsNew' has a wrong offset!");
static_assert(offsetof(UDIItem, bFlagAsPopular) == 0x0000CC, "Member 'UDIItem::bFlagAsPopular' has a wrong offset!");
static_assert(offsetof(UDIItem, CategoryOverride) == 0x0000CD, "Member 'UDIItem::CategoryOverride' has a wrong offset!");
static_assert(offsetof(UDIItem, Costs) == 0x0000D0, "Member 'UDIItem::Costs' has a wrong offset!");
static_assert(offsetof(UDIItem, BaseCosts) == 0x0000E0, "Member 'UDIItem::BaseCosts' has a wrong offset!");
static_assert(offsetof(UDIItem, RarityCostInfos) == 0x0000F0, "Member 'UDIItem::RarityCostInfos' has a wrong offset!");
static_assert(offsetof(UDIItem, RequiredCatalog) == 0x000100, "Member 'UDIItem::RequiredCatalog' has a wrong offset!");
static_assert(offsetof(UDIItem, RequiredCatalogID) == 0x000108, "Member 'UDIItem::RequiredCatalogID' has a wrong offset!");
static_assert(offsetof(UDIItem, VoucherItem) == 0x000110, "Member 'UDIItem::VoucherItem' has a wrong offset!");
static_assert(offsetof(UDIItem, VoucherItemID) == 0x000118, "Member 'UDIItem::VoucherItemID' has a wrong offset!");

// Class DeceiveInc.XpProgressionData
// 0x0038 (0x0070 - 0x0038)
class UXpProgressionData : public UDIPrimaryDataAsset
{
public:
	int32                                         MinLvlToCheckForXpOverflow;                        // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLevelUpAllowedInAMatch;                         // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 FixedLevels;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFormula>                       FormulaLevels;                                     // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEchelonProgression>            Echelons;                                          // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	int32 ClampMatchLevel(int32 CurrentLevel, int32 NewLevel);
	struct FEchelonProgression GetEchelonForLevel(int32 CurrentLevel);
	int32 GetEchelonMinLevel();
	struct FEchelonProgression GetLastUnlockEchelon(int32 CurrentLevel);
	int32 GetLevelForXpValue(int32 CurrentLevel, int32 XPTotal);
	int32 GetMaxLevel();
	int32 GetMaxLevelForMatch(int32 CurrentLevel);
	float GetProgressionPercent(int32 CurrentLevel, int32 XPTotal);
	int32 GetRequiredXPForLevel(int32 LevelIn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"XpProgressionData">();
	}
	static class UXpProgressionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UXpProgressionData>();
	}
};
static_assert(alignof(UXpProgressionData) == 0x000008, "Wrong alignment on UXpProgressionData");
static_assert(sizeof(UXpProgressionData) == 0x000070, "Wrong size on UXpProgressionData");
static_assert(offsetof(UXpProgressionData, MinLvlToCheckForXpOverflow) == 0x000038, "Member 'UXpProgressionData::MinLvlToCheckForXpOverflow' has a wrong offset!");
static_assert(offsetof(UXpProgressionData, MaxLevelUpAllowedInAMatch) == 0x00003C, "Member 'UXpProgressionData::MaxLevelUpAllowedInAMatch' has a wrong offset!");
static_assert(offsetof(UXpProgressionData, FixedLevels) == 0x000040, "Member 'UXpProgressionData::FixedLevels' has a wrong offset!");
static_assert(offsetof(UXpProgressionData, FormulaLevels) == 0x000050, "Member 'UXpProgressionData::FormulaLevels' has a wrong offset!");
static_assert(offsetof(UXpProgressionData, Echelons) == 0x000060, "Member 'UXpProgressionData::Echelons' has a wrong offset!");

// Class DeceiveInc.DIAgentItem
// 0x0000 (0x0120 - 0x0120)
class UDIAgentItem final : public UDIItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIAgentItem">();
	}
	static class UDIAgentItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIAgentItem>();
	}
};
static_assert(alignof(UDIAgentItem) == 0x000008, "Wrong alignment on UDIAgentItem");
static_assert(sizeof(UDIAgentItem) == 0x000120, "Wrong size on UDIAgentItem");

// Class DeceiveInc.DIAgentSkinItem
// 0x0000 (0x0120 - 0x0120)
class UDIAgentSkinItem final : public UDIItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIAgentSkinItem">();
	}
	static class UDIAgentSkinItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIAgentSkinItem>();
	}
};
static_assert(alignof(UDIAgentSkinItem) == 0x000008, "Wrong alignment on UDIAgentSkinItem");
static_assert(sizeof(UDIAgentSkinItem) == 0x000120, "Wrong size on UDIAgentSkinItem");

// Class DeceiveInc.MaxResourceConditionComponent
// 0x0018 (0x00E8 - 0x00D0)
class UMaxResourceConditionComponent final : public UBaseConditionComponent
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EGameplayResourcesType>                AlternateResourceTypeArray;                        // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaxResourceConditionComponent">();
	}
	static class UMaxResourceConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaxResourceConditionComponent>();
	}
};
static_assert(alignof(UMaxResourceConditionComponent) == 0x000008, "Wrong alignment on UMaxResourceConditionComponent");
static_assert(sizeof(UMaxResourceConditionComponent) == 0x0000E8, "Wrong size on UMaxResourceConditionComponent");
static_assert(offsetof(UMaxResourceConditionComponent, ResourceType) == 0x0000D0, "Member 'UMaxResourceConditionComponent::ResourceType' has a wrong offset!");
static_assert(offsetof(UMaxResourceConditionComponent, AlternateResourceTypeArray) == 0x0000D8, "Member 'UMaxResourceConditionComponent::AlternateResourceTypeArray' has a wrong offset!");

// Class DeceiveInc.DIGadgetItem
// 0x0000 (0x0120 - 0x0120)
class UDIGadgetItem final : public UDIItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIGadgetItem">();
	}
	static class UDIGadgetItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIGadgetItem>();
	}
};
static_assert(alignof(UDIGadgetItem) == 0x000008, "Wrong alignment on UDIGadgetItem");
static_assert(sizeof(UDIGadgetItem) == 0x000120, "Wrong size on UDIGadgetItem");

// Class DeceiveInc.DIWeaponItem
// 0x0000 (0x0120 - 0x0120)
class UDIWeaponItem final : public UDIItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIWeaponItem">();
	}
	static class UDIWeaponItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIWeaponItem>();
	}
};
static_assert(alignof(UDIWeaponItem) == 0x000008, "Wrong alignment on UDIWeaponItem");
static_assert(sizeof(UDIWeaponItem) == 0x000120, "Wrong size on UDIWeaponItem");

// Class DeceiveInc.VictimEffectTickBehavior_Silence
// 0x0028 (0x0058 - 0x0030)
class UVictimEffectTickBehavior_Silence : public UVictimEffectTickBehavior
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VictimEffectTickBehavior_Silence">();
	}
	static class UVictimEffectTickBehavior_Silence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVictimEffectTickBehavior_Silence>();
	}
};
static_assert(alignof(UVictimEffectTickBehavior_Silence) == 0x000008, "Wrong alignment on UVictimEffectTickBehavior_Silence");
static_assert(sizeof(UVictimEffectTickBehavior_Silence) == 0x000058, "Wrong size on UVictimEffectTickBehavior_Silence");

// Class DeceiveInc.NavModeData
// 0x0050 (0x0088 - 0x0038)
class UNavModeData final : public UDIPrimaryDataAsset
{
public:
	TMap<ENavModeItemType, struct FNavModeItemTypeSettings> NavModeItemSettings;                               // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavModeData">();
	}
	static class UNavModeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavModeData>();
	}
};
static_assert(alignof(UNavModeData) == 0x000008, "Wrong alignment on UNavModeData");
static_assert(sizeof(UNavModeData) == 0x000088, "Wrong size on UNavModeData");
static_assert(offsetof(UNavModeData, NavModeItemSettings) == 0x000038, "Member 'UNavModeData::NavModeItemSettings' has a wrong offset!");

// Class DeceiveInc.DIActiveAbilityItem
// 0x0000 (0x0120 - 0x0120)
class UDIActiveAbilityItem final : public UDIItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIActiveAbilityItem">();
	}
	static class UDIActiveAbilityItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIActiveAbilityItem>();
	}
};
static_assert(alignof(UDIActiveAbilityItem) == 0x000008, "Wrong alignment on UDIActiveAbilityItem");
static_assert(sizeof(UDIActiveAbilityItem) == 0x000120, "Wrong size on UDIActiveAbilityItem");

// Class DeceiveInc.DIPassiveAbilityItem
// 0x0000 (0x0120 - 0x0120)
class UDIPassiveAbilityItem final : public UDIItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIPassiveAbilityItem">();
	}
	static class UDIPassiveAbilityItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIPassiveAbilityItem>();
	}
};
static_assert(alignof(UDIPassiveAbilityItem) == 0x000008, "Wrong alignment on UDIPassiveAbilityItem");
static_assert(sizeof(UDIPassiveAbilityItem) == 0x000120, "Wrong size on UDIPassiveAbilityItem");

// Class DeceiveInc.MenuWrapData
// 0x0078 (0x00B0 - 0x0038)
class UMenuWrapData final : public UDIPrimaryDataAsset
{
public:
	class FText                                   WrapDisplayName;                                   // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         WrapRarity;                                        // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInstance>       SprayCanMaterial;                                  // 0x0058(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              WrapTexture;                                       // 0x0080(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWrapType                                     WrapType;                                          // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuWrapData">();
	}
	static class UMenuWrapData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuWrapData>();
	}
};
static_assert(alignof(UMenuWrapData) == 0x000008, "Wrong alignment on UMenuWrapData");
static_assert(sizeof(UMenuWrapData) == 0x0000B0, "Wrong size on UMenuWrapData");
static_assert(offsetof(UMenuWrapData, WrapDisplayName) == 0x000038, "Member 'UMenuWrapData::WrapDisplayName' has a wrong offset!");
static_assert(offsetof(UMenuWrapData, WrapRarity) == 0x000050, "Member 'UMenuWrapData::WrapRarity' has a wrong offset!");
static_assert(offsetof(UMenuWrapData, SprayCanMaterial) == 0x000058, "Member 'UMenuWrapData::SprayCanMaterial' has a wrong offset!");
static_assert(offsetof(UMenuWrapData, WrapTexture) == 0x000080, "Member 'UMenuWrapData::WrapTexture' has a wrong offset!");
static_assert(offsetof(UMenuWrapData, WrapType) == 0x0000A8, "Member 'UMenuWrapData::WrapType' has a wrong offset!");

// Class DeceiveInc.DIIntroPoseItem
// 0x0000 (0x0120 - 0x0120)
class UDIIntroPoseItem final : public UDIItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIIntroPoseItem">();
	}
	static class UDIIntroPoseItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIIntroPoseItem>();
	}
};
static_assert(alignof(UDIIntroPoseItem) == 0x000008, "Wrong alignment on UDIIntroPoseItem");
static_assert(sizeof(UDIIntroPoseItem) == 0x000120, "Wrong size on UDIIntroPoseItem");

// Class DeceiveInc.DIWrapItem
// 0x0000 (0x0120 - 0x0120)
class UDIWrapItem final : public UDIItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIWrapItem">();
	}
	static class UDIWrapItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIWrapItem>();
	}
};
static_assert(alignof(UDIWrapItem) == 0x000008, "Wrong alignment on UDIWrapItem");
static_assert(sizeof(UDIWrapItem) == 0x000120, "Wrong size on UDIWrapItem");

// Class DeceiveInc.VaultDoorOverrideCondition
// 0x0088 (0x0158 - 0x00D0)
class UVaultDoorOverrideCondition final : public UBaseConditionComponent
{
public:
	uint8                                         Pad_D0[0x4];                                       // 0x00D0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RequiredIntel;                                     // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 RequiredIntelPerTeam;                              // 0x00D8(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bVaultOverrideActivated;                           // 0x00E8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESecurityLevel                                RequiredSecutiryLEvel;                             // 0x00E9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedSecurityToDonate;                             // 0x00EA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShareIntelDonation;                               // 0x00EB(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShareIntelDonationPerTeam;                        // 0x00EC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnIntelSpent;                                      // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnRetinaScanned;                                   // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class FText                                   IntelPoolText;                                     // 0x0110(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   NeedDisguiseText;                                  // 0x0128(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   RetinaScanText;                                    // 0x0140(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	EVaultOverrideStatus GetCurrentStatus();
	void HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void ReduceCost(int32 Reduction, class ASpy* Spy);

	int32 GetRemainingIntelRequired() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VaultDoorOverrideCondition">();
	}
	static class UVaultDoorOverrideCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVaultDoorOverrideCondition>();
	}
};
static_assert(alignof(UVaultDoorOverrideCondition) == 0x000008, "Wrong alignment on UVaultDoorOverrideCondition");
static_assert(sizeof(UVaultDoorOverrideCondition) == 0x000158, "Wrong size on UVaultDoorOverrideCondition");
static_assert(offsetof(UVaultDoorOverrideCondition, RequiredIntel) == 0x0000D4, "Member 'UVaultDoorOverrideCondition::RequiredIntel' has a wrong offset!");
static_assert(offsetof(UVaultDoorOverrideCondition, RequiredIntelPerTeam) == 0x0000D8, "Member 'UVaultDoorOverrideCondition::RequiredIntelPerTeam' has a wrong offset!");
static_assert(offsetof(UVaultDoorOverrideCondition, bVaultOverrideActivated) == 0x0000E8, "Member 'UVaultDoorOverrideCondition::bVaultOverrideActivated' has a wrong offset!");
static_assert(offsetof(UVaultDoorOverrideCondition, RequiredSecutiryLEvel) == 0x0000E9, "Member 'UVaultDoorOverrideCondition::RequiredSecutiryLEvel' has a wrong offset!");
static_assert(offsetof(UVaultDoorOverrideCondition, bNeedSecurityToDonate) == 0x0000EA, "Member 'UVaultDoorOverrideCondition::bNeedSecurityToDonate' has a wrong offset!");
static_assert(offsetof(UVaultDoorOverrideCondition, bShareIntelDonation) == 0x0000EB, "Member 'UVaultDoorOverrideCondition::bShareIntelDonation' has a wrong offset!");
static_assert(offsetof(UVaultDoorOverrideCondition, bShareIntelDonationPerTeam) == 0x0000EC, "Member 'UVaultDoorOverrideCondition::bShareIntelDonationPerTeam' has a wrong offset!");
static_assert(offsetof(UVaultDoorOverrideCondition, OnIntelSpent) == 0x0000F0, "Member 'UVaultDoorOverrideCondition::OnIntelSpent' has a wrong offset!");
static_assert(offsetof(UVaultDoorOverrideCondition, OnRetinaScanned) == 0x000100, "Member 'UVaultDoorOverrideCondition::OnRetinaScanned' has a wrong offset!");
static_assert(offsetof(UVaultDoorOverrideCondition, IntelPoolText) == 0x000110, "Member 'UVaultDoorOverrideCondition::IntelPoolText' has a wrong offset!");
static_assert(offsetof(UVaultDoorOverrideCondition, NeedDisguiseText) == 0x000128, "Member 'UVaultDoorOverrideCondition::NeedDisguiseText' has a wrong offset!");
static_assert(offsetof(UVaultDoorOverrideCondition, RetinaScanText) == 0x000140, "Member 'UVaultDoorOverrideCondition::RetinaScanText' has a wrong offset!");

// Class DeceiveInc.Matchmaker
// 0x0000 (0x0028 - 0x0028)
class IMatchmaker final : public IInterface
{
public:
	void CancelMatchmaking();
	void DoStartMatchmakingRequest(const EDIGameMode GameMode);
	void DoStartMatchmakingRequestForPrivateLobby(const EDIGameMode GameMode, const struct FDIPrivateLobbyInfo& DIPrivateLobbyInfo);
	bool IsDelayedMatchmaking();
	bool IsMatchmaking();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Matchmaker">();
	}
	static class IMatchmaker* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMatchmaker>();
	}
};
static_assert(alignof(IMatchmaker) == 0x000008, "Wrong alignment on IMatchmaker");
static_assert(sizeof(IMatchmaker) == 0x000028, "Wrong size on IMatchmaker");

// Class DeceiveInc.DICCItem
// 0x0000 (0x0120 - 0x0120)
class UDICCItem final : public UDIItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DICCItem">();
	}
	static class UDICCItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDICCItem>();
	}
};
static_assert(alignof(UDICCItem) == 0x000008, "Wrong alignment on UDICCItem");
static_assert(sizeof(UDICCItem) == 0x000120, "Wrong size on UDICCItem");

// Class DeceiveInc.DIAvatarItem
// 0x0000 (0x0120 - 0x0120)
class UDIAvatarItem final : public UDIItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIAvatarItem">();
	}
	static class UDIAvatarItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIAvatarItem>();
	}
};
static_assert(alignof(UDIAvatarItem) == 0x000008, "Wrong alignment on UDIAvatarItem");
static_assert(sizeof(UDIAvatarItem) == 0x000120, "Wrong size on UDIAvatarItem");

// Class DeceiveInc.GenericErrorReportSubsystem
// 0x0008 (0x0038 - 0x0030)
class UGenericErrorReportSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericErrorReportSubsystem">();
	}
	static class UGenericErrorReportSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericErrorReportSubsystem>();
	}
};
static_assert(alignof(UGenericErrorReportSubsystem) == 0x000008, "Wrong alignment on UGenericErrorReportSubsystem");
static_assert(sizeof(UGenericErrorReportSubsystem) == 0x000038, "Wrong size on UGenericErrorReportSubsystem");

// Class DeceiveInc.DITitleItem
// 0x0000 (0x0120 - 0x0120)
class UDITitleItem final : public UDIItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DITitleItem">();
	}
	static class UDITitleItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDITitleItem>();
	}
};
static_assert(alignof(UDITitleItem) == 0x000008, "Wrong alignment on UDITitleItem");
static_assert(sizeof(UDITitleItem) == 0x000120, "Wrong size on UDITitleItem");

// Class DeceiveInc.DSkinGroupItem
// 0x0000 (0x0120 - 0x0120)
class UDSkinGroupItem final : public UDIItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DSkinGroupItem">();
	}
	static class UDSkinGroupItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDSkinGroupItem>();
	}
};
static_assert(alignof(UDSkinGroupItem) == 0x000008, "Wrong alignment on UDSkinGroupItem");
static_assert(sizeof(UDSkinGroupItem) == 0x000120, "Wrong size on UDSkinGroupItem");

// Class DeceiveInc.NPCBehavior
// 0x0010 (0x00C0 - 0x00B0)
class UNPCBehavior : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCBehavior">();
	}
	static class UNPCBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCBehavior>();
	}
};
static_assert(alignof(UNPCBehavior) == 0x000008, "Wrong alignment on UNPCBehavior");
static_assert(sizeof(UNPCBehavior) == 0x0000C0, "Wrong size on UNPCBehavior");

// Class DeceiveInc.NPCBehaviorDefault
// 0x0058 (0x0118 - 0x00C0)
class UNPCBehaviorDefault final : public UNPCBehavior
{
public:
	float                                         ChancesToInteract;                                 // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewObjectiveDelayMin;                              // 0x00C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NewObjectiveDelayMax;                              // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SusNewObjectiveDelayMin;                           // 0x00CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SusNewObjectiveDelayMax;                           // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMinMaxChances>                 ChancesToRemainInRoomWithNotEnoughNPC_PreSecurityLevel; // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x30];                                      // 0x00E8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCBehaviorDefault">();
	}
	static class UNPCBehaviorDefault* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCBehaviorDefault>();
	}
};
static_assert(alignof(UNPCBehaviorDefault) == 0x000008, "Wrong alignment on UNPCBehaviorDefault");
static_assert(sizeof(UNPCBehaviorDefault) == 0x000118, "Wrong size on UNPCBehaviorDefault");
static_assert(offsetof(UNPCBehaviorDefault, ChancesToInteract) == 0x0000C0, "Member 'UNPCBehaviorDefault::ChancesToInteract' has a wrong offset!");
static_assert(offsetof(UNPCBehaviorDefault, NewObjectiveDelayMin) == 0x0000C4, "Member 'UNPCBehaviorDefault::NewObjectiveDelayMin' has a wrong offset!");
static_assert(offsetof(UNPCBehaviorDefault, NewObjectiveDelayMax) == 0x0000C8, "Member 'UNPCBehaviorDefault::NewObjectiveDelayMax' has a wrong offset!");
static_assert(offsetof(UNPCBehaviorDefault, SusNewObjectiveDelayMin) == 0x0000CC, "Member 'UNPCBehaviorDefault::SusNewObjectiveDelayMin' has a wrong offset!");
static_assert(offsetof(UNPCBehaviorDefault, SusNewObjectiveDelayMax) == 0x0000D0, "Member 'UNPCBehaviorDefault::SusNewObjectiveDelayMax' has a wrong offset!");
static_assert(offsetof(UNPCBehaviorDefault, ChancesToRemainInRoomWithNotEnoughNPC_PreSecurityLevel) == 0x0000D8, "Member 'UNPCBehaviorDefault::ChancesToRemainInRoomWithNotEnoughNPC_PreSecurityLevel' has a wrong offset!");

// Class DeceiveInc.DILootItem
// 0x0000 (0x0120 - 0x0120)
class UDILootItem final : public UDIItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DILootItem">();
	}
	static class UDILootItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDILootItem>();
	}
};
static_assert(alignof(UDILootItem) == 0x000008, "Wrong alignment on UDILootItem");
static_assert(sizeof(UDILootItem) == 0x000120, "Wrong size on UDILootItem");

// Class DeceiveInc.DIProgressionItem
// 0x0000 (0x0120 - 0x0120)
class UDIProgressionItem final : public UDIItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIProgressionItem">();
	}
	static class UDIProgressionItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIProgressionItem>();
	}
};
static_assert(alignof(UDIProgressionItem) == 0x000008, "Wrong alignment on UDIProgressionItem");
static_assert(sizeof(UDIProgressionItem) == 0x000120, "Wrong size on UDIProgressionItem");

// Class DeceiveInc.ScannableComponent
// 0x0060 (0x0260 - 0x0200)
class UScannableComponent : public USceneComponent
{
public:
	FMulticastInlineDelegateProperty_             OnScannableStateChanged;                           // 0x01F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UInteractionIconComponent*              InteractionIconComp;                               // 0x0208(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 InteractableComp;                                  // 0x0210(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShapeComponent*                        ScannableDetectionColl;                            // 0x0218(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBaseConditionComponent*>        ConditionsList;                                    // 0x0220(0x0010)(ExportObject, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   InteractWidgetIconClass;                           // 0x0230(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanBeScanIfDisable;                               // 0x0258(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AreConditionsMet(class AActor* Interacter);
	bool AreRayCastConditionMet(class AActor* Interacter);
	void OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void SetDetectionCollision(class UShapeComponent* CollisionShape);
	void SetIsScannable(bool bScannable);
	void SetScanIcon(class UInteractionIconComponent* ScanIcon);

	struct FVector GetInteractionLocation() const;
	class UInteractionIconComponent* GetScanIcon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScannableComponent">();
	}
	static class UScannableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScannableComponent>();
	}
};
static_assert(alignof(UScannableComponent) == 0x000010, "Wrong alignment on UScannableComponent");
static_assert(sizeof(UScannableComponent) == 0x000260, "Wrong size on UScannableComponent");
static_assert(offsetof(UScannableComponent, OnScannableStateChanged) == 0x0001F8, "Member 'UScannableComponent::OnScannableStateChanged' has a wrong offset!");
static_assert(offsetof(UScannableComponent, InteractionIconComp) == 0x000208, "Member 'UScannableComponent::InteractionIconComp' has a wrong offset!");
static_assert(offsetof(UScannableComponent, InteractableComp) == 0x000210, "Member 'UScannableComponent::InteractableComp' has a wrong offset!");
static_assert(offsetof(UScannableComponent, ScannableDetectionColl) == 0x000218, "Member 'UScannableComponent::ScannableDetectionColl' has a wrong offset!");
static_assert(offsetof(UScannableComponent, ConditionsList) == 0x000220, "Member 'UScannableComponent::ConditionsList' has a wrong offset!");
static_assert(offsetof(UScannableComponent, InteractWidgetIconClass) == 0x000230, "Member 'UScannableComponent::InteractWidgetIconClass' has a wrong offset!");
static_assert(offsetof(UScannableComponent, bCanBeScanIfDisable) == 0x000258, "Member 'UScannableComponent::bCanBeScanIfDisable' has a wrong offset!");

// Class DeceiveInc.DIAgentBundleItem
// 0x0000 (0x0120 - 0x0120)
class UDIAgentBundleItem final : public UDIItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIAgentBundleItem">();
	}
	static class UDIAgentBundleItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIAgentBundleItem>();
	}
};
static_assert(alignof(UDIAgentBundleItem) == 0x000008, "Wrong alignment on UDIAgentBundleItem");
static_assert(sizeof(UDIAgentBundleItem) == 0x000120, "Wrong size on UDIAgentBundleItem");

// Class DeceiveInc.DIBundleItem
// 0x0000 (0x0120 - 0x0120)
class UDIBundleItem final : public UDIItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIBundleItem">();
	}
	static class UDIBundleItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIBundleItem>();
	}
};
static_assert(alignof(UDIBundleItem) == 0x000008, "Wrong alignment on UDIBundleItem");
static_assert(sizeof(UDIBundleItem) == 0x000120, "Wrong size on UDIBundleItem");

// Class DeceiveInc.GameplayResourcesComponent
// 0x0080 (0x0130 - 0x00B0)
class UGameplayResourcesComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnResourceNewAmount;                               // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnResourceChange;                                  // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLocalResourceChange;                             // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnResourceNewMaxAmount;                            // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGameplayResourcesInitDone;                       // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FPlayerResourceData>            PlayerResourceAmountMap;                           // 0x0100(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	class UGameplayResourcesData*                 GameplayResourcesData;                             // 0x0110(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRessourceMaxMods>              MaxAmoutMods;                                      // 0x0120(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void AddMaxAmountPowerup(EGameplayResourcesType Ressource, int32 MaxAmountIncrease, int32 ResourceToGive);
	void AddResource(EGameplayResourcesType ResourceType, int32 Amount, bool bGiveXpForResource);
	int32 GetMaxAmount(EGameplayResourcesType ResourceType);
	int32 GetResourceAmount(EGameplayResourcesType ResourceType);
	class FText GetResourceDisplayName(EGameplayResourcesType ResourceType);
	bool HasEnoughResource(EGameplayResourcesType ResourceType, int32 Amount);
	void OnRep_NewPlayerResourceData(const TArray<struct FPlayerResourceData>& OldData);
	void RemoveMaxAmountPowerup(EGameplayResourcesType Ressource, int32 MaxAmountIncrease, int32 ResourceToGive);
	void RemoveResource(EGameplayResourcesType ResourceType, int32 Amount);
	void ResetPlayerResources();
	void SetMaxAmount(EGameplayResourcesType ResourceType, int32 MaxAmount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayResourcesComponent">();
	}
	static class UGameplayResourcesComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayResourcesComponent>();
	}
};
static_assert(alignof(UGameplayResourcesComponent) == 0x000008, "Wrong alignment on UGameplayResourcesComponent");
static_assert(sizeof(UGameplayResourcesComponent) == 0x000130, "Wrong size on UGameplayResourcesComponent");
static_assert(offsetof(UGameplayResourcesComponent, OnResourceNewAmount) == 0x0000B0, "Member 'UGameplayResourcesComponent::OnResourceNewAmount' has a wrong offset!");
static_assert(offsetof(UGameplayResourcesComponent, OnResourceChange) == 0x0000C0, "Member 'UGameplayResourcesComponent::OnResourceChange' has a wrong offset!");
static_assert(offsetof(UGameplayResourcesComponent, OnLocalResourceChange) == 0x0000D0, "Member 'UGameplayResourcesComponent::OnLocalResourceChange' has a wrong offset!");
static_assert(offsetof(UGameplayResourcesComponent, OnResourceNewMaxAmount) == 0x0000E0, "Member 'UGameplayResourcesComponent::OnResourceNewMaxAmount' has a wrong offset!");
static_assert(offsetof(UGameplayResourcesComponent, OnGameplayResourcesInitDone) == 0x0000F0, "Member 'UGameplayResourcesComponent::OnGameplayResourcesInitDone' has a wrong offset!");
static_assert(offsetof(UGameplayResourcesComponent, PlayerResourceAmountMap) == 0x000100, "Member 'UGameplayResourcesComponent::PlayerResourceAmountMap' has a wrong offset!");
static_assert(offsetof(UGameplayResourcesComponent, GameplayResourcesData) == 0x000110, "Member 'UGameplayResourcesComponent::GameplayResourcesData' has a wrong offset!");
static_assert(offsetof(UGameplayResourcesComponent, MaxAmoutMods) == 0x000120, "Member 'UGameplayResourcesComponent::MaxAmoutMods' has a wrong offset!");

// Class DeceiveInc.DICurrencyItem
// 0x0000 (0x0120 - 0x0120)
class UDICurrencyItem final : public UDIItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DICurrencyItem">();
	}
	static class UDICurrencyItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDICurrencyItem>();
	}
};
static_assert(alignof(UDICurrencyItem) == 0x000008, "Wrong alignment on UDICurrencyItem");
static_assert(sizeof(UDICurrencyItem) == 0x000120, "Wrong size on UDICurrencyItem");

// Class DeceiveInc.DICatalogueItem
// 0x0000 (0x0120 - 0x0120)
class UDICatalogueItem final : public UDIItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DICatalogueItem">();
	}
	static class UDICatalogueItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDICatalogueItem>();
	}
};
static_assert(alignof(UDICatalogueItem) == 0x000008, "Wrong alignment on UDICatalogueItem");
static_assert(sizeof(UDICatalogueItem) == 0x000120, "Wrong size on UDICatalogueItem");

// Class DeceiveInc.DIConsumableItem
// 0x0000 (0x0120 - 0x0120)
class UDIConsumableItem final : public UDIItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIConsumableItem">();
	}
	static class UDIConsumableItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIConsumableItem>();
	}
};
static_assert(alignof(UDIConsumableItem) == 0x000008, "Wrong alignment on UDIConsumableItem");
static_assert(sizeof(UDIConsumableItem) == 0x000120, "Wrong size on UDIConsumableItem");

// Class DeceiveInc.DIVoucherItem
// 0x0000 (0x0120 - 0x0120)
class UDIVoucherItem final : public UDIItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIVoucherItem">();
	}
	static class UDIVoucherItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIVoucherItem>();
	}
};
static_assert(alignof(UDIVoucherItem) == 0x000008, "Wrong alignment on UDIVoucherItem");
static_assert(sizeof(UDIVoucherItem) == 0x000120, "Wrong size on UDIVoucherItem");

// Class DeceiveInc.NPCCharacter
// 0x0360 (0x0580 - 0x0220)
class ANPCCharacter final : public AActor
{
public:
	uint8                                         Pad_220[0x40];                                     // 0x0220(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class ANPCAIActor*                            NPCAI;                                             // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractableType                             InteractableType;                                  // 0x0268(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAirborneChangeEvent;                             // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnScaredChangeEvent;                               // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnScareTriggered;                                  // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMainAnimationChangeEvent;                        // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnScoldStateChangeDelegate;                        // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSetInteractAnimations;                           // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVisibilityChanged;                               // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDeathDelegate;                                   // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDisguiseCoverBlown;                              // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpperBodyBoneGroupChange;                        // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHipsRotationChanged;                             // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEnableHipsRotationChange;                        // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRotationStart;                                   // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAggroedChange;                                   // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRunningChange;                                   // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFollowingVIPChange;                              // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWalkDirectionChange;                             // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNPCFellOffMap;                                   // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_390[0x10];                                     // 0x0390(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Mesh;                                              // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNPCMovementComponent*                  MovementComponent;                                 // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsCrouched : 1;                                   // 0x03B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3B9[0x7];                                      // 0x03B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReplicatedInteractionActor;                        // 0x03C0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ANPCAIActor>                NPCAIClass;                                        // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESecurityLevel                                SecurityLevel;                                     // 0x03D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENPCPool                                      NPCPool;                                           // 0x03D1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D2[0x6];                                      // 0x03D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ConditionMetTooltipText;                           // 0x03D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   VIPName;                                           // 0x03F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UHealthComponent*                       HealthComponent;                                   // 0x0408(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       RegistrationCollisionShapeComp;                    // 0x0410(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRunning;                                          // 0x0418(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bScared;                                           // 0x0419(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EScoldState                                   ScoldState;                                        // 0x041A(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENPCMainAnimation                             MainAnimation;                                     // 0x041B(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FNPCMovementReplicationData            MovementData;                                      // 0x041C(0x0010)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FNPCLookAtReplicationData              LookAtData;                                        // 0x042C(0x000C)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLastInteractionData                   KillerData;                                        // 0x0438(0x0010)(Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 InteractableComp;                                  // 0x0448(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseConditionComponent*                DisguiseConditionComp;                             // 0x0450(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNPCMotionSetComponent*                 MotionSetComponent;                                // 0x0458(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHeadTrackingComponent*                 HeadTrackingComponent;                             // 0x0460(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPointOfInterestComponent*              PointOfInterestHead;                               // 0x0468(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USBAimAssistTargetComponent*            AimAssistTargetComp;                               // 0x0470(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    DebugTextRenderComponent;                          // 0x0478(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFollowingVIP;                                     // 0x0480(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_481[0x57];                                     // 0x0481(0x0057)(Fixing Size After Last Property [ Dumper-7 ])
	class UDeadNPCInteraction*                    ResurrectInteract;                                 // 0x04D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CurrentProp;                                       // 0x04E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E8[0x1];                                      // 0x04E8(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanPlayFootsteps;                                 // 0x04E9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bThrottleMovment;                                  // 0x04EA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4EB[0x1];                                      // 0x04EB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReviveDelay;                                       // 0x04EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F0[0x22];                                     // 0x04F0(0x0022)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          PlayerSetting_ShadowEnabled;                       // 0x0512(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_513[0x9];                                      // 0x0513(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bBounced;                                          // 0x051C(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51D[0x3];                                      // 0x051D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           ForceVisibilityBasedAnimActors;                    // 0x0520(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_570[0x8];                                      // 0x0570(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsCachedNPC;                                      // 0x0578(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNPCVisibleFlag;                                   // 0x0579(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57A[0x6];                                      // 0x057A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsNPCMainAnimationAirborne(ENPCMainAnimation CheckMainAnimation);

	void BouncedTimeOutTimerEnd();
	void BP_OnDeath();
	void BP_OnGuardLostTargetAnim();
	void BP_OnNPCBanter();
	void BP_OnNPCJustRevivedAnotherNPC(class ANPCCharacter* DeadNPC, class AActor* Prop);
	void BP_OnNPCRevivingAnotherNPC(class ANPCCharacter* DeadNPC);
	void BP_OnPlayReplicatedVO(ENPCReplicatedVO VOType);
	void BP_OnResurrected();
	void BP_OnScaredChange(bool bScaredIn);
	void BP_OnScareTriggered(ENPCScaredReason ScaredReason);
	void BP_OnScoldStart();
	void BP_OnSpyRelease();
	void BP_OnXiuDecoyEffect();
	void BP_SignificanceUpdate(float OldValue, float NewValue);
	void DestroyCurrentProp();
	void ExternalBounce(const struct FVector& Impulse, class AActor* BouncedBy);
	void HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void HandleTakePointDamage(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& ShotFromDirection, const class UDamageType* DamageType, class AActor* DamageCauser);
	bool IsRightFootForward();
	void Multicast_FellOffMap();
	void MulticastExternalBounce(const struct FVector_NetQuantize& Impulse, class AActor* BouncedBy);
	void NetMulticast_OnResurrected();
	void NetMulticast_TriggerScared(ENPCScaredReason ScaredReason);
	void NetMulticast_TriggerXiuDecoyEffect();
	void OnConversationNewTalkingNPC(class UNPCConversationComponent* ConversationInteractionComp, class ANPCCharacter* TalkingNPC);
	void OnCrouchToResurectDelayTimerEnd();
	void OnDeath(class AActor* DeadActor);
	void OnHealthChanged(class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, float RawDamage);
	void OnRep_Bounced();
	void OnRep_CachedNPC();
	void OnRep_FollowingVIP();
	void OnRep_IsCrouched();
	void OnRep_LookAtData(const struct FNPCLookAtReplicationData& PrevLookAtData);
	void OnRep_MainAnimation(ENPCMainAnimation PrevMainAnimation);
	void OnRep_MovementData(const struct FNPCMovementReplicationData& PrevMovementData);
	void OnRep_ReplicatedInteraction(class AActor* PrevReplicatedInteraction);
	void OnRep_Running(bool PrevRunning);
	void OnRep_Scared(bool PrevScared);
	void OnRep_ScoldState(EScoldState PrevScoldState);
	void OnResurrectTimer();
	void OnRevive(class AActor* DeadActor);
	void OnScaredEnd();
	void OnScoldGiveUp();
	void PlayReplicatedVO(ENPCReplicatedVO VOType);
	void ReleasePlayerPossessMulticast();
	void Resurrect();
	void SetUpperBodyBoneGroup(ENPCUpperBodyBoneGroup NewBoneGroup);
	class AActor* SpawnProp(TSubclassOf<class AActor> ActorClassToSpawn, class FName BoneAttachName);
	void TriggerGuardLostTargetAnimEvent();
	void TriggerNPCBanterEvent();

	bool CanEverBeAggroed() const;
	class ASpy* GetControllingSpy() const;
	class AActor* GetCurrentProp() const;
	class AVictimEffect* GetEffectOfClass(class UClass* EffectClass) const;
	class UNPCGuardComponent* GetGuardComponent() const;
	EInteractableType GetInteractableType() const;
	struct FLastInteractionData GetKillerData() const;
	ENPCPool GetNPCPool() const;
	ESecurityLevel GetSecurityLevel() const;
	ENPCUpperBodyBoneGroup GetUpperBodyBoneGroup() const;
	ENPCWalkDirection GetWalkDirection() const;
	bool IsActorFlaggedAsIgnoreHeat(class AActor* FlaggedActor) const;
	bool IsAggroed() const;
	bool IsControlledBySpy() const;
	bool IsDead() const;
	bool IsFlaggedAsXiuDecoy() const;
	bool IsFollowingVIP() const;
	bool IsRunDisabled() const;
	bool IsRunning() const;
	bool IsScared() const;
	bool IsScolding() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCCharacter">();
	}
	static class ANPCCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANPCCharacter>();
	}
};
static_assert(alignof(ANPCCharacter) == 0x000008, "Wrong alignment on ANPCCharacter");
static_assert(sizeof(ANPCCharacter) == 0x000580, "Wrong size on ANPCCharacter");
static_assert(offsetof(ANPCCharacter, NPCAI) == 0x000260, "Member 'ANPCCharacter::NPCAI' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, InteractableType) == 0x000268, "Member 'ANPCCharacter::InteractableType' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, OnAirborneChangeEvent) == 0x000270, "Member 'ANPCCharacter::OnAirborneChangeEvent' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, OnScaredChangeEvent) == 0x000280, "Member 'ANPCCharacter::OnScaredChangeEvent' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, OnScareTriggered) == 0x000290, "Member 'ANPCCharacter::OnScareTriggered' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, OnMainAnimationChangeEvent) == 0x0002A0, "Member 'ANPCCharacter::OnMainAnimationChangeEvent' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, OnScoldStateChangeDelegate) == 0x0002B0, "Member 'ANPCCharacter::OnScoldStateChangeDelegate' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, OnSetInteractAnimations) == 0x0002C0, "Member 'ANPCCharacter::OnSetInteractAnimations' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, OnVisibilityChanged) == 0x0002D0, "Member 'ANPCCharacter::OnVisibilityChanged' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, OnDeathDelegate) == 0x0002E0, "Member 'ANPCCharacter::OnDeathDelegate' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, OnDisguiseCoverBlown) == 0x0002F0, "Member 'ANPCCharacter::OnDisguiseCoverBlown' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, OnUpperBodyBoneGroupChange) == 0x000300, "Member 'ANPCCharacter::OnUpperBodyBoneGroupChange' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, OnHipsRotationChanged) == 0x000310, "Member 'ANPCCharacter::OnHipsRotationChanged' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, OnEnableHipsRotationChange) == 0x000320, "Member 'ANPCCharacter::OnEnableHipsRotationChange' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, OnRotationStart) == 0x000330, "Member 'ANPCCharacter::OnRotationStart' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, OnAggroedChange) == 0x000340, "Member 'ANPCCharacter::OnAggroedChange' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, OnRunningChange) == 0x000350, "Member 'ANPCCharacter::OnRunningChange' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, OnFollowingVIPChange) == 0x000360, "Member 'ANPCCharacter::OnFollowingVIPChange' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, OnWalkDirectionChange) == 0x000370, "Member 'ANPCCharacter::OnWalkDirectionChange' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, OnNPCFellOffMap) == 0x000380, "Member 'ANPCCharacter::OnNPCFellOffMap' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, Mesh) == 0x0003A0, "Member 'ANPCCharacter::Mesh' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, CapsuleComponent) == 0x0003A8, "Member 'ANPCCharacter::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, MovementComponent) == 0x0003B0, "Member 'ANPCCharacter::MovementComponent' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, ReplicatedInteractionActor) == 0x0003C0, "Member 'ANPCCharacter::ReplicatedInteractionActor' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, NPCAIClass) == 0x0003C8, "Member 'ANPCCharacter::NPCAIClass' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, SecurityLevel) == 0x0003D0, "Member 'ANPCCharacter::SecurityLevel' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, NPCPool) == 0x0003D1, "Member 'ANPCCharacter::NPCPool' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, ConditionMetTooltipText) == 0x0003D8, "Member 'ANPCCharacter::ConditionMetTooltipText' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, VIPName) == 0x0003F0, "Member 'ANPCCharacter::VIPName' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, HealthComponent) == 0x000408, "Member 'ANPCCharacter::HealthComponent' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, RegistrationCollisionShapeComp) == 0x000410, "Member 'ANPCCharacter::RegistrationCollisionShapeComp' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, bRunning) == 0x000418, "Member 'ANPCCharacter::bRunning' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, bScared) == 0x000419, "Member 'ANPCCharacter::bScared' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, ScoldState) == 0x00041A, "Member 'ANPCCharacter::ScoldState' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, MainAnimation) == 0x00041B, "Member 'ANPCCharacter::MainAnimation' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, MovementData) == 0x00041C, "Member 'ANPCCharacter::MovementData' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, LookAtData) == 0x00042C, "Member 'ANPCCharacter::LookAtData' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, KillerData) == 0x000438, "Member 'ANPCCharacter::KillerData' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, InteractableComp) == 0x000448, "Member 'ANPCCharacter::InteractableComp' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, DisguiseConditionComp) == 0x000450, "Member 'ANPCCharacter::DisguiseConditionComp' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, MotionSetComponent) == 0x000458, "Member 'ANPCCharacter::MotionSetComponent' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, HeadTrackingComponent) == 0x000460, "Member 'ANPCCharacter::HeadTrackingComponent' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, PointOfInterestHead) == 0x000468, "Member 'ANPCCharacter::PointOfInterestHead' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, AimAssistTargetComp) == 0x000470, "Member 'ANPCCharacter::AimAssistTargetComp' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, DebugTextRenderComponent) == 0x000478, "Member 'ANPCCharacter::DebugTextRenderComponent' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, bFollowingVIP) == 0x000480, "Member 'ANPCCharacter::bFollowingVIP' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, ResurrectInteract) == 0x0004D8, "Member 'ANPCCharacter::ResurrectInteract' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, CurrentProp) == 0x0004E0, "Member 'ANPCCharacter::CurrentProp' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, bCanPlayFootsteps) == 0x0004E9, "Member 'ANPCCharacter::bCanPlayFootsteps' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, bThrottleMovment) == 0x0004EA, "Member 'ANPCCharacter::bThrottleMovment' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, ReviveDelay) == 0x0004EC, "Member 'ANPCCharacter::ReviveDelay' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, PlayerSetting_ShadowEnabled) == 0x000512, "Member 'ANPCCharacter::PlayerSetting_ShadowEnabled' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, bBounced) == 0x00051C, "Member 'ANPCCharacter::bBounced' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, ForceVisibilityBasedAnimActors) == 0x000520, "Member 'ANPCCharacter::ForceVisibilityBasedAnimActors' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, bIsCachedNPC) == 0x000578, "Member 'ANPCCharacter::bIsCachedNPC' has a wrong offset!");
static_assert(offsetof(ANPCCharacter, bNPCVisibleFlag) == 0x000579, "Member 'ANPCCharacter::bNPCVisibleFlag' has a wrong offset!");

// Class DeceiveInc.StoreScheduleData
// 0x0070 (0x00A0 - 0x0030)
class UStoreScheduleData final : public UDataAsset
{
public:
	struct FDateTime                              StartDate;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasRotation;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScheduleSlotData                      Slot1Schedule;                                     // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FScheduleSlotData                      Slot2Schedule;                                     // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FScheduleSlotData                      Slot3Schedule;                                     // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FScheduleSlotData                      Slot4Schedule;                                     // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FScheduleSlotData                      Slot5Schedule;                                     // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FScheduleSaleEntry>             OnSaleItems;                                       // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreScheduleData">();
	}
	static class UStoreScheduleData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreScheduleData>();
	}
};
static_assert(alignof(UStoreScheduleData) == 0x000008, "Wrong alignment on UStoreScheduleData");
static_assert(sizeof(UStoreScheduleData) == 0x0000A0, "Wrong size on UStoreScheduleData");
static_assert(offsetof(UStoreScheduleData, StartDate) == 0x000030, "Member 'UStoreScheduleData::StartDate' has a wrong offset!");
static_assert(offsetof(UStoreScheduleData, bHasRotation) == 0x000038, "Member 'UStoreScheduleData::bHasRotation' has a wrong offset!");
static_assert(offsetof(UStoreScheduleData, Slot1Schedule) == 0x000040, "Member 'UStoreScheduleData::Slot1Schedule' has a wrong offset!");
static_assert(offsetof(UStoreScheduleData, Slot2Schedule) == 0x000050, "Member 'UStoreScheduleData::Slot2Schedule' has a wrong offset!");
static_assert(offsetof(UStoreScheduleData, Slot3Schedule) == 0x000060, "Member 'UStoreScheduleData::Slot3Schedule' has a wrong offset!");
static_assert(offsetof(UStoreScheduleData, Slot4Schedule) == 0x000070, "Member 'UStoreScheduleData::Slot4Schedule' has a wrong offset!");
static_assert(offsetof(UStoreScheduleData, Slot5Schedule) == 0x000080, "Member 'UStoreScheduleData::Slot5Schedule' has a wrong offset!");
static_assert(offsetof(UStoreScheduleData, OnSaleItems) == 0x000090, "Member 'UStoreScheduleData::OnSaleItems' has a wrong offset!");

// Class DeceiveInc.StoreCatalogEntryData
// 0x01D8 (0x0208 - 0x0030)
class UStoreCatalogEntryData final : public UDataAsset
{
public:
	class UDICatalogueItem*                       CatalogItem;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CatalogItemID;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Year;                                              // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Season;                                            // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCurrentSeason;                                  // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              CatalogKeyart;                                     // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CatalogName;                                       // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              CatalogIcon;                                       // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              CatalogIconGray;                                   // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CatalogDesc;                                       // 0x00D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UDIItem*                                CatalogPurchaseReward1;                            // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CatalogPurchaseReward1Name;                        // 0x00F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         CatalogPurchaseReward1ItemID;                      // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDIItem*                                CatalogPurchaseReward2;                            // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CatalogPurchaseReward2Name;                        // 0x0120(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         CatalogPurchaseReward2ItemID;                      // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDIItem*                                CatalogWeaponShowcase;                             // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FStoreCatalogEntryPageData>     CatalogPages;                                      // 0x0148(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FStoreCatalogEntryRewardData           CatalogRewards;                                    // 0x0158(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCatalogEntryData">();
	}
	static class UStoreCatalogEntryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreCatalogEntryData>();
	}
};
static_assert(alignof(UStoreCatalogEntryData) == 0x000008, "Wrong alignment on UStoreCatalogEntryData");
static_assert(sizeof(UStoreCatalogEntryData) == 0x000208, "Wrong size on UStoreCatalogEntryData");
static_assert(offsetof(UStoreCatalogEntryData, CatalogItem) == 0x000030, "Member 'UStoreCatalogEntryData::CatalogItem' has a wrong offset!");
static_assert(offsetof(UStoreCatalogEntryData, CatalogItemID) == 0x000038, "Member 'UStoreCatalogEntryData::CatalogItemID' has a wrong offset!");
static_assert(offsetof(UStoreCatalogEntryData, Year) == 0x00003C, "Member 'UStoreCatalogEntryData::Year' has a wrong offset!");
static_assert(offsetof(UStoreCatalogEntryData, Season) == 0x000040, "Member 'UStoreCatalogEntryData::Season' has a wrong offset!");
static_assert(offsetof(UStoreCatalogEntryData, bIsCurrentSeason) == 0x000044, "Member 'UStoreCatalogEntryData::bIsCurrentSeason' has a wrong offset!");
static_assert(offsetof(UStoreCatalogEntryData, CatalogKeyart) == 0x000048, "Member 'UStoreCatalogEntryData::CatalogKeyart' has a wrong offset!");
static_assert(offsetof(UStoreCatalogEntryData, CatalogName) == 0x000070, "Member 'UStoreCatalogEntryData::CatalogName' has a wrong offset!");
static_assert(offsetof(UStoreCatalogEntryData, CatalogIcon) == 0x000088, "Member 'UStoreCatalogEntryData::CatalogIcon' has a wrong offset!");
static_assert(offsetof(UStoreCatalogEntryData, CatalogIconGray) == 0x0000B0, "Member 'UStoreCatalogEntryData::CatalogIconGray' has a wrong offset!");
static_assert(offsetof(UStoreCatalogEntryData, CatalogDesc) == 0x0000D8, "Member 'UStoreCatalogEntryData::CatalogDesc' has a wrong offset!");
static_assert(offsetof(UStoreCatalogEntryData, CatalogPurchaseReward1) == 0x0000F0, "Member 'UStoreCatalogEntryData::CatalogPurchaseReward1' has a wrong offset!");
static_assert(offsetof(UStoreCatalogEntryData, CatalogPurchaseReward1Name) == 0x0000F8, "Member 'UStoreCatalogEntryData::CatalogPurchaseReward1Name' has a wrong offset!");
static_assert(offsetof(UStoreCatalogEntryData, CatalogPurchaseReward1ItemID) == 0x000110, "Member 'UStoreCatalogEntryData::CatalogPurchaseReward1ItemID' has a wrong offset!");
static_assert(offsetof(UStoreCatalogEntryData, CatalogPurchaseReward2) == 0x000118, "Member 'UStoreCatalogEntryData::CatalogPurchaseReward2' has a wrong offset!");
static_assert(offsetof(UStoreCatalogEntryData, CatalogPurchaseReward2Name) == 0x000120, "Member 'UStoreCatalogEntryData::CatalogPurchaseReward2Name' has a wrong offset!");
static_assert(offsetof(UStoreCatalogEntryData, CatalogPurchaseReward2ItemID) == 0x000138, "Member 'UStoreCatalogEntryData::CatalogPurchaseReward2ItemID' has a wrong offset!");
static_assert(offsetof(UStoreCatalogEntryData, CatalogWeaponShowcase) == 0x000140, "Member 'UStoreCatalogEntryData::CatalogWeaponShowcase' has a wrong offset!");
static_assert(offsetof(UStoreCatalogEntryData, CatalogPages) == 0x000148, "Member 'UStoreCatalogEntryData::CatalogPages' has a wrong offset!");
static_assert(offsetof(UStoreCatalogEntryData, CatalogRewards) == 0x000158, "Member 'UStoreCatalogEntryData::CatalogRewards' has a wrong offset!");

// Class DeceiveInc.NPCBehaviorInteract
// 0x0048 (0x0108 - 0x00C0)
class UNPCBehaviorInteract final : public UNPCBehavior
{
public:
	uint8                                         Pad_C0[0x48];                                      // 0x00C0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFakeInteractTimerEnd();
	void OnFlushNetDormancyIntervalTimerEnd();
	void OnGiveUpInteractTimerEnd();
	void OnOutroTimerEnd();
	void OnReInteractTimerEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCBehaviorInteract">();
	}
	static class UNPCBehaviorInteract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCBehaviorInteract>();
	}
};
static_assert(alignof(UNPCBehaviorInteract) == 0x000008, "Wrong alignment on UNPCBehaviorInteract");
static_assert(sizeof(UNPCBehaviorInteract) == 0x000108, "Wrong size on UNPCBehaviorInteract");

// Class DeceiveInc.StoreCatalogsData
// 0x0010 (0x0040 - 0x0030)
class UStoreCatalogsData final : public UDataAsset
{
public:
	TArray<class UStoreCatalogEntryData*>         Catalogs;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCatalogsData">();
	}
	static class UStoreCatalogsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreCatalogsData>();
	}
};
static_assert(alignof(UStoreCatalogsData) == 0x000008, "Wrong alignment on UStoreCatalogsData");
static_assert(sizeof(UStoreCatalogsData) == 0x000040, "Wrong size on UStoreCatalogsData");
static_assert(offsetof(UStoreCatalogsData, Catalogs) == 0x000030, "Member 'UStoreCatalogsData::Catalogs' has a wrong offset!");

// Class DeceiveInc.DIStoreDataAsset
// 0x0058 (0x0090 - 0x0038)
class UDIStoreDataAsset final : public UDIPrimaryDataAsset
{
public:
	TArray<class UDIItem*>                        AllStoreItems;                                     // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class UStoreScheduleData*                     Schedule;                                          // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStoreCatalogsData*                     Catalogs;                                          // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDataItemIDGenerationData>      IDGenRangeData;                                    // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftCurrencyGroupCostData             SoftCurrencyGroupCostData;                         // 0x0068(0x0010)(Edit, NativeAccessSpecifierPublic)
	class UDICurrencyItem*                        SoftCurrency;                                      // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDICurrencyItem*                        HardCurrency;                                      // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDICurrencyItem*                        CatalogCurency;                                    // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIStoreDataAsset">();
	}
	static class UDIStoreDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIStoreDataAsset>();
	}
};
static_assert(alignof(UDIStoreDataAsset) == 0x000008, "Wrong alignment on UDIStoreDataAsset");
static_assert(sizeof(UDIStoreDataAsset) == 0x000090, "Wrong size on UDIStoreDataAsset");
static_assert(offsetof(UDIStoreDataAsset, AllStoreItems) == 0x000038, "Member 'UDIStoreDataAsset::AllStoreItems' has a wrong offset!");
static_assert(offsetof(UDIStoreDataAsset, Schedule) == 0x000048, "Member 'UDIStoreDataAsset::Schedule' has a wrong offset!");
static_assert(offsetof(UDIStoreDataAsset, Catalogs) == 0x000050, "Member 'UDIStoreDataAsset::Catalogs' has a wrong offset!");
static_assert(offsetof(UDIStoreDataAsset, IDGenRangeData) == 0x000058, "Member 'UDIStoreDataAsset::IDGenRangeData' has a wrong offset!");
static_assert(offsetof(UDIStoreDataAsset, SoftCurrencyGroupCostData) == 0x000068, "Member 'UDIStoreDataAsset::SoftCurrencyGroupCostData' has a wrong offset!");
static_assert(offsetof(UDIStoreDataAsset, SoftCurrency) == 0x000078, "Member 'UDIStoreDataAsset::SoftCurrency' has a wrong offset!");
static_assert(offsetof(UDIStoreDataAsset, HardCurrency) == 0x000080, "Member 'UDIStoreDataAsset::HardCurrency' has a wrong offset!");
static_assert(offsetof(UDIStoreDataAsset, CatalogCurency) == 0x000088, "Member 'UDIStoreDataAsset::CatalogCurency' has a wrong offset!");

// Class DeceiveInc.NPCAdditionalComponent
// 0x0008 (0x00B8 - 0x00B0)
class UNPCAdditionalComponent : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCAdditionalComponent">();
	}
	static class UNPCAdditionalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCAdditionalComponent>();
	}
};
static_assert(alignof(UNPCAdditionalComponent) == 0x000008, "Wrong alignment on UNPCAdditionalComponent");
static_assert(sizeof(UNPCAdditionalComponent) == 0x0000B8, "Wrong size on UNPCAdditionalComponent");

// Class DeceiveInc.DIStoreSubsystem
// 0x0040 (0x0070 - 0x0030)
class UDIStoreSubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnWalletUpdated;                                   // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UDIStoreDataAsset*                      StoreData;                                         // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HardCurrencyAmount;                                // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnShopDataRefreshed;                               // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CatalogueIsItemPremiumLocked(const class UStoreCatalogEntryData* Catalogue, const class UDIItem* ItemToChheck);
	TArray<class UDIItem*> GetAllItemsOfType(EDIITemTypeQuery ItemType, int32 MinRarity, int32 MaxRarity, bool bShopOnly, bool bReverse);
	class UDICurrencyItem* GetCurrencyFromCurrencyId(const class FString& CurrencyId);
	bool GetIsRotationEnabled();
	class UDIItem* GetItemFromAssetId(const struct FPrimaryAssetId& AssetId);
	class UDIItem* GetItemFromItemId(const class FString& ItemId);
	void GetTimeUntilRotation(class FString* TimeLeft, float* Ratio);
	int32 GetXPBoosterActiveTime();
	class FString GetXPBoosterID();
	void OnWalletUpdated__DelegateSignature(const struct FAccelByteModelsWalletInfo& WalletInfo);
	void QueryWallet();

	bool CanPurchaseItemWithCurrency(const class UDIItem* ItemToCheck, const class UDICurrencyItem* CurrencyType, int32 CurrencyAmount) const;
	bool CatalogueCanPurchaseItem(const class UDIItem* ItemToCheck) const;
	bool CatalogueCheckPageCompleted(const struct FStoreCatalogEntryPageData& PageToCheck, int32* NbItemsUnlocked) const;
	int32 CatalogueGetCurrentPage(const class UStoreCatalogEntryData* Catalogue) const;
	bool CatalogueIsCurrentSeason(const class UStoreCatalogEntryData* Catalogue) const;
	class UDIItem* GetBundleContainingItem(const class UDIItem* ToFind) const;
	class UStoreCatalogEntryData* GetCatalogForAgent(const class UDIItem* ItemToCheck) const;
	class UStoreCatalogEntryData* GetCatalogForItem(const class UDIItem* ItemToCheck) const;
	class UDICurrencyItem* GetCatalogueCurrencyItem() const;
	class UTexture2D* GetCollectionIconForItem(const class UDIItem* ItemToCheck) const;
	class UDICurrencyItem* GetHardCurrencyItem() const;
	int32 GetItemCostForCurrency(const class UDIItem* ItemToCheck, const class UDICurrencyItem* Currency) const;
	class UDIItem* GetItemFromItemIdNum(const int32& ItemId) const;
	int32 GetRebatePercentForItem(const class UDIItem* ItemToCheck) const;
	class UDICurrencyItem* GetSoftCurrencyItem() const;
	bool IsItemPurchasable(const class UDIItem* ItemToCheck) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIStoreSubsystem">();
	}
	static class UDIStoreSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIStoreSubsystem>();
	}
};
static_assert(alignof(UDIStoreSubsystem) == 0x000008, "Wrong alignment on UDIStoreSubsystem");
static_assert(sizeof(UDIStoreSubsystem) == 0x000070, "Wrong size on UDIStoreSubsystem");
static_assert(offsetof(UDIStoreSubsystem, OnWalletUpdated) == 0x000030, "Member 'UDIStoreSubsystem::OnWalletUpdated' has a wrong offset!");
static_assert(offsetof(UDIStoreSubsystem, StoreData) == 0x000040, "Member 'UDIStoreSubsystem::StoreData' has a wrong offset!");
static_assert(offsetof(UDIStoreSubsystem, HardCurrencyAmount) == 0x000048, "Member 'UDIStoreSubsystem::HardCurrencyAmount' has a wrong offset!");
static_assert(offsetof(UDIStoreSubsystem, OnShopDataRefreshed) == 0x000050, "Member 'UDIStoreSubsystem::OnShopDataRefreshed' has a wrong offset!");

// Class DeceiveInc.DiUserSettingWidget
// 0x0050 (0x02B0 - 0x0260)
class UDiUserSettingWidget : public UUserWidget
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SettingShortDescription;                           // 0x0268(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class FText                                   SettingLongDescription;                            // 0x0280(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          bAllowedPerAgentSetting;                           // 0x0298(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAdvancedSetting;                                // 0x0299(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerSettingsDefaultState                   DefaultVisibilityState;                            // 0x029A(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29B[0x5];                                      // 0x029B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPlayerSettingsType>                   SubSettingTypes;                                   // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void BP_OnCollapse();
	void BP_OnCollapseSubSettings();
	void BP_OnExpand();
	void BP_OnExpandSubSettings();
	void BP_OnRefresh();
	void HandleSettingChange(EPlayerSettingsType SettingChanged);
	void Refresh();
	void SetupForSetting(EPlayerSettingsType InSettingType);

	EPlayerSettingsDefaultState GetDefaultVisibilityState() const;
	class FText GetSettingShortDescription() const;
	class FText GetSettingTooltipDecription() const;
	bool IsAdvancedSetting() const;
	bool IsAllowedPerAgentSetting() const;
	bool IsAllowedSubSetting() const;
	bool IsEnabled() const;
	bool IsTooltipAvailable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiUserSettingWidget">();
	}
	static class UDiUserSettingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiUserSettingWidget>();
	}
};
static_assert(alignof(UDiUserSettingWidget) == 0x000008, "Wrong alignment on UDiUserSettingWidget");
static_assert(sizeof(UDiUserSettingWidget) == 0x0002B0, "Wrong size on UDiUserSettingWidget");
static_assert(offsetof(UDiUserSettingWidget, SettingType) == 0x000260, "Member 'UDiUserSettingWidget::SettingType' has a wrong offset!");
static_assert(offsetof(UDiUserSettingWidget, SettingShortDescription) == 0x000268, "Member 'UDiUserSettingWidget::SettingShortDescription' has a wrong offset!");
static_assert(offsetof(UDiUserSettingWidget, SettingLongDescription) == 0x000280, "Member 'UDiUserSettingWidget::SettingLongDescription' has a wrong offset!");
static_assert(offsetof(UDiUserSettingWidget, bAllowedPerAgentSetting) == 0x000298, "Member 'UDiUserSettingWidget::bAllowedPerAgentSetting' has a wrong offset!");
static_assert(offsetof(UDiUserSettingWidget, bIsAdvancedSetting) == 0x000299, "Member 'UDiUserSettingWidget::bIsAdvancedSetting' has a wrong offset!");
static_assert(offsetof(UDiUserSettingWidget, DefaultVisibilityState) == 0x00029A, "Member 'UDiUserSettingWidget::DefaultVisibilityState' has a wrong offset!");
static_assert(offsetof(UDiUserSettingWidget, SubSettingTypes) == 0x0002A0, "Member 'UDiUserSettingWidget::SubSettingTypes' has a wrong offset!");

// Class DeceiveInc.NPCBug
// 0x0168 (0x0480 - 0x0318)
class ANPCBug final : public ABasePickablePlaceable
{
public:
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USpringArmComponent*                    SpringArm;                                         // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        NPCBugCameraRef1P;                                 // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpringArmComponent*                    SpringArm3P;                                       // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        NPCBugCameraRef3P;                                 // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       CameraComponent;                                   // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHeightCheckComponent*                  HeightCheckComp;                                   // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FNPCBugViewLimit                       RotationViewLimits1P;                              // 0x0350(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FNPCBugViewLimit                       HorizontalRotationViewLimits1P;                    // 0x0368(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FNPCBugViewLimit                       RotationViewLimits3P;                              // 0x0380(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         PitchTolerance;                                    // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   NPCBugHudAsset;                                    // 0x03A0(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   VictimEffectAsset;                                 // 0x03C8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     OutOfBoundsActorClass;                             // 0x03F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VictimEffectFadeOutTime;                           // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3FC[0x4];                                      // 0x03FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCameraActiveChanged;                             // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnCameraOutOfBounds;                               // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UClass*                                 NPCBugHudClass;                                    // 0x0420(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 VictimEffectClass;                                 // 0x0428(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 VictimEffectActor;                                 // 0x0430(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            NPCBugHud;                                         // 0x0438(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AVictimEffect*                          CurrentVictimEffect;                               // 0x0440(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CurrentVictim;                                     // 0x0448(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 OutOfBoundsActor;                                  // 0x0450(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASpy*                                   SpyVictim;                                         // 0x0458(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCamera3P;                                      // 0x0460(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_461[0x1F];                                     // 0x0461(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleCoverSwitch(class ANPCCharacter* Disguise);
	void HandleDeadActor(class AActor* DeadActor);
	void HandleNPCFellOffMap(class ANPCCharacter* NPCCharacter);
	void HandleSpyLookAction(class ASpy* Spy, float YawValue, float PitchValue, bool bIsSpyCameraMovementLock);
	void HandleSpyTransformInMimic(class ASpy* Spy, class ABaseMimicScannableActor* Mimic);
	void HandleSpyUndercoverChanged(class ASpy* Spy, bool Undercover);
	void NetMulticast_SetIsCameraActive(bool bInIsCameraActive);
	void NetMulticast_SetNewRotation(const struct FRotator& NewRotation);
	void OnFadeOutTimerEnd();
	void OnRep_SpyVictim(class ASpy* OldSpy);
	void OnRep_UseCamera3P();
	void Server_SetIsCameraActive(bool bInIsCameraActive);
	void Server_SetNewRotation(const struct FRotator& NewRotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCBug">();
	}
	static class ANPCBug* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANPCBug>();
	}
};
static_assert(alignof(ANPCBug) == 0x000008, "Wrong alignment on ANPCBug");
static_assert(sizeof(ANPCBug) == 0x000480, "Wrong size on ANPCBug");
static_assert(offsetof(ANPCBug, SpringArm) == 0x000320, "Member 'ANPCBug::SpringArm' has a wrong offset!");
static_assert(offsetof(ANPCBug, NPCBugCameraRef1P) == 0x000328, "Member 'ANPCBug::NPCBugCameraRef1P' has a wrong offset!");
static_assert(offsetof(ANPCBug, SpringArm3P) == 0x000330, "Member 'ANPCBug::SpringArm3P' has a wrong offset!");
static_assert(offsetof(ANPCBug, NPCBugCameraRef3P) == 0x000338, "Member 'ANPCBug::NPCBugCameraRef3P' has a wrong offset!");
static_assert(offsetof(ANPCBug, CameraComponent) == 0x000340, "Member 'ANPCBug::CameraComponent' has a wrong offset!");
static_assert(offsetof(ANPCBug, HeightCheckComp) == 0x000348, "Member 'ANPCBug::HeightCheckComp' has a wrong offset!");
static_assert(offsetof(ANPCBug, RotationViewLimits1P) == 0x000350, "Member 'ANPCBug::RotationViewLimits1P' has a wrong offset!");
static_assert(offsetof(ANPCBug, HorizontalRotationViewLimits1P) == 0x000368, "Member 'ANPCBug::HorizontalRotationViewLimits1P' has a wrong offset!");
static_assert(offsetof(ANPCBug, RotationViewLimits3P) == 0x000380, "Member 'ANPCBug::RotationViewLimits3P' has a wrong offset!");
static_assert(offsetof(ANPCBug, PitchTolerance) == 0x000398, "Member 'ANPCBug::PitchTolerance' has a wrong offset!");
static_assert(offsetof(ANPCBug, NPCBugHudAsset) == 0x0003A0, "Member 'ANPCBug::NPCBugHudAsset' has a wrong offset!");
static_assert(offsetof(ANPCBug, VictimEffectAsset) == 0x0003C8, "Member 'ANPCBug::VictimEffectAsset' has a wrong offset!");
static_assert(offsetof(ANPCBug, OutOfBoundsActorClass) == 0x0003F0, "Member 'ANPCBug::OutOfBoundsActorClass' has a wrong offset!");
static_assert(offsetof(ANPCBug, VictimEffectFadeOutTime) == 0x0003F8, "Member 'ANPCBug::VictimEffectFadeOutTime' has a wrong offset!");
static_assert(offsetof(ANPCBug, OnCameraActiveChanged) == 0x000400, "Member 'ANPCBug::OnCameraActiveChanged' has a wrong offset!");
static_assert(offsetof(ANPCBug, OnCameraOutOfBounds) == 0x000410, "Member 'ANPCBug::OnCameraOutOfBounds' has a wrong offset!");
static_assert(offsetof(ANPCBug, NPCBugHudClass) == 0x000420, "Member 'ANPCBug::NPCBugHudClass' has a wrong offset!");
static_assert(offsetof(ANPCBug, VictimEffectClass) == 0x000428, "Member 'ANPCBug::VictimEffectClass' has a wrong offset!");
static_assert(offsetof(ANPCBug, VictimEffectActor) == 0x000430, "Member 'ANPCBug::VictimEffectActor' has a wrong offset!");
static_assert(offsetof(ANPCBug, NPCBugHud) == 0x000438, "Member 'ANPCBug::NPCBugHud' has a wrong offset!");
static_assert(offsetof(ANPCBug, CurrentVictimEffect) == 0x000440, "Member 'ANPCBug::CurrentVictimEffect' has a wrong offset!");
static_assert(offsetof(ANPCBug, CurrentVictim) == 0x000448, "Member 'ANPCBug::CurrentVictim' has a wrong offset!");
static_assert(offsetof(ANPCBug, OutOfBoundsActor) == 0x000450, "Member 'ANPCBug::OutOfBoundsActor' has a wrong offset!");
static_assert(offsetof(ANPCBug, SpyVictim) == 0x000458, "Member 'ANPCBug::SpyVictim' has a wrong offset!");
static_assert(offsetof(ANPCBug, bUseCamera3P) == 0x000460, "Member 'ANPCBug::bUseCamera3P' has a wrong offset!");

// Class DeceiveInc.DiUserBooleanSettingWidget
// 0x0000 (0x02B0 - 0x02B0)
class UDiUserBooleanSettingWidget final : public UDiUserSettingWidget
{
public:
	void ApplyNewSettingValue(bool bNewSettingValue);

	bool GetSettingValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiUserBooleanSettingWidget">();
	}
	static class UDiUserBooleanSettingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiUserBooleanSettingWidget>();
	}
};
static_assert(alignof(UDiUserBooleanSettingWidget) == 0x000008, "Wrong alignment on UDiUserBooleanSettingWidget");
static_assert(sizeof(UDiUserBooleanSettingWidget) == 0x0002B0, "Wrong size on UDiUserBooleanSettingWidget");

// Class DeceiveInc.DiUserIntegerSettingWidget
// 0x0000 (0x02B0 - 0x02B0)
class UDiUserIntegerSettingWidget final : public UDiUserSettingWidget
{
public:
	void ApplyNewSettingValue(int32 NewSettingValue);

	int32 GetSettingValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiUserIntegerSettingWidget">();
	}
	static class UDiUserIntegerSettingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiUserIntegerSettingWidget>();
	}
};
static_assert(alignof(UDiUserIntegerSettingWidget) == 0x000008, "Wrong alignment on UDiUserIntegerSettingWidget");
static_assert(sizeof(UDiUserIntegerSettingWidget) == 0x0002B0, "Wrong size on UDiUserIntegerSettingWidget");

// Class DeceiveInc.NPCInteraction
// 0x0030 (0x0058 - 0x0028)
class UNPCInteraction : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCInteraction">();
	}
	static class UNPCInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCInteraction>();
	}
};
static_assert(alignof(UNPCInteraction) == 0x000008, "Wrong alignment on UNPCInteraction");
static_assert(sizeof(UNPCInteraction) == 0x000058, "Wrong size on UNPCInteraction");

// Class DeceiveInc.DeadNPCInteraction
// 0x0008 (0x0060 - 0x0058)
class UDeadNPCInteraction final : public UNPCInteraction
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeadNPCInteraction">();
	}
	static class UDeadNPCInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeadNPCInteraction>();
	}
};
static_assert(alignof(UDeadNPCInteraction) == 0x000008, "Wrong alignment on UDeadNPCInteraction");
static_assert(sizeof(UDeadNPCInteraction) == 0x000060, "Wrong size on UDeadNPCInteraction");

// Class DeceiveInc.DiUserFloatSettingWidget
// 0x0000 (0x02B0 - 0x02B0)
class UDiUserFloatSettingWidget final : public UDiUserSettingWidget
{
public:
	void ApplyNewSettingValue(float NewSettingValue);

	float GetSettingValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiUserFloatSettingWidget">();
	}
	static class UDiUserFloatSettingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiUserFloatSettingWidget>();
	}
};
static_assert(alignof(UDiUserFloatSettingWidget) == 0x000008, "Wrong alignment on UDiUserFloatSettingWidget");
static_assert(sizeof(UDiUserFloatSettingWidget) == 0x0002B0, "Wrong size on UDiUserFloatSettingWidget");

// Class DeceiveInc.DiUserStringSettingWidget
// 0x0000 (0x02B0 - 0x02B0)
class UDiUserStringSettingWidget final : public UDiUserSettingWidget
{
public:
	void ApplyNewSettingValue(const class FString& NewSettingValue);

	class FString GetSettingValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiUserStringSettingWidget">();
	}
	static class UDiUserStringSettingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiUserStringSettingWidget>();
	}
};
static_assert(alignof(UDiUserStringSettingWidget) == 0x000008, "Wrong alignment on UDiUserStringSettingWidget");
static_assert(sizeof(UDiUserStringSettingWidget) == 0x0002B0, "Wrong size on UDiUserStringSettingWidget");

// Class DeceiveInc.NPCContainerInteraction
// 0x0008 (0x0060 - 0x0058)
class UNPCContainerInteraction final : public UNPCInteraction
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCContainerInteraction">();
	}
	static class UNPCContainerInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCContainerInteraction>();
	}
};
static_assert(alignof(UNPCContainerInteraction) == 0x000008, "Wrong alignment on UNPCContainerInteraction");
static_assert(sizeof(UNPCContainerInteraction) == 0x000060, "Wrong size on UNPCContainerInteraction");

// Class DeceiveInc.DiUserWidgetInterface
// 0x0000 (0x0028 - 0x0028)
class IDiUserWidgetInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiUserWidgetInterface">();
	}
	static class IDiUserWidgetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDiUserWidgetInterface>();
	}
};
static_assert(alignof(IDiUserWidgetInterface) == 0x000008, "Wrong alignment on IDiUserWidgetInterface");
static_assert(sizeof(IDiUserWidgetInterface) == 0x000028, "Wrong size on IDiUserWidgetInterface");

// Class DeceiveInc.NPCBehaviorScared
// 0x0000 (0x00C0 - 0x00C0)
class UNPCBehaviorScared final : public UNPCBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCBehaviorScared">();
	}
	static class UNPCBehaviorScared* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCBehaviorScared>();
	}
};
static_assert(alignof(UNPCBehaviorScared) == 0x000008, "Wrong alignment on UNPCBehaviorScared");
static_assert(sizeof(UNPCBehaviorScared) == 0x0000C0, "Wrong size on UNPCBehaviorScared");

// Class DeceiveInc.WALCDataHolder
// 0x0000 (0x0220 - 0x0220)
class AWALCDataHolder final : public AInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WALCDataHolder">();
	}
	static class AWALCDataHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWALCDataHolder>();
	}
};
static_assert(alignof(AWALCDataHolder) == 0x000008, "Wrong alignment on AWALCDataHolder");
static_assert(sizeof(AWALCDataHolder) == 0x000220, "Wrong size on AWALCDataHolder");

// Class DeceiveInc.NPCInteractionComponent
// 0x0080 (0x0280 - 0x0200)
#pragma pack(push, 0x1)
class alignas(0x10) UNPCInteractionComponent : public USceneComponent
{
public:
	bool                                          bLookingTowardInteract;                            // 0x01F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnNPCInteractionStart;                             // 0x0200(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNPCInteractionEnd;                               // 0x0210(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   InteractAnimID;                                    // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENPCInteractionPositioning                    Positioning;                                       // 0x0228(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlwaysDisabled;                                   // 0x0229(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceOnlyOneInteracter;                           // 0x022A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22B[0x5];                                      // 0x022B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableComponent*                 InteractableComp;                                  // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        StandPoint;                                        // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        PartOfRoomCRC;                                     // 0x0240(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        ToReachRoomCells;                                  // 0x0248(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                          bNoValidCellInRange;                               // 0x0258(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bObstructed;                                       // 0x0259(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25A[0xE];                                      // 0x025A(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	class UGenericNPCInteraction*                 Interaction;                                       // 0x0268(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USecurityLevelConditionComponent*       SecurityLevelCondition;                            // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class ANPCCharacter* GetInteractingNPC();
	class UAnimSequence* GetWatchingPlayerDisguiseAnimationLoop();
	void HandleDisableBySpawned();
	void OnMimicPositioned();
	void OnMimicVisibilityChange(bool bVisibleIn);
	void OnPlayerInteractComplete(class UInteracterComponent* InteracterIn, class UInteractableComponent* InteractableIn);
	void OnPostInitRooms(class UWorld* World);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCInteractionComponent">();
	}
	static class UNPCInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCInteractionComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UNPCInteractionComponent) == 0x000010, "Wrong alignment on UNPCInteractionComponent");
static_assert(sizeof(UNPCInteractionComponent) == 0x000280, "Wrong size on UNPCInteractionComponent");
static_assert(offsetof(UNPCInteractionComponent, bLookingTowardInteract) == 0x0001F8, "Member 'UNPCInteractionComponent::bLookingTowardInteract' has a wrong offset!");
static_assert(offsetof(UNPCInteractionComponent, OnNPCInteractionStart) == 0x000200, "Member 'UNPCInteractionComponent::OnNPCInteractionStart' has a wrong offset!");
static_assert(offsetof(UNPCInteractionComponent, OnNPCInteractionEnd) == 0x000210, "Member 'UNPCInteractionComponent::OnNPCInteractionEnd' has a wrong offset!");
static_assert(offsetof(UNPCInteractionComponent, InteractAnimID) == 0x000220, "Member 'UNPCInteractionComponent::InteractAnimID' has a wrong offset!");
static_assert(offsetof(UNPCInteractionComponent, Positioning) == 0x000228, "Member 'UNPCInteractionComponent::Positioning' has a wrong offset!");
static_assert(offsetof(UNPCInteractionComponent, bAlwaysDisabled) == 0x000229, "Member 'UNPCInteractionComponent::bAlwaysDisabled' has a wrong offset!");
static_assert(offsetof(UNPCInteractionComponent, bForceOnlyOneInteracter) == 0x00022A, "Member 'UNPCInteractionComponent::bForceOnlyOneInteracter' has a wrong offset!");
static_assert(offsetof(UNPCInteractionComponent, InteractableComp) == 0x000230, "Member 'UNPCInteractionComponent::InteractableComp' has a wrong offset!");
static_assert(offsetof(UNPCInteractionComponent, StandPoint) == 0x000238, "Member 'UNPCInteractionComponent::StandPoint' has a wrong offset!");
static_assert(offsetof(UNPCInteractionComponent, PartOfRoomCRC) == 0x000240, "Member 'UNPCInteractionComponent::PartOfRoomCRC' has a wrong offset!");
static_assert(offsetof(UNPCInteractionComponent, ToReachRoomCells) == 0x000248, "Member 'UNPCInteractionComponent::ToReachRoomCells' has a wrong offset!");
static_assert(offsetof(UNPCInteractionComponent, bNoValidCellInRange) == 0x000258, "Member 'UNPCInteractionComponent::bNoValidCellInRange' has a wrong offset!");
static_assert(offsetof(UNPCInteractionComponent, bObstructed) == 0x000259, "Member 'UNPCInteractionComponent::bObstructed' has a wrong offset!");
static_assert(offsetof(UNPCInteractionComponent, Interaction) == 0x000268, "Member 'UNPCInteractionComponent::Interaction' has a wrong offset!");
static_assert(offsetof(UNPCInteractionComponent, SecurityLevelCondition) == 0x000270, "Member 'UNPCInteractionComponent::SecurityLevelCondition' has a wrong offset!");

// Class DeceiveInc.NPCConversationComponent
// 0x0030 (0x02B0 - 0x0280)
class UNPCConversationComponent final : public UNPCInteractionComponent
{
public:
	int32                                         MaxNPCInConversation;                              // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnConversationNewTalkingNPC;                       // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ANPCCharacter*                          TalkingNPC;                                        // 0x0290(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsConversationActive;                             // 0x0298(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299[0x17];                                     // 0x0299(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_TalkingNPC(class ANPCCharacter* PrevNPC);
	void OnTalkingTimerEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCConversationComponent">();
	}
	static class UNPCConversationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCConversationComponent>();
	}
};
static_assert(alignof(UNPCConversationComponent) == 0x000010, "Wrong alignment on UNPCConversationComponent");
static_assert(sizeof(UNPCConversationComponent) == 0x0002B0, "Wrong size on UNPCConversationComponent");
static_assert(offsetof(UNPCConversationComponent, MaxNPCInConversation) == 0x000278, "Member 'UNPCConversationComponent::MaxNPCInConversation' has a wrong offset!");
static_assert(offsetof(UNPCConversationComponent, OnConversationNewTalkingNPC) == 0x000280, "Member 'UNPCConversationComponent::OnConversationNewTalkingNPC' has a wrong offset!");
static_assert(offsetof(UNPCConversationComponent, TalkingNPC) == 0x000290, "Member 'UNPCConversationComponent::TalkingNPC' has a wrong offset!");
static_assert(offsetof(UNPCConversationComponent, bIsConversationActive) == 0x000298, "Member 'UNPCConversationComponent::bIsConversationActive' has a wrong offset!");

// Class DeceiveInc.DIWorldAsyncLoadCache
// 0x0068 (0x00A8 - 0x0040)
class UDIWorldAsyncLoadCache final : public UTickableWorldSubsystem
{
public:
	TArray<struct FDIPlayerStateCacheEntry>       PlayerStateCache;                                  // 0x0040(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         DataHolders;                                       // 0x0050(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_60[0x48];                                      // 0x0060(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIWorldAsyncLoadCache">();
	}
	static class UDIWorldAsyncLoadCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIWorldAsyncLoadCache>();
	}
};
static_assert(alignof(UDIWorldAsyncLoadCache) == 0x000008, "Wrong alignment on UDIWorldAsyncLoadCache");
static_assert(sizeof(UDIWorldAsyncLoadCache) == 0x0000A8, "Wrong size on UDIWorldAsyncLoadCache");
static_assert(offsetof(UDIWorldAsyncLoadCache, PlayerStateCache) == 0x000040, "Member 'UDIWorldAsyncLoadCache::PlayerStateCache' has a wrong offset!");
static_assert(offsetof(UDIWorldAsyncLoadCache, DataHolders) == 0x000050, "Member 'UDIWorldAsyncLoadCache::DataHolders' has a wrong offset!");

// Class DeceiveInc.DIXpEventDataAsset
// 0x00B8 (0x00F0 - 0x0038)
class UDIXpEventDataAsset final : public UDIPrimaryDataAsset
{
public:
	class FString                                 CurrentActiveLimitedEventId;                       // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EDIXPEvent, struct FXpEventInfo>         XpEventsMap;                                       // 0x0048(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EDIXPEvent, struct FXpMultiplicatorEventInfo> XpMultiplicatorMap;                                // 0x0098(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         BondsPerEvent;                                     // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CreditsPerEvent;                                   // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIXpEventDataAsset">();
	}
	static class UDIXpEventDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIXpEventDataAsset>();
	}
};
static_assert(alignof(UDIXpEventDataAsset) == 0x000008, "Wrong alignment on UDIXpEventDataAsset");
static_assert(sizeof(UDIXpEventDataAsset) == 0x0000F0, "Wrong size on UDIXpEventDataAsset");
static_assert(offsetof(UDIXpEventDataAsset, CurrentActiveLimitedEventId) == 0x000038, "Member 'UDIXpEventDataAsset::CurrentActiveLimitedEventId' has a wrong offset!");
static_assert(offsetof(UDIXpEventDataAsset, XpEventsMap) == 0x000048, "Member 'UDIXpEventDataAsset::XpEventsMap' has a wrong offset!");
static_assert(offsetof(UDIXpEventDataAsset, XpMultiplicatorMap) == 0x000098, "Member 'UDIXpEventDataAsset::XpMultiplicatorMap' has a wrong offset!");
static_assert(offsetof(UDIXpEventDataAsset, BondsPerEvent) == 0x0000E8, "Member 'UDIXpEventDataAsset::BondsPerEvent' has a wrong offset!");
static_assert(offsetof(UDIXpEventDataAsset, CreditsPerEvent) == 0x0000EC, "Member 'UDIXpEventDataAsset::CreditsPerEvent' has a wrong offset!");

// Class DeceiveInc.ObjectSpawnComponent
// 0x0100 (0x0300 - 0x0200)
class UObjectSpawnComponent final : public USceneComponent
{
public:
	uint8                                         Pad_1F8[0x10];                                     // 0x01F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        ToReachRoomCells;                                  // 0x0208(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	class FString                                 ObjectSpawnPointType;                              // 0x0218(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableSpawnPoint;                                 // 0x0228(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x3];                                      // 0x0229(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        PartOfRoomCRC;                                     // 0x022C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint32>                                PartOfLevelAreaCRCs;                               // 0x0230(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	class AActor*                                 SpawnedObject;                                     // 0x0240(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPossibleObjectsToSpawn                CustomPossibleObjectsToSpawn;                      // 0x0248(0x0020)(Edit, NativeAccessSpecifierPublic)
	class FName                                   SingleObjSpawnGroup;                               // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_270[0x78];                                     // 0x0270(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnObjectSpawned;                                   // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bNeedRoomForSpawn;                                 // 0x02F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_SpawnedObject();
	void UpdateConnectedRoomsReference(class UWorld* World);

	class AActor* GetSpawnedObject() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectSpawnComponent">();
	}
	static class UObjectSpawnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectSpawnComponent>();
	}
};
static_assert(alignof(UObjectSpawnComponent) == 0x000010, "Wrong alignment on UObjectSpawnComponent");
static_assert(sizeof(UObjectSpawnComponent) == 0x000300, "Wrong size on UObjectSpawnComponent");
static_assert(offsetof(UObjectSpawnComponent, ToReachRoomCells) == 0x000208, "Member 'UObjectSpawnComponent::ToReachRoomCells' has a wrong offset!");
static_assert(offsetof(UObjectSpawnComponent, ObjectSpawnPointType) == 0x000218, "Member 'UObjectSpawnComponent::ObjectSpawnPointType' has a wrong offset!");
static_assert(offsetof(UObjectSpawnComponent, DisableSpawnPoint) == 0x000228, "Member 'UObjectSpawnComponent::DisableSpawnPoint' has a wrong offset!");
static_assert(offsetof(UObjectSpawnComponent, PartOfRoomCRC) == 0x00022C, "Member 'UObjectSpawnComponent::PartOfRoomCRC' has a wrong offset!");
static_assert(offsetof(UObjectSpawnComponent, PartOfLevelAreaCRCs) == 0x000230, "Member 'UObjectSpawnComponent::PartOfLevelAreaCRCs' has a wrong offset!");
static_assert(offsetof(UObjectSpawnComponent, SpawnedObject) == 0x000240, "Member 'UObjectSpawnComponent::SpawnedObject' has a wrong offset!");
static_assert(offsetof(UObjectSpawnComponent, CustomPossibleObjectsToSpawn) == 0x000248, "Member 'UObjectSpawnComponent::CustomPossibleObjectsToSpawn' has a wrong offset!");
static_assert(offsetof(UObjectSpawnComponent, SingleObjSpawnGroup) == 0x000268, "Member 'UObjectSpawnComponent::SingleObjSpawnGroup' has a wrong offset!");
static_assert(offsetof(UObjectSpawnComponent, OnObjectSpawned) == 0x0002E8, "Member 'UObjectSpawnComponent::OnObjectSpawned' has a wrong offset!");
static_assert(offsetof(UObjectSpawnComponent, bNeedRoomForSpawn) == 0x0002F8, "Member 'UObjectSpawnComponent::bNeedRoomForSpawn' has a wrong offset!");

// Class DeceiveInc.DoorClosedConditionComponent
// 0x0000 (0x00D0 - 0x00D0)
class UDoorClosedConditionComponent final : public UBaseConditionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorClosedConditionComponent">();
	}
	static class UDoorClosedConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoorClosedConditionComponent>();
	}
};
static_assert(alignof(UDoorClosedConditionComponent) == 0x000008, "Wrong alignment on UDoorClosedConditionComponent");
static_assert(sizeof(UDoorClosedConditionComponent) == 0x0000D0, "Wrong size on UDoorClosedConditionComponent");

// Class DeceiveInc.DoubleContainerActor
// 0x0058 (0x0360 - 0x0308)
class ADoubleContainerActor final : public ABaseContainerActor
{
public:
	class UMeshComponent*                         SecondaryMovablePart;                              // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       SecondaryRegistrationCollisionShapeComp;           // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 SecondaryInteractableComp;                         // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EContainerState                               SecondaryContainerState;                           // 0x0320(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_321[0x3];                                      // 0x0321(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecondaryOpenTime;                                 // 0x0324(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FContainerGeneratedData                SecondaryGeneratedData;                            // 0x0328(0x0020)(Edit, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNPCContainerInteraction*               SecondaryNPCInteraction;                           // 0x0350(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnSecondaryContainerClosing();
	void BP_OnSecondaryContainerOpening();
	void HandleSecondaryInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void OnRep_SecondaryContainerState(EContainerState PreviousState);
	void OnTimeToEnableSecondaryInteract();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoubleContainerActor">();
	}
	static class ADoubleContainerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADoubleContainerActor>();
	}
};
static_assert(alignof(ADoubleContainerActor) == 0x000008, "Wrong alignment on ADoubleContainerActor");
static_assert(sizeof(ADoubleContainerActor) == 0x000360, "Wrong size on ADoubleContainerActor");
static_assert(offsetof(ADoubleContainerActor, SecondaryMovablePart) == 0x000308, "Member 'ADoubleContainerActor::SecondaryMovablePart' has a wrong offset!");
static_assert(offsetof(ADoubleContainerActor, SecondaryRegistrationCollisionShapeComp) == 0x000310, "Member 'ADoubleContainerActor::SecondaryRegistrationCollisionShapeComp' has a wrong offset!");
static_assert(offsetof(ADoubleContainerActor, SecondaryInteractableComp) == 0x000318, "Member 'ADoubleContainerActor::SecondaryInteractableComp' has a wrong offset!");
static_assert(offsetof(ADoubleContainerActor, SecondaryContainerState) == 0x000320, "Member 'ADoubleContainerActor::SecondaryContainerState' has a wrong offset!");
static_assert(offsetof(ADoubleContainerActor, SecondaryOpenTime) == 0x000324, "Member 'ADoubleContainerActor::SecondaryOpenTime' has a wrong offset!");
static_assert(offsetof(ADoubleContainerActor, SecondaryGeneratedData) == 0x000328, "Member 'ADoubleContainerActor::SecondaryGeneratedData' has a wrong offset!");
static_assert(offsetof(ADoubleContainerActor, SecondaryNPCInteraction) == 0x000350, "Member 'ADoubleContainerActor::SecondaryNPCInteraction' has a wrong offset!");

// Class DeceiveInc.NPCMovementComponent
// 0x0140 (0x0450 - 0x0310)
class UNPCMovementComponent final : public UDICharacterMovementComponent
{
public:
	FMulticastInlineDelegateProperty_             OnJumpInAnimPlayRateChanged;                       // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     CustomNavigationQuerryFilter;                      // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidOffset;                                       // 0x0320(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChancesToRunOnNewPath;                             // 0x0324(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x128];                                    // 0x0328(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyAnimationStateJumpInChange(bool bJumpInStart);
	void OnCollisionBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnCollisionEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void SetJumpInAnimationSequence(class UAnimSequence* JumpInAnim);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCMovementComponent">();
	}
	static class UNPCMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCMovementComponent>();
	}
};
static_assert(alignof(UNPCMovementComponent) == 0x000010, "Wrong alignment on UNPCMovementComponent");
static_assert(sizeof(UNPCMovementComponent) == 0x000450, "Wrong size on UNPCMovementComponent");
static_assert(offsetof(UNPCMovementComponent, OnJumpInAnimPlayRateChanged) == 0x000308, "Member 'UNPCMovementComponent::OnJumpInAnimPlayRateChanged' has a wrong offset!");
static_assert(offsetof(UNPCMovementComponent, CustomNavigationQuerryFilter) == 0x000318, "Member 'UNPCMovementComponent::CustomNavigationQuerryFilter' has a wrong offset!");
static_assert(offsetof(UNPCMovementComponent, AvoidOffset) == 0x000320, "Member 'UNPCMovementComponent::AvoidOffset' has a wrong offset!");
static_assert(offsetof(UNPCMovementComponent, ChancesToRunOnNewPath) == 0x000324, "Member 'UNPCMovementComponent::ChancesToRunOnNewPath' has a wrong offset!");

// Class DeceiveInc.Drone
// 0x01B0 (0x0670 - 0x04C0)
class ADrone final : public ACharacter
{
public:
	uint8                                         Pad_4B8[0x30];                                     // 0x04B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 PingedActor;                                       // 0x04E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHealthComponent*                       HealthComponent;                                   // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       CameraComponent;                                   // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpringArmComponent*                    SpringArm;                                         // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       RegistrationCollisionShapeComp;                    // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 InteractableComp;                                  // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorAffectedComponent*                EMPAffectedComponent;                              // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorAffectedComponent*                ScramblerAffectedComp;                             // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerOwnedConditionComponent*         PlayerOwnedCondition;                              // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URayCastConditionComponent*             RayCastCondition;                                  // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteracterComponent*                   InteracterComponent;                               // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WeaponClass;                                       // 0x0540(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DroneHudAsset;                                     // 0x0568(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 DroneHudClass;                                     // 0x0590(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpDownSpeedRatio;                                  // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseTurnRate;                                      // 0x059C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseLookUpRate;                                    // 0x05A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostSpeed;                                        // 0x05A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADroneSpawnerWeapon*                    Weapon;                                            // 0x05A8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            DroneHud;                                          // 0x05B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   OriginalBody;                                      // 0x05B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InputContextPriority;                              // 0x05C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C4[0x4];                                      // 0x05C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADroneSpawnerWeapon*                    SpawnerTool;                                       // 0x05C8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDroneDestroyed;                                  // 0x05D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDroneTakeControl;                                // 0x05E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDroneReleaseControl;                             // 0x05F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDroneRoomChange;                                 // 0x0600(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         FlyingSpeed;                                       // 0x0610(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_614[0x4];                                      // 0x0614(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ARoomVolume*                            CurrentRoom;                                       // 0x0618(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_620[0x38];                                     // 0x0620(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         InteractsInRange;                                  // 0x0658(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_668[0x8];                                      // 0x0668(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroyDrone();
	uint8 GetFactionId();
	void HandleBooleanPlayerSettingChange(EPlayerSettingsType SettingType, bool NewValue);
	void HandleDeath(class AActor* DeadActor);
	void HandleEMPIsAffectedChanged(bool bIsAffected, class AActor* AffectedActor);
	void HandleFloatPlayerSettingChange(EPlayerSettingsType SettingType, float NewValue);
	void HandleInteractionCompleted(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void HandleIntPlayerSettingChange(EPlayerSettingsType SettingType, int32 NewValue);
	void HandleRecycleTimerEnd();
	void HandleScramblerIsAffectedChanged(bool bIsAffected, class AActor* AffectedActor);
	void LocalReleaseControl(class ASpy* OriginalSpy);
	void LocalTakeControl(class ASpy* OriginalSpy);
	void MulticastDestroy();
	void MulticastReleaseControl(class AController* Possesor);
	void MulticastTakeControl(class AController* Possesor);
	void NetMulticast_OnDroneDeath();
	void OnRep_FlyingSpeed();
	void OnRep_OriginalBody(class ASpy* OldValue);
	void OnRep_Spawner(class ADroneSpawnerWeapon* OldValue);
	void OnRep_Weapon(class ADroneSpawnerWeapon* OldValue);
	void RecycleServer();
	void ReleaseControl();
	void Server_SpawnPing(const struct FVector_NetQuantize& Position, class AActor* TargetActor, bool bUrgent, int32 RadialPingIndex);
	void ServerDestroyDrone();
	void ServerReleaseControl();
	void ServerUpdateSpeed(bool bIsSpeeding);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Drone">();
	}
	static class ADrone* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADrone>();
	}
};
static_assert(alignof(ADrone) == 0x000010, "Wrong alignment on ADrone");
static_assert(sizeof(ADrone) == 0x000670, "Wrong size on ADrone");
static_assert(offsetof(ADrone, PingedActor) == 0x0004E8, "Member 'ADrone::PingedActor' has a wrong offset!");
static_assert(offsetof(ADrone, HealthComponent) == 0x0004F0, "Member 'ADrone::HealthComponent' has a wrong offset!");
static_assert(offsetof(ADrone, CameraComponent) == 0x0004F8, "Member 'ADrone::CameraComponent' has a wrong offset!");
static_assert(offsetof(ADrone, SpringArm) == 0x000500, "Member 'ADrone::SpringArm' has a wrong offset!");
static_assert(offsetof(ADrone, RegistrationCollisionShapeComp) == 0x000508, "Member 'ADrone::RegistrationCollisionShapeComp' has a wrong offset!");
static_assert(offsetof(ADrone, InteractableComp) == 0x000510, "Member 'ADrone::InteractableComp' has a wrong offset!");
static_assert(offsetof(ADrone, EMPAffectedComponent) == 0x000518, "Member 'ADrone::EMPAffectedComponent' has a wrong offset!");
static_assert(offsetof(ADrone, ScramblerAffectedComp) == 0x000520, "Member 'ADrone::ScramblerAffectedComp' has a wrong offset!");
static_assert(offsetof(ADrone, PlayerOwnedCondition) == 0x000528, "Member 'ADrone::PlayerOwnedCondition' has a wrong offset!");
static_assert(offsetof(ADrone, RayCastCondition) == 0x000530, "Member 'ADrone::RayCastCondition' has a wrong offset!");
static_assert(offsetof(ADrone, InteracterComponent) == 0x000538, "Member 'ADrone::InteracterComponent' has a wrong offset!");
static_assert(offsetof(ADrone, WeaponClass) == 0x000540, "Member 'ADrone::WeaponClass' has a wrong offset!");
static_assert(offsetof(ADrone, DroneHudAsset) == 0x000568, "Member 'ADrone::DroneHudAsset' has a wrong offset!");
static_assert(offsetof(ADrone, DroneHudClass) == 0x000590, "Member 'ADrone::DroneHudClass' has a wrong offset!");
static_assert(offsetof(ADrone, UpDownSpeedRatio) == 0x000598, "Member 'ADrone::UpDownSpeedRatio' has a wrong offset!");
static_assert(offsetof(ADrone, BaseTurnRate) == 0x00059C, "Member 'ADrone::BaseTurnRate' has a wrong offset!");
static_assert(offsetof(ADrone, BaseLookUpRate) == 0x0005A0, "Member 'ADrone::BaseLookUpRate' has a wrong offset!");
static_assert(offsetof(ADrone, BoostSpeed) == 0x0005A4, "Member 'ADrone::BoostSpeed' has a wrong offset!");
static_assert(offsetof(ADrone, Weapon) == 0x0005A8, "Member 'ADrone::Weapon' has a wrong offset!");
static_assert(offsetof(ADrone, DroneHud) == 0x0005B0, "Member 'ADrone::DroneHud' has a wrong offset!");
static_assert(offsetof(ADrone, OriginalBody) == 0x0005B8, "Member 'ADrone::OriginalBody' has a wrong offset!");
static_assert(offsetof(ADrone, InputContextPriority) == 0x0005C0, "Member 'ADrone::InputContextPriority' has a wrong offset!");
static_assert(offsetof(ADrone, SpawnerTool) == 0x0005C8, "Member 'ADrone::SpawnerTool' has a wrong offset!");
static_assert(offsetof(ADrone, OnDroneDestroyed) == 0x0005D0, "Member 'ADrone::OnDroneDestroyed' has a wrong offset!");
static_assert(offsetof(ADrone, OnDroneTakeControl) == 0x0005E0, "Member 'ADrone::OnDroneTakeControl' has a wrong offset!");
static_assert(offsetof(ADrone, OnDroneReleaseControl) == 0x0005F0, "Member 'ADrone::OnDroneReleaseControl' has a wrong offset!");
static_assert(offsetof(ADrone, OnDroneRoomChange) == 0x000600, "Member 'ADrone::OnDroneRoomChange' has a wrong offset!");
static_assert(offsetof(ADrone, FlyingSpeed) == 0x000610, "Member 'ADrone::FlyingSpeed' has a wrong offset!");
static_assert(offsetof(ADrone, CurrentRoom) == 0x000618, "Member 'ADrone::CurrentRoom' has a wrong offset!");
static_assert(offsetof(ADrone, InteractsInRange) == 0x000658, "Member 'ADrone::InteractsInRange' has a wrong offset!");

// Class DeceiveInc.HitscanWeapon
// 0x00A8 (0x09B8 - 0x0910)
class AHitscanWeapon : public AProjectileWeapon
{
public:
	uint8                                         Pad_910[0x8];                                      // 0x0910(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EffectiveRange;                                    // 0x0918(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ImpactForce;                                       // 0x091C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Damage;                                            // 0x0920(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CriticalDamage;                                    // 0x0924(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LimbDamage;                                        // 0x0928(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Radius;                                            // 0x092C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DamageFalloffCurve;                                // 0x0930(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHitType                                      ForceHitType;                                      // 0x0938(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_939[0x7];                                      // 0x0939(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   FakeProjectileClass;                               // 0x0940(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ClientSideActorToSpawnOnImpactClass;               // 0x0968(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ServerSideActorToSpawnOnImpactClass;               // 0x0990(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitscanWeapon">();
	}
	static class AHitscanWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHitscanWeapon>();
	}
};
static_assert(alignof(AHitscanWeapon) == 0x000008, "Wrong alignment on AHitscanWeapon");
static_assert(sizeof(AHitscanWeapon) == 0x0009B8, "Wrong size on AHitscanWeapon");
static_assert(offsetof(AHitscanWeapon, EffectiveRange) == 0x000918, "Member 'AHitscanWeapon::EffectiveRange' has a wrong offset!");
static_assert(offsetof(AHitscanWeapon, ImpactForce) == 0x00091C, "Member 'AHitscanWeapon::ImpactForce' has a wrong offset!");
static_assert(offsetof(AHitscanWeapon, Damage) == 0x000920, "Member 'AHitscanWeapon::Damage' has a wrong offset!");
static_assert(offsetof(AHitscanWeapon, CriticalDamage) == 0x000924, "Member 'AHitscanWeapon::CriticalDamage' has a wrong offset!");
static_assert(offsetof(AHitscanWeapon, LimbDamage) == 0x000928, "Member 'AHitscanWeapon::LimbDamage' has a wrong offset!");
static_assert(offsetof(AHitscanWeapon, Radius) == 0x00092C, "Member 'AHitscanWeapon::Radius' has a wrong offset!");
static_assert(offsetof(AHitscanWeapon, DamageFalloffCurve) == 0x000930, "Member 'AHitscanWeapon::DamageFalloffCurve' has a wrong offset!");
static_assert(offsetof(AHitscanWeapon, ForceHitType) == 0x000938, "Member 'AHitscanWeapon::ForceHitType' has a wrong offset!");
static_assert(offsetof(AHitscanWeapon, FakeProjectileClass) == 0x000940, "Member 'AHitscanWeapon::FakeProjectileClass' has a wrong offset!");
static_assert(offsetof(AHitscanWeapon, ClientSideActorToSpawnOnImpactClass) == 0x000968, "Member 'AHitscanWeapon::ClientSideActorToSpawnOnImpactClass' has a wrong offset!");
static_assert(offsetof(AHitscanWeapon, ServerSideActorToSpawnOnImpactClass) == 0x000990, "Member 'AHitscanWeapon::ServerSideActorToSpawnOnImpactClass' has a wrong offset!");

// Class DeceiveInc.GenericNPCInteraction
// 0x0010 (0x0068 - 0x0058)
class UGenericNPCInteraction : public UNPCInteraction
{
public:
	class UNPCInteractionComponent*               InteractComponent;                                 // 0x0058(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericNPCInteraction">();
	}
	static class UGenericNPCInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericNPCInteraction>();
	}
};
static_assert(alignof(UGenericNPCInteraction) == 0x000008, "Wrong alignment on UGenericNPCInteraction");
static_assert(sizeof(UGenericNPCInteraction) == 0x000068, "Wrong size on UGenericNPCInteraction");
static_assert(offsetof(UGenericNPCInteraction, InteractComponent) == 0x000058, "Member 'UGenericNPCInteraction::InteractComponent' has a wrong offset!");

// Class DeceiveInc.NPCConversationInteraction
// 0x0028 (0x0090 - 0x0068)
class UNPCConversationInteraction final : public UGenericNPCInteraction
{
public:
	uint8                                         Pad_68[0x28];                                      // 0x0068(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCConversationInteraction">();
	}
	static class UNPCConversationInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCConversationInteraction>();
	}
};
static_assert(alignof(UNPCConversationInteraction) == 0x000008, "Wrong alignment on UNPCConversationInteraction");
static_assert(sizeof(UNPCConversationInteraction) == 0x000090, "Wrong size on UNPCConversationInteraction");

// Class DeceiveInc.DroneSpawnerWeapon
// 0x00E8 (0x0AA0 - 0x09B8)
class ADroneSpawnerWeapon final : public AHitscanWeapon
{
public:
	float                                         WallOffset;                                        // 0x09B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9BC[0x4];                                      // 0x09BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCooldownComponent*                     DartRespawnCooldown;                               // 0x09C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCooldownComponent*                     DroneRespawnCooldown;                              // 0x09C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ControlledDronePrimaryActionText;                  // 0x09D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ControlledDroneSecondaryActionText;                // 0x09E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   PoudrierPrimaryActionText;                         // 0x0A00(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   PoudrierSecondaryActionText;                       // 0x0A18(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UCooldownComponent*                     RuntimeDartRespawnCooldown;                        // 0x0A30(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCooldownComponent*                     RuntimeDroneRespawnCooldown;                       // 0x0A38(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DroneClass;                                        // 0x0A40(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecycleTime;                                       // 0x0A68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DroneReticuleHudName;                              // 0x0A6C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DronesOnStart;                                     // 0x0A74(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADrone*                                 SpawnedDrone;                                      // 0x0A78(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A80[0x20];                                     // 0x0A80(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetDartCooldownRatio();
	void HandleDartCooldownChange(bool bOnCooldown);
	void HandleDroneCooldownChange(bool bOnCooldown);
	void HandleRecycleTimerEnd();
	void HandleResourceChanged(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 Amount);
	void OnRep_NewSpawnedDrone();
	void RecycleServer();
	void ServerDestroyDrone(bool bDestroyed);
	void ServerSpawnDrone();
	void ServerStartDroneRegen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DroneSpawnerWeapon">();
	}
	static class ADroneSpawnerWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADroneSpawnerWeapon>();
	}
};
static_assert(alignof(ADroneSpawnerWeapon) == 0x000008, "Wrong alignment on ADroneSpawnerWeapon");
static_assert(sizeof(ADroneSpawnerWeapon) == 0x000AA0, "Wrong size on ADroneSpawnerWeapon");
static_assert(offsetof(ADroneSpawnerWeapon, WallOffset) == 0x0009B8, "Member 'ADroneSpawnerWeapon::WallOffset' has a wrong offset!");
static_assert(offsetof(ADroneSpawnerWeapon, DartRespawnCooldown) == 0x0009C0, "Member 'ADroneSpawnerWeapon::DartRespawnCooldown' has a wrong offset!");
static_assert(offsetof(ADroneSpawnerWeapon, DroneRespawnCooldown) == 0x0009C8, "Member 'ADroneSpawnerWeapon::DroneRespawnCooldown' has a wrong offset!");
static_assert(offsetof(ADroneSpawnerWeapon, ControlledDronePrimaryActionText) == 0x0009D0, "Member 'ADroneSpawnerWeapon::ControlledDronePrimaryActionText' has a wrong offset!");
static_assert(offsetof(ADroneSpawnerWeapon, ControlledDroneSecondaryActionText) == 0x0009E8, "Member 'ADroneSpawnerWeapon::ControlledDroneSecondaryActionText' has a wrong offset!");
static_assert(offsetof(ADroneSpawnerWeapon, PoudrierPrimaryActionText) == 0x000A00, "Member 'ADroneSpawnerWeapon::PoudrierPrimaryActionText' has a wrong offset!");
static_assert(offsetof(ADroneSpawnerWeapon, PoudrierSecondaryActionText) == 0x000A18, "Member 'ADroneSpawnerWeapon::PoudrierSecondaryActionText' has a wrong offset!");
static_assert(offsetof(ADroneSpawnerWeapon, RuntimeDartRespawnCooldown) == 0x000A30, "Member 'ADroneSpawnerWeapon::RuntimeDartRespawnCooldown' has a wrong offset!");
static_assert(offsetof(ADroneSpawnerWeapon, RuntimeDroneRespawnCooldown) == 0x000A38, "Member 'ADroneSpawnerWeapon::RuntimeDroneRespawnCooldown' has a wrong offset!");
static_assert(offsetof(ADroneSpawnerWeapon, DroneClass) == 0x000A40, "Member 'ADroneSpawnerWeapon::DroneClass' has a wrong offset!");
static_assert(offsetof(ADroneSpawnerWeapon, RecycleTime) == 0x000A68, "Member 'ADroneSpawnerWeapon::RecycleTime' has a wrong offset!");
static_assert(offsetof(ADroneSpawnerWeapon, DroneReticuleHudName) == 0x000A6C, "Member 'ADroneSpawnerWeapon::DroneReticuleHudName' has a wrong offset!");
static_assert(offsetof(ADroneSpawnerWeapon, DronesOnStart) == 0x000A74, "Member 'ADroneSpawnerWeapon::DronesOnStart' has a wrong offset!");
static_assert(offsetof(ADroneSpawnerWeapon, SpawnedDrone) == 0x000A78, "Member 'ADroneSpawnerWeapon::SpawnedDrone' has a wrong offset!");

// Class DeceiveInc.EffectVictim
// 0x0000 (0x0028 - 0x0028)
class IEffectVictim final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectVictim">();
	}
	static class IEffectVictim* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEffectVictim>();
	}
};
static_assert(alignof(IEffectVictim) == 0x000008, "Wrong alignment on IEffectVictim");
static_assert(sizeof(IEffectVictim) == 0x000028, "Wrong size on IEffectVictim");

// Class DeceiveInc.EncounterDataAsset
// 0x0060 (0x0098 - 0x0038)
class UEncounterDataAsset final : public UDIPrimaryDataAsset
{
public:
	int32                                         AssignRange;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AssignHeight;                                      // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxGuards;                                         // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpyLostDuration;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleRatioMaxTime;                                  // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkRatioMaxTime;                                  // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunRatioMaxTime;                                   // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAccuracyHealthThreshold>       AccuracyHealthMultipliers;                         // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DecayMaxTime;                                      // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RatioValueFromDangerSpotted;                       // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RatioValueFromDangerSource;                        // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetLostTTL;                                     // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ByStanderMaxDistance;                              // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowShooting;                                    // 0x007C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowMelee;                                       // 0x007D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E[0x2];                                       // 0x007E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHeatLevelEncounterData>        HeatLevelData;                                     // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAssignCloseRoomToEncounter;                       // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAssignNearbyGuardsToEncounter;                    // 0x0091(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EncounterDataAsset">();
	}
	static class UEncounterDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEncounterDataAsset>();
	}
};
static_assert(alignof(UEncounterDataAsset) == 0x000008, "Wrong alignment on UEncounterDataAsset");
static_assert(sizeof(UEncounterDataAsset) == 0x000098, "Wrong size on UEncounterDataAsset");
static_assert(offsetof(UEncounterDataAsset, AssignRange) == 0x000038, "Member 'UEncounterDataAsset::AssignRange' has a wrong offset!");
static_assert(offsetof(UEncounterDataAsset, AssignHeight) == 0x00003C, "Member 'UEncounterDataAsset::AssignHeight' has a wrong offset!");
static_assert(offsetof(UEncounterDataAsset, MaxGuards) == 0x000040, "Member 'UEncounterDataAsset::MaxGuards' has a wrong offset!");
static_assert(offsetof(UEncounterDataAsset, Duration) == 0x000044, "Member 'UEncounterDataAsset::Duration' has a wrong offset!");
static_assert(offsetof(UEncounterDataAsset, SpyLostDuration) == 0x000048, "Member 'UEncounterDataAsset::SpyLostDuration' has a wrong offset!");
static_assert(offsetof(UEncounterDataAsset, IdleRatioMaxTime) == 0x00004C, "Member 'UEncounterDataAsset::IdleRatioMaxTime' has a wrong offset!");
static_assert(offsetof(UEncounterDataAsset, WalkRatioMaxTime) == 0x000050, "Member 'UEncounterDataAsset::WalkRatioMaxTime' has a wrong offset!");
static_assert(offsetof(UEncounterDataAsset, RunRatioMaxTime) == 0x000054, "Member 'UEncounterDataAsset::RunRatioMaxTime' has a wrong offset!");
static_assert(offsetof(UEncounterDataAsset, AccuracyHealthMultipliers) == 0x000058, "Member 'UEncounterDataAsset::AccuracyHealthMultipliers' has a wrong offset!");
static_assert(offsetof(UEncounterDataAsset, DecayMaxTime) == 0x000068, "Member 'UEncounterDataAsset::DecayMaxTime' has a wrong offset!");
static_assert(offsetof(UEncounterDataAsset, RatioValueFromDangerSpotted) == 0x00006C, "Member 'UEncounterDataAsset::RatioValueFromDangerSpotted' has a wrong offset!");
static_assert(offsetof(UEncounterDataAsset, RatioValueFromDangerSource) == 0x000070, "Member 'UEncounterDataAsset::RatioValueFromDangerSource' has a wrong offset!");
static_assert(offsetof(UEncounterDataAsset, TargetLostTTL) == 0x000074, "Member 'UEncounterDataAsset::TargetLostTTL' has a wrong offset!");
static_assert(offsetof(UEncounterDataAsset, ByStanderMaxDistance) == 0x000078, "Member 'UEncounterDataAsset::ByStanderMaxDistance' has a wrong offset!");
static_assert(offsetof(UEncounterDataAsset, bAllowShooting) == 0x00007C, "Member 'UEncounterDataAsset::bAllowShooting' has a wrong offset!");
static_assert(offsetof(UEncounterDataAsset, bAllowMelee) == 0x00007D, "Member 'UEncounterDataAsset::bAllowMelee' has a wrong offset!");
static_assert(offsetof(UEncounterDataAsset, HeatLevelData) == 0x000080, "Member 'UEncounterDataAsset::HeatLevelData' has a wrong offset!");
static_assert(offsetof(UEncounterDataAsset, bAssignCloseRoomToEncounter) == 0x000090, "Member 'UEncounterDataAsset::bAssignCloseRoomToEncounter' has a wrong offset!");
static_assert(offsetof(UEncounterDataAsset, bAssignNearbyGuardsToEncounter) == 0x000091, "Member 'UEncounterDataAsset::bAssignNearbyGuardsToEncounter' has a wrong offset!");

// Class DeceiveInc.Encounter
// 0x00B0 (0x00D8 - 0x0028)
class UEncounter final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UEncounterParticipant*>          AssignedToResolve;                                 // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UEncounterParticipant*>          ByStanders;                                        // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UEncounterParticipant*>          AwareNotParticipating;                             // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UEncounterParticipant*>          Fakers;                                            // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x40];                                      // 0x0098(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Encounter">();
	}
	static class UEncounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEncounter>();
	}
};
static_assert(alignof(UEncounter) == 0x000008, "Wrong alignment on UEncounter");
static_assert(sizeof(UEncounter) == 0x0000D8, "Wrong size on UEncounter");
static_assert(offsetof(UEncounter, AssignedToResolve) == 0x000058, "Member 'UEncounter::AssignedToResolve' has a wrong offset!");
static_assert(offsetof(UEncounter, ByStanders) == 0x000068, "Member 'UEncounter::ByStanders' has a wrong offset!");
static_assert(offsetof(UEncounter, AwareNotParticipating) == 0x000078, "Member 'UEncounter::AwareNotParticipating' has a wrong offset!");
static_assert(offsetof(UEncounter, Fakers) == 0x000088, "Member 'UEncounter::Fakers' has a wrong offset!");

// Class DeceiveInc.EncountersDebugger
// 0x0010 (0x0230 - 0x0220)
class AEncountersDebugger final : public AActor
{
public:
	TArray<struct FDebugEncounterReplicationData> DebugEncounterData;                                // 0x0220(0x0010)(Net, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EncountersDebugger">();
	}
	static class AEncountersDebugger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEncountersDebugger>();
	}
};
static_assert(alignof(AEncountersDebugger) == 0x000008, "Wrong alignment on AEncountersDebugger");
static_assert(sizeof(AEncountersDebugger) == 0x000230, "Wrong size on AEncountersDebugger");
static_assert(offsetof(AEncountersDebugger, DebugEncounterData) == 0x000220, "Member 'AEncountersDebugger::DebugEncounterData' has a wrong offset!");

// Class DeceiveInc.ExtractionInteractableActor
// 0x01B8 (0x0470 - 0x02B8)
class AExtractionInteractableActor final : public ABaseInteractableActor
{
public:
	float                                         ZoneTimeToExtract;                                 // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OutOfZoneDecayRate;                                // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableLegacyInteract;                             // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ExtractionRatios;                                  // 0x02C8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         ExtractionLMSMultiplier;                           // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASpy*                                   CurrentCarrier;                                    // 0x02E0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ASpy*>                           EnemiesInZone;                                     // 0x02E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class ASpy*>                           TeamMatesInZone;                                   // 0x02F8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bObjectiveInPlay;                                  // 0x0308(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCarrierInZone;                                    // 0x0309(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExtractBLocked;                                   // 0x030A(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30B[0x1];                                      // 0x030B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CarrierTimeInZone;                                 // 0x030C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EExtractionActorReplicatedState               ExtractionActorReplicatedState;                    // 0x0310(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnExtractionZoneEntered;                           // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnExtractionZoneExited;                            // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnExtractionZoneBlocked;                           // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnExtractionZoneResumed;                           // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UBoxComponent*                          MeshObstacleVolume;                                // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   ExtractZoneComp2;                                  // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0x10];                                     // 0x0368(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStartArrival;                                    // 0x0378(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnArrivedAtDestination;                            // 0x0388(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         TimeToStartArrival;                                // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToStartDangerEvent;                            // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ImpulseValue;                                      // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ImpulseZValue;                                     // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeBeforeOtherImpulse;                            // 0x03A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdditionnalDistanceToMoveActor;                    // 0x03AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NormalizedValueToConsiderOnTop;                    // 0x03B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NormalizedValueToConsiderUnder;                    // 0x03B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             ImpulseCollisionChannel;                           // 0x03B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B9[0x3];                                      // 0x03B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DetectionBoxSizeOverride;                          // 0x03BC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C8[0x48];                                     // 0x03C8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       SecondaryRegistrationCollisionShapeComp;           // 0x0410(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 SecondaryInteractableComp;                         // 0x0418(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AActor*, struct FCachedImpulseData> ImpulsedList;                                      // 0x0420(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void BP_ExfilDisable();
	void BP_ExfilInitialize();
	void BP_PlayerExtractedServer(class AActor* Player);
	void BP_RequestLeave();
	float GetExtractionRatio();
	void HandleComponentOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void HandleComponentOverlapStart(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void HandleExfilArrivedEvent(class UExtractionArrivedPhaseInfo* PhaseInfo);
	void HandleExfilArrivingEvent(class UExtractionArrivingPhaseInfo* PhaseInfo);
	void HandleExfilMovedEvent();
	void HandleGamePhaseTick(int32 RemainingTime);
	void HandleObjectiveDropped(class ASpy* Carrier);
	void HandleObjectivePickedUp(class ASpy* Carrier);
	void HandleRequestLeave();
	void OnExfilArrived();
	void OnExfilArriving();
	void OnExfilDisable();
	void OnExfilInitialize(bool bArriveNow);
	void OnRep_CarrierInZone();
	void OnRep_ExtractBlocked();
	void OnRep_ExtractionActorReplicatedState(EExtractionActorReplicatedState PrevState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExtractionInteractableActor">();
	}
	static class AExtractionInteractableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AExtractionInteractableActor>();
	}
};
static_assert(alignof(AExtractionInteractableActor) == 0x000008, "Wrong alignment on AExtractionInteractableActor");
static_assert(sizeof(AExtractionInteractableActor) == 0x000470, "Wrong size on AExtractionInteractableActor");
static_assert(offsetof(AExtractionInteractableActor, ZoneTimeToExtract) == 0x0002B8, "Member 'AExtractionInteractableActor::ZoneTimeToExtract' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, OutOfZoneDecayRate) == 0x0002BC, "Member 'AExtractionInteractableActor::OutOfZoneDecayRate' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, bEnableLegacyInteract) == 0x0002C0, "Member 'AExtractionInteractableActor::bEnableLegacyInteract' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, ExtractionRatios) == 0x0002C8, "Member 'AExtractionInteractableActor::ExtractionRatios' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, ExtractionLMSMultiplier) == 0x0002D8, "Member 'AExtractionInteractableActor::ExtractionLMSMultiplier' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, CurrentCarrier) == 0x0002E0, "Member 'AExtractionInteractableActor::CurrentCarrier' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, EnemiesInZone) == 0x0002E8, "Member 'AExtractionInteractableActor::EnemiesInZone' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, TeamMatesInZone) == 0x0002F8, "Member 'AExtractionInteractableActor::TeamMatesInZone' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, bObjectiveInPlay) == 0x000308, "Member 'AExtractionInteractableActor::bObjectiveInPlay' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, bCarrierInZone) == 0x000309, "Member 'AExtractionInteractableActor::bCarrierInZone' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, bExtractBLocked) == 0x00030A, "Member 'AExtractionInteractableActor::bExtractBLocked' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, CarrierTimeInZone) == 0x00030C, "Member 'AExtractionInteractableActor::CarrierTimeInZone' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, ExtractionActorReplicatedState) == 0x000310, "Member 'AExtractionInteractableActor::ExtractionActorReplicatedState' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, OnExtractionZoneEntered) == 0x000318, "Member 'AExtractionInteractableActor::OnExtractionZoneEntered' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, OnExtractionZoneExited) == 0x000328, "Member 'AExtractionInteractableActor::OnExtractionZoneExited' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, OnExtractionZoneBlocked) == 0x000338, "Member 'AExtractionInteractableActor::OnExtractionZoneBlocked' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, OnExtractionZoneResumed) == 0x000348, "Member 'AExtractionInteractableActor::OnExtractionZoneResumed' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, MeshObstacleVolume) == 0x000358, "Member 'AExtractionInteractableActor::MeshObstacleVolume' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, ExtractZoneComp2) == 0x000360, "Member 'AExtractionInteractableActor::ExtractZoneComp2' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, OnStartArrival) == 0x000378, "Member 'AExtractionInteractableActor::OnStartArrival' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, OnArrivedAtDestination) == 0x000388, "Member 'AExtractionInteractableActor::OnArrivedAtDestination' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, TimeToStartArrival) == 0x000398, "Member 'AExtractionInteractableActor::TimeToStartArrival' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, TimeToStartDangerEvent) == 0x00039C, "Member 'AExtractionInteractableActor::TimeToStartDangerEvent' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, ImpulseValue) == 0x0003A0, "Member 'AExtractionInteractableActor::ImpulseValue' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, ImpulseZValue) == 0x0003A4, "Member 'AExtractionInteractableActor::ImpulseZValue' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, TimeBeforeOtherImpulse) == 0x0003A8, "Member 'AExtractionInteractableActor::TimeBeforeOtherImpulse' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, AdditionnalDistanceToMoveActor) == 0x0003AC, "Member 'AExtractionInteractableActor::AdditionnalDistanceToMoveActor' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, NormalizedValueToConsiderOnTop) == 0x0003B0, "Member 'AExtractionInteractableActor::NormalizedValueToConsiderOnTop' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, NormalizedValueToConsiderUnder) == 0x0003B4, "Member 'AExtractionInteractableActor::NormalizedValueToConsiderUnder' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, ImpulseCollisionChannel) == 0x0003B8, "Member 'AExtractionInteractableActor::ImpulseCollisionChannel' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, DetectionBoxSizeOverride) == 0x0003BC, "Member 'AExtractionInteractableActor::DetectionBoxSizeOverride' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, SecondaryRegistrationCollisionShapeComp) == 0x000410, "Member 'AExtractionInteractableActor::SecondaryRegistrationCollisionShapeComp' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, SecondaryInteractableComp) == 0x000418, "Member 'AExtractionInteractableActor::SecondaryInteractableComp' has a wrong offset!");
static_assert(offsetof(AExtractionInteractableActor, ImpulsedList) == 0x000420, "Member 'AExtractionInteractableActor::ImpulsedList' has a wrong offset!");

// Class DeceiveInc.FacingWidgetComponent
// 0x0010 (0x05C0 - 0x05B0)
class UFacingWidgetComponent : public UDIWidgetComponent
{
public:
	float                                         WidgetRotationSpeed;                               // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B4[0xC];                                      // 0x05B4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FacingWidgetComponent">();
	}
	static class UFacingWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFacingWidgetComponent>();
	}
};
static_assert(alignof(UFacingWidgetComponent) == 0x000010, "Wrong alignment on UFacingWidgetComponent");
static_assert(sizeof(UFacingWidgetComponent) == 0x0005C0, "Wrong size on UFacingWidgetComponent");
static_assert(offsetof(UFacingWidgetComponent, WidgetRotationSpeed) == 0x0005B0, "Member 'UFacingWidgetComponent::WidgetRotationSpeed' has a wrong offset!");

// Class DeceiveInc.FallDamageComponent
// 0x0018 (0x00C8 - 0x00B0)
class UFallDamageComponent final : public UActorComponent
{
public:
	TArray<struct FFallDamageStep>                FallDamageSteps;                                   // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallDamageComponent">();
	}
	static class UFallDamageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFallDamageComponent>();
	}
};
static_assert(alignof(UFallDamageComponent) == 0x000008, "Wrong alignment on UFallDamageComponent");
static_assert(sizeof(UFallDamageComponent) == 0x0000C8, "Wrong size on UFallDamageComponent");
static_assert(offsetof(UFallDamageComponent, FallDamageSteps) == 0x0000B0, "Member 'UFallDamageComponent::FallDamageSteps' has a wrong offset!");

// Class DeceiveInc.GadgetData
// 0x0110 (0x0148 - 0x0038)
class UGadgetData final : public UDIPrimaryDataAsset
{
public:
	class FText                                   GadgetName;                                        // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   GadgetDescription;                                 // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   GadgetTooltipDescription;                          // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   GadgetUnlockDescription;                           // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       GadgetIcon;                                        // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   LeftActionTxt;                                     // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   RightActionTxt;                                    // 0x00B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   GadgetClass;                                       // 0x00D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           GadgetPreviewMesh;                                 // 0x00F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UToolWrapData*                          GadgetWrapDataAsset;                               // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UToolWrapData*                          PlaceableWrapDataAsset;                            // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             GadgetCategoryIcon;                                // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 GadgetCategoryColor;                               // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMediaSource*                           GadgetMedia;                                       // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetData">();
	}
	static class UGadgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetData>();
	}
};
static_assert(alignof(UGadgetData) == 0x000008, "Wrong alignment on UGadgetData");
static_assert(sizeof(UGadgetData) == 0x000148, "Wrong size on UGadgetData");
static_assert(offsetof(UGadgetData, GadgetName) == 0x000038, "Member 'UGadgetData::GadgetName' has a wrong offset!");
static_assert(offsetof(UGadgetData, GadgetDescription) == 0x000050, "Member 'UGadgetData::GadgetDescription' has a wrong offset!");
static_assert(offsetof(UGadgetData, GadgetTooltipDescription) == 0x000068, "Member 'UGadgetData::GadgetTooltipDescription' has a wrong offset!");
static_assert(offsetof(UGadgetData, GadgetUnlockDescription) == 0x000080, "Member 'UGadgetData::GadgetUnlockDescription' has a wrong offset!");
static_assert(offsetof(UGadgetData, GadgetIcon) == 0x000098, "Member 'UGadgetData::GadgetIcon' has a wrong offset!");
static_assert(offsetof(UGadgetData, LeftActionTxt) == 0x0000A0, "Member 'UGadgetData::LeftActionTxt' has a wrong offset!");
static_assert(offsetof(UGadgetData, RightActionTxt) == 0x0000B8, "Member 'UGadgetData::RightActionTxt' has a wrong offset!");
static_assert(offsetof(UGadgetData, GadgetClass) == 0x0000D0, "Member 'UGadgetData::GadgetClass' has a wrong offset!");
static_assert(offsetof(UGadgetData, GadgetPreviewMesh) == 0x0000F8, "Member 'UGadgetData::GadgetPreviewMesh' has a wrong offset!");
static_assert(offsetof(UGadgetData, GadgetWrapDataAsset) == 0x000120, "Member 'UGadgetData::GadgetWrapDataAsset' has a wrong offset!");
static_assert(offsetof(UGadgetData, PlaceableWrapDataAsset) == 0x000128, "Member 'UGadgetData::PlaceableWrapDataAsset' has a wrong offset!");
static_assert(offsetof(UGadgetData, GadgetCategoryIcon) == 0x000130, "Member 'UGadgetData::GadgetCategoryIcon' has a wrong offset!");
static_assert(offsetof(UGadgetData, GadgetCategoryColor) == 0x000138, "Member 'UGadgetData::GadgetCategoryColor' has a wrong offset!");
static_assert(offsetof(UGadgetData, GadgetMedia) == 0x000140, "Member 'UGadgetData::GadgetMedia' has a wrong offset!");

// Class DeceiveInc.GameLiftDedicatedServerManager
// 0x0058 (0x0158 - 0x0100)
class UGameLiftDedicatedServerManager final : public UDIDedicatedServerManager
{
public:
	uint8                                         Pad_100[0x58];                                     // 0x0100(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameLiftDedicatedServerManager">();
	}
	static class UGameLiftDedicatedServerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameLiftDedicatedServerManager>();
	}
};
static_assert(alignof(UGameLiftDedicatedServerManager) == 0x000008, "Wrong alignment on UGameLiftDedicatedServerManager");
static_assert(sizeof(UGameLiftDedicatedServerManager) == 0x000158, "Wrong size on UGameLiftDedicatedServerManager");

// Class DeceiveInc.GameplayBotBrain
// 0x00C0 (0x0138 - 0x0078)
class UGameplayBotBrain final : public UBotBrain
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBotPlanFight*                          PlanFight;                                         // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBotPlanProgressFlow*                   PlanProgressFlow;                                  // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0xA0];                                      // 0x0098(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBriefcaseDropped();
	void OnDoNotAggroOtherBotsTimerEnd();
	void OnFightTargetLost(class UBotPlanFight* BotPlanFight, class ASpy* LostTarget);
	void OnGamePhaseChanged(ESpyGamePhase NewGamePhase);
	void OnHealthChanged(class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, float RawDamage);
	void OnLingeringExtractingSpyTimerEnd();
	void OnPanicCooldownTimerEnd();
	void OnRefreshGoalTimerEnd();
	void OnResourceChange(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 Amount);
	void OnSpyExtractingChange(class AExtractionInteractableActor* ExtractPointIn, class ASpy* ExtractingSpyIn, bool bExtractingIn);
	void OnStallProgressTimerEnd();
	void OnUndercoverChange(bool bUndercover);
	void OnVaultTerminalUnlockedCountChange(int32 VaultTerminalUnlockedCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayBotBrain">();
	}
	static class UGameplayBotBrain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayBotBrain>();
	}
};
static_assert(alignof(UGameplayBotBrain) == 0x000008, "Wrong alignment on UGameplayBotBrain");
static_assert(sizeof(UGameplayBotBrain) == 0x000138, "Wrong size on UGameplayBotBrain");
static_assert(offsetof(UGameplayBotBrain, PlanFight) == 0x000088, "Member 'UGameplayBotBrain::PlanFight' has a wrong offset!");
static_assert(offsetof(UGameplayBotBrain, PlanProgressFlow) == 0x000090, "Member 'UGameplayBotBrain::PlanProgressFlow' has a wrong offset!");

// Class DeceiveInc.GameplayEventBus
// 0x00E0 (0x0108 - 0x0028)
class UGameplayEventBus final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnCoverChangedEvent;                               // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNewSpySpawnedEvent;                              // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyDespawningEvent;                              // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNonLocalSpySpawnedEvent;                         // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNonLocalSpyDespawningEvent;                      // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNonLocalHealthChangeEvent;                       // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCoverBlownEvent;                                 // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCoverRegainedEvent;                              // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyAddVictimEffect;                              // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGamePhaseChange;                                 // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyDeathEvent;                                   // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpySecurityStateChanged;                         // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNPCKilledEvent;                                  // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyHeatChange;                                   // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static void FireOnNPCKilledEvent(class ASpy* Spy, class ANPCCharacter* NPC);
	static void FireOnSpyHeatChanged(class ASpy* Spy, int32 NewHeatValue, int32 HeatDelta);

	void GameplayEventDelegate_CoverChanged__DelegateSignature(class ASpy* Spy, class ANPCCharacter* NewCover);
	void GameplayEventDelegate_GamePhaseChange__DelegateSignature(ESpyGamePhase NewPhase, const class ADeceiveIncMatchGameState* GameState);
	void GameplayEventDelegate_HealthSpecific__DelegateSignature(class ASpy* Spy, class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);
	void GameplayEventDelegate_NewPlayerState__DelegateSignature(class ADIPlayerState* PlayerState);
	void GameplayEventDelegate_SpyHeatChange__DelegateSignature(class ASpy* Spy, int32 NewHeatValue, int32 HeatDelta);
	void GameplayEventDelegate_SpySecuritySpecific__DelegateSignature(class ASpy* Spy, ESpySecurityState PreviousState, ESpySecurityState NewState);
	void GameplayEventDelegate_SpySpecific__DelegateSignature(class ASpy* Spy);
	void GameplayEventDelegate_SpyVictimEffect__DelegateSignature(class ASpy* Spy, class AVictimEffect* VictimEffect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayEventBus">();
	}
	static class UGameplayEventBus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayEventBus>();
	}
};
static_assert(alignof(UGameplayEventBus) == 0x000008, "Wrong alignment on UGameplayEventBus");
static_assert(sizeof(UGameplayEventBus) == 0x000108, "Wrong size on UGameplayEventBus");
static_assert(offsetof(UGameplayEventBus, OnCoverChangedEvent) == 0x000028, "Member 'UGameplayEventBus::OnCoverChangedEvent' has a wrong offset!");
static_assert(offsetof(UGameplayEventBus, OnNewSpySpawnedEvent) == 0x000038, "Member 'UGameplayEventBus::OnNewSpySpawnedEvent' has a wrong offset!");
static_assert(offsetof(UGameplayEventBus, OnSpyDespawningEvent) == 0x000048, "Member 'UGameplayEventBus::OnSpyDespawningEvent' has a wrong offset!");
static_assert(offsetof(UGameplayEventBus, OnNonLocalSpySpawnedEvent) == 0x000058, "Member 'UGameplayEventBus::OnNonLocalSpySpawnedEvent' has a wrong offset!");
static_assert(offsetof(UGameplayEventBus, OnNonLocalSpyDespawningEvent) == 0x000068, "Member 'UGameplayEventBus::OnNonLocalSpyDespawningEvent' has a wrong offset!");
static_assert(offsetof(UGameplayEventBus, OnNonLocalHealthChangeEvent) == 0x000078, "Member 'UGameplayEventBus::OnNonLocalHealthChangeEvent' has a wrong offset!");
static_assert(offsetof(UGameplayEventBus, OnCoverBlownEvent) == 0x000088, "Member 'UGameplayEventBus::OnCoverBlownEvent' has a wrong offset!");
static_assert(offsetof(UGameplayEventBus, OnCoverRegainedEvent) == 0x000098, "Member 'UGameplayEventBus::OnCoverRegainedEvent' has a wrong offset!");
static_assert(offsetof(UGameplayEventBus, OnSpyAddVictimEffect) == 0x0000A8, "Member 'UGameplayEventBus::OnSpyAddVictimEffect' has a wrong offset!");
static_assert(offsetof(UGameplayEventBus, OnGamePhaseChange) == 0x0000B8, "Member 'UGameplayEventBus::OnGamePhaseChange' has a wrong offset!");
static_assert(offsetof(UGameplayEventBus, OnSpyDeathEvent) == 0x0000C8, "Member 'UGameplayEventBus::OnSpyDeathEvent' has a wrong offset!");
static_assert(offsetof(UGameplayEventBus, OnSpySecurityStateChanged) == 0x0000D8, "Member 'UGameplayEventBus::OnSpySecurityStateChanged' has a wrong offset!");
static_assert(offsetof(UGameplayEventBus, OnNPCKilledEvent) == 0x0000E8, "Member 'UGameplayEventBus::OnNPCKilledEvent' has a wrong offset!");
static_assert(offsetof(UGameplayEventBus, OnSpyHeatChange) == 0x0000F8, "Member 'UGameplayEventBus::OnSpyHeatChange' has a wrong offset!");

// Class DeceiveInc.GameplayResourcesData
// 0x0058 (0x0090 - 0x0038)
class UGameplayResourcesData final : public UDIPrimaryDataAsset
{
public:
	TMap<EGameplayResourcesType, struct FGameplayResourcesSettings> GameplayResources;                                 // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSubclassOf<class ASpyPack>                   SpyPack;                                           // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayResourcesData">();
	}
	static class UGameplayResourcesData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayResourcesData>();
	}
};
static_assert(alignof(UGameplayResourcesData) == 0x000008, "Wrong alignment on UGameplayResourcesData");
static_assert(sizeof(UGameplayResourcesData) == 0x000090, "Wrong size on UGameplayResourcesData");
static_assert(offsetof(UGameplayResourcesData, GameplayResources) == 0x000038, "Member 'UGameplayResourcesData::GameplayResources' has a wrong offset!");
static_assert(offsetof(UGameplayResourcesData, SpyPack) == 0x000088, "Member 'UGameplayResourcesData::SpyPack' has a wrong offset!");

// Class DeceiveInc.GlobalEBusSubsystem
// 0x0040 (0x0070 - 0x0030)
class UGlobalEBusSubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnClientEventExtractionPointSet;                   // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnClientInputDeviceChange;                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLoadingScreenInfoEvent;                          // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlueprintEbusStringEvent;                        // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void SignalBlueprintEbusStringEvent(const class FString& StringEvent);
	void SignalLoadingScreenEvent(const class FString& LoadingEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalEBusSubsystem">();
	}
	static class UGlobalEBusSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalEBusSubsystem>();
	}
};
static_assert(alignof(UGlobalEBusSubsystem) == 0x000008, "Wrong alignment on UGlobalEBusSubsystem");
static_assert(sizeof(UGlobalEBusSubsystem) == 0x000070, "Wrong size on UGlobalEBusSubsystem");
static_assert(offsetof(UGlobalEBusSubsystem, OnClientEventExtractionPointSet) == 0x000030, "Member 'UGlobalEBusSubsystem::OnClientEventExtractionPointSet' has a wrong offset!");
static_assert(offsetof(UGlobalEBusSubsystem, OnClientInputDeviceChange) == 0x000040, "Member 'UGlobalEBusSubsystem::OnClientInputDeviceChange' has a wrong offset!");
static_assert(offsetof(UGlobalEBusSubsystem, OnLoadingScreenInfoEvent) == 0x000050, "Member 'UGlobalEBusSubsystem::OnLoadingScreenInfoEvent' has a wrong offset!");
static_assert(offsetof(UGlobalEBusSubsystem, OnBlueprintEbusStringEvent) == 0x000060, "Member 'UGlobalEBusSubsystem::OnBlueprintEbusStringEvent' has a wrong offset!");

// Class DeceiveInc.GooPodTool
// 0x0028 (0x06B0 - 0x0688)
class AGooPodTool final : public ABasePlaceableSpyTool
{
public:
	class FText                                   PlaceableToolSecondaryAlternativeActionText;       // 0x0688(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   GooPodReticuleHudName;                             // 0x06A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsActive;                                         // 0x06A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A9[0x7];                                      // 0x06A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_ToggleGoo(bool bIsActiveIn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GooPodTool">();
	}
	static class AGooPodTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGooPodTool>();
	}
};
static_assert(alignof(AGooPodTool) == 0x000008, "Wrong alignment on AGooPodTool");
static_assert(sizeof(AGooPodTool) == 0x0006B0, "Wrong size on AGooPodTool");
static_assert(offsetof(AGooPodTool, PlaceableToolSecondaryAlternativeActionText) == 0x000688, "Member 'AGooPodTool::PlaceableToolSecondaryAlternativeActionText' has a wrong offset!");
static_assert(offsetof(AGooPodTool, GooPodReticuleHudName) == 0x0006A0, "Member 'AGooPodTool::GooPodReticuleHudName' has a wrong offset!");
static_assert(offsetof(AGooPodTool, bIsActive) == 0x0006A8, "Member 'AGooPodTool::bIsActive' has a wrong offset!");

// Class DeceiveInc.HackTrapScannableComponent
// 0x0090 (0x02F0 - 0x0260)
class UHackTrapScannableComponent final : public UScannableComponent
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTrapTriggered;                                   // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIsTrappedChanged;                                // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIsTrappedByEnnemyChanged;                        // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bRemoveTrapOnDisable;                              // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTriggerOnlyOnResourceSpend;                       // 0x0299(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameplayResourcesType                        ResourceSpendType;                                 // 0x029A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29B[0x5];                                      // 0x029B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class AHackTrapScannerTool*                   LocalScannerInRange;                               // 0x02A0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 FactionTrappingDevice;                             // 0x02A8(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 FactionScramblingDevice;                           // 0x02B8(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AHackTrapScannerTool>> HackTrapRegistered;                                // 0x02C8(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         ScramblingActors;                                  // 0x02D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnIsTrappedChanged(bool bIsTrapped);
	void HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void HandleResourceSpent(class UInteracterComponent* Interacter, EGameplayResourcesType ResourceType, int32 Amount);
	void HandleSpyToolLoadComplete(class UToolLoadoutComponent* ToolLoadout);
	bool IsTrappedByEnnemyFaction();
	void NetMulticast_IsDeviceTrappedChanged(bool bIsTrapped, class AHackTrapScannerTool* HackTrapScanner, class AActor* Interacter);
	void OnRep_FactionScramblingDevice(const TArray<int32>& OldFactionScramblingDevice);
	void OnRep_FactionTrappingDevice(const TArray<int32>& OldFactionTrappingDevice);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HackTrapScannableComponent">();
	}
	static class UHackTrapScannableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHackTrapScannableComponent>();
	}
};
static_assert(alignof(UHackTrapScannableComponent) == 0x000010, "Wrong alignment on UHackTrapScannableComponent");
static_assert(sizeof(UHackTrapScannableComponent) == 0x0002F0, "Wrong size on UHackTrapScannableComponent");
static_assert(offsetof(UHackTrapScannableComponent, OnTrapTriggered) == 0x000268, "Member 'UHackTrapScannableComponent::OnTrapTriggered' has a wrong offset!");
static_assert(offsetof(UHackTrapScannableComponent, OnIsTrappedChanged) == 0x000278, "Member 'UHackTrapScannableComponent::OnIsTrappedChanged' has a wrong offset!");
static_assert(offsetof(UHackTrapScannableComponent, OnIsTrappedByEnnemyChanged) == 0x000288, "Member 'UHackTrapScannableComponent::OnIsTrappedByEnnemyChanged' has a wrong offset!");
static_assert(offsetof(UHackTrapScannableComponent, bRemoveTrapOnDisable) == 0x000298, "Member 'UHackTrapScannableComponent::bRemoveTrapOnDisable' has a wrong offset!");
static_assert(offsetof(UHackTrapScannableComponent, bTriggerOnlyOnResourceSpend) == 0x000299, "Member 'UHackTrapScannableComponent::bTriggerOnlyOnResourceSpend' has a wrong offset!");
static_assert(offsetof(UHackTrapScannableComponent, ResourceSpendType) == 0x00029A, "Member 'UHackTrapScannableComponent::ResourceSpendType' has a wrong offset!");
static_assert(offsetof(UHackTrapScannableComponent, LocalScannerInRange) == 0x0002A0, "Member 'UHackTrapScannableComponent::LocalScannerInRange' has a wrong offset!");
static_assert(offsetof(UHackTrapScannableComponent, FactionTrappingDevice) == 0x0002A8, "Member 'UHackTrapScannableComponent::FactionTrappingDevice' has a wrong offset!");
static_assert(offsetof(UHackTrapScannableComponent, FactionScramblingDevice) == 0x0002B8, "Member 'UHackTrapScannableComponent::FactionScramblingDevice' has a wrong offset!");
static_assert(offsetof(UHackTrapScannableComponent, HackTrapRegistered) == 0x0002C8, "Member 'UHackTrapScannableComponent::HackTrapRegistered' has a wrong offset!");
static_assert(offsetof(UHackTrapScannableComponent, ScramblingActors) == 0x0002D8, "Member 'UHackTrapScannableComponent::ScramblingActors' has a wrong offset!");

// Class DeceiveInc.HansActiveAbility
// 0x0190 (0x0720 - 0x0590)
class AHansActiveAbility final : public ABaseSpyActiveAbility
{
public:
	uint8                                         Pad_590[0x8];                                      // 0x0590(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EffectiveAimRange;                                 // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MuzzleSocketName;                                  // 0x059C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A4[0x4];                                      // 0x05A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   HansVictimEffectSpy;                               // 0x05A8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   HansVictimEffectGuard;                             // 0x05D0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnOProjectileDelay;                             // 0x05F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AfterSpawnProjectileDelay;                         // 0x05FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ASpawnerWeaponRound>        WeaponRoundClass;                                  // 0x0600(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHansActiveProjectileHit;                         // 0x0608(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnProjectilesReleased;                             // 0x0618(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnProjectilesAbort;                                // 0x0628(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnShowProjectiles;                                 // 0x0638(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_648[0xD8];                                     // 0x0648(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnHansActiveProjectileHit(class AActor* Victim, const struct FVector& ImpactPoint, const struct FVector& ImpactNormal);
	void BP_OnLocalHansActiveEnd();
	void BP_OnLocalHansActiveStart();
	void MulticastFireShot(const struct FVector_NetQuantize& OriginPos, const struct FVector_NetQuantize& DestinationPos);
	void MulticastProjectileHit(class AActor* Victim, const struct FVector_NetQuantize& ImpactPos, const struct FVector_NetQuantizeNormal& ImpactNormal);
	void OnAfterShotTimerEnd();
	void OnServerHansActiveEnd();
	void Server_StartHansActive();

	struct FVector GetMuzzlePosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HansActiveAbility">();
	}
	static class AHansActiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHansActiveAbility>();
	}
};
static_assert(alignof(AHansActiveAbility) == 0x000008, "Wrong alignment on AHansActiveAbility");
static_assert(sizeof(AHansActiveAbility) == 0x000720, "Wrong size on AHansActiveAbility");
static_assert(offsetof(AHansActiveAbility, EffectiveAimRange) == 0x000598, "Member 'AHansActiveAbility::EffectiveAimRange' has a wrong offset!");
static_assert(offsetof(AHansActiveAbility, MuzzleSocketName) == 0x00059C, "Member 'AHansActiveAbility::MuzzleSocketName' has a wrong offset!");
static_assert(offsetof(AHansActiveAbility, HansVictimEffectSpy) == 0x0005A8, "Member 'AHansActiveAbility::HansVictimEffectSpy' has a wrong offset!");
static_assert(offsetof(AHansActiveAbility, HansVictimEffectGuard) == 0x0005D0, "Member 'AHansActiveAbility::HansVictimEffectGuard' has a wrong offset!");
static_assert(offsetof(AHansActiveAbility, SpawnOProjectileDelay) == 0x0005F8, "Member 'AHansActiveAbility::SpawnOProjectileDelay' has a wrong offset!");
static_assert(offsetof(AHansActiveAbility, AfterSpawnProjectileDelay) == 0x0005FC, "Member 'AHansActiveAbility::AfterSpawnProjectileDelay' has a wrong offset!");
static_assert(offsetof(AHansActiveAbility, WeaponRoundClass) == 0x000600, "Member 'AHansActiveAbility::WeaponRoundClass' has a wrong offset!");
static_assert(offsetof(AHansActiveAbility, OnHansActiveProjectileHit) == 0x000608, "Member 'AHansActiveAbility::OnHansActiveProjectileHit' has a wrong offset!");
static_assert(offsetof(AHansActiveAbility, OnProjectilesReleased) == 0x000618, "Member 'AHansActiveAbility::OnProjectilesReleased' has a wrong offset!");
static_assert(offsetof(AHansActiveAbility, OnProjectilesAbort) == 0x000628, "Member 'AHansActiveAbility::OnProjectilesAbort' has a wrong offset!");
static_assert(offsetof(AHansActiveAbility, OnShowProjectiles) == 0x000638, "Member 'AHansActiveAbility::OnShowProjectiles' has a wrong offset!");

// Class DeceiveInc.HeadTrackingComponent
// 0x00C0 (0x0170 - 0x00B0)
class UHeadTrackingComponent final : public UActorComponent
{
public:
	float                                         AngleClamp;                                        // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInDuration;                                    // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutDuration;                                   // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RefSocketName;                                     // 0x00BC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisableAtLOD;                                      // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x00C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAlphaChangeEvent;                                // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLookAtPositionChangeEvent;                       // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x80];                                      // 0x00F0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeadTrackingComponent">();
	}
	static class UHeadTrackingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeadTrackingComponent>();
	}
};
static_assert(alignof(UHeadTrackingComponent) == 0x000008, "Wrong alignment on UHeadTrackingComponent");
static_assert(sizeof(UHeadTrackingComponent) == 0x000170, "Wrong size on UHeadTrackingComponent");
static_assert(offsetof(UHeadTrackingComponent, AngleClamp) == 0x0000B0, "Member 'UHeadTrackingComponent::AngleClamp' has a wrong offset!");
static_assert(offsetof(UHeadTrackingComponent, FadeInDuration) == 0x0000B4, "Member 'UHeadTrackingComponent::FadeInDuration' has a wrong offset!");
static_assert(offsetof(UHeadTrackingComponent, FadeOutDuration) == 0x0000B8, "Member 'UHeadTrackingComponent::FadeOutDuration' has a wrong offset!");
static_assert(offsetof(UHeadTrackingComponent, RefSocketName) == 0x0000BC, "Member 'UHeadTrackingComponent::RefSocketName' has a wrong offset!");
static_assert(offsetof(UHeadTrackingComponent, DisableAtLOD) == 0x0000C4, "Member 'UHeadTrackingComponent::DisableAtLOD' has a wrong offset!");
static_assert(offsetof(UHeadTrackingComponent, SkeletalMesh) == 0x0000C8, "Member 'UHeadTrackingComponent::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(UHeadTrackingComponent, OnAlphaChangeEvent) == 0x0000D0, "Member 'UHeadTrackingComponent::OnAlphaChangeEvent' has a wrong offset!");
static_assert(offsetof(UHeadTrackingComponent, OnLookAtPositionChangeEvent) == 0x0000E0, "Member 'UHeadTrackingComponent::OnLookAtPositionChangeEvent' has a wrong offset!");

// Class DeceiveInc.HealthComponent
// 0x0120 (0x01D0 - 0x00B0)
class UHealthComponent final : public UActorComponent
{
public:
	uint8                                         FactionID;                                         // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDead;                                           // 0x00B1(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B2[0x2];                                       // 0x00B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Health;                                            // 0x00B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxHealth;                                         // 0x00B8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableHeadshots;                                 // 0x00BC(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowFriendlyFire;                                // 0x00BD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHitType                                      HitTypeOverride;                                   // 0x00BE(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BF[0x1];                                       // 0x00BF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EHitType, EHitType>                      HitTypeOverrides;                                  // 0x00C0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         DefaultHealth;                                     // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AController>             LastPlayerDamageInstigator;                        // 0x0114(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDamageModifiers*                       DamageModifiers;                                   // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHealthInfo                            HealthInfo;                                        // 0x0128(0x0020)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnHealthChanged;                                   // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInstigateZeroDamage;                             // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMaxHealthChanged;                                // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDeath;                                           // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRevive;                                          // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIgnoreDamage;                                     // 0x0198(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockHealing;                                     // 0x0199(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A[0x6];                                      // 0x019A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorBlockingHealing;                              // 0x01A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	float                                         MaxOverhealAmmount;                                // 0x01B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0x1C];                                     // 0x01B4(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsFriendly(const class AActor* ActorA, const class AActor* ActorB);
	static bool IsFriendlyOrNeutral(const class AActor* ActorA, const class AActor* ActorB);

	void AddDamageModifier(class AActor* Instigator, class UDamageModifier* Modifier);
	void FullHeal();
	void HandleTakeAnyDamage(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);
	void Heal(float HealAmount);
	void OnRep_Dead(bool OldDead);
	void OnRep_HealthInfo(const struct FHealthInfo& OldHealthInfo);
	void OnRep_MaxHealth(float OldMaxHealth);
	void RemoveDamageModifier(class UDamageModifier* Modifier);
	void SetHealth(float NewHealth);
	void SetMaxHealth(float NewMaxHealth);
	void SetOfflineDemiGod(bool bDemiGod);

	float GetHealth() const;
	float GetHealthRatio() const;
	float GetHealthRatioOnDefault() const;
	float GetMaxHealth() const;
	bool IsDead() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealthComponent">();
	}
	static class UHealthComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealthComponent>();
	}
};
static_assert(alignof(UHealthComponent) == 0x000008, "Wrong alignment on UHealthComponent");
static_assert(sizeof(UHealthComponent) == 0x0001D0, "Wrong size on UHealthComponent");
static_assert(offsetof(UHealthComponent, FactionID) == 0x0000B0, "Member 'UHealthComponent::FactionID' has a wrong offset!");
static_assert(offsetof(UHealthComponent, bIsDead) == 0x0000B1, "Member 'UHealthComponent::bIsDead' has a wrong offset!");
static_assert(offsetof(UHealthComponent, Health) == 0x0000B4, "Member 'UHealthComponent::Health' has a wrong offset!");
static_assert(offsetof(UHealthComponent, MaxHealth) == 0x0000B8, "Member 'UHealthComponent::MaxHealth' has a wrong offset!");
static_assert(offsetof(UHealthComponent, bDisableHeadshots) == 0x0000BC, "Member 'UHealthComponent::bDisableHeadshots' has a wrong offset!");
static_assert(offsetof(UHealthComponent, bAllowFriendlyFire) == 0x0000BD, "Member 'UHealthComponent::bAllowFriendlyFire' has a wrong offset!");
static_assert(offsetof(UHealthComponent, HitTypeOverride) == 0x0000BE, "Member 'UHealthComponent::HitTypeOverride' has a wrong offset!");
static_assert(offsetof(UHealthComponent, HitTypeOverrides) == 0x0000C0, "Member 'UHealthComponent::HitTypeOverrides' has a wrong offset!");
static_assert(offsetof(UHealthComponent, DefaultHealth) == 0x000110, "Member 'UHealthComponent::DefaultHealth' has a wrong offset!");
static_assert(offsetof(UHealthComponent, LastPlayerDamageInstigator) == 0x000114, "Member 'UHealthComponent::LastPlayerDamageInstigator' has a wrong offset!");
static_assert(offsetof(UHealthComponent, DamageModifiers) == 0x000120, "Member 'UHealthComponent::DamageModifiers' has a wrong offset!");
static_assert(offsetof(UHealthComponent, HealthInfo) == 0x000128, "Member 'UHealthComponent::HealthInfo' has a wrong offset!");
static_assert(offsetof(UHealthComponent, OnHealthChanged) == 0x000148, "Member 'UHealthComponent::OnHealthChanged' has a wrong offset!");
static_assert(offsetof(UHealthComponent, OnInstigateZeroDamage) == 0x000158, "Member 'UHealthComponent::OnInstigateZeroDamage' has a wrong offset!");
static_assert(offsetof(UHealthComponent, OnMaxHealthChanged) == 0x000168, "Member 'UHealthComponent::OnMaxHealthChanged' has a wrong offset!");
static_assert(offsetof(UHealthComponent, OnDeath) == 0x000178, "Member 'UHealthComponent::OnDeath' has a wrong offset!");
static_assert(offsetof(UHealthComponent, OnRevive) == 0x000188, "Member 'UHealthComponent::OnRevive' has a wrong offset!");
static_assert(offsetof(UHealthComponent, bIgnoreDamage) == 0x000198, "Member 'UHealthComponent::bIgnoreDamage' has a wrong offset!");
static_assert(offsetof(UHealthComponent, bBlockHealing) == 0x000199, "Member 'UHealthComponent::bBlockHealing' has a wrong offset!");
static_assert(offsetof(UHealthComponent, ActorBlockingHealing) == 0x0001A0, "Member 'UHealthComponent::ActorBlockingHealing' has a wrong offset!");
static_assert(offsetof(UHealthComponent, MaxOverhealAmmount) == 0x0001B0, "Member 'UHealthComponent::MaxOverhealAmmount' has a wrong offset!");

// Class DeceiveInc.HeightCheckComponent
// 0x0040 (0x00F0 - 0x00B0)
class UHeightCheckComponent final : public UActorComponent
{
public:
	ETraceTypeQuery                               CollisionChannel;                                  // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckForOverlaps;                                 // 0x00B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAxis                                         AxisToCheck;                                       // 0x00B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInvertAxis;                                       // 0x00B3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PointingRayRadius;                                 // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HeightMaxDistance;                                 // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartActive;                                      // 0x00BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTryFallingDown;                                   // 0x00BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckIfAttached;                                  // 0x00BE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDrawDebugTrace                               DebugTrace;                                        // 0x00BF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x30];                                      // 0x00C0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateHeightCheck(bool bActivate);
	void SetCustomCheckLocation(const struct FVector& CheckLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeightCheckComponent">();
	}
	static class UHeightCheckComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeightCheckComponent>();
	}
};
static_assert(alignof(UHeightCheckComponent) == 0x000008, "Wrong alignment on UHeightCheckComponent");
static_assert(sizeof(UHeightCheckComponent) == 0x0000F0, "Wrong size on UHeightCheckComponent");
static_assert(offsetof(UHeightCheckComponent, CollisionChannel) == 0x0000B0, "Member 'UHeightCheckComponent::CollisionChannel' has a wrong offset!");
static_assert(offsetof(UHeightCheckComponent, bCheckForOverlaps) == 0x0000B1, "Member 'UHeightCheckComponent::bCheckForOverlaps' has a wrong offset!");
static_assert(offsetof(UHeightCheckComponent, AxisToCheck) == 0x0000B2, "Member 'UHeightCheckComponent::AxisToCheck' has a wrong offset!");
static_assert(offsetof(UHeightCheckComponent, bInvertAxis) == 0x0000B3, "Member 'UHeightCheckComponent::bInvertAxis' has a wrong offset!");
static_assert(offsetof(UHeightCheckComponent, PointingRayRadius) == 0x0000B4, "Member 'UHeightCheckComponent::PointingRayRadius' has a wrong offset!");
static_assert(offsetof(UHeightCheckComponent, HeightMaxDistance) == 0x0000B8, "Member 'UHeightCheckComponent::HeightMaxDistance' has a wrong offset!");
static_assert(offsetof(UHeightCheckComponent, bStartActive) == 0x0000BC, "Member 'UHeightCheckComponent::bStartActive' has a wrong offset!");
static_assert(offsetof(UHeightCheckComponent, bTryFallingDown) == 0x0000BD, "Member 'UHeightCheckComponent::bTryFallingDown' has a wrong offset!");
static_assert(offsetof(UHeightCheckComponent, bCheckIfAttached) == 0x0000BE, "Member 'UHeightCheckComponent::bCheckIfAttached' has a wrong offset!");
static_assert(offsetof(UHeightCheckComponent, DebugTrace) == 0x0000BF, "Member 'UHeightCheckComponent::DebugTrace' has a wrong offset!");

// Class DeceiveInc.ImpulseWeaponComponent
// 0x0008 (0x00B8 - 0x00B0)
class UImpulseWeaponComponent final : public UActorComponent
{
public:
	float                                         AimImpulse;                                        // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundUpImpulse;                                   // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnSimulateLocalFireShot(class AProjectileWeapon* Weapon, const struct FVector& OriginPos, const struct FVector& DestinationPos, bool bDoDamage, bool bMissingShot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImpulseWeaponComponent">();
	}
	static class UImpulseWeaponComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImpulseWeaponComponent>();
	}
};
static_assert(alignof(UImpulseWeaponComponent) == 0x000008, "Wrong alignment on UImpulseWeaponComponent");
static_assert(sizeof(UImpulseWeaponComponent) == 0x0000B8, "Wrong size on UImpulseWeaponComponent");
static_assert(offsetof(UImpulseWeaponComponent, AimImpulse) == 0x0000B0, "Member 'UImpulseWeaponComponent::AimImpulse' has a wrong offset!");
static_assert(offsetof(UImpulseWeaponComponent, GroundUpImpulse) == 0x0000B4, "Member 'UImpulseWeaponComponent::GroundUpImpulse' has a wrong offset!");

// Class DeceiveInc.InNavmodeConditionComponent
// 0x0000 (0x00D0 - 0x00D0)
class UInNavmodeConditionComponent final : public UBaseConditionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InNavmodeConditionComponent">();
	}
	static class UInNavmodeConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInNavmodeConditionComponent>();
	}
};
static_assert(alignof(UInNavmodeConditionComponent) == 0x000008, "Wrong alignment on UInNavmodeConditionComponent");
static_assert(sizeof(UInNavmodeConditionComponent) == 0x0000D0, "Wrong size on UInNavmodeConditionComponent");

// Class DeceiveInc.InteractableActorInterface
// 0x0000 (0x0028 - 0x0028)
class IInteractableActorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableActorInterface">();
	}
	static class IInteractableActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInteractableActorInterface>();
	}
};
static_assert(alignof(IInteractableActorInterface) == 0x000008, "Wrong alignment on IInteractableActorInterface");
static_assert(sizeof(IInteractableActorInterface) == 0x000028, "Wrong size on IInteractableActorInterface");

// Class DeceiveInc.InteractableComponent
// 0x01D0 (0x03D0 - 0x0200)
class UInteractableComponent final : public USceneComponent
{
public:
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnInteractionStart;                                // 0x0200(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractionCancel;                               // 0x0210(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractionComplete;                             // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractableStateChanged;                        // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLocalInteractionStart;                           // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLocalInteractionCancel;                          // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLocalInteractionComplete;                        // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractionIconChanged;                          // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnResourceSpent;                                   // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractionDisabledBySpawnedObject;              // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bWillNeverBeEnabled;                               // 0x02A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompletingIsSuspiciousToBots;                     // 0x02A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNPCFakeInteracts;                                 // 0x02A2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A3[0x5];                                      // 0x02A3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        ToReachRoomCells;                                  // 0x02A8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	uint32                                        PartOfRoomCRC;                                     // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x8];                                      // 0x02BC(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractionDuration;                               // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NonOwnerInteractionDurationOverride;               // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractionDistance;                               // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableOnCantInteract;                            // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableOnDestroyed;                               // 0x02D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHideCloseIcon;                                    // 0x02D2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bValidateDistStartOnly;                            // 0x02D3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanInteractOnVisibleOnly;                         // 0x02D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCancelOnDamage;                                 // 0x02D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanReduceDuration;                                // 0x02D6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D7[0x1];                                      // 0x02D7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConflictWeightMultiply;                            // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteract1PAnimation                          FirstPersonInteractAnimation;                      // 0x02DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTakeIconForInteractLocation;                      // 0x02DD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bContinuousInteraction;                            // 0x02DE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldFrustumCheck;                               // 0x02DF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 InteractWidgetIconClassHolder;                     // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   InteractWidgetIconClass;                           // 0x02E8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FLastInteractionData>           LastInteractionsData;                              // 0x0310(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x10];                                     // 0x0320(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsEnableLocal;                                    // 0x0330(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_331[0x57];                                     // 0x0331(0x0057)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionIconComponent*              InteractionIconComp;                               // 0x0388(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UBaseConditionComponent*>        ConditionsList;                                    // 0x0390(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, DuplicateTransient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A0[0x1];                                      // 0x03A0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsEnable;                                         // 0x03A1(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A2[0x6];                                      // 0x03A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AObjectSpawn>            AssociatedObjectSpawner;                           // 0x03A8(0x0028)(Edit, DisableEditOnTemplate, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool GetContinuousInteraction();
	void HandleActorSpawned(class AActor* SpawnedActor);
	void HandleSpyDead(class ASpy* DeadSpy);
	bool IsBeingInteractedWith();
	bool IsResourceSpend(const class UInteracterComponent* Interacter);
	void OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnGamePhaseChanged(ESpyGamePhase NewGamePhase);
	void OnRep_IsEnable();
	void SetEnable(bool Enable);

	bool CanReduceInteractDuration(const class UInteracterComponent* Interacter) const;
	struct FLastInteractionData GetCurrentInteractionData() const;
	EInteract1PAnimation GetInteract1PAnimation(class AActor* Interacter) const;
	EInteractableState GetInteractableState() const;
	float GetInteractionDistance() const;
	float GetInteractionDuration(const class UInteracterComponent* Interacter) const;
	class UInteractionIconComponent* GetInteractionIcon() const;
	bool IsDisableOnDestroyed() const;
	bool IsInteractCancelOnDamage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableComponent">();
	}
	static class UInteractableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractableComponent>();
	}
};
static_assert(alignof(UInteractableComponent) == 0x000010, "Wrong alignment on UInteractableComponent");
static_assert(sizeof(UInteractableComponent) == 0x0003D0, "Wrong size on UInteractableComponent");
static_assert(offsetof(UInteractableComponent, OnInteractionStart) == 0x000200, "Member 'UInteractableComponent::OnInteractionStart' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnInteractionCancel) == 0x000210, "Member 'UInteractableComponent::OnInteractionCancel' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnInteractionComplete) == 0x000220, "Member 'UInteractableComponent::OnInteractionComplete' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnInteractableStateChanged) == 0x000230, "Member 'UInteractableComponent::OnInteractableStateChanged' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnLocalInteractionStart) == 0x000240, "Member 'UInteractableComponent::OnLocalInteractionStart' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnLocalInteractionCancel) == 0x000250, "Member 'UInteractableComponent::OnLocalInteractionCancel' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnLocalInteractionComplete) == 0x000260, "Member 'UInteractableComponent::OnLocalInteractionComplete' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnInteractionIconChanged) == 0x000270, "Member 'UInteractableComponent::OnInteractionIconChanged' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnResourceSpent) == 0x000280, "Member 'UInteractableComponent::OnResourceSpent' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnInteractionDisabledBySpawnedObject) == 0x000290, "Member 'UInteractableComponent::OnInteractionDisabledBySpawnedObject' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bWillNeverBeEnabled) == 0x0002A0, "Member 'UInteractableComponent::bWillNeverBeEnabled' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bCompletingIsSuspiciousToBots) == 0x0002A1, "Member 'UInteractableComponent::bCompletingIsSuspiciousToBots' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bNPCFakeInteracts) == 0x0002A2, "Member 'UInteractableComponent::bNPCFakeInteracts' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, ToReachRoomCells) == 0x0002A8, "Member 'UInteractableComponent::ToReachRoomCells' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, PartOfRoomCRC) == 0x0002B8, "Member 'UInteractableComponent::PartOfRoomCRC' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, InteractionDuration) == 0x0002C4, "Member 'UInteractableComponent::InteractionDuration' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, NonOwnerInteractionDurationOverride) == 0x0002C8, "Member 'UInteractableComponent::NonOwnerInteractionDurationOverride' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, InteractionDistance) == 0x0002CC, "Member 'UInteractableComponent::InteractionDistance' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bDisableOnCantInteract) == 0x0002D0, "Member 'UInteractableComponent::bDisableOnCantInteract' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bDisableOnDestroyed) == 0x0002D1, "Member 'UInteractableComponent::bDisableOnDestroyed' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bHideCloseIcon) == 0x0002D2, "Member 'UInteractableComponent::bHideCloseIcon' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bValidateDistStartOnly) == 0x0002D3, "Member 'UInteractableComponent::bValidateDistStartOnly' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bCanInteractOnVisibleOnly) == 0x0002D4, "Member 'UInteractableComponent::bCanInteractOnVisibleOnly' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bIsCancelOnDamage) == 0x0002D5, "Member 'UInteractableComponent::bIsCancelOnDamage' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bCanReduceDuration) == 0x0002D6, "Member 'UInteractableComponent::bCanReduceDuration' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, ConflictWeightMultiply) == 0x0002D8, "Member 'UInteractableComponent::ConflictWeightMultiply' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, FirstPersonInteractAnimation) == 0x0002DC, "Member 'UInteractableComponent::FirstPersonInteractAnimation' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bTakeIconForInteractLocation) == 0x0002DD, "Member 'UInteractableComponent::bTakeIconForInteractLocation' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bContinuousInteraction) == 0x0002DE, "Member 'UInteractableComponent::bContinuousInteraction' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bShouldFrustumCheck) == 0x0002DF, "Member 'UInteractableComponent::bShouldFrustumCheck' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, InteractWidgetIconClassHolder) == 0x0002E0, "Member 'UInteractableComponent::InteractWidgetIconClassHolder' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, InteractWidgetIconClass) == 0x0002E8, "Member 'UInteractableComponent::InteractWidgetIconClass' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, LastInteractionsData) == 0x000310, "Member 'UInteractableComponent::LastInteractionsData' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bIsEnableLocal) == 0x000330, "Member 'UInteractableComponent::bIsEnableLocal' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, InteractionIconComp) == 0x000388, "Member 'UInteractableComponent::InteractionIconComp' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, ConditionsList) == 0x000390, "Member 'UInteractableComponent::ConditionsList' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bIsEnable) == 0x0003A1, "Member 'UInteractableComponent::bIsEnable' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, AssociatedObjectSpawner) == 0x0003A8, "Member 'UInteractableComponent::AssociatedObjectSpawner' has a wrong offset!");

// Class DeceiveInc.InteractionIconWidget
// 0x0018 (0x0278 - 0x0260)
class UInteractionIconWidget final : public UUserWidget
{
public:
	bool                                          bIsRepeatableInteraction;                          // 0x0260(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261[0x3];                                      // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UInteractionIconComponent> InteractionIconComp;                               // 0x0264(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bScaleIconOnDistance;                              // 0x026C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26D[0x3];                                      // 0x026D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistanceForScale;                               // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinScalePercent;                                   // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnNewInteractionIconComponent(class UInteractionIconComponent* OldComponent, class UInteractionIconComponent* NewComponent);
	void SetIsRepeatableInteraction(bool bState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionIconWidget">();
	}
	static class UInteractionIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionIconWidget>();
	}
};
static_assert(alignof(UInteractionIconWidget) == 0x000008, "Wrong alignment on UInteractionIconWidget");
static_assert(sizeof(UInteractionIconWidget) == 0x000278, "Wrong size on UInteractionIconWidget");
static_assert(offsetof(UInteractionIconWidget, bIsRepeatableInteraction) == 0x000260, "Member 'UInteractionIconWidget::bIsRepeatableInteraction' has a wrong offset!");
static_assert(offsetof(UInteractionIconWidget, InteractionIconComp) == 0x000264, "Member 'UInteractionIconWidget::InteractionIconComp' has a wrong offset!");
static_assert(offsetof(UInteractionIconWidget, bScaleIconOnDistance) == 0x00026C, "Member 'UInteractionIconWidget::bScaleIconOnDistance' has a wrong offset!");
static_assert(offsetof(UInteractionIconWidget, MaxDistanceForScale) == 0x000270, "Member 'UInteractionIconWidget::MaxDistanceForScale' has a wrong offset!");
static_assert(offsetof(UInteractionIconWidget, MinScalePercent) == 0x000274, "Member 'UInteractionIconWidget::MinScalePercent' has a wrong offset!");

// Class DeceiveInc.IntroFlow
// 0x00D0 (0x02F0 - 0x0220)
class AIntroFlow final : public AActor
{
public:
	class UAnimationAsset*                        ForcedPosingSpyAnimation;                          // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     PosingSpyContainerClassParam;                      // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       Camera;                                            // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraLookHeightOffset;                            // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraDistanceOffset;                              // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraDistanceOffsetEnd;                           // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraHeightOffset;                                // 0x0244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraZoomSpeedFactor;                             // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoverDelay;                                      // 0x024C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraChangeDelay;                                 // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraChangeDuration;                              // 0x0254(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraChangeInterpolationExp;                      // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraChangeSideOffset;                            // 0x025C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_260[0x80];                                     // 0x0260(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     PosingSpyContainerClass;                           // 0x02E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SpawnedPosingSpyContainer;                         // 0x02E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BP_OnShowPosingSpySequenceEnd();
	void BP_OnShowPosingSpySequenceStart(const struct FVector& SpyPosition, class APosingSpy* PosingSpy);
	void CleanupIntroShowcase();
	void InitIntroShowcase();
	bool IsKillcamPlaying();
	class AActor* SpawnPosingSpyLightRig(TSubclassOf<class AActor> LightRigClass, const struct FVector& LocalOffset, const struct FRotator& LocalRotation);
	void StartShowPosingSpySequence(TSubclassOf<class AActor> PosingSpyContainer, const struct FLatentActionInfo& LatentInfo);

	bool IsShowPosingSpySequenceInProgress() const;
	bool IsShowPosingSpySuccessful() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IntroFlow">();
	}
	static class AIntroFlow* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIntroFlow>();
	}
};
static_assert(alignof(AIntroFlow) == 0x000008, "Wrong alignment on AIntroFlow");
static_assert(sizeof(AIntroFlow) == 0x0002F0, "Wrong size on AIntroFlow");
static_assert(offsetof(AIntroFlow, ForcedPosingSpyAnimation) == 0x000220, "Member 'AIntroFlow::ForcedPosingSpyAnimation' has a wrong offset!");
static_assert(offsetof(AIntroFlow, PosingSpyContainerClassParam) == 0x000228, "Member 'AIntroFlow::PosingSpyContainerClassParam' has a wrong offset!");
static_assert(offsetof(AIntroFlow, Camera) == 0x000230, "Member 'AIntroFlow::Camera' has a wrong offset!");
static_assert(offsetof(AIntroFlow, CameraLookHeightOffset) == 0x000238, "Member 'AIntroFlow::CameraLookHeightOffset' has a wrong offset!");
static_assert(offsetof(AIntroFlow, CameraDistanceOffset) == 0x00023C, "Member 'AIntroFlow::CameraDistanceOffset' has a wrong offset!");
static_assert(offsetof(AIntroFlow, CameraDistanceOffsetEnd) == 0x000240, "Member 'AIntroFlow::CameraDistanceOffsetEnd' has a wrong offset!");
static_assert(offsetof(AIntroFlow, CameraHeightOffset) == 0x000244, "Member 'AIntroFlow::CameraHeightOffset' has a wrong offset!");
static_assert(offsetof(AIntroFlow, CameraZoomSpeedFactor) == 0x000248, "Member 'AIntroFlow::CameraZoomSpeedFactor' has a wrong offset!");
static_assert(offsetof(AIntroFlow, RecoverDelay) == 0x00024C, "Member 'AIntroFlow::RecoverDelay' has a wrong offset!");
static_assert(offsetof(AIntroFlow, CameraChangeDelay) == 0x000250, "Member 'AIntroFlow::CameraChangeDelay' has a wrong offset!");
static_assert(offsetof(AIntroFlow, CameraChangeDuration) == 0x000254, "Member 'AIntroFlow::CameraChangeDuration' has a wrong offset!");
static_assert(offsetof(AIntroFlow, CameraChangeInterpolationExp) == 0x000258, "Member 'AIntroFlow::CameraChangeInterpolationExp' has a wrong offset!");
static_assert(offsetof(AIntroFlow, CameraChangeSideOffset) == 0x00025C, "Member 'AIntroFlow::CameraChangeSideOffset' has a wrong offset!");
static_assert(offsetof(AIntroFlow, PosingSpyContainerClass) == 0x0002E0, "Member 'AIntroFlow::PosingSpyContainerClass' has a wrong offset!");
static_assert(offsetof(AIntroFlow, SpawnedPosingSpyContainer) == 0x0002E8, "Member 'AIntroFlow::SpawnedPosingSpyContainer' has a wrong offset!");

// Class DeceiveInc.InvestigationZoneActor
// 0x00A0 (0x02C0 - 0x0220)
class AInvestigationZoneActor final : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnTrapRegister;                                    // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTrapUnregister;                                  // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTrapTriggered;                                   // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USphereComponent*                       RegistrationCollisionShapeComp;                    // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   AbilityVictimEffect;                               // 0x0258(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EInteractableType>                     InteractableInteractTypeList;                      // 0x0280(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	ECollisionChannel                             CollisionChannel;                                  // 0x0290(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         TrapInZone;                                        // 0x0298(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         MaxHeightDiff;                                     // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AC[0x14];                                     // 0x02AC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void HandleComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void HandleInteractTrapTriggered(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void HandleTrapTriggered(class UHackTrapScannableComponent* Trap, class AActor* Victim);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InvestigationZoneActor">();
	}
	static class AInvestigationZoneActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInvestigationZoneActor>();
	}
};
static_assert(alignof(AInvestigationZoneActor) == 0x000008, "Wrong alignment on AInvestigationZoneActor");
static_assert(sizeof(AInvestigationZoneActor) == 0x0002C0, "Wrong size on AInvestigationZoneActor");
static_assert(offsetof(AInvestigationZoneActor, OnTrapRegister) == 0x000220, "Member 'AInvestigationZoneActor::OnTrapRegister' has a wrong offset!");
static_assert(offsetof(AInvestigationZoneActor, OnTrapUnregister) == 0x000230, "Member 'AInvestigationZoneActor::OnTrapUnregister' has a wrong offset!");
static_assert(offsetof(AInvestigationZoneActor, OnTrapTriggered) == 0x000240, "Member 'AInvestigationZoneActor::OnTrapTriggered' has a wrong offset!");
static_assert(offsetof(AInvestigationZoneActor, RegistrationCollisionShapeComp) == 0x000250, "Member 'AInvestigationZoneActor::RegistrationCollisionShapeComp' has a wrong offset!");
static_assert(offsetof(AInvestigationZoneActor, AbilityVictimEffect) == 0x000258, "Member 'AInvestigationZoneActor::AbilityVictimEffect' has a wrong offset!");
static_assert(offsetof(AInvestigationZoneActor, InteractableInteractTypeList) == 0x000280, "Member 'AInvestigationZoneActor::InteractableInteractTypeList' has a wrong offset!");
static_assert(offsetof(AInvestigationZoneActor, CollisionChannel) == 0x000290, "Member 'AInvestigationZoneActor::CollisionChannel' has a wrong offset!");
static_assert(offsetof(AInvestigationZoneActor, TrapInZone) == 0x000298, "Member 'AInvestigationZoneActor::TrapInZone' has a wrong offset!");
static_assert(offsetof(AInvestigationZoneActor, MaxHeightDiff) == 0x0002A8, "Member 'AInvestigationZoneActor::MaxHeightDiff' has a wrong offset!");

// Class DeceiveInc.JammerAoEActor
// 0x0010 (0x0338 - 0x0328)
class AJammerAoEActor final : public ABaseAoEActor
{
public:
	FMulticastInlineDelegateProperty_             OnActorJammedChanged;                              // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JammerAoEActor">();
	}
	static class AJammerAoEActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJammerAoEActor>();
	}
};
static_assert(alignof(AJammerAoEActor) == 0x000008, "Wrong alignment on AJammerAoEActor");
static_assert(sizeof(AJammerAoEActor) == 0x000338, "Wrong size on AJammerAoEActor");
static_assert(offsetof(AJammerAoEActor, OnActorJammedChanged) == 0x000328, "Member 'AJammerAoEActor::OnActorJammedChanged' has a wrong offset!");

// Class DeceiveInc.LarcinPassiveAbility
// 0x0078 (0x05A8 - 0x0530)
class ALarcinPassiveAbility final : public ABaseSpyPassiveAbility
{
public:
	TArray<EGameplayResourcesType>                StealPriorityList;                                 // 0x0530(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EGameplayResourcesType, struct FLarcinStealResourcesSettings> LarcinStealResourcesSettings;                      // 0x0540(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bDoDamageWhenUndercover;                           // 0x0590(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlowCoverWhenUndercover;                          // 0x0591(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlowCoverWhenNPCUndercover;                       // 0x0592(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnlyStealWhenUndercover;                          // 0x0593(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_594[0x4];                                      // 0x0594(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnNPCHit;                                          // 0x0598(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	void BP_OnLocalLarcinStoleResource(class AActor* VictimActor, EGameplayResourcesType InResourceType);
	void BP_OnLocalVictimOfLarcinSteal(class AActor* StealingLarcinActor, EGameplayResourcesType InResourceType);
	void HandleCoverChange(bool Undercover);
	void HandleLoadoutSpawnCompleteEvent(class UToolLoadoutComponent* LoadoutComponent);
	void HandleMeleeAttackImpactEvent(class AActor* Victim, const struct FVector& ImpactPoint, int32 ChargeLevel, float Damage, float ResultingHealthPercentage, EHitType HitType, const struct FMeleeHitConfirmedData& HitConfirmedData);
	void NotifyHitNPCMulticast(class AActor* Victim);
	void NotifySuccessfulStealNetMulticast(class AActor* Theft, class AActor* Victim, EGameplayResourcesType InResourceType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LarcinPassiveAbility">();
	}
	static class ALarcinPassiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALarcinPassiveAbility>();
	}
};
static_assert(alignof(ALarcinPassiveAbility) == 0x000008, "Wrong alignment on ALarcinPassiveAbility");
static_assert(sizeof(ALarcinPassiveAbility) == 0x0005A8, "Wrong size on ALarcinPassiveAbility");
static_assert(offsetof(ALarcinPassiveAbility, StealPriorityList) == 0x000530, "Member 'ALarcinPassiveAbility::StealPriorityList' has a wrong offset!");
static_assert(offsetof(ALarcinPassiveAbility, LarcinStealResourcesSettings) == 0x000540, "Member 'ALarcinPassiveAbility::LarcinStealResourcesSettings' has a wrong offset!");
static_assert(offsetof(ALarcinPassiveAbility, bDoDamageWhenUndercover) == 0x000590, "Member 'ALarcinPassiveAbility::bDoDamageWhenUndercover' has a wrong offset!");
static_assert(offsetof(ALarcinPassiveAbility, bBlowCoverWhenUndercover) == 0x000591, "Member 'ALarcinPassiveAbility::bBlowCoverWhenUndercover' has a wrong offset!");
static_assert(offsetof(ALarcinPassiveAbility, bBlowCoverWhenNPCUndercover) == 0x000592, "Member 'ALarcinPassiveAbility::bBlowCoverWhenNPCUndercover' has a wrong offset!");
static_assert(offsetof(ALarcinPassiveAbility, bOnlyStealWhenUndercover) == 0x000593, "Member 'ALarcinPassiveAbility::bOnlyStealWhenUndercover' has a wrong offset!");
static_assert(offsetof(ALarcinPassiveAbility, OnNPCHit) == 0x000598, "Member 'ALarcinPassiveAbility::OnNPCHit' has a wrong offset!");

// Class DeceiveInc.LarcinPassiveMod1_2Ability
// 0x0010 (0x0540 - 0x0530)
class ALarcinPassiveMod1_2Ability final : public ABaseSpyPassiveAbility
{
public:
	TArray<EGameplayResourcesType>                StealPriorityList;                                 // 0x0530(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void BP_OnLocalLarcinStoleResource(class AActor* Victim, EGameplayResourcesType InResourceType);
	void BP_OnLocalVictimOfLarcinSteal(class AActor* Victim, EGameplayResourcesType InResourceType);
	void HandleCoverBlownEvent(class ASpy* Spy);
	void NotifySuccessfulStealNetMulticast(class AActor* Larcin, class AActor* Victim, EGameplayResourcesType InResourceType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LarcinPassiveMod1_2Ability">();
	}
	static class ALarcinPassiveMod1_2Ability* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALarcinPassiveMod1_2Ability>();
	}
};
static_assert(alignof(ALarcinPassiveMod1_2Ability) == 0x000008, "Wrong alignment on ALarcinPassiveMod1_2Ability");
static_assert(sizeof(ALarcinPassiveMod1_2Ability) == 0x000540, "Wrong size on ALarcinPassiveMod1_2Ability");
static_assert(offsetof(ALarcinPassiveMod1_2Ability, StealPriorityList) == 0x000530, "Member 'ALarcinPassiveMod1_2Ability::StealPriorityList' has a wrong offset!");

// Class DeceiveInc.LevelArea
// 0x0078 (0x02D0 - 0x0258)
class ALevelArea final : public AVolume
{
public:
	uint8                                         Flags_0;                                           // 0x0258(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FObjectSpawnGroupContainer             ObjectSpawnGroupContainer;                         // 0x0260(0x0050)(Edit, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	class FText                                   AreaName;                                          // 0x02B0(0x0018)(Edit, NativeAccessSpecifierPublic)
	uint32                                        LevelAreaCRC;                                      // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetAreaName();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelArea">();
	}
	static class ALevelArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelArea>();
	}
};
static_assert(alignof(ALevelArea) == 0x000008, "Wrong alignment on ALevelArea");
static_assert(sizeof(ALevelArea) == 0x0002D0, "Wrong size on ALevelArea");
static_assert(offsetof(ALevelArea, Flags_0) == 0x000258, "Member 'ALevelArea::Flags_0' has a wrong offset!");
static_assert(offsetof(ALevelArea, ObjectSpawnGroupContainer) == 0x000260, "Member 'ALevelArea::ObjectSpawnGroupContainer' has a wrong offset!");
static_assert(offsetof(ALevelArea, AreaName) == 0x0002B0, "Member 'ALevelArea::AreaName' has a wrong offset!");
static_assert(offsetof(ALevelArea, LevelAreaCRC) == 0x0002C8, "Member 'ALevelArea::LevelAreaCRC' has a wrong offset!");

// Class DeceiveInc.LevelAreaSubsystem
// 0x0000 (0x0030 - 0x0030)
class ULevelAreaSubsystem final : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelAreaSubsystem">();
	}
	static class ULevelAreaSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelAreaSubsystem>();
	}
};
static_assert(alignof(ULevelAreaSubsystem) == 0x000008, "Wrong alignment on ULevelAreaSubsystem");
static_assert(sizeof(ULevelAreaSubsystem) == 0x000030, "Wrong size on ULevelAreaSubsystem");

// Class DeceiveInc.LimitedEventItemsDataAsset
// 0x0010 (0x0048 - 0x0038)
class ULimitedEventItemsDataAsset final : public UDIPrimaryDataAsset
{
public:
	TArray<struct FLimitedEventItemsInfo>         EventEntries;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimitedEventItemsDataAsset">();
	}
	static class ULimitedEventItemsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimitedEventItemsDataAsset>();
	}
};
static_assert(alignof(ULimitedEventItemsDataAsset) == 0x000008, "Wrong alignment on ULimitedEventItemsDataAsset");
static_assert(sizeof(ULimitedEventItemsDataAsset) == 0x000048, "Wrong size on ULimitedEventItemsDataAsset");
static_assert(offsetof(ULimitedEventItemsDataAsset, EventEntries) == 0x000038, "Member 'ULimitedEventItemsDataAsset::EventEntries' has a wrong offset!");

// Class DeceiveInc.LimitedEventXpProgressionData
// 0x0010 (0x0080 - 0x0070)
class ULimitedEventXpProgressionData final : public UXpProgressionData
{
public:
	class FString                                 LimitedEventId;                                    // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimitedEventXpProgressionData">();
	}
	static class ULimitedEventXpProgressionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimitedEventXpProgressionData>();
	}
};
static_assert(alignof(ULimitedEventXpProgressionData) == 0x000008, "Wrong alignment on ULimitedEventXpProgressionData");
static_assert(sizeof(ULimitedEventXpProgressionData) == 0x000080, "Wrong size on ULimitedEventXpProgressionData");
static_assert(offsetof(ULimitedEventXpProgressionData, LimitedEventId) == 0x000070, "Member 'ULimitedEventXpProgressionData::LimitedEventId' has a wrong offset!");

// Class DeceiveInc.LocalSpyEventBus
// 0x02D0 (0x02F8 - 0x0028)
class ULocalSpyEventBus final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnNewSpySpawnedEvent;                              // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyDespawningEvent;                              // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyInputEnabledEvent;                            // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyInputDisabledEvent;                           // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnResourceNewAmountEvent;                          // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnResourceAmountChangedEvent;                      // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCoverBlownEvent;                                 // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCoverRegainedEvent;                              // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIntroCoverRegainedEvent;                         // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponProjectileImpact;                          // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponHitConfirmed;                              // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMeleeImpact;                                     // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyInVaultChanged;                               // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyRoomChanged;                                  // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCoverChanged;                                    // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNavModeBeginEvent;                               // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNavModeEndEvent;                                 // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHealthChangedEvent;                              // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerNameChangedEvent;                          // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpectatingPlayerChangeEvent;                     // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAutoSpectatingChangeEvent;                       // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnKillcamPlaybackChangeEvent;                      // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnObjectivePickedUpEvent;                          // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnObjectiveDroppedEvent;                           // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDirectionalDamageReceived;                       // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLoadoutSpawnComplete;                            // 0x01B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPoudrierVisibilityChangeEvent;                   // 0x01C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFallLand;                                        // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractCancelEvent;                             // 0x01E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIntroCameraDoneEvent;                            // 0x01F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponAmmoStateChangeEvent;                      // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponAllowedChangeEvent;                        // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponChargeChangeEvent;                         // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponChargeEvent;                               // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponShootEvent;                                // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyDeathEvent;                                   // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyDeathSequenceEndEvent;                        // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyRevivalEvent;                                 // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyFactionEliminationEvent;                      // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyMovementEvent;                                // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyNewHeadingEvent;                              // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharmedChange;                                   // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharmBroken;                                     // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReceivedXPEvent;                                 // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnConfirmKill;                                     // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void BP_FireOnCharmBrokenEvent();
	void SpyEventDelegate_AutoSpectatingChange__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, bool bAutoSpectating);
	void SpyEventDelegate_CancelInteract__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, EInteractCancelType InteractCancelType);
	void SpyEventDelegate_CharmBroken__DelegateSignature();
	void SpyEventDelegate_CharmedChange__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, bool bIsCharmed);
	void SpyEventDelegate_ConfirmKill__DelegateSignature(class ASpy* Spy, class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);
	void SpyEventDelegate_CoverChanged__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, class ANPCCharacter* NewDisguise, bool bIsFirstDisguise);
	void SpyEventDelegate_DirectionalDamageReceived__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, float Damage, const struct FVector& ShotFromDirection, EHitType HitType);
	void SpyEventDelegate_FallLand__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, int32 FallStep, int32 FallDamageAmount);
	void SpyEventDelegate_Generic__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy);
	void SpyEventDelegate_HeadingChange__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, float NewHeading);
	void SpyEventDelegate_IntroFlow__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, class AIntroFlow* IntroFlowActor);
	void SpyEventDelegate_InVaultChanged__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, bool bInVault);
	void SpyEventDelegate_KillcamPlaybackChange__DelegateSignature(class ADeceiveIncPlayerController* PlayerController);
	void SpyEventDelegate_LoadoutSpawnComplete__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class UToolLoadoutComponent* ToolLoadout);
	void SpyEventDelegate_MeleeImpact__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, class AActor* Victim, const struct FVector& ImpactPoint, int32 ChargeLevel, float Damage, float ResultingHealthPercentage, EHitType HitType);
	void SpyEventDelegate_MovementEvent__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, EMovementEventType MovementEventType);
	void SpyEventDelegate_PlayerNameChanged__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, const class FString& PlayerName);
	void SpyEventDelegate_PoudrierVisibilityChange__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, bool bVisible);
	void SpyEventDelegate_ReceivedXPEvent__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, EDIXPEvent XPEventType, int32 AddedXP);
	void SpyEventDelegate_ResourceAmountChanged__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, EGameplayResourcesType AffectedResource, int32 NewResourceCount, int32 AmountDelta);
	void SpyEventDelegate_ResourceNewAmount__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, EGameplayResourcesType AffectedResource, int32 NewResourceCount);
	void SpyEventDelegate_RoomChanged__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, class ARoomVolume* InRoom);
	void SpyEventDelegate_SpectatingPlayerChange__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class AActor* SpectatingActor, class ADIPlayerState* SpectatingPlayerState);
	void SpyEventDelegate_WeaponAllowedChange__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, class AProjectileWeapon* Weapon, bool bIsAllowed);
	void SpyEventDelegate_WeaponAmmoStateChange__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, class AProjectileWeapon* Weapon, EWeaponAmmoState AmmoState);
	void SpyEventDelegate_WeaponChargeChange__DelegateSignature(class ASpy* Spy, class AProjectileWeapon* Weapon, bool bIsCharging, float MaxChargingTime);
	void SpyEventDelegate_WeaponHitConfirmedEvent__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, const struct FHitConfirmData& HitConfirmedData);
	void SpyEventDelegate_WeaponProjectileImpact__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, const struct FWeaponImpactData& WeaponImpactData);
	void SpyEventDelegate_WeaponShoot__DelegateSignature(class ASpy* Spy, class AProjectileWeapon* Weapon, const struct FVector& OriginPos, const struct FVector& DestinationPos);
	void SpyEventDeletgate_HealthChanged__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, class UHealthComponent* SpyHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& DamageDirection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalSpyEventBus">();
	}
	static class ULocalSpyEventBus* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalSpyEventBus>();
	}
};
static_assert(alignof(ULocalSpyEventBus) == 0x000008, "Wrong alignment on ULocalSpyEventBus");
static_assert(sizeof(ULocalSpyEventBus) == 0x0002F8, "Wrong size on ULocalSpyEventBus");
static_assert(offsetof(ULocalSpyEventBus, OnNewSpySpawnedEvent) == 0x000028, "Member 'ULocalSpyEventBus::OnNewSpySpawnedEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnSpyDespawningEvent) == 0x000038, "Member 'ULocalSpyEventBus::OnSpyDespawningEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnSpyInputEnabledEvent) == 0x000048, "Member 'ULocalSpyEventBus::OnSpyInputEnabledEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnSpyInputDisabledEvent) == 0x000058, "Member 'ULocalSpyEventBus::OnSpyInputDisabledEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnResourceNewAmountEvent) == 0x000068, "Member 'ULocalSpyEventBus::OnResourceNewAmountEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnResourceAmountChangedEvent) == 0x000078, "Member 'ULocalSpyEventBus::OnResourceAmountChangedEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnCoverBlownEvent) == 0x000088, "Member 'ULocalSpyEventBus::OnCoverBlownEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnCoverRegainedEvent) == 0x000098, "Member 'ULocalSpyEventBus::OnCoverRegainedEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnIntroCoverRegainedEvent) == 0x0000A8, "Member 'ULocalSpyEventBus::OnIntroCoverRegainedEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnWeaponProjectileImpact) == 0x0000B8, "Member 'ULocalSpyEventBus::OnWeaponProjectileImpact' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnWeaponHitConfirmed) == 0x0000C8, "Member 'ULocalSpyEventBus::OnWeaponHitConfirmed' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnMeleeImpact) == 0x0000D8, "Member 'ULocalSpyEventBus::OnMeleeImpact' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnSpyInVaultChanged) == 0x0000E8, "Member 'ULocalSpyEventBus::OnSpyInVaultChanged' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnSpyRoomChanged) == 0x0000F8, "Member 'ULocalSpyEventBus::OnSpyRoomChanged' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnCoverChanged) == 0x000108, "Member 'ULocalSpyEventBus::OnCoverChanged' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnNavModeBeginEvent) == 0x000118, "Member 'ULocalSpyEventBus::OnNavModeBeginEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnNavModeEndEvent) == 0x000128, "Member 'ULocalSpyEventBus::OnNavModeEndEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnHealthChangedEvent) == 0x000138, "Member 'ULocalSpyEventBus::OnHealthChangedEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnPlayerNameChangedEvent) == 0x000148, "Member 'ULocalSpyEventBus::OnPlayerNameChangedEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnSpectatingPlayerChangeEvent) == 0x000158, "Member 'ULocalSpyEventBus::OnSpectatingPlayerChangeEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnAutoSpectatingChangeEvent) == 0x000168, "Member 'ULocalSpyEventBus::OnAutoSpectatingChangeEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnKillcamPlaybackChangeEvent) == 0x000178, "Member 'ULocalSpyEventBus::OnKillcamPlaybackChangeEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnObjectivePickedUpEvent) == 0x000188, "Member 'ULocalSpyEventBus::OnObjectivePickedUpEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnObjectiveDroppedEvent) == 0x000198, "Member 'ULocalSpyEventBus::OnObjectiveDroppedEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnDirectionalDamageReceived) == 0x0001A8, "Member 'ULocalSpyEventBus::OnDirectionalDamageReceived' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnLoadoutSpawnComplete) == 0x0001B8, "Member 'ULocalSpyEventBus::OnLoadoutSpawnComplete' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnPoudrierVisibilityChangeEvent) == 0x0001C8, "Member 'ULocalSpyEventBus::OnPoudrierVisibilityChangeEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnFallLand) == 0x0001D8, "Member 'ULocalSpyEventBus::OnFallLand' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnInteractCancelEvent) == 0x0001E8, "Member 'ULocalSpyEventBus::OnInteractCancelEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnIntroCameraDoneEvent) == 0x0001F8, "Member 'ULocalSpyEventBus::OnIntroCameraDoneEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnWeaponAmmoStateChangeEvent) == 0x000208, "Member 'ULocalSpyEventBus::OnWeaponAmmoStateChangeEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnWeaponAllowedChangeEvent) == 0x000218, "Member 'ULocalSpyEventBus::OnWeaponAllowedChangeEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnWeaponChargeChangeEvent) == 0x000228, "Member 'ULocalSpyEventBus::OnWeaponChargeChangeEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnWeaponChargeEvent) == 0x000238, "Member 'ULocalSpyEventBus::OnWeaponChargeEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnWeaponShootEvent) == 0x000248, "Member 'ULocalSpyEventBus::OnWeaponShootEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnSpyDeathEvent) == 0x000258, "Member 'ULocalSpyEventBus::OnSpyDeathEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnSpyDeathSequenceEndEvent) == 0x000268, "Member 'ULocalSpyEventBus::OnSpyDeathSequenceEndEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnSpyRevivalEvent) == 0x000278, "Member 'ULocalSpyEventBus::OnSpyRevivalEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnSpyFactionEliminationEvent) == 0x000288, "Member 'ULocalSpyEventBus::OnSpyFactionEliminationEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnSpyMovementEvent) == 0x000298, "Member 'ULocalSpyEventBus::OnSpyMovementEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnSpyNewHeadingEvent) == 0x0002A8, "Member 'ULocalSpyEventBus::OnSpyNewHeadingEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnCharmedChange) == 0x0002B8, "Member 'ULocalSpyEventBus::OnCharmedChange' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnCharmBroken) == 0x0002C8, "Member 'ULocalSpyEventBus::OnCharmBroken' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnReceivedXPEvent) == 0x0002D8, "Member 'ULocalSpyEventBus::OnReceivedXPEvent' has a wrong offset!");
static_assert(offsetof(ULocalSpyEventBus, OnConfirmKill) == 0x0002E8, "Member 'ULocalSpyEventBus::OnConfirmKill' has a wrong offset!");

// Class DeceiveInc.LootItemShowcase
// 0x0180 (0x03A0 - 0x0220)
class ALootItemShowcase final : public AActor
{
public:
	TSubclassOf<class AActor>                     PosingSpyContainerClass;                           // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     CallingCardClass;                                  // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     WrapSprayCanClass;                                 // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     AvatarClass;                                       // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     GenericItemClass;                                  // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Mesh;                                              // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        PosingSpySocket;                                   // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        CallingCardSocket;                                 // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        WrapSprayCanSocket;                                // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        AvatarSocket;                                      // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        GenericItemSocket;                                 // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        HoverWidgetSocket;                                 // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       PedestalCamera;                                    // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        SpySkinCameraRef;                                  // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        SmallerItemsCameraRef;                             // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ItemTypeNameSkinBundle;                            // 0x0298(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ItemTypeNameIntroPose;                             // 0x02B0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ItemTypeNameAvatar;                                // 0x02C8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ItemTypeNameWrap;                                  // 0x02E0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ItemTypeNameCallingCard;                           // 0x02F8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   RarityName1;                                       // 0x0310(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   RarityName2;                                       // 0x0328(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   RarityName3;                                       // 0x0340(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   RarityName4;                                       // 0x0358(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_370[0x30];                                     // 0x0370(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnClaimedItemResponseSet(const struct FClaimedItemResponse& NewClaimedItemResponse, class UDIItem* ItemIn);
	void EnableItemRotation(bool bEnable);

	class UTexture2D* GetAvatarTexture2D() const;
	struct FClaimedItemResponse GetClaimedItemResponse() const;
	class UCameraComponent* GetFocusCamera() const;
	struct FVector GetHoverWidgetRefPos() const;
	class UDIItem* GetItem() const;
	class FText GetItemDisplayName() const;
	int32 GetItemRarity() const;
	class FText GetItemRarityDisplayName() const;
	class FText GetItemTypeDisplayName() const;
	class AActor* GetItemVisualRepresentation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LootItemShowcase">();
	}
	static class ALootItemShowcase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALootItemShowcase>();
	}
};
static_assert(alignof(ALootItemShowcase) == 0x000008, "Wrong alignment on ALootItemShowcase");
static_assert(sizeof(ALootItemShowcase) == 0x0003A0, "Wrong size on ALootItemShowcase");
static_assert(offsetof(ALootItemShowcase, PosingSpyContainerClass) == 0x000220, "Member 'ALootItemShowcase::PosingSpyContainerClass' has a wrong offset!");
static_assert(offsetof(ALootItemShowcase, CallingCardClass) == 0x000228, "Member 'ALootItemShowcase::CallingCardClass' has a wrong offset!");
static_assert(offsetof(ALootItemShowcase, WrapSprayCanClass) == 0x000230, "Member 'ALootItemShowcase::WrapSprayCanClass' has a wrong offset!");
static_assert(offsetof(ALootItemShowcase, AvatarClass) == 0x000238, "Member 'ALootItemShowcase::AvatarClass' has a wrong offset!");
static_assert(offsetof(ALootItemShowcase, GenericItemClass) == 0x000240, "Member 'ALootItemShowcase::GenericItemClass' has a wrong offset!");
static_assert(offsetof(ALootItemShowcase, Mesh) == 0x000248, "Member 'ALootItemShowcase::Mesh' has a wrong offset!");
static_assert(offsetof(ALootItemShowcase, PosingSpySocket) == 0x000250, "Member 'ALootItemShowcase::PosingSpySocket' has a wrong offset!");
static_assert(offsetof(ALootItemShowcase, CallingCardSocket) == 0x000258, "Member 'ALootItemShowcase::CallingCardSocket' has a wrong offset!");
static_assert(offsetof(ALootItemShowcase, WrapSprayCanSocket) == 0x000260, "Member 'ALootItemShowcase::WrapSprayCanSocket' has a wrong offset!");
static_assert(offsetof(ALootItemShowcase, AvatarSocket) == 0x000268, "Member 'ALootItemShowcase::AvatarSocket' has a wrong offset!");
static_assert(offsetof(ALootItemShowcase, GenericItemSocket) == 0x000270, "Member 'ALootItemShowcase::GenericItemSocket' has a wrong offset!");
static_assert(offsetof(ALootItemShowcase, HoverWidgetSocket) == 0x000278, "Member 'ALootItemShowcase::HoverWidgetSocket' has a wrong offset!");
static_assert(offsetof(ALootItemShowcase, PedestalCamera) == 0x000280, "Member 'ALootItemShowcase::PedestalCamera' has a wrong offset!");
static_assert(offsetof(ALootItemShowcase, SpySkinCameraRef) == 0x000288, "Member 'ALootItemShowcase::SpySkinCameraRef' has a wrong offset!");
static_assert(offsetof(ALootItemShowcase, SmallerItemsCameraRef) == 0x000290, "Member 'ALootItemShowcase::SmallerItemsCameraRef' has a wrong offset!");
static_assert(offsetof(ALootItemShowcase, ItemTypeNameSkinBundle) == 0x000298, "Member 'ALootItemShowcase::ItemTypeNameSkinBundle' has a wrong offset!");
static_assert(offsetof(ALootItemShowcase, ItemTypeNameIntroPose) == 0x0002B0, "Member 'ALootItemShowcase::ItemTypeNameIntroPose' has a wrong offset!");
static_assert(offsetof(ALootItemShowcase, ItemTypeNameAvatar) == 0x0002C8, "Member 'ALootItemShowcase::ItemTypeNameAvatar' has a wrong offset!");
static_assert(offsetof(ALootItemShowcase, ItemTypeNameWrap) == 0x0002E0, "Member 'ALootItemShowcase::ItemTypeNameWrap' has a wrong offset!");
static_assert(offsetof(ALootItemShowcase, ItemTypeNameCallingCard) == 0x0002F8, "Member 'ALootItemShowcase::ItemTypeNameCallingCard' has a wrong offset!");
static_assert(offsetof(ALootItemShowcase, RarityName1) == 0x000310, "Member 'ALootItemShowcase::RarityName1' has a wrong offset!");
static_assert(offsetof(ALootItemShowcase, RarityName2) == 0x000328, "Member 'ALootItemShowcase::RarityName2' has a wrong offset!");
static_assert(offsetof(ALootItemShowcase, RarityName3) == 0x000340, "Member 'ALootItemShowcase::RarityName3' has a wrong offset!");
static_assert(offsetof(ALootItemShowcase, RarityName4) == 0x000358, "Member 'ALootItemShowcase::RarityName4' has a wrong offset!");

// Class DeceiveInc.MapData
// 0x0108 (0x0140 - 0x0038)
class UMapData final : public UDIPrimaryDataAsset
{
public:
	class FString                                 MapFileName;                                       // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapCode;                                           // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   MapDisplayName;                                    // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UPregameLobbyMapData*                   PregameLobbyMapData;                               // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpyGameModeMapData*                    SpyGameModeMapData;                                // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              MapLoadingImage;                                   // 0x0080(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   MapFlavor;                                         // 0x00A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         MapNorthYawAngle;                                  // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      PreviewMapMaterial;                                // 0x00C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      PreviewVillainMaterial;                            // 0x00F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      PreviewTitleMaterial;                              // 0x0118(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapData">();
	}
	static class UMapData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapData>();
	}
};
static_assert(alignof(UMapData) == 0x000008, "Wrong alignment on UMapData");
static_assert(sizeof(UMapData) == 0x000140, "Wrong size on UMapData");
static_assert(offsetof(UMapData, MapFileName) == 0x000038, "Member 'UMapData::MapFileName' has a wrong offset!");
static_assert(offsetof(UMapData, MapCode) == 0x000048, "Member 'UMapData::MapCode' has a wrong offset!");
static_assert(offsetof(UMapData, MapDisplayName) == 0x000058, "Member 'UMapData::MapDisplayName' has a wrong offset!");
static_assert(offsetof(UMapData, PregameLobbyMapData) == 0x000070, "Member 'UMapData::PregameLobbyMapData' has a wrong offset!");
static_assert(offsetof(UMapData, SpyGameModeMapData) == 0x000078, "Member 'UMapData::SpyGameModeMapData' has a wrong offset!");
static_assert(offsetof(UMapData, MapLoadingImage) == 0x000080, "Member 'UMapData::MapLoadingImage' has a wrong offset!");
static_assert(offsetof(UMapData, MapFlavor) == 0x0000A8, "Member 'UMapData::MapFlavor' has a wrong offset!");
static_assert(offsetof(UMapData, MapNorthYawAngle) == 0x0000C0, "Member 'UMapData::MapNorthYawAngle' has a wrong offset!");
static_assert(offsetof(UMapData, PreviewMapMaterial) == 0x0000C8, "Member 'UMapData::PreviewMapMaterial' has a wrong offset!");
static_assert(offsetof(UMapData, PreviewVillainMaterial) == 0x0000F0, "Member 'UMapData::PreviewVillainMaterial' has a wrong offset!");
static_assert(offsetof(UMapData, PreviewTitleMaterial) == 0x000118, "Member 'UMapData::PreviewTitleMaterial' has a wrong offset!");

// Class DeceiveInc.MaxHealthConditionComponent
// 0x0008 (0x00D8 - 0x00D0)
class UMaxHealthConditionComponent final : public UBaseConditionComponent
{
public:
	float                                         MaxHealthAmount;                                   // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          GreaterThan;                                       // 0x00D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Equals;                                            // 0x00D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          LessThan;                                          // 0x00D6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D7[0x1];                                       // 0x00D7(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaxHealthConditionComponent">();
	}
	static class UMaxHealthConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaxHealthConditionComponent>();
	}
};
static_assert(alignof(UMaxHealthConditionComponent) == 0x000008, "Wrong alignment on UMaxHealthConditionComponent");
static_assert(sizeof(UMaxHealthConditionComponent) == 0x0000D8, "Wrong size on UMaxHealthConditionComponent");
static_assert(offsetof(UMaxHealthConditionComponent, MaxHealthAmount) == 0x0000D0, "Member 'UMaxHealthConditionComponent::MaxHealthAmount' has a wrong offset!");
static_assert(offsetof(UMaxHealthConditionComponent, GreaterThan) == 0x0000D4, "Member 'UMaxHealthConditionComponent::GreaterThan' has a wrong offset!");
static_assert(offsetof(UMaxHealthConditionComponent, Equals) == 0x0000D5, "Member 'UMaxHealthConditionComponent::Equals' has a wrong offset!");
static_assert(offsetof(UMaxHealthConditionComponent, LessThan) == 0x0000D6, "Member 'UMaxHealthConditionComponent::LessThan' has a wrong offset!");

// Class DeceiveInc.MaxUseConditionComponent
// 0x0078 (0x0148 - 0x00D0)
class UMaxUseConditionComponent final : public UBaseConditionComponent
{
public:
	int32                                         MaxUseCount;                                       // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPerPlayer;                                        // 0x00D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPerFaction;                                       // 0x00D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D6[0x2];                                       // 0x00D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FReplicatedPlayerUseLeft>       ReplicatedPlayerUseLeft;                           // 0x00D8(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x50];                                      // 0x00E8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMaxUseChanged;                                   // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void OnRep_PlayerUseLeft();
	void Reset();
	bool ResetForPlayer(class AActor* PlayerActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaxUseConditionComponent">();
	}
	static class UMaxUseConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaxUseConditionComponent>();
	}
};
static_assert(alignof(UMaxUseConditionComponent) == 0x000008, "Wrong alignment on UMaxUseConditionComponent");
static_assert(sizeof(UMaxUseConditionComponent) == 0x000148, "Wrong size on UMaxUseConditionComponent");
static_assert(offsetof(UMaxUseConditionComponent, MaxUseCount) == 0x0000D0, "Member 'UMaxUseConditionComponent::MaxUseCount' has a wrong offset!");
static_assert(offsetof(UMaxUseConditionComponent, bPerPlayer) == 0x0000D4, "Member 'UMaxUseConditionComponent::bPerPlayer' has a wrong offset!");
static_assert(offsetof(UMaxUseConditionComponent, bPerFaction) == 0x0000D5, "Member 'UMaxUseConditionComponent::bPerFaction' has a wrong offset!");
static_assert(offsetof(UMaxUseConditionComponent, ReplicatedPlayerUseLeft) == 0x0000D8, "Member 'UMaxUseConditionComponent::ReplicatedPlayerUseLeft' has a wrong offset!");
static_assert(offsetof(UMaxUseConditionComponent, OnMaxUseChanged) == 0x000138, "Member 'UMaxUseConditionComponent::OnMaxUseChanged' has a wrong offset!");

// Class DeceiveInc.MenuData
// 0x01F8 (0x0230 - 0x0038)
class UMenuData final : public UDIPrimaryDataAsset
{
public:
	TMap<EMenuType, TSoftClassPtr<class UClass>>  MenuWidgetClasses;                                 // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<ESubMenuPages, TSoftClassPtr<class UClass>> SubMenuWidgetClasses;                              // 0x0088(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EPopupType, TSoftClassPtr<class UClass>> PopupWidgetClasses;                                // 0x00D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EDescribeMatchmakingStatus, class FText> MatchmakingStatusText;                             // 0x0128(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EMatchmakingError, class FText>          MatchmakingErrorText;                              // 0x0178(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FPlayerSettingEntry>            GeneralPlayerSettings;                             // 0x01C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerSettingEntry>            ControlsPlayerSettings;                            // 0x01D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerSettingEntry>            AudioPlayerSettings;                               // 0x01E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerSettingEntry>            GraphicsPlayerSettings;                            // 0x01F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerSettingEntry>            PrivateLobbyAdvanceSettings;                       // 0x0208(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   SkipTutorialPopupText;                             // 0x0218(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	TSubclassOf<class UUserWidget> GetMenuWidgetClass(EMenuType MenuType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuData">();
	}
	static class UMenuData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuData>();
	}
};
static_assert(alignof(UMenuData) == 0x000008, "Wrong alignment on UMenuData");
static_assert(sizeof(UMenuData) == 0x000230, "Wrong size on UMenuData");
static_assert(offsetof(UMenuData, MenuWidgetClasses) == 0x000038, "Member 'UMenuData::MenuWidgetClasses' has a wrong offset!");
static_assert(offsetof(UMenuData, SubMenuWidgetClasses) == 0x000088, "Member 'UMenuData::SubMenuWidgetClasses' has a wrong offset!");
static_assert(offsetof(UMenuData, PopupWidgetClasses) == 0x0000D8, "Member 'UMenuData::PopupWidgetClasses' has a wrong offset!");
static_assert(offsetof(UMenuData, MatchmakingStatusText) == 0x000128, "Member 'UMenuData::MatchmakingStatusText' has a wrong offset!");
static_assert(offsetof(UMenuData, MatchmakingErrorText) == 0x000178, "Member 'UMenuData::MatchmakingErrorText' has a wrong offset!");
static_assert(offsetof(UMenuData, GeneralPlayerSettings) == 0x0001C8, "Member 'UMenuData::GeneralPlayerSettings' has a wrong offset!");
static_assert(offsetof(UMenuData, ControlsPlayerSettings) == 0x0001D8, "Member 'UMenuData::ControlsPlayerSettings' has a wrong offset!");
static_assert(offsetof(UMenuData, AudioPlayerSettings) == 0x0001E8, "Member 'UMenuData::AudioPlayerSettings' has a wrong offset!");
static_assert(offsetof(UMenuData, GraphicsPlayerSettings) == 0x0001F8, "Member 'UMenuData::GraphicsPlayerSettings' has a wrong offset!");
static_assert(offsetof(UMenuData, PrivateLobbyAdvanceSettings) == 0x000208, "Member 'UMenuData::PrivateLobbyAdvanceSettings' has a wrong offset!");
static_assert(offsetof(UMenuData, SkipTutorialPopupText) == 0x000218, "Member 'UMenuData::SkipTutorialPopupText' has a wrong offset!");

// Class DeceiveInc.MessageUserWidget
// 0x0128 (0x0388 - 0x0260)
class UMessageUserWidget final : public UUserWidget
{
public:
	struct FDIMessageSettings                     MessageSettings;                                   // 0x0260(0x0128)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UMessageUserWidget* CreateMessageWidget(const struct FDIMessageSettings& InMessageSettings);

	void BP_OnRedraw();
	void DoClickedAction();
	TSoftObjectPtr<class UTexture> ImageAsset();
	void Redraw();
	void SetMessageSettings(const struct FDIMessageSettings& InMessageSettings);

	class FString GetExtraData() const;
	class FText GetText() const;
	class FText GetTitle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MessageUserWidget">();
	}
	static class UMessageUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMessageUserWidget>();
	}
};
static_assert(alignof(UMessageUserWidget) == 0x000008, "Wrong alignment on UMessageUserWidget");
static_assert(sizeof(UMessageUserWidget) == 0x000388, "Wrong size on UMessageUserWidget");
static_assert(offsetof(UMessageUserWidget, MessageSettings) == 0x000260, "Member 'UMessageUserWidget::MessageSettings' has a wrong offset!");

// Class DeceiveInc.VictimEffectTickBehavior_Fear
// 0x0000 (0x0030 - 0x0030)
class UVictimEffectTickBehavior_Fear final : public UVictimEffectTickBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VictimEffectTickBehavior_Fear">();
	}
	static class UVictimEffectTickBehavior_Fear* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVictimEffectTickBehavior_Fear>();
	}
};
static_assert(alignof(UVictimEffectTickBehavior_Fear) == 0x000008, "Wrong alignment on UVictimEffectTickBehavior_Fear");
static_assert(sizeof(UVictimEffectTickBehavior_Fear) == 0x000030, "Wrong size on UVictimEffectTickBehavior_Fear");

// Class DeceiveInc.MimicScannableComponent
// 0x0010 (0x0270 - 0x0260)
class UMimicScannableComponent final : public UScannableComponent
{
public:
	TSubclassOf<class AActor>                     ActorToMimic;                                      // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMimicScannerTool*                      LocalScannerInRange;                               // 0x0268(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnSpyToolLoadComplete(class UToolLoadoutComponent* ToolLoadout);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MimicScannableComponent">();
	}
	static class UMimicScannableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMimicScannableComponent>();
	}
};
static_assert(alignof(UMimicScannableComponent) == 0x000010, "Wrong alignment on UMimicScannableComponent");
static_assert(sizeof(UMimicScannableComponent) == 0x000270, "Wrong size on UMimicScannableComponent");
static_assert(offsetof(UMimicScannableComponent, ActorToMimic) == 0x000260, "Member 'UMimicScannableComponent::ActorToMimic' has a wrong offset!");
static_assert(offsetof(UMimicScannableComponent, LocalScannerInRange) == 0x000268, "Member 'UMimicScannableComponent::LocalScannerInRange' has a wrong offset!");

// Class DeceiveInc.MimicScannerTool
// 0x0068 (0x0618 - 0x05B0)
class AMimicScannerTool final : public ABaseScannerTool
{
public:
	class FText                                   ToolPrimaryMimicActionText;                        // 0x05B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class ABaseMimicScannableActor*               SpawnedMimic;                                      // 0x05C8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   BaseMimicMesh;                                     // 0x05D0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterMovementComponent*            CharacterMovementComp;                             // 0x05D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   ActorToMimicClass;                                 // 0x05E0(0x0028)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_608[0x10];                                     // 0x0608(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleCoverAffectingSourceChange(ECoverAffectingSourceType NewCoverAffectingType, bool bAdded);
	void HandleOutOfMimic();
	void NetMulticast_ToggleMimicRotation(bool bRotate);
	void NetMulticast_TransformToMimic();
	void OnRep_NewSpawnedMimic();
	void Server_ToggleMimicRotation(bool bRotate);
	void Server_TransformToMimic();

	bool IsInMimic() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MimicScannerTool">();
	}
	static class AMimicScannerTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMimicScannerTool>();
	}
};
static_assert(alignof(AMimicScannerTool) == 0x000008, "Wrong alignment on AMimicScannerTool");
static_assert(sizeof(AMimicScannerTool) == 0x000618, "Wrong size on AMimicScannerTool");
static_assert(offsetof(AMimicScannerTool, ToolPrimaryMimicActionText) == 0x0005B0, "Member 'AMimicScannerTool::ToolPrimaryMimicActionText' has a wrong offset!");
static_assert(offsetof(AMimicScannerTool, SpawnedMimic) == 0x0005C8, "Member 'AMimicScannerTool::SpawnedMimic' has a wrong offset!");
static_assert(offsetof(AMimicScannerTool, BaseMimicMesh) == 0x0005D0, "Member 'AMimicScannerTool::BaseMimicMesh' has a wrong offset!");
static_assert(offsetof(AMimicScannerTool, CharacterMovementComp) == 0x0005D8, "Member 'AMimicScannerTool::CharacterMovementComp' has a wrong offset!");
static_assert(offsetof(AMimicScannerTool, ActorToMimicClass) == 0x0005E0, "Member 'AMimicScannerTool::ActorToMimicClass' has a wrong offset!");

// Class DeceiveInc.MirrorBotBrain
// 0x0018 (0x0090 - 0x0078)
class UMirrorBotBrain final : public UBotBrain
{
public:
	uint8                                         Pad_78[0x18];                                      // 0x0078(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLocalMeleeEvent(ESpyToolEvent EventType, class ABaseSpyTool* SpyTool);
	void OnLocalPlayerCoverBlown(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy);
	void OnLocalPlayerCoverRegainedEvent(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy);
	void OnLocalPlayerJump();
	void OnLocalWeaponEvent(ESpyToolEvent EventType, class ABaseSpyTool* SpyTool);
	void OnSwitchTool(class ABaseSpyTool* SpyTool, ELoadoutSlot Slot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MirrorBotBrain">();
	}
	static class UMirrorBotBrain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMirrorBotBrain>();
	}
};
static_assert(alignof(UMirrorBotBrain) == 0x000008, "Wrong alignment on UMirrorBotBrain");
static_assert(sizeof(UMirrorBotBrain) == 0x000090, "Wrong size on UMirrorBotBrain");

// Class DeceiveInc.ModsVariantMediaDataAsset
// 0x0050 (0x0088 - 0x0038)
class UModsVariantMediaDataAsset final : public UDIPrimaryDataAsset
{
public:
	TMap<class UDIPrimaryDataAsset*, class UMediaSource*> VariantsMediaSourceMap;                            // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModsVariantMediaDataAsset">();
	}
	static class UModsVariantMediaDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModsVariantMediaDataAsset>();
	}
};
static_assert(alignof(UModsVariantMediaDataAsset) == 0x000008, "Wrong alignment on UModsVariantMediaDataAsset");
static_assert(sizeof(UModsVariantMediaDataAsset) == 0x000088, "Wrong size on UModsVariantMediaDataAsset");
static_assert(offsetof(UModsVariantMediaDataAsset, VariantsMediaSourceMap) == 0x000038, "Member 'UModsVariantMediaDataAsset::VariantsMediaSourceMap' has a wrong offset!");

// Class DeceiveInc.NavModeItemComponent
// 0x00B0 (0x02B0 - 0x0200)
class UNavModeItemComponent final : public USceneComponent
{
public:
	FMulticastInlineDelegateProperty_             OnNavModeItemShowedChanged;                        // 0x01F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNavModeItemSelectedChanged;                      // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWidgetSpawned;                                   // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ENavModeItemType                              NavModeItemType;                                   // 0x0228(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   NavModeIconAsset;                                  // 0x0230(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                NavModeIconOffset;                                 // 0x0258(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowInAllPhases;                                  // 0x0264(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRegisterOnBeginPlay;                              // 0x0265(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_266[0x2];                                      // 0x0266(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ESpyGamePhase>                         PhaseToShow;                                       // 0x0268(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UDIUserWidget*                          NavModeIcon;                                       // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDIWidgetComponent*                     NavModeIconWC;                                     // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinSquaredDistanceToUnselect;                      // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RaycastPenetrationThreshold;                       // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 NavModeIconAssetHolder;                            // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x18];                                     // 0x0298(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableNavModeItem(bool bEnable);
	void HandleGamePhaseChanged(ESpyGamePhase NewGamePhase);
	void HandleOnLocalLoadoutSpawnComplete(class ADeceiveIncPlayerController* PlayerController, class UToolLoadoutComponent* ToolLoadout);
	void SetNavModeItemIcon(TSoftClassPtr<class UClass> NewIcon);
	void SetNavModeItemSelected(bool bHighlight, float Duration);
	void SetNavModeItemShowed(bool bShowed);

	float GetMinSquaredDistanceToUnselect() const;
	ENavModeItemType GetNavModeItemType() const;
	float GetRaycastPenetrationThreshold() const;
	bool IsEnable() const;
	bool IsNavModeItemSelected() const;
	bool IsNavModeItemShowed() const;
	bool IsShowedInCurrentPhase() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavModeItemComponent">();
	}
	static class UNavModeItemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavModeItemComponent>();
	}
};
static_assert(alignof(UNavModeItemComponent) == 0x000010, "Wrong alignment on UNavModeItemComponent");
static_assert(sizeof(UNavModeItemComponent) == 0x0002B0, "Wrong size on UNavModeItemComponent");
static_assert(offsetof(UNavModeItemComponent, OnNavModeItemShowedChanged) == 0x0001F8, "Member 'UNavModeItemComponent::OnNavModeItemShowedChanged' has a wrong offset!");
static_assert(offsetof(UNavModeItemComponent, OnNavModeItemSelectedChanged) == 0x000208, "Member 'UNavModeItemComponent::OnNavModeItemSelectedChanged' has a wrong offset!");
static_assert(offsetof(UNavModeItemComponent, OnWidgetSpawned) == 0x000218, "Member 'UNavModeItemComponent::OnWidgetSpawned' has a wrong offset!");
static_assert(offsetof(UNavModeItemComponent, NavModeItemType) == 0x000228, "Member 'UNavModeItemComponent::NavModeItemType' has a wrong offset!");
static_assert(offsetof(UNavModeItemComponent, NavModeIconAsset) == 0x000230, "Member 'UNavModeItemComponent::NavModeIconAsset' has a wrong offset!");
static_assert(offsetof(UNavModeItemComponent, NavModeIconOffset) == 0x000258, "Member 'UNavModeItemComponent::NavModeIconOffset' has a wrong offset!");
static_assert(offsetof(UNavModeItemComponent, bShowInAllPhases) == 0x000264, "Member 'UNavModeItemComponent::bShowInAllPhases' has a wrong offset!");
static_assert(offsetof(UNavModeItemComponent, bRegisterOnBeginPlay) == 0x000265, "Member 'UNavModeItemComponent::bRegisterOnBeginPlay' has a wrong offset!");
static_assert(offsetof(UNavModeItemComponent, PhaseToShow) == 0x000268, "Member 'UNavModeItemComponent::PhaseToShow' has a wrong offset!");
static_assert(offsetof(UNavModeItemComponent, NavModeIcon) == 0x000278, "Member 'UNavModeItemComponent::NavModeIcon' has a wrong offset!");
static_assert(offsetof(UNavModeItemComponent, NavModeIconWC) == 0x000280, "Member 'UNavModeItemComponent::NavModeIconWC' has a wrong offset!");
static_assert(offsetof(UNavModeItemComponent, MinSquaredDistanceToUnselect) == 0x000288, "Member 'UNavModeItemComponent::MinSquaredDistanceToUnselect' has a wrong offset!");
static_assert(offsetof(UNavModeItemComponent, RaycastPenetrationThreshold) == 0x00028C, "Member 'UNavModeItemComponent::RaycastPenetrationThreshold' has a wrong offset!");
static_assert(offsetof(UNavModeItemComponent, NavModeIconAssetHolder) == 0x000290, "Member 'UNavModeItemComponent::NavModeIconAssetHolder' has a wrong offset!");

// Class DeceiveInc.NavModeTool
// 0x0248 (0x0778 - 0x0530)
class ANavModeTool final : public ABaseSpyTool
{
public:
	FMulticastInlineDelegateProperty_             OnNewNavModePath;                                  // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNewNavModePathDirection;                         // 0x0540(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNavModeEnable;                                   // 0x0550(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNewLocalSelectedNavModeItem;                     // 0x0560(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNavModeToolEmpoweredTickChanged;                 // 0x0570(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLocalNavModeItemReached;                         // 0x0580(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bAlwaysHighlightItemOfEveryType;                   // 0x0590(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_591[0x3];                                      // 0x0591(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RoomHeight;                                        // 0x0594(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SquaredDistanceToHeightSort;                       // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             RaycastCollisionChannel;                           // 0x059C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59D[0x3];                                      // 0x059D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathUpdateInterval;                                // 0x05A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowDebugPath;                                    // 0x05A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A5[0x3];                                      // 0x05A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDistanceForUpdate;                              // 0x05A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ForwardPointDistance;                              // 0x05AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SidePointDistance;                                 // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinAngleToConsiderBehind;                          // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InclineCheckMinDistance;                           // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InclineCheckMinHeight;                             // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NextInclinePointDistance;                          // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NextInclinePointHeight;                            // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinHeightToAddPoint;                               // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ExtentIterationNum;                                // 0x05CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExtentSizeAugmentPerIteration;                     // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D4[0x4];                                      // 0x05D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UToolLoadoutComponent*                  LoadoutComponent;                                  // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayResourcesComponent*            ResourceComponent;                                 // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EmpoweredIntelRatePerSecond;                       // 0x05E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EmpoweredSightDistance;                            // 0x05EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   EmpoweredSightVictimEffect;                        // 0x05F0(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_618[0x8];                                      // 0x0618(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ASpy*, class AVictimEffect*>       EmpoweredSeenSpies;                                // 0x0620(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         OnTriggerBufferTime;                               // 0x0670(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BufferedTime;                                      // 0x0674(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_678[0x1];                                      // 0x0678(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EGameplayResourcesType                        EmpoweredNavmodeResource;                          // 0x0679(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_67A[0x2];                                      // 0x067A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EmpoweredNavmodeResourceRegenFrequency;            // 0x067C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EmpoweredNavmodeResourceRegenFrequencyDelay;       // 0x0680(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_684[0x8];                                      // 0x0684(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bNavModeEnableReplicated;                          // 0x068C(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68D[0xB];                                      // 0x068D(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class UNavModeData*                           NavModeData;                                       // 0x0698(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNavModeItemComponent*                  SelectedNavModeItem;                               // 0x06A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A8[0x80];                                     // 0x06A8(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ENavModeItemType, struct FNavModeItemList> NavModeItemMap;                                    // 0x0728(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void HandleLocalSpyDeathEvent(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy);
	void HandleResourceChanged(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 Amount);
	void OnRep_NavModeEnable();
	void Server_OnNavModeItemSelected(class UNavModeItemComponent* NavModeItem);
	void Server_OnNavModeStateChanged(bool bEnable);

	class UNavModeItemComponent* GetSelectedNavModeItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavModeTool">();
	}
	static class ANavModeTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavModeTool>();
	}
};
static_assert(alignof(ANavModeTool) == 0x000008, "Wrong alignment on ANavModeTool");
static_assert(sizeof(ANavModeTool) == 0x000778, "Wrong size on ANavModeTool");
static_assert(offsetof(ANavModeTool, OnNewNavModePath) == 0x000530, "Member 'ANavModeTool::OnNewNavModePath' has a wrong offset!");
static_assert(offsetof(ANavModeTool, OnNewNavModePathDirection) == 0x000540, "Member 'ANavModeTool::OnNewNavModePathDirection' has a wrong offset!");
static_assert(offsetof(ANavModeTool, OnNavModeEnable) == 0x000550, "Member 'ANavModeTool::OnNavModeEnable' has a wrong offset!");
static_assert(offsetof(ANavModeTool, OnNewLocalSelectedNavModeItem) == 0x000560, "Member 'ANavModeTool::OnNewLocalSelectedNavModeItem' has a wrong offset!");
static_assert(offsetof(ANavModeTool, OnNavModeToolEmpoweredTickChanged) == 0x000570, "Member 'ANavModeTool::OnNavModeToolEmpoweredTickChanged' has a wrong offset!");
static_assert(offsetof(ANavModeTool, OnLocalNavModeItemReached) == 0x000580, "Member 'ANavModeTool::OnLocalNavModeItemReached' has a wrong offset!");
static_assert(offsetof(ANavModeTool, bAlwaysHighlightItemOfEveryType) == 0x000590, "Member 'ANavModeTool::bAlwaysHighlightItemOfEveryType' has a wrong offset!");
static_assert(offsetof(ANavModeTool, RoomHeight) == 0x000594, "Member 'ANavModeTool::RoomHeight' has a wrong offset!");
static_assert(offsetof(ANavModeTool, SquaredDistanceToHeightSort) == 0x000598, "Member 'ANavModeTool::SquaredDistanceToHeightSort' has a wrong offset!");
static_assert(offsetof(ANavModeTool, RaycastCollisionChannel) == 0x00059C, "Member 'ANavModeTool::RaycastCollisionChannel' has a wrong offset!");
static_assert(offsetof(ANavModeTool, PathUpdateInterval) == 0x0005A0, "Member 'ANavModeTool::PathUpdateInterval' has a wrong offset!");
static_assert(offsetof(ANavModeTool, bShowDebugPath) == 0x0005A4, "Member 'ANavModeTool::bShowDebugPath' has a wrong offset!");
static_assert(offsetof(ANavModeTool, MinDistanceForUpdate) == 0x0005A8, "Member 'ANavModeTool::MinDistanceForUpdate' has a wrong offset!");
static_assert(offsetof(ANavModeTool, ForwardPointDistance) == 0x0005AC, "Member 'ANavModeTool::ForwardPointDistance' has a wrong offset!");
static_assert(offsetof(ANavModeTool, SidePointDistance) == 0x0005B0, "Member 'ANavModeTool::SidePointDistance' has a wrong offset!");
static_assert(offsetof(ANavModeTool, MinAngleToConsiderBehind) == 0x0005B4, "Member 'ANavModeTool::MinAngleToConsiderBehind' has a wrong offset!");
static_assert(offsetof(ANavModeTool, InclineCheckMinDistance) == 0x0005B8, "Member 'ANavModeTool::InclineCheckMinDistance' has a wrong offset!");
static_assert(offsetof(ANavModeTool, InclineCheckMinHeight) == 0x0005BC, "Member 'ANavModeTool::InclineCheckMinHeight' has a wrong offset!");
static_assert(offsetof(ANavModeTool, NextInclinePointDistance) == 0x0005C0, "Member 'ANavModeTool::NextInclinePointDistance' has a wrong offset!");
static_assert(offsetof(ANavModeTool, NextInclinePointHeight) == 0x0005C4, "Member 'ANavModeTool::NextInclinePointHeight' has a wrong offset!");
static_assert(offsetof(ANavModeTool, MinHeightToAddPoint) == 0x0005C8, "Member 'ANavModeTool::MinHeightToAddPoint' has a wrong offset!");
static_assert(offsetof(ANavModeTool, ExtentIterationNum) == 0x0005CC, "Member 'ANavModeTool::ExtentIterationNum' has a wrong offset!");
static_assert(offsetof(ANavModeTool, ExtentSizeAugmentPerIteration) == 0x0005D0, "Member 'ANavModeTool::ExtentSizeAugmentPerIteration' has a wrong offset!");
static_assert(offsetof(ANavModeTool, LoadoutComponent) == 0x0005D8, "Member 'ANavModeTool::LoadoutComponent' has a wrong offset!");
static_assert(offsetof(ANavModeTool, ResourceComponent) == 0x0005E0, "Member 'ANavModeTool::ResourceComponent' has a wrong offset!");
static_assert(offsetof(ANavModeTool, EmpoweredIntelRatePerSecond) == 0x0005E8, "Member 'ANavModeTool::EmpoweredIntelRatePerSecond' has a wrong offset!");
static_assert(offsetof(ANavModeTool, EmpoweredSightDistance) == 0x0005EC, "Member 'ANavModeTool::EmpoweredSightDistance' has a wrong offset!");
static_assert(offsetof(ANavModeTool, EmpoweredSightVictimEffect) == 0x0005F0, "Member 'ANavModeTool::EmpoweredSightVictimEffect' has a wrong offset!");
static_assert(offsetof(ANavModeTool, EmpoweredSeenSpies) == 0x000620, "Member 'ANavModeTool::EmpoweredSeenSpies' has a wrong offset!");
static_assert(offsetof(ANavModeTool, OnTriggerBufferTime) == 0x000670, "Member 'ANavModeTool::OnTriggerBufferTime' has a wrong offset!");
static_assert(offsetof(ANavModeTool, BufferedTime) == 0x000674, "Member 'ANavModeTool::BufferedTime' has a wrong offset!");
static_assert(offsetof(ANavModeTool, EmpoweredNavmodeResource) == 0x000679, "Member 'ANavModeTool::EmpoweredNavmodeResource' has a wrong offset!");
static_assert(offsetof(ANavModeTool, EmpoweredNavmodeResourceRegenFrequency) == 0x00067C, "Member 'ANavModeTool::EmpoweredNavmodeResourceRegenFrequency' has a wrong offset!");
static_assert(offsetof(ANavModeTool, EmpoweredNavmodeResourceRegenFrequencyDelay) == 0x000680, "Member 'ANavModeTool::EmpoweredNavmodeResourceRegenFrequencyDelay' has a wrong offset!");
static_assert(offsetof(ANavModeTool, bNavModeEnableReplicated) == 0x00068C, "Member 'ANavModeTool::bNavModeEnableReplicated' has a wrong offset!");
static_assert(offsetof(ANavModeTool, NavModeData) == 0x000698, "Member 'ANavModeTool::NavModeData' has a wrong offset!");
static_assert(offsetof(ANavModeTool, SelectedNavModeItem) == 0x0006A0, "Member 'ANavModeTool::SelectedNavModeItem' has a wrong offset!");
static_assert(offsetof(ANavModeTool, NavModeItemMap) == 0x000728, "Member 'ANavModeTool::NavModeItemMap' has a wrong offset!");

// Class DeceiveInc.NetworkInfoWidget
// 0x0078 (0x02D8 - 0x0260)
class UNetworkInfoWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x78];                                     // 0x0260(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnDataUpdated();
	void BP_OnDisplayModeChange(ENetInfoDisplayMode NewDisplayMode);
	void HandleIntegerPlayerSettingChange(EPlayerSettingsType SettingType, int32 NewValue);

	bool CanBeDisplayed() const;
	bool CanDisplayRegion() const;
	bool CanDisplayServerFrameTime() const;
	bool CanDisplayServerVersion() const;
	bool CanDisplaySessionID() const;
	ENetInfoDisplayMode GetDisplayMode() const;
	const struct FDINetworkInfoData GetNetworkInfo() const;
	bool IsConnexionLagging() const;
	bool IsDisconnected() const;
	bool IsPacketLoss() const;
	bool IsServerLagging() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkInfoWidget">();
	}
	static class UNetworkInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetworkInfoWidget>();
	}
};
static_assert(alignof(UNetworkInfoWidget) == 0x000008, "Wrong alignment on UNetworkInfoWidget");
static_assert(sizeof(UNetworkInfoWidget) == 0x0002D8, "Wrong size on UNetworkInfoWidget");

// Class DeceiveInc.NPCAIActor
// 0x01D0 (0x03F0 - 0x0220)
class ANPCAIActor final : public AActor
{
public:
	class UBehaviorMachineComponent*              BehaviorMachine;                                   // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNPCBehaviorDefault*                    DefaultBehavior;                                   // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNPCBehaviorControlled*                 ControlledBehavior;                                // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNPCBehaviorScared*                     ScaredBehavior;                                    // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNPCBehaviorScold*                      ScoldBehavior;                                     // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNPCBehaviorInvestigate*                InvestigateBehavior;                               // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNPCBehaviorFollow*                     FollowBehavior;                                    // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNPCBehaviorInteract*                   InteractBehavior;                                  // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowVIPOnEnterRoomProbability;                   // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FollowVIPCountMax;                                 // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowVIPConsiderPlayerDisguiseRange;              // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReviveOnEnterRoomProbability;                      // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReviveWhenInteractingInRoomProbability;            // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReviveRange;                                       // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReviveDelay;                                       // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaredDelayMin;                                    // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaredDelayMax;                                    // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaredPercentageChancesToCrouch;                   // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScoldCloseEnoughDistance;                          // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScoldGiveUpTime;                                   // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScoldLineOfSightAngle;                             // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScoldRunDistance;                                  // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x98];                                     // 0x0298(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageModifier>            PossesedInvulnerability;                           // 0x0330(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_338[0x68];                                     // 0x0338(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UNPCAdditionalComponent*>        AdditionalComponents;                              // 0x03A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x40];                                     // 0x03B0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCrouchToResurectDelayTimerEnd();
	void OnGamePhaseChanged(ESpyGamePhase NewGamePhase);
	void OnRunningChange(bool bRunningIn);
	void OnScaredChange(bool bScaredIn);
	void OnScoldingChange(EScoldState PrevScoldState, EScoldState ScoldState);
	void OnSlowInterval();
	void OnStandingOnBounceMatDeflated(class ABouncingMat* DeflatingBounceMat);
	void OnSuspiciousTimeOutTimerEnd();
	void OnToggleRunDelayTimerEnd();

	ENPCMovementStatus GetNPCMoveStatus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCAIActor">();
	}
	static class ANPCAIActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANPCAIActor>();
	}
};
static_assert(alignof(ANPCAIActor) == 0x000008, "Wrong alignment on ANPCAIActor");
static_assert(sizeof(ANPCAIActor) == 0x0003F0, "Wrong size on ANPCAIActor");
static_assert(offsetof(ANPCAIActor, BehaviorMachine) == 0x000220, "Member 'ANPCAIActor::BehaviorMachine' has a wrong offset!");
static_assert(offsetof(ANPCAIActor, DefaultBehavior) == 0x000228, "Member 'ANPCAIActor::DefaultBehavior' has a wrong offset!");
static_assert(offsetof(ANPCAIActor, ControlledBehavior) == 0x000230, "Member 'ANPCAIActor::ControlledBehavior' has a wrong offset!");
static_assert(offsetof(ANPCAIActor, ScaredBehavior) == 0x000238, "Member 'ANPCAIActor::ScaredBehavior' has a wrong offset!");
static_assert(offsetof(ANPCAIActor, ScoldBehavior) == 0x000240, "Member 'ANPCAIActor::ScoldBehavior' has a wrong offset!");
static_assert(offsetof(ANPCAIActor, InvestigateBehavior) == 0x000248, "Member 'ANPCAIActor::InvestigateBehavior' has a wrong offset!");
static_assert(offsetof(ANPCAIActor, FollowBehavior) == 0x000250, "Member 'ANPCAIActor::FollowBehavior' has a wrong offset!");
static_assert(offsetof(ANPCAIActor, InteractBehavior) == 0x000258, "Member 'ANPCAIActor::InteractBehavior' has a wrong offset!");
static_assert(offsetof(ANPCAIActor, FollowVIPOnEnterRoomProbability) == 0x000260, "Member 'ANPCAIActor::FollowVIPOnEnterRoomProbability' has a wrong offset!");
static_assert(offsetof(ANPCAIActor, FollowVIPCountMax) == 0x000264, "Member 'ANPCAIActor::FollowVIPCountMax' has a wrong offset!");
static_assert(offsetof(ANPCAIActor, FollowVIPConsiderPlayerDisguiseRange) == 0x000268, "Member 'ANPCAIActor::FollowVIPConsiderPlayerDisguiseRange' has a wrong offset!");
static_assert(offsetof(ANPCAIActor, ReviveOnEnterRoomProbability) == 0x00026C, "Member 'ANPCAIActor::ReviveOnEnterRoomProbability' has a wrong offset!");
static_assert(offsetof(ANPCAIActor, ReviveWhenInteractingInRoomProbability) == 0x000270, "Member 'ANPCAIActor::ReviveWhenInteractingInRoomProbability' has a wrong offset!");
static_assert(offsetof(ANPCAIActor, ReviveRange) == 0x000274, "Member 'ANPCAIActor::ReviveRange' has a wrong offset!");
static_assert(offsetof(ANPCAIActor, ReviveDelay) == 0x000278, "Member 'ANPCAIActor::ReviveDelay' has a wrong offset!");
static_assert(offsetof(ANPCAIActor, ScaredDelayMin) == 0x00027C, "Member 'ANPCAIActor::ScaredDelayMin' has a wrong offset!");
static_assert(offsetof(ANPCAIActor, ScaredDelayMax) == 0x000280, "Member 'ANPCAIActor::ScaredDelayMax' has a wrong offset!");
static_assert(offsetof(ANPCAIActor, ScaredPercentageChancesToCrouch) == 0x000284, "Member 'ANPCAIActor::ScaredPercentageChancesToCrouch' has a wrong offset!");
static_assert(offsetof(ANPCAIActor, ScoldCloseEnoughDistance) == 0x000288, "Member 'ANPCAIActor::ScoldCloseEnoughDistance' has a wrong offset!");
static_assert(offsetof(ANPCAIActor, ScoldGiveUpTime) == 0x00028C, "Member 'ANPCAIActor::ScoldGiveUpTime' has a wrong offset!");
static_assert(offsetof(ANPCAIActor, ScoldLineOfSightAngle) == 0x000290, "Member 'ANPCAIActor::ScoldLineOfSightAngle' has a wrong offset!");
static_assert(offsetof(ANPCAIActor, ScoldRunDistance) == 0x000294, "Member 'ANPCAIActor::ScoldRunDistance' has a wrong offset!");
static_assert(offsetof(ANPCAIActor, PossesedInvulnerability) == 0x000330, "Member 'ANPCAIActor::PossesedInvulnerability' has a wrong offset!");
static_assert(offsetof(ANPCAIActor, AdditionalComponents) == 0x0003A0, "Member 'ANPCAIActor::AdditionalComponents' has a wrong offset!");

// Class DeceiveInc.NPCBehaviorControlled
// 0x0000 (0x00C0 - 0x00C0)
class UNPCBehaviorControlled final : public UNPCBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCBehaviorControlled">();
	}
	static class UNPCBehaviorControlled* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCBehaviorControlled>();
	}
};
static_assert(alignof(UNPCBehaviorControlled) == 0x000008, "Wrong alignment on UNPCBehaviorControlled");
static_assert(sizeof(UNPCBehaviorControlled) == 0x0000C0, "Wrong size on UNPCBehaviorControlled");

// Class DeceiveInc.NPCBehaviorFollow
// 0x0090 (0x0150 - 0x00C0)
class UNPCBehaviorFollow final : public UNPCBehavior
{
public:
	float                                         FollowDistZMin;                                    // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowDistZMax;                                    // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowDistXMin;                                    // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowDistXMax;                                    // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowCloseEnoughDistance;                         // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowRunDistance;                                 // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefreshTargetPosDistance;                          // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefreshRunningTargetPosDistance;                   // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x70];                                      // 0x00E0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFollowingNPCEnteredRoom(class ANPCCharacter* FollowingNPC, class ARoomVolume* EnteredRoom);
	void OnGiveUpTimerEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCBehaviorFollow">();
	}
	static class UNPCBehaviorFollow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCBehaviorFollow>();
	}
};
static_assert(alignof(UNPCBehaviorFollow) == 0x000008, "Wrong alignment on UNPCBehaviorFollow");
static_assert(sizeof(UNPCBehaviorFollow) == 0x000150, "Wrong size on UNPCBehaviorFollow");
static_assert(offsetof(UNPCBehaviorFollow, FollowDistZMin) == 0x0000C0, "Member 'UNPCBehaviorFollow::FollowDistZMin' has a wrong offset!");
static_assert(offsetof(UNPCBehaviorFollow, FollowDistZMax) == 0x0000C4, "Member 'UNPCBehaviorFollow::FollowDistZMax' has a wrong offset!");
static_assert(offsetof(UNPCBehaviorFollow, FollowDistXMin) == 0x0000C8, "Member 'UNPCBehaviorFollow::FollowDistXMin' has a wrong offset!");
static_assert(offsetof(UNPCBehaviorFollow, FollowDistXMax) == 0x0000CC, "Member 'UNPCBehaviorFollow::FollowDistXMax' has a wrong offset!");
static_assert(offsetof(UNPCBehaviorFollow, FollowCloseEnoughDistance) == 0x0000D0, "Member 'UNPCBehaviorFollow::FollowCloseEnoughDistance' has a wrong offset!");
static_assert(offsetof(UNPCBehaviorFollow, FollowRunDistance) == 0x0000D4, "Member 'UNPCBehaviorFollow::FollowRunDistance' has a wrong offset!");
static_assert(offsetof(UNPCBehaviorFollow, RefreshTargetPosDistance) == 0x0000D8, "Member 'UNPCBehaviorFollow::RefreshTargetPosDistance' has a wrong offset!");
static_assert(offsetof(UNPCBehaviorFollow, RefreshRunningTargetPosDistance) == 0x0000DC, "Member 'UNPCBehaviorFollow::RefreshRunningTargetPosDistance' has a wrong offset!");

// Class DeceiveInc.NPCBehaviorInvestigate
// 0x0188 (0x0248 - 0x00C0)
class UNPCBehaviorInvestigate final : public UNPCBehavior
{
public:
	uint8                                         Pad_C0[0x188];                                     // 0x00C0(0x0188)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBlockAttackTimerEnd();
	void OnMeleeDelayTimerEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCBehaviorInvestigate">();
	}
	static class UNPCBehaviorInvestigate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCBehaviorInvestigate>();
	}
};
static_assert(alignof(UNPCBehaviorInvestigate) == 0x000008, "Wrong alignment on UNPCBehaviorInvestigate");
static_assert(sizeof(UNPCBehaviorInvestigate) == 0x000248, "Wrong size on UNPCBehaviorInvestigate");

// Class DeceiveInc.NPCBehaviorScold
// 0x0010 (0x00D0 - 0x00C0)
class UNPCBehaviorScold final : public UNPCBehavior
{
public:
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCBehaviorScold">();
	}
	static class UNPCBehaviorScold* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCBehaviorScold>();
	}
};
static_assert(alignof(UNPCBehaviorScold) == 0x000008, "Wrong alignment on UNPCBehaviorScold");
static_assert(sizeof(UNPCBehaviorScold) == 0x0000D0, "Wrong size on UNPCBehaviorScold");

// Class DeceiveInc.NPCBugSpawnerWeapon
// 0x0100 (0x0788 - 0x0688)
class ANPCBugSpawnerWeapon final : public ABasePlaceableSpyTool
{
public:
	TSoftClassPtr<class UClass>                   SpawnerWeaponClass;                                // 0x0688(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   NPCBugToSpawnClass;                                // 0x06B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayToRefundShot;                                 // 0x06D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FailsafeDelayToShoot;                              // 0x06DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SpawnerWeaponAttachementPointName;                 // 0x06E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ReticuleHudName;                                   // 0x06E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EMovementEventType>                    SpyMovementEventToForceOutOfCamera;                // 0x06F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         OffsetFromImpactPoint;                             // 0x0700(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallOffset;                                        // 0x0704(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETraceTypeQuery                               TraceCollision;                                    // 0x0708(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_709[0x7];                                      // 0x0709(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CameraPrimaryActionText;                           // 0x0710(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   CameraSecondaryActionText;                         // 0x0728(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class AHitscanWeapon*                         SpawnerWeapon;                                     // 0x0740(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ANPCCharacter*                          LastDisguise;                                      // 0x0748(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ANPCBug*>                        AvailableNPCBugs;                                  // 0x0750(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ANPCBug*>                        DisabledNPCBugs;                                   // 0x0760(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_770[0x18];                                     // 0x0770(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleCoverSwitch(class ANPCCharacter* Disguise);
	void HandleOwnerTookDamage(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, class UHealthComponent* SpyHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& DamageDirection);
	void HandleProjectileImpact(const struct FWeaponImpactData& WeaponInpactData);
	void HandleSimulateLocalFireShot(class AProjectileWeapon* Weapon, const struct FVector& OriginPos, const struct FVector& DestinationPos, bool bDoDamage, bool bMissingShot);
	void HandleSpyMovementEvent(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, EMovementEventType MovementEventType);
	void HandleSpyToolEvent(ESpyToolEvent EventType, class ABaseSpyTool* SpyTool);
	void OnDelayShootTimerEnd();
	void OnRefundShotTimerEnd();
	void OnRep_NewSpawnerWeapon();
	void Server_HandleProjectileImpactOnClient(const struct FWeaponImpactData& WeaponImpactData, const struct FVector_NetQuantize& RelativePosition);
	void ShootFromAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCBugSpawnerWeapon">();
	}
	static class ANPCBugSpawnerWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANPCBugSpawnerWeapon>();
	}
};
static_assert(alignof(ANPCBugSpawnerWeapon) == 0x000008, "Wrong alignment on ANPCBugSpawnerWeapon");
static_assert(sizeof(ANPCBugSpawnerWeapon) == 0x000788, "Wrong size on ANPCBugSpawnerWeapon");
static_assert(offsetof(ANPCBugSpawnerWeapon, SpawnerWeaponClass) == 0x000688, "Member 'ANPCBugSpawnerWeapon::SpawnerWeaponClass' has a wrong offset!");
static_assert(offsetof(ANPCBugSpawnerWeapon, NPCBugToSpawnClass) == 0x0006B0, "Member 'ANPCBugSpawnerWeapon::NPCBugToSpawnClass' has a wrong offset!");
static_assert(offsetof(ANPCBugSpawnerWeapon, DelayToRefundShot) == 0x0006D8, "Member 'ANPCBugSpawnerWeapon::DelayToRefundShot' has a wrong offset!");
static_assert(offsetof(ANPCBugSpawnerWeapon, FailsafeDelayToShoot) == 0x0006DC, "Member 'ANPCBugSpawnerWeapon::FailsafeDelayToShoot' has a wrong offset!");
static_assert(offsetof(ANPCBugSpawnerWeapon, SpawnerWeaponAttachementPointName) == 0x0006E0, "Member 'ANPCBugSpawnerWeapon::SpawnerWeaponAttachementPointName' has a wrong offset!");
static_assert(offsetof(ANPCBugSpawnerWeapon, ReticuleHudName) == 0x0006E8, "Member 'ANPCBugSpawnerWeapon::ReticuleHudName' has a wrong offset!");
static_assert(offsetof(ANPCBugSpawnerWeapon, SpyMovementEventToForceOutOfCamera) == 0x0006F0, "Member 'ANPCBugSpawnerWeapon::SpyMovementEventToForceOutOfCamera' has a wrong offset!");
static_assert(offsetof(ANPCBugSpawnerWeapon, OffsetFromImpactPoint) == 0x000700, "Member 'ANPCBugSpawnerWeapon::OffsetFromImpactPoint' has a wrong offset!");
static_assert(offsetof(ANPCBugSpawnerWeapon, WallOffset) == 0x000704, "Member 'ANPCBugSpawnerWeapon::WallOffset' has a wrong offset!");
static_assert(offsetof(ANPCBugSpawnerWeapon, TraceCollision) == 0x000708, "Member 'ANPCBugSpawnerWeapon::TraceCollision' has a wrong offset!");
static_assert(offsetof(ANPCBugSpawnerWeapon, CameraPrimaryActionText) == 0x000710, "Member 'ANPCBugSpawnerWeapon::CameraPrimaryActionText' has a wrong offset!");
static_assert(offsetof(ANPCBugSpawnerWeapon, CameraSecondaryActionText) == 0x000728, "Member 'ANPCBugSpawnerWeapon::CameraSecondaryActionText' has a wrong offset!");
static_assert(offsetof(ANPCBugSpawnerWeapon, SpawnerWeapon) == 0x000740, "Member 'ANPCBugSpawnerWeapon::SpawnerWeapon' has a wrong offset!");
static_assert(offsetof(ANPCBugSpawnerWeapon, LastDisguise) == 0x000748, "Member 'ANPCBugSpawnerWeapon::LastDisguise' has a wrong offset!");
static_assert(offsetof(ANPCBugSpawnerWeapon, AvailableNPCBugs) == 0x000750, "Member 'ANPCBugSpawnerWeapon::AvailableNPCBugs' has a wrong offset!");
static_assert(offsetof(ANPCBugSpawnerWeapon, DisabledNPCBugs) == 0x000760, "Member 'ANPCBugSpawnerWeapon::DisabledNPCBugs' has a wrong offset!");

// Class DeceiveInc.NPCGuardComponent
// 0x0198 (0x0250 - 0x00B8)
class UNPCGuardComponent final : public UNPCAdditionalComponent
{
public:
	bool                                          bInvestigatingSpy;                                 // 0x00B8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInvestigatingDanger;                              // 0x00B9(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLookingAtAggroTarget;                             // 0x00BA(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BB[0x5];                                       // 0x00BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReplicatedAggroTargetActor;                        // 0x00C0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnInvestigationTypeChange;                         // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnInvestigationTypeChange_Always;                  // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnInvestigationStateChange;                        // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnWeaponChanged;                                   // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnAimingPitchChange;                               // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnGuardKillSpy;                                    // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	EInvestigationState                           CurrentInvestigationState;                         // 0x0130(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UEncounterParticipant>   EncounterParticipant;                              // 0x0134(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C[0xC];                                      // 0x013C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EncounterDistanceToTarget;                         // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EncounterDistanceToTargetMin;                      // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EncounterDistanceToRepursue;                       // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EncounterShootRange;                               // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EncounterMoveFromIdleDistance;                     // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EncounterFiringFrequency;                          // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NoAttackAfterHurtDelay;                            // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EncounterMeleeRange;                               // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EncounterMeleeFrequency;                           // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EncounterMeleeDamage;                              // 0x016C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveAfterMeleeDelay;                               // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EncounterMeleeHitMaxRange;                         // 0x0174(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AggroNoAttackDelay;                                // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AfterLostAggroDelay;                               // 0x017C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChaseRunDelay;                                     // 0x0180(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGuardEncounterHeatData>        HeatEncounterDataPerLevel;                         // 0x0188(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         AngleToConsiderTargetLookingAtGuard;               // 0x0198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BulletVFXTravelTime;                               // 0x019C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WeaponClass;                                       // 0x01A0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHitscanWeapon*                         Weapon;                                            // 0x01C8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class ASpy>>            WatchedSpies;                                      // 0x01D0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class ASpy>>            SeenSpies;                                         // 0x01E0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bReachedTarget;                                    // 0x01F0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1[0x57];                                     // 0x01F1(0x0057)(Fixing Size After Last Property [ Dumper-7 ])
	EInvestigationType                            CurrentInvestigationType;                          // 0x0248(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERotationAnimationType                        CurrentRotationAnimationType;                      // 0x0249(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24A[0x6];                                      // 0x024A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FOnLoSChange(class AActor* AffectedActor, bool bIsSeen);
	void NetMulticast_OnKillSpy(class ASpy* KilledSpy);
	void OnKillSpyNotify(class ASpy* KilledSpy);
	void OnMoveAfterMeleeTimerEnd();
	void OnRep_AggroTargetActor(class AActor* PrevAggroTarget);
	void OnRep_InvestigationState();
	void OnRep_InvestigationType(EInvestigationType PrevType);
	void OnRep_LookingAtAggroTarget();
	void OnRep_RotationAnimationType(ERotationAnimationType PrevType);
	void OnRep_WeaponChanged(class AHitscanWeapon* OldWeapon);
	void OnRunDelayTimerEnd();
	void OnStopIntestigationTimerEnd();
	void OnUpdateWeaponVisibilityTimerEnd();
	void OnVisibilityChanged(bool bIsVisible);
	void ShowWeaponFromAnimation(bool bShow);

	EInvestigationType GetInvestigationType() const;
	bool IsAggroed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCGuardComponent">();
	}
	static class UNPCGuardComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCGuardComponent>();
	}
};
static_assert(alignof(UNPCGuardComponent) == 0x000008, "Wrong alignment on UNPCGuardComponent");
static_assert(sizeof(UNPCGuardComponent) == 0x000250, "Wrong size on UNPCGuardComponent");
static_assert(offsetof(UNPCGuardComponent, bInvestigatingSpy) == 0x0000B8, "Member 'UNPCGuardComponent::bInvestigatingSpy' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, bInvestigatingDanger) == 0x0000B9, "Member 'UNPCGuardComponent::bInvestigatingDanger' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, bLookingAtAggroTarget) == 0x0000BA, "Member 'UNPCGuardComponent::bLookingAtAggroTarget' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, ReplicatedAggroTargetActor) == 0x0000C0, "Member 'UNPCGuardComponent::ReplicatedAggroTargetActor' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, OnInvestigationTypeChange) == 0x0000D0, "Member 'UNPCGuardComponent::OnInvestigationTypeChange' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, OnInvestigationTypeChange_Always) == 0x0000E0, "Member 'UNPCGuardComponent::OnInvestigationTypeChange_Always' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, OnInvestigationStateChange) == 0x0000F0, "Member 'UNPCGuardComponent::OnInvestigationStateChange' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, OnWeaponChanged) == 0x000100, "Member 'UNPCGuardComponent::OnWeaponChanged' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, OnAimingPitchChange) == 0x000110, "Member 'UNPCGuardComponent::OnAimingPitchChange' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, OnGuardKillSpy) == 0x000120, "Member 'UNPCGuardComponent::OnGuardKillSpy' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, CurrentInvestigationState) == 0x000130, "Member 'UNPCGuardComponent::CurrentInvestigationState' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, EncounterParticipant) == 0x000134, "Member 'UNPCGuardComponent::EncounterParticipant' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, EncounterDistanceToTarget) == 0x000148, "Member 'UNPCGuardComponent::EncounterDistanceToTarget' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, EncounterDistanceToTargetMin) == 0x00014C, "Member 'UNPCGuardComponent::EncounterDistanceToTargetMin' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, EncounterDistanceToRepursue) == 0x000150, "Member 'UNPCGuardComponent::EncounterDistanceToRepursue' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, EncounterShootRange) == 0x000154, "Member 'UNPCGuardComponent::EncounterShootRange' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, EncounterMoveFromIdleDistance) == 0x000158, "Member 'UNPCGuardComponent::EncounterMoveFromIdleDistance' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, EncounterFiringFrequency) == 0x00015C, "Member 'UNPCGuardComponent::EncounterFiringFrequency' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, NoAttackAfterHurtDelay) == 0x000160, "Member 'UNPCGuardComponent::NoAttackAfterHurtDelay' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, EncounterMeleeRange) == 0x000164, "Member 'UNPCGuardComponent::EncounterMeleeRange' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, EncounterMeleeFrequency) == 0x000168, "Member 'UNPCGuardComponent::EncounterMeleeFrequency' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, EncounterMeleeDamage) == 0x00016C, "Member 'UNPCGuardComponent::EncounterMeleeDamage' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, MoveAfterMeleeDelay) == 0x000170, "Member 'UNPCGuardComponent::MoveAfterMeleeDelay' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, EncounterMeleeHitMaxRange) == 0x000174, "Member 'UNPCGuardComponent::EncounterMeleeHitMaxRange' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, AggroNoAttackDelay) == 0x000178, "Member 'UNPCGuardComponent::AggroNoAttackDelay' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, AfterLostAggroDelay) == 0x00017C, "Member 'UNPCGuardComponent::AfterLostAggroDelay' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, ChaseRunDelay) == 0x000180, "Member 'UNPCGuardComponent::ChaseRunDelay' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, HeatEncounterDataPerLevel) == 0x000188, "Member 'UNPCGuardComponent::HeatEncounterDataPerLevel' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, AngleToConsiderTargetLookingAtGuard) == 0x000198, "Member 'UNPCGuardComponent::AngleToConsiderTargetLookingAtGuard' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, BulletVFXTravelTime) == 0x00019C, "Member 'UNPCGuardComponent::BulletVFXTravelTime' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, WeaponClass) == 0x0001A0, "Member 'UNPCGuardComponent::WeaponClass' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, Weapon) == 0x0001C8, "Member 'UNPCGuardComponent::Weapon' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, WatchedSpies) == 0x0001D0, "Member 'UNPCGuardComponent::WatchedSpies' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, SeenSpies) == 0x0001E0, "Member 'UNPCGuardComponent::SeenSpies' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, bReachedTarget) == 0x0001F0, "Member 'UNPCGuardComponent::bReachedTarget' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, CurrentInvestigationType) == 0x000248, "Member 'UNPCGuardComponent::CurrentInvestigationType' has a wrong offset!");
static_assert(offsetof(UNPCGuardComponent, CurrentRotationAnimationType) == 0x000249, "Member 'UNPCGuardComponent::CurrentRotationAnimationType' has a wrong offset!");

// Class DeceiveInc.NPCMotionSetComponent
// 0x0050 (0x0100 - 0x00B0)
class UNPCMotionSetComponent final : public UActorComponent
{
public:
	TMap<class FName, struct FNPCInteractAnimKit> InteractAnimations;                                // 0x00B0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCMotionSetComponent">();
	}
	static class UNPCMotionSetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCMotionSetComponent>();
	}
};
static_assert(alignof(UNPCMotionSetComponent) == 0x000008, "Wrong alignment on UNPCMotionSetComponent");
static_assert(sizeof(UNPCMotionSetComponent) == 0x000100, "Wrong size on UNPCMotionSetComponent");
static_assert(offsetof(UNPCMotionSetComponent, InteractAnimations) == 0x0000B0, "Member 'UNPCMotionSetComponent::InteractAnimations' has a wrong offset!");

// Class DeceiveInc.ObjectiveProximityData
// 0x0018 (0x0050 - 0x0038)
class UObjectiveProximityData final : public UDIPrimaryDataAsset
{
public:
	TArray<float>                                 ProximityLevelUpperLimits;                         // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ProximityCheckingPeriod;                           // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveProximityData">();
	}
	static class UObjectiveProximityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveProximityData>();
	}
};
static_assert(alignof(UObjectiveProximityData) == 0x000008, "Wrong alignment on UObjectiveProximityData");
static_assert(sizeof(UObjectiveProximityData) == 0x000050, "Wrong size on UObjectiveProximityData");
static_assert(offsetof(UObjectiveProximityData, ProximityLevelUpperLimits) == 0x000038, "Member 'UObjectiveProximityData::ProximityLevelUpperLimits' has a wrong offset!");
static_assert(offsetof(UObjectiveProximityData, ProximityCheckingPeriod) == 0x000048, "Member 'UObjectiveProximityData::ProximityCheckingPeriod' has a wrong offset!");

// Class DeceiveInc.ObjectSpawn
// 0x00F8 (0x0318 - 0x0220)
class AObjectSpawn final : public AActor
{
public:
	uint8                                         Pad_220[0x10];                                     // 0x0220(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SpawnedActor;                                      // 0x0230(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        ToReachRoomCells;                                  // 0x0238(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	class FString                                 ObjectSpawnPointType;                              // 0x0248(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PartOfRoomCRC;                                     // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint32>                                PartOfLevelAreaCRCs;                               // 0x0260(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	struct FPossibleObjectsToSpawn                CustomPossibleObjectsToSpawn;                      // 0x0270(0x0020)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x68];                                     // 0x0290(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SingleObjSpawnGroup;                               // 0x02F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextRenderComponent*                   DebugTextRenderComponent;                          // 0x0300(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnObjectSpawned;                                   // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnRep_SpawnedActor();
	void UpdateConnectedRoomsReference(class UWorld* World);

	class AActor* GetSpawnedObject() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectSpawn">();
	}
	static class AObjectSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AObjectSpawn>();
	}
};
static_assert(alignof(AObjectSpawn) == 0x000008, "Wrong alignment on AObjectSpawn");
static_assert(sizeof(AObjectSpawn) == 0x000318, "Wrong size on AObjectSpawn");
static_assert(offsetof(AObjectSpawn, SpawnedActor) == 0x000230, "Member 'AObjectSpawn::SpawnedActor' has a wrong offset!");
static_assert(offsetof(AObjectSpawn, ToReachRoomCells) == 0x000238, "Member 'AObjectSpawn::ToReachRoomCells' has a wrong offset!");
static_assert(offsetof(AObjectSpawn, ObjectSpawnPointType) == 0x000248, "Member 'AObjectSpawn::ObjectSpawnPointType' has a wrong offset!");
static_assert(offsetof(AObjectSpawn, PartOfRoomCRC) == 0x000258, "Member 'AObjectSpawn::PartOfRoomCRC' has a wrong offset!");
static_assert(offsetof(AObjectSpawn, PartOfLevelAreaCRCs) == 0x000260, "Member 'AObjectSpawn::PartOfLevelAreaCRCs' has a wrong offset!");
static_assert(offsetof(AObjectSpawn, CustomPossibleObjectsToSpawn) == 0x000270, "Member 'AObjectSpawn::CustomPossibleObjectsToSpawn' has a wrong offset!");
static_assert(offsetof(AObjectSpawn, SingleObjSpawnGroup) == 0x0002F8, "Member 'AObjectSpawn::SingleObjSpawnGroup' has a wrong offset!");
static_assert(offsetof(AObjectSpawn, DebugTextRenderComponent) == 0x000300, "Member 'AObjectSpawn::DebugTextRenderComponent' has a wrong offset!");
static_assert(offsetof(AObjectSpawn, OnObjectSpawned) == 0x000308, "Member 'AObjectSpawn::OnObjectSpawned' has a wrong offset!");

// Class DeceiveInc.DIObjectsToSpawnDataAsset
// 0x0010 (0x0048 - 0x0038)
class UDIObjectsToSpawnDataAsset final : public UDIPrimaryDataAsset
{
public:
	TArray<struct FObjectToSpawn>                 ObjectsToSpawn;                                    // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIObjectsToSpawnDataAsset">();
	}
	static class UDIObjectsToSpawnDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIObjectsToSpawnDataAsset>();
	}
};
static_assert(alignof(UDIObjectsToSpawnDataAsset) == 0x000008, "Wrong alignment on UDIObjectsToSpawnDataAsset");
static_assert(sizeof(UDIObjectsToSpawnDataAsset) == 0x000048, "Wrong size on UDIObjectsToSpawnDataAsset");
static_assert(offsetof(UDIObjectsToSpawnDataAsset, ObjectsToSpawn) == 0x000038, "Member 'UDIObjectsToSpawnDataAsset::ObjectsToSpawn' has a wrong offset!");

// Class DeceiveInc.DIObjectSpawnPresetsDataAsset
// 0x0140 (0x0178 - 0x0038)
class UDIObjectSpawnPresetsDataAsset final : public UDIPrimaryDataAsset
{
public:
	struct FPossibleObjectsToSpawn                InVaultPresets[0x5];                               // 0x0038(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FPossibleObjectsToSpawn                OutOfVaultPresets[0x5];                            // 0x00D8(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIObjectSpawnPresetsDataAsset">();
	}
	static class UDIObjectSpawnPresetsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIObjectSpawnPresetsDataAsset>();
	}
};
static_assert(alignof(UDIObjectSpawnPresetsDataAsset) == 0x000008, "Wrong alignment on UDIObjectSpawnPresetsDataAsset");
static_assert(sizeof(UDIObjectSpawnPresetsDataAsset) == 0x000178, "Wrong size on UDIObjectSpawnPresetsDataAsset");
static_assert(offsetof(UDIObjectSpawnPresetsDataAsset, InVaultPresets) == 0x000038, "Member 'UDIObjectSpawnPresetsDataAsset::InVaultPresets' has a wrong offset!");
static_assert(offsetof(UDIObjectSpawnPresetsDataAsset, OutOfVaultPresets) == 0x0000D8, "Member 'UDIObjectSpawnPresetsDataAsset::OutOfVaultPresets' has a wrong offset!");

// Class DeceiveInc.TargetDummy
// 0x0018 (0x0238 - 0x0220)
class ATargetDummy final : public AActor
{
public:
	uint8                                         Pad_220[0x18];                                     // 0x0220(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetDummy">();
	}
	static class ATargetDummy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATargetDummy>();
	}
};
static_assert(alignof(ATargetDummy) == 0x000008, "Wrong alignment on ATargetDummy");
static_assert(sizeof(ATargetDummy) == 0x000238, "Wrong size on ATargetDummy");

// Class DeceiveInc.ObjectSpawningManager
// 0x03D0 (0x05F0 - 0x0220)
class AObjectSpawningManager final : public AActor
{
public:
	float                                         FillingObjectsMaxWeightFactor;                     // 0x0220(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   DebugPP;                                           // 0x0228(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             BP_OnObjectsSpawnDone;                             // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FObjectToSpawn>                 ObjectsToSpawn;                                    // 0x0260(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	TArray<struct FObjectToSpawnCount>            ObjectsToSpawnCount;                               // 0x0270(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	struct FPossibleObjectToSpawnPresets          ObjectSpawnPresets;                                // 0x0280(0x0140)(Edit, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	class UDIObjectsToSpawnDataAsset*             ObjectsToSpawnData;                                // 0x03C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EDIGameMode, class UDIObjectsToSpawnDataAsset*> ObjectsToSpawnDataByModeOverride;                  // 0x03C8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	class UDIObjectsToSpawnCountDataAsset*        ObjectsToSpawnCountData;                           // 0x0418(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EDIGameMode, class UDIObjectsToSpawnCountDataAsset*> ObjectsToSpawnCountDataByModeOverride;             // 0x0420(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	class UDIObjectSpawnPresetsDataAsset*         ObjectSpawnPresetsData;                            // 0x0470(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EDIGameMode, class UDIObjectSpawnPresetsDataAsset*> ObjectSpawnPresetsDataByModeOverride;              // 0x0478(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	class UDIObjectsToSpawnDataAsset*             InstancedObjectsToSpawnData;                       // 0x04C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDIObjectsToSpawnCountDataAsset*        InstancedObjectsToSpawnCountData;                  // 0x04D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDIObjectSpawnPresetsDataAsset*         InstancedObjectSpawnPresetsData;                   // 0x04D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E0[0x110];                                    // 0x04E0(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AObjectSpawningManager* Get(class UWorld* World);

	class UDIObjectSpawnPresetsDataAsset* GetObjectSpawnPresetsData();
	class UDIObjectsToSpawnCountDataAsset* GetObjectsToSpawnCountData();
	class UDIObjectsToSpawnDataAsset* GetObjectsToSpawnData();
	void HandleAllRoomsSetup(class UWorld* World);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectSpawningManager">();
	}
	static class AObjectSpawningManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AObjectSpawningManager>();
	}
};
static_assert(alignof(AObjectSpawningManager) == 0x000008, "Wrong alignment on AObjectSpawningManager");
static_assert(sizeof(AObjectSpawningManager) == 0x0005F0, "Wrong size on AObjectSpawningManager");
static_assert(offsetof(AObjectSpawningManager, FillingObjectsMaxWeightFactor) == 0x000220, "Member 'AObjectSpawningManager::FillingObjectsMaxWeightFactor' has a wrong offset!");
static_assert(offsetof(AObjectSpawningManager, DebugPP) == 0x000228, "Member 'AObjectSpawningManager::DebugPP' has a wrong offset!");
static_assert(offsetof(AObjectSpawningManager, BP_OnObjectsSpawnDone) == 0x000250, "Member 'AObjectSpawningManager::BP_OnObjectsSpawnDone' has a wrong offset!");
static_assert(offsetof(AObjectSpawningManager, ObjectsToSpawn) == 0x000260, "Member 'AObjectSpawningManager::ObjectsToSpawn' has a wrong offset!");
static_assert(offsetof(AObjectSpawningManager, ObjectsToSpawnCount) == 0x000270, "Member 'AObjectSpawningManager::ObjectsToSpawnCount' has a wrong offset!");
static_assert(offsetof(AObjectSpawningManager, ObjectSpawnPresets) == 0x000280, "Member 'AObjectSpawningManager::ObjectSpawnPresets' has a wrong offset!");
static_assert(offsetof(AObjectSpawningManager, ObjectsToSpawnData) == 0x0003C0, "Member 'AObjectSpawningManager::ObjectsToSpawnData' has a wrong offset!");
static_assert(offsetof(AObjectSpawningManager, ObjectsToSpawnDataByModeOverride) == 0x0003C8, "Member 'AObjectSpawningManager::ObjectsToSpawnDataByModeOverride' has a wrong offset!");
static_assert(offsetof(AObjectSpawningManager, ObjectsToSpawnCountData) == 0x000418, "Member 'AObjectSpawningManager::ObjectsToSpawnCountData' has a wrong offset!");
static_assert(offsetof(AObjectSpawningManager, ObjectsToSpawnCountDataByModeOverride) == 0x000420, "Member 'AObjectSpawningManager::ObjectsToSpawnCountDataByModeOverride' has a wrong offset!");
static_assert(offsetof(AObjectSpawningManager, ObjectSpawnPresetsData) == 0x000470, "Member 'AObjectSpawningManager::ObjectSpawnPresetsData' has a wrong offset!");
static_assert(offsetof(AObjectSpawningManager, ObjectSpawnPresetsDataByModeOverride) == 0x000478, "Member 'AObjectSpawningManager::ObjectSpawnPresetsDataByModeOverride' has a wrong offset!");
static_assert(offsetof(AObjectSpawningManager, InstancedObjectsToSpawnData) == 0x0004C8, "Member 'AObjectSpawningManager::InstancedObjectsToSpawnData' has a wrong offset!");
static_assert(offsetof(AObjectSpawningManager, InstancedObjectsToSpawnCountData) == 0x0004D0, "Member 'AObjectSpawningManager::InstancedObjectsToSpawnCountData' has a wrong offset!");
static_assert(offsetof(AObjectSpawningManager, InstancedObjectSpawnPresetsData) == 0x0004D8, "Member 'AObjectSpawningManager::InstancedObjectSpawnPresetsData' has a wrong offset!");

// Class DeceiveInc.ThrowableWeapon
// 0x00A0 (0x0150 - 0x00B0)
class UThrowableWeapon final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnProjectilesReleased;                             // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnProjectilesAbort;                                // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnShowProjectiles;                                 // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnReloadThrowStart;                                // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ReloadFireShotClass;                               // 0x00F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShootDelay;                                        // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BalancingName;                                     // 0x0124(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AProjectileWeapon*                      OwnerWeapon;                                       // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_138[0x18];                                     // 0x0138(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnShootDelayTimerEnd();
	void OnSpyToolEvent(ESpyToolEvent EventType, class ABaseSpyTool* SpyTool);
	void ReloadThrowProjectile(const struct FVector_NetQuantize& DestinationPos);
	void ReloadThrowStart();

	bool ShouldReloadThrow() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrowableWeapon">();
	}
	static class UThrowableWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThrowableWeapon>();
	}
};
static_assert(alignof(UThrowableWeapon) == 0x000008, "Wrong alignment on UThrowableWeapon");
static_assert(sizeof(UThrowableWeapon) == 0x000150, "Wrong size on UThrowableWeapon");
static_assert(offsetof(UThrowableWeapon, OnProjectilesReleased) == 0x0000B8, "Member 'UThrowableWeapon::OnProjectilesReleased' has a wrong offset!");
static_assert(offsetof(UThrowableWeapon, OnProjectilesAbort) == 0x0000C8, "Member 'UThrowableWeapon::OnProjectilesAbort' has a wrong offset!");
static_assert(offsetof(UThrowableWeapon, OnShowProjectiles) == 0x0000D8, "Member 'UThrowableWeapon::OnShowProjectiles' has a wrong offset!");
static_assert(offsetof(UThrowableWeapon, OnReloadThrowStart) == 0x0000E8, "Member 'UThrowableWeapon::OnReloadThrowStart' has a wrong offset!");
static_assert(offsetof(UThrowableWeapon, ReloadFireShotClass) == 0x0000F8, "Member 'UThrowableWeapon::ReloadFireShotClass' has a wrong offset!");
static_assert(offsetof(UThrowableWeapon, ShootDelay) == 0x000120, "Member 'UThrowableWeapon::ShootDelay' has a wrong offset!");
static_assert(offsetof(UThrowableWeapon, BalancingName) == 0x000124, "Member 'UThrowableWeapon::BalancingName' has a wrong offset!");
static_assert(offsetof(UThrowableWeapon, OwnerWeapon) == 0x000130, "Member 'UThrowableWeapon::OwnerWeapon' has a wrong offset!");

// Class DeceiveInc.OctoActiveAbilityMod2
// 0x0048 (0x0658 - 0x0610)
class AOctoActiveAbilityMod2 final : public AOctoDrainingActiveAbility
{
public:
	TArray<TSoftClassPtr<class UClass>>           SeenOutOfCoverSpyVictimEffects;                    // 0x0610(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         DetectionRange;                                    // 0x0620(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetectionAngle;                                    // 0x0624(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LingeringEffectDuration;                           // 0x0628(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_62C[0x4];                                      // 0x062C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           VisibilityCheckSpyBones;                           // 0x0630(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_640[0x8];                                      // 0x0640(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASpy*>                           SeenSpies;                                         // 0x0648(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnSeenSpyUndercoverChanged(bool bUndercover);
	void Server_SpySeenChange(class ASpy* SpyIn, bool bSeenIn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OctoActiveAbilityMod2">();
	}
	static class AOctoActiveAbilityMod2* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOctoActiveAbilityMod2>();
	}
};
static_assert(alignof(AOctoActiveAbilityMod2) == 0x000008, "Wrong alignment on AOctoActiveAbilityMod2");
static_assert(sizeof(AOctoActiveAbilityMod2) == 0x000658, "Wrong size on AOctoActiveAbilityMod2");
static_assert(offsetof(AOctoActiveAbilityMod2, SeenOutOfCoverSpyVictimEffects) == 0x000610, "Member 'AOctoActiveAbilityMod2::SeenOutOfCoverSpyVictimEffects' has a wrong offset!");
static_assert(offsetof(AOctoActiveAbilityMod2, DetectionRange) == 0x000620, "Member 'AOctoActiveAbilityMod2::DetectionRange' has a wrong offset!");
static_assert(offsetof(AOctoActiveAbilityMod2, DetectionAngle) == 0x000624, "Member 'AOctoActiveAbilityMod2::DetectionAngle' has a wrong offset!");
static_assert(offsetof(AOctoActiveAbilityMod2, LingeringEffectDuration) == 0x000628, "Member 'AOctoActiveAbilityMod2::LingeringEffectDuration' has a wrong offset!");
static_assert(offsetof(AOctoActiveAbilityMod2, VisibilityCheckSpyBones) == 0x000630, "Member 'AOctoActiveAbilityMod2::VisibilityCheckSpyBones' has a wrong offset!");
static_assert(offsetof(AOctoActiveAbilityMod2, SeenSpies) == 0x000648, "Member 'AOctoActiveAbilityMod2::SeenSpies' has a wrong offset!");

// Class DeceiveInc.ToReachRoomCellsInterface
// 0x0000 (0x0028 - 0x0028)
class IToReachRoomCellsInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToReachRoomCellsInterface">();
	}
	static class IToReachRoomCellsInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IToReachRoomCellsInterface>();
	}
};
static_assert(alignof(IToReachRoomCellsInterface) == 0x000008, "Wrong alignment on IToReachRoomCellsInterface");
static_assert(sizeof(IToReachRoomCellsInterface) == 0x000028, "Wrong size on IToReachRoomCellsInterface");

// Class DeceiveInc.OctoIntelDrainZone
// 0x0020 (0x0240 - 0x0220)
class AOctoIntelDrainZone final : public AActor
{
public:
	class UCapsuleComponent*                      DetectionCollisionShapeComp;                       // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoneRadius;                                        // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoneHeight;                                        // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OctoIntelDrainZone">();
	}
	static class AOctoIntelDrainZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOctoIntelDrainZone>();
	}
};
static_assert(alignof(AOctoIntelDrainZone) == 0x000008, "Wrong alignment on AOctoIntelDrainZone");
static_assert(sizeof(AOctoIntelDrainZone) == 0x000240, "Wrong size on AOctoIntelDrainZone");
static_assert(offsetof(AOctoIntelDrainZone, DetectionCollisionShapeComp) == 0x000220, "Member 'AOctoIntelDrainZone::DetectionCollisionShapeComp' has a wrong offset!");
static_assert(offsetof(AOctoIntelDrainZone, ZoneRadius) == 0x000228, "Member 'AOctoIntelDrainZone::ZoneRadius' has a wrong offset!");
static_assert(offsetof(AOctoIntelDrainZone, ZoneHeight) == 0x00022C, "Member 'AOctoIntelDrainZone::ZoneHeight' has a wrong offset!");

// Class DeceiveInc.OctoIntelDrainZoneVisualFeedback
// 0x0030 (0x0250 - 0x0220)
class AOctoIntelDrainZoneVisualFeedback final : public AActor
{
public:
	float                                         ZoneRadius;                                        // 0x0220(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoneHeight;                                        // 0x0224(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 FactionsEffectingZone;                             // 0x0230(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	class ABaseIntelActor*                        RepActorIntel;                                     // 0x0240(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_FactionsEffectingZone();
	void OnRep_IntelActor();

	class ABaseIntelActor* GetIntelActor() const;
	int32 GetRefCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OctoIntelDrainZoneVisualFeedback">();
	}
	static class AOctoIntelDrainZoneVisualFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOctoIntelDrainZoneVisualFeedback>();
	}
};
static_assert(alignof(AOctoIntelDrainZoneVisualFeedback) == 0x000008, "Wrong alignment on AOctoIntelDrainZoneVisualFeedback");
static_assert(sizeof(AOctoIntelDrainZoneVisualFeedback) == 0x000250, "Wrong size on AOctoIntelDrainZoneVisualFeedback");
static_assert(offsetof(AOctoIntelDrainZoneVisualFeedback, ZoneRadius) == 0x000220, "Member 'AOctoIntelDrainZoneVisualFeedback::ZoneRadius' has a wrong offset!");
static_assert(offsetof(AOctoIntelDrainZoneVisualFeedback, ZoneHeight) == 0x000224, "Member 'AOctoIntelDrainZoneVisualFeedback::ZoneHeight' has a wrong offset!");
static_assert(offsetof(AOctoIntelDrainZoneVisualFeedback, FactionsEffectingZone) == 0x000230, "Member 'AOctoIntelDrainZoneVisualFeedback::FactionsEffectingZone' has a wrong offset!");
static_assert(offsetof(AOctoIntelDrainZoneVisualFeedback, RepActorIntel) == 0x000240, "Member 'AOctoIntelDrainZoneVisualFeedback::RepActorIntel' has a wrong offset!");

// Class DeceiveInc.UIStyleDataAsset
// 0x0088 (0x00C0 - 0x0038)
class UUIStyleDataAsset final : public UDIPrimaryDataAsset
{
public:
	struct FSlateBrush                            FocusBrush;                                        // 0x0038(0x0088)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStyleDataAsset">();
	}
	static class UUIStyleDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStyleDataAsset>();
	}
};
static_assert(alignof(UUIStyleDataAsset) == 0x000008, "Wrong alignment on UUIStyleDataAsset");
static_assert(sizeof(UUIStyleDataAsset) == 0x0000C0, "Wrong size on UUIStyleDataAsset");
static_assert(offsetof(UUIStyleDataAsset, FocusBrush) == 0x000038, "Member 'UUIStyleDataAsset::FocusBrush' has a wrong offset!");

// Class DeceiveInc.OctoPassiveAbilityMod2
// 0x0008 (0x05B8 - 0x05B0)
class AOctoPassiveAbilityMod2 final : public AOctoPassiveAbilityLuckBased
{
public:
	float                                         PercentChancesToRefillActive;                      // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RefundActivePercent;                               // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OctoPassiveAbilityMod2">();
	}
	static class AOctoPassiveAbilityMod2* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOctoPassiveAbilityMod2>();
	}
};
static_assert(alignof(AOctoPassiveAbilityMod2) == 0x000008, "Wrong alignment on AOctoPassiveAbilityMod2");
static_assert(sizeof(AOctoPassiveAbilityMod2) == 0x0005B8, "Wrong size on AOctoPassiveAbilityMod2");
static_assert(offsetof(AOctoPassiveAbilityMod2, PercentChancesToRefillActive) == 0x0005B0, "Member 'AOctoPassiveAbilityMod2::PercentChancesToRefillActive' has a wrong offset!");
static_assert(offsetof(AOctoPassiveAbilityMod2, RefundActivePercent) == 0x0005B4, "Member 'AOctoPassiveAbilityMod2::RefundActivePercent' has a wrong offset!");

// Class DeceiveInc.PeripheralChromaPatternDataAsset
// 0x0050 (0x0088 - 0x0038)
class UPeripheralChromaPatternDataAsset final : public UDIPrimaryDataAsset
{
public:
	TMap<EPeripheralPatternType, class FName>     PatternNames;                                      // 0x0038(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PeripheralChromaPatternDataAsset">();
	}
	static class UPeripheralChromaPatternDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPeripheralChromaPatternDataAsset>();
	}
};
static_assert(alignof(UPeripheralChromaPatternDataAsset) == 0x000008, "Wrong alignment on UPeripheralChromaPatternDataAsset");
static_assert(sizeof(UPeripheralChromaPatternDataAsset) == 0x000088, "Wrong size on UPeripheralChromaPatternDataAsset");
static_assert(offsetof(UPeripheralChromaPatternDataAsset, PatternNames) == 0x000038, "Member 'UPeripheralChromaPatternDataAsset::PatternNames' has a wrong offset!");

// Class DeceiveInc.PingSystemDataAsset
// 0x00F0 (0x0128 - 0x0038)
class UPingSystemDataAsset final : public UDIPrimaryDataAsset
{
public:
	TArray<struct FPingInfo>                      DoorPingInfoPerLevel;                              // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPingInfo>                      PowerupPingInfoPerLevel;                           // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPingInfo>                      PowerupChestPingInfoPerLevel;                      // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPingInfo>                      KeycardPingInfoPerLevel;                           // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<EInteractableType, struct FPingInfo>     InteractablePingInfo;                              // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<ESpyToolType, struct FPingInfo>          SpyToolPingInfo;                                   // 0x00C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FPingInfo>                      RadialMenuPingTextures;                            // 0x0118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PingSystemDataAsset">();
	}
	static class UPingSystemDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPingSystemDataAsset>();
	}
};
static_assert(alignof(UPingSystemDataAsset) == 0x000008, "Wrong alignment on UPingSystemDataAsset");
static_assert(sizeof(UPingSystemDataAsset) == 0x000128, "Wrong size on UPingSystemDataAsset");
static_assert(offsetof(UPingSystemDataAsset, DoorPingInfoPerLevel) == 0x000038, "Member 'UPingSystemDataAsset::DoorPingInfoPerLevel' has a wrong offset!");
static_assert(offsetof(UPingSystemDataAsset, PowerupPingInfoPerLevel) == 0x000048, "Member 'UPingSystemDataAsset::PowerupPingInfoPerLevel' has a wrong offset!");
static_assert(offsetof(UPingSystemDataAsset, PowerupChestPingInfoPerLevel) == 0x000058, "Member 'UPingSystemDataAsset::PowerupChestPingInfoPerLevel' has a wrong offset!");
static_assert(offsetof(UPingSystemDataAsset, KeycardPingInfoPerLevel) == 0x000068, "Member 'UPingSystemDataAsset::KeycardPingInfoPerLevel' has a wrong offset!");
static_assert(offsetof(UPingSystemDataAsset, InteractablePingInfo) == 0x000078, "Member 'UPingSystemDataAsset::InteractablePingInfo' has a wrong offset!");
static_assert(offsetof(UPingSystemDataAsset, SpyToolPingInfo) == 0x0000C8, "Member 'UPingSystemDataAsset::SpyToolPingInfo' has a wrong offset!");
static_assert(offsetof(UPingSystemDataAsset, RadialMenuPingTextures) == 0x000118, "Member 'UPingSystemDataAsset::RadialMenuPingTextures' has a wrong offset!");

// Class DeceiveInc.PlayableAgentList
// 0x0020 (0x0058 - 0x0038)
class UPlayableAgentList final : public UDIPrimaryDataAsset
{
public:
	TArray<struct FPrimaryAssetId>                Agents;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                FallbackAgents;                                    // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayableAgentList">();
	}
	static class UPlayableAgentList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayableAgentList>();
	}
};
static_assert(alignof(UPlayableAgentList) == 0x000008, "Wrong alignment on UPlayableAgentList");
static_assert(sizeof(UPlayableAgentList) == 0x000058, "Wrong size on UPlayableAgentList");
static_assert(offsetof(UPlayableAgentList, Agents) == 0x000038, "Member 'UPlayableAgentList::Agents' has a wrong offset!");
static_assert(offsetof(UPlayableAgentList, FallbackAgents) == 0x000048, "Member 'UPlayableAgentList::FallbackAgents' has a wrong offset!");

// Class DeceiveInc.PlayerBPLibrary
// 0x0000 (0x0028 - 0x0028)
class UPlayerBPLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class ASpy* GetHUDPlayerSpy(class UObject* WorldContextObject);
	static class USkeletalMesh* GetWatchingPlayerDisguiseMesh(class UObject* WorldContextObject);
	static class ASpy* GetWatchingPlayerSpy(class UObject* WorldContextObject);
	static bool IsSpectating(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerBPLibrary">();
	}
	static class UPlayerBPLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerBPLibrary>();
	}
};
static_assert(alignof(UPlayerBPLibrary) == 0x000008, "Wrong alignment on UPlayerBPLibrary");
static_assert(sizeof(UPlayerBPLibrary) == 0x000028, "Wrong size on UPlayerBPLibrary");

// Class DeceiveInc.PlayerNameWidgetComponent
// 0x0000 (0x05C0 - 0x05C0)
class UPlayerNameWidgetComponent final : public UFacingWidgetComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerNameWidgetComponent">();
	}
	static class UPlayerNameWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerNameWidgetComponent>();
	}
};
static_assert(alignof(UPlayerNameWidgetComponent) == 0x000010, "Wrong alignment on UPlayerNameWidgetComponent");
static_assert(sizeof(UPlayerNameWidgetComponent) == 0x0005C0, "Wrong size on UPlayerNameWidgetComponent");

// Class DeceiveInc.PlayerTalkingWidget
// 0x0020 (0x0280 - 0x0260)
class UPlayerTalkingWidget final : public UUserWidget
{
public:
	int32                                         PlayerTeamIndex;                                   // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bManagedByPlayerController;                        // 0x0264(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_265[0x1B];                                     // 0x0265(0x001B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnPlayerChange(const class FString& NewPlayerName);
	void BP_OnPlayerTalkBegin();
	void BP_OnPlayerTalkEnd();
	void HandlePlayerTakingUpdate(bool bTalking);

	float GetNormalizedAmplitude() const;
	class FString GetPlayerName() const;
	class ADIPlayerState* GetPlayerState() const;
	bool IsPlayerTalking() const;
	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerTalkingWidget">();
	}
	static class UPlayerTalkingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerTalkingWidget>();
	}
};
static_assert(alignof(UPlayerTalkingWidget) == 0x000008, "Wrong alignment on UPlayerTalkingWidget");
static_assert(sizeof(UPlayerTalkingWidget) == 0x000280, "Wrong size on UPlayerTalkingWidget");
static_assert(offsetof(UPlayerTalkingWidget, PlayerTeamIndex) == 0x000260, "Member 'UPlayerTalkingWidget::PlayerTeamIndex' has a wrong offset!");
static_assert(offsetof(UPlayerTalkingWidget, bManagedByPlayerController) == 0x000264, "Member 'UPlayerTalkingWidget::bManagedByPlayerController' has a wrong offset!");

// Class DeceiveInc.PointOfInterestSubsystem
// 0x0018 (0x0048 - 0x0030)
class UPointOfInterestSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PointOfInterestSubsystem">();
	}
	static class UPointOfInterestSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPointOfInterestSubsystem>();
	}
};
static_assert(alignof(UPointOfInterestSubsystem) == 0x000008, "Wrong alignment on UPointOfInterestSubsystem");
static_assert(sizeof(UPointOfInterestSubsystem) == 0x000048, "Wrong size on UPointOfInterestSubsystem");

// Class DeceiveInc.PoisonedConditionComponent
// 0x0000 (0x00D0 - 0x00D0)
class UPoisonedConditionComponent final : public UBaseConditionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoisonedConditionComponent">();
	}
	static class UPoisonedConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPoisonedConditionComponent>();
	}
};
static_assert(alignof(UPoisonedConditionComponent) == 0x000008, "Wrong alignment on UPoisonedConditionComponent");
static_assert(sizeof(UPoisonedConditionComponent) == 0x0000D0, "Wrong size on UPoisonedConditionComponent");

// Class DeceiveInc.VigilActiveAbility
// 0x0048 (0x05D8 - 0x0590)
class AVigilActiveAbility final : public ABaseSpyActiveAbility
{
public:
	TSubclassOf<class AProjectileWeapon>          WeaponClass;                                       // 0x0590(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnequipDelay;                                      // 0x0598(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59C[0x4];                                      // 0x059C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAbilityWeaponSpawned;                            // 0x05A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AProjectileWeapon*                      ReplicatedAbilityWeapon;                           // 0x05B8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayResourcesComponent*            GameplayResourceComponent;                         // 0x05C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C8[0x10];                                     // 0x05C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AProjectileWeapon* GetAbilityWeapon();
	void OnRep_ReplicatedAbilityWeapon(class AProjectileWeapon* PrevWeapon);
	void OnResourceAmountChanged(int32 TotalBulletLeft);
	void OnUnequipDelayTimerEnd();
	void OnWeaponEvent(ESpyToolEvent EventType, class ABaseSpyTool* SpyTool);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VigilActiveAbility">();
	}
	static class AVigilActiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVigilActiveAbility>();
	}
};
static_assert(alignof(AVigilActiveAbility) == 0x000008, "Wrong alignment on AVigilActiveAbility");
static_assert(sizeof(AVigilActiveAbility) == 0x0005D8, "Wrong size on AVigilActiveAbility");
static_assert(offsetof(AVigilActiveAbility, WeaponClass) == 0x000590, "Member 'AVigilActiveAbility::WeaponClass' has a wrong offset!");
static_assert(offsetof(AVigilActiveAbility, UnequipDelay) == 0x000598, "Member 'AVigilActiveAbility::UnequipDelay' has a wrong offset!");
static_assert(offsetof(AVigilActiveAbility, OnAbilityWeaponSpawned) == 0x0005A0, "Member 'AVigilActiveAbility::OnAbilityWeaponSpawned' has a wrong offset!");
static_assert(offsetof(AVigilActiveAbility, ReplicatedAbilityWeapon) == 0x0005B8, "Member 'AVigilActiveAbility::ReplicatedAbilityWeapon' has a wrong offset!");
static_assert(offsetof(AVigilActiveAbility, GameplayResourceComponent) == 0x0005C0, "Member 'AVigilActiveAbility::GameplayResourceComponent' has a wrong offset!");

// Class DeceiveInc.DIPopulationManagerRoomWeightDataAsset
// 0x0090 (0x00C8 - 0x0038)
class UDIPopulationManagerRoomWeightDataAsset final : public UDIPrimaryDataAsset
{
public:
	struct FRoomWeightMultiplierBySLevel          RoomWeightMultiplierByNPCPool[0x7];                // 0x0038(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIPopulationManagerRoomWeightDataAsset">();
	}
	static class UDIPopulationManagerRoomWeightDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIPopulationManagerRoomWeightDataAsset>();
	}
};
static_assert(alignof(UDIPopulationManagerRoomWeightDataAsset) == 0x000008, "Wrong alignment on UDIPopulationManagerRoomWeightDataAsset");
static_assert(sizeof(UDIPopulationManagerRoomWeightDataAsset) == 0x0000C8, "Wrong size on UDIPopulationManagerRoomWeightDataAsset");
static_assert(offsetof(UDIPopulationManagerRoomWeightDataAsset, RoomWeightMultiplierByNPCPool) == 0x000038, "Member 'UDIPopulationManagerRoomWeightDataAsset::RoomWeightMultiplierByNPCPool' has a wrong offset!");

// Class DeceiveInc.DIPopulationManagerNPCSuspiciousnessDataAsset
// 0x0010 (0x0048 - 0x0038)
class UDIPopulationManagerNPCSuspiciousnessDataAsset final : public UDIPrimaryDataAsset
{
public:
	TArray<struct FNPCSuspiciousRankParams>       NPCSuspiciousness;                                 // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DIPopulationManagerNPCSuspiciousnessDataAsset">();
	}
	static class UDIPopulationManagerNPCSuspiciousnessDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDIPopulationManagerNPCSuspiciousnessDataAsset>();
	}
};
static_assert(alignof(UDIPopulationManagerNPCSuspiciousnessDataAsset) == 0x000008, "Wrong alignment on UDIPopulationManagerNPCSuspiciousnessDataAsset");
static_assert(sizeof(UDIPopulationManagerNPCSuspiciousnessDataAsset) == 0x000048, "Wrong size on UDIPopulationManagerNPCSuspiciousnessDataAsset");
static_assert(offsetof(UDIPopulationManagerNPCSuspiciousnessDataAsset, NPCSuspiciousness) == 0x000038, "Member 'UDIPopulationManagerNPCSuspiciousnessDataAsset::NPCSuspiciousness' has a wrong offset!");

// Class DeceiveInc.PopulationManager
// 0x0738 (0x0958 - 0x0220)
class APopulationManager final : public AActor
{
public:
	struct FSpawnNPCLevelData                     SpawnNPCLevelData[0x7];                            // 0x0220(0x0018)(Edit, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FRoomWeightMultiplierBySLevel          RoomWeightMultiplierByNPCPool[0x7];                // 0x02C8(0x0014)(Edit, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         GuardsPercentageSpawningInVault;                   // 0x0354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EliteGuardsPercentageSpawningInVault;              // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaffsPercentageSpawningInVault;                   // 0x035C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNPCSuspiciousRankParams>       NPCSuspiciousness;                                 // 0x0360(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<float>                                 RunFactorAtTerminalActivatedCount;                 // 0x0370(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         RunFactorAtInfiltrationPhase;                      // 0x0380(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunFactorAtExtractionPhase;                        // 0x0384(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AProjectileWeapon>>  GuardWeaponsRefs;                                  // 0x0388(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FDangerScareSettings                   DangerScareSettings;                               // 0x0398(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPopulationSpawned;                               // 0x03F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         OnGoingFightInRoomDuration;                        // 0x0408(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OnGoingFightInRoomScareNPCDuration;                // 0x040C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDIPopulationManagerNpcSpawnDataAsset*  NPCSpawnData;                                      // 0x0410(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EDIGameMode, class UDIPopulationManagerNpcSpawnDataAsset*> NPCSpawnDataByModeOverride;                        // 0x0418(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	class UDIPopulationManagerRoomWeightDataAsset* RoomWeightData;                                    // 0x0468(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EDIGameMode, class UDIPopulationManagerRoomWeightDataAsset*> RoomWeightDataByModeOverride;                      // 0x0470(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	class UDIPopulationManagerNPCSuspiciousnessDataAsset* NPCSuspiciousnessData;                             // 0x04C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EDIGameMode, class UDIPopulationManagerNPCSuspiciousnessDataAsset*> NPCSuspiciousnessDataByModeOverride;               // 0x04C8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	class UDIPopulationManagerNpcSpawnDataAsset*  InstanceNPCSpawnData;                              // 0x0518(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDIPopulationManagerRoomWeightDataAsset* InstanceRoomWeightData;                            // 0x0520(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDIPopulationManagerNPCSuspiciousnessDataAsset* InstanceNPCSuspiciousnessData;                     // 0x0528(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_530[0x270];                                    // 0x0530(0x0270)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ANPCCharacter*>                  AllNPCToPossess;                                   // 0x07A0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B0[0x8];                                      // 0x07B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ANPCCharacter>>   InitialPopulationNPCs;                             // 0x07B8(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C8[0xB0];                                     // 0x07C8(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ANPCCharacter*>                  AllNPCs;                                           // 0x0878(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_888[0x20];                                     // 0x0888(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint64, struct FDangerSourceStorage>     DelayedDangerStorage;                              // 0x08A8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class ADIPlayerState*, struct FPopManCacheEntry> PerPlayerNPCCache;                                 // 0x08F8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<class ADIPlayerState*>                 PendingCache;                                      // 0x0948(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static void BP_TriggerDangerEventAtPos(class AActor* DangerCause, const struct FVector& DangerPos);

	void HandleSpySpawnedEvent(class ASpy* Spy);
	void OnGamePhaseChanged(ESpyGamePhase NewGamePhase);
	void OnVaultTerminalUnlockedCountChanged(int32 VaultTerminalUnlockedCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PopulationManager">();
	}
	static class APopulationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<APopulationManager>();
	}
};
static_assert(alignof(APopulationManager) == 0x000008, "Wrong alignment on APopulationManager");
static_assert(sizeof(APopulationManager) == 0x000958, "Wrong size on APopulationManager");
static_assert(offsetof(APopulationManager, SpawnNPCLevelData) == 0x000220, "Member 'APopulationManager::SpawnNPCLevelData' has a wrong offset!");
static_assert(offsetof(APopulationManager, RoomWeightMultiplierByNPCPool) == 0x0002C8, "Member 'APopulationManager::RoomWeightMultiplierByNPCPool' has a wrong offset!");
static_assert(offsetof(APopulationManager, GuardsPercentageSpawningInVault) == 0x000354, "Member 'APopulationManager::GuardsPercentageSpawningInVault' has a wrong offset!");
static_assert(offsetof(APopulationManager, EliteGuardsPercentageSpawningInVault) == 0x000358, "Member 'APopulationManager::EliteGuardsPercentageSpawningInVault' has a wrong offset!");
static_assert(offsetof(APopulationManager, StaffsPercentageSpawningInVault) == 0x00035C, "Member 'APopulationManager::StaffsPercentageSpawningInVault' has a wrong offset!");
static_assert(offsetof(APopulationManager, NPCSuspiciousness) == 0x000360, "Member 'APopulationManager::NPCSuspiciousness' has a wrong offset!");
static_assert(offsetof(APopulationManager, RunFactorAtTerminalActivatedCount) == 0x000370, "Member 'APopulationManager::RunFactorAtTerminalActivatedCount' has a wrong offset!");
static_assert(offsetof(APopulationManager, RunFactorAtInfiltrationPhase) == 0x000380, "Member 'APopulationManager::RunFactorAtInfiltrationPhase' has a wrong offset!");
static_assert(offsetof(APopulationManager, RunFactorAtExtractionPhase) == 0x000384, "Member 'APopulationManager::RunFactorAtExtractionPhase' has a wrong offset!");
static_assert(offsetof(APopulationManager, GuardWeaponsRefs) == 0x000388, "Member 'APopulationManager::GuardWeaponsRefs' has a wrong offset!");
static_assert(offsetof(APopulationManager, DangerScareSettings) == 0x000398, "Member 'APopulationManager::DangerScareSettings' has a wrong offset!");
static_assert(offsetof(APopulationManager, OnPopulationSpawned) == 0x0003F8, "Member 'APopulationManager::OnPopulationSpawned' has a wrong offset!");
static_assert(offsetof(APopulationManager, OnGoingFightInRoomDuration) == 0x000408, "Member 'APopulationManager::OnGoingFightInRoomDuration' has a wrong offset!");
static_assert(offsetof(APopulationManager, OnGoingFightInRoomScareNPCDuration) == 0x00040C, "Member 'APopulationManager::OnGoingFightInRoomScareNPCDuration' has a wrong offset!");
static_assert(offsetof(APopulationManager, NPCSpawnData) == 0x000410, "Member 'APopulationManager::NPCSpawnData' has a wrong offset!");
static_assert(offsetof(APopulationManager, NPCSpawnDataByModeOverride) == 0x000418, "Member 'APopulationManager::NPCSpawnDataByModeOverride' has a wrong offset!");
static_assert(offsetof(APopulationManager, RoomWeightData) == 0x000468, "Member 'APopulationManager::RoomWeightData' has a wrong offset!");
static_assert(offsetof(APopulationManager, RoomWeightDataByModeOverride) == 0x000470, "Member 'APopulationManager::RoomWeightDataByModeOverride' has a wrong offset!");
static_assert(offsetof(APopulationManager, NPCSuspiciousnessData) == 0x0004C0, "Member 'APopulationManager::NPCSuspiciousnessData' has a wrong offset!");
static_assert(offsetof(APopulationManager, NPCSuspiciousnessDataByModeOverride) == 0x0004C8, "Member 'APopulationManager::NPCSuspiciousnessDataByModeOverride' has a wrong offset!");
static_assert(offsetof(APopulationManager, InstanceNPCSpawnData) == 0x000518, "Member 'APopulationManager::InstanceNPCSpawnData' has a wrong offset!");
static_assert(offsetof(APopulationManager, InstanceRoomWeightData) == 0x000520, "Member 'APopulationManager::InstanceRoomWeightData' has a wrong offset!");
static_assert(offsetof(APopulationManager, InstanceNPCSuspiciousnessData) == 0x000528, "Member 'APopulationManager::InstanceNPCSuspiciousnessData' has a wrong offset!");
static_assert(offsetof(APopulationManager, AllNPCToPossess) == 0x0007A0, "Member 'APopulationManager::AllNPCToPossess' has a wrong offset!");
static_assert(offsetof(APopulationManager, InitialPopulationNPCs) == 0x0007B8, "Member 'APopulationManager::InitialPopulationNPCs' has a wrong offset!");
static_assert(offsetof(APopulationManager, AllNPCs) == 0x000878, "Member 'APopulationManager::AllNPCs' has a wrong offset!");
static_assert(offsetof(APopulationManager, DelayedDangerStorage) == 0x0008A8, "Member 'APopulationManager::DelayedDangerStorage' has a wrong offset!");
static_assert(offsetof(APopulationManager, PerPlayerNPCCache) == 0x0008F8, "Member 'APopulationManager::PerPlayerNPCCache' has a wrong offset!");
static_assert(offsetof(APopulationManager, PendingCache) == 0x000948, "Member 'APopulationManager::PendingCache' has a wrong offset!");

// Class DeceiveInc.VoicechatMemberContainerWidget
// 0x0020 (0x0280 - 0x0260)
class UVoicechatMemberContainerWidget : public UUserWidget
{
public:
	TArray<struct FVoicechatMemberData>           InstancedMemberWidgets;                            // 0x0260(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UVoicechatMemberWidget>     VoiceChatMemberWidgetClass;                        // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FreeSlotForMemberWidget(class UVoicechatMemberWidget* MemberWidget);
	void HandleChatMemberTalkingEvent(const class FString& PlayerChatID, const class FString& ChannelName, bool bTalking);
	void HandleVoiceChatPlayerRemovedFromChannel(const class FString& PlayerChatID, const class FString& ChannelName);
	void ReserveSlotForMemberWidget(class UVoicechatMemberWidget* MemberWidget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoicechatMemberContainerWidget">();
	}
	static class UVoicechatMemberContainerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoicechatMemberContainerWidget>();
	}
};
static_assert(alignof(UVoicechatMemberContainerWidget) == 0x000008, "Wrong alignment on UVoicechatMemberContainerWidget");
static_assert(sizeof(UVoicechatMemberContainerWidget) == 0x000280, "Wrong size on UVoicechatMemberContainerWidget");
static_assert(offsetof(UVoicechatMemberContainerWidget, InstancedMemberWidgets) == 0x000260, "Member 'UVoicechatMemberContainerWidget::InstancedMemberWidgets' has a wrong offset!");
static_assert(offsetof(UVoicechatMemberContainerWidget, VoiceChatMemberWidgetClass) == 0x000270, "Member 'UVoicechatMemberContainerWidget::VoiceChatMemberWidgetClass' has a wrong offset!");

// Class DeceiveInc.PosingSpyActorContainer
// 0x0110 (0x01C0 - 0x00B0)
class UPosingSpyActorContainer final : public UActorComponent
{
public:
	struct FPrimaryAssetId                        DisplayedAgentId;                                  // 0x00B0(0x0010)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        DisplayedWeaponId;                                 // 0x00C0(0x0010)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        DisplayedWrapId;                                   // 0x00D0(0x0010)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x20];                                      // 0x00E0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DisplayedIndex;                                    // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bManualSetup;                                      // 0x0104(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceShowMenuSelection;                           // 0x0105(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceSyncLoad;                                    // 0x0106(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayIntroPose;                                    // 0x0107(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowMouseRotation;                               // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IntroPosePlayDelay;                                // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x8];                                      // 0x0110(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APosingSpy*                             CurrentPosingSpy;                                  // 0x0118(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class ADIPlayerState>          CurrentDIPlayerState;                              // 0x0120(0x0028)(BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnPosingSpySpawned;                                // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0x68];                                     // 0x0158(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearAnimationProps();
	void CreateAnimationProp(const struct FAnimationPropData& PropsIn, bool bLooping);
	void CreateAnimationProps(const TArray<struct FAnimationPropData>& PropIn, bool bLooping);
	void CreateChildren();
	void DestroyOwnerChildren();
	void HandleDisplayedWrapChangedDelegate(const struct FPrimaryAssetId& WeaponId, const struct FPrimaryAssetId& WrapId, int32 DisplayedWrapIndex);
	void HandleLoadoutSpawnComplete(class UToolLoadoutComponent* ToolLoadout);
	void HandlePlayerStateModified();
	void HandleSpySpawnedEvent(class ASpy* Spy);
	void HandleStateArrayModified();
	void OnDelayedIntroPoseTimer();
	void OnDisplayedAgentChangedDelegate(const struct FPrimaryAssetId& AgentSkinId, int32 DisplayedAgentIndex);
	void OnDisplayedIntroPoseChangedDelegate(const struct FPrimaryAssetId& IntroPoseId, int32 DisplayedAgentIndex);
	void OnIntroPoseLoop();
	void PlayIntroPoseAnimation(const struct FPrimaryAssetId& IntroPoseId, bool bStartPaused);
	void PlaySelectedIntroPoseAnimation();
	void SetupFromPlayerState(class ADIPlayerState* DIPlayeState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PosingSpyActorContainer">();
	}
	static class UPosingSpyActorContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPosingSpyActorContainer>();
	}
};
static_assert(alignof(UPosingSpyActorContainer) == 0x000008, "Wrong alignment on UPosingSpyActorContainer");
static_assert(sizeof(UPosingSpyActorContainer) == 0x0001C0, "Wrong size on UPosingSpyActorContainer");
static_assert(offsetof(UPosingSpyActorContainer, DisplayedAgentId) == 0x0000B0, "Member 'UPosingSpyActorContainer::DisplayedAgentId' has a wrong offset!");
static_assert(offsetof(UPosingSpyActorContainer, DisplayedWeaponId) == 0x0000C0, "Member 'UPosingSpyActorContainer::DisplayedWeaponId' has a wrong offset!");
static_assert(offsetof(UPosingSpyActorContainer, DisplayedWrapId) == 0x0000D0, "Member 'UPosingSpyActorContainer::DisplayedWrapId' has a wrong offset!");
static_assert(offsetof(UPosingSpyActorContainer, DisplayedIndex) == 0x000100, "Member 'UPosingSpyActorContainer::DisplayedIndex' has a wrong offset!");
static_assert(offsetof(UPosingSpyActorContainer, bManualSetup) == 0x000104, "Member 'UPosingSpyActorContainer::bManualSetup' has a wrong offset!");
static_assert(offsetof(UPosingSpyActorContainer, bForceShowMenuSelection) == 0x000105, "Member 'UPosingSpyActorContainer::bForceShowMenuSelection' has a wrong offset!");
static_assert(offsetof(UPosingSpyActorContainer, bForceSyncLoad) == 0x000106, "Member 'UPosingSpyActorContainer::bForceSyncLoad' has a wrong offset!");
static_assert(offsetof(UPosingSpyActorContainer, bPlayIntroPose) == 0x000107, "Member 'UPosingSpyActorContainer::bPlayIntroPose' has a wrong offset!");
static_assert(offsetof(UPosingSpyActorContainer, bAllowMouseRotation) == 0x000108, "Member 'UPosingSpyActorContainer::bAllowMouseRotation' has a wrong offset!");
static_assert(offsetof(UPosingSpyActorContainer, IntroPosePlayDelay) == 0x00010C, "Member 'UPosingSpyActorContainer::IntroPosePlayDelay' has a wrong offset!");
static_assert(offsetof(UPosingSpyActorContainer, CurrentPosingSpy) == 0x000118, "Member 'UPosingSpyActorContainer::CurrentPosingSpy' has a wrong offset!");
static_assert(offsetof(UPosingSpyActorContainer, CurrentDIPlayerState) == 0x000120, "Member 'UPosingSpyActorContainer::CurrentDIPlayerState' has a wrong offset!");
static_assert(offsetof(UPosingSpyActorContainer, OnPosingSpySpawned) == 0x000148, "Member 'UPosingSpyActorContainer::OnPosingSpySpawned' has a wrong offset!");

// Class DeceiveInc.PosingSpyAnimInstance
// 0x0010 (0x02D0 - 0x02C0)
class UPosingSpyAnimInstance final : public UAnimInstance
{
public:
	class UAnimSequence*                          CurAnimationSequence1;                             // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CurAnimationSequence2;                             // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping1;                                         // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping2;                                         // 0x02C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSecondAnimation;                                  // 0x02CA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimationPaused;                                  // 0x02CB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_SetAnimationPaused(bool bPaused);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PosingSpyAnimInstance">();
	}
	static class UPosingSpyAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPosingSpyAnimInstance>();
	}
};
static_assert(alignof(UPosingSpyAnimInstance) == 0x000010, "Wrong alignment on UPosingSpyAnimInstance");
static_assert(sizeof(UPosingSpyAnimInstance) == 0x0002D0, "Wrong size on UPosingSpyAnimInstance");
static_assert(offsetof(UPosingSpyAnimInstance, CurAnimationSequence1) == 0x0002B8, "Member 'UPosingSpyAnimInstance::CurAnimationSequence1' has a wrong offset!");
static_assert(offsetof(UPosingSpyAnimInstance, CurAnimationSequence2) == 0x0002C0, "Member 'UPosingSpyAnimInstance::CurAnimationSequence2' has a wrong offset!");
static_assert(offsetof(UPosingSpyAnimInstance, bLooping1) == 0x0002C8, "Member 'UPosingSpyAnimInstance::bLooping1' has a wrong offset!");
static_assert(offsetof(UPosingSpyAnimInstance, bLooping2) == 0x0002C9, "Member 'UPosingSpyAnimInstance::bLooping2' has a wrong offset!");
static_assert(offsetof(UPosingSpyAnimInstance, bSecondAnimation) == 0x0002CA, "Member 'UPosingSpyAnimInstance::bSecondAnimation' has a wrong offset!");
static_assert(offsetof(UPosingSpyAnimInstance, bAnimationPaused) == 0x0002CB, "Member 'UPosingSpyAnimInstance::bAnimationPaused' has a wrong offset!");

// Class DeceiveInc.PoudrierActor
// 0x0028 (0x0248 - 0x0220)
class APoudrierActor final : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnActiveSpyToolChanged;                            // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPoudrierVisibilityChanged;                       // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ABaseSpyTool*                           ActiveSpyTool;                                     // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class ABaseSpyTool* GetActiveSpyTool() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoudrierActor">();
	}
	static class APoudrierActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APoudrierActor>();
	}
};
static_assert(alignof(APoudrierActor) == 0x000008, "Wrong alignment on APoudrierActor");
static_assert(sizeof(APoudrierActor) == 0x000248, "Wrong size on APoudrierActor");
static_assert(offsetof(APoudrierActor, OnActiveSpyToolChanged) == 0x000220, "Member 'APoudrierActor::OnActiveSpyToolChanged' has a wrong offset!");
static_assert(offsetof(APoudrierActor, OnPoudrierVisibilityChanged) == 0x000230, "Member 'APoudrierActor::OnPoudrierVisibilityChanged' has a wrong offset!");
static_assert(offsetof(APoudrierActor, ActiveSpyTool) == 0x000240, "Member 'APoudrierActor::ActiveSpyTool' has a wrong offset!");

// Class DeceiveInc.PowerupData
// 0x0210 (0x0248 - 0x0038)
class UPowerupData final : public UDIPrimaryDataAsset
{
public:
	TMap<EPowerupType, struct FMaxAmountPowerupSettings> MaxAmountSettings;                                 // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EPowerupType, struct FReductionPowerupSettings> ReductionSettings;                                 // 0x0088(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSocialBatteryData                     SocialBatteryData;                                 // 0x00D8(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFoodieData                            FoodieData;                                        // 0x0138(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FExfiltratorData                       ExfiltratorData;                                   // 0x0188(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EPowerupType, struct FPowerupInfo>       PowerupInfos;                                      // 0x01D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DefaultDeckName;                                   // 0x0228(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPerPowerupPickupData                  PerPowerupPickupData;                              // 0x0240(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_243[0x5];                                      // 0x0243(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerupData">();
	}
	static class UPowerupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPowerupData>();
	}
};
static_assert(alignof(UPowerupData) == 0x000008, "Wrong alignment on UPowerupData");
static_assert(sizeof(UPowerupData) == 0x000248, "Wrong size on UPowerupData");
static_assert(offsetof(UPowerupData, MaxAmountSettings) == 0x000038, "Member 'UPowerupData::MaxAmountSettings' has a wrong offset!");
static_assert(offsetof(UPowerupData, ReductionSettings) == 0x000088, "Member 'UPowerupData::ReductionSettings' has a wrong offset!");
static_assert(offsetof(UPowerupData, SocialBatteryData) == 0x0000D8, "Member 'UPowerupData::SocialBatteryData' has a wrong offset!");
static_assert(offsetof(UPowerupData, FoodieData) == 0x000138, "Member 'UPowerupData::FoodieData' has a wrong offset!");
static_assert(offsetof(UPowerupData, ExfiltratorData) == 0x000188, "Member 'UPowerupData::ExfiltratorData' has a wrong offset!");
static_assert(offsetof(UPowerupData, PowerupInfos) == 0x0001D8, "Member 'UPowerupData::PowerupInfos' has a wrong offset!");
static_assert(offsetof(UPowerupData, DefaultDeckName) == 0x000228, "Member 'UPowerupData::DefaultDeckName' has a wrong offset!");
static_assert(offsetof(UPowerupData, PerPowerupPickupData) == 0x000240, "Member 'UPowerupData::PerPowerupPickupData' has a wrong offset!");

// Class DeceiveInc.WebStreamedVisualAsset
// 0x0050 (0x0270 - 0x0220)
class AWebStreamedVisualAsset : public AActor
{
public:
	class UMaterialInstanceDynamic*               RTMatInstance;                                     // 0x0220(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoLoadAndApplyAssetToCanvas;                    // 0x0228(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWebStreamedAssetDefinition            AssetDefinition;                                   // 0x0230(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FName                                   MaterialPropertNameForRenderTarget;                // 0x0248(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAssetAxisScaleType                           ScaleType;                                         // 0x0250(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         CanvasMesh;                                        // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        Root;                                              // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LoadAndApplyAssetToCanvas();
	void SetWebAssetDefinition(const struct FWebStreamedAssetDefinition& InAssetDefinition);

	const struct FWebStreamedAssetDefinition GetWebAssetDefinition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WebStreamedVisualAsset">();
	}
	static class AWebStreamedVisualAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWebStreamedVisualAsset>();
	}
};
static_assert(alignof(AWebStreamedVisualAsset) == 0x000008, "Wrong alignment on AWebStreamedVisualAsset");
static_assert(sizeof(AWebStreamedVisualAsset) == 0x000270, "Wrong size on AWebStreamedVisualAsset");
static_assert(offsetof(AWebStreamedVisualAsset, RTMatInstance) == 0x000220, "Member 'AWebStreamedVisualAsset::RTMatInstance' has a wrong offset!");
static_assert(offsetof(AWebStreamedVisualAsset, bAutoLoadAndApplyAssetToCanvas) == 0x000228, "Member 'AWebStreamedVisualAsset::bAutoLoadAndApplyAssetToCanvas' has a wrong offset!");
static_assert(offsetof(AWebStreamedVisualAsset, AssetDefinition) == 0x000230, "Member 'AWebStreamedVisualAsset::AssetDefinition' has a wrong offset!");
static_assert(offsetof(AWebStreamedVisualAsset, MaterialPropertNameForRenderTarget) == 0x000248, "Member 'AWebStreamedVisualAsset::MaterialPropertNameForRenderTarget' has a wrong offset!");
static_assert(offsetof(AWebStreamedVisualAsset, ScaleType) == 0x000250, "Member 'AWebStreamedVisualAsset::ScaleType' has a wrong offset!");
static_assert(offsetof(AWebStreamedVisualAsset, CanvasMesh) == 0x000258, "Member 'AWebStreamedVisualAsset::CanvasMesh' has a wrong offset!");
static_assert(offsetof(AWebStreamedVisualAsset, Root) == 0x000260, "Member 'AWebStreamedVisualAsset::Root' has a wrong offset!");

// Class DeceiveInc.PowerupManagerComponent
// 0x0010 (0x00C0 - 0x00B0)
class UPowerupManagerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPowerupData*                           PowerupData;                                       // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static void GetExfiltratorData(const class UObject* WorldContextObject, struct FExfiltratorData* FoodieData);
	static void GetFoodieData(const class UObject* WorldContextObject, struct FFoodieData* FoodieData);
	static EPowerupType GetPowerupForLevel(class ASpy* SpyToCheck, ESecurityLevel Level);
	static void GetPowerupInfos(const class UObject* WorldContextObject, EPowerupType PowerupType, struct FPowerupInfo* PowerupInfo);
	static void GetSocialBatteryData(const class UObject* WorldContextObject, struct FSocialBatteryData* SocialBatteryData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerupManagerComponent">();
	}
	static class UPowerupManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPowerupManagerComponent>();
	}
};
static_assert(alignof(UPowerupManagerComponent) == 0x000008, "Wrong alignment on UPowerupManagerComponent");
static_assert(sizeof(UPowerupManagerComponent) == 0x0000C0, "Wrong size on UPowerupManagerComponent");
static_assert(offsetof(UPowerupManagerComponent, PowerupData) == 0x0000B8, "Member 'UPowerupManagerComponent::PowerupData' has a wrong offset!");

// Class DeceiveInc.PrivateLobbyState
// 0x0000 (0x0220 - 0x0220)
class APrivateLobbyState final : public AInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrivateLobbyState">();
	}
	static class APrivateLobbyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<APrivateLobbyState>();
	}
};
static_assert(alignof(APrivateLobbyState) == 0x000008, "Wrong alignment on APrivateLobbyState");
static_assert(sizeof(APrivateLobbyState) == 0x000220, "Wrong size on APrivateLobbyState");

// Class DeceiveInc.XiuPassiveAbilityMod1
// 0x0050 (0x0580 - 0x0530)
class AXiuPassiveAbilityMod1 final : public ABaseSpyPassiveAbility
{
public:
	float                                         LoSDistance;                                       // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LoSMaxAngle;                                       // 0x0534(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   VictimEffectClass;                                 // 0x0538(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinHealthToDetect;                                 // 0x0560(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoLOSCheck;                                       // 0x0564(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_565[0x3];                                      // 0x0565(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistance;                                       // 0x0568(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_56C[0x4];                                      // 0x056C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FXiuVictimData>                 VictimsArray;                                      // 0x0570(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void HandleOnNonLocalHealthChangeEvent(class ASpy* Spy, class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"XiuPassiveAbilityMod1">();
	}
	static class AXiuPassiveAbilityMod1* GetDefaultObj()
	{
		return GetDefaultObjImpl<AXiuPassiveAbilityMod1>();
	}
};
static_assert(alignof(AXiuPassiveAbilityMod1) == 0x000008, "Wrong alignment on AXiuPassiveAbilityMod1");
static_assert(sizeof(AXiuPassiveAbilityMod1) == 0x000580, "Wrong size on AXiuPassiveAbilityMod1");
static_assert(offsetof(AXiuPassiveAbilityMod1, LoSDistance) == 0x000530, "Member 'AXiuPassiveAbilityMod1::LoSDistance' has a wrong offset!");
static_assert(offsetof(AXiuPassiveAbilityMod1, LoSMaxAngle) == 0x000534, "Member 'AXiuPassiveAbilityMod1::LoSMaxAngle' has a wrong offset!");
static_assert(offsetof(AXiuPassiveAbilityMod1, VictimEffectClass) == 0x000538, "Member 'AXiuPassiveAbilityMod1::VictimEffectClass' has a wrong offset!");
static_assert(offsetof(AXiuPassiveAbilityMod1, MinHealthToDetect) == 0x000560, "Member 'AXiuPassiveAbilityMod1::MinHealthToDetect' has a wrong offset!");
static_assert(offsetof(AXiuPassiveAbilityMod1, bDoLOSCheck) == 0x000564, "Member 'AXiuPassiveAbilityMod1::bDoLOSCheck' has a wrong offset!");
static_assert(offsetof(AXiuPassiveAbilityMod1, MaxDistance) == 0x000568, "Member 'AXiuPassiveAbilityMod1::MaxDistance' has a wrong offset!");
static_assert(offsetof(AXiuPassiveAbilityMod1, VictimsArray) == 0x000570, "Member 'AXiuPassiveAbilityMod1::VictimsArray' has a wrong offset!");

// Class DeceiveInc.ProgressionRewardData
// 0x0080 (0x00B8 - 0x0038)
class UProgressionRewardData final : public UDIPrimaryDataAsset
{
public:
	class FString                                 XpType;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrencyRewardAmountPerLevel;                      // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRewardPerMatch                        RewardPerMatch;                                    // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLootRewardPerLevel>            LootRewardPerLevel;                                // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, struct FLevelReward>              ProgressionRewardMap;                              // 0x0068(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProgressionRewardData">();
	}
	static class UProgressionRewardData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProgressionRewardData>();
	}
};
static_assert(alignof(UProgressionRewardData) == 0x000008, "Wrong alignment on UProgressionRewardData");
static_assert(sizeof(UProgressionRewardData) == 0x0000B8, "Wrong size on UProgressionRewardData");
static_assert(offsetof(UProgressionRewardData, XpType) == 0x000038, "Member 'UProgressionRewardData::XpType' has a wrong offset!");
static_assert(offsetof(UProgressionRewardData, CurrencyRewardAmountPerLevel) == 0x000048, "Member 'UProgressionRewardData::CurrencyRewardAmountPerLevel' has a wrong offset!");
static_assert(offsetof(UProgressionRewardData, RewardPerMatch) == 0x00004C, "Member 'UProgressionRewardData::RewardPerMatch' has a wrong offset!");
static_assert(offsetof(UProgressionRewardData, LootRewardPerLevel) == 0x000058, "Member 'UProgressionRewardData::LootRewardPerLevel' has a wrong offset!");
static_assert(offsetof(UProgressionRewardData, ProgressionRewardMap) == 0x000068, "Member 'UProgressionRewardData::ProgressionRewardMap' has a wrong offset!");

// Class DeceiveInc.RangePlacementComponent
// 0x00D0 (0x0180 - 0x00B0)
class URangePlacementComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnChargeNewAmount;                                 // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPositionerVisibilityChanged;                     // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PositionerClass;                                   // 0x00D0(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   PlaceableToSpawn;                                  // 0x00F8(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ObjSpawnState;                                     // 0x0120(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChargeResourceToRemove;                            // 0x0124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBasePositionerComponent*               Positioner;                                        // 0x0128(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 PlaceableActor;                                    // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameplayResourcesComponent*            GameplayResourceComponent;                         // 0x0138(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0x40];                                     // 0x0140(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetRemainingCharges();
	void HandleResourceNewAmount(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 NewAmount);
	bool HasEnoughCharges();
	void ServerSpawnPlaceable(const struct FVector_NetQuantize& SpawnLocation, const struct FRotator& SpawnRotation, const struct FVector_NetQuantizeNormal& TargetNormal, bool bDrop, bool bSpawnLocalOnly);
	void SetPositioning(bool _bPositioning);

	bool IsPositionerVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangePlacementComponent">();
	}
	static class URangePlacementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URangePlacementComponent>();
	}
};
static_assert(alignof(URangePlacementComponent) == 0x000008, "Wrong alignment on URangePlacementComponent");
static_assert(sizeof(URangePlacementComponent) == 0x000180, "Wrong size on URangePlacementComponent");
static_assert(offsetof(URangePlacementComponent, OnChargeNewAmount) == 0x0000B0, "Member 'URangePlacementComponent::OnChargeNewAmount' has a wrong offset!");
static_assert(offsetof(URangePlacementComponent, OnPositionerVisibilityChanged) == 0x0000C0, "Member 'URangePlacementComponent::OnPositionerVisibilityChanged' has a wrong offset!");
static_assert(offsetof(URangePlacementComponent, PositionerClass) == 0x0000D0, "Member 'URangePlacementComponent::PositionerClass' has a wrong offset!");
static_assert(offsetof(URangePlacementComponent, PlaceableToSpawn) == 0x0000F8, "Member 'URangePlacementComponent::PlaceableToSpawn' has a wrong offset!");
static_assert(offsetof(URangePlacementComponent, ObjSpawnState) == 0x000120, "Member 'URangePlacementComponent::ObjSpawnState' has a wrong offset!");
static_assert(offsetof(URangePlacementComponent, ChargeResourceToRemove) == 0x000124, "Member 'URangePlacementComponent::ChargeResourceToRemove' has a wrong offset!");
static_assert(offsetof(URangePlacementComponent, Positioner) == 0x000128, "Member 'URangePlacementComponent::Positioner' has a wrong offset!");
static_assert(offsetof(URangePlacementComponent, PlaceableActor) == 0x000130, "Member 'URangePlacementComponent::PlaceableActor' has a wrong offset!");
static_assert(offsetof(URangePlacementComponent, GameplayResourceComponent) == 0x000138, "Member 'URangePlacementComponent::GameplayResourceComponent' has a wrong offset!");

// Class DeceiveInc.SquirePassiveAbility
// 0x0018 (0x0548 - 0x0530)
class ASquirePassiveAbility final : public ABaseSpyPassiveAbility
{
public:
	float                                         SpeedBoostDuration;                                // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedBoostFactor;                                  // 0x0534(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCooldownComponent*                     BoostDurationTimer;                                // 0x0538(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HudToShowWhenBoosting;                             // 0x0540(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BP_OnSquirePassiveGiveSpeedBoost();
	void BP_OnSquirePassiveRevokeSpeedBoost();
	void HandleBoostDurationCooldownChange(bool OnCooldown);
	void HandleUnderCoverChanged(bool bUndercover);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquirePassiveAbility">();
	}
	static class ASquirePassiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASquirePassiveAbility>();
	}
};
static_assert(alignof(ASquirePassiveAbility) == 0x000008, "Wrong alignment on ASquirePassiveAbility");
static_assert(sizeof(ASquirePassiveAbility) == 0x000548, "Wrong size on ASquirePassiveAbility");
static_assert(offsetof(ASquirePassiveAbility, SpeedBoostDuration) == 0x000530, "Member 'ASquirePassiveAbility::SpeedBoostDuration' has a wrong offset!");
static_assert(offsetof(ASquirePassiveAbility, SpeedBoostFactor) == 0x000534, "Member 'ASquirePassiveAbility::SpeedBoostFactor' has a wrong offset!");
static_assert(offsetof(ASquirePassiveAbility, BoostDurationTimer) == 0x000538, "Member 'ASquirePassiveAbility::BoostDurationTimer' has a wrong offset!");
static_assert(offsetof(ASquirePassiveAbility, HudToShowWhenBoosting) == 0x000540, "Member 'ASquirePassiveAbility::HudToShowWhenBoosting' has a wrong offset!");

// Class DeceiveInc.RemoteTurret
// 0x00E8 (0x0400 - 0x0318)
class ARemoteTurret final : public ABasePickablePlaceable
{
public:
	class URemoteTurretAIComponent*               RemoteTurretAIComp;                                // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCheckLoSComponent*                     LoSComponent;                                      // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpringArmComponent*                    SpringArm;                                         // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       TurretCamera;                                      // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USBAimAssistTargetComponent*            AimAssistTargetComp;                               // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   TurretTargetVictimEffect;                          // 0x0340(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EMovementEventType>                    SpyMovementEventToForceOutOfTurret;                // 0x0368(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   TurretHudAsset;                                    // 0x0378(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SpringArmAttachementSocketName;                    // 0x03A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   TurretSpawnerWeaponClass;                          // 0x03A8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SpawnerWeaponAttachementPointName;                 // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHitscanWeapon*                         TurretSpawnerWeapon;                               // 0x03D8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 TurretHudClass;                                    // 0x03E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            TurretHud;                                         // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AVictimEffect*                          TargetVictimEffect;                                // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F8[0x8];                                      // 0x03F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleAggroTargetChange(class AActor* NewTarget);
	void HandleAggroTargetLost();
	void HandlePhaseChanged(ESpyGamePhase NewGamePhase);
	void HandleSpyMovementEvent(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, EMovementEventType MovementEventType);
	void HandleSpyToolEvent(ESpyToolEvent EventType, class ABaseSpyTool* SpyTool);
	void HandleStateChange(ERemoteTurretAIState OldState, ERemoteTurretAIState NewState);
	void OnRep_NewTurretSpawnerWeapon();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemoteTurret">();
	}
	static class ARemoteTurret* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARemoteTurret>();
	}
};
static_assert(alignof(ARemoteTurret) == 0x000008, "Wrong alignment on ARemoteTurret");
static_assert(sizeof(ARemoteTurret) == 0x000400, "Wrong size on ARemoteTurret");
static_assert(offsetof(ARemoteTurret, RemoteTurretAIComp) == 0x000318, "Member 'ARemoteTurret::RemoteTurretAIComp' has a wrong offset!");
static_assert(offsetof(ARemoteTurret, LoSComponent) == 0x000320, "Member 'ARemoteTurret::LoSComponent' has a wrong offset!");
static_assert(offsetof(ARemoteTurret, SpringArm) == 0x000328, "Member 'ARemoteTurret::SpringArm' has a wrong offset!");
static_assert(offsetof(ARemoteTurret, TurretCamera) == 0x000330, "Member 'ARemoteTurret::TurretCamera' has a wrong offset!");
static_assert(offsetof(ARemoteTurret, AimAssistTargetComp) == 0x000338, "Member 'ARemoteTurret::AimAssistTargetComp' has a wrong offset!");
static_assert(offsetof(ARemoteTurret, TurretTargetVictimEffect) == 0x000340, "Member 'ARemoteTurret::TurretTargetVictimEffect' has a wrong offset!");
static_assert(offsetof(ARemoteTurret, SpyMovementEventToForceOutOfTurret) == 0x000368, "Member 'ARemoteTurret::SpyMovementEventToForceOutOfTurret' has a wrong offset!");
static_assert(offsetof(ARemoteTurret, TurretHudAsset) == 0x000378, "Member 'ARemoteTurret::TurretHudAsset' has a wrong offset!");
static_assert(offsetof(ARemoteTurret, SpringArmAttachementSocketName) == 0x0003A0, "Member 'ARemoteTurret::SpringArmAttachementSocketName' has a wrong offset!");
static_assert(offsetof(ARemoteTurret, TurretSpawnerWeaponClass) == 0x0003A8, "Member 'ARemoteTurret::TurretSpawnerWeaponClass' has a wrong offset!");
static_assert(offsetof(ARemoteTurret, SpawnerWeaponAttachementPointName) == 0x0003D0, "Member 'ARemoteTurret::SpawnerWeaponAttachementPointName' has a wrong offset!");
static_assert(offsetof(ARemoteTurret, TurretSpawnerWeapon) == 0x0003D8, "Member 'ARemoteTurret::TurretSpawnerWeapon' has a wrong offset!");
static_assert(offsetof(ARemoteTurret, TurretHudClass) == 0x0003E0, "Member 'ARemoteTurret::TurretHudClass' has a wrong offset!");
static_assert(offsetof(ARemoteTurret, TurretHud) == 0x0003E8, "Member 'ARemoteTurret::TurretHud' has a wrong offset!");
static_assert(offsetof(ARemoteTurret, TargetVictimEffect) == 0x0003F0, "Member 'ARemoteTurret::TargetVictimEffect' has a wrong offset!");

// Class DeceiveInc.RemoteTurretTool
// 0x0010 (0x0698 - 0x0688)
class ARemoteTurretTool final : public ABasePlaceableSpyTool
{
public:
	uint8                                         Pad_688[0x10];                                     // 0x0688(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleOwnerTookDamage(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, class UHealthComponent* SpyHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& DamageDirection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemoteTurretTool">();
	}
	static class ARemoteTurretTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARemoteTurretTool>();
	}
};
static_assert(alignof(ARemoteTurretTool) == 0x000008, "Wrong alignment on ARemoteTurretTool");
static_assert(sizeof(ARemoteTurretTool) == 0x000698, "Wrong size on ARemoteTurretTool");

// Class DeceiveInc.Sway1PComponent
// 0x0070 (0x0120 - 0x00B0)
class USway1PComponent final : public UActorComponent
{
public:
	struct FSwayAxisParams                        AxisXParams;                                       // 0x00B0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSwayAxisParams                        AxisYParams;                                       // 0x00C0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         VerticalAccel;                                     // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopVerticalKick;                                  // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSway1PFactorsChange;                             // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x38];                                      // 0x00E8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPitchInputDelta(float PitchDelta);
	void OnSpyAirborneVerticalAccel(float VerticalAccelIn);
	void OnSpyGroundStopGoingForward();
	void OnSpyOwnerPossessedByController(class AController* NewController);
	void OnYawInputDelta(float YawDelta);

	struct FVector GetFactors() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Sway1PComponent">();
	}
	static class USway1PComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USway1PComponent>();
	}
};
static_assert(alignof(USway1PComponent) == 0x000008, "Wrong alignment on USway1PComponent");
static_assert(sizeof(USway1PComponent) == 0x000120, "Wrong size on USway1PComponent");
static_assert(offsetof(USway1PComponent, AxisXParams) == 0x0000B0, "Member 'USway1PComponent::AxisXParams' has a wrong offset!");
static_assert(offsetof(USway1PComponent, AxisYParams) == 0x0000C0, "Member 'USway1PComponent::AxisYParams' has a wrong offset!");
static_assert(offsetof(USway1PComponent, VerticalAccel) == 0x0000D0, "Member 'USway1PComponent::VerticalAccel' has a wrong offset!");
static_assert(offsetof(USway1PComponent, StopVerticalKick) == 0x0000D4, "Member 'USway1PComponent::StopVerticalKick' has a wrong offset!");
static_assert(offsetof(USway1PComponent, OnSway1PFactorsChange) == 0x0000D8, "Member 'USway1PComponent::OnSway1PFactorsChange' has a wrong offset!");

// Class DeceiveInc.ResourceConditionComponent
// 0x0018 (0x00E8 - 0x00D0)
class UResourceConditionComponent final : public UBaseConditionComponent
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RequiredAmount;                                    // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpendResource;                                    // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpendResourceInteractionDuration;                  // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsConditionOptional;                              // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsNegative;                                       // 0x00E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowDrone;                                       // 0x00E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteract1PAnimation                          OverwriteFirstPersonInteractAnimation;             // 0x00E3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResourceConditionComponent">();
	}
	static class UResourceConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResourceConditionComponent>();
	}
};
static_assert(alignof(UResourceConditionComponent) == 0x000008, "Wrong alignment on UResourceConditionComponent");
static_assert(sizeof(UResourceConditionComponent) == 0x0000E8, "Wrong size on UResourceConditionComponent");
static_assert(offsetof(UResourceConditionComponent, ResourceType) == 0x0000D0, "Member 'UResourceConditionComponent::ResourceType' has a wrong offset!");
static_assert(offsetof(UResourceConditionComponent, RequiredAmount) == 0x0000D4, "Member 'UResourceConditionComponent::RequiredAmount' has a wrong offset!");
static_assert(offsetof(UResourceConditionComponent, bSpendResource) == 0x0000D8, "Member 'UResourceConditionComponent::bSpendResource' has a wrong offset!");
static_assert(offsetof(UResourceConditionComponent, SpendResourceInteractionDuration) == 0x0000DC, "Member 'UResourceConditionComponent::SpendResourceInteractionDuration' has a wrong offset!");
static_assert(offsetof(UResourceConditionComponent, bIsConditionOptional) == 0x0000E0, "Member 'UResourceConditionComponent::bIsConditionOptional' has a wrong offset!");
static_assert(offsetof(UResourceConditionComponent, bIsNegative) == 0x0000E1, "Member 'UResourceConditionComponent::bIsNegative' has a wrong offset!");
static_assert(offsetof(UResourceConditionComponent, bAllowDrone) == 0x0000E2, "Member 'UResourceConditionComponent::bAllowDrone' has a wrong offset!");
static_assert(offsetof(UResourceConditionComponent, OverwriteFirstPersonInteractAnimation) == 0x0000E3, "Member 'UResourceConditionComponent::OverwriteFirstPersonInteractAnimation' has a wrong offset!");

// Class DeceiveInc.ReviveSpyConditionComponent
// 0x0028 (0x00F8 - 0x00D0)
class UReviveSpyConditionComponent final : public UBaseConditionComponent
{
public:
	int32                                         CurrentReviveCount;                                // 0x00D0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ReviveCosts;                                       // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReviveCountChanged;                              // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnRep_CurrentReviveCount();

	int32 GetCurrentReviveCount() const;
	bool IsBurned() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReviveSpyConditionComponent">();
	}
	static class UReviveSpyConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReviveSpyConditionComponent>();
	}
};
static_assert(alignof(UReviveSpyConditionComponent) == 0x000008, "Wrong alignment on UReviveSpyConditionComponent");
static_assert(sizeof(UReviveSpyConditionComponent) == 0x0000F8, "Wrong size on UReviveSpyConditionComponent");
static_assert(offsetof(UReviveSpyConditionComponent, CurrentReviveCount) == 0x0000D0, "Member 'UReviveSpyConditionComponent::CurrentReviveCount' has a wrong offset!");
static_assert(offsetof(UReviveSpyConditionComponent, ReviveCosts) == 0x0000D8, "Member 'UReviveSpyConditionComponent::ReviveCosts' has a wrong offset!");
static_assert(offsetof(UReviveSpyConditionComponent, OnReviveCountChanged) == 0x0000E8, "Member 'UReviveSpyConditionComponent::OnReviveCountChanged' has a wrong offset!");

// Class DeceiveInc.RoomNavArea_Civilian
// 0x0000 (0x0048 - 0x0048)
class URoomNavArea_Civilian final : public URoomNavArea_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoomNavArea_Civilian">();
	}
	static class URoomNavArea_Civilian* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoomNavArea_Civilian>();
	}
};
static_assert(alignof(URoomNavArea_Civilian) == 0x000008, "Wrong alignment on URoomNavArea_Civilian");
static_assert(sizeof(URoomNavArea_Civilian) == 0x000048, "Wrong size on URoomNavArea_Civilian");

// Class DeceiveInc.SweetInputModifierAccelerators
// 0x0020 (0x0048 - 0x0028)
class USweetInputModifierAccelerators : public UInputModifier
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Threshold;                                         // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxBoostValue;                                     // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToMaxBoost;                                    // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DropThreshold;                                     // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToRemoveBoost;                                 // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerSettingsType                           MaxBoostValueSetting;                              // 0x0044(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerSettingsType                           TimeToMaxBoostSetting;                             // 0x0045(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SweetInputModifierAccelerators">();
	}
	static class USweetInputModifierAccelerators* GetDefaultObj()
	{
		return GetDefaultObjImpl<USweetInputModifierAccelerators>();
	}
};
static_assert(alignof(USweetInputModifierAccelerators) == 0x000008, "Wrong alignment on USweetInputModifierAccelerators");
static_assert(sizeof(USweetInputModifierAccelerators) == 0x000048, "Wrong size on USweetInputModifierAccelerators");
static_assert(offsetof(USweetInputModifierAccelerators, Threshold) == 0x000030, "Member 'USweetInputModifierAccelerators::Threshold' has a wrong offset!");
static_assert(offsetof(USweetInputModifierAccelerators, MaxBoostValue) == 0x000034, "Member 'USweetInputModifierAccelerators::MaxBoostValue' has a wrong offset!");
static_assert(offsetof(USweetInputModifierAccelerators, TimeToMaxBoost) == 0x000038, "Member 'USweetInputModifierAccelerators::TimeToMaxBoost' has a wrong offset!");
static_assert(offsetof(USweetInputModifierAccelerators, DropThreshold) == 0x00003C, "Member 'USweetInputModifierAccelerators::DropThreshold' has a wrong offset!");
static_assert(offsetof(USweetInputModifierAccelerators, TimeToRemoveBoost) == 0x000040, "Member 'USweetInputModifierAccelerators::TimeToRemoveBoost' has a wrong offset!");
static_assert(offsetof(USweetInputModifierAccelerators, MaxBoostValueSetting) == 0x000044, "Member 'USweetInputModifierAccelerators::MaxBoostValueSetting' has a wrong offset!");
static_assert(offsetof(USweetInputModifierAccelerators, TimeToMaxBoostSetting) == 0x000045, "Member 'USweetInputModifierAccelerators::TimeToMaxBoostSetting' has a wrong offset!");

// Class DeceiveInc.RoomNavArea_Guard
// 0x0000 (0x0048 - 0x0048)
class URoomNavArea_Guard final : public URoomNavArea_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoomNavArea_Guard">();
	}
	static class URoomNavArea_Guard* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoomNavArea_Guard>();
	}
};
static_assert(alignof(URoomNavArea_Guard) == 0x000008, "Wrong alignment on URoomNavArea_Guard");
static_assert(sizeof(URoomNavArea_Guard) == 0x000048, "Wrong size on URoomNavArea_Guard");

// Class DeceiveInc.RoomNavArea_Technician
// 0x0000 (0x0048 - 0x0048)
class URoomNavArea_Technician final : public URoomNavArea_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoomNavArea_Technician">();
	}
	static class URoomNavArea_Technician* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoomNavArea_Technician>();
	}
};
static_assert(alignof(URoomNavArea_Technician) == 0x000008, "Wrong alignment on URoomNavArea_Technician");
static_assert(sizeof(URoomNavArea_Technician) == 0x000048, "Wrong size on URoomNavArea_Technician");

// Class DeceiveInc.RoomVolume
// 0x0298 (0x04F0 - 0x0258)
class ARoomVolume final : public AVolume
{
public:
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ESecurityLevel                                SecurityLevel;                                     // 0x0260(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGeneratedRoomData                     GeneratedRoomData;                                 // 0x0268(0x0070)(Edit, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	float                                         WeightMultiplier;                                  // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightOverwrite;                                   // 0x02DC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CellValidHeightThreshold;                          // 0x02E0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValidatedHeight;                                  // 0x02E4(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E5[0x3];                                      // 0x02E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimumNPCInRoom;                                  // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRoomObjectSpawnParams                 ObjectSpawnParams;                                 // 0x02EC(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	class ARoomVolume*                            ConsideredSameRoomAs;                              // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInteriorRoom;                                   // 0x0300(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRoomAllowsPlayeSpawn;                             // 0x0301(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_302[0x2];                                      // 0x0302(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerSpawnGroup;                                  // 0x0304(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRoomSoloSpawnOnly;                              // 0x0308(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRoomPrivateLobbySpawnOnly;                      // 0x0309(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30A[0x6];                                      // 0x030A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint32, struct FConnectedRoomData>       ConnectedRooms;                                    // 0x0310(0x0050)(Edit, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FConnectedRoomData>             ConnectedRoomsOfSameVaultFlag;                     // 0x0360(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FExitPoint>                     ExitPoints;                                        // 0x0370(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	bool                                          bInVault;                                          // 0x0380(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_381[0x7];                                      // 0x0381(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FObjectSpawnGroupContainer             ObjectSpawnGroupContainer;                         // 0x0388(0x0050)(Edit, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	class UTextRenderComponent*                   DebugTextRenderComponent;                          // 0x03D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E0[0xE8];                                     // 0x03E0(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        RoomCRC;                                           // 0x04C8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4CC[0x4];                                      // 0x04CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UNPCInteraction*>                RoomInteractions;                                  // 0x04D0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UDeadNPCInteraction*>            DeadNPCInteractions;                               // 0x04E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void OnGoingFightScareNPCsTimerEnd();
	void OnGoingFightTimerEnd();
	void UpdateConnectedRoomsReference(class UWorld* World);
	void UpdateNotAllowedCharacters();

	struct FVector GetCenterValidPos() const;
	bool HasOnGoingFightInRoom() const;
	bool HasOnGoingFightInRoomFlag(uint8 FlagIn) const;
	bool IsPosInRoom(const struct FVector& TestPos, float SphereRadius) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoomVolume">();
	}
	static class ARoomVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARoomVolume>();
	}
};
static_assert(alignof(ARoomVolume) == 0x000008, "Wrong alignment on ARoomVolume");
static_assert(sizeof(ARoomVolume) == 0x0004F0, "Wrong size on ARoomVolume");
static_assert(offsetof(ARoomVolume, SecurityLevel) == 0x000260, "Member 'ARoomVolume::SecurityLevel' has a wrong offset!");
static_assert(offsetof(ARoomVolume, GeneratedRoomData) == 0x000268, "Member 'ARoomVolume::GeneratedRoomData' has a wrong offset!");
static_assert(offsetof(ARoomVolume, WeightMultiplier) == 0x0002D8, "Member 'ARoomVolume::WeightMultiplier' has a wrong offset!");
static_assert(offsetof(ARoomVolume, WeightOverwrite) == 0x0002DC, "Member 'ARoomVolume::WeightOverwrite' has a wrong offset!");
static_assert(offsetof(ARoomVolume, CellValidHeightThreshold) == 0x0002E0, "Member 'ARoomVolume::CellValidHeightThreshold' has a wrong offset!");
static_assert(offsetof(ARoomVolume, bValidatedHeight) == 0x0002E4, "Member 'ARoomVolume::bValidatedHeight' has a wrong offset!");
static_assert(offsetof(ARoomVolume, MinimumNPCInRoom) == 0x0002E8, "Member 'ARoomVolume::MinimumNPCInRoom' has a wrong offset!");
static_assert(offsetof(ARoomVolume, ObjectSpawnParams) == 0x0002EC, "Member 'ARoomVolume::ObjectSpawnParams' has a wrong offset!");
static_assert(offsetof(ARoomVolume, ConsideredSameRoomAs) == 0x0002F8, "Member 'ARoomVolume::ConsideredSameRoomAs' has a wrong offset!");
static_assert(offsetof(ARoomVolume, bIsInteriorRoom) == 0x000300, "Member 'ARoomVolume::bIsInteriorRoom' has a wrong offset!");
static_assert(offsetof(ARoomVolume, bRoomAllowsPlayeSpawn) == 0x000301, "Member 'ARoomVolume::bRoomAllowsPlayeSpawn' has a wrong offset!");
static_assert(offsetof(ARoomVolume, PlayerSpawnGroup) == 0x000304, "Member 'ARoomVolume::PlayerSpawnGroup' has a wrong offset!");
static_assert(offsetof(ARoomVolume, bIsRoomSoloSpawnOnly) == 0x000308, "Member 'ARoomVolume::bIsRoomSoloSpawnOnly' has a wrong offset!");
static_assert(offsetof(ARoomVolume, bIsRoomPrivateLobbySpawnOnly) == 0x000309, "Member 'ARoomVolume::bIsRoomPrivateLobbySpawnOnly' has a wrong offset!");
static_assert(offsetof(ARoomVolume, ConnectedRooms) == 0x000310, "Member 'ARoomVolume::ConnectedRooms' has a wrong offset!");
static_assert(offsetof(ARoomVolume, ConnectedRoomsOfSameVaultFlag) == 0x000360, "Member 'ARoomVolume::ConnectedRoomsOfSameVaultFlag' has a wrong offset!");
static_assert(offsetof(ARoomVolume, ExitPoints) == 0x000370, "Member 'ARoomVolume::ExitPoints' has a wrong offset!");
static_assert(offsetof(ARoomVolume, bInVault) == 0x000380, "Member 'ARoomVolume::bInVault' has a wrong offset!");
static_assert(offsetof(ARoomVolume, ObjectSpawnGroupContainer) == 0x000388, "Member 'ARoomVolume::ObjectSpawnGroupContainer' has a wrong offset!");
static_assert(offsetof(ARoomVolume, DebugTextRenderComponent) == 0x0003D8, "Member 'ARoomVolume::DebugTextRenderComponent' has a wrong offset!");
static_assert(offsetof(ARoomVolume, RoomCRC) == 0x0004C8, "Member 'ARoomVolume::RoomCRC' has a wrong offset!");
static_assert(offsetof(ARoomVolume, RoomInteractions) == 0x0004D0, "Member 'ARoomVolume::RoomInteractions' has a wrong offset!");
static_assert(offsetof(ARoomVolume, DeadNPCInteractions) == 0x0004E0, "Member 'ARoomVolume::DeadNPCInteractions' has a wrong offset!");

// Class DeceiveInc.SasoriActiveAbility
// 0x0080 (0x0668 - 0x05E8)
class ASasoriActiveAbility final : public ASasoriBaseActiveAbility
{
public:
	FMulticastInlineDelegateProperty_             OnAnimationCancelEventDelegate;                    // 0x05E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bAffectMeleeWeapon;                                // 0x05F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F9[0x7];                                      // 0x05F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ActiveActorToSpawnOnHitClass;                      // 0x0600(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASpawnerWeapon*                         RangeWeapon;                                       // 0x0628(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMeleeWeapon*                           MeleeWeapon;                                       // 0x0630(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ApplyPoisonDelay;                                  // 0x0638(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_63C[0x4];                                      // 0x063C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASpawnerWeaponRound*>            LastProjectiles;                                   // 0x0640(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_650[0x18];                                     // 0x0650(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleMeleeAttackDamageDone(class AActor* Victim, const struct FVector& ImpactPoint, int32 ChargeLevel, float DamageDone, float ResultingHealthPercentage, EHitType HitType, const struct FMeleeHitConfirmedData& HitConfirmedData);
	void HandleProjectileSpawnAndActivate(class ASpawnerWeapon* Weapon, class ASpawnerWeaponRound* Projectile);
	void HandleWeaponSpyToolEvent(ESpyToolEvent EventType, class ABaseSpyTool* SpyTool);
	void OnCleanupPoisonTimerComplete();
	void OnDisableWeaponTimerComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SasoriActiveAbility">();
	}
	static class ASasoriActiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASasoriActiveAbility>();
	}
};
static_assert(alignof(ASasoriActiveAbility) == 0x000008, "Wrong alignment on ASasoriActiveAbility");
static_assert(sizeof(ASasoriActiveAbility) == 0x000668, "Wrong size on ASasoriActiveAbility");
static_assert(offsetof(ASasoriActiveAbility, OnAnimationCancelEventDelegate) == 0x0005E8, "Member 'ASasoriActiveAbility::OnAnimationCancelEventDelegate' has a wrong offset!");
static_assert(offsetof(ASasoriActiveAbility, bAffectMeleeWeapon) == 0x0005F8, "Member 'ASasoriActiveAbility::bAffectMeleeWeapon' has a wrong offset!");
static_assert(offsetof(ASasoriActiveAbility, ActiveActorToSpawnOnHitClass) == 0x000600, "Member 'ASasoriActiveAbility::ActiveActorToSpawnOnHitClass' has a wrong offset!");
static_assert(offsetof(ASasoriActiveAbility, RangeWeapon) == 0x000628, "Member 'ASasoriActiveAbility::RangeWeapon' has a wrong offset!");
static_assert(offsetof(ASasoriActiveAbility, MeleeWeapon) == 0x000630, "Member 'ASasoriActiveAbility::MeleeWeapon' has a wrong offset!");
static_assert(offsetof(ASasoriActiveAbility, ApplyPoisonDelay) == 0x000638, "Member 'ASasoriActiveAbility::ApplyPoisonDelay' has a wrong offset!");
static_assert(offsetof(ASasoriActiveAbility, LastProjectiles) == 0x000640, "Member 'ASasoriActiveAbility::LastProjectiles' has a wrong offset!");

// Class DeceiveInc.SasoriActiveAbilityMod2
// 0x0068 (0x0650 - 0x05E8)
class ASasoriActiveAbilityMod2 final : public ASasoriBaseActiveAbility
{
public:
	float                                         TriggerDelay;                                      // 0x05E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5EC[0x4];                                      // 0x05EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   DamagingEffectToSpawnClass;                        // 0x05F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlowCover;                                        // 0x0618(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_619[0x7];                                      // 0x0619(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AActor>                  DamagingEffectClassInstance;                       // 0x0620(0x0028)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_648[0x8];                                      // 0x0648(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTriggerDelayTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SasoriActiveAbilityMod2">();
	}
	static class ASasoriActiveAbilityMod2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASasoriActiveAbilityMod2>();
	}
};
static_assert(alignof(ASasoriActiveAbilityMod2) == 0x000008, "Wrong alignment on ASasoriActiveAbilityMod2");
static_assert(sizeof(ASasoriActiveAbilityMod2) == 0x000650, "Wrong size on ASasoriActiveAbilityMod2");
static_assert(offsetof(ASasoriActiveAbilityMod2, TriggerDelay) == 0x0005E8, "Member 'ASasoriActiveAbilityMod2::TriggerDelay' has a wrong offset!");
static_assert(offsetof(ASasoriActiveAbilityMod2, DamagingEffectToSpawnClass) == 0x0005F0, "Member 'ASasoriActiveAbilityMod2::DamagingEffectToSpawnClass' has a wrong offset!");
static_assert(offsetof(ASasoriActiveAbilityMod2, bBlowCover) == 0x000618, "Member 'ASasoriActiveAbilityMod2::bBlowCover' has a wrong offset!");
static_assert(offsetof(ASasoriActiveAbilityMod2, DamagingEffectClassInstance) == 0x000620, "Member 'ASasoriActiveAbilityMod2::DamagingEffectClassInstance' has a wrong offset!");

// Class DeceiveInc.SasoriMod2DmgModComponent
// 0x0010 (0x00C0 - 0x00B0)
class USasoriMod2DmgModComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MultiplierPerEffect;                               // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMultiplier;                                     // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SasoriMod2DmgModComponent">();
	}
	static class USasoriMod2DmgModComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USasoriMod2DmgModComponent>();
	}
};
static_assert(alignof(USasoriMod2DmgModComponent) == 0x000008, "Wrong alignment on USasoriMod2DmgModComponent");
static_assert(sizeof(USasoriMod2DmgModComponent) == 0x0000C0, "Wrong size on USasoriMod2DmgModComponent");
static_assert(offsetof(USasoriMod2DmgModComponent, MultiplierPerEffect) == 0x0000B8, "Member 'USasoriMod2DmgModComponent::MultiplierPerEffect' has a wrong offset!");
static_assert(offsetof(USasoriMod2DmgModComponent, MaxMultiplier) == 0x0000BC, "Member 'USasoriMod2DmgModComponent::MaxMultiplier' has a wrong offset!");

// Class DeceiveInc.SasoriPassiveAbilityMod1
// 0x0028 (0x0558 - 0x0530)
class ASasoriPassiveAbilityMod1 final : public ABaseSpyPassiveAbility
{
public:
	uint8                                         Pad_530[0x8];                                      // 0x0530(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UToolLoadoutComponent*                  LoadoutComponent;                                  // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SwordDamageMultiplier;                             // 0x0540(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_544[0x4];                                      // 0x0544(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           PoisonVictimEffectClass;                           // 0x0548(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SasoriPassiveAbilityMod1">();
	}
	static class ASasoriPassiveAbilityMod1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASasoriPassiveAbilityMod1>();
	}
};
static_assert(alignof(ASasoriPassiveAbilityMod1) == 0x000008, "Wrong alignment on ASasoriPassiveAbilityMod1");
static_assert(sizeof(ASasoriPassiveAbilityMod1) == 0x000558, "Wrong size on ASasoriPassiveAbilityMod1");
static_assert(offsetof(ASasoriPassiveAbilityMod1, LoadoutComponent) == 0x000538, "Member 'ASasoriPassiveAbilityMod1::LoadoutComponent' has a wrong offset!");
static_assert(offsetof(ASasoriPassiveAbilityMod1, SwordDamageMultiplier) == 0x000540, "Member 'ASasoriPassiveAbilityMod1::SwordDamageMultiplier' has a wrong offset!");
static_assert(offsetof(ASasoriPassiveAbilityMod1, PoisonVictimEffectClass) == 0x000548, "Member 'ASasoriPassiveAbilityMod1::PoisonVictimEffectClass' has a wrong offset!");

// Class DeceiveInc.SasoriPassiveAbilityMod2
// 0x0020 (0x0578 - 0x0558)
class ASasoriPassiveAbilityMod2 final : public ASasoriPassiveAbility
{
public:
	class UToolLoadoutComponent*                  LoadoutComponent;                                  // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentToRefundOnDamageDone;                       // 0x0560(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayBetweenRefunds;                               // 0x0564(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_568[0x10];                                     // 0x0568(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleMeleeAttackHit(class AActor* Victim, const struct FVector& ImpactPoint, int32 ChargeLevel, float DamageDone, float ResultingHealthPercentage, EHitType HitType, const struct FMeleeHitConfirmedData& HitConfirmedData);
	void HandleProjectileHit(const struct FHitConfirmData& HitConfirmData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SasoriPassiveAbilityMod2">();
	}
	static class ASasoriPassiveAbilityMod2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASasoriPassiveAbilityMod2>();
	}
};
static_assert(alignof(ASasoriPassiveAbilityMod2) == 0x000008, "Wrong alignment on ASasoriPassiveAbilityMod2");
static_assert(sizeof(ASasoriPassiveAbilityMod2) == 0x000578, "Wrong size on ASasoriPassiveAbilityMod2");
static_assert(offsetof(ASasoriPassiveAbilityMod2, LoadoutComponent) == 0x000558, "Member 'ASasoriPassiveAbilityMod2::LoadoutComponent' has a wrong offset!");
static_assert(offsetof(ASasoriPassiveAbilityMod2, PercentToRefundOnDamageDone) == 0x000560, "Member 'ASasoriPassiveAbilityMod2::PercentToRefundOnDamageDone' has a wrong offset!");
static_assert(offsetof(ASasoriPassiveAbilityMod2, DelayBetweenRefunds) == 0x000564, "Member 'ASasoriPassiveAbilityMod2::DelayBetweenRefunds' has a wrong offset!");

// Class DeceiveInc.SBAimAssistComponent
// 0x01F0 (0x02A0 - 0x00B0)
class USBAimAssistComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnAimDataAssetChangedDelegate;                     // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bEnableFriction;                                   // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMagnetism;                                  // 0x00C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableBulletMagnetism;                            // 0x00C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableScaling;                                    // 0x00C3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScalingByDPI;                                     // 0x00C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAutoAim;                                    // 0x00C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawCircles;                                      // 0x00C6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawCrosshair;                                    // 0x00C7(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugOverlayBox;                                  // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowValidTargetSockets;                           // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowValidTargetPhysic;                            // 0x00CA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowValidTargetSegments;                          // 0x00CB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawInput;                                        // 0x00CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugTargetTraces;                                // 0x00CD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CE[0x2];                                       // 0x00CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class USBAimAssistConfigDataAsset*            AimAssistDataAsset;                                // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TargetsDetectionProfileName;                       // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ObstacleCheckProfileName;                          // 0x00E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OnTargetCheckProfileName;                          // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class AActor*>                           IgnoredActors;                                     // 0x00F0(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_140[0x160];                                    // 0x0140(0x0160)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleBooleanPlayerSettingChange(EPlayerSettingsType SettingType, bool NewValue);
	void OnTargetDestroyed(class AActor* DestroyedActor);
	void SetAimAssistDataAsset(class USBAimAssistConfigDataAsset* DataAsset);
	void SetAimAssistFactionID(uint8 NewFactionID);
	void SetAimAssistInfluenceRatio(float Ratio);
	void SetAssistedControllerRotationSpeeds(float PitchSpeed, float YawSpeed);
	void SetIgnoredActors(const TSet<class AActor*>& ActorList);
	void SetMinimumTargetPriority(float MinimumPriority);

	const struct FVector2D GetCrosshairPosition() const;
	bool GetCurrentTargetSocketLocation(struct FVector* OutLocation) const;
	const TSet<class AActor*> GetIgnoredActors() const;
	struct FRotator GetRotationToCrosshairDirection(const struct FVector& From, class FName TraceProfileName, float MinDistanceToRotateToTarget, float Distance) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SBAimAssistComponent">();
	}
	static class USBAimAssistComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USBAimAssistComponent>();
	}
};
static_assert(alignof(USBAimAssistComponent) == 0x000008, "Wrong alignment on USBAimAssistComponent");
static_assert(sizeof(USBAimAssistComponent) == 0x0002A0, "Wrong size on USBAimAssistComponent");
static_assert(offsetof(USBAimAssistComponent, OnAimDataAssetChangedDelegate) == 0x0000B0, "Member 'USBAimAssistComponent::OnAimDataAssetChangedDelegate' has a wrong offset!");
static_assert(offsetof(USBAimAssistComponent, bEnableFriction) == 0x0000C0, "Member 'USBAimAssistComponent::bEnableFriction' has a wrong offset!");
static_assert(offsetof(USBAimAssistComponent, bEnableMagnetism) == 0x0000C1, "Member 'USBAimAssistComponent::bEnableMagnetism' has a wrong offset!");
static_assert(offsetof(USBAimAssistComponent, bEnableBulletMagnetism) == 0x0000C2, "Member 'USBAimAssistComponent::bEnableBulletMagnetism' has a wrong offset!");
static_assert(offsetof(USBAimAssistComponent, bEnableScaling) == 0x0000C3, "Member 'USBAimAssistComponent::bEnableScaling' has a wrong offset!");
static_assert(offsetof(USBAimAssistComponent, bScalingByDPI) == 0x0000C4, "Member 'USBAimAssistComponent::bScalingByDPI' has a wrong offset!");
static_assert(offsetof(USBAimAssistComponent, bEnableAutoAim) == 0x0000C5, "Member 'USBAimAssistComponent::bEnableAutoAim' has a wrong offset!");
static_assert(offsetof(USBAimAssistComponent, bDrawCircles) == 0x0000C6, "Member 'USBAimAssistComponent::bDrawCircles' has a wrong offset!");
static_assert(offsetof(USBAimAssistComponent, bDrawCrosshair) == 0x0000C7, "Member 'USBAimAssistComponent::bDrawCrosshair' has a wrong offset!");
static_assert(offsetof(USBAimAssistComponent, bDebugOverlayBox) == 0x0000C8, "Member 'USBAimAssistComponent::bDebugOverlayBox' has a wrong offset!");
static_assert(offsetof(USBAimAssistComponent, bShowValidTargetSockets) == 0x0000C9, "Member 'USBAimAssistComponent::bShowValidTargetSockets' has a wrong offset!");
static_assert(offsetof(USBAimAssistComponent, bShowValidTargetPhysic) == 0x0000CA, "Member 'USBAimAssistComponent::bShowValidTargetPhysic' has a wrong offset!");
static_assert(offsetof(USBAimAssistComponent, bShowValidTargetSegments) == 0x0000CB, "Member 'USBAimAssistComponent::bShowValidTargetSegments' has a wrong offset!");
static_assert(offsetof(USBAimAssistComponent, bDrawInput) == 0x0000CC, "Member 'USBAimAssistComponent::bDrawInput' has a wrong offset!");
static_assert(offsetof(USBAimAssistComponent, bDebugTargetTraces) == 0x0000CD, "Member 'USBAimAssistComponent::bDebugTargetTraces' has a wrong offset!");
static_assert(offsetof(USBAimAssistComponent, AimAssistDataAsset) == 0x0000D0, "Member 'USBAimAssistComponent::AimAssistDataAsset' has a wrong offset!");
static_assert(offsetof(USBAimAssistComponent, TargetsDetectionProfileName) == 0x0000D8, "Member 'USBAimAssistComponent::TargetsDetectionProfileName' has a wrong offset!");
static_assert(offsetof(USBAimAssistComponent, ObstacleCheckProfileName) == 0x0000E0, "Member 'USBAimAssistComponent::ObstacleCheckProfileName' has a wrong offset!");
static_assert(offsetof(USBAimAssistComponent, OnTargetCheckProfileName) == 0x0000E8, "Member 'USBAimAssistComponent::OnTargetCheckProfileName' has a wrong offset!");
static_assert(offsetof(USBAimAssistComponent, IgnoredActors) == 0x0000F0, "Member 'USBAimAssistComponent::IgnoredActors' has a wrong offset!");

// Class DeceiveInc.SBAimAssistTargetComponent
// 0x0050 (0x0100 - 0x00B0)
class USBAimAssistTargetComponent : public UActorComponent
{
public:
	class UMeshComponent*                         MeshComponent;                                     // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAimAssistActive;                                // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ExtraAimTargetSockets;                             // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         TargetPriority;                                    // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetActivationRangeFactor;                       // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAATargetSegmentDefinition>     AimTargetSegments;                                 // 0x00D8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FAASegmentPoint                        AimTargetCenterMass;                               // 0x00E8(0x0014)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class UMeshComponent* Mesh);
	void SetTargetPriority(float NewPriority);

	float GetTargetActivationRangeFactor() const;
	uint8 GetTargetFactionID() const;
	float GetTargetPriority() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SBAimAssistTargetComponent">();
	}
	static class USBAimAssistTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USBAimAssistTargetComponent>();
	}
};
static_assert(alignof(USBAimAssistTargetComponent) == 0x000008, "Wrong alignment on USBAimAssistTargetComponent");
static_assert(sizeof(USBAimAssistTargetComponent) == 0x000100, "Wrong size on USBAimAssistTargetComponent");
static_assert(offsetof(USBAimAssistTargetComponent, MeshComponent) == 0x0000B0, "Member 'USBAimAssistTargetComponent::MeshComponent' has a wrong offset!");
static_assert(offsetof(USBAimAssistTargetComponent, bIsAimAssistActive) == 0x0000B8, "Member 'USBAimAssistTargetComponent::bIsAimAssistActive' has a wrong offset!");
static_assert(offsetof(USBAimAssistTargetComponent, ExtraAimTargetSockets) == 0x0000C0, "Member 'USBAimAssistTargetComponent::ExtraAimTargetSockets' has a wrong offset!");
static_assert(offsetof(USBAimAssistTargetComponent, TargetPriority) == 0x0000D0, "Member 'USBAimAssistTargetComponent::TargetPriority' has a wrong offset!");
static_assert(offsetof(USBAimAssistTargetComponent, TargetActivationRangeFactor) == 0x0000D4, "Member 'USBAimAssistTargetComponent::TargetActivationRangeFactor' has a wrong offset!");
static_assert(offsetof(USBAimAssistTargetComponent, AimTargetSegments) == 0x0000D8, "Member 'USBAimAssistTargetComponent::AimTargetSegments' has a wrong offset!");
static_assert(offsetof(USBAimAssistTargetComponent, AimTargetCenterMass) == 0x0000E8, "Member 'USBAimAssistTargetComponent::AimTargetCenterMass' has a wrong offset!");

// Class DeceiveInc.SBStaticPointAimAssistTargetComponent
// 0x0000 (0x0100 - 0x0100)
class USBStaticPointAimAssistTargetComponent final : public USBAimAssistTargetComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SBStaticPointAimAssistTargetComponent">();
	}
	static class USBStaticPointAimAssistTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USBStaticPointAimAssistTargetComponent>();
	}
};
static_assert(alignof(USBStaticPointAimAssistTargetComponent) == 0x000008, "Wrong alignment on USBStaticPointAimAssistTargetComponent");
static_assert(sizeof(USBStaticPointAimAssistTargetComponent) == 0x000100, "Wrong size on USBStaticPointAimAssistTargetComponent");

// Class DeceiveInc.SBCollisionPatch
// 0x0010 (0x0230 - 0x0220)
class ASBCollisionPatch : public AActor
{
public:
	struct FVector                                ColScale;                                          // 0x0220(0x000C)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ColScale();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SBCollisionPatch">();
	}
	static class ASBCollisionPatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASBCollisionPatch>();
	}
};
static_assert(alignof(ASBCollisionPatch) == 0x000008, "Wrong alignment on ASBCollisionPatch");
static_assert(sizeof(ASBCollisionPatch) == 0x000230, "Wrong size on ASBCollisionPatch");
static_assert(offsetof(ASBCollisionPatch, ColScale) == 0x000220, "Member 'ASBCollisionPatch::ColScale' has a wrong offset!");

// Class DeceiveInc.SBColPatchMetadata
// 0x0010 (0x0048 - 0x0038)
class USBColPatchMetadata final : public UDIPrimaryDataAsset
{
public:
	TArray<class UClass*>                         RequiredClasses;                                   // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SBColPatchMetadata">();
	}
	static class USBColPatchMetadata* GetDefaultObj()
	{
		return GetDefaultObjImpl<USBColPatchMetadata>();
	}
};
static_assert(alignof(USBColPatchMetadata) == 0x000008, "Wrong alignment on USBColPatchMetadata");
static_assert(sizeof(USBColPatchMetadata) == 0x000048, "Wrong size on USBColPatchMetadata");
static_assert(offsetof(USBColPatchMetadata, RequiredClasses) == 0x000038, "Member 'USBColPatchMetadata::RequiredClasses' has a wrong offset!");

// Class DeceiveInc.SBPlayerRegistrySubsystem
// 0x0050 (0x0080 - 0x0030)
class USBPlayerRegistrySubsystem final : public UGameInstanceSubsystem
{
public:
	TSet<class ADIPlayerState*>                   RegisteredPlayerStates;                            // 0x0030(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SBPlayerRegistrySubsystem">();
	}
	static class USBPlayerRegistrySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USBPlayerRegistrySubsystem>();
	}
};
static_assert(alignof(USBPlayerRegistrySubsystem) == 0x000008, "Wrong alignment on USBPlayerRegistrySubsystem");
static_assert(sizeof(USBPlayerRegistrySubsystem) == 0x000080, "Wrong size on USBPlayerRegistrySubsystem");
static_assert(offsetof(USBPlayerRegistrySubsystem, RegisteredPlayerStates) == 0x000030, "Member 'USBPlayerRegistrySubsystem::RegisteredPlayerStates' has a wrong offset!");

// Class DeceiveInc.SBShaderPrecompilerSubsytem
// 0x0060 (0x0090 - 0x0030)
class USBShaderPrecompilerSubsytem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnShaderPrecompileFinished;                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x38];                                      // 0x0040(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASBShaderPrecompileWorkerActor*> Workers;                                           // 0x0078(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetShaderPrecompileProgress();
	void MaterialWorkCompleted();
	void ParticleWorkCompleted();
	bool ShouldPrecompileShaders();
	void StartShaderPrecompilation(bool bShowMenu);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SBShaderPrecompilerSubsytem">();
	}
	static class USBShaderPrecompilerSubsytem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USBShaderPrecompilerSubsytem>();
	}
};
static_assert(alignof(USBShaderPrecompilerSubsytem) == 0x000008, "Wrong alignment on USBShaderPrecompilerSubsytem");
static_assert(sizeof(USBShaderPrecompilerSubsytem) == 0x000090, "Wrong size on USBShaderPrecompilerSubsytem");
static_assert(offsetof(USBShaderPrecompilerSubsytem, OnShaderPrecompileFinished) == 0x000030, "Member 'USBShaderPrecompilerSubsytem::OnShaderPrecompileFinished' has a wrong offset!");
static_assert(offsetof(USBShaderPrecompilerSubsytem, Workers) == 0x000078, "Member 'USBShaderPrecompilerSubsytem::Workers' has a wrong offset!");

// Class DeceiveInc.SBShaderPrecompileWorkerActor
// 0x0080 (0x02A0 - 0x0220)
class ASBShaderPrecompileWorkerActor final : public AActor
{
public:
	class UStaticMeshComponent*                   Worker_StaticMesh;                                 // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 Worker_SkeletalMesh;                               // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    Worker_Niagara;                                    // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_238[0x60];                                     // 0x0238(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class USBShaderPrecompilerSubsytem*           ShaderPrecompiler;                                 // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SBShaderPrecompileWorkerActor">();
	}
	static class ASBShaderPrecompileWorkerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASBShaderPrecompileWorkerActor>();
	}
};
static_assert(alignof(ASBShaderPrecompileWorkerActor) == 0x000008, "Wrong alignment on ASBShaderPrecompileWorkerActor");
static_assert(sizeof(ASBShaderPrecompileWorkerActor) == 0x0002A0, "Wrong size on ASBShaderPrecompileWorkerActor");
static_assert(offsetof(ASBShaderPrecompileWorkerActor, Worker_StaticMesh) == 0x000220, "Member 'ASBShaderPrecompileWorkerActor::Worker_StaticMesh' has a wrong offset!");
static_assert(offsetof(ASBShaderPrecompileWorkerActor, Worker_SkeletalMesh) == 0x000228, "Member 'ASBShaderPrecompileWorkerActor::Worker_SkeletalMesh' has a wrong offset!");
static_assert(offsetof(ASBShaderPrecompileWorkerActor, Worker_Niagara) == 0x000230, "Member 'ASBShaderPrecompileWorkerActor::Worker_Niagara' has a wrong offset!");
static_assert(offsetof(ASBShaderPrecompileWorkerActor, ShaderPrecompiler) == 0x000298, "Member 'ASBShaderPrecompileWorkerActor::ShaderPrecompiler' has a wrong offset!");

// Class DeceiveInc.ScanAuthorityComponent
// 0x0010 (0x00C0 - 0x00B0)
class UScanAuthorityComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnScanComplete;                                    // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void NetMulticastCompleteScan(class ABaseScannerTool* Scanner, class UScannableComponent* Scannable, class AActor* Interacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScanAuthorityComponent">();
	}
	static class UScanAuthorityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScanAuthorityComponent>();
	}
};
static_assert(alignof(UScanAuthorityComponent) == 0x000008, "Wrong alignment on UScanAuthorityComponent");
static_assert(sizeof(UScanAuthorityComponent) == 0x0000C0, "Wrong size on UScanAuthorityComponent");
static_assert(offsetof(UScanAuthorityComponent, OnScanComplete) == 0x0000B0, "Member 'UScanAuthorityComponent::OnScanComplete' has a wrong offset!");

// Class DeceiveInc.ScrambleAffectedObject
// 0x0000 (0x0028 - 0x0028)
class IScrambleAffectedObject final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScrambleAffectedObject">();
	}
	static class IScrambleAffectedObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<IScrambleAffectedObject>();
	}
};
static_assert(alignof(IScrambleAffectedObject) == 0x000008, "Wrong alignment on IScrambleAffectedObject");
static_assert(sizeof(IScrambleAffectedObject) == 0x000028, "Wrong size on IScrambleAffectedObject");

// Class DeceiveInc.Scrambler
// 0x0038 (0x0350 - 0x0318)
class AScrambler final : public ABasePickablePlaceable
{
public:
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnToggleScrambler;                                 // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnScramblerPlaceableNewAffectedActor;              // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USphereComponent*                       DetectionCollisionSphereComp;                      // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAffectOwnerFaction;                               // 0x0348(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_349[0x7];                                      // 0x0349(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnToggleScrambler(bool bActive);
	void HandleDetectionCollisionBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void HandleDetectionCollisionEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	bool IsScrambleActive();
	void Multicast_ActivateScrambler(bool bActive);
	void Server_ActivateScrambler(bool bActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scrambler">();
	}
	static class AScrambler* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScrambler>();
	}
};
static_assert(alignof(AScrambler) == 0x000008, "Wrong alignment on AScrambler");
static_assert(sizeof(AScrambler) == 0x000350, "Wrong size on AScrambler");
static_assert(offsetof(AScrambler, OnToggleScrambler) == 0x000320, "Member 'AScrambler::OnToggleScrambler' has a wrong offset!");
static_assert(offsetof(AScrambler, OnScramblerPlaceableNewAffectedActor) == 0x000330, "Member 'AScrambler::OnScramblerPlaceableNewAffectedActor' has a wrong offset!");
static_assert(offsetof(AScrambler, DetectionCollisionSphereComp) == 0x000340, "Member 'AScrambler::DetectionCollisionSphereComp' has a wrong offset!");
static_assert(offsetof(AScrambler, bAffectOwnerFaction) == 0x000348, "Member 'AScrambler::bAffectOwnerFaction' has a wrong offset!");

// Class DeceiveInc.ScramblerTool
// 0x0060 (0x06E8 - 0x0688)
class AScramblerTool final : public ABasePlaceableSpyTool
{
public:
	uint8                                         Pad_688[0x8];                                      // 0x0688(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnToggleScramblerTool;                             // 0x0690(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnScramblerNewAffectedActor;                       // 0x06A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                   PlaceableToolDisabledSecondaryActionText;          // 0x06B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bAffectOwnerFaction;                               // 0x06C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C9[0x7];                                      // 0x06C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AScrambler*                             ScramblerActor;                                    // 0x06D0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       DetectionCollisionSphereComp;                      // 0x06D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6E0[0x8];                                      // 0x06E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnToggleInHandScrambler(bool bActive, bool bSendBPEvent);
	void HandleDetectionCollisionBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void HandleDetectionCollisionEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	bool IsScramblerToolActive();
	void NetMulticast_ToggleInHandScrambler(bool bActive);
	void Server_ToggleInHandScrambler(bool bActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScramblerTool">();
	}
	static class AScramblerTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScramblerTool>();
	}
};
static_assert(alignof(AScramblerTool) == 0x000008, "Wrong alignment on AScramblerTool");
static_assert(sizeof(AScramblerTool) == 0x0006E8, "Wrong size on AScramblerTool");
static_assert(offsetof(AScramblerTool, OnToggleScramblerTool) == 0x000690, "Member 'AScramblerTool::OnToggleScramblerTool' has a wrong offset!");
static_assert(offsetof(AScramblerTool, OnScramblerNewAffectedActor) == 0x0006A0, "Member 'AScramblerTool::OnScramblerNewAffectedActor' has a wrong offset!");
static_assert(offsetof(AScramblerTool, PlaceableToolDisabledSecondaryActionText) == 0x0006B0, "Member 'AScramblerTool::PlaceableToolDisabledSecondaryActionText' has a wrong offset!");
static_assert(offsetof(AScramblerTool, bAffectOwnerFaction) == 0x0006C8, "Member 'AScramblerTool::bAffectOwnerFaction' has a wrong offset!");
static_assert(offsetof(AScramblerTool, ScramblerActor) == 0x0006D0, "Member 'AScramblerTool::ScramblerActor' has a wrong offset!");
static_assert(offsetof(AScramblerTool, DetectionCollisionSphereComp) == 0x0006D8, "Member 'AScramblerTool::DetectionCollisionSphereComp' has a wrong offset!");

// Class DeceiveInc.ScriptedBotBrain
// 0x0008 (0x0080 - 0x0078)
class UScriptedBotBrain final : public UBotBrain
{
public:
	class UBotPlanFight*                          PlanFight;                                         // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnFightTargetLost(class UBotPlanFight* BotPlanFight, class ASpy* LostTarget);
	void OnUndercoverChange(bool bUndercover);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScriptedBotBrain">();
	}
	static class UScriptedBotBrain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScriptedBotBrain>();
	}
};
static_assert(alignof(UScriptedBotBrain) == 0x000008, "Wrong alignment on UScriptedBotBrain");
static_assert(sizeof(UScriptedBotBrain) == 0x000080, "Wrong size on UScriptedBotBrain");
static_assert(offsetof(UScriptedBotBrain, PlanFight) == 0x000078, "Member 'UScriptedBotBrain::PlanFight' has a wrong offset!");

// Class DeceiveInc.SecurityLevelConditionComponent
// 0x0030 (0x0100 - 0x00D0)
class USecurityLevelConditionComponent final : public UBaseConditionComponent
{
public:
	ECompareCheck                                 CompareCheck;                                      // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESecurityLevel                                SecurityLevel;                                     // 0x00D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ESecurityLevel>                        SecurityLevels;                                    // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<ENPCPool>                              NPCPools;                                          // 0x00E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bMustBeInCover;                                    // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SecurityLevelConditionComponent">();
	}
	static class USecurityLevelConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USecurityLevelConditionComponent>();
	}
};
static_assert(alignof(USecurityLevelConditionComponent) == 0x000008, "Wrong alignment on USecurityLevelConditionComponent");
static_assert(sizeof(USecurityLevelConditionComponent) == 0x000100, "Wrong size on USecurityLevelConditionComponent");
static_assert(offsetof(USecurityLevelConditionComponent, CompareCheck) == 0x0000D0, "Member 'USecurityLevelConditionComponent::CompareCheck' has a wrong offset!");
static_assert(offsetof(USecurityLevelConditionComponent, SecurityLevel) == 0x0000D1, "Member 'USecurityLevelConditionComponent::SecurityLevel' has a wrong offset!");
static_assert(offsetof(USecurityLevelConditionComponent, SecurityLevels) == 0x0000D8, "Member 'USecurityLevelConditionComponent::SecurityLevels' has a wrong offset!");
static_assert(offsetof(USecurityLevelConditionComponent, NPCPools) == 0x0000E8, "Member 'USecurityLevelConditionComponent::NPCPools' has a wrong offset!");
static_assert(offsetof(USecurityLevelConditionComponent, bMustBeInCover) == 0x0000F8, "Member 'USecurityLevelConditionComponent::bMustBeInCover' has a wrong offset!");

// Class DeceiveInc.SecurityLevelData
// 0x0100 (0x0138 - 0x0038)
class USecurityLevelData final : public UDIPrimaryDataAsset
{
public:
	TMap<ESecurityLevel, struct FColor>           SecurityColors;                                    // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<ENPCPool, class FText>                   NPCPoolDisplayName;                                // 0x0088(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FText>                           VIPName;                                           // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<ENPCPool, ESecurityLevel>                SecurityLevelForPool;                              // 0x00E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SecurityLevelData">();
	}
	static class USecurityLevelData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USecurityLevelData>();
	}
};
static_assert(alignof(USecurityLevelData) == 0x000008, "Wrong alignment on USecurityLevelData");
static_assert(sizeof(USecurityLevelData) == 0x000138, "Wrong size on USecurityLevelData");
static_assert(offsetof(USecurityLevelData, SecurityColors) == 0x000038, "Member 'USecurityLevelData::SecurityColors' has a wrong offset!");
static_assert(offsetof(USecurityLevelData, NPCPoolDisplayName) == 0x000088, "Member 'USecurityLevelData::NPCPoolDisplayName' has a wrong offset!");
static_assert(offsetof(USecurityLevelData, VIPName) == 0x0000D8, "Member 'USecurityLevelData::VIPName' has a wrong offset!");
static_assert(offsetof(USecurityLevelData, SecurityLevelForPool) == 0x0000E8, "Member 'USecurityLevelData::SecurityLevelForPool' has a wrong offset!");

// Class DeceiveInc.ShieldbrellaSpawnerWeapon
// 0x0120 (0x0B20 - 0x0A00)
class AShieldbrellaSpawnerWeapon final : public ASpawnerWeapon
{
public:
	struct FToolAssetsId                          PlaceableAssetsId;                                 // 0x0A00(0x0024)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A24[0x14];                                     // 0x0A24(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class URangePlacementComponent*               RangePlacementComp;                                // 0x0A38(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCooldownComponent*                     CooldownComp;                                      // 0x0A40(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHealthComponent*                       HealthComp;                                        // 0x0A48(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          BoxShieldComp;                                     // 0x0A50(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealingRatio;                                      // 0x0A58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealingDelay;                                      // 0x0A5C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamagingRatio;                                     // 0x0A60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamagingDelay;                                     // 0x0A64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeployedShieldHealth;                              // 0x0A68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CooldownBeforeRedeploying;                         // 0x0A6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShootingBlockedAfterClosingShield;                 // 0x0A70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OpeningDelayAfterShooting;                         // 0x0A74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumInteractionTimeToCloseShield;               // 0x0A78(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A7C[0x4];                                      // 0x0A7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADeployedShieldbrella*                  DeployedShieldActor;                               // 0x0A80(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayResourcesComponent*            GameplayResource;                                  // 0x0A88(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteracterComponent*                   InteracterComp;                                    // 0x0A90(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bToggleOpenShield;                                 // 0x0A98(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A99[0x3];                                      // 0x0A99(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecycleTime;                                       // 0x0A9C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ShieldActivateActionText;                          // 0x0AA0(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class FText                                   ShieldDeactivateActionText;                        // 0x0AB8(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseBumpMecanic;                                   // 0x0AD0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AD1[0x3];                                      // 0x0AD1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BumpImpulseStrength;                               // 0x0AD4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BumpSweepRadius;                                   // 0x0AD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             BumpCollCheck;                                     // 0x0ADC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ADD[0x3];                                      // 0x0ADD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BumpImpulseVerticalOffset;                         // 0x0AE0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AE4[0x26];                                     // 0x0AE4(0x0026)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShieldOpenedState;                                // 0x0B0A(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0B[0x15];                                     // 0x0B0B(0x0015)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleChargeAmountChange(int32 Amount);
	void HandleCooldownChange(bool bOnCooldown);
	void HandleDeath(class AActor* DeadActor);
	void HandleDeployedShieldActorDestroyed(class AActor* DestroyedActor);
	void HandleDeployedShieldHealthChange(class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, float RawDamage);
	void HandleDeployedShieldInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void HandleDeployedShieldSpawned(class ABasePlaceable* NewPlaceable);
	void HandleHealthChanged(class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, float RawDamage);
	void HandleLocalInteractionStart(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void HandleOpeningDelayAfterShootingTimerEnd();
	void HandleRecycleTimerEnd();
	void HandleRedeployTimerEnd();
	void HandleResourceNewAmount(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 Amount);
	void HandleShootingBlockedTimerEnd();
	void HandleWeaponShot(class ASpy* Spy);
	void Multicast_Bump(class AActor* BumpActor, const struct FVector_NetQuantize& BumpImpulse);
	void OnRep_NewPlaceableAssetsId();
	void OnRep_ShieldOpen();
	void RecycleServer();
	void Server_BumpMecanic();
	void Server_ForceDamage(float DamageAmount, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCause);
	void Server_OnShieldbrellaOpen(bool bIsOpen);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShieldbrellaSpawnerWeapon">();
	}
	static class AShieldbrellaSpawnerWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShieldbrellaSpawnerWeapon>();
	}
};
static_assert(alignof(AShieldbrellaSpawnerWeapon) == 0x000008, "Wrong alignment on AShieldbrellaSpawnerWeapon");
static_assert(sizeof(AShieldbrellaSpawnerWeapon) == 0x000B20, "Wrong size on AShieldbrellaSpawnerWeapon");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, PlaceableAssetsId) == 0x000A00, "Member 'AShieldbrellaSpawnerWeapon::PlaceableAssetsId' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, RangePlacementComp) == 0x000A38, "Member 'AShieldbrellaSpawnerWeapon::RangePlacementComp' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, CooldownComp) == 0x000A40, "Member 'AShieldbrellaSpawnerWeapon::CooldownComp' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, HealthComp) == 0x000A48, "Member 'AShieldbrellaSpawnerWeapon::HealthComp' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, BoxShieldComp) == 0x000A50, "Member 'AShieldbrellaSpawnerWeapon::BoxShieldComp' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, HealingRatio) == 0x000A58, "Member 'AShieldbrellaSpawnerWeapon::HealingRatio' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, HealingDelay) == 0x000A5C, "Member 'AShieldbrellaSpawnerWeapon::HealingDelay' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, DamagingRatio) == 0x000A60, "Member 'AShieldbrellaSpawnerWeapon::DamagingRatio' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, DamagingDelay) == 0x000A64, "Member 'AShieldbrellaSpawnerWeapon::DamagingDelay' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, DeployedShieldHealth) == 0x000A68, "Member 'AShieldbrellaSpawnerWeapon::DeployedShieldHealth' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, CooldownBeforeRedeploying) == 0x000A6C, "Member 'AShieldbrellaSpawnerWeapon::CooldownBeforeRedeploying' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, ShootingBlockedAfterClosingShield) == 0x000A70, "Member 'AShieldbrellaSpawnerWeapon::ShootingBlockedAfterClosingShield' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, OpeningDelayAfterShooting) == 0x000A74, "Member 'AShieldbrellaSpawnerWeapon::OpeningDelayAfterShooting' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, MinimumInteractionTimeToCloseShield) == 0x000A78, "Member 'AShieldbrellaSpawnerWeapon::MinimumInteractionTimeToCloseShield' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, DeployedShieldActor) == 0x000A80, "Member 'AShieldbrellaSpawnerWeapon::DeployedShieldActor' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, GameplayResource) == 0x000A88, "Member 'AShieldbrellaSpawnerWeapon::GameplayResource' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, InteracterComp) == 0x000A90, "Member 'AShieldbrellaSpawnerWeapon::InteracterComp' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, bToggleOpenShield) == 0x000A98, "Member 'AShieldbrellaSpawnerWeapon::bToggleOpenShield' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, RecycleTime) == 0x000A9C, "Member 'AShieldbrellaSpawnerWeapon::RecycleTime' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, ShieldActivateActionText) == 0x000AA0, "Member 'AShieldbrellaSpawnerWeapon::ShieldActivateActionText' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, ShieldDeactivateActionText) == 0x000AB8, "Member 'AShieldbrellaSpawnerWeapon::ShieldDeactivateActionText' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, bUseBumpMecanic) == 0x000AD0, "Member 'AShieldbrellaSpawnerWeapon::bUseBumpMecanic' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, BumpImpulseStrength) == 0x000AD4, "Member 'AShieldbrellaSpawnerWeapon::BumpImpulseStrength' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, BumpSweepRadius) == 0x000AD8, "Member 'AShieldbrellaSpawnerWeapon::BumpSweepRadius' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, BumpCollCheck) == 0x000ADC, "Member 'AShieldbrellaSpawnerWeapon::BumpCollCheck' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, BumpImpulseVerticalOffset) == 0x000AE0, "Member 'AShieldbrellaSpawnerWeapon::BumpImpulseVerticalOffset' has a wrong offset!");
static_assert(offsetof(AShieldbrellaSpawnerWeapon, bShieldOpenedState) == 0x000B0A, "Member 'AShieldbrellaSpawnerWeapon::bShieldOpenedState' has a wrong offset!");

// Class DeceiveInc.SingleUserConditionComponent
// 0x0018 (0x00E8 - 0x00D0)
class USingleUserConditionComponent final : public UBaseConditionComponent
{
public:
	TArray<struct FSingleUserReplicationData>     CurrentInteracters;                                // 0x00D0(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bPerTeamCondition;                                 // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SingleUserConditionComponent">();
	}
	static class USingleUserConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USingleUserConditionComponent>();
	}
};
static_assert(alignof(USingleUserConditionComponent) == 0x000008, "Wrong alignment on USingleUserConditionComponent");
static_assert(sizeof(USingleUserConditionComponent) == 0x0000E8, "Wrong size on USingleUserConditionComponent");
static_assert(offsetof(USingleUserConditionComponent, CurrentInteracters) == 0x0000D0, "Member 'USingleUserConditionComponent::CurrentInteracters' has a wrong offset!");
static_assert(offsetof(USingleUserConditionComponent, bPerTeamCondition) == 0x0000E0, "Member 'USingleUserConditionComponent::bPerTeamCondition' has a wrong offset!");

// Class DeceiveInc.SittableActor
// 0x0000 (0x0230 - 0x0230)
class ASittableActor final : public AStaticMeshActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SittableActor">();
	}
	static class ASittableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASittableActor>();
	}
};
static_assert(alignof(ASittableActor) == 0x000008, "Wrong alignment on ASittableActor");
static_assert(sizeof(ASittableActor) == 0x000230, "Wrong size on ASittableActor");

// Class DeceiveInc.SmokeGrenadeProjectileComponent
// 0x0010 (0x00C0 - 0x00B0)
class USmokeGrenadeProjectileComponent final : public UActorComponent
{
public:
	TSubclassOf<class AActor>                     SmokeZoneClass;                                    // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnProjectileHit(const struct FHitResult& Hit, const struct FVector& HitDirection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmokeGrenadeProjectileComponent">();
	}
	static class USmokeGrenadeProjectileComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmokeGrenadeProjectileComponent>();
	}
};
static_assert(alignof(USmokeGrenadeProjectileComponent) == 0x000008, "Wrong alignment on USmokeGrenadeProjectileComponent");
static_assert(sizeof(USmokeGrenadeProjectileComponent) == 0x0000C0, "Wrong size on USmokeGrenadeProjectileComponent");
static_assert(offsetof(USmokeGrenadeProjectileComponent, SmokeZoneClass) == 0x0000B0, "Member 'USmokeGrenadeProjectileComponent::SmokeZoneClass' has a wrong offset!");

// Class DeceiveInc.SmokeTestBotsManager
// 0x0030 (0x0058 - 0x0028)
class USmokeTestBotsManager final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmokeTestBotsManager">();
	}
	static class USmokeTestBotsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmokeTestBotsManager>();
	}
};
static_assert(alignof(USmokeTestBotsManager) == 0x000008, "Wrong alignment on USmokeTestBotsManager");
static_assert(sizeof(USmokeTestBotsManager) == 0x000058, "Wrong size on USmokeTestBotsManager");

// Class DeceiveInc.SmokeTestMurderBotBrain
// 0x0008 (0x0080 - 0x0078)
class USmokeTestMurderBotBrain final : public UBotBrain
{
public:
	class UBotPlanFight*                          PlanFight;                                         // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmokeTestMurderBotBrain">();
	}
	static class USmokeTestMurderBotBrain* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmokeTestMurderBotBrain>();
	}
};
static_assert(alignof(USmokeTestMurderBotBrain) == 0x000008, "Wrong alignment on USmokeTestMurderBotBrain");
static_assert(sizeof(USmokeTestMurderBotBrain) == 0x000080, "Wrong size on USmokeTestMurderBotBrain");
static_assert(offsetof(USmokeTestMurderBotBrain, PlanFight) == 0x000078, "Member 'USmokeTestMurderBotBrain::PlanFight' has a wrong offset!");

// Class DeceiveInc.SmokeZoneActor
// 0x0068 (0x0288 - 0x0220)
class ASmokeZoneActor final : public AActor
{
public:
	class UStaticMeshComponent*                   ZoneCollision;                                     // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EnemyVictimEffect;                                 // 0x0228(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoneLifeTime;                                      // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LingeringEffectDuration;                           // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_258[0x28];                                     // 0x0258(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOnlyAffectOutOfCoverSpys;                         // 0x0280(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_281[0x7];                                      // 0x0281(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleSpyUndercoverChanged(class ASpy* Spy, bool bUndercover);
	void OnCollisionBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnCollisionEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnLifeTimerHandleEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmokeZoneActor">();
	}
	static class ASmokeZoneActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASmokeZoneActor>();
	}
};
static_assert(alignof(ASmokeZoneActor) == 0x000008, "Wrong alignment on ASmokeZoneActor");
static_assert(sizeof(ASmokeZoneActor) == 0x000288, "Wrong size on ASmokeZoneActor");
static_assert(offsetof(ASmokeZoneActor, ZoneCollision) == 0x000220, "Member 'ASmokeZoneActor::ZoneCollision' has a wrong offset!");
static_assert(offsetof(ASmokeZoneActor, EnemyVictimEffect) == 0x000228, "Member 'ASmokeZoneActor::EnemyVictimEffect' has a wrong offset!");
static_assert(offsetof(ASmokeZoneActor, ZoneLifeTime) == 0x000250, "Member 'ASmokeZoneActor::ZoneLifeTime' has a wrong offset!");
static_assert(offsetof(ASmokeZoneActor, LingeringEffectDuration) == 0x000254, "Member 'ASmokeZoneActor::LingeringEffectDuration' has a wrong offset!");
static_assert(offsetof(ASmokeZoneActor, bOnlyAffectOutOfCoverSpys) == 0x000280, "Member 'ASmokeZoneActor::bOnlyAffectOutOfCoverSpys' has a wrong offset!");

// Class DeceiveInc.SocialInteractConditionComponent
// 0x0000 (0x00D0 - 0x00D0)
class USocialInteractConditionComponent final : public UBaseConditionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialInteractConditionComponent">();
	}
	static class USocialInteractConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialInteractConditionComponent>();
	}
};
static_assert(alignof(USocialInteractConditionComponent) == 0x000008, "Wrong alignment on USocialInteractConditionComponent");
static_assert(sizeof(USocialInteractConditionComponent) == 0x0000D0, "Wrong size on USocialInteractConditionComponent");

// Class DeceiveInc.SocialiteActiveAbility
// 0x0140 (0x06D0 - 0x0590)
class ASocialiteActiveAbility final : public ABaseSpyActiveAbility
{
public:
	class FName                                   MuzzleSocketName;                                  // 0x0590(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SocialiteVictimEffectSpy;                          // 0x0598(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SocialiteVictimEffectNPC;                          // 0x05C0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnEffectDelay;                                  // 0x05E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AfterSpawnEffectDelay;                             // 0x05EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackRange;                                       // 0x05F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackAngle;                                       // 0x05F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSocialiteActiveEffectHit;                        // 0x05F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<uint64, struct FSAAQueryData>            DelayedActiveStorage;                              // 0x0608(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_658[0x78];                                     // 0x0658(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnLocalSocialiteActiveEnd();
	void BP_OnLocalSocialiteActiveStart();
	void BP_OnSocialiteActiveConeAttack(const struct FVector& OriginPos, const struct FVector& Normal, float ConeLength, float ConeAngle);
	void BP_OnSocialiteActiveConeAttackLocal(const struct FVector& OriginPos, const struct FVector& Normal, float ConeLength, float ConeAngle);
	void BP_OnSocialiteActiveConeAttackReplicated(const struct FVector& OriginPos, const struct FVector& Normal, float ConeLength, float ConeAngle);
	void BP_OnSocialiteActiveEffectHit(class AActor* Victim, const struct FVector& ImpactPoint, const struct FVector& ImpactNormal);
	void MulticastProjectileHit(class AActor* Victim, const struct FVector_NetQuantize& ImpactPos, const struct FVector_NetQuantizeNormal& ImpactNormal);
	void MulticastSocialiteActiveConeAttack(const struct FVector_NetQuantize& OriginPos, const struct FVector_NetQuantizeNormal& Normal);
	void OnAfterShotTimerEnd();
	void OnLocalSocialiteActiveEnd();
	void OnServerSocialiteActiveEnd();
	void Server_StartSocialiteActive();
	void Server_TriggerAttack(const struct FVector& OriginPos, const struct FVector& Normal);

	struct FVector GetMuzzlePosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialiteActiveAbility">();
	}
	static class ASocialiteActiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASocialiteActiveAbility>();
	}
};
static_assert(alignof(ASocialiteActiveAbility) == 0x000008, "Wrong alignment on ASocialiteActiveAbility");
static_assert(sizeof(ASocialiteActiveAbility) == 0x0006D0, "Wrong size on ASocialiteActiveAbility");
static_assert(offsetof(ASocialiteActiveAbility, MuzzleSocketName) == 0x000590, "Member 'ASocialiteActiveAbility::MuzzleSocketName' has a wrong offset!");
static_assert(offsetof(ASocialiteActiveAbility, SocialiteVictimEffectSpy) == 0x000598, "Member 'ASocialiteActiveAbility::SocialiteVictimEffectSpy' has a wrong offset!");
static_assert(offsetof(ASocialiteActiveAbility, SocialiteVictimEffectNPC) == 0x0005C0, "Member 'ASocialiteActiveAbility::SocialiteVictimEffectNPC' has a wrong offset!");
static_assert(offsetof(ASocialiteActiveAbility, SpawnEffectDelay) == 0x0005E8, "Member 'ASocialiteActiveAbility::SpawnEffectDelay' has a wrong offset!");
static_assert(offsetof(ASocialiteActiveAbility, AfterSpawnEffectDelay) == 0x0005EC, "Member 'ASocialiteActiveAbility::AfterSpawnEffectDelay' has a wrong offset!");
static_assert(offsetof(ASocialiteActiveAbility, AttackRange) == 0x0005F0, "Member 'ASocialiteActiveAbility::AttackRange' has a wrong offset!");
static_assert(offsetof(ASocialiteActiveAbility, AttackAngle) == 0x0005F4, "Member 'ASocialiteActiveAbility::AttackAngle' has a wrong offset!");
static_assert(offsetof(ASocialiteActiveAbility, OnSocialiteActiveEffectHit) == 0x0005F8, "Member 'ASocialiteActiveAbility::OnSocialiteActiveEffectHit' has a wrong offset!");
static_assert(offsetof(ASocialiteActiveAbility, DelayedActiveStorage) == 0x000608, "Member 'ASocialiteActiveAbility::DelayedActiveStorage' has a wrong offset!");

// Class DeceiveInc.SocialiteActiveAbilityMod1
// 0x00C8 (0x0658 - 0x0590)
class ASocialiteActiveAbilityMod1 final : public ABaseSpyActiveAbility
{
public:
	class FName                                   MuzzleSocketName;                                  // 0x0590(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SocialiteVictimEffectSpy;                          // 0x0598(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnEffectDelay;                                  // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AfterSpawnEffectDelay;                             // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackRadius;                                      // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackHeight;                                      // 0x05CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSocialiteActiveMod1EffectHit;                    // 0x05D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E0[0x78];                                     // 0x05E0(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnLocalSocialiteActiveEnd();
	void BP_OnLocalSocialiteActiveStart();
	void BP_OnSocialiteActiveEffectHit(class AActor* Victim, const struct FVector& ImpactPoint, const struct FVector& ImpactNormal);
	void BP_OnSocialiteActiveMod1(const struct FVector& FloorPos, const struct FVector& Normal, float Radius, float Height);
	void BP_OnSocialiteActiveMod1Local(const struct FVector& FloorPos, const struct FVector& Normal, float Radius, float Height);
	void BP_OnSocialiteActiveMod1Replicated(const struct FVector& FloorPos, const struct FVector& Normal, float Radius, float Height);
	void MulticastProjectileHit(class AActor* Victim, const struct FVector_NetQuantize& ImpactPos, const struct FVector_NetQuantizeNormal& ImpactNormal);
	void MulticastSocialiteActiveMod1(const struct FVector_NetQuantize& OriginPos, const struct FVector_NetQuantizeNormal& Normal);
	void OnAfterShotTimerEnd();
	void OnServerSocialiteActiveEnd();
	void Server_StartSocialiteActive();

	struct FVector GetMuzzlePosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialiteActiveAbilityMod1">();
	}
	static class ASocialiteActiveAbilityMod1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASocialiteActiveAbilityMod1>();
	}
};
static_assert(alignof(ASocialiteActiveAbilityMod1) == 0x000008, "Wrong alignment on ASocialiteActiveAbilityMod1");
static_assert(sizeof(ASocialiteActiveAbilityMod1) == 0x000658, "Wrong size on ASocialiteActiveAbilityMod1");
static_assert(offsetof(ASocialiteActiveAbilityMod1, MuzzleSocketName) == 0x000590, "Member 'ASocialiteActiveAbilityMod1::MuzzleSocketName' has a wrong offset!");
static_assert(offsetof(ASocialiteActiveAbilityMod1, SocialiteVictimEffectSpy) == 0x000598, "Member 'ASocialiteActiveAbilityMod1::SocialiteVictimEffectSpy' has a wrong offset!");
static_assert(offsetof(ASocialiteActiveAbilityMod1, SpawnEffectDelay) == 0x0005C0, "Member 'ASocialiteActiveAbilityMod1::SpawnEffectDelay' has a wrong offset!");
static_assert(offsetof(ASocialiteActiveAbilityMod1, AfterSpawnEffectDelay) == 0x0005C4, "Member 'ASocialiteActiveAbilityMod1::AfterSpawnEffectDelay' has a wrong offset!");
static_assert(offsetof(ASocialiteActiveAbilityMod1, AttackRadius) == 0x0005C8, "Member 'ASocialiteActiveAbilityMod1::AttackRadius' has a wrong offset!");
static_assert(offsetof(ASocialiteActiveAbilityMod1, AttackHeight) == 0x0005CC, "Member 'ASocialiteActiveAbilityMod1::AttackHeight' has a wrong offset!");
static_assert(offsetof(ASocialiteActiveAbilityMod1, OnSocialiteActiveMod1EffectHit) == 0x0005D0, "Member 'ASocialiteActiveAbilityMod1::OnSocialiteActiveMod1EffectHit' has a wrong offset!");

// Class DeceiveInc.SocialiteActiveAbilityMod2
// 0x0098 (0x0628 - 0x0590)
class ASocialiteActiveAbilityMod2 final : public ABaseSpyActiveAbility
{
public:
	FMulticastInlineDelegateProperty_             OnTrapThrowDelayEnd;                               // 0x0590(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTrapFullThrowEnd;                                // 0x05A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class URangePlacementComponent*               RangePlacementComp;                                // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayResourcesComponent*            GameplayResource;                                  // 0x05B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VictimEffectDuration;                              // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C4[0x4];                                      // 0x05C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASocialiteTrap*                         SocialiteTrap;                                     // 0x05C8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowDelay1P;                                      // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowOutTime1P;                                    // 0x05D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowDelay3P;                                      // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowOutlTime3P;                                   // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E0[0x48];                                     // 0x05E0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleMiscToolSpawned(class AActor* SpawnedTool);
	void HandleTrapPickedUp(class AActor* Spy);
	void HandleTrapTriggered();
	void OnPendingSpawnTrapTimer();
	void OnRep_SocialiteTrap();
	void OnThrowDelayTimerEnd();
	void OnThrowTimerEnd();
	void OnTrapDeath(class AActor* DeadActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialiteActiveAbilityMod2">();
	}
	static class ASocialiteActiveAbilityMod2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASocialiteActiveAbilityMod2>();
	}
};
static_assert(alignof(ASocialiteActiveAbilityMod2) == 0x000008, "Wrong alignment on ASocialiteActiveAbilityMod2");
static_assert(sizeof(ASocialiteActiveAbilityMod2) == 0x000628, "Wrong size on ASocialiteActiveAbilityMod2");
static_assert(offsetof(ASocialiteActiveAbilityMod2, OnTrapThrowDelayEnd) == 0x000590, "Member 'ASocialiteActiveAbilityMod2::OnTrapThrowDelayEnd' has a wrong offset!");
static_assert(offsetof(ASocialiteActiveAbilityMod2, OnTrapFullThrowEnd) == 0x0005A0, "Member 'ASocialiteActiveAbilityMod2::OnTrapFullThrowEnd' has a wrong offset!");
static_assert(offsetof(ASocialiteActiveAbilityMod2, RangePlacementComp) == 0x0005B0, "Member 'ASocialiteActiveAbilityMod2::RangePlacementComp' has a wrong offset!");
static_assert(offsetof(ASocialiteActiveAbilityMod2, GameplayResource) == 0x0005B8, "Member 'ASocialiteActiveAbilityMod2::GameplayResource' has a wrong offset!");
static_assert(offsetof(ASocialiteActiveAbilityMod2, VictimEffectDuration) == 0x0005C0, "Member 'ASocialiteActiveAbilityMod2::VictimEffectDuration' has a wrong offset!");
static_assert(offsetof(ASocialiteActiveAbilityMod2, SocialiteTrap) == 0x0005C8, "Member 'ASocialiteActiveAbilityMod2::SocialiteTrap' has a wrong offset!");
static_assert(offsetof(ASocialiteActiveAbilityMod2, ThrowDelay1P) == 0x0005D0, "Member 'ASocialiteActiveAbilityMod2::ThrowDelay1P' has a wrong offset!");
static_assert(offsetof(ASocialiteActiveAbilityMod2, ThrowOutTime1P) == 0x0005D4, "Member 'ASocialiteActiveAbilityMod2::ThrowOutTime1P' has a wrong offset!");
static_assert(offsetof(ASocialiteActiveAbilityMod2, ThrowDelay3P) == 0x0005D8, "Member 'ASocialiteActiveAbilityMod2::ThrowDelay3P' has a wrong offset!");
static_assert(offsetof(ASocialiteActiveAbilityMod2, ThrowOutlTime3P) == 0x0005DC, "Member 'ASocialiteActiveAbilityMod2::ThrowOutlTime3P' has a wrong offset!");

// Class DeceiveInc.SocialitePassiveAbility
// 0x0028 (0x0558 - 0x0530)
class ASocialitePassiveAbility final : public ABaseSpyPassiveAbility
{
public:
	TSoftClassPtr<class UClass>                   RegainCoverVictimEffect;                           // 0x0530(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnUndercoverChange(bool Undercover);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialitePassiveAbility">();
	}
	static class ASocialitePassiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASocialitePassiveAbility>();
	}
};
static_assert(alignof(ASocialitePassiveAbility) == 0x000008, "Wrong alignment on ASocialitePassiveAbility");
static_assert(sizeof(ASocialitePassiveAbility) == 0x000558, "Wrong size on ASocialitePassiveAbility");
static_assert(offsetof(ASocialitePassiveAbility, RegainCoverVictimEffect) == 0x000530, "Member 'ASocialitePassiveAbility::RegainCoverVictimEffect' has a wrong offset!");

// Class DeceiveInc.SocialitePassiveAbilityMod1
// 0x0058 (0x0588 - 0x0530)
class ASocialitePassiveAbilityMod1 final : public ABaseSpyPassiveAbility
{
public:
	float                                         PassiveRange;                                      // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PassiveHeight;                                     // 0x0534(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PassiveMaxDuration;                                // 0x0538(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PassiveLingeringDuration;                          // 0x053C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoverReduction;                                  // 0x0540(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_544[0x4];                                      // 0x0544(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   VictimEffectClassToSelfApply;                      // 0x0548(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AVictimEffect*                          CurrentVictimEffect;                               // 0x0570(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_578[0x10];                                     // 0x0578(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleSpyDeath(class ASpy* DeadSpy);
	void HandleUnderCoverChanged(bool bUndercover);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialitePassiveAbilityMod1">();
	}
	static class ASocialitePassiveAbilityMod1* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASocialitePassiveAbilityMod1>();
	}
};
static_assert(alignof(ASocialitePassiveAbilityMod1) == 0x000008, "Wrong alignment on ASocialitePassiveAbilityMod1");
static_assert(sizeof(ASocialitePassiveAbilityMod1) == 0x000588, "Wrong size on ASocialitePassiveAbilityMod1");
static_assert(offsetof(ASocialitePassiveAbilityMod1, PassiveRange) == 0x000530, "Member 'ASocialitePassiveAbilityMod1::PassiveRange' has a wrong offset!");
static_assert(offsetof(ASocialitePassiveAbilityMod1, PassiveHeight) == 0x000534, "Member 'ASocialitePassiveAbilityMod1::PassiveHeight' has a wrong offset!");
static_assert(offsetof(ASocialitePassiveAbilityMod1, PassiveMaxDuration) == 0x000538, "Member 'ASocialitePassiveAbilityMod1::PassiveMaxDuration' has a wrong offset!");
static_assert(offsetof(ASocialitePassiveAbilityMod1, PassiveLingeringDuration) == 0x00053C, "Member 'ASocialitePassiveAbilityMod1::PassiveLingeringDuration' has a wrong offset!");
static_assert(offsetof(ASocialitePassiveAbilityMod1, RecoverReduction) == 0x000540, "Member 'ASocialitePassiveAbilityMod1::RecoverReduction' has a wrong offset!");
static_assert(offsetof(ASocialitePassiveAbilityMod1, VictimEffectClassToSelfApply) == 0x000548, "Member 'ASocialitePassiveAbilityMod1::VictimEffectClassToSelfApply' has a wrong offset!");
static_assert(offsetof(ASocialitePassiveAbilityMod1, CurrentVictimEffect) == 0x000570, "Member 'ASocialitePassiveAbilityMod1::CurrentVictimEffect' has a wrong offset!");

// Class DeceiveInc.SocialitePassiveAbilityMod2
// 0x0110 (0x0640 - 0x0530)
class ASocialitePassiveAbilityMod2 final : public ABaseSpyPassiveAbility
{
public:
	FMulticastInlineDelegateProperty_             OnSpyTraceHeatStart;                               // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyTraceScoldedStart;                            // 0x0540(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyTraceScoldedEnd;                              // 0x0550(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         ScoldDetectionRange;                               // 0x0560(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScoldDetectionHeight;                              // 0x0564(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HeatDetectionRange;                                // 0x0568(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HeatDetectionHeight;                               // 0x056C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VictimEffectDuration;                              // 0x0570(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_574[0x4];                                      // 0x0574(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   TraceVictimEffectClass;                            // 0x0578(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class ASpy*, class AVictimEffect*>       ScoldTracedSpys;                                   // 0x05A0(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class ASpy*, class AVictimEffect*>       HeatTracedSpys;                                    // 0x05F0(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void HandleSpyHeatChange(class ASpy* Spy, int32 NewHeatValue, int32 HeatDelta);
	void HandleSpySecurityStateChanged(class ASpy* Spy, ESpySecurityState PreviousState, ESpySecurityState NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialitePassiveAbilityMod2">();
	}
	static class ASocialitePassiveAbilityMod2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASocialitePassiveAbilityMod2>();
	}
};
static_assert(alignof(ASocialitePassiveAbilityMod2) == 0x000008, "Wrong alignment on ASocialitePassiveAbilityMod2");
static_assert(sizeof(ASocialitePassiveAbilityMod2) == 0x000640, "Wrong size on ASocialitePassiveAbilityMod2");
static_assert(offsetof(ASocialitePassiveAbilityMod2, OnSpyTraceHeatStart) == 0x000530, "Member 'ASocialitePassiveAbilityMod2::OnSpyTraceHeatStart' has a wrong offset!");
static_assert(offsetof(ASocialitePassiveAbilityMod2, OnSpyTraceScoldedStart) == 0x000540, "Member 'ASocialitePassiveAbilityMod2::OnSpyTraceScoldedStart' has a wrong offset!");
static_assert(offsetof(ASocialitePassiveAbilityMod2, OnSpyTraceScoldedEnd) == 0x000550, "Member 'ASocialitePassiveAbilityMod2::OnSpyTraceScoldedEnd' has a wrong offset!");
static_assert(offsetof(ASocialitePassiveAbilityMod2, ScoldDetectionRange) == 0x000560, "Member 'ASocialitePassiveAbilityMod2::ScoldDetectionRange' has a wrong offset!");
static_assert(offsetof(ASocialitePassiveAbilityMod2, ScoldDetectionHeight) == 0x000564, "Member 'ASocialitePassiveAbilityMod2::ScoldDetectionHeight' has a wrong offset!");
static_assert(offsetof(ASocialitePassiveAbilityMod2, HeatDetectionRange) == 0x000568, "Member 'ASocialitePassiveAbilityMod2::HeatDetectionRange' has a wrong offset!");
static_assert(offsetof(ASocialitePassiveAbilityMod2, HeatDetectionHeight) == 0x00056C, "Member 'ASocialitePassiveAbilityMod2::HeatDetectionHeight' has a wrong offset!");
static_assert(offsetof(ASocialitePassiveAbilityMod2, VictimEffectDuration) == 0x000570, "Member 'ASocialitePassiveAbilityMod2::VictimEffectDuration' has a wrong offset!");
static_assert(offsetof(ASocialitePassiveAbilityMod2, TraceVictimEffectClass) == 0x000578, "Member 'ASocialitePassiveAbilityMod2::TraceVictimEffectClass' has a wrong offset!");
static_assert(offsetof(ASocialitePassiveAbilityMod2, ScoldTracedSpys) == 0x0005A0, "Member 'ASocialitePassiveAbilityMod2::ScoldTracedSpys' has a wrong offset!");
static_assert(offsetof(ASocialitePassiveAbilityMod2, HeatTracedSpys) == 0x0005F0, "Member 'ASocialitePassiveAbilityMod2::HeatTracedSpys' has a wrong offset!");

// Class DeceiveInc.SocialiteTrap
// 0x00D0 (0x03E8 - 0x0318)
class ASocialiteTrap final : public ABasePickablePlaceable
{
public:
	TSoftClassPtr<class UClass>                   TrapVictimEffect;                                  // 0x0318(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSocialiteTrapTriggered;                          // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSocialiteTrapPickedUp;                           // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   DetectionCollisionShapeComp;                       // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0x18];                                     // 0x0368(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ConditionMetText;                                  // 0x0380(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EConditionType, class FText>             ConditionNotMetTextMap;                            // 0x0398(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void HandleDetectionCollisionBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void HandleDetectionCollisionEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnHealthChanged(class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, float RawDamage);
	void OnInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void OnSpyInRangeUndercoverChange(bool bUndercover);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialiteTrap">();
	}
	static class ASocialiteTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASocialiteTrap>();
	}
};
static_assert(alignof(ASocialiteTrap) == 0x000008, "Wrong alignment on ASocialiteTrap");
static_assert(sizeof(ASocialiteTrap) == 0x0003E8, "Wrong size on ASocialiteTrap");
static_assert(offsetof(ASocialiteTrap, TrapVictimEffect) == 0x000318, "Member 'ASocialiteTrap::TrapVictimEffect' has a wrong offset!");
static_assert(offsetof(ASocialiteTrap, OnSocialiteTrapTriggered) == 0x000340, "Member 'ASocialiteTrap::OnSocialiteTrapTriggered' has a wrong offset!");
static_assert(offsetof(ASocialiteTrap, OnSocialiteTrapPickedUp) == 0x000350, "Member 'ASocialiteTrap::OnSocialiteTrapPickedUp' has a wrong offset!");
static_assert(offsetof(ASocialiteTrap, DetectionCollisionShapeComp) == 0x000360, "Member 'ASocialiteTrap::DetectionCollisionShapeComp' has a wrong offset!");
static_assert(offsetof(ASocialiteTrap, ConditionMetText) == 0x000380, "Member 'ASocialiteTrap::ConditionMetText' has a wrong offset!");
static_assert(offsetof(ASocialiteTrap, ConditionNotMetTextMap) == 0x000398, "Member 'ASocialiteTrap::ConditionNotMetTextMap' has a wrong offset!");

// Class DeceiveInc.SoundMachine
// 0x00E0 (0x03F8 - 0x0318)
class ASoundMachine final : public ABasePickablePlaceable
{
public:
	class ASoundMachineTool*                      SoundMachineTool;                                  // 0x0318(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 AudioEventName;                                    // 0x0320(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AkComponent;                                       // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultTimeForAudioEnd;                            // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DangerPosOffset;                                   // 0x033C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnSoundMachineAudioStart;                          // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnSoundMachineAudioEnd;                            // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnSoundMachineAudioPlay;                           // 0x0368(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_378[0x80];                                     // 0x0378(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NetMulticast_PlaySound(const struct FTrackSoundEvents& SoundToPlay, int32 NewRandomSeed);
	void OnAudioEndedTimerEnd();
	void OnSoundLoopTimerEnd();
	void OnSoundPlayTimerEnd();
	void Server_PlaySound(const struct FTrackSoundEvents& SoundToPlay, int32 NewRandomSeed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundMachine">();
	}
	static class ASoundMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASoundMachine>();
	}
};
static_assert(alignof(ASoundMachine) == 0x000008, "Wrong alignment on ASoundMachine");
static_assert(sizeof(ASoundMachine) == 0x0003F8, "Wrong size on ASoundMachine");
static_assert(offsetof(ASoundMachine, SoundMachineTool) == 0x000318, "Member 'ASoundMachine::SoundMachineTool' has a wrong offset!");
static_assert(offsetof(ASoundMachine, AudioEventName) == 0x000320, "Member 'ASoundMachine::AudioEventName' has a wrong offset!");
static_assert(offsetof(ASoundMachine, AkComponent) == 0x000330, "Member 'ASoundMachine::AkComponent' has a wrong offset!");
static_assert(offsetof(ASoundMachine, DefaultTimeForAudioEnd) == 0x000338, "Member 'ASoundMachine::DefaultTimeForAudioEnd' has a wrong offset!");
static_assert(offsetof(ASoundMachine, DangerPosOffset) == 0x00033C, "Member 'ASoundMachine::DangerPosOffset' has a wrong offset!");
static_assert(offsetof(ASoundMachine, OnSoundMachineAudioStart) == 0x000348, "Member 'ASoundMachine::OnSoundMachineAudioStart' has a wrong offset!");
static_assert(offsetof(ASoundMachine, OnSoundMachineAudioEnd) == 0x000358, "Member 'ASoundMachine::OnSoundMachineAudioEnd' has a wrong offset!");
static_assert(offsetof(ASoundMachine, OnSoundMachineAudioPlay) == 0x000368, "Member 'ASoundMachine::OnSoundMachineAudioPlay' has a wrong offset!");

// Class DeceiveInc.SoundMachineTool
// 0x0068 (0x06F0 - 0x0688)
class ASoundMachineTool final : public ABasePlaceableSpyTool
{
public:
	FMulticastInlineDelegateProperty_             OnSoundCooldownEnd;                                // 0x0688(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSoundCooldownStart;                              // 0x0698(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTrackChanged;                                    // 0x06A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FTrackSoundEvents>              AudioTracks;                                       // 0x06B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         SoundCooldown;                                     // 0x06C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SoundMachineReticleName;                           // 0x06CC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D4[0x4];                                      // 0x06D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASoundMachine*                          SoundMachineActor;                                 // 0x06D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6E0[0x10];                                     // 0x06E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FTrackSoundEvents GetCurrentSoundTrackInfo();
	void HandleSoundMachineDropDone(class AActor* ActorDropped, const struct FVector& EndPos, const struct FRotator& EndRotation);
	void OnSoundCooldownTimerEnd();

	bool IsSoundPlaying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundMachineTool">();
	}
	static class ASoundMachineTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASoundMachineTool>();
	}
};
static_assert(alignof(ASoundMachineTool) == 0x000008, "Wrong alignment on ASoundMachineTool");
static_assert(sizeof(ASoundMachineTool) == 0x0006F0, "Wrong size on ASoundMachineTool");
static_assert(offsetof(ASoundMachineTool, OnSoundCooldownEnd) == 0x000688, "Member 'ASoundMachineTool::OnSoundCooldownEnd' has a wrong offset!");
static_assert(offsetof(ASoundMachineTool, OnSoundCooldownStart) == 0x000698, "Member 'ASoundMachineTool::OnSoundCooldownStart' has a wrong offset!");
static_assert(offsetof(ASoundMachineTool, OnTrackChanged) == 0x0006A8, "Member 'ASoundMachineTool::OnTrackChanged' has a wrong offset!");
static_assert(offsetof(ASoundMachineTool, AudioTracks) == 0x0006B8, "Member 'ASoundMachineTool::AudioTracks' has a wrong offset!");
static_assert(offsetof(ASoundMachineTool, SoundCooldown) == 0x0006C8, "Member 'ASoundMachineTool::SoundCooldown' has a wrong offset!");
static_assert(offsetof(ASoundMachineTool, SoundMachineReticleName) == 0x0006CC, "Member 'ASoundMachineTool::SoundMachineReticleName' has a wrong offset!");
static_assert(offsetof(ASoundMachineTool, SoundMachineActor) == 0x0006D8, "Member 'ASoundMachineTool::SoundMachineActor' has a wrong offset!");

// Class DeceiveInc.SpawnableObjectInterface
// 0x0000 (0x0028 - 0x0028)
class ISpawnableObjectInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnableObjectInterface">();
	}
	static class ISpawnableObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISpawnableObjectInterface>();
	}
};
static_assert(alignof(ISpawnableObjectInterface) == 0x000008, "Wrong alignment on ISpawnableObjectInterface");
static_assert(sizeof(ISpawnableObjectInterface) == 0x000028, "Wrong size on ISpawnableObjectInterface");

// Class DeceiveInc.SpawnerWeaponInterface
// 0x0000 (0x0028 - 0x0028)
class ISpawnerWeaponInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerWeaponInterface">();
	}
	static class ISpawnerWeaponInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISpawnerWeaponInterface>();
	}
};
static_assert(alignof(ISpawnerWeaponInterface) == 0x000008, "Wrong alignment on ISpawnerWeaponInterface");
static_assert(sizeof(ISpawnerWeaponInterface) == 0x000028, "Wrong size on ISpawnerWeaponInterface");

// Class DeceiveInc.SpawnerWeaponRound
// 0x00B0 (0x02D0 - 0x0220)
class ASpawnerWeaponRound : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnVisibilityChanged;                               // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_230[0x28];                                     // 0x0230(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanBeHeld;                                        // 0x0258(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ActorToSpawnOnHitClass;                            // 0x0260(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSimulationMode;                                   // 0x0288(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShootFromCameraAndFakeMuzzlePos;                  // 0x0289(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28A[0x2];                                      // 0x028A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShootFromCameraResetMeshDuration;                  // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x40];                                     // 0x0290(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_SignalRelease();
	class AActor* GetSpawnerWeapon();
	void ProjectilesAbortHandler();
	void ProjectilesReleasedHandler(const struct FVector& AimPosition);
	void ShowProjectilesHandler(EVisibilityMode VisibilityMode);
	void UpdateBreadcrumb();

	bool CanBeHeld() const;
	TSoftClassPtr<class UClass> GetActorToSpawnOnHit() const;
	const struct FVector GetReleasePosition() const;
	bool IsShootFromCameraAndFakeMuzzlePos() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerWeaponRound">();
	}
	static class ASpawnerWeaponRound* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpawnerWeaponRound>();
	}
};
static_assert(alignof(ASpawnerWeaponRound) == 0x000008, "Wrong alignment on ASpawnerWeaponRound");
static_assert(sizeof(ASpawnerWeaponRound) == 0x0002D0, "Wrong size on ASpawnerWeaponRound");
static_assert(offsetof(ASpawnerWeaponRound, OnVisibilityChanged) == 0x000220, "Member 'ASpawnerWeaponRound::OnVisibilityChanged' has a wrong offset!");
static_assert(offsetof(ASpawnerWeaponRound, bCanBeHeld) == 0x000258, "Member 'ASpawnerWeaponRound::bCanBeHeld' has a wrong offset!");
static_assert(offsetof(ASpawnerWeaponRound, ActorToSpawnOnHitClass) == 0x000260, "Member 'ASpawnerWeaponRound::ActorToSpawnOnHitClass' has a wrong offset!");
static_assert(offsetof(ASpawnerWeaponRound, bSimulationMode) == 0x000288, "Member 'ASpawnerWeaponRound::bSimulationMode' has a wrong offset!");
static_assert(offsetof(ASpawnerWeaponRound, bShootFromCameraAndFakeMuzzlePos) == 0x000289, "Member 'ASpawnerWeaponRound::bShootFromCameraAndFakeMuzzlePos' has a wrong offset!");
static_assert(offsetof(ASpawnerWeaponRound, ShootFromCameraResetMeshDuration) == 0x00028C, "Member 'ASpawnerWeaponRound::ShootFromCameraResetMeshDuration' has a wrong offset!");

// Class DeceiveInc.SpawnerWeaponRound_Beam
// 0x0000 (0x02D0 - 0x02D0)
class ASpawnerWeaponRound_Beam final : public ASpawnerWeaponRound
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerWeaponRound_Beam">();
	}
	static class ASpawnerWeaponRound_Beam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpawnerWeaponRound_Beam>();
	}
};
static_assert(alignof(ASpawnerWeaponRound_Beam) == 0x000008, "Wrong alignment on ASpawnerWeaponRound_Beam");
static_assert(sizeof(ASpawnerWeaponRound_Beam) == 0x0002D0, "Wrong size on ASpawnerWeaponRound_Beam");

// Class DeceiveInc.SpawnerWeaponRound_Projectile
// 0x0098 (0x0368 - 0x02D0)
class ASpawnerWeaponRound_Projectile : public ASpawnerWeaponRound
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaximumTimeToLive;                                 // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UProjectileMovementComponent*           MovementComponent;                                 // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnProjectileHit;                                   // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USphereComponent*                       CollisionComponent;                                // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ImpactForce;                                       // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Damage;                                            // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CriticalDamage;                                    // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LimbDamage;                                        // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoDestroyOnImpact;                              // 0x0310(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowMultipleHits;                                // 0x0311(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_312[0x2];                                      // 0x0312(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaximumRangeForDamageFalloff;                      // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DamageFalloffCurve;                                // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DamageBehaviorName;                                // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BalancingName;                                     // 0x0328(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             BalancingDataTable;                                // 0x0330(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNoRadiusVersusEnvironment;                        // 0x0338(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_339[0x2F];                                     // 0x0339(0x002F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyNewBalancingTableAndUpdateStats(class UDataTable* NewTable, class FName NewBalancingName);
	void BP_OnLifetimeCompleted();
	void HandleBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void HandleHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnLifetimeCompleted();
	void UpdateStatsFromBalancingTable();

	class UDataTable* GetBalancingDataTable() const;
	float GetLifetime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerWeaponRound_Projectile">();
	}
	static class ASpawnerWeaponRound_Projectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpawnerWeaponRound_Projectile>();
	}
};
static_assert(alignof(ASpawnerWeaponRound_Projectile) == 0x000008, "Wrong alignment on ASpawnerWeaponRound_Projectile");
static_assert(sizeof(ASpawnerWeaponRound_Projectile) == 0x000368, "Wrong size on ASpawnerWeaponRound_Projectile");
static_assert(offsetof(ASpawnerWeaponRound_Projectile, MaximumTimeToLive) == 0x0002D8, "Member 'ASpawnerWeaponRound_Projectile::MaximumTimeToLive' has a wrong offset!");
static_assert(offsetof(ASpawnerWeaponRound_Projectile, MovementComponent) == 0x0002E0, "Member 'ASpawnerWeaponRound_Projectile::MovementComponent' has a wrong offset!");
static_assert(offsetof(ASpawnerWeaponRound_Projectile, OnProjectileHit) == 0x0002E8, "Member 'ASpawnerWeaponRound_Projectile::OnProjectileHit' has a wrong offset!");
static_assert(offsetof(ASpawnerWeaponRound_Projectile, CollisionComponent) == 0x0002F8, "Member 'ASpawnerWeaponRound_Projectile::CollisionComponent' has a wrong offset!");
static_assert(offsetof(ASpawnerWeaponRound_Projectile, ImpactForce) == 0x000300, "Member 'ASpawnerWeaponRound_Projectile::ImpactForce' has a wrong offset!");
static_assert(offsetof(ASpawnerWeaponRound_Projectile, Damage) == 0x000304, "Member 'ASpawnerWeaponRound_Projectile::Damage' has a wrong offset!");
static_assert(offsetof(ASpawnerWeaponRound_Projectile, CriticalDamage) == 0x000308, "Member 'ASpawnerWeaponRound_Projectile::CriticalDamage' has a wrong offset!");
static_assert(offsetof(ASpawnerWeaponRound_Projectile, LimbDamage) == 0x00030C, "Member 'ASpawnerWeaponRound_Projectile::LimbDamage' has a wrong offset!");
static_assert(offsetof(ASpawnerWeaponRound_Projectile, bAutoDestroyOnImpact) == 0x000310, "Member 'ASpawnerWeaponRound_Projectile::bAutoDestroyOnImpact' has a wrong offset!");
static_assert(offsetof(ASpawnerWeaponRound_Projectile, bAllowMultipleHits) == 0x000311, "Member 'ASpawnerWeaponRound_Projectile::bAllowMultipleHits' has a wrong offset!");
static_assert(offsetof(ASpawnerWeaponRound_Projectile, MaximumRangeForDamageFalloff) == 0x000314, "Member 'ASpawnerWeaponRound_Projectile::MaximumRangeForDamageFalloff' has a wrong offset!");
static_assert(offsetof(ASpawnerWeaponRound_Projectile, DamageFalloffCurve) == 0x000318, "Member 'ASpawnerWeaponRound_Projectile::DamageFalloffCurve' has a wrong offset!");
static_assert(offsetof(ASpawnerWeaponRound_Projectile, DamageBehaviorName) == 0x000320, "Member 'ASpawnerWeaponRound_Projectile::DamageBehaviorName' has a wrong offset!");
static_assert(offsetof(ASpawnerWeaponRound_Projectile, BalancingName) == 0x000328, "Member 'ASpawnerWeaponRound_Projectile::BalancingName' has a wrong offset!");
static_assert(offsetof(ASpawnerWeaponRound_Projectile, BalancingDataTable) == 0x000330, "Member 'ASpawnerWeaponRound_Projectile::BalancingDataTable' has a wrong offset!");
static_assert(offsetof(ASpawnerWeaponRound_Projectile, bNoRadiusVersusEnvironment) == 0x000338, "Member 'ASpawnerWeaponRound_Projectile::bNoRadiusVersusEnvironment' has a wrong offset!");

// Class DeceiveInc.YumiPassiveAbilityMod1
// 0x0018 (0x0548 - 0x0530)
class AYumiPassiveAbilityMod1 final : public ABaseSpyPassiveAbility
{
public:
	float                                         HealthBuff;                                        // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_534[0x4];                                      // 0x0534(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnModAffectsTool;                                  // 0x0538(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	void HandleEffectNewSource(class AActor* AffectingSource, class AActor* AffectedActor);
	void HandleEffectRemoveSource(class AActor* AffectingSource, class AActor* AffectedActor);
	void HandleEffectStateChange(bool bAffected, class AActor* AffectedActor);
	void HandleMiscToolSpawned(class AActor* SpawnedTool);
	void HandlePlaceableSpawned(class ABasePlaceable* NewPlaceable);
	void HandleSpyToolLoadComplete(class UToolLoadoutComponent* ToolLoadout);
	void NotifyActorAffected_Multicast(class AActor* AffectedActor, bool bAffected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"YumiPassiveAbilityMod1">();
	}
	static class AYumiPassiveAbilityMod1* GetDefaultObj()
	{
		return GetDefaultObjImpl<AYumiPassiveAbilityMod1>();
	}
};
static_assert(alignof(AYumiPassiveAbilityMod1) == 0x000008, "Wrong alignment on AYumiPassiveAbilityMod1");
static_assert(sizeof(AYumiPassiveAbilityMod1) == 0x000548, "Wrong size on AYumiPassiveAbilityMod1");
static_assert(offsetof(AYumiPassiveAbilityMod1, HealthBuff) == 0x000530, "Member 'AYumiPassiveAbilityMod1::HealthBuff' has a wrong offset!");
static_assert(offsetof(AYumiPassiveAbilityMod1, OnModAffectsTool) == 0x000538, "Member 'AYumiPassiveAbilityMod1::OnModAffectsTool' has a wrong offset!");

// Class DeceiveInc.SpawnerWeaponRound_Charge
// 0x0010 (0x0378 - 0x0368)
class ASpawnerWeaponRound_Charge final : public ASpawnerWeaponRound_Projectile
{
public:
	float                                         FullyChargeSpeed;                                  // 0x0368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ChargedDamageBehaviorName;                         // 0x036C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFullyCharged;                                   // 0x0374(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_375[0x3];                                      // 0x0375(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerWeaponRound_Charge">();
	}
	static class ASpawnerWeaponRound_Charge* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpawnerWeaponRound_Charge>();
	}
};
static_assert(alignof(ASpawnerWeaponRound_Charge) == 0x000008, "Wrong alignment on ASpawnerWeaponRound_Charge");
static_assert(sizeof(ASpawnerWeaponRound_Charge) == 0x000378, "Wrong size on ASpawnerWeaponRound_Charge");
static_assert(offsetof(ASpawnerWeaponRound_Charge, FullyChargeSpeed) == 0x000368, "Member 'ASpawnerWeaponRound_Charge::FullyChargeSpeed' has a wrong offset!");
static_assert(offsetof(ASpawnerWeaponRound_Charge, ChargedDamageBehaviorName) == 0x00036C, "Member 'ASpawnerWeaponRound_Charge::ChargedDamageBehaviorName' has a wrong offset!");
static_assert(offsetof(ASpawnerWeaponRound_Charge, bIsFullyCharged) == 0x000374, "Member 'ASpawnerWeaponRound_Charge::bIsFullyCharged' has a wrong offset!");

// Class DeceiveInc.SpawnerWeaponRound_Shield
// 0x0008 (0x02D8 - 0x02D0)
class ASpawnerWeaponRound_Shield final : public ASpawnerWeaponRound
{
public:
	class UHealthComponent*                       HealthComponent;                                   // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerWeaponRound_Shield">();
	}
	static class ASpawnerWeaponRound_Shield* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpawnerWeaponRound_Shield>();
	}
};
static_assert(alignof(ASpawnerWeaponRound_Shield) == 0x000008, "Wrong alignment on ASpawnerWeaponRound_Shield");
static_assert(sizeof(ASpawnerWeaponRound_Shield) == 0x0002D8, "Wrong size on ASpawnerWeaponRound_Shield");
static_assert(offsetof(ASpawnerWeaponRound_Shield, HealthComponent) == 0x0002D0, "Member 'ASpawnerWeaponRound_Shield::HealthComponent' has a wrong offset!");

// Class DeceiveInc.SpecialHitLocationComponent
// 0x0010 (0x0210 - 0x0200)
class USpecialHitLocationComponent final : public USceneComponent
{
public:
	EHitType                                      HitTypeForLocation;                                // 0x01F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UShapeComponent*                        CollisionShape;                                    // 0x0200(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverridesAllHitTypes;                             // 0x0208(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_209[0x7];                                      // 0x0209(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialHitLocationComponent">();
	}
	static class USpecialHitLocationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialHitLocationComponent>();
	}
};
static_assert(alignof(USpecialHitLocationComponent) == 0x000010, "Wrong alignment on USpecialHitLocationComponent");
static_assert(sizeof(USpecialHitLocationComponent) == 0x000210, "Wrong size on USpecialHitLocationComponent");
static_assert(offsetof(USpecialHitLocationComponent, HitTypeForLocation) == 0x0001F8, "Member 'USpecialHitLocationComponent::HitTypeForLocation' has a wrong offset!");
static_assert(offsetof(USpecialHitLocationComponent, CollisionShape) == 0x000200, "Member 'USpecialHitLocationComponent::CollisionShape' has a wrong offset!");
static_assert(offsetof(USpecialHitLocationComponent, bOverridesAllHitTypes) == 0x000208, "Member 'USpecialHitLocationComponent::bOverridesAllHitTypes' has a wrong offset!");

// Class DeceiveInc.SpectatorManager
// 0x0008 (0x0228 - 0x0220)
class ASpectatorManager final : public AActor
{
public:
	class UAutoSpectateAIComponent*               AutoSpectateAI;                                    // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpectatorManager">();
	}
	static class ASpectatorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpectatorManager>();
	}
};
static_assert(alignof(ASpectatorManager) == 0x000008, "Wrong alignment on ASpectatorManager");
static_assert(sizeof(ASpectatorManager) == 0x000228, "Wrong size on ASpectatorManager");
static_assert(offsetof(ASpectatorManager, AutoSpectateAI) == 0x000220, "Member 'ASpectatorManager::AutoSpectateAI' has a wrong offset!");

// Class DeceiveInc.SprayChargeSpawnerWeapon
// 0x0078 (0x0AE0 - 0x0A68)
class ASprayChargeSpawnerWeapon final : public AChargeSpawnerWeapon
{
public:
	FMulticastInlineDelegateProperty_             OnNewChargeLevel;                                  // 0x0A68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A78[0x20];                                     // 0x0A78(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASpawnerWeaponRound*>            SprayProjectiles;                                  // 0x0A98(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bConsumeAmmoForEachSprayShots;                     // 0x0AA8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA9[0x7];                                      // 0x0AA9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSprayChargeLevel>              ChargeLevels;                                      // 0x0AB0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UWeaponSprayDataAsset*                  SprayData;                                         // 0x0AC0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWeaponSprayDataAsset*                  ADSSprayData;                                      // 0x0AC8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprayPlaneDepth;                                   // 0x0AD0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprayPlaneWidth;                                   // 0x0AD4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprayPlaneHeight;                                  // 0x0AD8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ADC[0x4];                                      // 0x0ADC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnSprayImpacts(class AProjectileWeapon* Weapon, const TArray<struct FSprayShotImpact>& Impacts);
	void BP_OnSprayNoDamageImpacts(class AProjectileWeapon* Weapon, const TArray<struct FSprayShotImpact>& Impacts);
	void BP_OnSprayShotFired(const TArray<struct FVector>& ShotEndPoints, class AProjectileWeapon* Weapon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SprayChargeSpawnerWeapon">();
	}
	static class ASprayChargeSpawnerWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASprayChargeSpawnerWeapon>();
	}
};
static_assert(alignof(ASprayChargeSpawnerWeapon) == 0x000008, "Wrong alignment on ASprayChargeSpawnerWeapon");
static_assert(sizeof(ASprayChargeSpawnerWeapon) == 0x000AE0, "Wrong size on ASprayChargeSpawnerWeapon");
static_assert(offsetof(ASprayChargeSpawnerWeapon, OnNewChargeLevel) == 0x000A68, "Member 'ASprayChargeSpawnerWeapon::OnNewChargeLevel' has a wrong offset!");
static_assert(offsetof(ASprayChargeSpawnerWeapon, SprayProjectiles) == 0x000A98, "Member 'ASprayChargeSpawnerWeapon::SprayProjectiles' has a wrong offset!");
static_assert(offsetof(ASprayChargeSpawnerWeapon, bConsumeAmmoForEachSprayShots) == 0x000AA8, "Member 'ASprayChargeSpawnerWeapon::bConsumeAmmoForEachSprayShots' has a wrong offset!");
static_assert(offsetof(ASprayChargeSpawnerWeapon, ChargeLevels) == 0x000AB0, "Member 'ASprayChargeSpawnerWeapon::ChargeLevels' has a wrong offset!");
static_assert(offsetof(ASprayChargeSpawnerWeapon, SprayData) == 0x000AC0, "Member 'ASprayChargeSpawnerWeapon::SprayData' has a wrong offset!");
static_assert(offsetof(ASprayChargeSpawnerWeapon, ADSSprayData) == 0x000AC8, "Member 'ASprayChargeSpawnerWeapon::ADSSprayData' has a wrong offset!");
static_assert(offsetof(ASprayChargeSpawnerWeapon, SprayPlaneDepth) == 0x000AD0, "Member 'ASprayChargeSpawnerWeapon::SprayPlaneDepth' has a wrong offset!");
static_assert(offsetof(ASprayChargeSpawnerWeapon, SprayPlaneWidth) == 0x000AD4, "Member 'ASprayChargeSpawnerWeapon::SprayPlaneWidth' has a wrong offset!");
static_assert(offsetof(ASprayChargeSpawnerWeapon, SprayPlaneHeight) == 0x000AD8, "Member 'ASprayChargeSpawnerWeapon::SprayPlaneHeight' has a wrong offset!");

// Class DeceiveInc.SprayWeapon
// 0x0020 (0x09D8 - 0x09B8)
class ASprayWeapon final : public AHitscanWeapon
{
public:
	class UWeaponSprayDataAsset*                  SprayData;                                         // 0x09B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponSprayDataAsset*                  ADSSprayData;                                      // 0x09C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprayPlaneDepth;                                   // 0x09C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprayPlaneWidth;                                   // 0x09CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprayPlaneHeight;                                  // 0x09D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D4[0x4];                                      // 0x09D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnSprayImpacts(class AProjectileWeapon* Weapon, const TArray<struct FSprayShotImpact>& Impacts);
	void BP_OnSprayNoDamageImpacts(class AProjectileWeapon* Weapon, const TArray<struct FSprayShotImpact>& Impacts);
	void BP_OnSprayShotFired(const TArray<struct FVector>& ShotEndPoints, class AProjectileWeapon* Weapon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SprayWeapon">();
	}
	static class ASprayWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASprayWeapon>();
	}
};
static_assert(alignof(ASprayWeapon) == 0x000008, "Wrong alignment on ASprayWeapon");
static_assert(sizeof(ASprayWeapon) == 0x0009D8, "Wrong size on ASprayWeapon");
static_assert(offsetof(ASprayWeapon, SprayData) == 0x0009B8, "Member 'ASprayWeapon::SprayData' has a wrong offset!");
static_assert(offsetof(ASprayWeapon, ADSSprayData) == 0x0009C0, "Member 'ASprayWeapon::ADSSprayData' has a wrong offset!");
static_assert(offsetof(ASprayWeapon, SprayPlaneDepth) == 0x0009C8, "Member 'ASprayWeapon::SprayPlaneDepth' has a wrong offset!");
static_assert(offsetof(ASprayWeapon, SprayPlaneWidth) == 0x0009CC, "Member 'ASprayWeapon::SprayPlaneWidth' has a wrong offset!");
static_assert(offsetof(ASprayWeapon, SprayPlaneHeight) == 0x0009D0, "Member 'ASprayWeapon::SprayPlaneHeight' has a wrong offset!");

// Class DeceiveInc.Spy
// 0x1190 (0x1650 - 0x04C0)
class ASpy final : public ACharacter
{
public:
	uint8                                         Pad_4B8[0x50];                                     // 0x04B8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnNavModeChanged;                                  // 0x0508(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUndercoverChanged;                               // 0x0518(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyUndercoverChanged;                            // 0x0528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRunningChanged;                                  // 0x0538(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCrouchedChanged;                                 // 0x0548(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCoverDrainChanged;                               // 0x0558(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCoverRatioChanged;                               // 0x0568(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLeftHandFlavorAnimationsAllowedChanged;          // 0x0578(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIgnoreRightArmInHurtAdditiveChanged;             // 0x0588(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCancelLeftHandFlavorAnimations;                  // 0x0598(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlaceableSpawned;                                // 0x05A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMiscToolSpawned;                                 // 0x05B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSwitchTool;                                      // 0x05C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOutOfMimic;                                      // 0x05D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyTransformInMimic;                             // 0x05E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInputBound;                                      // 0x05F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMimicChanged;                                    // 0x0608(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemoveDisguise;                                  // 0x0618(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCoverSwitch;                                     // 0x0628(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVisibilityChanged;                               // 0x0638(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerHUDVisibilityChange;                       // 0x0648(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHipsRotationChanged;                             // 0x0658(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAirborneVerticalAccel;                           // 0x0668(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyGroundStopGoingForward;                       // 0x0678(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyRunningChanged;                               // 0x0688(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLocalSpyMovingChanged;                           // 0x0698(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRelativeGroundMovementChanged;                   // 0x06A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAimPitchChanged;                                 // 0x06B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFactionChanged;                                  // 0x06C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAddVictimEffect;                                 // 0x06D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVictimEffectWidgetReady;                         // 0x06E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVictimEffectWidgetRemoved;                       // 0x06F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemoveVictimEffect;                              // 0x0708(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCoverAffectingSourceChanged;                     // 0x0718(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UZoomComponent*                         ZoomComponent;                                     // 0x0728(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy3DPortrait*                         Spy3DPortrait;                                     // 0x0730(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyDeathEvent;                                   // 0x0738(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyImmediateDeathEvent;                          // 0x0748(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyRevivedEvent;                                 // 0x0758(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnJumpInAnimPlayRateChanged;                       // 0x0768(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAirborneDirectionalTiltChanged;                  // 0x0778(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSetGrabLootAnimationType;                        // 0x0788(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNewDropActorDropped;                             // 0x0798(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyPowerupApplied;                               // 0x07A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyPowerupRemoved;                               // 0x07B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDirectionalDamage3PHurt;                         // 0x07C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyMovementStateChanged;                         // 0x07D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDisarmedChanged;                                 // 0x07E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnKeepRunAdditiveWhileRunningOutOfCoverChange;     // 0x07F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReviveStart;                                     // 0x0808(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReviveCancel;                                    // 0x0818(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReviveComplete;                                  // 0x0828(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyLookAction;                                   // 0x0838(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpySelfBlowActionTriggered;                      // 0x0848(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHackedIntel;                                     // 0x0858(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponShot;                                      // 0x0868(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_878[0x20];                                     // 0x0878(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSpyJumpEvent;                                    // 0x0898(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A8[0x18];                                     // 0x08A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UClass*, struct FDroppedInvCacheEntry> DroppedItemCache;                                  // 0x08C0(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_910[0x10];                                     // 0x0910(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AExtractionInteractableActor*           ExtractZone;                                       // 0x0920(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyExtractZoneChanged;                           // 0x0928(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyExtractZoneBlocking;                          // 0x0938(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDisguiseReplicationData               DisguiseData;                                      // 0x0948(0x0010)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   MainToolAttachmentPointName;                       // 0x0958(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   SpyPlayerHudAsset;                                 // 0x0960(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 DirectionalDamageHudAssetHolder;                   // 0x0988(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHideReticleInADS;                                 // 0x0990(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_991[0x3];                                      // 0x0991(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeToRecoverIdling;                               // 0x0994(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToRecoverWalking;                              // 0x0998(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToRecoverRunning;                              // 0x099C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeBeforeStartingRecover;                         // 0x09A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToRecoverInCoverIdling;                        // 0x09A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToRecoverInCoverWalking;                       // 0x09A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToRecoverInCoverRunning;                       // 0x09AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECoverAffectingSourceType                     SecurityCoverAffectingType;                        // 0x09B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECoverAffectingSourceType                     EMPCoverAffectingType;                             // 0x09B1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9B2[0x2];                                      // 0x09B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutOfCoverStrafeWalkSpeedMultiplier;               // 0x09B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeLoseCoverFromScolded;                          // 0x09B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeLoseCoverFromGuardAggro;                       // 0x09BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           BreadcrumbsClass;                                  // 0x09C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         BreadcrumbLifetime;                                // 0x09D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxSpawnedBreadcrumbs;                             // 0x09D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraHeightOffset;                                // 0x09D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrouchCameraHeightExtraOffset;                     // 0x09DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRecoilData                            FrontHurtRecoil;                                   // 0x09E0(0x0030)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRecoilData                            BackHurtRecoil;                                    // 0x0A10(0x0030)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRollKickData                          SideHurtRollKick;                                  // 0x0A40(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            HurtDamageRatioCurve;                              // 0x0A58(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HurtRecoilLowDamageRatio;                          // 0x0A60(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HurtRecoilLowDamageDurationRatio;                  // 0x0A64(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HurtRecoilLowDamage;                               // 0x0A68(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HurtRecoilHighDamage;                              // 0x0A6C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HurtRecoilDelay;                                   // 0x0A70(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A74[0xC];                                      // 0x0A74(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlockShootingAfterRunDuration;                     // 0x0A80(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlockRunAfterShootDuration;                        // 0x0A84(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A88[0x4];                                      // 0x0A88(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrouchCameraHeightInterpolationTime;               // 0x0A8C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              CustomSkin_1P_Class;                               // 0x0A90(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              CustomSkin_3P_Class;                               // 0x0A98(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASpy*                                   BouncedBySpy;                                      // 0x0AA0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ABaseBreadcrumbsActor*>          ActiveBreadcrumbsActor;                            // 0x0AA8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FPrecacheBreadcrumb>            BreadcrumbsActorCache;                             // 0x0AB8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<ESecurityLevel, class UClass*>           BreadcrumbsClassHolderMap;                         // 0x0AC8(0x0050)(Protected, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 Mesh1P;                                            // 0x0B18(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 Mesh3P;                                            // 0x0B20(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpringArmComponent*                    SpringArm1P;                                       // 0x0B28(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       Camera1P;                                          // 0x0B30(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       Camera3P;                                          // 0x0B38(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpringArmComponent*                    SpringArm3P;                                       // 0x0B40(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHealthComponent*                       HealthComponent;                                   // 0x0B48(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UToolLoadoutComponent*                  LoadoutComponent;                                  // 0x0B50(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayResourcesComponent*            GameplayResourcesComponent;                        // 0x0B58(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActorAffectedComponent*                EMPAffectedComponent;                              // 0x0B60(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActorAffectedComponent*                ScramblerAffectedComponent;                        // 0x0B68(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteracterComponent*                   InteracterComponent;                               // 0x0B70(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerNameWidgetComponent*             PlayerNameComponent2;                              // 0x0B78(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPointOfInterestComponent*              PointOfInterestCamera1P;                           // 0x0B80(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPointOfInterestComponent*              PointOfInterest3PHead;                             // 0x0B88(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFallDamageComponent*                   FallDamageComponent;                               // 0x0B90(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNavModeItemComponent*                  NavModeItemComponent;                              // 0x0B98(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDamageType>                FallDamageType;                                    // 0x0BA0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDisguiseShieldComponent*               DisguiseShieldComponent;                           // 0x0BA8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USway1PComponent*                       Sway1PComponent;                                   // 0x0BB0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshComponent*                         Weapon1PMesh;                                      // 0x0BB8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshComponent*                         Weapon3PMesh;                                      // 0x0BC0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShapeComponent*                        PlayerFlagCollision;                               // 0x0BC8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       RegistrationCollisionShapeComp;                    // 0x0BD0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 InteractableComp;                                  // 0x0BD8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UReviveSpyConditionComponent*           ReviveSpyCondition;                                // 0x0BE0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URayCastConditionComponent*             RayCastCondition;                                  // 0x0BE8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USBAimAssistTargetComponent*            AimAssistTargetComp;                               // 0x0BF0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USweetPawnAudioComponent*               PawnAudioComponent;                                // 0x0BF8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReviveHealth;                                      // 0x0C00(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ReviveAmmoPackCount;                               // 0x0C04(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReviveRegainCover;                                // 0x0C08(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractableType                             InteractableType;                                  // 0x0C09(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0A[0x6];                                      // 0x0C0A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SpyBurnedTooltip;                                  // 0x0C10(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ReviveSpyTooltip;                                  // 0x0C28(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         MaxAmmoBoxDrop;                                    // 0x0C40(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeathAmmoLostRatio;                                // 0x0C44(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 Watch1P;                                           // 0x0C48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 Watch3P;                                           // 0x0C50(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     Watch1PClass;                                      // 0x0C58(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     Watch3PClass;                                      // 0x0C60(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APoudrierActor*                         Poudrier1P;                                        // 0x0C68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APoudrierActor*                         Poudrier3P;                                        // 0x0C70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   PoudrierMesh1PClass;                               // 0x0C78(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   PoudrierMesh3PClass;                               // 0x0CA0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              Poudrier_Anim_1P_Class;                            // 0x0CC8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              Poudrier_Anim_3P_Class;                            // 0x0CD0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WatchAttachmentPointName;                          // 0x0CD8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   SpyPortrait3DClass;                                // 0x0CE0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseSpyTool*                           CurrentActiveTool;                                 // 0x0D08(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseMeleeAttack*                       CurrentMeleeAttack;                                // 0x0D10(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            PlayerHud;                                         // 0x0D18(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AActor*, int32>                    HideHudRequest;                                    // 0x0D20(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<class UVictimEffectUserWidget*>        VictimEffectsHuds;                                 // 0x0D70(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UMeshComponent*>                 AlwaysVisibleMeshs;                                // 0x0D80(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         CoverRatio;                                        // 0x0D90(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WalkingSpeed;                                      // 0x0D94(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrouchingSpeed;                                    // 0x0D98(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlowPercent;                                       // 0x0D9C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoverDrainSpeed;                                   // 0x0DA0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESpySecurityState                             SecurityState;                                     // 0x0DA4(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DA5[0x3];                                      // 0x0DA5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUndercoverReplicationData             UndercoverReplicationData;                         // 0x0DA8(0x0008)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_DB0[0x8];                                      // 0x0DB0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecoverReduction;                                  // 0x0DB8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FControlledByDisguiseData              ControlledByDisguise;                              // 0x0DBC(0x001C)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_DD8[0x8];                                      // 0x0DD8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAgentData*                             AgentData;                                         // 0x0DE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADrone>                  ControlledDrone;                                   // 0x0DE8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseMimicScannableActor*               MimicActor;                                        // 0x0DF0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnInstantLoseAggroFromBots;                        // 0x0DF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FHeatSetupData                         HeatSetup;                                         // 0x0E08(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FHeatStateData                         HeatState;                                         // 0x0E58(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E60[0x20];                                     // 0x0E60(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AVictimEffect*>                  CurrentHeatPenalities;                             // 0x0E80(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnHeatLevelChanged;                                // 0x0E90(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnHeatValueChanged;                                // 0x0EA0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseOldHeatSystem;                                 // 0x0EB0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EB1[0x3];                                      // 0x0EB1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StaminaMax;                                        // 0x0EB4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EB8[0x4];                                      // 0x0EB8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StaminaCurrent;                                    // 0x0EBC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC0[0x4];                                      // 0x0EC0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StaminaDrainRate;                                  // 0x0EC4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaRegainRate;                                 // 0x0EC8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaminaDrainRateMultiplier;                        // 0x0ECC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ED0[0x8];                                      // 0x0ED0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SusCheckSeenByNPCDistanceSQ;                       // 0x0ED8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SusEnableNPCCheck;                                 // 0x0EDC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSuspicious;                                     // 0x0EDD(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EDE[0x2];                                      // 0x0EDE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStaminaChanged;                                  // 0x0EE0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnSuspiciousChanged;                               // 0x0EF0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	bool                                          bResetStamOnCoverChange;                           // 0x0F00(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bResetStamOnCoverLoss;                             // 0x0F01(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNoStamTickOutOfCover;                             // 0x0F02(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSusOnlyDrainUndercover;                           // 0x0F03(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SusFlushOnCoverBlowRatio;                          // 0x0F04(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowHealingConsumableInMimic;                    // 0x0F08(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowHealingConsumableWhenImmaterial;             // 0x0F09(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowHealingConsumableWhenHidden;                 // 0x0F0A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0B[0x5];                                      // 0x0F0B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHealthConsumableEvent;                           // 0x0F10(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F20[0xC];                                      // 0x0F20(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBetweenCOnsumable;                            // 0x0F2C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F30[0x6];                                      // 0x0F30(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	ESpyHealthConsumableEvent                     LastHealthEvent;                                   // 0x0F36(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F37[0x1];                                      // 0x0F37(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   PingClass;                                         // 0x0F38(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F60[0x8];                                      // 0x0F60(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 PingClassHolder;                                   // 0x0F68(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASpyPing*                               ActivePing;                                        // 0x0F70(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InputContextPriority;                              // 0x0F78(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseTurnRate;                                      // 0x0F7C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseLookUpRate;                                    // 0x0F80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PingInputHoldMinTime;                              // 0x0F84(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDIMenuUserWidget>          PingSelectionMenuClass;                            // 0x0F88(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PingSelectionHudName;                              // 0x0F90(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDIMenuUserWidget*                      PingActiveMenu;                                    // 0x0F98(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FA0[0x18];                                     // 0x0FA0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 PingedActor;                                       // 0x0FB8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UrgentPingDoubleClick;                             // 0x0FC0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FC4[0x1C];                                     // 0x0FC4(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLastInteractionData                   KillerData;                                        // 0x0FE0(0x0010)(Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         SecurityFlags;                                     // 0x0FF0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScoldTimeoutDelay;                                 // 0x0FF4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InvestigatedTimeoutDelay;                          // 0x0FF8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GuardAgrroTimeoutDelay;                            // 0x0FFC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1000[0x60];                                    // 0x1000(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AActor*, float>                    RunSpeedSource;                                    // 0x1060(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_10B0[0x10];                                    // 0x10B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecoverDelay;                                      // 0x10C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C4[0x4];                                     // 0x10C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   WatchMesh1P;                                       // 0x10C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   WatchMesh3P;                                       // 0x10D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10D8[0x18];                                    // 0x10D8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnRoomStatusChanged;                               // 0x10F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMap<class AActor*, float>                    SlowSources;                                       // 0x1100(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class AActor*, float>                    CoverDrainSources;                                 // 0x1150(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<ECoverAffectingSourceType, struct FCoverSourceInfo> CoverAffectingSources;                             // 0x11A0(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         JumpDisablingSource;                               // 0x11F0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         MovementDisablingSource;                           // 0x1200(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         RunDisablingSource;                                // 0x1210(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         SpeedBoostDisablingSource;                         // 0x1220(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         CameraMovementLockSource;                          // 0x1230(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class AActor*, int32>                    InputDisablingRequest;                             // 0x1240(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<class UMeshComponent*>                 Extra3PMeshes;                                     // 0x1290(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UMeshComponent*>                 Extra1PMeshes;                                     // 0x12A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class AActor*>              AnimationProps1P;                                  // 0x12B0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class AActor*>              AnimationProps3P;                                  // 0x1300(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1350[0x19];                                    // 0x1350(0x0019)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInVault;                                          // 0x1369(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_136A[0x12];                                    // 0x136A(0x0012)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInPregameLobby;                                   // 0x137C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_137D[0x1];                                     // 0x137D(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsBot;                                            // 0x137E(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_137F[0x8];                                     // 0x137F(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWeaponDisabled;                                   // 0x1387(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1388[0x14];                                    // 0x1388(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsImmaterial;                                     // 0x139C(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHidden;                                         // 0x139D(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_139E[0x86];                                    // 0x139E(0x0086)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DeadCount;                                         // 0x1424(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1428[0xC4];                                    // 0x1428(0x00C4)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AwardKillDelay;                                    // 0x14EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14F0[0x24];                                    // 0x14F0(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaximumRunAngle;                                   // 0x1514(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InactiveRunToggleResetTime;                        // 0x1518(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeathCameraObstructionInterpolationDuration;       // 0x151C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeathCameraObstructionWantedHeight;                // 0x1520(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1524[0x4];                                     // 0x1524(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   SpyDeathVictimEffectClass;                         // 0x1528(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AVictimEffect*                          SpyDeathVictimEffect;                              // 0x1550(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1558[0x8];                                     // 0x1558(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJumpFatigueSetting>            JumpFatigueSettings;                               // 0x1560(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         JumpFatigueDecay;                                  // 0x1570(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1574[0xC];                                     // 0x1574(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrouchFatigueSetting>          CrouchFatigueSettings;                             // 0x1580(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         CrouchFatigueDecay;                                // 0x1590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1594[0xC];                                     // 0x1594(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class AVictimEffect*                          SocialBatteryHealing;                              // 0x15A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADIPlayerState*                         CachedDIPlayerState;                               // 0x15A8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APopulationManager*                     PopMan;                                            // 0x15B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15B8[0x8];                                     // 0x15B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextRenderComponent*                   DebugTextRenderComponent;                          // 0x15C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActorComponent*                        CheatsComponent;                                   // 0x15C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheatDisableCover;                                // 0x15D0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15D1[0xF];                                     // 0x15D1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         InteractsInRange;                                  // 0x15E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_15F0[0x20];                                    // 0x15F0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHideLocalWidget;                                 // 0x1610(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CheatTraceClass;                                   // 0x1620(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1648[0x8];                                     // 0x1648(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAlwaysVisibleMesh(class UMeshComponent* InMesh);
	void AddCoverAffectingSource(class AActor* NewCoverDrainSource, ECoverAffectingSourceType NewCoverAffectingType);
	void AddCoverDrainSource(class AActor* NewCoverDrainSource, float NewCoverDrain);
	void AddEffectFromNPC(class AVictimEffect* InNewEffect);
	void AddRecoverReduction(float Reduction);
	void AddRunSpeedFactor(float InNewSpeedFactor, class AActor* Source);
	void AddSlowSource(class AActor* NewSlowSource, float NewSlowPercent);
	void AllowActiveAbility(bool bAllow);
	void AllowCover(bool bAllow);
	void AllowMelee(bool bAllow);
	void AllowNavMode(bool bAllow);
	void AllowWeapon(bool bAllow);
	void AttachCurrentToolToMainAttachment();
	void AttachCurrentToolToSocket(class FName SocketName);
	void AttachToolToMainAttachment(class ABaseSpyTool* ToolToAttatch);
	void AttachToolToMeshOnAlternateBone(class USkeletalMeshComponent* TargetMesh, class FName BoneName);
	bool AuthExternalBlowCover(class AController* InstigatedByIn, class AActor* BlowCoverSourceActor);
	void BlockToolActions(bool bBlock);
	void BP_BlockLeftHandFlavorAnimations(bool bBlock, EBlockLeftHandFavorAnimationsBlueprintType FlagIn);
	void BP_CancelHealingConsumable();
	bool BP_DebugGetShowRoomName();
	bool BP_GetCheatHideHuds();
	void BP_OnBounce();
	void BP_OnCoverBlown();
	void BP_OnCoverRatioUpdate(float NewRatio);
	void BP_OnCoverRegained();
	void BP_OnCoverSwitched(class ANPCCharacter* NewDisguise, bool bIsFirstDisguise, bool bShowFeedback);
	void BP_OnCoverSwitchedVisualFeedback(class ANPCCharacter* NewDisguise);
	void BP_OnHealthConsumableEvent(ESpyHealthConsumableEvent Event);
	void BP_OnHudLoaded(class UUserWidget* HUD);
	void BP_OnIntroCoverRegained();
	void BP_OnLocalFallLand(int32 FallStep, int32 FallDamageAmount);
	void BP_OnServerBeginPlay();
	void BP_OnSpyDisappear();
	void BP_OnStartUsingFirstAid();
	void BP_OnStopUsingFirstAid();
	void BPSetWantedHeatLevel(int32 Level);
	void CancelLeftHandFlavorAnimations();
	bool CanUseHealingConsumable();
	void Client_ObjectiveCarriedByYourTeam(bool bYourFactionHasObjective);
	void Client_ObjectiveDistanceProximityLevelChanged(uint8 NewLevel);
	void Client_OnConfirmDamageDealt(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, bool bIsDead);
	void Client_OnFallLand(int32 FallStep, int32 FallDamageAmount);
	void Client_OnStartNPCInteract(class UNPCInteraction* InteractIn);
	class AActor* CreateAnimationProp(class FName NameID, TSubclassOf<class AActor> ActorToCreate, class FName AttachSocket, bool bFirstPerson);
	void DecrementHeat(int32 Decrement);
	void DestroyAnimationProp(class FName NameID, bool bFirstPerson);
	void DisableBlockRun(bool bDisable);
	void DisableRun(class AActor* Source, bool bDisableRun);
	void ExternalBounce(const struct FVector& ImpulseToApply, class AActor* BouncedBy);
	void ExternalServerCompleteInteraction(class UInteractableComponent* InteractableComp_0);
	void ExtractSetBlockingPlayer_Client(bool bBlocking);
	void ExtractSetuptExtractZone_Client(class AExtractionInteractableActor* Extract);
	void Force3rdPersonView(bool b3PForced);
	void ForceKillcamRevive();
	class AActor* GetAnimationProp(class FName NameID, bool bFirstPerson);
	int32 GetCurrentHeatLevel();
	int32 GetCurrentHeatValue();
	class ADeceiveIncPlayerController* GetDIPlayerController();
	class UUserWidget* GetPlayerHud();
	void GetPowerupLevel(EPowerupType Powerup, ESecurityLevel* Level, bool* bAvailable);
	TArray<class AVictimEffect*> GetSpyActiveEffectsOfClass(class UClass* EffectClass);
	void HandleActiveAbilityLoadComplete(class ABaseSpyTool* NewActiveAbility);
	void HandleActiveHandToolEvent(ESpyToolEvent EventType, class ABaseSpyTool* SpyTool);
	void HandleBooleanPlayerSettingChange(EPlayerSettingsType SettingType, bool NewValue);
	void HandleCallingCardToolFullThrowEnd();
	void HandleDeath(class AActor* DeadActor);
	void HandleEMPIsAffectedChanged(bool bIsAffected, class AActor* AffectedActor);
	void HandleFloatPlayerSettingChange(EPlayerSettingsType SettingType, float NewValue);
	void HandleHealthChanged(class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, float RawDamage);
	void HandleInstigateZeroDamage(class UHealthComponent* OwningHealthComp, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);
	void HandleInteractableCompCancel(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void HandleInteractableCompStart(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void HandleIntPlayerSettingChange(EPlayerSettingsType SettingType, int32 NewValue);
	void HandleLoadoutSpawnCompleteEvent(class UToolLoadoutComponent* ToolLoadout);
	void HandleLocalInteractionCanceled(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void HandleLocalInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void HandleLocalInteractionStart(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void HandleLocalResourceAmountChanged(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 AmountDelta);
	void HandleMeleeAttackLoadComplete(class ABaseSpyTool* NewMeleeAttack);
	void HandleNewRadialMenuPingSelection(int32 Index_0);
	void HandleOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
	void HandleOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);
	void HandleResourceNewAmount(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 Amount);
	void HandleResultScreenStart(class UResultScreenPhaseInfo* PhaseInfo);
	void HandleRevive(class AActor* RevivedActor);
	void HandleScramblerAffectingSourceRegister(class AActor* AffectingSource, class AActor* AffectedActor);
	void HandleScramblerAffectingSourceUnregister(class AActor* AffectingSource, class AActor* AffectedActor);
	void HandleScramblerIsAffectedChanged(bool bIsAffected, class AActor* AffectedActor);
	void HandleSelectedToolChangeLoadoutEvent(class ABaseSpyTool* NewToolInHand, ELoadoutSlot NewSelectedSlot);
	void HandleSpyToolLoadComplete(class ABaseSpyTool* SpyTool);
	void HandleTakePointDamage(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& ShotFromDirection, const class UDamageType* DamageType, class AActor* DamageCauser);
	void HandleWeaponHitConfirmed(const struct FHitConfirmData& HitConfirmedData);
	void HandleWeaponProjectileImpact(const struct FWeaponImpactData& WeaponImpactData);
	void HeatTriggerNPCHit(int32 NPCSecurityIndex, float DamageRatio, bool bNpcKilled);
	void HidePlayerHud(class AActor* Requester);
	void HideToolsHud();
	void IncrementHeat(int32 Increment);
	void IncrementStamina(float Delta);
	bool IsScolded();
	bool IsTeamAlive();
	void KeepRunAdditiveWhileRunningOutOfCover(bool bKeepAdditive);
	void MakeSpyAndDisguiseInvisible(bool bInvisible);
	void NetMulticast_DirectionalDamageReceived(float Damage, const struct FVector_NetQuantize& ShotFromDirection, EHitType HitType);
	void NetMulticast_ForceOutOfMimic();
	void NetMulticast_TriggerChangeDisguiseVisualFeedback(class ANPCCharacter* NewDisguise);
	void NotifyAnimationStateJumpInChange(bool bJumpInStart);
	void OnADSChanged(bool bADS);
	void OnAffectingSourceRegister(class AActor* AffectingSource, class AActor* AffectedActor);
	void OnAffectingSourceUnregister(class AActor* AffectingSource, class AActor* AffectedActor);
	void OnAwardKillTimerEnd();
	void OnBlockRunAfterShootingTimerEnd();
	void OnBlockShootingAfterRunTimerEnd();
	void OnCheatToggleAutoShootForeverTimerEnd();
	void OnConfirmedDamageDealt__DelegateSignature(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);
	void OnDelayed3PTimerEnd();
	void OnHealthConsumableDisableCompleted();
	void OnIntroPhaseStart(class UIntroPhaseInfo* PhaseInfo);
	void OnMeleeImpact(class AActor* Victim, const struct FVector& ImpactPoint, int32 ChargeLevel, float Damage, float ResultingHealthPercentage, EHitType HitType, const struct FMeleeHitConfirmedData& HitConfirmedData);
	void OnNewActiveCameraEvent(class UObject* NewActiveCamera, ECameraPriority NewCameraPriority);
	void OnNewHighestWeightCameraEvent(class UObject* NewActiveCamera, ECameraPriority NewCameraPriority);
	void OnPowerupStateChangedClient(EPowerupType PowerupType, ESecurityLevel PowerupLevel, bool bAdded);
	void OnPowerupStateChangedServer(EPowerupType PowerupType, ESecurityLevel PowerupLevel, bool bAdded);
	void OnRep_CachedDIPlayerState();
	void OnRep_ControlledByDisguise(const struct FControlledByDisguiseData& PrevControlledByDisguiseData);
	void OnRep_CoverDrainSpeed(float OldCoverDrain);
	void OnRep_CoverRatio(float PreviousCoverRatio);
	void OnRep_CrouchingSpeed(float PreviousCrouchingSpeed);
	void OnRep_Disguise(const struct FDisguiseReplicationData& PreviousDisguiseData);
	void OnRep_HeatInfo(const struct FHeatStateData& OldState);
	void OnRep_Hidden();
	void OnRep_Imaterial();
	void OnRep_InVault();
	void OnRep_IsBot();
	void OnRep_IsSuspicious();
	void OnRep_LastHealthEvent();
	void OnRep_NewMimic();
	void OnRep_SecurityState(ESpySecurityState PreviousSecurityState);
	void OnRep_SlowPercent();
	void OnRep_StaminaChanged();
	void OnRep_UndercoverReplicationData(const struct FUndercoverReplicationData& PreviousUndercoverReplicationData);
	void OnRep_WalkingSpeed(float PreviousWalkingSpeed);
	void OnSuspiciousForBotsTimerEnd();
	void OnValidateBlowCoverOnClientTimerEnd();
	void OnWeaponProjectileImpact__DelegateSignature(class ADeceiveIncPlayerController* PlayerController, class ASpy* Spy, class AActor* Victim, const struct FVector& ImpactPoint, const struct FVector& ImpactDirection, const struct FVector& ImpactNormal, class AProjectileWeapon* Weapon);
	void PrepareForIntro();
	void ReduceStamina(float Delta);
	void RemoveAlwaysVisibleMesh(class UMeshComponent* InMesh);
	void RemoveCoverAffectingSource(class AActor* NewCoverDrainSource, ECoverAffectingSourceType NewCoverAffectingType);
	void RemoveCoverDrainSource(class AActor* CoverDrainSourceToRemove);
	void RemoveEffectFromNPC(class AVictimEffect* InNewEffect);
	void RemoveRecoverReduction(float Reduction);
	void RemoveRunSpeedFactor(class AActor* Source);
	void RemoveSlowSource(class AActor* SlowSourceToRemove);
	void ResetAttachToolToMesh(class USkeletalMeshComponent* TargetMesh);
	void ResetStaminaToMax();
	void Server_ExitNPCInteract(bool bInstant);
	void Server_ForceOutOfMimic();
	void Server_SetCrouchingSpeed(float NewCrouchingSpeed);
	void Server_SetWalkingSpeed(float NewWalkingSpeed);
	void Server_SpawnPing(const struct FVector_NetQuantize& Position, class AActor* TargetActor, bool bUrgent, int32 RadialPingIndex);
	void SetHandToolVisibilityFromAnimation(bool bVisible, bool bFirstPerson);
	void SetHandToolVisibilityFromAnimationFlag(EHandToolVisibilityFromAnimationFlag FlagIn, bool bVisible, bool bFirstPerson);
	void SetHandToolVisibilityFromAnimationFlag1PAnd3P(EHandToolVisibilityFromAnimationFlag FlagIn, bool bVisible);
	void SetIsHidden(bool bNewHiddenState, bool bBlockShooting);
	void SetIsImmaterial(bool bNewImaterialState, bool bBlockShooting);
	void SetJumpInAnimationSequence(class UAnimSequence* JumpInAnim);
	void SetRunDrainEnabled(bool bEnabled);
	void SetSecondaryHandToolVisibilityFromAnimation(bool bVisible, bool bFirstPerson);
	void SetupHeat(const struct FHeatSetupData& NewHeatSetup);
	void SetWeapon1PMesh(class UMeshComponent* WeaponMesh);
	void SetWeapon3PMesh(class UMeshComponent* WeaponMesh);
	void ShowPlayerHud(class AActor* Requester);
	void ShowToolsHud();
	bool TestOcclusionCollisionOfJointFromLocalCamera(class FName JointName);
	void TriggerHealthConsumableEvent(ESpyHealthConsumableEvent Event);
	void TriggerHealthConsumableEventServer(ESpyHealthConsumableEvent Event);

	bool AreLeftHandFlavorAnimationsAllowed() const;
	bool CanBeRevive() const;
	class ABaseSpyActiveAbility* GetActiveAbilityTool() const;
	class UAgentExpertiseSkillData* GetAgentExpertiseSkillData() const;
	int32 GetAgentExpertiseVariantIndex() const;
	class UAgentPassiveSkillData* GetAgentPassiveSkillData() const;
	int32 GetAgentPassiveVariantIndex() const;
	class UAgentWeaponData* GetAgentWeaponData() const;
	int32 GetAgentWeaponVariantIndex() const;
	float GetCoverRatio() const;
	class USkeletalMeshComponent* GetCurrentActiveMesh() const;
	class ALevelArea* GetCurrentArea() const;
	float GetCurrentHeading() const;
	class ARoomVolume* GetCurrentRoom() const;
	float GetCurrentStaminaRatio() const;
	class ABaseSpyTool* GetCurrentTool() const;
	class ADIPlayerState* GetDIPlayerState() const;
	class ANPCCharacter* GetDisguise() const;
	class AVictimEffect* GetEffectOfClass(class UClass* EffectClass) const;
	uint8 GetFactionId() const;
	struct FVector GetFeetLevelPos() const;
	EInteractableType GetInteractableType() const;
	struct FLastInteractionData GetKillerData() const;
	class UToolLoadoutComponent* GetLoadoutComponent() const;
	class USkeletalMeshComponent* GetMesh1P() const;
	class USkeletalMeshComponent* GetMesh3P() const;
	float GetOutOfCoverTime() const;
	class ABaseSpyPassiveAbility* GetPassiveAbilityTool() const;
	class FString GetPlayerName() const;
	EPlatformType GetPlayerPlatformType() const;
	float GetPreviousFrameCoverRatio() const;
	bool GetRunDrainCanTrigger() const;
	bool GetRunDrainEnabled() const;
	class UAgentSkinData* GetSkinData() const;
	float GetSlowPercent() const;
	TArray<class AVictimEffect*> GetSpyActiveEffects() const;
	class ABaseSpyTool* GetToolInSlot(ELoadoutSlot ToolSlot) const;
	float GetViewPitch() const;
	class UMeshComponent* GetWeapon1PMesh() const;
	class UMeshComponent* GetWeapon3PMesh() const;
	class ABaseSpyWeapon* GetWeaponTool() const;
	bool IsBot() const;
	bool IsBurned() const;
	bool IsCharmRecover() const;
	bool IsDead() const;
	bool IsDisarmed() const;
	bool IsDisguiseVisible() const;
	bool IsEnemyCharmRecover() const;
	bool IsFalling() const;
	bool IsFriendlyCharmRecover() const;
	bool IsHidden() const;
	bool IsHidingReticleInADS() const;
	bool IsImmaterial() const;
	bool IsImmaterialOrHidden() const;
	bool IsInADS() const;
	bool IsInMimic() const;
	bool IsInNavMode() const;
	bool IsInVault() const;
	bool IsJumpDisabled() const;
	bool IsKeepRunAdditiveWhileRunningOutOfCover() const;
	bool IsKillcamViewTarget() const;
	bool IsLastCoverBlowSelfInstigated() const;
	bool IsLocalOrKillcamViewTarget() const;
	bool IsLocalSpy() const;
	bool IsMovementDisabled() const;
	bool IsPlayerHudVisible() const;
	bool IsRunBlocked() const;
	bool IsRunDisabled() const;
	bool IsRunning() const;
	bool IsSameFactionAsLocalPlayer() const;
	bool IsShootingBlocked() const;
	bool IsSilenced() const;
	bool IsSpeedBoostDisabled() const;
	bool IsSpyAndDisguiseInvisible() const;
	bool IsSpyPlayer() const;
	bool IsSpyPoisoned() const;
	bool IsSpyRunning() const;
	bool IsSpyVisibleToOthers() const;
	bool IsSuspicious() const;
	bool IsTransformingOrInMimic() const;
	bool IsTryingToRun() const;
	bool IsUndercover() const;
	bool IsViewIn1P() const;
	bool ShouldBeUndercover() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Spy">();
	}
	static class ASpy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpy>();
	}
};
static_assert(alignof(ASpy) == 0x000010, "Wrong alignment on ASpy");
static_assert(sizeof(ASpy) == 0x001650, "Wrong size on ASpy");
static_assert(offsetof(ASpy, OnNavModeChanged) == 0x000508, "Member 'ASpy::OnNavModeChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnUndercoverChanged) == 0x000518, "Member 'ASpy::OnUndercoverChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnSpyUndercoverChanged) == 0x000528, "Member 'ASpy::OnSpyUndercoverChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnRunningChanged) == 0x000538, "Member 'ASpy::OnRunningChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnCrouchedChanged) == 0x000548, "Member 'ASpy::OnCrouchedChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnCoverDrainChanged) == 0x000558, "Member 'ASpy::OnCoverDrainChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnCoverRatioChanged) == 0x000568, "Member 'ASpy::OnCoverRatioChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnLeftHandFlavorAnimationsAllowedChanged) == 0x000578, "Member 'ASpy::OnLeftHandFlavorAnimationsAllowedChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnIgnoreRightArmInHurtAdditiveChanged) == 0x000588, "Member 'ASpy::OnIgnoreRightArmInHurtAdditiveChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnCancelLeftHandFlavorAnimations) == 0x000598, "Member 'ASpy::OnCancelLeftHandFlavorAnimations' has a wrong offset!");
static_assert(offsetof(ASpy, OnPlaceableSpawned) == 0x0005A8, "Member 'ASpy::OnPlaceableSpawned' has a wrong offset!");
static_assert(offsetof(ASpy, OnMiscToolSpawned) == 0x0005B8, "Member 'ASpy::OnMiscToolSpawned' has a wrong offset!");
static_assert(offsetof(ASpy, OnSwitchTool) == 0x0005C8, "Member 'ASpy::OnSwitchTool' has a wrong offset!");
static_assert(offsetof(ASpy, OnOutOfMimic) == 0x0005D8, "Member 'ASpy::OnOutOfMimic' has a wrong offset!");
static_assert(offsetof(ASpy, OnSpyTransformInMimic) == 0x0005E8, "Member 'ASpy::OnSpyTransformInMimic' has a wrong offset!");
static_assert(offsetof(ASpy, OnInputBound) == 0x0005F8, "Member 'ASpy::OnInputBound' has a wrong offset!");
static_assert(offsetof(ASpy, OnMimicChanged) == 0x000608, "Member 'ASpy::OnMimicChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnRemoveDisguise) == 0x000618, "Member 'ASpy::OnRemoveDisguise' has a wrong offset!");
static_assert(offsetof(ASpy, OnCoverSwitch) == 0x000628, "Member 'ASpy::OnCoverSwitch' has a wrong offset!");
static_assert(offsetof(ASpy, OnVisibilityChanged) == 0x000638, "Member 'ASpy::OnVisibilityChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnPlayerHUDVisibilityChange) == 0x000648, "Member 'ASpy::OnPlayerHUDVisibilityChange' has a wrong offset!");
static_assert(offsetof(ASpy, OnHipsRotationChanged) == 0x000658, "Member 'ASpy::OnHipsRotationChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnAirborneVerticalAccel) == 0x000668, "Member 'ASpy::OnAirborneVerticalAccel' has a wrong offset!");
static_assert(offsetof(ASpy, OnSpyGroundStopGoingForward) == 0x000678, "Member 'ASpy::OnSpyGroundStopGoingForward' has a wrong offset!");
static_assert(offsetof(ASpy, OnSpyRunningChanged) == 0x000688, "Member 'ASpy::OnSpyRunningChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnLocalSpyMovingChanged) == 0x000698, "Member 'ASpy::OnLocalSpyMovingChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnRelativeGroundMovementChanged) == 0x0006A8, "Member 'ASpy::OnRelativeGroundMovementChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnAimPitchChanged) == 0x0006B8, "Member 'ASpy::OnAimPitchChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnFactionChanged) == 0x0006C8, "Member 'ASpy::OnFactionChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnAddVictimEffect) == 0x0006D8, "Member 'ASpy::OnAddVictimEffect' has a wrong offset!");
static_assert(offsetof(ASpy, OnVictimEffectWidgetReady) == 0x0006E8, "Member 'ASpy::OnVictimEffectWidgetReady' has a wrong offset!");
static_assert(offsetof(ASpy, OnVictimEffectWidgetRemoved) == 0x0006F8, "Member 'ASpy::OnVictimEffectWidgetRemoved' has a wrong offset!");
static_assert(offsetof(ASpy, OnRemoveVictimEffect) == 0x000708, "Member 'ASpy::OnRemoveVictimEffect' has a wrong offset!");
static_assert(offsetof(ASpy, OnCoverAffectingSourceChanged) == 0x000718, "Member 'ASpy::OnCoverAffectingSourceChanged' has a wrong offset!");
static_assert(offsetof(ASpy, ZoomComponent) == 0x000728, "Member 'ASpy::ZoomComponent' has a wrong offset!");
static_assert(offsetof(ASpy, Spy3DPortrait) == 0x000730, "Member 'ASpy::Spy3DPortrait' has a wrong offset!");
static_assert(offsetof(ASpy, OnSpyDeathEvent) == 0x000738, "Member 'ASpy::OnSpyDeathEvent' has a wrong offset!");
static_assert(offsetof(ASpy, OnSpyImmediateDeathEvent) == 0x000748, "Member 'ASpy::OnSpyImmediateDeathEvent' has a wrong offset!");
static_assert(offsetof(ASpy, OnSpyRevivedEvent) == 0x000758, "Member 'ASpy::OnSpyRevivedEvent' has a wrong offset!");
static_assert(offsetof(ASpy, OnJumpInAnimPlayRateChanged) == 0x000768, "Member 'ASpy::OnJumpInAnimPlayRateChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnAirborneDirectionalTiltChanged) == 0x000778, "Member 'ASpy::OnAirborneDirectionalTiltChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnSetGrabLootAnimationType) == 0x000788, "Member 'ASpy::OnSetGrabLootAnimationType' has a wrong offset!");
static_assert(offsetof(ASpy, OnNewDropActorDropped) == 0x000798, "Member 'ASpy::OnNewDropActorDropped' has a wrong offset!");
static_assert(offsetof(ASpy, OnSpyPowerupApplied) == 0x0007A8, "Member 'ASpy::OnSpyPowerupApplied' has a wrong offset!");
static_assert(offsetof(ASpy, OnSpyPowerupRemoved) == 0x0007B8, "Member 'ASpy::OnSpyPowerupRemoved' has a wrong offset!");
static_assert(offsetof(ASpy, OnDirectionalDamage3PHurt) == 0x0007C8, "Member 'ASpy::OnDirectionalDamage3PHurt' has a wrong offset!");
static_assert(offsetof(ASpy, OnSpyMovementStateChanged) == 0x0007D8, "Member 'ASpy::OnSpyMovementStateChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnDisarmedChanged) == 0x0007E8, "Member 'ASpy::OnDisarmedChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnKeepRunAdditiveWhileRunningOutOfCoverChange) == 0x0007F8, "Member 'ASpy::OnKeepRunAdditiveWhileRunningOutOfCoverChange' has a wrong offset!");
static_assert(offsetof(ASpy, OnReviveStart) == 0x000808, "Member 'ASpy::OnReviveStart' has a wrong offset!");
static_assert(offsetof(ASpy, OnReviveCancel) == 0x000818, "Member 'ASpy::OnReviveCancel' has a wrong offset!");
static_assert(offsetof(ASpy, OnReviveComplete) == 0x000828, "Member 'ASpy::OnReviveComplete' has a wrong offset!");
static_assert(offsetof(ASpy, OnSpyLookAction) == 0x000838, "Member 'ASpy::OnSpyLookAction' has a wrong offset!");
static_assert(offsetof(ASpy, OnSpySelfBlowActionTriggered) == 0x000848, "Member 'ASpy::OnSpySelfBlowActionTriggered' has a wrong offset!");
static_assert(offsetof(ASpy, OnHackedIntel) == 0x000858, "Member 'ASpy::OnHackedIntel' has a wrong offset!");
static_assert(offsetof(ASpy, OnWeaponShot) == 0x000868, "Member 'ASpy::OnWeaponShot' has a wrong offset!");
static_assert(offsetof(ASpy, OnSpyJumpEvent) == 0x000898, "Member 'ASpy::OnSpyJumpEvent' has a wrong offset!");
static_assert(offsetof(ASpy, DroppedItemCache) == 0x0008C0, "Member 'ASpy::DroppedItemCache' has a wrong offset!");
static_assert(offsetof(ASpy, ExtractZone) == 0x000920, "Member 'ASpy::ExtractZone' has a wrong offset!");
static_assert(offsetof(ASpy, OnSpyExtractZoneChanged) == 0x000928, "Member 'ASpy::OnSpyExtractZoneChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnSpyExtractZoneBlocking) == 0x000938, "Member 'ASpy::OnSpyExtractZoneBlocking' has a wrong offset!");
static_assert(offsetof(ASpy, DisguiseData) == 0x000948, "Member 'ASpy::DisguiseData' has a wrong offset!");
static_assert(offsetof(ASpy, MainToolAttachmentPointName) == 0x000958, "Member 'ASpy::MainToolAttachmentPointName' has a wrong offset!");
static_assert(offsetof(ASpy, SpyPlayerHudAsset) == 0x000960, "Member 'ASpy::SpyPlayerHudAsset' has a wrong offset!");
static_assert(offsetof(ASpy, DirectionalDamageHudAssetHolder) == 0x000988, "Member 'ASpy::DirectionalDamageHudAssetHolder' has a wrong offset!");
static_assert(offsetof(ASpy, bHideReticleInADS) == 0x000990, "Member 'ASpy::bHideReticleInADS' has a wrong offset!");
static_assert(offsetof(ASpy, TimeToRecoverIdling) == 0x000994, "Member 'ASpy::TimeToRecoverIdling' has a wrong offset!");
static_assert(offsetof(ASpy, TimeToRecoverWalking) == 0x000998, "Member 'ASpy::TimeToRecoverWalking' has a wrong offset!");
static_assert(offsetof(ASpy, TimeToRecoverRunning) == 0x00099C, "Member 'ASpy::TimeToRecoverRunning' has a wrong offset!");
static_assert(offsetof(ASpy, TimeBeforeStartingRecover) == 0x0009A0, "Member 'ASpy::TimeBeforeStartingRecover' has a wrong offset!");
static_assert(offsetof(ASpy, TimeToRecoverInCoverIdling) == 0x0009A4, "Member 'ASpy::TimeToRecoverInCoverIdling' has a wrong offset!");
static_assert(offsetof(ASpy, TimeToRecoverInCoverWalking) == 0x0009A8, "Member 'ASpy::TimeToRecoverInCoverWalking' has a wrong offset!");
static_assert(offsetof(ASpy, TimeToRecoverInCoverRunning) == 0x0009AC, "Member 'ASpy::TimeToRecoverInCoverRunning' has a wrong offset!");
static_assert(offsetof(ASpy, SecurityCoverAffectingType) == 0x0009B0, "Member 'ASpy::SecurityCoverAffectingType' has a wrong offset!");
static_assert(offsetof(ASpy, EMPCoverAffectingType) == 0x0009B1, "Member 'ASpy::EMPCoverAffectingType' has a wrong offset!");
static_assert(offsetof(ASpy, OutOfCoverStrafeWalkSpeedMultiplier) == 0x0009B4, "Member 'ASpy::OutOfCoverStrafeWalkSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(ASpy, TimeLoseCoverFromScolded) == 0x0009B8, "Member 'ASpy::TimeLoseCoverFromScolded' has a wrong offset!");
static_assert(offsetof(ASpy, TimeLoseCoverFromGuardAggro) == 0x0009BC, "Member 'ASpy::TimeLoseCoverFromGuardAggro' has a wrong offset!");
static_assert(offsetof(ASpy, BreadcrumbsClass) == 0x0009C0, "Member 'ASpy::BreadcrumbsClass' has a wrong offset!");
static_assert(offsetof(ASpy, BreadcrumbLifetime) == 0x0009D0, "Member 'ASpy::BreadcrumbLifetime' has a wrong offset!");
static_assert(offsetof(ASpy, MaxSpawnedBreadcrumbs) == 0x0009D4, "Member 'ASpy::MaxSpawnedBreadcrumbs' has a wrong offset!");
static_assert(offsetof(ASpy, CameraHeightOffset) == 0x0009D8, "Member 'ASpy::CameraHeightOffset' has a wrong offset!");
static_assert(offsetof(ASpy, CrouchCameraHeightExtraOffset) == 0x0009DC, "Member 'ASpy::CrouchCameraHeightExtraOffset' has a wrong offset!");
static_assert(offsetof(ASpy, FrontHurtRecoil) == 0x0009E0, "Member 'ASpy::FrontHurtRecoil' has a wrong offset!");
static_assert(offsetof(ASpy, BackHurtRecoil) == 0x000A10, "Member 'ASpy::BackHurtRecoil' has a wrong offset!");
static_assert(offsetof(ASpy, SideHurtRollKick) == 0x000A40, "Member 'ASpy::SideHurtRollKick' has a wrong offset!");
static_assert(offsetof(ASpy, HurtDamageRatioCurve) == 0x000A58, "Member 'ASpy::HurtDamageRatioCurve' has a wrong offset!");
static_assert(offsetof(ASpy, HurtRecoilLowDamageRatio) == 0x000A60, "Member 'ASpy::HurtRecoilLowDamageRatio' has a wrong offset!");
static_assert(offsetof(ASpy, HurtRecoilLowDamageDurationRatio) == 0x000A64, "Member 'ASpy::HurtRecoilLowDamageDurationRatio' has a wrong offset!");
static_assert(offsetof(ASpy, HurtRecoilLowDamage) == 0x000A68, "Member 'ASpy::HurtRecoilLowDamage' has a wrong offset!");
static_assert(offsetof(ASpy, HurtRecoilHighDamage) == 0x000A6C, "Member 'ASpy::HurtRecoilHighDamage' has a wrong offset!");
static_assert(offsetof(ASpy, HurtRecoilDelay) == 0x000A70, "Member 'ASpy::HurtRecoilDelay' has a wrong offset!");
static_assert(offsetof(ASpy, BlockShootingAfterRunDuration) == 0x000A80, "Member 'ASpy::BlockShootingAfterRunDuration' has a wrong offset!");
static_assert(offsetof(ASpy, BlockRunAfterShootDuration) == 0x000A84, "Member 'ASpy::BlockRunAfterShootDuration' has a wrong offset!");
static_assert(offsetof(ASpy, CrouchCameraHeightInterpolationTime) == 0x000A8C, "Member 'ASpy::CrouchCameraHeightInterpolationTime' has a wrong offset!");
static_assert(offsetof(ASpy, CustomSkin_1P_Class) == 0x000A90, "Member 'ASpy::CustomSkin_1P_Class' has a wrong offset!");
static_assert(offsetof(ASpy, CustomSkin_3P_Class) == 0x000A98, "Member 'ASpy::CustomSkin_3P_Class' has a wrong offset!");
static_assert(offsetof(ASpy, BouncedBySpy) == 0x000AA0, "Member 'ASpy::BouncedBySpy' has a wrong offset!");
static_assert(offsetof(ASpy, ActiveBreadcrumbsActor) == 0x000AA8, "Member 'ASpy::ActiveBreadcrumbsActor' has a wrong offset!");
static_assert(offsetof(ASpy, BreadcrumbsActorCache) == 0x000AB8, "Member 'ASpy::BreadcrumbsActorCache' has a wrong offset!");
static_assert(offsetof(ASpy, BreadcrumbsClassHolderMap) == 0x000AC8, "Member 'ASpy::BreadcrumbsClassHolderMap' has a wrong offset!");
static_assert(offsetof(ASpy, Mesh1P) == 0x000B18, "Member 'ASpy::Mesh1P' has a wrong offset!");
static_assert(offsetof(ASpy, Mesh3P) == 0x000B20, "Member 'ASpy::Mesh3P' has a wrong offset!");
static_assert(offsetof(ASpy, SpringArm1P) == 0x000B28, "Member 'ASpy::SpringArm1P' has a wrong offset!");
static_assert(offsetof(ASpy, Camera1P) == 0x000B30, "Member 'ASpy::Camera1P' has a wrong offset!");
static_assert(offsetof(ASpy, Camera3P) == 0x000B38, "Member 'ASpy::Camera3P' has a wrong offset!");
static_assert(offsetof(ASpy, SpringArm3P) == 0x000B40, "Member 'ASpy::SpringArm3P' has a wrong offset!");
static_assert(offsetof(ASpy, HealthComponent) == 0x000B48, "Member 'ASpy::HealthComponent' has a wrong offset!");
static_assert(offsetof(ASpy, LoadoutComponent) == 0x000B50, "Member 'ASpy::LoadoutComponent' has a wrong offset!");
static_assert(offsetof(ASpy, GameplayResourcesComponent) == 0x000B58, "Member 'ASpy::GameplayResourcesComponent' has a wrong offset!");
static_assert(offsetof(ASpy, EMPAffectedComponent) == 0x000B60, "Member 'ASpy::EMPAffectedComponent' has a wrong offset!");
static_assert(offsetof(ASpy, ScramblerAffectedComponent) == 0x000B68, "Member 'ASpy::ScramblerAffectedComponent' has a wrong offset!");
static_assert(offsetof(ASpy, InteracterComponent) == 0x000B70, "Member 'ASpy::InteracterComponent' has a wrong offset!");
static_assert(offsetof(ASpy, PlayerNameComponent2) == 0x000B78, "Member 'ASpy::PlayerNameComponent2' has a wrong offset!");
static_assert(offsetof(ASpy, PointOfInterestCamera1P) == 0x000B80, "Member 'ASpy::PointOfInterestCamera1P' has a wrong offset!");
static_assert(offsetof(ASpy, PointOfInterest3PHead) == 0x000B88, "Member 'ASpy::PointOfInterest3PHead' has a wrong offset!");
static_assert(offsetof(ASpy, FallDamageComponent) == 0x000B90, "Member 'ASpy::FallDamageComponent' has a wrong offset!");
static_assert(offsetof(ASpy, NavModeItemComponent) == 0x000B98, "Member 'ASpy::NavModeItemComponent' has a wrong offset!");
static_assert(offsetof(ASpy, FallDamageType) == 0x000BA0, "Member 'ASpy::FallDamageType' has a wrong offset!");
static_assert(offsetof(ASpy, DisguiseShieldComponent) == 0x000BA8, "Member 'ASpy::DisguiseShieldComponent' has a wrong offset!");
static_assert(offsetof(ASpy, Sway1PComponent) == 0x000BB0, "Member 'ASpy::Sway1PComponent' has a wrong offset!");
static_assert(offsetof(ASpy, Weapon1PMesh) == 0x000BB8, "Member 'ASpy::Weapon1PMesh' has a wrong offset!");
static_assert(offsetof(ASpy, Weapon3PMesh) == 0x000BC0, "Member 'ASpy::Weapon3PMesh' has a wrong offset!");
static_assert(offsetof(ASpy, PlayerFlagCollision) == 0x000BC8, "Member 'ASpy::PlayerFlagCollision' has a wrong offset!");
static_assert(offsetof(ASpy, RegistrationCollisionShapeComp) == 0x000BD0, "Member 'ASpy::RegistrationCollisionShapeComp' has a wrong offset!");
static_assert(offsetof(ASpy, InteractableComp) == 0x000BD8, "Member 'ASpy::InteractableComp' has a wrong offset!");
static_assert(offsetof(ASpy, ReviveSpyCondition) == 0x000BE0, "Member 'ASpy::ReviveSpyCondition' has a wrong offset!");
static_assert(offsetof(ASpy, RayCastCondition) == 0x000BE8, "Member 'ASpy::RayCastCondition' has a wrong offset!");
static_assert(offsetof(ASpy, AimAssistTargetComp) == 0x000BF0, "Member 'ASpy::AimAssistTargetComp' has a wrong offset!");
static_assert(offsetof(ASpy, PawnAudioComponent) == 0x000BF8, "Member 'ASpy::PawnAudioComponent' has a wrong offset!");
static_assert(offsetof(ASpy, ReviveHealth) == 0x000C00, "Member 'ASpy::ReviveHealth' has a wrong offset!");
static_assert(offsetof(ASpy, ReviveAmmoPackCount) == 0x000C04, "Member 'ASpy::ReviveAmmoPackCount' has a wrong offset!");
static_assert(offsetof(ASpy, bReviveRegainCover) == 0x000C08, "Member 'ASpy::bReviveRegainCover' has a wrong offset!");
static_assert(offsetof(ASpy, InteractableType) == 0x000C09, "Member 'ASpy::InteractableType' has a wrong offset!");
static_assert(offsetof(ASpy, SpyBurnedTooltip) == 0x000C10, "Member 'ASpy::SpyBurnedTooltip' has a wrong offset!");
static_assert(offsetof(ASpy, ReviveSpyTooltip) == 0x000C28, "Member 'ASpy::ReviveSpyTooltip' has a wrong offset!");
static_assert(offsetof(ASpy, MaxAmmoBoxDrop) == 0x000C40, "Member 'ASpy::MaxAmmoBoxDrop' has a wrong offset!");
static_assert(offsetof(ASpy, DeathAmmoLostRatio) == 0x000C44, "Member 'ASpy::DeathAmmoLostRatio' has a wrong offset!");
static_assert(offsetof(ASpy, Watch1P) == 0x000C48, "Member 'ASpy::Watch1P' has a wrong offset!");
static_assert(offsetof(ASpy, Watch3P) == 0x000C50, "Member 'ASpy::Watch3P' has a wrong offset!");
static_assert(offsetof(ASpy, Watch1PClass) == 0x000C58, "Member 'ASpy::Watch1PClass' has a wrong offset!");
static_assert(offsetof(ASpy, Watch3PClass) == 0x000C60, "Member 'ASpy::Watch3PClass' has a wrong offset!");
static_assert(offsetof(ASpy, Poudrier1P) == 0x000C68, "Member 'ASpy::Poudrier1P' has a wrong offset!");
static_assert(offsetof(ASpy, Poudrier3P) == 0x000C70, "Member 'ASpy::Poudrier3P' has a wrong offset!");
static_assert(offsetof(ASpy, PoudrierMesh1PClass) == 0x000C78, "Member 'ASpy::PoudrierMesh1PClass' has a wrong offset!");
static_assert(offsetof(ASpy, PoudrierMesh3PClass) == 0x000CA0, "Member 'ASpy::PoudrierMesh3PClass' has a wrong offset!");
static_assert(offsetof(ASpy, Poudrier_Anim_1P_Class) == 0x000CC8, "Member 'ASpy::Poudrier_Anim_1P_Class' has a wrong offset!");
static_assert(offsetof(ASpy, Poudrier_Anim_3P_Class) == 0x000CD0, "Member 'ASpy::Poudrier_Anim_3P_Class' has a wrong offset!");
static_assert(offsetof(ASpy, WatchAttachmentPointName) == 0x000CD8, "Member 'ASpy::WatchAttachmentPointName' has a wrong offset!");
static_assert(offsetof(ASpy, SpyPortrait3DClass) == 0x000CE0, "Member 'ASpy::SpyPortrait3DClass' has a wrong offset!");
static_assert(offsetof(ASpy, CurrentActiveTool) == 0x000D08, "Member 'ASpy::CurrentActiveTool' has a wrong offset!");
static_assert(offsetof(ASpy, CurrentMeleeAttack) == 0x000D10, "Member 'ASpy::CurrentMeleeAttack' has a wrong offset!");
static_assert(offsetof(ASpy, PlayerHud) == 0x000D18, "Member 'ASpy::PlayerHud' has a wrong offset!");
static_assert(offsetof(ASpy, HideHudRequest) == 0x000D20, "Member 'ASpy::HideHudRequest' has a wrong offset!");
static_assert(offsetof(ASpy, VictimEffectsHuds) == 0x000D70, "Member 'ASpy::VictimEffectsHuds' has a wrong offset!");
static_assert(offsetof(ASpy, AlwaysVisibleMeshs) == 0x000D80, "Member 'ASpy::AlwaysVisibleMeshs' has a wrong offset!");
static_assert(offsetof(ASpy, CoverRatio) == 0x000D90, "Member 'ASpy::CoverRatio' has a wrong offset!");
static_assert(offsetof(ASpy, WalkingSpeed) == 0x000D94, "Member 'ASpy::WalkingSpeed' has a wrong offset!");
static_assert(offsetof(ASpy, CrouchingSpeed) == 0x000D98, "Member 'ASpy::CrouchingSpeed' has a wrong offset!");
static_assert(offsetof(ASpy, SlowPercent) == 0x000D9C, "Member 'ASpy::SlowPercent' has a wrong offset!");
static_assert(offsetof(ASpy, CoverDrainSpeed) == 0x000DA0, "Member 'ASpy::CoverDrainSpeed' has a wrong offset!");
static_assert(offsetof(ASpy, SecurityState) == 0x000DA4, "Member 'ASpy::SecurityState' has a wrong offset!");
static_assert(offsetof(ASpy, UndercoverReplicationData) == 0x000DA8, "Member 'ASpy::UndercoverReplicationData' has a wrong offset!");
static_assert(offsetof(ASpy, RecoverReduction) == 0x000DB8, "Member 'ASpy::RecoverReduction' has a wrong offset!");
static_assert(offsetof(ASpy, ControlledByDisguise) == 0x000DBC, "Member 'ASpy::ControlledByDisguise' has a wrong offset!");
static_assert(offsetof(ASpy, AgentData) == 0x000DE0, "Member 'ASpy::AgentData' has a wrong offset!");
static_assert(offsetof(ASpy, ControlledDrone) == 0x000DE8, "Member 'ASpy::ControlledDrone' has a wrong offset!");
static_assert(offsetof(ASpy, MimicActor) == 0x000DF0, "Member 'ASpy::MimicActor' has a wrong offset!");
static_assert(offsetof(ASpy, OnInstantLoseAggroFromBots) == 0x000DF8, "Member 'ASpy::OnInstantLoseAggroFromBots' has a wrong offset!");
static_assert(offsetof(ASpy, HeatSetup) == 0x000E08, "Member 'ASpy::HeatSetup' has a wrong offset!");
static_assert(offsetof(ASpy, HeatState) == 0x000E58, "Member 'ASpy::HeatState' has a wrong offset!");
static_assert(offsetof(ASpy, CurrentHeatPenalities) == 0x000E80, "Member 'ASpy::CurrentHeatPenalities' has a wrong offset!");
static_assert(offsetof(ASpy, OnHeatLevelChanged) == 0x000E90, "Member 'ASpy::OnHeatLevelChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnHeatValueChanged) == 0x000EA0, "Member 'ASpy::OnHeatValueChanged' has a wrong offset!");
static_assert(offsetof(ASpy, bUseOldHeatSystem) == 0x000EB0, "Member 'ASpy::bUseOldHeatSystem' has a wrong offset!");
static_assert(offsetof(ASpy, StaminaMax) == 0x000EB4, "Member 'ASpy::StaminaMax' has a wrong offset!");
static_assert(offsetof(ASpy, StaminaCurrent) == 0x000EBC, "Member 'ASpy::StaminaCurrent' has a wrong offset!");
static_assert(offsetof(ASpy, StaminaDrainRate) == 0x000EC4, "Member 'ASpy::StaminaDrainRate' has a wrong offset!");
static_assert(offsetof(ASpy, StaminaRegainRate) == 0x000EC8, "Member 'ASpy::StaminaRegainRate' has a wrong offset!");
static_assert(offsetof(ASpy, StaminaDrainRateMultiplier) == 0x000ECC, "Member 'ASpy::StaminaDrainRateMultiplier' has a wrong offset!");
static_assert(offsetof(ASpy, SusCheckSeenByNPCDistanceSQ) == 0x000ED8, "Member 'ASpy::SusCheckSeenByNPCDistanceSQ' has a wrong offset!");
static_assert(offsetof(ASpy, SusEnableNPCCheck) == 0x000EDC, "Member 'ASpy::SusEnableNPCCheck' has a wrong offset!");
static_assert(offsetof(ASpy, bIsSuspicious) == 0x000EDD, "Member 'ASpy::bIsSuspicious' has a wrong offset!");
static_assert(offsetof(ASpy, OnStaminaChanged) == 0x000EE0, "Member 'ASpy::OnStaminaChanged' has a wrong offset!");
static_assert(offsetof(ASpy, OnSuspiciousChanged) == 0x000EF0, "Member 'ASpy::OnSuspiciousChanged' has a wrong offset!");
static_assert(offsetof(ASpy, bResetStamOnCoverChange) == 0x000F00, "Member 'ASpy::bResetStamOnCoverChange' has a wrong offset!");
static_assert(offsetof(ASpy, bResetStamOnCoverLoss) == 0x000F01, "Member 'ASpy::bResetStamOnCoverLoss' has a wrong offset!");
static_assert(offsetof(ASpy, bNoStamTickOutOfCover) == 0x000F02, "Member 'ASpy::bNoStamTickOutOfCover' has a wrong offset!");
static_assert(offsetof(ASpy, bSusOnlyDrainUndercover) == 0x000F03, "Member 'ASpy::bSusOnlyDrainUndercover' has a wrong offset!");
static_assert(offsetof(ASpy, SusFlushOnCoverBlowRatio) == 0x000F04, "Member 'ASpy::SusFlushOnCoverBlowRatio' has a wrong offset!");
static_assert(offsetof(ASpy, bAllowHealingConsumableInMimic) == 0x000F08, "Member 'ASpy::bAllowHealingConsumableInMimic' has a wrong offset!");
static_assert(offsetof(ASpy, bAllowHealingConsumableWhenImmaterial) == 0x000F09, "Member 'ASpy::bAllowHealingConsumableWhenImmaterial' has a wrong offset!");
static_assert(offsetof(ASpy, bAllowHealingConsumableWhenHidden) == 0x000F0A, "Member 'ASpy::bAllowHealingConsumableWhenHidden' has a wrong offset!");
static_assert(offsetof(ASpy, OnHealthConsumableEvent) == 0x000F10, "Member 'ASpy::OnHealthConsumableEvent' has a wrong offset!");
static_assert(offsetof(ASpy, DelayBetweenCOnsumable) == 0x000F2C, "Member 'ASpy::DelayBetweenCOnsumable' has a wrong offset!");
static_assert(offsetof(ASpy, LastHealthEvent) == 0x000F36, "Member 'ASpy::LastHealthEvent' has a wrong offset!");
static_assert(offsetof(ASpy, PingClass) == 0x000F38, "Member 'ASpy::PingClass' has a wrong offset!");
static_assert(offsetof(ASpy, PingClassHolder) == 0x000F68, "Member 'ASpy::PingClassHolder' has a wrong offset!");
static_assert(offsetof(ASpy, ActivePing) == 0x000F70, "Member 'ASpy::ActivePing' has a wrong offset!");
static_assert(offsetof(ASpy, InputContextPriority) == 0x000F78, "Member 'ASpy::InputContextPriority' has a wrong offset!");
static_assert(offsetof(ASpy, BaseTurnRate) == 0x000F7C, "Member 'ASpy::BaseTurnRate' has a wrong offset!");
static_assert(offsetof(ASpy, BaseLookUpRate) == 0x000F80, "Member 'ASpy::BaseLookUpRate' has a wrong offset!");
static_assert(offsetof(ASpy, PingInputHoldMinTime) == 0x000F84, "Member 'ASpy::PingInputHoldMinTime' has a wrong offset!");
static_assert(offsetof(ASpy, PingSelectionMenuClass) == 0x000F88, "Member 'ASpy::PingSelectionMenuClass' has a wrong offset!");
static_assert(offsetof(ASpy, PingSelectionHudName) == 0x000F90, "Member 'ASpy::PingSelectionHudName' has a wrong offset!");
static_assert(offsetof(ASpy, PingActiveMenu) == 0x000F98, "Member 'ASpy::PingActiveMenu' has a wrong offset!");
static_assert(offsetof(ASpy, PingedActor) == 0x000FB8, "Member 'ASpy::PingedActor' has a wrong offset!");
static_assert(offsetof(ASpy, UrgentPingDoubleClick) == 0x000FC0, "Member 'ASpy::UrgentPingDoubleClick' has a wrong offset!");
static_assert(offsetof(ASpy, KillerData) == 0x000FE0, "Member 'ASpy::KillerData' has a wrong offset!");
static_assert(offsetof(ASpy, SecurityFlags) == 0x000FF0, "Member 'ASpy::SecurityFlags' has a wrong offset!");
static_assert(offsetof(ASpy, ScoldTimeoutDelay) == 0x000FF4, "Member 'ASpy::ScoldTimeoutDelay' has a wrong offset!");
static_assert(offsetof(ASpy, InvestigatedTimeoutDelay) == 0x000FF8, "Member 'ASpy::InvestigatedTimeoutDelay' has a wrong offset!");
static_assert(offsetof(ASpy, GuardAgrroTimeoutDelay) == 0x000FFC, "Member 'ASpy::GuardAgrroTimeoutDelay' has a wrong offset!");
static_assert(offsetof(ASpy, RunSpeedSource) == 0x001060, "Member 'ASpy::RunSpeedSource' has a wrong offset!");
static_assert(offsetof(ASpy, RecoverDelay) == 0x0010C0, "Member 'ASpy::RecoverDelay' has a wrong offset!");
static_assert(offsetof(ASpy, WatchMesh1P) == 0x0010C8, "Member 'ASpy::WatchMesh1P' has a wrong offset!");
static_assert(offsetof(ASpy, WatchMesh3P) == 0x0010D0, "Member 'ASpy::WatchMesh3P' has a wrong offset!");
static_assert(offsetof(ASpy, OnRoomStatusChanged) == 0x0010F0, "Member 'ASpy::OnRoomStatusChanged' has a wrong offset!");
static_assert(offsetof(ASpy, SlowSources) == 0x001100, "Member 'ASpy::SlowSources' has a wrong offset!");
static_assert(offsetof(ASpy, CoverDrainSources) == 0x001150, "Member 'ASpy::CoverDrainSources' has a wrong offset!");
static_assert(offsetof(ASpy, CoverAffectingSources) == 0x0011A0, "Member 'ASpy::CoverAffectingSources' has a wrong offset!");
static_assert(offsetof(ASpy, JumpDisablingSource) == 0x0011F0, "Member 'ASpy::JumpDisablingSource' has a wrong offset!");
static_assert(offsetof(ASpy, MovementDisablingSource) == 0x001200, "Member 'ASpy::MovementDisablingSource' has a wrong offset!");
static_assert(offsetof(ASpy, RunDisablingSource) == 0x001210, "Member 'ASpy::RunDisablingSource' has a wrong offset!");
static_assert(offsetof(ASpy, SpeedBoostDisablingSource) == 0x001220, "Member 'ASpy::SpeedBoostDisablingSource' has a wrong offset!");
static_assert(offsetof(ASpy, CameraMovementLockSource) == 0x001230, "Member 'ASpy::CameraMovementLockSource' has a wrong offset!");
static_assert(offsetof(ASpy, InputDisablingRequest) == 0x001240, "Member 'ASpy::InputDisablingRequest' has a wrong offset!");
static_assert(offsetof(ASpy, Extra3PMeshes) == 0x001290, "Member 'ASpy::Extra3PMeshes' has a wrong offset!");
static_assert(offsetof(ASpy, Extra1PMeshes) == 0x0012A0, "Member 'ASpy::Extra1PMeshes' has a wrong offset!");
static_assert(offsetof(ASpy, AnimationProps1P) == 0x0012B0, "Member 'ASpy::AnimationProps1P' has a wrong offset!");
static_assert(offsetof(ASpy, AnimationProps3P) == 0x001300, "Member 'ASpy::AnimationProps3P' has a wrong offset!");
static_assert(offsetof(ASpy, bInVault) == 0x001369, "Member 'ASpy::bInVault' has a wrong offset!");
static_assert(offsetof(ASpy, bInPregameLobby) == 0x00137C, "Member 'ASpy::bInPregameLobby' has a wrong offset!");
static_assert(offsetof(ASpy, bIsBot) == 0x00137E, "Member 'ASpy::bIsBot' has a wrong offset!");
static_assert(offsetof(ASpy, bWeaponDisabled) == 0x001387, "Member 'ASpy::bWeaponDisabled' has a wrong offset!");
static_assert(offsetof(ASpy, bIsImmaterial) == 0x00139C, "Member 'ASpy::bIsImmaterial' has a wrong offset!");
static_assert(offsetof(ASpy, bIsHidden) == 0x00139D, "Member 'ASpy::bIsHidden' has a wrong offset!");
static_assert(offsetof(ASpy, DeadCount) == 0x001424, "Member 'ASpy::DeadCount' has a wrong offset!");
static_assert(offsetof(ASpy, AwardKillDelay) == 0x0014EC, "Member 'ASpy::AwardKillDelay' has a wrong offset!");
static_assert(offsetof(ASpy, MaximumRunAngle) == 0x001514, "Member 'ASpy::MaximumRunAngle' has a wrong offset!");
static_assert(offsetof(ASpy, InactiveRunToggleResetTime) == 0x001518, "Member 'ASpy::InactiveRunToggleResetTime' has a wrong offset!");
static_assert(offsetof(ASpy, DeathCameraObstructionInterpolationDuration) == 0x00151C, "Member 'ASpy::DeathCameraObstructionInterpolationDuration' has a wrong offset!");
static_assert(offsetof(ASpy, DeathCameraObstructionWantedHeight) == 0x001520, "Member 'ASpy::DeathCameraObstructionWantedHeight' has a wrong offset!");
static_assert(offsetof(ASpy, SpyDeathVictimEffectClass) == 0x001528, "Member 'ASpy::SpyDeathVictimEffectClass' has a wrong offset!");
static_assert(offsetof(ASpy, SpyDeathVictimEffect) == 0x001550, "Member 'ASpy::SpyDeathVictimEffect' has a wrong offset!");
static_assert(offsetof(ASpy, JumpFatigueSettings) == 0x001560, "Member 'ASpy::JumpFatigueSettings' has a wrong offset!");
static_assert(offsetof(ASpy, JumpFatigueDecay) == 0x001570, "Member 'ASpy::JumpFatigueDecay' has a wrong offset!");
static_assert(offsetof(ASpy, CrouchFatigueSettings) == 0x001580, "Member 'ASpy::CrouchFatigueSettings' has a wrong offset!");
static_assert(offsetof(ASpy, CrouchFatigueDecay) == 0x001590, "Member 'ASpy::CrouchFatigueDecay' has a wrong offset!");
static_assert(offsetof(ASpy, SocialBatteryHealing) == 0x0015A0, "Member 'ASpy::SocialBatteryHealing' has a wrong offset!");
static_assert(offsetof(ASpy, CachedDIPlayerState) == 0x0015A8, "Member 'ASpy::CachedDIPlayerState' has a wrong offset!");
static_assert(offsetof(ASpy, PopMan) == 0x0015B0, "Member 'ASpy::PopMan' has a wrong offset!");
static_assert(offsetof(ASpy, DebugTextRenderComponent) == 0x0015C0, "Member 'ASpy::DebugTextRenderComponent' has a wrong offset!");
static_assert(offsetof(ASpy, CheatsComponent) == 0x0015C8, "Member 'ASpy::CheatsComponent' has a wrong offset!");
static_assert(offsetof(ASpy, bCheatDisableCover) == 0x0015D0, "Member 'ASpy::bCheatDisableCover' has a wrong offset!");
static_assert(offsetof(ASpy, InteractsInRange) == 0x0015E0, "Member 'ASpy::InteractsInRange' has a wrong offset!");
static_assert(offsetof(ASpy, OnHideLocalWidget) == 0x001610, "Member 'ASpy::OnHideLocalWidget' has a wrong offset!");
static_assert(offsetof(ASpy, CheatTraceClass) == 0x001620, "Member 'ASpy::CheatTraceClass' has a wrong offset!");

// Class DeceiveInc.Spy3DPortrait
// 0x0068 (0x0288 - 0x0220)
class ASpy3DPortrait final : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnDamageReceived;                                  // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ASpy*                                   TargetSpy;                                         // 0x0230(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 Disguise;                                          // 0x0238(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESecurityLevel                                SecurityLevel;                                     // 0x0240(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 SpyMesh;                                           // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 DisguiseMesh;                                      // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneCaptureComponent2D*               Camera;                                            // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpotLightComponent*                    CameraSpotlight;                                   // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CameraFocusSocketName;                             // 0x0268(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMeshComponent*>                 ExtraCapturedComponents;                           // 0x0270(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnDamageReceived();
	void BP_OnDisguiseChange();
	void BP_OnDisguiseVisibilityChange(bool bIsVisible);
	void BP_OnSpyVisibilityChange(bool bIsVisible);
	void BP_UpdatePlayerHud(class UUserWidget* NewHud);
	void EnableSpotlight(bool bEnable);
	void HandleCoverVisibilityChange(bool CoverVisible);
	void HandleHealthChanged(class UHealthComponent* OwningHealthComp, float Health, float HealthDelta, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser, float RawDamage);
	void SnapSpyStaticPortraitNow();
	void UpdateCameraRotation();

	class USkeletalMeshComponent* GetCurrentVisibleMesh() const;
	class USkeletalMeshComponent* GetDisguiseReferenceMesh() const;
	ESecurityLevel GetDisguiseSecurityLevel() const;
	class UAnimationAsset* GetSpyAnimMotionAsset(class FName MotionName) const;
	class USkeletalMeshComponent* GetSpyReferenceMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Spy3DPortrait">();
	}
	static class ASpy3DPortrait* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpy3DPortrait>();
	}
};
static_assert(alignof(ASpy3DPortrait) == 0x000008, "Wrong alignment on ASpy3DPortrait");
static_assert(sizeof(ASpy3DPortrait) == 0x000288, "Wrong size on ASpy3DPortrait");
static_assert(offsetof(ASpy3DPortrait, OnDamageReceived) == 0x000220, "Member 'ASpy3DPortrait::OnDamageReceived' has a wrong offset!");
static_assert(offsetof(ASpy3DPortrait, TargetSpy) == 0x000230, "Member 'ASpy3DPortrait::TargetSpy' has a wrong offset!");
static_assert(offsetof(ASpy3DPortrait, Disguise) == 0x000238, "Member 'ASpy3DPortrait::Disguise' has a wrong offset!");
static_assert(offsetof(ASpy3DPortrait, SecurityLevel) == 0x000240, "Member 'ASpy3DPortrait::SecurityLevel' has a wrong offset!");
static_assert(offsetof(ASpy3DPortrait, SpyMesh) == 0x000248, "Member 'ASpy3DPortrait::SpyMesh' has a wrong offset!");
static_assert(offsetof(ASpy3DPortrait, DisguiseMesh) == 0x000250, "Member 'ASpy3DPortrait::DisguiseMesh' has a wrong offset!");
static_assert(offsetof(ASpy3DPortrait, Camera) == 0x000258, "Member 'ASpy3DPortrait::Camera' has a wrong offset!");
static_assert(offsetof(ASpy3DPortrait, CameraSpotlight) == 0x000260, "Member 'ASpy3DPortrait::CameraSpotlight' has a wrong offset!");
static_assert(offsetof(ASpy3DPortrait, CameraFocusSocketName) == 0x000268, "Member 'ASpy3DPortrait::CameraFocusSocketName' has a wrong offset!");
static_assert(offsetof(ASpy3DPortrait, ExtraCapturedComponents) == 0x000270, "Member 'ASpy3DPortrait::ExtraCapturedComponents' has a wrong offset!");

// Class DeceiveInc.SpyCache
// 0x0030 (0x02E8 - 0x02B8)
class ASpyCache final : public ABaseInteractableActor
{
public:
	class UHackTrapScannableComponent*            HackTrapScannableComp;                             // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URayCastConditionComponent*             RayCastCond;                                       // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActiveAbilityConditionComponent*       ActiveAbility;                                     // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaxResourceConditionComponent*         MaxResource;                                       // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Mesh;                                              // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         IntelToGive;                                       // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4[0x1];                                      // 0x02E4(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsSpyCacheEnabled;                                // 0x02E5(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E6[0x2];                                      // 0x02E6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_CloseCache();
	void BP_DoPing();
	void OnInteractionCanceled(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void OnInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void OnInteractionCompleteAll(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void OnRep_CacheEnabled(bool OldVal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpyCache">();
	}
	static class ASpyCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpyCache>();
	}
};
static_assert(alignof(ASpyCache) == 0x000008, "Wrong alignment on ASpyCache");
static_assert(sizeof(ASpyCache) == 0x0002E8, "Wrong size on ASpyCache");
static_assert(offsetof(ASpyCache, HackTrapScannableComp) == 0x0002B8, "Member 'ASpyCache::HackTrapScannableComp' has a wrong offset!");
static_assert(offsetof(ASpyCache, RayCastCond) == 0x0002C0, "Member 'ASpyCache::RayCastCond' has a wrong offset!");
static_assert(offsetof(ASpyCache, ActiveAbility) == 0x0002C8, "Member 'ASpyCache::ActiveAbility' has a wrong offset!");
static_assert(offsetof(ASpyCache, MaxResource) == 0x0002D0, "Member 'ASpyCache::MaxResource' has a wrong offset!");
static_assert(offsetof(ASpyCache, Mesh) == 0x0002D8, "Member 'ASpyCache::Mesh' has a wrong offset!");
static_assert(offsetof(ASpyCache, IntelToGive) == 0x0002E0, "Member 'ASpyCache::IntelToGive' has a wrong offset!");
static_assert(offsetof(ASpyCache, bIsSpyCacheEnabled) == 0x0002E5, "Member 'ASpyCache::bIsSpyCacheEnabled' has a wrong offset!");

// Class DeceiveInc.SpyCheatsComponent
// 0x0010 (0x00C0 - 0x00B0)
class USpyCheatsComponent final : public UActorComponent
{
public:
	class ADIFreeSpectator*                       SpectatorTest;                                     // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheatAbilityResetCooldown();
	void CheatAbilityResetCooldownSrv();
	void CheatAbilityToggleNoCooldown();
	void CheatAbilityToggleNoCooldownSrv();
	void CheatBotsDisableStalling();
	void CheatBotsDisableStallingSrv();
	void CheatBotToggleIgnoreOtherBots();
	void CheatBotToggleIgnoreOtherBotsSrv();
	void CheatBotTogglePerfectFireRate();
	void CheatBotTogglePerfectFireRateSrv();
	void CheatDamage(float DamageAmmount);
	void CheatDamageSrv(float DamageAmmount);
	void CheatDangerDebugDraw();
	void CheatDelayDamage(float DamageAmmount);
	void CheatDemiGodSrv();
	void CheatDisableSpecialRule(EDISpecialRules SpecialRule);
	void CheatDisguiseGiveSecurityLevel(ESecurityLevel Security);
	void CheatDisguiseGiveSecurityLevelSrv(ESecurityLevel Security);
	void CheatDisguiseToggleDebugInfo();
	void CheatDisguiseToggleNoCover();
	void CheatDisguiseToggleNoCoverSrv();
	void CheatDropInv();
	void CheatDropInvSrv();
	void CheatEnableRulesetSrv(EDISpecialRules SpecialRule, bool bEnable);
	void CheatEnableSpecialRule(EDISpecialRules SpecialRule);
	void CheatFillWithBots();
	void CheatFillWithBotsSrv();
	void CheatForceShowHud();
	void CheatForceSpectator();
	void CheatForceSpectatorSrv();
	void CheatFOVLog();
	void CheatGameAddTimeLeft(int32 TimeToAdd);
	void CheatGameAddTimeLeftSrv(int32 TimeToAdd);
	void CheatGameChangeMap(const class FString& NewMap);
	void CheatGameChangeMapSrv(const class FString& NewMap);
	void CheatGameClearNPCBodies();
	void CheatGameClearNPCBodiesSrv();
	void CheatGameDisableGuards();
	void CheatGameEnableGuards();
	void CheatGameEndSrv(bool bWin);
	void CheatGameForceFaction(int8 NewFactionID);
	void CheatGameForceFactionSrv(int8 NewFactionID);
	void CheatGameForceShowTimer();
	void CheatGameKillAllNPCs();
	void CheatGameKillAllNPCsSrv();
	void CheatGameLose();
	void CheatGamePause();
	void CheatGamePauseSrv(bool bPause);
	void CheatGameSetGuardsEnabledSrv(bool bEnabled);
	void CheatGameSetTimeLeft(int32 TimeLeft);
	void CheatGameSetTimeLeftSrv(int32 TimeLeft);
	void CheatGameSkipPhase();
	void CheatGameTeleportToSafe();
	void CheatGameTeleportToSafeSrv();
	void CheatGameToggleDebugGuardAggro();
	void CheatGameToggleDebugGuardAggroSrv();
	void CheatGameToggleGuardTrailDebugDraw();
	void CheatGameTogglePlayername();
	void CheatGameToggleShowRoomName();
	void CheatGameTraceBondPiles();
	void CheatGameTraceBondPilesSrv();
	void CheatGameTraceVIPs();
	void CheatGameTraceVIPsSrv();
	void CheatGameUnpause();
	void CheatGameWin();
	void CheatGenericChestClose();
	void CheatGenericChestCloseSrv();
	void CheatGiveAllCharge();
	void CheatGiveAllPowerups();
	void CheatGiveFullAmmo();
	void CheatGiveResource(EGameplayResourcesType Type, int32 Ammount);
	void CheatGiveResourceSrv(EGameplayResourcesType Type, int32 Ammount);
	void CheatGiveSpyKit();
	void CheatGodSrv();
	void CheatHeal(float HealAmmount);
	void CheatHealSrv(float HealAmmount);
	void CheatHeatReset();
	void CheatHeatSetLevel(int32 Level);
	void CheatHeatSetLevelSrv(int32 Level);
	void CheatHideAllHuds();
	void CheatHideHud(const class FString& HudToHide);
	void CheatIgnoreLastManStanding();
	void CheatIgnoreLastManStandingSrv();
	void CheatIntroShowcaseFillWithClones();
	void CheatLogActiveHandToolEventsDebug();
	void CheatLogClient(const class FString& Message);
	void CheatLogServer(const class FString& Message);
	void CheatLookAt3rdSpy();
	void CheatMeleeToggleDebug();
	void CheatNPCSetNetCullingDistance(float Distance);
	void CheatNPCSetNetCullingDistanceSrv(float Distance);
	void CheatNPCToggleDebugInfoTargeting();
	void CheatNPCToggleDebugSuspiciousness();
	void CheatNPCToggleMeshTickEnabled();
	void CheatRestore();
	void CheatRestoreSrv();
	void CheatRevive();
	void CheatReviveSrv();
	void CheatSetGameRuleset(EDIGameRuleset NewRuleset);
	void CheatSetGameRulesetSrv(EDIGameRuleset NewRuleset);
	void CheatShowBotDebugText();
	void CheatSkipGamePhaseSrv();
	void CheatSmokeTestBotsBattleRoyale();
	void CheatSmokeTestBotsBattleRoyaleDemiGod();
	void CheatSmokeTestBotsBattleRoyaleSrv(bool bDemiGod);
	void CheatSpawnBot(const class FString& SpyName);
	void CheatSpawnBotAndDebug(const class FString& SpyName);
	void CheatSpawnBotSrv(const class FString& SpyName);
	void CheatSuperEvilManeuverToMaketheServerCrash();
	void CheatSuperEvilManeuverToMaketheServerCrashSrv();
	void CheatTestCheat();
	void CheatToggleAimAssistExtraInfo();
	void CheatToggleAimAssistInfo();
	void CheatToggleAlwaysShowReticle();
	void CheatToggleAutoClick();
	void CheatToggleAutoShootForever();
	void CheatToggleDemiGod();
	void CheatToggleGod();
	void CheatToggleHideFriendlyGadgetOverlay();
	void CheatToggleIKFromPoseDebugDraws();
	void CheatToggleIKFromPoseEnabled();
	void CheatToggleSpySuspiciousSystem();
	void CheatToggleSpySuspiciousSystemSrv();
	void CheatToggleSway1PDebugDraw();
	void CheatToggleSway1PEnabled();
	void CheatTraceAllBots();
	void CheatTraceAllBotsSrv();
	void CheatWeaponToggleAmmoConsumption();
	void CheatWeaponToggleDamageNumbers();
	void CheatWeaponToggleRecoil();
	void CheatWeaponToggleSprayDebugDraw();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpyCheatsComponent">();
	}
	static class USpyCheatsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpyCheatsComponent>();
	}
};
static_assert(alignof(USpyCheatsComponent) == 0x000008, "Wrong alignment on USpyCheatsComponent");
static_assert(sizeof(USpyCheatsComponent) == 0x0000C0, "Wrong size on USpyCheatsComponent");
static_assert(offsetof(USpyCheatsComponent, SpectatorTest) == 0x0000B0, "Member 'USpyCheatsComponent::SpectatorTest' has a wrong offset!");

// Class DeceiveInc.SpyGameModeMapData
// 0x03C0 (0x03F8 - 0x0038)
class USpyGameModeMapData final : public UDIPrimaryDataAsset
{
public:
	struct FIntroPhaseData                        IntroPhaseData;                                    // 0x0038(0x0058)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVaultLockedPhaseData                  VaultLockedPhaseData;                              // 0x0090(0x0098)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVaultUnlockedPhaseData                VaultUnlockedPhaseData;                            // 0x0128(0x00C8)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FExtractionArrivingPhaseData           ExtractionArrivingPhaseData;                       // 0x01F0(0x00E8)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FExtractionArrivedPhaseData            ExtractionArrivedPhaseData;                        // 0x02D8(0x00C0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FResultScreenPhaseData                 ResultScreenPhaseData;                             // 0x0398(0x0058)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bCheckForLastSpyStanding;                          // 0x03F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckForLastSpyStandingExtract;                   // 0x03F1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckForAllDeath;                                 // 0x03F2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTimerEnabled;                                     // 0x03F3(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyInvulnerability;                             // 0x03F4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckInventory;                                   // 0x03F5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F6[0x2];                                      // 0x03F6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpyGameModeMapData">();
	}
	static class USpyGameModeMapData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpyGameModeMapData>();
	}
};
static_assert(alignof(USpyGameModeMapData) == 0x000008, "Wrong alignment on USpyGameModeMapData");
static_assert(sizeof(USpyGameModeMapData) == 0x0003F8, "Wrong size on USpyGameModeMapData");
static_assert(offsetof(USpyGameModeMapData, IntroPhaseData) == 0x000038, "Member 'USpyGameModeMapData::IntroPhaseData' has a wrong offset!");
static_assert(offsetof(USpyGameModeMapData, VaultLockedPhaseData) == 0x000090, "Member 'USpyGameModeMapData::VaultLockedPhaseData' has a wrong offset!");
static_assert(offsetof(USpyGameModeMapData, VaultUnlockedPhaseData) == 0x000128, "Member 'USpyGameModeMapData::VaultUnlockedPhaseData' has a wrong offset!");
static_assert(offsetof(USpyGameModeMapData, ExtractionArrivingPhaseData) == 0x0001F0, "Member 'USpyGameModeMapData::ExtractionArrivingPhaseData' has a wrong offset!");
static_assert(offsetof(USpyGameModeMapData, ExtractionArrivedPhaseData) == 0x0002D8, "Member 'USpyGameModeMapData::ExtractionArrivedPhaseData' has a wrong offset!");
static_assert(offsetof(USpyGameModeMapData, ResultScreenPhaseData) == 0x000398, "Member 'USpyGameModeMapData::ResultScreenPhaseData' has a wrong offset!");
static_assert(offsetof(USpyGameModeMapData, bCheckForLastSpyStanding) == 0x0003F0, "Member 'USpyGameModeMapData::bCheckForLastSpyStanding' has a wrong offset!");
static_assert(offsetof(USpyGameModeMapData, bCheckForLastSpyStandingExtract) == 0x0003F1, "Member 'USpyGameModeMapData::bCheckForLastSpyStandingExtract' has a wrong offset!");
static_assert(offsetof(USpyGameModeMapData, bCheckForAllDeath) == 0x0003F2, "Member 'USpyGameModeMapData::bCheckForAllDeath' has a wrong offset!");
static_assert(offsetof(USpyGameModeMapData, bTimerEnabled) == 0x0003F3, "Member 'USpyGameModeMapData::bTimerEnabled' has a wrong offset!");
static_assert(offsetof(USpyGameModeMapData, bApplyInvulnerability) == 0x0003F4, "Member 'USpyGameModeMapData::bApplyInvulnerability' has a wrong offset!");
static_assert(offsetof(USpyGameModeMapData, bCheckInventory) == 0x0003F5, "Member 'USpyGameModeMapData::bCheckInventory' has a wrong offset!");

// Class DeceiveInc.SpyGlassTool
// 0x0040 (0x0570 - 0x0530)
class ASpyGlassTool final : public ABaseSpyTool
{
public:
	class FName                                   SpyGlassHudName;                                   // 0x0530(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URangeInteracterComponent*              RangeInteracterComp;                               // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCooldownComponent*                     CooldownComp;                                      // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpringArmComponent*                    SpringArm;                                         // 0x0548(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       ToolCamera;                                        // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayResourcesComponent*            GameplayResource;                                  // 0x0558(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteracterComponent*                   OwnerInteracterComp;                               // 0x0560(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleAddInteractionTimeReduction(float Reduction);
	void HandleCooldownChange(bool bOnCooldown);
	void HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);
	void HandleRemoveInteractionTimeReduction(float Reduction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpyGlassTool">();
	}
	static class ASpyGlassTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpyGlassTool>();
	}
};
static_assert(alignof(ASpyGlassTool) == 0x000008, "Wrong alignment on ASpyGlassTool");
static_assert(sizeof(ASpyGlassTool) == 0x000570, "Wrong size on ASpyGlassTool");
static_assert(offsetof(ASpyGlassTool, SpyGlassHudName) == 0x000530, "Member 'ASpyGlassTool::SpyGlassHudName' has a wrong offset!");
static_assert(offsetof(ASpyGlassTool, RangeInteracterComp) == 0x000538, "Member 'ASpyGlassTool::RangeInteracterComp' has a wrong offset!");
static_assert(offsetof(ASpyGlassTool, CooldownComp) == 0x000540, "Member 'ASpyGlassTool::CooldownComp' has a wrong offset!");
static_assert(offsetof(ASpyGlassTool, SpringArm) == 0x000548, "Member 'ASpyGlassTool::SpringArm' has a wrong offset!");
static_assert(offsetof(ASpyGlassTool, ToolCamera) == 0x000550, "Member 'ASpyGlassTool::ToolCamera' has a wrong offset!");
static_assert(offsetof(ASpyGlassTool, GameplayResource) == 0x000558, "Member 'ASpyGlassTool::GameplayResource' has a wrong offset!");
static_assert(offsetof(ASpyGlassTool, OwnerInteracterComp) == 0x000560, "Member 'ASpyGlassTool::OwnerInteracterComp' has a wrong offset!");

// Class DeceiveInc.SpyPack
// 0x0010 (0x0300 - 0x02F0)
class ASpyPack : public ABasePickableActor
{
public:
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HealthCount;                                       // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpyPack">();
	}
	static class ASpyPack* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpyPack>();
	}
};
static_assert(alignof(ASpyPack) == 0x000008, "Wrong alignment on ASpyPack");
static_assert(sizeof(ASpyPack) == 0x000300, "Wrong size on ASpyPack");
static_assert(offsetof(ASpyPack, HealthCount) == 0x0002F8, "Member 'ASpyPack::HealthCount' has a wrong offset!");

// Class DeceiveInc.SpyPing
// 0x00A0 (0x02C0 - 0x0220)
class ASpyPing final : public AActor
{
public:
	TSoftClassPtr<class UClass>                   PingWidgetClass;                                   // 0x0220(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDIPingWidget*                          PingWidget;                                        // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPingData                              PingData;                                          // 0x0250(0x0058)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CriticalDuration;                                  // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PingUIOffset;                                      // 0x02B0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_SetupPing(const struct FPingData& SetupPingData, int32 FactionIndex);
	void OnRep_PingData();

	float GetWidgetFade() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpyPing">();
	}
	static class ASpyPing* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpyPing>();
	}
};
static_assert(alignof(ASpyPing) == 0x000008, "Wrong alignment on ASpyPing");
static_assert(sizeof(ASpyPing) == 0x0002C0, "Wrong size on ASpyPing");
static_assert(offsetof(ASpyPing, PingWidgetClass) == 0x000220, "Member 'ASpyPing::PingWidgetClass' has a wrong offset!");
static_assert(offsetof(ASpyPing, PingWidget) == 0x000248, "Member 'ASpyPing::PingWidget' has a wrong offset!");
static_assert(offsetof(ASpyPing, PingData) == 0x000250, "Member 'ASpyPing::PingData' has a wrong offset!");
static_assert(offsetof(ASpyPing, Duration) == 0x0002A8, "Member 'ASpyPing::Duration' has a wrong offset!");
static_assert(offsetof(ASpyPing, CriticalDuration) == 0x0002AC, "Member 'ASpyPing::CriticalDuration' has a wrong offset!");
static_assert(offsetof(ASpyPing, PingUIOffset) == 0x0002B0, "Member 'ASpyPing::PingUIOffset' has a wrong offset!");

// Class DeceiveInc.SpyWeaponInterface
// 0x0000 (0x0028 - 0x0028)
class ISpyWeaponInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpyWeaponInterface">();
	}
	static class ISpyWeaponInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISpyWeaponInterface>();
	}
};
static_assert(alignof(ISpyWeaponInterface) == 0x000008, "Wrong alignment on ISpyWeaponInterface");
static_assert(sizeof(ISpyWeaponInterface) == 0x000028, "Wrong size on ISpyWeaponInterface");

// Class DeceiveInc.SquireActiveAbility
// 0x00B8 (0x0648 - 0x0590)
class ASquireActiveAbility final : public ABaseSpyActiveAbility
{
public:
	float                                         DetectionRange;                                    // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetectionHeight;                                   // 0x0594(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class AActor*>                           DetectedActors;                                    // 0x0598(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<ECollisionChannel>                     DetectionCollisionChannels;                        // 0x05E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<EInteractableType, uint8>                DepthStencilValuePerType;                          // 0x05F8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void BP_OnInteractableDetected(class AActor* InteractableActor, EInteractableType InteractableType, uint8 StencilValue);
	void BP_OnInteractableDetectionEnd(class AActor* InteractableActor);
	void BP_OnTriggerLocalDetection();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquireActiveAbility">();
	}
	static class ASquireActiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASquireActiveAbility>();
	}
};
static_assert(alignof(ASquireActiveAbility) == 0x000008, "Wrong alignment on ASquireActiveAbility");
static_assert(sizeof(ASquireActiveAbility) == 0x000648, "Wrong size on ASquireActiveAbility");
static_assert(offsetof(ASquireActiveAbility, DetectionRange) == 0x000590, "Member 'ASquireActiveAbility::DetectionRange' has a wrong offset!");
static_assert(offsetof(ASquireActiveAbility, DetectionHeight) == 0x000594, "Member 'ASquireActiveAbility::DetectionHeight' has a wrong offset!");
static_assert(offsetof(ASquireActiveAbility, DetectedActors) == 0x000598, "Member 'ASquireActiveAbility::DetectedActors' has a wrong offset!");
static_assert(offsetof(ASquireActiveAbility, DetectionCollisionChannels) == 0x0005E8, "Member 'ASquireActiveAbility::DetectionCollisionChannels' has a wrong offset!");
static_assert(offsetof(ASquireActiveAbility, DepthStencilValuePerType) == 0x0005F8, "Member 'ASquireActiveAbility::DepthStencilValuePerType' has a wrong offset!");

// Class DeceiveInc.SquireActiveAbilityMod2
// 0x0028 (0x05B8 - 0x0590)
class ASquireActiveAbilityMod2 final : public ABaseSpyActiveAbility
{
public:
	float                                         EffectRange;                                       // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectHeight;                                      // 0x0594(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_598[0x14];                                     // 0x0598(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DetectedSpies;                                     // 0x05AC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_ClosestSpyInfo(int32 AffectedSpies, class ASpy* Spy, float Distance);
	void BP_DetectedSpiesChanged(int32 AffectedSpies);
	void BP_DetectedSpy(class ASpy* Spy, float Distance);
	void OnRep_DetectedSpies();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquireActiveAbilityMod2">();
	}
	static class ASquireActiveAbilityMod2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASquireActiveAbilityMod2>();
	}
};
static_assert(alignof(ASquireActiveAbilityMod2) == 0x000008, "Wrong alignment on ASquireActiveAbilityMod2");
static_assert(sizeof(ASquireActiveAbilityMod2) == 0x0005B8, "Wrong size on ASquireActiveAbilityMod2");
static_assert(offsetof(ASquireActiveAbilityMod2, EffectRange) == 0x000590, "Member 'ASquireActiveAbilityMod2::EffectRange' has a wrong offset!");
static_assert(offsetof(ASquireActiveAbilityMod2, EffectHeight) == 0x000594, "Member 'ASquireActiveAbilityMod2::EffectHeight' has a wrong offset!");
static_assert(offsetof(ASquireActiveAbilityMod2, DetectedSpies) == 0x0005AC, "Member 'ASquireActiveAbilityMod2::DetectedSpies' has a wrong offset!");

// Class DeceiveInc.SquirePassiveAbilityMod2
// 0x0058 (0x0588 - 0x0530)
class ASquirePassiveAbilityMod2 final : public ABaseSpyPassiveAbility
{
public:
	TSoftClassPtr<class UClass>                   ShieldDisguiseDamageModifier;                      // 0x0530(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ShieldDamageModifier;                              // 0x0558(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageReductionDuration;                           // 0x0580(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_584[0x4];                                      // 0x0584(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleOnDisguiseShieldInitDone(class UDisguiseShieldComponent* DisguiseShieldComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquirePassiveAbilityMod2">();
	}
	static class ASquirePassiveAbilityMod2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASquirePassiveAbilityMod2>();
	}
};
static_assert(alignof(ASquirePassiveAbilityMod2) == 0x000008, "Wrong alignment on ASquirePassiveAbilityMod2");
static_assert(sizeof(ASquirePassiveAbilityMod2) == 0x000588, "Wrong size on ASquirePassiveAbilityMod2");
static_assert(offsetof(ASquirePassiveAbilityMod2, ShieldDisguiseDamageModifier) == 0x000530, "Member 'ASquirePassiveAbilityMod2::ShieldDisguiseDamageModifier' has a wrong offset!");
static_assert(offsetof(ASquirePassiveAbilityMod2, ShieldDamageModifier) == 0x000558, "Member 'ASquirePassiveAbilityMod2::ShieldDamageModifier' has a wrong offset!");
static_assert(offsetof(ASquirePassiveAbilityMod2, DamageReductionDuration) == 0x000580, "Member 'ASquirePassiveAbilityMod2::DamageReductionDuration' has a wrong offset!");

// Class DeceiveInc.SweetAimAssistInputModifierPitch1D
// 0x0000 (0x0038 - 0x0038)
class USweetAimAssistInputModifierPitch1D : public USweetAimAssistInputModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SweetAimAssistInputModifierPitch1D">();
	}
	static class USweetAimAssistInputModifierPitch1D* GetDefaultObj()
	{
		return GetDefaultObjImpl<USweetAimAssistInputModifierPitch1D>();
	}
};
static_assert(alignof(USweetAimAssistInputModifierPitch1D) == 0x000008, "Wrong alignment on USweetAimAssistInputModifierPitch1D");
static_assert(sizeof(USweetAimAssistInputModifierPitch1D) == 0x000038, "Wrong size on USweetAimAssistInputModifierPitch1D");

// Class DeceiveInc.SweetAimAssistInputModifier2D
// 0x0000 (0x0038 - 0x0038)
class USweetAimAssistInputModifier2D : public USweetAimAssistInputModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SweetAimAssistInputModifier2D">();
	}
	static class USweetAimAssistInputModifier2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<USweetAimAssistInputModifier2D>();
	}
};
static_assert(alignof(USweetAimAssistInputModifier2D) == 0x000008, "Wrong alignment on USweetAimAssistInputModifier2D");
static_assert(sizeof(USweetAimAssistInputModifier2D) == 0x000038, "Wrong size on USweetAimAssistInputModifier2D");

// Class DeceiveInc.SweetChatSubsystem
// 0x00D0 (0x0100 - 0x0030)
class USweetChatSubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnLocalPlayerTalkingUpdate;                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnJoinedChannelsChanged;                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnParticipantsChanged;                             // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAudioDevicesChanged;                             // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVoiceChatDisconnected;                           // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVoiceChatPlayerLoggedIn;                         // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVoiceChatPlayerLoggedOut;                        // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVoiceChatPlayerAddedToChannel;                   // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVoiceChatPlayerRemovedFromChannel;               // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVoiceChatChannelJoined;                          // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVoiceChatChannelExited;                          // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVoiceChatPlayerTalkingUpdated;                   // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AEOSVoiceChatHandler*                   VoiceChatHandler;                                  // 0x00F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerController*                      RegisteredPlayer;                                  // 0x00F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class ADeceiveIncPlayerVoiceChat* GetPlayerVoiceChat();
	void HandleAudioDevicesChanged();
	void HandleBooleanPlayerSettingChange(EPlayerSettingsType SettingType, bool NewValue);
	void HandleIntegerPlayerSettingChange(EPlayerSettingsType SettingType, int32 NewValue);
	void HandleJoinedChannelsChanged();
	void HandleLocalPlayerTalkingUpdate(bool Talking, float MaxAmp);
	void HandleParticipantsChanged();
	void HandleStringPlayerSettingChange(EPlayerSettingsType SettingType, const class FString& NewValue);
	void HandleVCInstanceBeingDestroyed(class AEOSVoiceChatHandler* Instance);
	void HandleVoiceChatChannelExited(const class FString& ChannelName, const class FString& Reason);
	void HandleVoiceChatChannelJoined(const class FString& ChannelName);
	void HandleVoiceChatDisconnected(const class FString& Reason);
	void HandleVoiceChatLoggedIn(const class FString& PlayerName);
	void HandleVoiceChatLoggedOut(const class FString& PlayerName);
	void HandleVoiceChatPlayerAdded(const class FString& ChannelName, const class FString& PlayerName);
	void HandleVoiceChatPlayerMuteUpdated(const class FString& ChannelName, const class FString& PlayerName, bool bIsMuted);
	void HandleVoiceChatPlayerRemoved(const class FString& ChannelName, const class FString& PlayerName);
	void HandleVoiceChatPlayerTalkingUpdated(const class FString& ChannelName, const class FString& PlayerName, bool bIsTalking);
	bool JoinVoiceChannel(const class FString& ChannelName, const class FString& ChannelCredentials);
	bool LeaveAllVoiceChannels();
	bool LeaveVoiceChannel(const class FString& ChannelName);
	void SetInputMuted(bool bMuted);
	void SetInputVolume(const float& Volume);
	void SetLocalVoiceActivationThreshold(float FNormalizedThreshold);
	void SetOutputMuted(bool bMuted);
	void SetOutputVolume(const float& Volume);
	void SetPlayerMuted(const class FString& PlayerName, bool bAudioMuted);
	void SetPlayerVolume(const class FString& PlayerName, float Volume);
	void SetTransmitMode(EPlayerVoiceChatTransmitMode TransmitMode);

	bool GetInputMuted() const;
	float GetInputVolume() const;
	TArray<class FString> GetJoinedChannels() const;
	float GetLocalVoiceActivationThreshold() const;
	class FString GetLoggedInPlayerName() const;
	bool GetOutputMuted() const;
	float GetOutputVolume() const;
	TArray<class FString> GetPlayersInChannel(const class FString& ChannelName) const;
	float GetPlayerVolume(const class FString& PlayerName) const;
	EPlayerVoiceChatTransmitMode GetTransmitMode() const;
	bool IsLocalPlayerTalking() const;
	bool IsPlayerMuted(const class FString& PlayerName) const;
	bool IsPlayerTalking(const class FString& PlayerName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SweetChatSubsystem">();
	}
	static class USweetChatSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USweetChatSubsystem>();
	}
};
static_assert(alignof(USweetChatSubsystem) == 0x000008, "Wrong alignment on USweetChatSubsystem");
static_assert(sizeof(USweetChatSubsystem) == 0x000100, "Wrong size on USweetChatSubsystem");
static_assert(offsetof(USweetChatSubsystem, OnLocalPlayerTalkingUpdate) == 0x000030, "Member 'USweetChatSubsystem::OnLocalPlayerTalkingUpdate' has a wrong offset!");
static_assert(offsetof(USweetChatSubsystem, OnJoinedChannelsChanged) == 0x000040, "Member 'USweetChatSubsystem::OnJoinedChannelsChanged' has a wrong offset!");
static_assert(offsetof(USweetChatSubsystem, OnParticipantsChanged) == 0x000050, "Member 'USweetChatSubsystem::OnParticipantsChanged' has a wrong offset!");
static_assert(offsetof(USweetChatSubsystem, OnAudioDevicesChanged) == 0x000060, "Member 'USweetChatSubsystem::OnAudioDevicesChanged' has a wrong offset!");
static_assert(offsetof(USweetChatSubsystem, OnVoiceChatDisconnected) == 0x000070, "Member 'USweetChatSubsystem::OnVoiceChatDisconnected' has a wrong offset!");
static_assert(offsetof(USweetChatSubsystem, OnVoiceChatPlayerLoggedIn) == 0x000080, "Member 'USweetChatSubsystem::OnVoiceChatPlayerLoggedIn' has a wrong offset!");
static_assert(offsetof(USweetChatSubsystem, OnVoiceChatPlayerLoggedOut) == 0x000090, "Member 'USweetChatSubsystem::OnVoiceChatPlayerLoggedOut' has a wrong offset!");
static_assert(offsetof(USweetChatSubsystem, OnVoiceChatPlayerAddedToChannel) == 0x0000A0, "Member 'USweetChatSubsystem::OnVoiceChatPlayerAddedToChannel' has a wrong offset!");
static_assert(offsetof(USweetChatSubsystem, OnVoiceChatPlayerRemovedFromChannel) == 0x0000B0, "Member 'USweetChatSubsystem::OnVoiceChatPlayerRemovedFromChannel' has a wrong offset!");
static_assert(offsetof(USweetChatSubsystem, OnVoiceChatChannelJoined) == 0x0000C0, "Member 'USweetChatSubsystem::OnVoiceChatChannelJoined' has a wrong offset!");
static_assert(offsetof(USweetChatSubsystem, OnVoiceChatChannelExited) == 0x0000D0, "Member 'USweetChatSubsystem::OnVoiceChatChannelExited' has a wrong offset!");
static_assert(offsetof(USweetChatSubsystem, OnVoiceChatPlayerTalkingUpdated) == 0x0000E0, "Member 'USweetChatSubsystem::OnVoiceChatPlayerTalkingUpdated' has a wrong offset!");
static_assert(offsetof(USweetChatSubsystem, VoiceChatHandler) == 0x0000F0, "Member 'USweetChatSubsystem::VoiceChatHandler' has a wrong offset!");
static_assert(offsetof(USweetChatSubsystem, RegisteredPlayer) == 0x0000F8, "Member 'USweetChatSubsystem::RegisteredPlayer' has a wrong offset!");

// Class DeceiveInc.SweetMathBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class USweetMathBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float GetClampedRatio(float Value, float Min, float Max);
	static float GetRatio(float Value, float Min, float Max);
	static struct FColor LerpColor(const struct FColor& A, const struct FColor& B, const float Alpha);
	static int32 RandRangeExcludingInteger(int32 Min, int32 Max, int32 Excluded);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SweetMathBlueprintLibrary">();
	}
	static class USweetMathBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USweetMathBlueprintLibrary>();
	}
};
static_assert(alignof(USweetMathBlueprintLibrary) == 0x000008, "Wrong alignment on USweetMathBlueprintLibrary");
static_assert(sizeof(USweetMathBlueprintLibrary) == 0x000028, "Wrong size on USweetMathBlueprintLibrary");

// Class DeceiveInc.TeamConditionComponent
// 0x0008 (0x00D8 - 0x00D0)
class UTeamConditionComponent final : public UBaseConditionComponent
{
public:
	bool                                          bMustBeFriendly;                                   // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamConditionComponent">();
	}
	static class UTeamConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamConditionComponent>();
	}
};
static_assert(alignof(UTeamConditionComponent) == 0x000008, "Wrong alignment on UTeamConditionComponent");
static_assert(sizeof(UTeamConditionComponent) == 0x0000D8, "Wrong size on UTeamConditionComponent");
static_assert(offsetof(UTeamConditionComponent, bMustBeFriendly) == 0x0000D0, "Member 'UTeamConditionComponent::bMustBeFriendly' has a wrong offset!");

// Class DeceiveInc.TeamDataAsset
// 0x0038 (0x0070 - 0x0038)
class UTeamDataAsset final : public UDIPrimaryDataAsset
{
public:
	TArray<struct FSlateColor>                    TeammatesColor;                                    // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSlateColor                            EnnemyColor;                                       // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamDataAsset">();
	}
	static class UTeamDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamDataAsset>();
	}
};
static_assert(alignof(UTeamDataAsset) == 0x000008, "Wrong alignment on UTeamDataAsset");
static_assert(sizeof(UTeamDataAsset) == 0x000070, "Wrong size on UTeamDataAsset");
static_assert(offsetof(UTeamDataAsset, TeammatesColor) == 0x000038, "Member 'UTeamDataAsset::TeammatesColor' has a wrong offset!");
static_assert(offsetof(UTeamDataAsset, EnnemyColor) == 0x000048, "Member 'UTeamDataAsset::EnnemyColor' has a wrong offset!");

// Class DeceiveInc.TitleDataAsset
// 0x0038 (0x0070 - 0x0038)
class UTitleDataAsset final : public UDIPrimaryDataAsset
{
public:
	class FText                                   TitleDisplayName;                                  // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   TitleUnlockDescription;                            // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         TitleRarity;                                       // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleDataAsset">();
	}
	static class UTitleDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTitleDataAsset>();
	}
};
static_assert(alignof(UTitleDataAsset) == 0x000008, "Wrong alignment on UTitleDataAsset");
static_assert(sizeof(UTitleDataAsset) == 0x000070, "Wrong size on UTitleDataAsset");
static_assert(offsetof(UTitleDataAsset, TitleDisplayName) == 0x000038, "Member 'UTitleDataAsset::TitleDisplayName' has a wrong offset!");
static_assert(offsetof(UTitleDataAsset, TitleUnlockDescription) == 0x000050, "Member 'UTitleDataAsset::TitleUnlockDescription' has a wrong offset!");
static_assert(offsetof(UTitleDataAsset, TitleRarity) == 0x000068, "Member 'UTitleDataAsset::TitleRarity' has a wrong offset!");

// Class DeceiveInc.ToolLoadoutComponent
// 0x0278 (0x0328 - 0x00B0)
class UToolLoadoutComponent final : public UActorComponent
{
public:
	TSoftClassPtr<class UClass>                   MainWeaponClass;                                   // 0x00B0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ActivePowerClass;                                  // 0x00D8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PassivePowerClass;                                 // 0x0100(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   MeleeAttackClass;                                  // 0x0128(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   NavModeClass;                                      // 0x0150(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CallingCardClass;                                  // 0x0178(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SecondaryWeaponClass;                              // 0x01A0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSelectedToolChanged;                             // 0x01C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLoadoutChanged;                                  // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLoadoutSpawnComplete;                            // 0x01E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActiveAbilityLoadComplete;                       // 0x01F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMeleeAttackLoadComplete;                         // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyToolLoadComplete;                             // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActiveHandToolEvent;                             // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActiveAbilityToolEvent;                          // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMeleeAttackEvent;                                // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         ActiveCooldown_StartPercent;                       // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C[0x14];                                     // 0x025C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSpyTool*                           SelectableSlotWeapon;                              // 0x0270(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseSpyTool*                           SelectableSlotGadget1;                             // 0x0278(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseSpyTool*                           SelectableSlotGadget2;                             // 0x0280(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELoadoutSlot                                  CurrentSelectedSlot;                               // 0x0288(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACallingCardPlaceableTool*              CallingCardInstance;                               // 0x0290(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseSpyActiveAbility*                  ActivePowerInstance;                               // 0x0298(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseSpyPassiveAbility*                 PassivePowerInstance;                              // 0x02A0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseMeleeAttack*                       MeleeAttackInstance;                               // 0x02A8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseSpyTool*                           NavModeInstance;                                   // 0x02B0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseSpyTool*                           SecondarySlotWeapon;                               // 0x02B8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class AActor*>                           IgnoredActors;                                     // 0x02C0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	ELoadoutSlot                                  ForcedGadgetSlot;                                  // 0x0310(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSpyTool*                           TemporaryToolInstance;                             // 0x0318(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddActorToIgnoreList(class AActor* TargetActor);
	void BP_OnActiveAbilityToolEvent(ESpyToolEvent Event);
	void BP_OnActiveHandToolEvent(ESpyToolEvent Event, class ABaseSpyTool* SpyTool);
	void BP_OnMeleeAttackEvent(ESpyMeleeAttackEvent Event);
	void Client_SetCurrentSelectedSlot(ELoadoutSlot ServerSelectedSlot);
	void Client_SetForcedGadgetSlot(ELoadoutSlot ForcedToolSlot, bool bSwitchToSlot);
	void DisableForcedGadgetSlot(bool bSwitchToSlot);
	void EnableForcedGadgetSlot(ELoadoutSlot ForcedSelection, bool bSwitchToSlot);
	void HandleActiveAbilityToolEvent(ESpyToolEvent Event, class ABaseSpyTool* SpyTool);
	void HandleActiveHandToolEvent(ESpyToolEvent Event, class ABaseSpyTool* SpyTool);
	void HandleMeleeAttackEvent(ESpyMeleeAttackEvent Event, class ABaseMeleeAttack* MeleeAttack);
	bool IsLoadoutSpawnComplete();
	void OnRep_ActivePowerInstance(class ABaseSpyActiveAbility* OldGadget);
	void OnRep_CallingCardInstance(class ACallingCardPlaceableTool* OldGadget);
	void OnRep_CurrentSlot(ELoadoutSlot OldSelectedSlot);
	void OnRep_MeleeAttackInstance(class ABaseMeleeAttack* OldGadget);
	void OnRep_NavModeInstance(class ABaseSpyTool* OldGadget);
	void OnRep_PassivePowerInstance(class ABaseSpyPassiveAbility* OldGadget);
	void OnRep_SecondarySlotWeapon(class ABaseSpyTool* OldWeapon);
	void OnRep_SelectableSlotGadget1(class ABaseSpyTool* OldGadget);
	void OnRep_SelectableSlotGadget2(class ABaseSpyTool* OldGadget);
	void OnRep_SelectableSlotWeapon(class ABaseSpyTool* OldWeapon);
	void OnRep_TemporaryToolInstance(class ABaseSpyTool* OldTempTool);
	void RemoveActorFromIgnoreList(class AActor* TargetActor);
	void SelectHandToolFromNextSlot();
	void SelectHandToolFromPreviousSlot();
	void SelectHandToolFromSlot(ELoadoutSlot ToolSlot, bool bFromServer, bool bFromOwner);
	void Server_SelectHandToolFromSlot(ELoadoutSlot ToolSlot);

	class ABaseSpyActiveAbility* GetActivePower() const;
	class ABaseSpyTool* GetCallingCard() const;
	class ACallingCardPlaceableTool* GetCallingCardTool() const;
	class ABaseSpyTool* GetCurrentHandTool() const;
	ELoadoutSlot GetCurrentHandToolSlot() const;
	class ABaseSpyTool* GetHandToolInSlot(ELoadoutSlot ToolSlot) const;
	ELoadoutSlot GetHandToolSlot(class ABaseSpyTool* HandTool) const;
	class ABaseMeleeAttack* GetMeleeAttack() const;
	class ABaseSpyTool* GetNavModeTool() const;
	class ABaseSpyPassiveAbility* GetPassivePower() const;
	bool HasAuthority() const;
	bool IsActorInIgnoreList(class AActor* TargetActor) const;
	bool IsLocallyControlled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToolLoadoutComponent">();
	}
	static class UToolLoadoutComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UToolLoadoutComponent>();
	}
};
static_assert(alignof(UToolLoadoutComponent) == 0x000008, "Wrong alignment on UToolLoadoutComponent");
static_assert(sizeof(UToolLoadoutComponent) == 0x000328, "Wrong size on UToolLoadoutComponent");
static_assert(offsetof(UToolLoadoutComponent, MainWeaponClass) == 0x0000B0, "Member 'UToolLoadoutComponent::MainWeaponClass' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, ActivePowerClass) == 0x0000D8, "Member 'UToolLoadoutComponent::ActivePowerClass' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, PassivePowerClass) == 0x000100, "Member 'UToolLoadoutComponent::PassivePowerClass' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, MeleeAttackClass) == 0x000128, "Member 'UToolLoadoutComponent::MeleeAttackClass' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, NavModeClass) == 0x000150, "Member 'UToolLoadoutComponent::NavModeClass' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, CallingCardClass) == 0x000178, "Member 'UToolLoadoutComponent::CallingCardClass' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, SecondaryWeaponClass) == 0x0001A0, "Member 'UToolLoadoutComponent::SecondaryWeaponClass' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, OnSelectedToolChanged) == 0x0001C8, "Member 'UToolLoadoutComponent::OnSelectedToolChanged' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, OnLoadoutChanged) == 0x0001D8, "Member 'UToolLoadoutComponent::OnLoadoutChanged' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, OnLoadoutSpawnComplete) == 0x0001E8, "Member 'UToolLoadoutComponent::OnLoadoutSpawnComplete' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, OnActiveAbilityLoadComplete) == 0x0001F8, "Member 'UToolLoadoutComponent::OnActiveAbilityLoadComplete' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, OnMeleeAttackLoadComplete) == 0x000208, "Member 'UToolLoadoutComponent::OnMeleeAttackLoadComplete' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, OnSpyToolLoadComplete) == 0x000218, "Member 'UToolLoadoutComponent::OnSpyToolLoadComplete' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, OnActiveHandToolEvent) == 0x000228, "Member 'UToolLoadoutComponent::OnActiveHandToolEvent' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, OnActiveAbilityToolEvent) == 0x000238, "Member 'UToolLoadoutComponent::OnActiveAbilityToolEvent' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, OnMeleeAttackEvent) == 0x000248, "Member 'UToolLoadoutComponent::OnMeleeAttackEvent' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, ActiveCooldown_StartPercent) == 0x000258, "Member 'UToolLoadoutComponent::ActiveCooldown_StartPercent' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, SelectableSlotWeapon) == 0x000270, "Member 'UToolLoadoutComponent::SelectableSlotWeapon' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, SelectableSlotGadget1) == 0x000278, "Member 'UToolLoadoutComponent::SelectableSlotGadget1' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, SelectableSlotGadget2) == 0x000280, "Member 'UToolLoadoutComponent::SelectableSlotGadget2' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, CurrentSelectedSlot) == 0x000288, "Member 'UToolLoadoutComponent::CurrentSelectedSlot' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, CallingCardInstance) == 0x000290, "Member 'UToolLoadoutComponent::CallingCardInstance' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, ActivePowerInstance) == 0x000298, "Member 'UToolLoadoutComponent::ActivePowerInstance' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, PassivePowerInstance) == 0x0002A0, "Member 'UToolLoadoutComponent::PassivePowerInstance' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, MeleeAttackInstance) == 0x0002A8, "Member 'UToolLoadoutComponent::MeleeAttackInstance' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, NavModeInstance) == 0x0002B0, "Member 'UToolLoadoutComponent::NavModeInstance' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, SecondarySlotWeapon) == 0x0002B8, "Member 'UToolLoadoutComponent::SecondarySlotWeapon' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, IgnoredActors) == 0x0002C0, "Member 'UToolLoadoutComponent::IgnoredActors' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, ForcedGadgetSlot) == 0x000310, "Member 'UToolLoadoutComponent::ForcedGadgetSlot' has a wrong offset!");
static_assert(offsetof(UToolLoadoutComponent, TemporaryToolInstance) == 0x000318, "Member 'UToolLoadoutComponent::TemporaryToolInstance' has a wrong offset!");

// Class DeceiveInc.Tripwire
// 0x0038 (0x0350 - 0x0318)
class ATripwire final : public ABasePickablePlaceable
{
public:
	FMulticastInlineDelegateProperty_             OnIsLinkedChanged;                                 // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWireLocationsUpdated;                            // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsLinked;                                         // 0x0338(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_339[0x7];                                      // 0x0339(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWireLocationsData>             Connections;                                       // 0x0340(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_Connections();
	void OnRep_IsLinked();

	bool IsLinked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Tripwire">();
	}
	static class ATripwire* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATripwire>();
	}
};
static_assert(alignof(ATripwire) == 0x000008, "Wrong alignment on ATripwire");
static_assert(sizeof(ATripwire) == 0x000350, "Wrong size on ATripwire");
static_assert(offsetof(ATripwire, OnIsLinkedChanged) == 0x000318, "Member 'ATripwire::OnIsLinkedChanged' has a wrong offset!");
static_assert(offsetof(ATripwire, OnWireLocationsUpdated) == 0x000328, "Member 'ATripwire::OnWireLocationsUpdated' has a wrong offset!");
static_assert(offsetof(ATripwire, bIsLinked) == 0x000338, "Member 'ATripwire::bIsLinked' has a wrong offset!");
static_assert(offsetof(ATripwire, Connections) == 0x000340, "Member 'ATripwire::Connections' has a wrong offset!");

// Class DeceiveInc.TripwireTool
// 0x00F8 (0x0780 - 0x0688)
class ATripwireTool final : public ABasePlaceableSpyTool
{
public:
	FMulticastInlineDelegateProperty_             OnWireLocationsUpdated;                            // 0x0688(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpyAffectedByWire;                               // 0x0698(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLocalSpyAffectedByWire;                          // 0x06A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         MaxTripwireDistance;                               // 0x06B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TripwireAdditionalHeight;                          // 0x06BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoverDrain;                                        // 0x06C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayBetweenCoverBlow;                             // 0x06C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECoverAffectingSourceType                     CoverAffectingType;                                // 0x06C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C9[0x7];                                      // 0x06C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   AnnouncementText;                                  // 0x06D0(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	EAnnouncementType                             AnnouncementType;                                  // 0x06E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAnnouncementGroup                            AnnouncementGroup;                                 // 0x06E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6EA[0x2];                                      // 0x06EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AnnouncementPriority;                              // 0x06EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             WireRaycastCollisionChannel;                       // 0x06F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6F1[0x7];                                      // 0x06F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABasePlaceable*>                 DroppedTripwire;                                   // 0x06F8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TArray<class ABasePlaceable*>                 SpawningTripwire;                                  // 0x0708(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TArray<class ASpy*>                           AffectedSpys;                                      // 0x0718(0x0010)(ExportObject, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class ASpy*, float>                      DelayBetweenCoverBlowMap;                          // 0x0728(0x0050)(Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_778[0x8];                                      // 0x0778(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnTripwireTriggered(class ASpy* Spy);
	void HandleTripwireDropDone(class AActor* ActorDropped, const struct FVector& EndPos, const struct FRotator& EndRotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TripwireTool">();
	}
	static class ATripwireTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATripwireTool>();
	}
};
static_assert(alignof(ATripwireTool) == 0x000008, "Wrong alignment on ATripwireTool");
static_assert(sizeof(ATripwireTool) == 0x000780, "Wrong size on ATripwireTool");
static_assert(offsetof(ATripwireTool, OnWireLocationsUpdated) == 0x000688, "Member 'ATripwireTool::OnWireLocationsUpdated' has a wrong offset!");
static_assert(offsetof(ATripwireTool, OnSpyAffectedByWire) == 0x000698, "Member 'ATripwireTool::OnSpyAffectedByWire' has a wrong offset!");
static_assert(offsetof(ATripwireTool, OnLocalSpyAffectedByWire) == 0x0006A8, "Member 'ATripwireTool::OnLocalSpyAffectedByWire' has a wrong offset!");
static_assert(offsetof(ATripwireTool, MaxTripwireDistance) == 0x0006B8, "Member 'ATripwireTool::MaxTripwireDistance' has a wrong offset!");
static_assert(offsetof(ATripwireTool, TripwireAdditionalHeight) == 0x0006BC, "Member 'ATripwireTool::TripwireAdditionalHeight' has a wrong offset!");
static_assert(offsetof(ATripwireTool, CoverDrain) == 0x0006C0, "Member 'ATripwireTool::CoverDrain' has a wrong offset!");
static_assert(offsetof(ATripwireTool, DelayBetweenCoverBlow) == 0x0006C4, "Member 'ATripwireTool::DelayBetweenCoverBlow' has a wrong offset!");
static_assert(offsetof(ATripwireTool, CoverAffectingType) == 0x0006C8, "Member 'ATripwireTool::CoverAffectingType' has a wrong offset!");
static_assert(offsetof(ATripwireTool, AnnouncementText) == 0x0006D0, "Member 'ATripwireTool::AnnouncementText' has a wrong offset!");
static_assert(offsetof(ATripwireTool, AnnouncementType) == 0x0006E8, "Member 'ATripwireTool::AnnouncementType' has a wrong offset!");
static_assert(offsetof(ATripwireTool, AnnouncementGroup) == 0x0006E9, "Member 'ATripwireTool::AnnouncementGroup' has a wrong offset!");
static_assert(offsetof(ATripwireTool, AnnouncementPriority) == 0x0006EC, "Member 'ATripwireTool::AnnouncementPriority' has a wrong offset!");
static_assert(offsetof(ATripwireTool, WireRaycastCollisionChannel) == 0x0006F0, "Member 'ATripwireTool::WireRaycastCollisionChannel' has a wrong offset!");
static_assert(offsetof(ATripwireTool, DroppedTripwire) == 0x0006F8, "Member 'ATripwireTool::DroppedTripwire' has a wrong offset!");
static_assert(offsetof(ATripwireTool, SpawningTripwire) == 0x000708, "Member 'ATripwireTool::SpawningTripwire' has a wrong offset!");
static_assert(offsetof(ATripwireTool, AffectedSpys) == 0x000718, "Member 'ATripwireTool::AffectedSpys' has a wrong offset!");
static_assert(offsetof(ATripwireTool, DelayBetweenCoverBlowMap) == 0x000728, "Member 'ATripwireTool::DelayBetweenCoverBlowMap' has a wrong offset!");

// Class DeceiveInc.UndercoverConditionComponent
// 0x0008 (0x00D8 - 0x00D0)
class UUndercoverConditionComponent final : public UBaseConditionComponent
{
public:
	bool                                          bMustBeInCover;                                    // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UndercoverConditionComponent">();
	}
	static class UUndercoverConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUndercoverConditionComponent>();
	}
};
static_assert(alignof(UUndercoverConditionComponent) == 0x000008, "Wrong alignment on UUndercoverConditionComponent");
static_assert(sizeof(UUndercoverConditionComponent) == 0x0000D8, "Wrong size on UUndercoverConditionComponent");
static_assert(offsetof(UUndercoverConditionComponent, bMustBeInCover) == 0x0000D0, "Member 'UUndercoverConditionComponent::bMustBeInCover' has a wrong offset!");

// Class DeceiveInc.UnlockConditionComponent
// 0x0070 (0x0140 - 0x00D0)
class UUnlockConditionComponent final : public UBaseConditionComponent
{
public:
	FMulticastInlineDelegateProperty_             OnUnlock;                                          // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FReplicatedPlayerUnlocked>      ReplicatedPlayerUnlocked;                          // 0x00E0(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x50];                                      // 0x00F0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNewBotPlayerController(class ADeceiveIncPlayerBotController* NewPlayerBot);
	void OnPlayerLogout(class AController* ExitingController);
	void OnPlayerPostLogin(class APlayerController* NewPlayer);
	void OnRep_PlayerUnlocked();
	void OnResourceSpent(class UInteracterComponent* Interacter, EGameplayResourcesType ResourceType, int32 Amount);

	int32 GetPlayerIdFromActor(class AActor* Actor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnlockConditionComponent">();
	}
	static class UUnlockConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnlockConditionComponent>();
	}
};
static_assert(alignof(UUnlockConditionComponent) == 0x000008, "Wrong alignment on UUnlockConditionComponent");
static_assert(sizeof(UUnlockConditionComponent) == 0x000140, "Wrong size on UUnlockConditionComponent");
static_assert(offsetof(UUnlockConditionComponent, OnUnlock) == 0x0000D0, "Member 'UUnlockConditionComponent::OnUnlock' has a wrong offset!");
static_assert(offsetof(UUnlockConditionComponent, ReplicatedPlayerUnlocked) == 0x0000E0, "Member 'UUnlockConditionComponent::ReplicatedPlayerUnlocked' has a wrong offset!");

// Class DeceiveInc.VictimEffectTickBehavior_AffectCoverRegen
// 0x0020 (0x0050 - 0x0030)
class UVictimEffectTickBehavior_AffectCoverRegen final : public UVictimEffectTickBehavior
{
public:
	bool                                          bIsInstantRecover;                                 // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AddedCoverRegen;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopOnRecover;                                    // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0xF];                                       // 0x0039(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class ASpy*                                   SpyVictim;                                         // 0x0048(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VictimEffectTickBehavior_AffectCoverRegen">();
	}
	static class UVictimEffectTickBehavior_AffectCoverRegen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVictimEffectTickBehavior_AffectCoverRegen>();
	}
};
static_assert(alignof(UVictimEffectTickBehavior_AffectCoverRegen) == 0x000008, "Wrong alignment on UVictimEffectTickBehavior_AffectCoverRegen");
static_assert(sizeof(UVictimEffectTickBehavior_AffectCoverRegen) == 0x000050, "Wrong size on UVictimEffectTickBehavior_AffectCoverRegen");
static_assert(offsetof(UVictimEffectTickBehavior_AffectCoverRegen, bIsInstantRecover) == 0x000030, "Member 'UVictimEffectTickBehavior_AffectCoverRegen::bIsInstantRecover' has a wrong offset!");
static_assert(offsetof(UVictimEffectTickBehavior_AffectCoverRegen, AddedCoverRegen) == 0x000034, "Member 'UVictimEffectTickBehavior_AffectCoverRegen::AddedCoverRegen' has a wrong offset!");
static_assert(offsetof(UVictimEffectTickBehavior_AffectCoverRegen, bStopOnRecover) == 0x000038, "Member 'UVictimEffectTickBehavior_AffectCoverRegen::bStopOnRecover' has a wrong offset!");
static_assert(offsetof(UVictimEffectTickBehavior_AffectCoverRegen, SpyVictim) == 0x000048, "Member 'UVictimEffectTickBehavior_AffectCoverRegen::SpyVictim' has a wrong offset!");

// Class DeceiveInc.VictimEffectTickBehavior_Charm
// 0x0040 (0x0070 - 0x0030)
class UVictimEffectTickBehavior_Charm final : public UVictimEffectTickBehavior
{
public:
	TSubclassOf<class AVictimEffect>              AdditionalVictimEffectOnCharmBreak;                // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBrokenOnVictimSelfCoverBlowOnly;                  // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x37];                                      // 0x0039(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnServerSpyVictimUndercoverChange(bool bUndercover);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VictimEffectTickBehavior_Charm">();
	}
	static class UVictimEffectTickBehavior_Charm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVictimEffectTickBehavior_Charm>();
	}
};
static_assert(alignof(UVictimEffectTickBehavior_Charm) == 0x000008, "Wrong alignment on UVictimEffectTickBehavior_Charm");
static_assert(sizeof(UVictimEffectTickBehavior_Charm) == 0x000070, "Wrong size on UVictimEffectTickBehavior_Charm");
static_assert(offsetof(UVictimEffectTickBehavior_Charm, AdditionalVictimEffectOnCharmBreak) == 0x000030, "Member 'UVictimEffectTickBehavior_Charm::AdditionalVictimEffectOnCharmBreak' has a wrong offset!");
static_assert(offsetof(UVictimEffectTickBehavior_Charm, bBrokenOnVictimSelfCoverBlowOnly) == 0x000038, "Member 'UVictimEffectTickBehavior_Charm::bBrokenOnVictimSelfCoverBlowOnly' has a wrong offset!");

// Class DeceiveInc.VictimEffectTickBehavior_CoverBlow
// 0x0000 (0x0030 - 0x0030)
class UVictimEffectTickBehavior_CoverBlow final : public UVictimEffectTickBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VictimEffectTickBehavior_CoverBlow">();
	}
	static class UVictimEffectTickBehavior_CoverBlow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVictimEffectTickBehavior_CoverBlow>();
	}
};
static_assert(alignof(UVictimEffectTickBehavior_CoverBlow) == 0x000008, "Wrong alignment on UVictimEffectTickBehavior_CoverBlow");
static_assert(sizeof(UVictimEffectTickBehavior_CoverBlow) == 0x000030, "Wrong size on UVictimEffectTickBehavior_CoverBlow");

// Class DeceiveInc.VictimEffectTickBehavior_Damage
// 0x0008 (0x0038 - 0x0030)
class UVictimEffectTickBehavior_Damage final : public UVictimEffectTickBehavior
{
public:
	float                                         Damage;                                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cap;                                               // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VictimEffectTickBehavior_Damage">();
	}
	static class UVictimEffectTickBehavior_Damage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVictimEffectTickBehavior_Damage>();
	}
};
static_assert(alignof(UVictimEffectTickBehavior_Damage) == 0x000008, "Wrong alignment on UVictimEffectTickBehavior_Damage");
static_assert(sizeof(UVictimEffectTickBehavior_Damage) == 0x000038, "Wrong size on UVictimEffectTickBehavior_Damage");
static_assert(offsetof(UVictimEffectTickBehavior_Damage, Damage) == 0x000030, "Member 'UVictimEffectTickBehavior_Damage::Damage' has a wrong offset!");
static_assert(offsetof(UVictimEffectTickBehavior_Damage, Cap) == 0x000034, "Member 'UVictimEffectTickBehavior_Damage::Cap' has a wrong offset!");

// Class DeceiveInc.VictimEffectTickBehavior_Disarmed
// 0x0030 (0x0060 - 0x0030)
class UVictimEffectTickBehavior_Disarmed final : public UVictimEffectTickBehavior
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VictimEffectTickBehavior_Disarmed">();
	}
	static class UVictimEffectTickBehavior_Disarmed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVictimEffectTickBehavior_Disarmed>();
	}
};
static_assert(alignof(UVictimEffectTickBehavior_Disarmed) == 0x000008, "Wrong alignment on UVictimEffectTickBehavior_Disarmed");
static_assert(sizeof(UVictimEffectTickBehavior_Disarmed) == 0x000060, "Wrong size on UVictimEffectTickBehavior_Disarmed");

// Class DeceiveInc.VictimEffectTickBehavior_InstantDamage
// 0x0010 (0x0040 - 0x0030)
class UVictimEffectTickBehavior_InstantDamage final : public UVictimEffectTickBehavior
{
public:
	float                                         Damage;                                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cap;                                               // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VictimEffectTickBehavior_InstantDamage">();
	}
	static class UVictimEffectTickBehavior_InstantDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVictimEffectTickBehavior_InstantDamage>();
	}
};
static_assert(alignof(UVictimEffectTickBehavior_InstantDamage) == 0x000008, "Wrong alignment on UVictimEffectTickBehavior_InstantDamage");
static_assert(sizeof(UVictimEffectTickBehavior_InstantDamage) == 0x000040, "Wrong size on UVictimEffectTickBehavior_InstantDamage");
static_assert(offsetof(UVictimEffectTickBehavior_InstantDamage, Damage) == 0x000030, "Member 'UVictimEffectTickBehavior_InstantDamage::Damage' has a wrong offset!");
static_assert(offsetof(UVictimEffectTickBehavior_InstantDamage, Cap) == 0x000034, "Member 'UVictimEffectTickBehavior_InstantDamage::Cap' has a wrong offset!");

// Class DeceiveInc.VictimEffectTickBehavior_NoAggro
// 0x0050 (0x0080 - 0x0030)
class UVictimEffectTickBehavior_NoAggro final : public UVictimEffectTickBehavior
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VictimEffectTickBehavior_NoAggro">();
	}
	static class UVictimEffectTickBehavior_NoAggro* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVictimEffectTickBehavior_NoAggro>();
	}
};
static_assert(alignof(UVictimEffectTickBehavior_NoAggro) == 0x000008, "Wrong alignment on UVictimEffectTickBehavior_NoAggro");
static_assert(sizeof(UVictimEffectTickBehavior_NoAggro) == 0x000080, "Wrong size on UVictimEffectTickBehavior_NoAggro");

// Class DeceiveInc.VictimEffectTickBehavior_Poison
// 0x0048 (0x0078 - 0x0030)
class UVictimEffectTickBehavior_Poison final : public UVictimEffectTickBehavior
{
public:
	TSoftObjectPtr<class AActor>                  PoisonedVictim;                                    // 0x0030(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 EffectInstigator;                                  // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlockHealing;                                     // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EInteractableType>                     InteractableTypeToNotBlock;                        // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void HandleInteractionComplete(class UInteracterComponent* Interacter, class UInteractableComponent* Interactable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VictimEffectTickBehavior_Poison">();
	}
	static class UVictimEffectTickBehavior_Poison* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVictimEffectTickBehavior_Poison>();
	}
};
static_assert(alignof(UVictimEffectTickBehavior_Poison) == 0x000008, "Wrong alignment on UVictimEffectTickBehavior_Poison");
static_assert(sizeof(UVictimEffectTickBehavior_Poison) == 0x000078, "Wrong size on UVictimEffectTickBehavior_Poison");
static_assert(offsetof(UVictimEffectTickBehavior_Poison, PoisonedVictim) == 0x000030, "Member 'UVictimEffectTickBehavior_Poison::PoisonedVictim' has a wrong offset!");
static_assert(offsetof(UVictimEffectTickBehavior_Poison, EffectInstigator) == 0x000058, "Member 'UVictimEffectTickBehavior_Poison::EffectInstigator' has a wrong offset!");
static_assert(offsetof(UVictimEffectTickBehavior_Poison, bBlockHealing) == 0x000060, "Member 'UVictimEffectTickBehavior_Poison::bBlockHealing' has a wrong offset!");
static_assert(offsetof(UVictimEffectTickBehavior_Poison, InteractableTypeToNotBlock) == 0x000068, "Member 'UVictimEffectTickBehavior_Poison::InteractableTypeToNotBlock' has a wrong offset!");

// Class DeceiveInc.VictimEffectTickBehavior_Suppress
// 0x0010 (0x0068 - 0x0058)
class UVictimEffectTickBehavior_Suppress final : public UVictimEffectTickBehavior_Silence
{
public:
	class AActor*                                 SuppressedSpy;                                     // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 EffectInstigator;                                  // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VictimEffectTickBehavior_Suppress">();
	}
	static class UVictimEffectTickBehavior_Suppress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVictimEffectTickBehavior_Suppress>();
	}
};
static_assert(alignof(UVictimEffectTickBehavior_Suppress) == 0x000008, "Wrong alignment on UVictimEffectTickBehavior_Suppress");
static_assert(sizeof(UVictimEffectTickBehavior_Suppress) == 0x000068, "Wrong size on UVictimEffectTickBehavior_Suppress");
static_assert(offsetof(UVictimEffectTickBehavior_Suppress, SuppressedSpy) == 0x000058, "Member 'UVictimEffectTickBehavior_Suppress::SuppressedSpy' has a wrong offset!");
static_assert(offsetof(UVictimEffectTickBehavior_Suppress, EffectInstigator) == 0x000060, "Member 'UVictimEffectTickBehavior_Suppress::EffectInstigator' has a wrong offset!");

// Class DeceiveInc.VictimEffectTickBehavior_Trace
// 0x0018 (0x0048 - 0x0030)
class UVictimEffectTickBehavior_Trace final : public UVictimEffectTickBehavior
{
public:
	class AActor*                                 TraceVictim;                                       // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraceDuration;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TracedVictim;                                      // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnTraceBegin(class UVictimEffectTickBehavior_Trace* InTrace, class AActor* InTraceVictim);
	void OnTraceEnd(class UVictimEffectTickBehavior_Trace* InTrace, class AActor* InTraceVictim);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VictimEffectTickBehavior_Trace">();
	}
	static class UVictimEffectTickBehavior_Trace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVictimEffectTickBehavior_Trace>();
	}
};
static_assert(alignof(UVictimEffectTickBehavior_Trace) == 0x000008, "Wrong alignment on UVictimEffectTickBehavior_Trace");
static_assert(sizeof(UVictimEffectTickBehavior_Trace) == 0x000048, "Wrong size on UVictimEffectTickBehavior_Trace");
static_assert(offsetof(UVictimEffectTickBehavior_Trace, TraceVictim) == 0x000030, "Member 'UVictimEffectTickBehavior_Trace::TraceVictim' has a wrong offset!");
static_assert(offsetof(UVictimEffectTickBehavior_Trace, TraceDuration) == 0x000038, "Member 'UVictimEffectTickBehavior_Trace::TraceDuration' has a wrong offset!");
static_assert(offsetof(UVictimEffectTickBehavior_Trace, TracedVictim) == 0x000040, "Member 'UVictimEffectTickBehavior_Trace::TracedVictim' has a wrong offset!");

// Class DeceiveInc.VictimEffectUserWidget
// 0x0010 (0x02B0 - 0x02A0)
class UVictimEffectUserWidget final : public UDIUserWidget
{
public:
	class AVictimEffect*                          VictimEffect;                                      // 0x02A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AVictimEffect>              ListenToEffect;                                    // 0x02A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float GetProgressRatio();
	float GetProgressRatioInverted();
	void HandleAddVictimEffect(class AVictimEffect* Effect);
	void HandleRemoveVictimEffect(class AVictimEffect* Effect);
	void SetupVictim(class AVictimEffect* Victim);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VictimEffectUserWidget">();
	}
	static class UVictimEffectUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVictimEffectUserWidget>();
	}
};
static_assert(alignof(UVictimEffectUserWidget) == 0x000008, "Wrong alignment on UVictimEffectUserWidget");
static_assert(sizeof(UVictimEffectUserWidget) == 0x0002B0, "Wrong size on UVictimEffectUserWidget");
static_assert(offsetof(UVictimEffectUserWidget, VictimEffect) == 0x0002A0, "Member 'UVictimEffectUserWidget::VictimEffect' has a wrong offset!");
static_assert(offsetof(UVictimEffectUserWidget, ListenToEffect) == 0x0002A8, "Member 'UVictimEffectUserWidget::ListenToEffect' has a wrong offset!");

// Class DeceiveInc.VigilPassiveAbilityDeviceBased
// 0x01E0 (0x0710 - 0x0530)
class AVigilPassiveAbilityDeviceBased final : public ABaseSpyPassiveAbility
{
public:
	uint8                                         Pad_530[0x8];                                      // 0x0530(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnProjectilesReleased;                             // 0x0538(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnProjectilesAbort;                                // 0x0548(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnShowProjectiles;                                 // 0x0558(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnDeviceThrowDelayStart;                           // 0x0568(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnDeviceThrowDelayEnd;                             // 0x0578(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnDeviceThrowOutDelayEnd;                          // 0x0588(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnDeviceStuckChange;                               // 0x0598(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   DeviceToSpawnClass;                                // 0x05A8(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   WeaponRoundToSpawnClass;                           // 0x05D0(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PassiveCooldown;                                   // 0x05F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SpyShootSocketName;                                // 0x05FC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpyShootEffectiveRange;                            // 0x0604(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowDelay1P;                                      // 0x0608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowOutTime1P;                                    // 0x060C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowDelay3P;                                      // 0x0610(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowOutlTime3P;                                   // 0x0614(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SpyFrontSocketName;                                // 0x0618(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SpyBackSocketName;                                 // 0x0620(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   NPCFrontSocketName;                                // 0x0628(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   NPCBackSocketName;                                 // 0x0630(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseVictimCapsuleAsOffset;                         // 0x0638(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanStickToSurface;                                // 0x0639(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanStickToNPC;                                    // 0x063A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanStickToSpy;                                    // 0x063B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_63C[0x4];                                      // 0x063C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   StartAnnouncementText;                             // 0x0640(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class FText                                   EndAnnouncementText;                               // 0x0658(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	int32                                         AnnouncementPriority;                              // 0x0670(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnnouncementDuration;                              // 0x0674(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASpy*                                   SpyOwner;                                          // 0x0678(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseMeleeAttack*                       OwnerMeleeAttack;                                  // 0x0680(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AProjectileWeapon*                      OwnerWeapon;                                       // 0x0688(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AProjectileWeapon*                      AbilityWeapon;                                     // 0x0690(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASpawnerWeaponRound*                    WeaponRound;                                       // 0x0698(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A0[0x30];                                     // 0x06A0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Device;                                            // 0x06D0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 RealVictim;                                        // 0x06D8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6E0[0x30];                                     // 0x06E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleAbilityWeaponSpawned(class AVigilActiveAbility* Active, class AProjectileWeapon* Weapon);
	void HandleADSChanged(bool bInADS);
	void HandleDeviceDestroyed(class AActor* DestroyedActor);
	void HandleLoadoutSpawnCompleteEvent(class UToolLoadoutComponent* LoadoutComponent);
	void HandleMeleeSpyToolEvent(ESpyToolEvent EventType, class ABaseSpyTool* SpyTool);
	void HandleSpyTransformInMimic(class ASpy* Spy, class ABaseMimicScannableActor* Mimic);
	void HandleVictimCoverChange(bool bUndercover);
	void HandleVictimCoverSwitch(class ANPCCharacter* NewDisguise);
	void NetMulticast_FireDevice(const struct FVector_NetQuantize& OriginPosition, const struct FVector_NetQuantize& DestinationPos);
	void NetMulticast_OnVictimAnnouncementEnd(class ASpy* SpyVictim);
	void NetMulticast_OnVictimAnnouncementStart(class ASpy* SpyVictim);
	void NetMulticast_StartDeviceThrow();
	void NetMultucast_OnDeviceSpawnFailed();
	void OnPassiveCooldownTimerEnd();
	void OnRep_Device();
	void OnRep_RealVictim(class AActor* OldRealVictim);
	void OnThrowDelayTimerEnd(bool bIsLocal);
	void OnThrowOutDelayTimerEnd();
	void Server_FireDevice(const struct FVector_NetQuantize& OriginPosition, const struct FVector_NetQuantize& DestinationPos);
	void Server_SpawnDevice(const struct FVector_NetQuantize& HitLocation, const struct FVector_NetQuantize& HitNormal, class AActor* ActorHit);
	void Server_StartDeviceThrow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VigilPassiveAbilityDeviceBased">();
	}
	static class AVigilPassiveAbilityDeviceBased* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVigilPassiveAbilityDeviceBased>();
	}
};
static_assert(alignof(AVigilPassiveAbilityDeviceBased) == 0x000008, "Wrong alignment on AVigilPassiveAbilityDeviceBased");
static_assert(sizeof(AVigilPassiveAbilityDeviceBased) == 0x000710, "Wrong size on AVigilPassiveAbilityDeviceBased");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, OnProjectilesReleased) == 0x000538, "Member 'AVigilPassiveAbilityDeviceBased::OnProjectilesReleased' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, OnProjectilesAbort) == 0x000548, "Member 'AVigilPassiveAbilityDeviceBased::OnProjectilesAbort' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, OnShowProjectiles) == 0x000558, "Member 'AVigilPassiveAbilityDeviceBased::OnShowProjectiles' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, OnDeviceThrowDelayStart) == 0x000568, "Member 'AVigilPassiveAbilityDeviceBased::OnDeviceThrowDelayStart' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, OnDeviceThrowDelayEnd) == 0x000578, "Member 'AVigilPassiveAbilityDeviceBased::OnDeviceThrowDelayEnd' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, OnDeviceThrowOutDelayEnd) == 0x000588, "Member 'AVigilPassiveAbilityDeviceBased::OnDeviceThrowOutDelayEnd' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, OnDeviceStuckChange) == 0x000598, "Member 'AVigilPassiveAbilityDeviceBased::OnDeviceStuckChange' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, DeviceToSpawnClass) == 0x0005A8, "Member 'AVigilPassiveAbilityDeviceBased::DeviceToSpawnClass' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, WeaponRoundToSpawnClass) == 0x0005D0, "Member 'AVigilPassiveAbilityDeviceBased::WeaponRoundToSpawnClass' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, PassiveCooldown) == 0x0005F8, "Member 'AVigilPassiveAbilityDeviceBased::PassiveCooldown' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, SpyShootSocketName) == 0x0005FC, "Member 'AVigilPassiveAbilityDeviceBased::SpyShootSocketName' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, SpyShootEffectiveRange) == 0x000604, "Member 'AVigilPassiveAbilityDeviceBased::SpyShootEffectiveRange' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, ThrowDelay1P) == 0x000608, "Member 'AVigilPassiveAbilityDeviceBased::ThrowDelay1P' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, ThrowOutTime1P) == 0x00060C, "Member 'AVigilPassiveAbilityDeviceBased::ThrowOutTime1P' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, ThrowDelay3P) == 0x000610, "Member 'AVigilPassiveAbilityDeviceBased::ThrowDelay3P' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, ThrowOutlTime3P) == 0x000614, "Member 'AVigilPassiveAbilityDeviceBased::ThrowOutlTime3P' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, SpyFrontSocketName) == 0x000618, "Member 'AVigilPassiveAbilityDeviceBased::SpyFrontSocketName' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, SpyBackSocketName) == 0x000620, "Member 'AVigilPassiveAbilityDeviceBased::SpyBackSocketName' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, NPCFrontSocketName) == 0x000628, "Member 'AVigilPassiveAbilityDeviceBased::NPCFrontSocketName' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, NPCBackSocketName) == 0x000630, "Member 'AVigilPassiveAbilityDeviceBased::NPCBackSocketName' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, bUseVictimCapsuleAsOffset) == 0x000638, "Member 'AVigilPassiveAbilityDeviceBased::bUseVictimCapsuleAsOffset' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, bCanStickToSurface) == 0x000639, "Member 'AVigilPassiveAbilityDeviceBased::bCanStickToSurface' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, bCanStickToNPC) == 0x00063A, "Member 'AVigilPassiveAbilityDeviceBased::bCanStickToNPC' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, bCanStickToSpy) == 0x00063B, "Member 'AVigilPassiveAbilityDeviceBased::bCanStickToSpy' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, StartAnnouncementText) == 0x000640, "Member 'AVigilPassiveAbilityDeviceBased::StartAnnouncementText' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, EndAnnouncementText) == 0x000658, "Member 'AVigilPassiveAbilityDeviceBased::EndAnnouncementText' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, AnnouncementPriority) == 0x000670, "Member 'AVigilPassiveAbilityDeviceBased::AnnouncementPriority' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, AnnouncementDuration) == 0x000674, "Member 'AVigilPassiveAbilityDeviceBased::AnnouncementDuration' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, SpyOwner) == 0x000678, "Member 'AVigilPassiveAbilityDeviceBased::SpyOwner' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, OwnerMeleeAttack) == 0x000680, "Member 'AVigilPassiveAbilityDeviceBased::OwnerMeleeAttack' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, OwnerWeapon) == 0x000688, "Member 'AVigilPassiveAbilityDeviceBased::OwnerWeapon' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, AbilityWeapon) == 0x000690, "Member 'AVigilPassiveAbilityDeviceBased::AbilityWeapon' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, WeaponRound) == 0x000698, "Member 'AVigilPassiveAbilityDeviceBased::WeaponRound' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, Device) == 0x0006D0, "Member 'AVigilPassiveAbilityDeviceBased::Device' has a wrong offset!");
static_assert(offsetof(AVigilPassiveAbilityDeviceBased, RealVictim) == 0x0006D8, "Member 'AVigilPassiveAbilityDeviceBased::RealVictim' has a wrong offset!");

// Class DeceiveInc.VoiceChatControlPanelEntryWidget
// 0x0020 (0x0280 - 0x0260)
class UVoiceChatControlPanelEntryWidget final : public UUserWidget
{
public:
	class ADIPlayerState*                         PlayerState;                                       // 0x0260(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 PlayerName;                                        // 0x0268(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Volume;                                            // 0x0278(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMuted;                                            // 0x027C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27D[0x3];                                      // 0x027D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnPlayerMutedChange();
	void BP_OnPlayerNameChange();
	void BP_OnPlayerStateChange();
	void BP_OnPlayerVolumeChange();
	void SetMuted(bool bInMuted);
	void SetVolume(float NewVolume);

	float GetVolume() const;
	bool IsLocalPlayer() const;
	bool IsMuted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoiceChatControlPanelEntryWidget">();
	}
	static class UVoiceChatControlPanelEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoiceChatControlPanelEntryWidget>();
	}
};
static_assert(alignof(UVoiceChatControlPanelEntryWidget) == 0x000008, "Wrong alignment on UVoiceChatControlPanelEntryWidget");
static_assert(sizeof(UVoiceChatControlPanelEntryWidget) == 0x000280, "Wrong size on UVoiceChatControlPanelEntryWidget");
static_assert(offsetof(UVoiceChatControlPanelEntryWidget, PlayerState) == 0x000260, "Member 'UVoiceChatControlPanelEntryWidget::PlayerState' has a wrong offset!");
static_assert(offsetof(UVoiceChatControlPanelEntryWidget, PlayerName) == 0x000268, "Member 'UVoiceChatControlPanelEntryWidget::PlayerName' has a wrong offset!");
static_assert(offsetof(UVoiceChatControlPanelEntryWidget, Volume) == 0x000278, "Member 'UVoiceChatControlPanelEntryWidget::Volume' has a wrong offset!");
static_assert(offsetof(UVoiceChatControlPanelEntryWidget, bMuted) == 0x00027C, "Member 'UVoiceChatControlPanelEntryWidget::bMuted' has a wrong offset!");

// Class DeceiveInc.VoiceChatControlPanelWidget
// 0x0010 (0x0270 - 0x0260)
class UVoiceChatControlPanelWidget final : public UUserWidget
{
public:
	TArray<class UVoiceChatControlPanelEntryWidget*> Entries;                                           // 0x0260(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoiceChatControlPanelWidget">();
	}
	static class UVoiceChatControlPanelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoiceChatControlPanelWidget>();
	}
};
static_assert(alignof(UVoiceChatControlPanelWidget) == 0x000008, "Wrong alignment on UVoiceChatControlPanelWidget");
static_assert(sizeof(UVoiceChatControlPanelWidget) == 0x000270, "Wrong size on UVoiceChatControlPanelWidget");
static_assert(offsetof(UVoiceChatControlPanelWidget, Entries) == 0x000260, "Member 'UVoiceChatControlPanelWidget::Entries' has a wrong offset!");

// Class DeceiveInc.VoicechatMemberWidget
// 0x0020 (0x0280 - 0x0260)
class UVoicechatMemberWidget : public UUserWidget
{
public:
	class ADIPlayerState*                         PlayerState;                                       // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_268[0x18];                                     // 0x0268(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerInfoUpdated();

	ESlateVisibility GetIntendedVisibility() const;
	class ADIPlayerState* GetPlayerState() const;
	class FString GetUserName() const;
	EPlatformType GetUserPlatform() const;
	bool IsPlayerTalking() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoicechatMemberWidget">();
	}
	static class UVoicechatMemberWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoicechatMemberWidget>();
	}
};
static_assert(alignof(UVoicechatMemberWidget) == 0x000008, "Wrong alignment on UVoicechatMemberWidget");
static_assert(sizeof(UVoicechatMemberWidget) == 0x000280, "Wrong size on UVoicechatMemberWidget");
static_assert(offsetof(UVoicechatMemberWidget, PlayerState) == 0x000260, "Member 'UVoicechatMemberWidget::PlayerState' has a wrong offset!");

// Class DeceiveInc.WeaponOverheatComponent
// 0x0038 (0x00E8 - 0x00B0)
class UWeaponOverheatComponent final : public UActorComponent
{
public:
	float                                         HeatIncreasePerShot;                               // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeatDecreasePerSec;                                // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeatDecreaseDelay;                                 // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverheatDuration;                                  // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockPlayerInWeaponWhileOverheating;               // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnWeaponHeatChange;                                // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bBlockLeftHandFlavorAnimationsOnOverheat;          // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0xF];                                       // 0x00D9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MulticastOverheatStart();
	void OnHeatDecreaseDelayTimerEnd();
	void OnShotCycleBegin();
	void OnShotCycleEnd();
	void OnWeaponDisabledChange(class AProjectileWeapon* Weapon, bool bDisabled);
	void OnWeaponShot(const struct FVector& ShotEndPoint, class AProjectileWeapon* Weapon);

	float GetCurWeaponHeat() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponOverheatComponent">();
	}
	static class UWeaponOverheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponOverheatComponent>();
	}
};
static_assert(alignof(UWeaponOverheatComponent) == 0x000008, "Wrong alignment on UWeaponOverheatComponent");
static_assert(sizeof(UWeaponOverheatComponent) == 0x0000E8, "Wrong size on UWeaponOverheatComponent");
static_assert(offsetof(UWeaponOverheatComponent, HeatIncreasePerShot) == 0x0000B0, "Member 'UWeaponOverheatComponent::HeatIncreasePerShot' has a wrong offset!");
static_assert(offsetof(UWeaponOverheatComponent, HeatDecreasePerSec) == 0x0000B4, "Member 'UWeaponOverheatComponent::HeatDecreasePerSec' has a wrong offset!");
static_assert(offsetof(UWeaponOverheatComponent, HeatDecreaseDelay) == 0x0000B8, "Member 'UWeaponOverheatComponent::HeatDecreaseDelay' has a wrong offset!");
static_assert(offsetof(UWeaponOverheatComponent, OverheatDuration) == 0x0000BC, "Member 'UWeaponOverheatComponent::OverheatDuration' has a wrong offset!");
static_assert(offsetof(UWeaponOverheatComponent, bLockPlayerInWeaponWhileOverheating) == 0x0000C0, "Member 'UWeaponOverheatComponent::bLockPlayerInWeaponWhileOverheating' has a wrong offset!");
static_assert(offsetof(UWeaponOverheatComponent, OnWeaponHeatChange) == 0x0000C8, "Member 'UWeaponOverheatComponent::OnWeaponHeatChange' has a wrong offset!");
static_assert(offsetof(UWeaponOverheatComponent, bBlockLeftHandFlavorAnimationsOnOverheat) == 0x0000D8, "Member 'UWeaponOverheatComponent::bBlockLeftHandFlavorAnimationsOnOverheat' has a wrong offset!");

// Class DeceiveInc.WeaponSprayDataAsset
// 0x0010 (0x0040 - 0x0030)
class UWeaponSprayDataAsset final : public UDataAsset
{
public:
	TArray<struct FVector2D>                      BulletOffsets;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponSprayDataAsset">();
	}
	static class UWeaponSprayDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponSprayDataAsset>();
	}
};
static_assert(alignof(UWeaponSprayDataAsset) == 0x000008, "Wrong alignment on UWeaponSprayDataAsset");
static_assert(sizeof(UWeaponSprayDataAsset) == 0x000040, "Wrong size on UWeaponSprayDataAsset");
static_assert(offsetof(UWeaponSprayDataAsset, BulletOffsets) == 0x000030, "Member 'UWeaponSprayDataAsset::BulletOffsets' has a wrong offset!");

// Class DeceiveInc.WebStreamedFanartAsset
// 0x0030 (0x02A0 - 0x0270)
class AWebStreamedFanartAsset final : public AWebStreamedVisualAsset
{
public:
	struct FFanartAssetDefinition                 FanartAssetDefinition;                             // 0x0270(0x0030)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void BP_OnFanartAssetDefinitionUpdated();
	void OnRep_FanartAssetDefinition();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WebStreamedFanartAsset">();
	}
	static class AWebStreamedFanartAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWebStreamedFanartAsset>();
	}
};
static_assert(alignof(AWebStreamedFanartAsset) == 0x000008, "Wrong alignment on AWebStreamedFanartAsset");
static_assert(sizeof(AWebStreamedFanartAsset) == 0x0002A0, "Wrong size on AWebStreamedFanartAsset");
static_assert(offsetof(AWebStreamedFanartAsset, FanartAssetDefinition) == 0x000270, "Member 'AWebStreamedFanartAsset::FanartAssetDefinition' has a wrong offset!");

// Class DeceiveInc.XiuActiveAbility
// 0x01D8 (0x0768 - 0x0590)
class AXiuActiveAbility final : public ABaseSpyActiveAbility
{
public:
	FMulticastInlineDelegateProperty_             OnLocalXiuTravelStartEvent;                        // 0x0590(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLocalXiuTravelEndEvent;                          // 0x05A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLocalXiuActiveTargetSelected;                    // 0x05B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLocalXiuActiveTargetChanged;                     // 0x05C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         AbilityRange;                                      // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AbilityHeight;                                     // 0x05D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxTimeBetweenJumps;                               // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5DC[0x4];                                      // 0x05DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     TravelCamRefBPClass;                               // 0x05E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     TargetUIBPClass;                                   // 0x05E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AVictimEffect>              TargetVictimEffect;                                // 0x05F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraTravelDuration;                              // 0x05F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumberOfJumps;                                     // 0x05FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTwoStepTeleportation;                             // 0x0600(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_601[0x3];                                      // 0x0601(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StoredTargetDecay;                                 // 0x0604(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostCompletedDuration;                             // 0x0608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60C[0xF4];                                     // 0x060C(0x00F4)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LocalCameraTravelRef;                              // 0x0700(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 TargetUI;                                          // 0x0708(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_710[0x28];                                     // 0x0710(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentJumpCount;                                  // 0x0738(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_73C[0x4];                                      // 0x073C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AVictimEffect*                          TagetEffect;                                       // 0x0740(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_748[0x20];                                     // 0x0748(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnLocalNewXiuActiveTarget(class ANPCCharacter* PrevBestNPCTargetIn, class ANPCCharacter* NewBestNPCTargetIn);
	void BP_OnLocalXiuActiveTargetSelected(class ANPCCharacter* SelectedTarget);
	void BP_OnLocalXiuTravelEnd(class ANPCCharacter* TarvelToNPC);
	void BP_OnLocalXiuTravelStart(class ANPCCharacter* TarvelToNPC);
	void BP_OnXiuTravelStart(class ANPCCharacter* PrevNPC, class ANPCCharacter* TarvelToNPC);
	void NetMulticast_OnTravelStart(class ANPCCharacter* PrevNPC, class ANPCCharacter* TarvelToNPC);
	void OnPostCompletedTimerEnd();
	void OnServerResetTargetNPC();
	void OnServerTravelEnd();
	void OnStoredTargetDeath();
	void OnStoredTargetDisguiseCoverBlown();
	void OnStoredTargetFellOutOfWorld(class ANPCCharacter* NPCThatFell);
	void OnStoredTargetVisibilityChanged(bool bNewVisibility);
	void Server_SetTarget(class ANPCCharacter* NewTarget);
	void Server_StartTravel(class ANPCCharacter* TravelToTarget);
	void Server_TargetDecayed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"XiuActiveAbility">();
	}
	static class AXiuActiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<AXiuActiveAbility>();
	}
};
static_assert(alignof(AXiuActiveAbility) == 0x000008, "Wrong alignment on AXiuActiveAbility");
static_assert(sizeof(AXiuActiveAbility) == 0x000768, "Wrong size on AXiuActiveAbility");
static_assert(offsetof(AXiuActiveAbility, OnLocalXiuTravelStartEvent) == 0x000590, "Member 'AXiuActiveAbility::OnLocalXiuTravelStartEvent' has a wrong offset!");
static_assert(offsetof(AXiuActiveAbility, OnLocalXiuTravelEndEvent) == 0x0005A0, "Member 'AXiuActiveAbility::OnLocalXiuTravelEndEvent' has a wrong offset!");
static_assert(offsetof(AXiuActiveAbility, OnLocalXiuActiveTargetSelected) == 0x0005B0, "Member 'AXiuActiveAbility::OnLocalXiuActiveTargetSelected' has a wrong offset!");
static_assert(offsetof(AXiuActiveAbility, OnLocalXiuActiveTargetChanged) == 0x0005C0, "Member 'AXiuActiveAbility::OnLocalXiuActiveTargetChanged' has a wrong offset!");
static_assert(offsetof(AXiuActiveAbility, AbilityRange) == 0x0005D0, "Member 'AXiuActiveAbility::AbilityRange' has a wrong offset!");
static_assert(offsetof(AXiuActiveAbility, AbilityHeight) == 0x0005D4, "Member 'AXiuActiveAbility::AbilityHeight' has a wrong offset!");
static_assert(offsetof(AXiuActiveAbility, MaxTimeBetweenJumps) == 0x0005D8, "Member 'AXiuActiveAbility::MaxTimeBetweenJumps' has a wrong offset!");
static_assert(offsetof(AXiuActiveAbility, TravelCamRefBPClass) == 0x0005E0, "Member 'AXiuActiveAbility::TravelCamRefBPClass' has a wrong offset!");
static_assert(offsetof(AXiuActiveAbility, TargetUIBPClass) == 0x0005E8, "Member 'AXiuActiveAbility::TargetUIBPClass' has a wrong offset!");
static_assert(offsetof(AXiuActiveAbility, TargetVictimEffect) == 0x0005F0, "Member 'AXiuActiveAbility::TargetVictimEffect' has a wrong offset!");
static_assert(offsetof(AXiuActiveAbility, CameraTravelDuration) == 0x0005F8, "Member 'AXiuActiveAbility::CameraTravelDuration' has a wrong offset!");
static_assert(offsetof(AXiuActiveAbility, NumberOfJumps) == 0x0005FC, "Member 'AXiuActiveAbility::NumberOfJumps' has a wrong offset!");
static_assert(offsetof(AXiuActiveAbility, bTwoStepTeleportation) == 0x000600, "Member 'AXiuActiveAbility::bTwoStepTeleportation' has a wrong offset!");
static_assert(offsetof(AXiuActiveAbility, StoredTargetDecay) == 0x000604, "Member 'AXiuActiveAbility::StoredTargetDecay' has a wrong offset!");
static_assert(offsetof(AXiuActiveAbility, PostCompletedDuration) == 0x000608, "Member 'AXiuActiveAbility::PostCompletedDuration' has a wrong offset!");
static_assert(offsetof(AXiuActiveAbility, LocalCameraTravelRef) == 0x000700, "Member 'AXiuActiveAbility::LocalCameraTravelRef' has a wrong offset!");
static_assert(offsetof(AXiuActiveAbility, TargetUI) == 0x000708, "Member 'AXiuActiveAbility::TargetUI' has a wrong offset!");
static_assert(offsetof(AXiuActiveAbility, CurrentJumpCount) == 0x000738, "Member 'AXiuActiveAbility::CurrentJumpCount' has a wrong offset!");
static_assert(offsetof(AXiuActiveAbility, TagetEffect) == 0x000740, "Member 'AXiuActiveAbility::TagetEffect' has a wrong offset!");

// Class DeceiveInc.XiuPassiveAbility
// 0x0010 (0x0540 - 0x0530)
class AXiuPassiveAbility final : public ABaseSpyPassiveAbility
{
public:
	float                                         DetectionRange;                                    // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetectionHeight;                                   // 0x0534(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SocketToUse;                                       // 0x0538(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BP_OnCoverBlownDetected(const struct FVector& CoverBlownPosition);
	void ClientSignalCoverBlownAtLocation(const struct FVector_NetQuantize& CoverBlownPosition);
	void HandleCoverBlownEvent(class ASpy* Spy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"XiuPassiveAbility">();
	}
	static class AXiuPassiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<AXiuPassiveAbility>();
	}
};
static_assert(alignof(AXiuPassiveAbility) == 0x000008, "Wrong alignment on AXiuPassiveAbility");
static_assert(sizeof(AXiuPassiveAbility) == 0x000540, "Wrong size on AXiuPassiveAbility");
static_assert(offsetof(AXiuPassiveAbility, DetectionRange) == 0x000530, "Member 'AXiuPassiveAbility::DetectionRange' has a wrong offset!");
static_assert(offsetof(AXiuPassiveAbility, DetectionHeight) == 0x000534, "Member 'AXiuPassiveAbility::DetectionHeight' has a wrong offset!");
static_assert(offsetof(AXiuPassiveAbility, SocketToUse) == 0x000538, "Member 'AXiuPassiveAbility::SocketToUse' has a wrong offset!");

// Class DeceiveInc.XiuPassiveAbilityMod2
// 0x0020 (0x0550 - 0x0530)
class AXiuPassiveAbilityMod2 final : public ABaseSpyPassiveAbility
{
public:
	TArray<ESpyGamePhase>                         PhaseToShowSpys;                                   // 0x0530(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         TimeToShowPing;                                    // 0x0540(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayBetweenPing;                                  // 0x0544(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_548[0x8];                                      // 0x0548(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_ShowSpys(const TArray<class ASpy*>& Spys);
	float GetTimeToShowPing();
	void HandleExtractionStateChanged();
	void HandleGamePhaseChanged(ESpyGamePhase NewGamePhase);
	void HandleVaultTerminalDeactivation(class ADIPlayerState* PlayerState, int32 FactionID);
	void HandleVaultTerminalUnlock(float UnlockValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"XiuPassiveAbilityMod2">();
	}
	static class AXiuPassiveAbilityMod2* GetDefaultObj()
	{
		return GetDefaultObjImpl<AXiuPassiveAbilityMod2>();
	}
};
static_assert(alignof(AXiuPassiveAbilityMod2) == 0x000008, "Wrong alignment on AXiuPassiveAbilityMod2");
static_assert(sizeof(AXiuPassiveAbilityMod2) == 0x000550, "Wrong size on AXiuPassiveAbilityMod2");
static_assert(offsetof(AXiuPassiveAbilityMod2, PhaseToShowSpys) == 0x000530, "Member 'AXiuPassiveAbilityMod2::PhaseToShowSpys' has a wrong offset!");
static_assert(offsetof(AXiuPassiveAbilityMod2, TimeToShowPing) == 0x000540, "Member 'AXiuPassiveAbilityMod2::TimeToShowPing' has a wrong offset!");
static_assert(offsetof(AXiuPassiveAbilityMod2, DelayBetweenPing) == 0x000544, "Member 'AXiuPassiveAbilityMod2::DelayBetweenPing' has a wrong offset!");

// Class DeceiveInc.YumiActiveAbility
// 0x0070 (0x0600 - 0x0590)
class AYumiActiveAbility final : public ABaseSpyActiveAbility
{
public:
	class ASpawnerWeapon*                         SpawnerWeapon;                                     // 0x0590(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ABaseSphereActor*>               ActiveSphere;                                      // 0x0598(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A8[0x8];                                      // 0x05A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ActiveFireShotClass;                               // 0x05B0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameplayResourcesType                        ActiveRoundResourceType;                           // 0x05D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D9[0x3];                                      // 0x05D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AmmoCount;                                         // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SphereDuration;                                    // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProjectileLifetime;                                // 0x05E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E8[0x18];                                     // 0x05E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleDelayedPowerDeactivationRequest();
	void HandleProjectileReleased(class ASpawnerWeapon* Weapon, class ASpawnerWeaponRound* Projectile);
	void HandleResourceAmountChanged(int32 TotalBulletLeft);
	void OnLoadoutSpawnComplete(class UToolLoadoutComponent* ToolLoadout);
	void OnProjectileLifeTimeTimerEnd();
	void OnResourceChanged(EGameplayResourcesType ResourceType, const class FText& ResourceDisplayName, int32 Amount);
	void TriggerEMPSphereEnd(class ABaseSphereActor* SphereActor);
	void TriggerEMPSphereStart(class ABaseSphereActor* SphereActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"YumiActiveAbility">();
	}
	static class AYumiActiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<AYumiActiveAbility>();
	}
};
static_assert(alignof(AYumiActiveAbility) == 0x000008, "Wrong alignment on AYumiActiveAbility");
static_assert(sizeof(AYumiActiveAbility) == 0x000600, "Wrong size on AYumiActiveAbility");
static_assert(offsetof(AYumiActiveAbility, SpawnerWeapon) == 0x000590, "Member 'AYumiActiveAbility::SpawnerWeapon' has a wrong offset!");
static_assert(offsetof(AYumiActiveAbility, ActiveSphere) == 0x000598, "Member 'AYumiActiveAbility::ActiveSphere' has a wrong offset!");
static_assert(offsetof(AYumiActiveAbility, ActiveFireShotClass) == 0x0005B0, "Member 'AYumiActiveAbility::ActiveFireShotClass' has a wrong offset!");
static_assert(offsetof(AYumiActiveAbility, ActiveRoundResourceType) == 0x0005D8, "Member 'AYumiActiveAbility::ActiveRoundResourceType' has a wrong offset!");
static_assert(offsetof(AYumiActiveAbility, AmmoCount) == 0x0005DC, "Member 'AYumiActiveAbility::AmmoCount' has a wrong offset!");
static_assert(offsetof(AYumiActiveAbility, SphereDuration) == 0x0005E0, "Member 'AYumiActiveAbility::SphereDuration' has a wrong offset!");
static_assert(offsetof(AYumiActiveAbility, ProjectileLifetime) == 0x0005E4, "Member 'AYumiActiveAbility::ProjectileLifetime' has a wrong offset!");

// Class DeceiveInc.YumiPassiveAbilityMod2
// 0x0030 (0x0560 - 0x0530)
class AYumiPassiveAbilityMod2 final : public ABaseSpyPassiveAbility
{
public:
	TSoftClassPtr<class UClass>                   ExplosionActorClass;                               // 0x0530(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAffectEnemies;                                    // 0x0558(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_559[0x7];                                      // 0x0559(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleHitConfirmed(const struct FHitConfirmData& HitConfirmData);
	void HandleMeleeDamageConfirmed(class AActor* Victim, const struct FVector& ImpactPoint, int32 ChargeLevel, float DamageDone, float ResultingHealthPercentage, EHitType HitType, const struct FMeleeHitConfirmedData& HitConfirmedData);
	void HandleMiscToolSpawned(class AActor* SpawnedTool);
	void HandlePlaceableSpawned(class ABasePlaceable* NewPlaceable);
	void HandleSpyToolLoadComplete(class UToolLoadoutComponent* ToolLoadout);
	void OnPlaceableDeath(class AActor* DeadActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"YumiPassiveAbilityMod2">();
	}
	static class AYumiPassiveAbilityMod2* GetDefaultObj()
	{
		return GetDefaultObjImpl<AYumiPassiveAbilityMod2>();
	}
};
static_assert(alignof(AYumiPassiveAbilityMod2) == 0x000008, "Wrong alignment on AYumiPassiveAbilityMod2");
static_assert(sizeof(AYumiPassiveAbilityMod2) == 0x000560, "Wrong size on AYumiPassiveAbilityMod2");
static_assert(offsetof(AYumiPassiveAbilityMod2, ExplosionActorClass) == 0x000530, "Member 'AYumiPassiveAbilityMod2::ExplosionActorClass' has a wrong offset!");
static_assert(offsetof(AYumiPassiveAbilityMod2, bAffectEnemies) == 0x000558, "Member 'AYumiPassiveAbilityMod2::bAffectEnemies' has a wrong offset!");

// Class DeceiveInc.ZoomComponent
// 0x00B8 (0x0168 - 0x00B0)
class UZoomComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnZoomFactorChange;                                // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0xA8];                                      // 0x00C0(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddZoomModifier(class FName ModifierName, float ZoomFactor, float InterpolationTime);
	void AddZoomModifier3P(class FName ModifierName, float ZoomFactor, float InterpolationTime);
	void HandleIntPlayerSettingChange(EPlayerSettingsType SettingType, int32 NewValue);
	void RemoveZoomModifier(class FName ModifierName, float InterpolationTime);
	void RemoveZoomModifier3P(class FName ModifierName, float InterpolationTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZoomComponent">();
	}
	static class UZoomComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZoomComponent>();
	}
};
static_assert(alignof(UZoomComponent) == 0x000008, "Wrong alignment on UZoomComponent");
static_assert(sizeof(UZoomComponent) == 0x000168, "Wrong size on UZoomComponent");
static_assert(offsetof(UZoomComponent, OnZoomFactorChange) == 0x0000B0, "Member 'UZoomComponent::OnZoomFactorChange' has a wrong offset!");

}

