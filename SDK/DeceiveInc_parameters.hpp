#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DeceiveInc

#include "Basic.hpp"

#include "DeceiveInc_structs.hpp"
#include "AIModule_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "InputCore_structs.hpp"
#include "Engine_structs.hpp"
#include "Agones_structs.hpp"
#include "OnlineSubsystemAccelByte_structs.hpp"
#include "AccelByteUe4Sdk_structs.hpp"
#include "UMG_structs.hpp"


namespace SDK::Params
{

// Function DeceiveInc.BotActionInteract.OnLocaInteractionCompleted
// 0x0010 (0x0010 - 0x0000)
struct BotActionInteract_OnLocaInteractionCompleted final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BotActionInteract_OnLocaInteractionCompleted) == 0x000008, "Wrong alignment on BotActionInteract_OnLocaInteractionCompleted");
static_assert(sizeof(BotActionInteract_OnLocaInteractionCompleted) == 0x000010, "Wrong size on BotActionInteract_OnLocaInteractionCompleted");
static_assert(offsetof(BotActionInteract_OnLocaInteractionCompleted, Interacter) == 0x000000, "Member 'BotActionInteract_OnLocaInteractionCompleted::Interacter' has a wrong offset!");
static_assert(offsetof(BotActionInteract_OnLocaInteractionCompleted, Interactable) == 0x000008, "Member 'BotActionInteract_OnLocaInteractionCompleted::Interactable' has a wrong offset!");

// Function DeceiveInc.BotActionInteract.OnReceiveMoveCompleted
// 0x0008 (0x0008 - 0x0000)
struct BotActionInteract_OnReceiveMoveCompleted final
{
public:
	struct FAIRequestID                           RequestId;                                         // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPathFollowingResult                          Result;                                            // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BotActionInteract_OnReceiveMoveCompleted) == 0x000004, "Wrong alignment on BotActionInteract_OnReceiveMoveCompleted");
static_assert(sizeof(BotActionInteract_OnReceiveMoveCompleted) == 0x000008, "Wrong size on BotActionInteract_OnReceiveMoveCompleted");
static_assert(offsetof(BotActionInteract_OnReceiveMoveCompleted, RequestId) == 0x000000, "Member 'BotActionInteract_OnReceiveMoveCompleted::RequestId' has a wrong offset!");
static_assert(offsetof(BotActionInteract_OnReceiveMoveCompleted, Result) == 0x000004, "Member 'BotActionInteract_OnReceiveMoveCompleted::Result' has a wrong offset!");

// Function DeceiveInc.BotActionMoveTo.OnReceiveMoveCompleted
// 0x0008 (0x0008 - 0x0000)
struct BotActionMoveTo_OnReceiveMoveCompleted final
{
public:
	struct FAIRequestID                           RequestId;                                         // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPathFollowingResult                          Result;                                            // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BotActionMoveTo_OnReceiveMoveCompleted) == 0x000004, "Wrong alignment on BotActionMoveTo_OnReceiveMoveCompleted");
static_assert(sizeof(BotActionMoveTo_OnReceiveMoveCompleted) == 0x000008, "Wrong size on BotActionMoveTo_OnReceiveMoveCompleted");
static_assert(offsetof(BotActionMoveTo_OnReceiveMoveCompleted, RequestId) == 0x000000, "Member 'BotActionMoveTo_OnReceiveMoveCompleted::RequestId' has a wrong offset!");
static_assert(offsetof(BotActionMoveTo_OnReceiveMoveCompleted, Result) == 0x000004, "Member 'BotActionMoveTo_OnReceiveMoveCompleted::Result' has a wrong offset!");

// Function DeceiveInc.DeceiveIncCheatManager.CheatMenuEnableFreeLootBundle
// 0x000C (0x000C - 0x0000)
struct DeceiveIncCheatManager_CheatMenuEnableFreeLootBundle final
{
public:
	int32                                         ItemId0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemId1;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemId2;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncCheatManager_CheatMenuEnableFreeLootBundle) == 0x000004, "Wrong alignment on DeceiveIncCheatManager_CheatMenuEnableFreeLootBundle");
static_assert(sizeof(DeceiveIncCheatManager_CheatMenuEnableFreeLootBundle) == 0x00000C, "Wrong size on DeceiveIncCheatManager_CheatMenuEnableFreeLootBundle");
static_assert(offsetof(DeceiveIncCheatManager_CheatMenuEnableFreeLootBundle, ItemId0) == 0x000000, "Member 'DeceiveIncCheatManager_CheatMenuEnableFreeLootBundle::ItemId0' has a wrong offset!");
static_assert(offsetof(DeceiveIncCheatManager_CheatMenuEnableFreeLootBundle, ItemId1) == 0x000004, "Member 'DeceiveIncCheatManager_CheatMenuEnableFreeLootBundle::ItemId1' has a wrong offset!");
static_assert(offsetof(DeceiveIncCheatManager_CheatMenuEnableFreeLootBundle, ItemId2) == 0x000008, "Member 'DeceiveIncCheatManager_CheatMenuEnableFreeLootBundle::ItemId2' has a wrong offset!");

// Function DeceiveInc.DeceiveIncCheatManager.CheatMenuGiveFakeLootBundles
// 0x0004 (0x0004 - 0x0000)
struct DeceiveIncCheatManager_CheatMenuGiveFakeLootBundles final
{
public:
	int32                                         Amount;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncCheatManager_CheatMenuGiveFakeLootBundles) == 0x000004, "Wrong alignment on DeceiveIncCheatManager_CheatMenuGiveFakeLootBundles");
static_assert(sizeof(DeceiveIncCheatManager_CheatMenuGiveFakeLootBundles) == 0x000004, "Wrong size on DeceiveIncCheatManager_CheatMenuGiveFakeLootBundles");
static_assert(offsetof(DeceiveIncCheatManager_CheatMenuGiveFakeLootBundles, Amount) == 0x000000, "Member 'DeceiveIncCheatManager_CheatMenuGiveFakeLootBundles::Amount' has a wrong offset!");

// Function DeceiveInc.DeceiveIncCheatManager.CheatSetXpTypeLvlAndXp
// 0x0020 (0x0020 - 0x0000)
struct DeceiveIncCheatManager_CheatSetXpTypeLvlAndXp final
{
public:
	class FString                                 XpType;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Lvl;                                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XpAmount;                                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EXpProgressionType                            ProgressionType;                                   // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DeceiveIncCheatManager_CheatSetXpTypeLvlAndXp) == 0x000008, "Wrong alignment on DeceiveIncCheatManager_CheatSetXpTypeLvlAndXp");
static_assert(sizeof(DeceiveIncCheatManager_CheatSetXpTypeLvlAndXp) == 0x000020, "Wrong size on DeceiveIncCheatManager_CheatSetXpTypeLvlAndXp");
static_assert(offsetof(DeceiveIncCheatManager_CheatSetXpTypeLvlAndXp, XpType) == 0x000000, "Member 'DeceiveIncCheatManager_CheatSetXpTypeLvlAndXp::XpType' has a wrong offset!");
static_assert(offsetof(DeceiveIncCheatManager_CheatSetXpTypeLvlAndXp, Lvl) == 0x000010, "Member 'DeceiveIncCheatManager_CheatSetXpTypeLvlAndXp::Lvl' has a wrong offset!");
static_assert(offsetof(DeceiveIncCheatManager_CheatSetXpTypeLvlAndXp, XpAmount) == 0x000014, "Member 'DeceiveIncCheatManager_CheatSetXpTypeLvlAndXp::XpAmount' has a wrong offset!");
static_assert(offsetof(DeceiveIncCheatManager_CheatSetXpTypeLvlAndXp, ProgressionType) == 0x000018, "Member 'DeceiveIncCheatManager_CheatSetXpTypeLvlAndXp::ProgressionType' has a wrong offset!");

// Function DeceiveInc.DeceiveIncCheatManager.CheatShowcollisionPatch
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncCheatManager_CheatShowcollisionPatch final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncCheatManager_CheatShowcollisionPatch) == 0x000001, "Wrong alignment on DeceiveIncCheatManager_CheatShowcollisionPatch");
static_assert(sizeof(DeceiveIncCheatManager_CheatShowcollisionPatch) == 0x000001, "Wrong size on DeceiveIncCheatManager_CheatShowcollisionPatch");
static_assert(offsetof(DeceiveIncCheatManager_CheatShowcollisionPatch, bShow) == 0x000000, "Member 'DeceiveIncCheatManager_CheatShowcollisionPatch::bShow' has a wrong offset!");

// Function DeceiveInc.DeceiveIncCheatManager.CheatTestSpawnPlayers
// 0x0008 (0x0008 - 0x0000)
struct DeceiveIncCheatManager_CheatTestSpawnPlayers final
{
public:
	int32                                         NbTeams;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NbPlayersPerTeam;                                  // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncCheatManager_CheatTestSpawnPlayers) == 0x000004, "Wrong alignment on DeceiveIncCheatManager_CheatTestSpawnPlayers");
static_assert(sizeof(DeceiveIncCheatManager_CheatTestSpawnPlayers) == 0x000008, "Wrong size on DeceiveIncCheatManager_CheatTestSpawnPlayers");
static_assert(offsetof(DeceiveIncCheatManager_CheatTestSpawnPlayers, NbTeams) == 0x000000, "Member 'DeceiveIncCheatManager_CheatTestSpawnPlayers::NbTeams' has a wrong offset!");
static_assert(offsetof(DeceiveIncCheatManager_CheatTestSpawnPlayers, NbPlayersPerTeam) == 0x000004, "Member 'DeceiveIncCheatManager_CheatTestSpawnPlayers::NbPlayersPerTeam' has a wrong offset!");

// Function DeceiveInc.DeceiveIncCheatManager.CheatTriggerShaderPrecompile
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncCheatManager_CheatTriggerShaderPrecompile final
{
public:
	bool                                          bShowMenu;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncCheatManager_CheatTriggerShaderPrecompile) == 0x000001, "Wrong alignment on DeceiveIncCheatManager_CheatTriggerShaderPrecompile");
static_assert(sizeof(DeceiveIncCheatManager_CheatTriggerShaderPrecompile) == 0x000001, "Wrong size on DeceiveIncCheatManager_CheatTriggerShaderPrecompile");
static_assert(offsetof(DeceiveIncCheatManager_CheatTriggerShaderPrecompile, bShowMenu) == 0x000000, "Member 'DeceiveIncCheatManager_CheatTriggerShaderPrecompile::bShowMenu' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.AddActorToIgnoreList
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_AddActorToIgnoreList final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_AddActorToIgnoreList) == 0x000008, "Wrong alignment on BaseSpyTool_AddActorToIgnoreList");
static_assert(sizeof(BaseSpyTool_AddActorToIgnoreList) == 0x000008, "Wrong size on BaseSpyTool_AddActorToIgnoreList");
static_assert(offsetof(BaseSpyTool_AddActorToIgnoreList, TargetActor) == 0x000000, "Member 'BaseSpyTool_AddActorToIgnoreList::TargetActor' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.AnimSwitchToPoudrier
// 0x0002 (0x0002 - 0x0000)
struct BaseSpyTool_AnimSwitchToPoudrier final
{
public:
	bool                                          bFirstPerson;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_AnimSwitchToPoudrier) == 0x000001, "Wrong alignment on BaseSpyTool_AnimSwitchToPoudrier");
static_assert(sizeof(BaseSpyTool_AnimSwitchToPoudrier) == 0x000002, "Wrong size on BaseSpyTool_AnimSwitchToPoudrier");
static_assert(offsetof(BaseSpyTool_AnimSwitchToPoudrier, bFirstPerson) == 0x000000, "Member 'BaseSpyTool_AnimSwitchToPoudrier::bFirstPerson' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_AnimSwitchToPoudrier, ReturnValue) == 0x000001, "Member 'BaseSpyTool_AnimSwitchToPoudrier::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.ApplyNewBalancingTableAndUpdateStats
// 0x0010 (0x0010 - 0x0000)
struct BaseSpyTool_ApplyNewBalancingTableAndUpdateStats final
{
public:
	class UDataTable*                             NewTable;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NewBalancingName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_ApplyNewBalancingTableAndUpdateStats) == 0x000008, "Wrong alignment on BaseSpyTool_ApplyNewBalancingTableAndUpdateStats");
static_assert(sizeof(BaseSpyTool_ApplyNewBalancingTableAndUpdateStats) == 0x000010, "Wrong size on BaseSpyTool_ApplyNewBalancingTableAndUpdateStats");
static_assert(offsetof(BaseSpyTool_ApplyNewBalancingTableAndUpdateStats, NewTable) == 0x000000, "Member 'BaseSpyTool_ApplyNewBalancingTableAndUpdateStats::NewTable' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_ApplyNewBalancingTableAndUpdateStats, NewBalancingName) == 0x000008, "Member 'BaseSpyTool_ApplyNewBalancingTableAndUpdateStats::NewBalancingName' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.ApplyWrapToComponent
// 0x0010 (0x0010 - 0x0000)
struct BaseSpyTool_ApplyWrapToComponent final
{
public:
	class UMeshComponent*                         TargetComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ApplyToChildrens;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BaseSpyTool_ApplyWrapToComponent) == 0x000008, "Wrong alignment on BaseSpyTool_ApplyWrapToComponent");
static_assert(sizeof(BaseSpyTool_ApplyWrapToComponent) == 0x000010, "Wrong size on BaseSpyTool_ApplyWrapToComponent");
static_assert(offsetof(BaseSpyTool_ApplyWrapToComponent, TargetComponent) == 0x000000, "Member 'BaseSpyTool_ApplyWrapToComponent::TargetComponent' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_ApplyWrapToComponent, ApplyToChildrens) == 0x000008, "Member 'BaseSpyTool_ApplyWrapToComponent::ApplyToChildrens' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.AttachToNewPreferredAttachSocket
// 0x0018 (0x0018 - 0x0000)
struct BaseSpyTool_AttachToNewPreferredAttachSocket final
{
public:
	class USceneComponent*                        Parent;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               LocationRule;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               RotationRule;                                      // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               ScaleRule;                                         // 0x000A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeldSimulatedBodies;                              // 0x000B(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NewPreferredAttachSocket;                          // 0x000C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BaseSpyTool_AttachToNewPreferredAttachSocket) == 0x000008, "Wrong alignment on BaseSpyTool_AttachToNewPreferredAttachSocket");
static_assert(sizeof(BaseSpyTool_AttachToNewPreferredAttachSocket) == 0x000018, "Wrong size on BaseSpyTool_AttachToNewPreferredAttachSocket");
static_assert(offsetof(BaseSpyTool_AttachToNewPreferredAttachSocket, Parent) == 0x000000, "Member 'BaseSpyTool_AttachToNewPreferredAttachSocket::Parent' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_AttachToNewPreferredAttachSocket, LocationRule) == 0x000008, "Member 'BaseSpyTool_AttachToNewPreferredAttachSocket::LocationRule' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_AttachToNewPreferredAttachSocket, RotationRule) == 0x000009, "Member 'BaseSpyTool_AttachToNewPreferredAttachSocket::RotationRule' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_AttachToNewPreferredAttachSocket, ScaleRule) == 0x00000A, "Member 'BaseSpyTool_AttachToNewPreferredAttachSocket::ScaleRule' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_AttachToNewPreferredAttachSocket, bWeldSimulatedBodies) == 0x00000B, "Member 'BaseSpyTool_AttachToNewPreferredAttachSocket::bWeldSimulatedBodies' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_AttachToNewPreferredAttachSocket, NewPreferredAttachSocket) == 0x00000C, "Member 'BaseSpyTool_AttachToNewPreferredAttachSocket::NewPreferredAttachSocket' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.BP_HideToolFromAnim
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_BP_HideToolFromAnim final
{
public:
	bool                                          bShouldAffectSecondaryTool;                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_BP_HideToolFromAnim) == 0x000001, "Wrong alignment on BaseSpyTool_BP_HideToolFromAnim");
static_assert(sizeof(BaseSpyTool_BP_HideToolFromAnim) == 0x000001, "Wrong size on BaseSpyTool_BP_HideToolFromAnim");
static_assert(offsetof(BaseSpyTool_BP_HideToolFromAnim, bShouldAffectSecondaryTool) == 0x000000, "Member 'BaseSpyTool_BP_HideToolFromAnim::bShouldAffectSecondaryTool' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.BP_OnOperatorRelease
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_BP_OnOperatorRelease final
{
public:
	class AActor*                                 ReleasingOperator;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_BP_OnOperatorRelease) == 0x000008, "Wrong alignment on BaseSpyTool_BP_OnOperatorRelease");
static_assert(sizeof(BaseSpyTool_BP_OnOperatorRelease) == 0x000008, "Wrong size on BaseSpyTool_BP_OnOperatorRelease");
static_assert(offsetof(BaseSpyTool_BP_OnOperatorRelease, ReleasingOperator) == 0x000000, "Member 'BaseSpyTool_BP_OnOperatorRelease::ReleasingOperator' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.BP_OnOwnerSet
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_BP_OnOwnerSet final
{
public:
	class ABaseSpyTool*                           SpyTool;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_BP_OnOwnerSet) == 0x000008, "Wrong alignment on BaseSpyTool_BP_OnOwnerSet");
static_assert(sizeof(BaseSpyTool_BP_OnOwnerSet) == 0x000008, "Wrong size on BaseSpyTool_BP_OnOwnerSet");
static_assert(offsetof(BaseSpyTool_BP_OnOwnerSet, SpyTool) == 0x000000, "Member 'BaseSpyTool_BP_OnOwnerSet::SpyTool' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.BP_OnPrimaryBegin
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_BP_OnPrimaryBegin final
{
public:
	class ABaseSpyTool*                           SpyTool;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_BP_OnPrimaryBegin) == 0x000008, "Wrong alignment on BaseSpyTool_BP_OnPrimaryBegin");
static_assert(sizeof(BaseSpyTool_BP_OnPrimaryBegin) == 0x000008, "Wrong size on BaseSpyTool_BP_OnPrimaryBegin");
static_assert(offsetof(BaseSpyTool_BP_OnPrimaryBegin, SpyTool) == 0x000000, "Member 'BaseSpyTool_BP_OnPrimaryBegin::SpyTool' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.BP_OnPrimaryEnd
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_BP_OnPrimaryEnd final
{
public:
	class ABaseSpyTool*                           SpyTool;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_BP_OnPrimaryEnd) == 0x000008, "Wrong alignment on BaseSpyTool_BP_OnPrimaryEnd");
static_assert(sizeof(BaseSpyTool_BP_OnPrimaryEnd) == 0x000008, "Wrong size on BaseSpyTool_BP_OnPrimaryEnd");
static_assert(offsetof(BaseSpyTool_BP_OnPrimaryEnd, SpyTool) == 0x000000, "Member 'BaseSpyTool_BP_OnPrimaryEnd::SpyTool' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.BP_OnPrimaryFailed
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_BP_OnPrimaryFailed final
{
public:
	class ABaseSpyTool*                           SpyTool;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_BP_OnPrimaryFailed) == 0x000008, "Wrong alignment on BaseSpyTool_BP_OnPrimaryFailed");
static_assert(sizeof(BaseSpyTool_BP_OnPrimaryFailed) == 0x000008, "Wrong size on BaseSpyTool_BP_OnPrimaryFailed");
static_assert(offsetof(BaseSpyTool_BP_OnPrimaryFailed, SpyTool) == 0x000000, "Member 'BaseSpyTool_BP_OnPrimaryFailed::SpyTool' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.BP_OnRecycleBegin
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_BP_OnRecycleBegin final
{
public:
	class ABaseSpyTool*                           SpyTool;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_BP_OnRecycleBegin) == 0x000008, "Wrong alignment on BaseSpyTool_BP_OnRecycleBegin");
static_assert(sizeof(BaseSpyTool_BP_OnRecycleBegin) == 0x000008, "Wrong size on BaseSpyTool_BP_OnRecycleBegin");
static_assert(offsetof(BaseSpyTool_BP_OnRecycleBegin, SpyTool) == 0x000000, "Member 'BaseSpyTool_BP_OnRecycleBegin::SpyTool' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.BP_OnRecycleEnd
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_BP_OnRecycleEnd final
{
public:
	class ABaseSpyTool*                           SpyTool;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_BP_OnRecycleEnd) == 0x000008, "Wrong alignment on BaseSpyTool_BP_OnRecycleEnd");
static_assert(sizeof(BaseSpyTool_BP_OnRecycleEnd) == 0x000008, "Wrong size on BaseSpyTool_BP_OnRecycleEnd");
static_assert(offsetof(BaseSpyTool_BP_OnRecycleEnd, SpyTool) == 0x000000, "Member 'BaseSpyTool_BP_OnRecycleEnd::SpyTool' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.BP_OnSecondaryBegin
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_BP_OnSecondaryBegin final
{
public:
	class ABaseSpyTool*                           SpyTool;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_BP_OnSecondaryBegin) == 0x000008, "Wrong alignment on BaseSpyTool_BP_OnSecondaryBegin");
static_assert(sizeof(BaseSpyTool_BP_OnSecondaryBegin) == 0x000008, "Wrong size on BaseSpyTool_BP_OnSecondaryBegin");
static_assert(offsetof(BaseSpyTool_BP_OnSecondaryBegin, SpyTool) == 0x000000, "Member 'BaseSpyTool_BP_OnSecondaryBegin::SpyTool' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.BP_OnSecondaryEnd
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_BP_OnSecondaryEnd final
{
public:
	class ABaseSpyTool*                           SpyTool;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_BP_OnSecondaryEnd) == 0x000008, "Wrong alignment on BaseSpyTool_BP_OnSecondaryEnd");
static_assert(sizeof(BaseSpyTool_BP_OnSecondaryEnd) == 0x000008, "Wrong size on BaseSpyTool_BP_OnSecondaryEnd");
static_assert(offsetof(BaseSpyTool_BP_OnSecondaryEnd, SpyTool) == 0x000000, "Member 'BaseSpyTool_BP_OnSecondaryEnd::SpyTool' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.BP_OnSecondaryFailed
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_BP_OnSecondaryFailed final
{
public:
	class ABaseSpyTool*                           SpyTool;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_BP_OnSecondaryFailed) == 0x000008, "Wrong alignment on BaseSpyTool_BP_OnSecondaryFailed");
static_assert(sizeof(BaseSpyTool_BP_OnSecondaryFailed) == 0x000008, "Wrong size on BaseSpyTool_BP_OnSecondaryFailed");
static_assert(offsetof(BaseSpyTool_BP_OnSecondaryFailed, SpyTool) == 0x000000, "Member 'BaseSpyTool_BP_OnSecondaryFailed::SpyTool' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.BP_OnSetupResource
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_BP_OnSetupResource final
{
public:
	class ABaseSpyTool*                           SpyTool;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_BP_OnSetupResource) == 0x000008, "Wrong alignment on BaseSpyTool_BP_OnSetupResource");
static_assert(sizeof(BaseSpyTool_BP_OnSetupResource) == 0x000008, "Wrong size on BaseSpyTool_BP_OnSetupResource");
static_assert(offsetof(BaseSpyTool_BP_OnSetupResource, SpyTool) == 0x000000, "Member 'BaseSpyTool_BP_OnSetupResource::SpyTool' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.BP_OnSpyToolEvent
// 0x0010 (0x0010 - 0x0000)
struct BaseSpyTool_BP_OnSpyToolEvent final
{
public:
	ESpyToolEvent                                 Event;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSpyTool*                           SpyTool;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_BP_OnSpyToolEvent) == 0x000008, "Wrong alignment on BaseSpyTool_BP_OnSpyToolEvent");
static_assert(sizeof(BaseSpyTool_BP_OnSpyToolEvent) == 0x000010, "Wrong size on BaseSpyTool_BP_OnSpyToolEvent");
static_assert(offsetof(BaseSpyTool_BP_OnSpyToolEvent, Event) == 0x000000, "Member 'BaseSpyTool_BP_OnSpyToolEvent::Event' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_BP_OnSpyToolEvent, SpyTool) == 0x000008, "Member 'BaseSpyTool_BP_OnSpyToolEvent::SpyTool' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.BP_OnSwitchAwayFrom
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_BP_OnSwitchAwayFrom final
{
public:
	class ABaseSpyTool*                           SpyTool;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_BP_OnSwitchAwayFrom) == 0x000008, "Wrong alignment on BaseSpyTool_BP_OnSwitchAwayFrom");
static_assert(sizeof(BaseSpyTool_BP_OnSwitchAwayFrom) == 0x000008, "Wrong size on BaseSpyTool_BP_OnSwitchAwayFrom");
static_assert(offsetof(BaseSpyTool_BP_OnSwitchAwayFrom, SpyTool) == 0x000000, "Member 'BaseSpyTool_BP_OnSwitchAwayFrom::SpyTool' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.BP_OnSwitchTo
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_BP_OnSwitchTo final
{
public:
	class ABaseSpyTool*                           SpyTool;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_BP_OnSwitchTo) == 0x000008, "Wrong alignment on BaseSpyTool_BP_OnSwitchTo");
static_assert(sizeof(BaseSpyTool_BP_OnSwitchTo) == 0x000008, "Wrong size on BaseSpyTool_BP_OnSwitchTo");
static_assert(offsetof(BaseSpyTool_BP_OnSwitchTo, SpyTool) == 0x000000, "Member 'BaseSpyTool_BP_OnSwitchTo::SpyTool' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.BP_ShowToolFromAnim
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_BP_ShowToolFromAnim final
{
public:
	bool                                          bShouldAffectSecondaryTool;                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_BP_ShowToolFromAnim) == 0x000001, "Wrong alignment on BaseSpyTool_BP_ShowToolFromAnim");
static_assert(sizeof(BaseSpyTool_BP_ShowToolFromAnim) == 0x000001, "Wrong size on BaseSpyTool_BP_ShowToolFromAnim");
static_assert(offsetof(BaseSpyTool_BP_ShowToolFromAnim, bShouldAffectSecondaryTool) == 0x000000, "Member 'BaseSpyTool_BP_ShowToolFromAnim::bShouldAffectSecondaryTool' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.BP_ShowToolFromSecondaryVisibilityFromAnim
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_BP_ShowToolFromSecondaryVisibilityFromAnim final
{
public:
	bool                                          bShouldAffectSecondaryTool;                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_BP_ShowToolFromSecondaryVisibilityFromAnim) == 0x000001, "Wrong alignment on BaseSpyTool_BP_ShowToolFromSecondaryVisibilityFromAnim");
static_assert(sizeof(BaseSpyTool_BP_ShowToolFromSecondaryVisibilityFromAnim) == 0x000001, "Wrong size on BaseSpyTool_BP_ShowToolFromSecondaryVisibilityFromAnim");
static_assert(offsetof(BaseSpyTool_BP_ShowToolFromSecondaryVisibilityFromAnim, bShouldAffectSecondaryTool) == 0x000000, "Member 'BaseSpyTool_BP_ShowToolFromSecondaryVisibilityFromAnim::bShouldAffectSecondaryTool' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.BP_ShowToolHUD
// 0x000C (0x000C - 0x0000)
struct BaseSpyTool_BP_ShowToolHUD final
{
public:
	class FName                                   HUDName;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowIn;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BaseSpyTool_BP_ShowToolHUD) == 0x000004, "Wrong alignment on BaseSpyTool_BP_ShowToolHUD");
static_assert(sizeof(BaseSpyTool_BP_ShowToolHUD) == 0x00000C, "Wrong size on BaseSpyTool_BP_ShowToolHUD");
static_assert(offsetof(BaseSpyTool_BP_ShowToolHUD, HUDName) == 0x000000, "Member 'BaseSpyTool_BP_ShowToolHUD::HUDName' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_BP_ShowToolHUD, bShowIn) == 0x000008, "Member 'BaseSpyTool_BP_ShowToolHUD::bShowIn' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.CreateAnimationProp
// 0x0028 (0x0028 - 0x0000)
struct BaseSpyTool_CreateAnimationProp final
{
public:
	class FName                                   NameID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorToCreate;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocket;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstPerson;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_CreateAnimationProp) == 0x000008, "Wrong alignment on BaseSpyTool_CreateAnimationProp");
static_assert(sizeof(BaseSpyTool_CreateAnimationProp) == 0x000028, "Wrong size on BaseSpyTool_CreateAnimationProp");
static_assert(offsetof(BaseSpyTool_CreateAnimationProp, NameID) == 0x000000, "Member 'BaseSpyTool_CreateAnimationProp::NameID' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_CreateAnimationProp, ActorToCreate) == 0x000008, "Member 'BaseSpyTool_CreateAnimationProp::ActorToCreate' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_CreateAnimationProp, AttachSocket) == 0x000010, "Member 'BaseSpyTool_CreateAnimationProp::AttachSocket' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_CreateAnimationProp, bFirstPerson) == 0x000018, "Member 'BaseSpyTool_CreateAnimationProp::bFirstPerson' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_CreateAnimationProp, ReturnValue) == 0x000020, "Member 'BaseSpyTool_CreateAnimationProp::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.DestroyAnimationProp
// 0x000C (0x000C - 0x0000)
struct BaseSpyTool_DestroyAnimationProp final
{
public:
	class FName                                   NameID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstPerson;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BaseSpyTool_DestroyAnimationProp) == 0x000004, "Wrong alignment on BaseSpyTool_DestroyAnimationProp");
static_assert(sizeof(BaseSpyTool_DestroyAnimationProp) == 0x00000C, "Wrong size on BaseSpyTool_DestroyAnimationProp");
static_assert(offsetof(BaseSpyTool_DestroyAnimationProp, NameID) == 0x000000, "Member 'BaseSpyTool_DestroyAnimationProp::NameID' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_DestroyAnimationProp, bFirstPerson) == 0x000008, "Member 'BaseSpyTool_DestroyAnimationProp::bFirstPerson' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.FireEvent
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_FireEvent final
{
public:
	ESpyToolEvent                                 Event;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_FireEvent) == 0x000001, "Wrong alignment on BaseSpyTool_FireEvent");
static_assert(sizeof(BaseSpyTool_FireEvent) == 0x000001, "Wrong size on BaseSpyTool_FireEvent");
static_assert(offsetof(BaseSpyTool_FireEvent, Event) == 0x000000, "Member 'BaseSpyTool_FireEvent::Event' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetAnimationProp
// 0x0018 (0x0018 - 0x0000)
struct BaseSpyTool_GetAnimationProp final
{
public:
	class FName                                   NameID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstPerson;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetAnimationProp) == 0x000008, "Wrong alignment on BaseSpyTool_GetAnimationProp");
static_assert(sizeof(BaseSpyTool_GetAnimationProp) == 0x000018, "Wrong size on BaseSpyTool_GetAnimationProp");
static_assert(offsetof(BaseSpyTool_GetAnimationProp, NameID) == 0x000000, "Member 'BaseSpyTool_GetAnimationProp::NameID' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_GetAnimationProp, bFirstPerson) == 0x000008, "Member 'BaseSpyTool_GetAnimationProp::bFirstPerson' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_GetAnimationProp, ReturnValue) == 0x000010, "Member 'BaseSpyTool_GetAnimationProp::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetCurrentVisibility
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_GetCurrentVisibility final
{
public:
	EVisibilityMode                               ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetCurrentVisibility) == 0x000001, "Wrong alignment on BaseSpyTool_GetCurrentVisibility");
static_assert(sizeof(BaseSpyTool_GetCurrentVisibility) == 0x000001, "Wrong size on BaseSpyTool_GetCurrentVisibility");
static_assert(offsetof(BaseSpyTool_GetCurrentVisibility, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetCurrentVisibility::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetToolActionsData
// 0x0040 (0x0040 - 0x0000)
struct BaseSpyTool_GetToolActionsData final
{
public:
	struct FToolActionTextData                    PrimaryActionData;                                 // 0x0000(0x0020)(Parm, OutParm, NativeAccessSpecifierPublic)
	struct FToolActionTextData                    SecondaryActionData;                               // 0x0020(0x0020)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetToolActionsData) == 0x000008, "Wrong alignment on BaseSpyTool_GetToolActionsData");
static_assert(sizeof(BaseSpyTool_GetToolActionsData) == 0x000040, "Wrong size on BaseSpyTool_GetToolActionsData");
static_assert(offsetof(BaseSpyTool_GetToolActionsData, PrimaryActionData) == 0x000000, "Member 'BaseSpyTool_GetToolActionsData::PrimaryActionData' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_GetToolActionsData, SecondaryActionData) == 0x000020, "Member 'BaseSpyTool_GetToolActionsData::SecondaryActionData' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.HandleEMPIsAffectedChanged
// 0x0010 (0x0010 - 0x0000)
struct BaseSpyTool_HandleEMPIsAffectedChanged final
{
public:
	bool                                          bIsAffected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AffectedActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_HandleEMPIsAffectedChanged) == 0x000008, "Wrong alignment on BaseSpyTool_HandleEMPIsAffectedChanged");
static_assert(sizeof(BaseSpyTool_HandleEMPIsAffectedChanged) == 0x000010, "Wrong size on BaseSpyTool_HandleEMPIsAffectedChanged");
static_assert(offsetof(BaseSpyTool_HandleEMPIsAffectedChanged, bIsAffected) == 0x000000, "Member 'BaseSpyTool_HandleEMPIsAffectedChanged::bIsAffected' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_HandleEMPIsAffectedChanged, AffectedActor) == 0x000008, "Member 'BaseSpyTool_HandleEMPIsAffectedChanged::AffectedActor' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.HandleGameRulesChanged
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_HandleGameRulesChanged final
{
public:
	EDIGameRuleset                                NewRuleset;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_HandleGameRulesChanged) == 0x000001, "Wrong alignment on BaseSpyTool_HandleGameRulesChanged");
static_assert(sizeof(BaseSpyTool_HandleGameRulesChanged) == 0x000001, "Wrong size on BaseSpyTool_HandleGameRulesChanged");
static_assert(offsetof(BaseSpyTool_HandleGameRulesChanged, NewRuleset) == 0x000000, "Member 'BaseSpyTool_HandleGameRulesChanged::NewRuleset' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.HandleLoadoutSpawnComplete
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_HandleLoadoutSpawnComplete final
{
public:
	class UToolLoadoutComponent*                  ToolLoadout;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_HandleLoadoutSpawnComplete) == 0x000008, "Wrong alignment on BaseSpyTool_HandleLoadoutSpawnComplete");
static_assert(sizeof(BaseSpyTool_HandleLoadoutSpawnComplete) == 0x000008, "Wrong size on BaseSpyTool_HandleLoadoutSpawnComplete");
static_assert(offsetof(BaseSpyTool_HandleLoadoutSpawnComplete, ToolLoadout) == 0x000000, "Member 'BaseSpyTool_HandleLoadoutSpawnComplete::ToolLoadout' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.HandleScramblerIsAffectedChanged
// 0x0010 (0x0010 - 0x0000)
struct BaseSpyTool_HandleScramblerIsAffectedChanged final
{
public:
	bool                                          bIsAffected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AffectedActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_HandleScramblerIsAffectedChanged) == 0x000008, "Wrong alignment on BaseSpyTool_HandleScramblerIsAffectedChanged");
static_assert(sizeof(BaseSpyTool_HandleScramblerIsAffectedChanged) == 0x000010, "Wrong size on BaseSpyTool_HandleScramblerIsAffectedChanged");
static_assert(offsetof(BaseSpyTool_HandleScramblerIsAffectedChanged, bIsAffected) == 0x000000, "Member 'BaseSpyTool_HandleScramblerIsAffectedChanged::bIsAffected' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_HandleScramblerIsAffectedChanged, AffectedActor) == 0x000008, "Member 'BaseSpyTool_HandleScramblerIsAffectedChanged::AffectedActor' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.HandleToolCooldownChange
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_HandleToolCooldownChange final
{
public:
	bool                                          bOnCooldown;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_HandleToolCooldownChange) == 0x000001, "Wrong alignment on BaseSpyTool_HandleToolCooldownChange");
static_assert(sizeof(BaseSpyTool_HandleToolCooldownChange) == 0x000001, "Wrong size on BaseSpyTool_HandleToolCooldownChange");
static_assert(offsetof(BaseSpyTool_HandleToolCooldownChange, bOnCooldown) == 0x000000, "Member 'BaseSpyTool_HandleToolCooldownChange::bOnCooldown' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.IsAllowingMelee
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_IsAllowingMelee final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_IsAllowingMelee) == 0x000001, "Wrong alignment on BaseSpyTool_IsAllowingMelee");
static_assert(sizeof(BaseSpyTool_IsAllowingMelee) == 0x000001, "Wrong size on BaseSpyTool_IsAllowingMelee");
static_assert(offsetof(BaseSpyTool_IsAllowingMelee, ReturnValue) == 0x000000, "Member 'BaseSpyTool_IsAllowingMelee::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.NetMulticast_NotifyPrimaryGadgetUse
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_NetMulticast_NotifyPrimaryGadgetUse final
{
public:
	bool                                          bStart;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_NetMulticast_NotifyPrimaryGadgetUse) == 0x000001, "Wrong alignment on BaseSpyTool_NetMulticast_NotifyPrimaryGadgetUse");
static_assert(sizeof(BaseSpyTool_NetMulticast_NotifyPrimaryGadgetUse) == 0x000001, "Wrong size on BaseSpyTool_NetMulticast_NotifyPrimaryGadgetUse");
static_assert(offsetof(BaseSpyTool_NetMulticast_NotifyPrimaryGadgetUse, bStart) == 0x000000, "Member 'BaseSpyTool_NetMulticast_NotifyPrimaryGadgetUse::bStart' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.NetMulticast_NotifySecondaryGadgetUse
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_NetMulticast_NotifySecondaryGadgetUse final
{
public:
	bool                                          bStart;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_NetMulticast_NotifySecondaryGadgetUse) == 0x000001, "Wrong alignment on BaseSpyTool_NetMulticast_NotifySecondaryGadgetUse");
static_assert(sizeof(BaseSpyTool_NetMulticast_NotifySecondaryGadgetUse) == 0x000001, "Wrong size on BaseSpyTool_NetMulticast_NotifySecondaryGadgetUse");
static_assert(offsetof(BaseSpyTool_NetMulticast_NotifySecondaryGadgetUse, bStart) == 0x000000, "Member 'BaseSpyTool_NetMulticast_NotifySecondaryGadgetUse::bStart' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.OnAnyHandToolShowed
// 0x0010 (0x0010 - 0x0000)
struct BaseSpyTool_OnAnyHandToolShowed final
{
public:
	class ABaseSpyTool*                           SpyTool;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELoadoutSlot                                  HandToolSlot;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BaseSpyTool_OnAnyHandToolShowed) == 0x000008, "Wrong alignment on BaseSpyTool_OnAnyHandToolShowed");
static_assert(sizeof(BaseSpyTool_OnAnyHandToolShowed) == 0x000010, "Wrong size on BaseSpyTool_OnAnyHandToolShowed");
static_assert(offsetof(BaseSpyTool_OnAnyHandToolShowed, SpyTool) == 0x000000, "Member 'BaseSpyTool_OnAnyHandToolShowed::SpyTool' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_OnAnyHandToolShowed, HandToolSlot) == 0x000008, "Member 'BaseSpyTool_OnAnyHandToolShowed::HandToolSlot' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.OnPlayerHUDVisibilityChange
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_OnPlayerHUDVisibilityChange final
{
public:
	bool                                          bVisible;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_OnPlayerHUDVisibilityChange) == 0x000001, "Wrong alignment on BaseSpyTool_OnPlayerHUDVisibilityChange");
static_assert(sizeof(BaseSpyTool_OnPlayerHUDVisibilityChange) == 0x000001, "Wrong size on BaseSpyTool_OnPlayerHUDVisibilityChange");
static_assert(offsetof(BaseSpyTool_OnPlayerHUDVisibilityChange, bVisible) == 0x000000, "Member 'BaseSpyTool_OnPlayerHUDVisibilityChange::bVisible' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.OnSpyDeath
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_OnSpyDeath final
{
public:
	class AActor*                                 DeadActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_OnSpyDeath) == 0x000008, "Wrong alignment on BaseSpyTool_OnSpyDeath");
static_assert(sizeof(BaseSpyTool_OnSpyDeath) == 0x000008, "Wrong size on BaseSpyTool_OnSpyDeath");
static_assert(offsetof(BaseSpyTool_OnSpyDeath, DeadActor) == 0x000000, "Member 'BaseSpyTool_OnSpyDeath::DeadActor' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.RemoveActorFromIgnoreList
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_RemoveActorFromIgnoreList final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_RemoveActorFromIgnoreList) == 0x000008, "Wrong alignment on BaseSpyTool_RemoveActorFromIgnoreList");
static_assert(sizeof(BaseSpyTool_RemoveActorFromIgnoreList) == 0x000008, "Wrong size on BaseSpyTool_RemoveActorFromIgnoreList");
static_assert(offsetof(BaseSpyTool_RemoveActorFromIgnoreList, TargetActor) == 0x000000, "Member 'BaseSpyTool_RemoveActorFromIgnoreList::TargetActor' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.Server_NotifyPrimaryGadgetUse
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_Server_NotifyPrimaryGadgetUse final
{
public:
	bool                                          bStart;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_Server_NotifyPrimaryGadgetUse) == 0x000001, "Wrong alignment on BaseSpyTool_Server_NotifyPrimaryGadgetUse");
static_assert(sizeof(BaseSpyTool_Server_NotifyPrimaryGadgetUse) == 0x000001, "Wrong size on BaseSpyTool_Server_NotifyPrimaryGadgetUse");
static_assert(offsetof(BaseSpyTool_Server_NotifyPrimaryGadgetUse, bStart) == 0x000000, "Member 'BaseSpyTool_Server_NotifyPrimaryGadgetUse::bStart' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.Server_NotifySecondaryGadgetUse
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_Server_NotifySecondaryGadgetUse final
{
public:
	bool                                          bStart;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_Server_NotifySecondaryGadgetUse) == 0x000001, "Wrong alignment on BaseSpyTool_Server_NotifySecondaryGadgetUse");
static_assert(sizeof(BaseSpyTool_Server_NotifySecondaryGadgetUse) == 0x000001, "Wrong size on BaseSpyTool_Server_NotifySecondaryGadgetUse");
static_assert(offsetof(BaseSpyTool_Server_NotifySecondaryGadgetUse, bStart) == 0x000000, "Member 'BaseSpyTool_Server_NotifySecondaryGadgetUse::bStart' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.SetLocalVisibility
// 0x0003 (0x0003 - 0x0000)
struct BaseSpyTool_SetLocalVisibility final
{
public:
	EVisibilityMode                               InMode;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanShowPoudrier;                                  // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EToolVisibilityChangeReason                   InReason;                                          // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_SetLocalVisibility) == 0x000001, "Wrong alignment on BaseSpyTool_SetLocalVisibility");
static_assert(sizeof(BaseSpyTool_SetLocalVisibility) == 0x000003, "Wrong size on BaseSpyTool_SetLocalVisibility");
static_assert(offsetof(BaseSpyTool_SetLocalVisibility, InMode) == 0x000000, "Member 'BaseSpyTool_SetLocalVisibility::InMode' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_SetLocalVisibility, bCanShowPoudrier) == 0x000001, "Member 'BaseSpyTool_SetLocalVisibility::bCanShowPoudrier' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_SetLocalVisibility, InReason) == 0x000002, "Member 'BaseSpyTool_SetLocalVisibility::InReason' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.SetVisibility
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_SetVisibility final
{
public:
	bool                                          bVisible;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_SetVisibility) == 0x000001, "Wrong alignment on BaseSpyTool_SetVisibility");
static_assert(sizeof(BaseSpyTool_SetVisibility) == 0x000001, "Wrong size on BaseSpyTool_SetVisibility");
static_assert(offsetof(BaseSpyTool_SetVisibility, bVisible) == 0x000000, "Member 'BaseSpyTool_SetVisibility::bVisible' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.ShouldShowPoudrierMesh
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_ShouldShowPoudrierMesh final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_ShouldShowPoudrierMesh) == 0x000001, "Wrong alignment on BaseSpyTool_ShouldShowPoudrierMesh");
static_assert(sizeof(BaseSpyTool_ShouldShowPoudrierMesh) == 0x000001, "Wrong size on BaseSpyTool_ShouldShowPoudrierMesh");
static_assert(offsetof(BaseSpyTool_ShouldShowPoudrierMesh, ReturnValue) == 0x000000, "Member 'BaseSpyTool_ShouldShowPoudrierMesh::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.CanBeUse
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_CanBeUse final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_CanBeUse) == 0x000001, "Wrong alignment on BaseSpyTool_CanBeUse");
static_assert(sizeof(BaseSpyTool_CanBeUse) == 0x000001, "Wrong size on BaseSpyTool_CanBeUse");
static_assert(offsetof(BaseSpyTool_CanBeUse, ReturnValue) == 0x000000, "Member 'BaseSpyTool_CanBeUse::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.CanRecycle
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_CanRecycle final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_CanRecycle) == 0x000001, "Wrong alignment on BaseSpyTool_CanRecycle");
static_assert(sizeof(BaseSpyTool_CanRecycle) == 0x000001, "Wrong size on BaseSpyTool_CanRecycle");
static_assert(offsetof(BaseSpyTool_CanRecycle, ReturnValue) == 0x000000, "Member 'BaseSpyTool_CanRecycle::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetAimAssistConfiguration
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_GetAimAssistConfiguration final
{
public:
	class USBAimAssistConfigDataAsset*            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetAimAssistConfiguration) == 0x000008, "Wrong alignment on BaseSpyTool_GetAimAssistConfiguration");
static_assert(sizeof(BaseSpyTool_GetAimAssistConfiguration) == 0x000008, "Wrong size on BaseSpyTool_GetAimAssistConfiguration");
static_assert(offsetof(BaseSpyTool_GetAimAssistConfiguration, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetAimAssistConfiguration::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetAnim1PClass
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_GetAnim1PClass final
{
public:
	TSubclassOf<class UAnimInstance>              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetAnim1PClass) == 0x000008, "Wrong alignment on BaseSpyTool_GetAnim1PClass");
static_assert(sizeof(BaseSpyTool_GetAnim1PClass) == 0x000008, "Wrong size on BaseSpyTool_GetAnim1PClass");
static_assert(offsetof(BaseSpyTool_GetAnim1PClass, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetAnim1PClass::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetAnim3PClass
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_GetAnim3PClass final
{
public:
	TSubclassOf<class UAnimInstance>              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetAnim3PClass) == 0x000008, "Wrong alignment on BaseSpyTool_GetAnim3PClass");
static_assert(sizeof(BaseSpyTool_GetAnim3PClass) == 0x000008, "Wrong size on BaseSpyTool_GetAnim3PClass");
static_assert(offsetof(BaseSpyTool_GetAnim3PClass, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetAnim3PClass::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetComittedResourceNum
// 0x0004 (0x0004 - 0x0000)
struct BaseSpyTool_GetComittedResourceNum final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetComittedResourceNum) == 0x000004, "Wrong alignment on BaseSpyTool_GetComittedResourceNum");
static_assert(sizeof(BaseSpyTool_GetComittedResourceNum) == 0x000004, "Wrong size on BaseSpyTool_GetComittedResourceNum");
static_assert(offsetof(BaseSpyTool_GetComittedResourceNum, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetComittedResourceNum::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetCurrentActiveMesh
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_GetCurrentActiveMesh final
{
public:
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetCurrentActiveMesh) == 0x000008, "Wrong alignment on BaseSpyTool_GetCurrentActiveMesh");
static_assert(sizeof(BaseSpyTool_GetCurrentActiveMesh) == 0x000008, "Wrong size on BaseSpyTool_GetCurrentActiveMesh");
static_assert(offsetof(BaseSpyTool_GetCurrentActiveMesh, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetCurrentActiveMesh::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetIgnoredActors
// 0x0050 (0x0050 - 0x0000)
struct BaseSpyTool_GetIgnoredActors final
{
public:
	TSet<class AActor*>                           ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetIgnoredActors) == 0x000008, "Wrong alignment on BaseSpyTool_GetIgnoredActors");
static_assert(sizeof(BaseSpyTool_GetIgnoredActors) == 0x000050, "Wrong size on BaseSpyTool_GetIgnoredActors");
static_assert(offsetof(BaseSpyTool_GetIgnoredActors, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetIgnoredActors::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetInitChargeCount
// 0x0004 (0x0004 - 0x0000)
struct BaseSpyTool_GetInitChargeCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetInitChargeCount) == 0x000004, "Wrong alignment on BaseSpyTool_GetInitChargeCount");
static_assert(sizeof(BaseSpyTool_GetInitChargeCount) == 0x000004, "Wrong size on BaseSpyTool_GetInitChargeCount");
static_assert(offsetof(BaseSpyTool_GetInitChargeCount, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetInitChargeCount::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetMaxResourceNum
// 0x0004 (0x0004 - 0x0000)
struct BaseSpyTool_GetMaxResourceNum final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetMaxResourceNum) == 0x000004, "Wrong alignment on BaseSpyTool_GetMaxResourceNum");
static_assert(sizeof(BaseSpyTool_GetMaxResourceNum) == 0x000004, "Wrong size on BaseSpyTool_GetMaxResourceNum");
static_assert(offsetof(BaseSpyTool_GetMaxResourceNum, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetMaxResourceNum::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetMeshComponent1P
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_GetMeshComponent1P final
{
public:
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetMeshComponent1P) == 0x000008, "Wrong alignment on BaseSpyTool_GetMeshComponent1P");
static_assert(sizeof(BaseSpyTool_GetMeshComponent1P) == 0x000008, "Wrong size on BaseSpyTool_GetMeshComponent1P");
static_assert(offsetof(BaseSpyTool_GetMeshComponent1P, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetMeshComponent1P::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetMeshComponent3P
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_GetMeshComponent3P final
{
public:
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetMeshComponent3P) == 0x000008, "Wrong alignment on BaseSpyTool_GetMeshComponent3P");
static_assert(sizeof(BaseSpyTool_GetMeshComponent3P) == 0x000008, "Wrong size on BaseSpyTool_GetMeshComponent3P");
static_assert(offsetof(BaseSpyTool_GetMeshComponent3P, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetMeshComponent3P::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetOperatingController
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_GetOperatingController final
{
public:
	class AController*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetOperatingController) == 0x000008, "Wrong alignment on BaseSpyTool_GetOperatingController");
static_assert(sizeof(BaseSpyTool_GetOperatingController) == 0x000008, "Wrong size on BaseSpyTool_GetOperatingController");
static_assert(offsetof(BaseSpyTool_GetOperatingController, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetOperatingController::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetPositionerBeamLocation
// 0x000C (0x000C - 0x0000)
struct BaseSpyTool_GetPositionerBeamLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetPositionerBeamLocation) == 0x000004, "Wrong alignment on BaseSpyTool_GetPositionerBeamLocation");
static_assert(sizeof(BaseSpyTool_GetPositionerBeamLocation) == 0x00000C, "Wrong size on BaseSpyTool_GetPositionerBeamLocation");
static_assert(offsetof(BaseSpyTool_GetPositionerBeamLocation, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetPositionerBeamLocation::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetPreferredAttachSocket
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_GetPreferredAttachSocket final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetPreferredAttachSocket) == 0x000004, "Wrong alignment on BaseSpyTool_GetPreferredAttachSocket");
static_assert(sizeof(BaseSpyTool_GetPreferredAttachSocket) == 0x000008, "Wrong size on BaseSpyTool_GetPreferredAttachSocket");
static_assert(offsetof(BaseSpyTool_GetPreferredAttachSocket, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetPreferredAttachSocket::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetRechargeDuration
// 0x0004 (0x0004 - 0x0000)
struct BaseSpyTool_GetRechargeDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetRechargeDuration) == 0x000004, "Wrong alignment on BaseSpyTool_GetRechargeDuration");
static_assert(sizeof(BaseSpyTool_GetRechargeDuration) == 0x000004, "Wrong size on BaseSpyTool_GetRechargeDuration");
static_assert(offsetof(BaseSpyTool_GetRechargeDuration, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetRechargeDuration::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetRecycleRatio
// 0x0004 (0x0004 - 0x0000)
struct BaseSpyTool_GetRecycleRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetRecycleRatio) == 0x000004, "Wrong alignment on BaseSpyTool_GetRecycleRatio");
static_assert(sizeof(BaseSpyTool_GetRecycleRatio) == 0x000004, "Wrong size on BaseSpyTool_GetRecycleRatio");
static_assert(offsetof(BaseSpyTool_GetRecycleRatio, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetRecycleRatio::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetResourceNum
// 0x0004 (0x0004 - 0x0000)
struct BaseSpyTool_GetResourceNum final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetResourceNum) == 0x000004, "Wrong alignment on BaseSpyTool_GetResourceNum");
static_assert(sizeof(BaseSpyTool_GetResourceNum) == 0x000004, "Wrong size on BaseSpyTool_GetResourceNum");
static_assert(offsetof(BaseSpyTool_GetResourceNum, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetResourceNum::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetSecondaryTool
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_GetSecondaryTool final
{
public:
	class ABaseSpyTool*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetSecondaryTool) == 0x000008, "Wrong alignment on BaseSpyTool_GetSecondaryTool");
static_assert(sizeof(BaseSpyTool_GetSecondaryTool) == 0x000008, "Wrong size on BaseSpyTool_GetSecondaryTool");
static_assert(offsetof(BaseSpyTool_GetSecondaryTool, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetSecondaryTool::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetSpyToolType
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_GetSpyToolType final
{
public:
	ESpyToolType                                  ReturnValue;                                       // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetSpyToolType) == 0x000001, "Wrong alignment on BaseSpyTool_GetSpyToolType");
static_assert(sizeof(BaseSpyTool_GetSpyToolType) == 0x000001, "Wrong size on BaseSpyTool_GetSpyToolType");
static_assert(offsetof(BaseSpyTool_GetSpyToolType, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetSpyToolType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetToolCooldownComponent
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_GetToolCooldownComponent final
{
public:
	class UCooldownComponent*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetToolCooldownComponent) == 0x000008, "Wrong alignment on BaseSpyTool_GetToolCooldownComponent");
static_assert(sizeof(BaseSpyTool_GetToolCooldownComponent) == 0x000008, "Wrong size on BaseSpyTool_GetToolCooldownComponent");
static_assert(offsetof(BaseSpyTool_GetToolCooldownComponent, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetToolCooldownComponent::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetToolCooldownRatio
// 0x0004 (0x0004 - 0x0000)
struct BaseSpyTool_GetToolCooldownRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetToolCooldownRatio) == 0x000004, "Wrong alignment on BaseSpyTool_GetToolCooldownRatio");
static_assert(sizeof(BaseSpyTool_GetToolCooldownRatio) == 0x000004, "Wrong size on BaseSpyTool_GetToolCooldownRatio");
static_assert(offsetof(BaseSpyTool_GetToolCooldownRatio, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetToolCooldownRatio::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetToolIconSlateBrush
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyTool_GetToolIconSlateBrush final
{
public:
	class USlateBrushAsset*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetToolIconSlateBrush) == 0x000008, "Wrong alignment on BaseSpyTool_GetToolIconSlateBrush");
static_assert(sizeof(BaseSpyTool_GetToolIconSlateBrush) == 0x000008, "Wrong size on BaseSpyTool_GetToolIconSlateBrush");
static_assert(offsetof(BaseSpyTool_GetToolIconSlateBrush, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetToolIconSlateBrush::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetToolResourceType
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_GetToolResourceType final
{
public:
	EGameplayResourcesType                        ReturnValue;                                       // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetToolResourceType) == 0x000001, "Wrong alignment on BaseSpyTool_GetToolResourceType");
static_assert(sizeof(BaseSpyTool_GetToolResourceType) == 0x000001, "Wrong size on BaseSpyTool_GetToolResourceType");
static_assert(offsetof(BaseSpyTool_GetToolResourceType, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetToolResourceType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetToolWidget
// 0x0010 (0x0010 - 0x0000)
struct BaseSpyTool_GetToolWidget final
{
public:
	int32                                         WidgetIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetToolWidget) == 0x000008, "Wrong alignment on BaseSpyTool_GetToolWidget");
static_assert(sizeof(BaseSpyTool_GetToolWidget) == 0x000010, "Wrong size on BaseSpyTool_GetToolWidget");
static_assert(offsetof(BaseSpyTool_GetToolWidget, WidgetIndex) == 0x000000, "Member 'BaseSpyTool_GetToolWidget::WidgetIndex' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_GetToolWidget, ReturnValue) == 0x000008, "Member 'BaseSpyTool_GetToolWidget::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetToolWidgetByName
// 0x0010 (0x0010 - 0x0000)
struct BaseSpyTool_GetToolWidgetByName final
{
public:
	class FName                                   WidgetName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetToolWidgetByName) == 0x000008, "Wrong alignment on BaseSpyTool_GetToolWidgetByName");
static_assert(sizeof(BaseSpyTool_GetToolWidgetByName) == 0x000010, "Wrong size on BaseSpyTool_GetToolWidgetByName");
static_assert(offsetof(BaseSpyTool_GetToolWidgetByName, WidgetName) == 0x000000, "Member 'BaseSpyTool_GetToolWidgetByName::WidgetName' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_GetToolWidgetByName, ReturnValue) == 0x000008, "Member 'BaseSpyTool_GetToolWidgetByName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.GetUncomittedResourceNum
// 0x0004 (0x0004 - 0x0000)
struct BaseSpyTool_GetUncomittedResourceNum final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_GetUncomittedResourceNum) == 0x000004, "Wrong alignment on BaseSpyTool_GetUncomittedResourceNum");
static_assert(sizeof(BaseSpyTool_GetUncomittedResourceNum) == 0x000004, "Wrong size on BaseSpyTool_GetUncomittedResourceNum");
static_assert(offsetof(BaseSpyTool_GetUncomittedResourceNum, ReturnValue) == 0x000000, "Member 'BaseSpyTool_GetUncomittedResourceNum::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.IsActorInIgnoreList
// 0x0010 (0x0010 - 0x0000)
struct BaseSpyTool_IsActorInIgnoreList final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BaseSpyTool_IsActorInIgnoreList) == 0x000008, "Wrong alignment on BaseSpyTool_IsActorInIgnoreList");
static_assert(sizeof(BaseSpyTool_IsActorInIgnoreList) == 0x000010, "Wrong size on BaseSpyTool_IsActorInIgnoreList");
static_assert(offsetof(BaseSpyTool_IsActorInIgnoreList, TargetActor) == 0x000000, "Member 'BaseSpyTool_IsActorInIgnoreList::TargetActor' has a wrong offset!");
static_assert(offsetof(BaseSpyTool_IsActorInIgnoreList, ReturnValue) == 0x000008, "Member 'BaseSpyTool_IsActorInIgnoreList::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.IsKillcamViewTarget
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_IsKillcamViewTarget final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_IsKillcamViewTarget) == 0x000001, "Wrong alignment on BaseSpyTool_IsKillcamViewTarget");
static_assert(sizeof(BaseSpyTool_IsKillcamViewTarget) == 0x000001, "Wrong size on BaseSpyTool_IsKillcamViewTarget");
static_assert(offsetof(BaseSpyTool_IsKillcamViewTarget, ReturnValue) == 0x000000, "Member 'BaseSpyTool_IsKillcamViewTarget::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.IsLocallyControlled
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_IsLocallyControlled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_IsLocallyControlled) == 0x000001, "Wrong alignment on BaseSpyTool_IsLocallyControlled");
static_assert(sizeof(BaseSpyTool_IsLocallyControlled) == 0x000001, "Wrong size on BaseSpyTool_IsLocallyControlled");
static_assert(offsetof(BaseSpyTool_IsLocallyControlled, ReturnValue) == 0x000000, "Member 'BaseSpyTool_IsLocallyControlled::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.IsOnCooldown
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_IsOnCooldown final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_IsOnCooldown) == 0x000001, "Wrong alignment on BaseSpyTool_IsOnCooldown");
static_assert(sizeof(BaseSpyTool_IsOnCooldown) == 0x000001, "Wrong size on BaseSpyTool_IsOnCooldown");
static_assert(offsetof(BaseSpyTool_IsOnCooldown, ReturnValue) == 0x000000, "Member 'BaseSpyTool_IsOnCooldown::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.IsOwnedByBot
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_IsOwnedByBot final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_IsOwnedByBot) == 0x000001, "Wrong alignment on BaseSpyTool_IsOwnedByBot");
static_assert(sizeof(BaseSpyTool_IsOwnedByBot) == 0x000001, "Wrong size on BaseSpyTool_IsOwnedByBot");
static_assert(offsetof(BaseSpyTool_IsOwnedByBot, ReturnValue) == 0x000000, "Member 'BaseSpyTool_IsOwnedByBot::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.IsPrimaryActive
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_IsPrimaryActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_IsPrimaryActive) == 0x000001, "Wrong alignment on BaseSpyTool_IsPrimaryActive");
static_assert(sizeof(BaseSpyTool_IsPrimaryActive) == 0x000001, "Wrong size on BaseSpyTool_IsPrimaryActive");
static_assert(offsetof(BaseSpyTool_IsPrimaryActive, ReturnValue) == 0x000000, "Member 'BaseSpyTool_IsPrimaryActive::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.IsPrimaryAvailable
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_IsPrimaryAvailable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_IsPrimaryAvailable) == 0x000001, "Wrong alignment on BaseSpyTool_IsPrimaryAvailable");
static_assert(sizeof(BaseSpyTool_IsPrimaryAvailable) == 0x000001, "Wrong size on BaseSpyTool_IsPrimaryAvailable");
static_assert(offsetof(BaseSpyTool_IsPrimaryAvailable, ReturnValue) == 0x000000, "Member 'BaseSpyTool_IsPrimaryAvailable::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.IsRecycleActive
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_IsRecycleActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_IsRecycleActive) == 0x000001, "Wrong alignment on BaseSpyTool_IsRecycleActive");
static_assert(sizeof(BaseSpyTool_IsRecycleActive) == 0x000001, "Wrong size on BaseSpyTool_IsRecycleActive");
static_assert(offsetof(BaseSpyTool_IsRecycleActive, ReturnValue) == 0x000000, "Member 'BaseSpyTool_IsRecycleActive::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.IsRecycleRequested
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_IsRecycleRequested final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_IsRecycleRequested) == 0x000001, "Wrong alignment on BaseSpyTool_IsRecycleRequested");
static_assert(sizeof(BaseSpyTool_IsRecycleRequested) == 0x000001, "Wrong size on BaseSpyTool_IsRecycleRequested");
static_assert(offsetof(BaseSpyTool_IsRecycleRequested, ReturnValue) == 0x000000, "Member 'BaseSpyTool_IsRecycleRequested::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.IsSecondaryActive
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_IsSecondaryActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_IsSecondaryActive) == 0x000001, "Wrong alignment on BaseSpyTool_IsSecondaryActive");
static_assert(sizeof(BaseSpyTool_IsSecondaryActive) == 0x000001, "Wrong size on BaseSpyTool_IsSecondaryActive");
static_assert(offsetof(BaseSpyTool_IsSecondaryActive, ReturnValue) == 0x000000, "Member 'BaseSpyTool_IsSecondaryActive::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.IsSecondaryAvailable
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_IsSecondaryAvailable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_IsSecondaryAvailable) == 0x000001, "Wrong alignment on BaseSpyTool_IsSecondaryAvailable");
static_assert(sizeof(BaseSpyTool_IsSecondaryAvailable) == 0x000001, "Wrong size on BaseSpyTool_IsSecondaryAvailable");
static_assert(offsetof(BaseSpyTool_IsSecondaryAvailable, ReturnValue) == 0x000000, "Member 'BaseSpyTool_IsSecondaryAvailable::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.IsToolActive
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_IsToolActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_IsToolActive) == 0x000001, "Wrong alignment on BaseSpyTool_IsToolActive");
static_assert(sizeof(BaseSpyTool_IsToolActive) == 0x000001, "Wrong size on BaseSpyTool_IsToolActive");
static_assert(offsetof(BaseSpyTool_IsToolActive, ReturnValue) == 0x000000, "Member 'BaseSpyTool_IsToolActive::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.IsToolDisabled
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_IsToolDisabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_IsToolDisabled) == 0x000001, "Wrong alignment on BaseSpyTool_IsToolDisabled");
static_assert(sizeof(BaseSpyTool_IsToolDisabled) == 0x000001, "Wrong size on BaseSpyTool_IsToolDisabled");
static_assert(offsetof(BaseSpyTool_IsToolDisabled, ReturnValue) == 0x000000, "Member 'BaseSpyTool_IsToolDisabled::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.IsToolSelected
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_IsToolSelected final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_IsToolSelected) == 0x000001, "Wrong alignment on BaseSpyTool_IsToolSelected");
static_assert(sizeof(BaseSpyTool_IsToolSelected) == 0x000001, "Wrong size on BaseSpyTool_IsToolSelected");
static_assert(offsetof(BaseSpyTool_IsToolSelected, ReturnValue) == 0x000000, "Member 'BaseSpyTool_IsToolSelected::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyTool.IsUserViewIn1P
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyTool_IsUserViewIn1P final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyTool_IsUserViewIn1P) == 0x000001, "Wrong alignment on BaseSpyTool_IsUserViewIn1P");
static_assert(sizeof(BaseSpyTool_IsUserViewIn1P) == 0x000001, "Wrong size on BaseSpyTool_IsUserViewIn1P");
static_assert(offsetof(BaseSpyTool_IsUserViewIn1P, ReturnValue) == 0x000000, "Member 'BaseSpyTool_IsUserViewIn1P::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyActiveAbility.GetActivePowerRatio
// 0x0004 (0x0004 - 0x0000)
struct BaseSpyActiveAbility_GetActivePowerRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyActiveAbility_GetActivePowerRatio) == 0x000004, "Wrong alignment on BaseSpyActiveAbility_GetActivePowerRatio");
static_assert(sizeof(BaseSpyActiveAbility_GetActivePowerRatio) == 0x000004, "Wrong size on BaseSpyActiveAbility_GetActivePowerRatio");
static_assert(offsetof(BaseSpyActiveAbility_GetActivePowerRatio, ReturnValue) == 0x000000, "Member 'BaseSpyActiveAbility_GetActivePowerRatio::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyActiveAbility.OnVaultLockedPhaseStart
// 0x0008 (0x0008 - 0x0000)
struct BaseSpyActiveAbility_OnVaultLockedPhaseStart final
{
public:
	class UVaultLockedPhaseInfo*                  PhaseInfo;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyActiveAbility_OnVaultLockedPhaseStart) == 0x000008, "Wrong alignment on BaseSpyActiveAbility_OnVaultLockedPhaseStart");
static_assert(sizeof(BaseSpyActiveAbility_OnVaultLockedPhaseStart) == 0x000008, "Wrong size on BaseSpyActiveAbility_OnVaultLockedPhaseStart");
static_assert(offsetof(BaseSpyActiveAbility_OnVaultLockedPhaseStart, PhaseInfo) == 0x000000, "Member 'BaseSpyActiveAbility_OnVaultLockedPhaseStart::PhaseInfo' has a wrong offset!");

// Function DeceiveInc.BaseSpyActiveAbility.Server_CancelActivePower
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyActiveAbility_Server_CancelActivePower final
{
public:
	bool                                          bRefundActive;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyActiveAbility_Server_CancelActivePower) == 0x000001, "Wrong alignment on BaseSpyActiveAbility_Server_CancelActivePower");
static_assert(sizeof(BaseSpyActiveAbility_Server_CancelActivePower) == 0x000001, "Wrong size on BaseSpyActiveAbility_Server_CancelActivePower");
static_assert(offsetof(BaseSpyActiveAbility_Server_CancelActivePower, bRefundActive) == 0x000000, "Member 'BaseSpyActiveAbility_Server_CancelActivePower::bRefundActive' has a wrong offset!");

// Function DeceiveInc.BaseSpyActiveAbility.BP_IsActiveInProgress
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyActiveAbility_BP_IsActiveInProgress final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyActiveAbility_BP_IsActiveInProgress) == 0x000001, "Wrong alignment on BaseSpyActiveAbility_BP_IsActiveInProgress");
static_assert(sizeof(BaseSpyActiveAbility_BP_IsActiveInProgress) == 0x000001, "Wrong size on BaseSpyActiveAbility_BP_IsActiveInProgress");
static_assert(offsetof(BaseSpyActiveAbility_BP_IsActiveInProgress, ReturnValue) == 0x000000, "Member 'BaseSpyActiveAbility_BP_IsActiveInProgress::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyActiveAbility.GetActiveTimeLeft
// 0x0004 (0x0004 - 0x0000)
struct BaseSpyActiveAbility_GetActiveTimeLeft final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyActiveAbility_GetActiveTimeLeft) == 0x000004, "Wrong alignment on BaseSpyActiveAbility_GetActiveTimeLeft");
static_assert(sizeof(BaseSpyActiveAbility_GetActiveTimeLeft) == 0x000004, "Wrong size on BaseSpyActiveAbility_GetActiveTimeLeft");
static_assert(offsetof(BaseSpyActiveAbility_GetActiveTimeLeft, ReturnValue) == 0x000000, "Member 'BaseSpyActiveAbility_GetActiveTimeLeft::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyActiveAbility.HasPendingActiveAbilityOutAnimation
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyActiveAbility_HasPendingActiveAbilityOutAnimation final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyActiveAbility_HasPendingActiveAbilityOutAnimation) == 0x000001, "Wrong alignment on BaseSpyActiveAbility_HasPendingActiveAbilityOutAnimation");
static_assert(sizeof(BaseSpyActiveAbility_HasPendingActiveAbilityOutAnimation) == 0x000001, "Wrong size on BaseSpyActiveAbility_HasPendingActiveAbilityOutAnimation");
static_assert(offsetof(BaseSpyActiveAbility_HasPendingActiveAbilityOutAnimation, ReturnValue) == 0x000000, "Member 'BaseSpyActiveAbility_HasPendingActiveAbilityOutAnimation::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseSpyActiveAbility.IsActive
// 0x0001 (0x0001 - 0x0000)
struct BaseSpyActiveAbility_IsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSpyActiveAbility_IsActive) == 0x000001, "Wrong alignment on BaseSpyActiveAbility_IsActive");
static_assert(sizeof(BaseSpyActiveAbility_IsActive) == 0x000001, "Wrong size on BaseSpyActiveAbility_IsActive");
static_assert(offsetof(BaseSpyActiveAbility_IsActive, ReturnValue) == 0x000000, "Member 'BaseSpyActiveAbility_IsActive::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ChavezActiveAbilityMod2_1.BP_DoorBumped
// 0x0008 (0x0008 - 0x0000)
struct ChavezActiveAbilityMod2_1_BP_DoorBumped final
{
public:
	class ABaseDoorActor*                         Door;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChavezActiveAbilityMod2_1_BP_DoorBumped) == 0x000008, "Wrong alignment on ChavezActiveAbilityMod2_1_BP_DoorBumped");
static_assert(sizeof(ChavezActiveAbilityMod2_1_BP_DoorBumped) == 0x000008, "Wrong size on ChavezActiveAbilityMod2_1_BP_DoorBumped");
static_assert(offsetof(ChavezActiveAbilityMod2_1_BP_DoorBumped, Door) == 0x000000, "Member 'ChavezActiveAbilityMod2_1_BP_DoorBumped::Door' has a wrong offset!");

// Function DeceiveInc.ChavezActiveAbilityMod2_1.MulticastBumpActor
// 0x0008 (0x0008 - 0x0000)
struct ChavezActiveAbilityMod2_1_MulticastBumpActor final
{
public:
	class AActor*                                 BumpedActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChavezActiveAbilityMod2_1_MulticastBumpActor) == 0x000008, "Wrong alignment on ChavezActiveAbilityMod2_1_MulticastBumpActor");
static_assert(sizeof(ChavezActiveAbilityMod2_1_MulticastBumpActor) == 0x000008, "Wrong size on ChavezActiveAbilityMod2_1_MulticastBumpActor");
static_assert(offsetof(ChavezActiveAbilityMod2_1_MulticastBumpActor, BumpedActor) == 0x000000, "Member 'ChavezActiveAbilityMod2_1_MulticastBumpActor::BumpedActor' has a wrong offset!");

// Function DeceiveInc.ChavezActiveAbilityMod2_1.TryBumpActor
// 0x0008 (0x0008 - 0x0000)
struct ChavezActiveAbilityMod2_1_TryBumpActor final
{
public:
	class AActor*                                 ToBump;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChavezActiveAbilityMod2_1_TryBumpActor) == 0x000008, "Wrong alignment on ChavezActiveAbilityMod2_1_TryBumpActor");
static_assert(sizeof(ChavezActiveAbilityMod2_1_TryBumpActor) == 0x000008, "Wrong size on ChavezActiveAbilityMod2_1_TryBumpActor");
static_assert(offsetof(ChavezActiveAbilityMod2_1_TryBumpActor, ToBump) == 0x000000, "Member 'ChavezActiveAbilityMod2_1_TryBumpActor::ToBump' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.GetCurrencyTypeAmount
// 0x0014 (0x0014 - 0x0000)
struct DISessionSubsystem_GetCurrencyTypeAmount final
{
public:
	struct FPrimaryAssetId                        CurrencyType;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSubsystem_GetCurrencyTypeAmount) == 0x000004, "Wrong alignment on DISessionSubsystem_GetCurrencyTypeAmount");
static_assert(sizeof(DISessionSubsystem_GetCurrencyTypeAmount) == 0x000014, "Wrong size on DISessionSubsystem_GetCurrencyTypeAmount");
static_assert(offsetof(DISessionSubsystem_GetCurrencyTypeAmount, CurrencyType) == 0x000000, "Member 'DISessionSubsystem_GetCurrencyTypeAmount::CurrencyType' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_GetCurrencyTypeAmount, ReturnValue) == 0x000010, "Member 'DISessionSubsystem_GetCurrencyTypeAmount::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.GetDIITemCostForCurrency
// 0x0018 (0x0018 - 0x0000)
struct DISessionSubsystem_GetDIITemCostForCurrency final
{
public:
	const class UDIItem*                          ItemToCheck;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDICurrencyItem*                        Currency;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DISessionSubsystem_GetDIITemCostForCurrency) == 0x000008, "Wrong alignment on DISessionSubsystem_GetDIITemCostForCurrency");
static_assert(sizeof(DISessionSubsystem_GetDIITemCostForCurrency) == 0x000018, "Wrong size on DISessionSubsystem_GetDIITemCostForCurrency");
static_assert(offsetof(DISessionSubsystem_GetDIITemCostForCurrency, ItemToCheck) == 0x000000, "Member 'DISessionSubsystem_GetDIITemCostForCurrency::ItemToCheck' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_GetDIITemCostForCurrency, Currency) == 0x000008, "Member 'DISessionSubsystem_GetDIITemCostForCurrency::Currency' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_GetDIITemCostForCurrency, ReturnValue) == 0x000010, "Member 'DISessionSubsystem_GetDIITemCostForCurrency::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.GetItemUnlockInfo
// 0x0020 (0x0020 - 0x0000)
struct DISessionSubsystem_GetItemUnlockInfo final
{
public:
	struct FPrimaryAssetId                        AssetId;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemUnlockLevelArray                  ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSubsystem_GetItemUnlockInfo) == 0x000008, "Wrong alignment on DISessionSubsystem_GetItemUnlockInfo");
static_assert(sizeof(DISessionSubsystem_GetItemUnlockInfo) == 0x000020, "Wrong size on DISessionSubsystem_GetItemUnlockInfo");
static_assert(offsetof(DISessionSubsystem_GetItemUnlockInfo, AssetId) == 0x000000, "Member 'DISessionSubsystem_GetItemUnlockInfo::AssetId' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_GetItemUnlockInfo, ReturnValue) == 0x000010, "Member 'DISessionSubsystem_GetItemUnlockInfo::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.GetXPBoosterActive
// 0x0001 (0x0001 - 0x0000)
struct DISessionSubsystem_GetXPBoosterActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSubsystem_GetXPBoosterActive) == 0x000001, "Wrong alignment on DISessionSubsystem_GetXPBoosterActive");
static_assert(sizeof(DISessionSubsystem_GetXPBoosterActive) == 0x000001, "Wrong size on DISessionSubsystem_GetXPBoosterActive");
static_assert(offsetof(DISessionSubsystem_GetXPBoosterActive, ReturnValue) == 0x000000, "Member 'DISessionSubsystem_GetXPBoosterActive::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.GetXPBoosterAmmount
// 0x0004 (0x0004 - 0x0000)
struct DISessionSubsystem_GetXPBoosterAmmount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSubsystem_GetXPBoosterAmmount) == 0x000004, "Wrong alignment on DISessionSubsystem_GetXPBoosterAmmount");
static_assert(sizeof(DISessionSubsystem_GetXPBoosterAmmount) == 0x000004, "Wrong size on DISessionSubsystem_GetXPBoosterAmmount");
static_assert(offsetof(DISessionSubsystem_GetXPBoosterAmmount, ReturnValue) == 0x000000, "Member 'DISessionSubsystem_GetXPBoosterAmmount::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.GetXPBoosterTimeLeft
// 0x0004 (0x0004 - 0x0000)
struct DISessionSubsystem_GetXPBoosterTimeLeft final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSubsystem_GetXPBoosterTimeLeft) == 0x000004, "Wrong alignment on DISessionSubsystem_GetXPBoosterTimeLeft");
static_assert(sizeof(DISessionSubsystem_GetXPBoosterTimeLeft) == 0x000004, "Wrong size on DISessionSubsystem_GetXPBoosterTimeLeft");
static_assert(offsetof(DISessionSubsystem_GetXPBoosterTimeLeft, ReturnValue) == 0x000000, "Member 'DISessionSubsystem_GetXPBoosterTimeLeft::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.GetXPBoosterTimeLeftFormat
// 0x0010 (0x0010 - 0x0000)
struct DISessionSubsystem_GetXPBoosterTimeLeftFormat final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSubsystem_GetXPBoosterTimeLeftFormat) == 0x000008, "Wrong alignment on DISessionSubsystem_GetXPBoosterTimeLeftFormat");
static_assert(sizeof(DISessionSubsystem_GetXPBoosterTimeLeftFormat) == 0x000010, "Wrong size on DISessionSubsystem_GetXPBoosterTimeLeftFormat");
static_assert(offsetof(DISessionSubsystem_GetXPBoosterTimeLeftFormat, ReturnValue) == 0x000000, "Member 'DISessionSubsystem_GetXPBoosterTimeLeftFormat::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.IsAgentAvailable
// 0x0014 (0x0014 - 0x0000)
struct DISessionSubsystem_IsAgentAvailable final
{
public:
	struct FPrimaryAssetId                        AssetId;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPurchased;                                      // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DISessionSubsystem_IsAgentAvailable) == 0x000004, "Wrong alignment on DISessionSubsystem_IsAgentAvailable");
static_assert(sizeof(DISessionSubsystem_IsAgentAvailable) == 0x000014, "Wrong size on DISessionSubsystem_IsAgentAvailable");
static_assert(offsetof(DISessionSubsystem_IsAgentAvailable, AssetId) == 0x000000, "Member 'DISessionSubsystem_IsAgentAvailable::AssetId' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_IsAgentAvailable, bIsPurchased) == 0x000010, "Member 'DISessionSubsystem_IsAgentAvailable::bIsPurchased' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_IsAgentAvailable, ReturnValue) == 0x000011, "Member 'DISessionSubsystem_IsAgentAvailable::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.IsOwnedItemAccelByteID
// 0x0018 (0x0018 - 0x0000)
struct DISessionSubsystem_IsOwnedItemAccelByteID final
{
public:
	class FString                                 AccelByteItemId;                                   // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DISessionSubsystem_IsOwnedItemAccelByteID) == 0x000008, "Wrong alignment on DISessionSubsystem_IsOwnedItemAccelByteID");
static_assert(sizeof(DISessionSubsystem_IsOwnedItemAccelByteID) == 0x000018, "Wrong size on DISessionSubsystem_IsOwnedItemAccelByteID");
static_assert(offsetof(DISessionSubsystem_IsOwnedItemAccelByteID, AccelByteItemId) == 0x000000, "Member 'DISessionSubsystem_IsOwnedItemAccelByteID::AccelByteItemId' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_IsOwnedItemAccelByteID, ReturnValue) == 0x000010, "Member 'DISessionSubsystem_IsOwnedItemAccelByteID::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.IsOwnedStringItemID
// 0x0018 (0x0018 - 0x0000)
struct DISessionSubsystem_IsOwnedStringItemID final
{
public:
	class FString                                 ItemId;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DISessionSubsystem_IsOwnedStringItemID) == 0x000008, "Wrong alignment on DISessionSubsystem_IsOwnedStringItemID");
static_assert(sizeof(DISessionSubsystem_IsOwnedStringItemID) == 0x000018, "Wrong size on DISessionSubsystem_IsOwnedStringItemID");
static_assert(offsetof(DISessionSubsystem_IsOwnedStringItemID, ItemId) == 0x000000, "Member 'DISessionSubsystem_IsOwnedStringItemID::ItemId' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_IsOwnedStringItemID, ReturnValue) == 0x000010, "Member 'DISessionSubsystem_IsOwnedStringItemID::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.IsSelectedAgentValid
// 0x0001 (0x0001 - 0x0000)
struct DISessionSubsystem_IsSelectedAgentValid final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSubsystem_IsSelectedAgentValid) == 0x000001, "Wrong alignment on DISessionSubsystem_IsSelectedAgentValid");
static_assert(sizeof(DISessionSubsystem_IsSelectedAgentValid) == 0x000001, "Wrong size on DISessionSubsystem_IsSelectedAgentValid");
static_assert(offsetof(DISessionSubsystem_IsSelectedAgentValid, ReturnValue) == 0x000000, "Member 'DISessionSubsystem_IsSelectedAgentValid::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.QuantityOwned
// 0x0014 (0x0014 - 0x0000)
struct DISessionSubsystem_QuantityOwned final
{
public:
	struct FPrimaryAssetId                        AssetId;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSubsystem_QuantityOwned) == 0x000004, "Wrong alignment on DISessionSubsystem_QuantityOwned");
static_assert(sizeof(DISessionSubsystem_QuantityOwned) == 0x000014, "Wrong size on DISessionSubsystem_QuantityOwned");
static_assert(offsetof(DISessionSubsystem_QuantityOwned, AssetId) == 0x000000, "Member 'DISessionSubsystem_QuantityOwned::AssetId' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_QuantityOwned, ReturnValue) == 0x000010, "Member 'DISessionSubsystem_QuantityOwned::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.CanAssetBePurchased
// 0x0014 (0x0014 - 0x0000)
struct DISessionSubsystem_CanAssetBePurchased final
{
public:
	struct FPrimaryAssetId                        AssetId;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DISessionSubsystem_CanAssetBePurchased) == 0x000004, "Wrong alignment on DISessionSubsystem_CanAssetBePurchased");
static_assert(sizeof(DISessionSubsystem_CanAssetBePurchased) == 0x000014, "Wrong size on DISessionSubsystem_CanAssetBePurchased");
static_assert(offsetof(DISessionSubsystem_CanAssetBePurchased, AssetId) == 0x000000, "Member 'DISessionSubsystem_CanAssetBePurchased::AssetId' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_CanAssetBePurchased, ReturnValue) == 0x000010, "Member 'DISessionSubsystem_CanAssetBePurchased::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.CanDIItemBePurchased
// 0x0010 (0x0010 - 0x0000)
struct DISessionSubsystem_CanDIItemBePurchased final
{
public:
	const class UDIItem*                          ItemToCheck;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DISessionSubsystem_CanDIItemBePurchased) == 0x000008, "Wrong alignment on DISessionSubsystem_CanDIItemBePurchased");
static_assert(sizeof(DISessionSubsystem_CanDIItemBePurchased) == 0x000010, "Wrong size on DISessionSubsystem_CanDIItemBePurchased");
static_assert(offsetof(DISessionSubsystem_CanDIItemBePurchased, ItemToCheck) == 0x000000, "Member 'DISessionSubsystem_CanDIItemBePurchased::ItemToCheck' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_CanDIItemBePurchased, ReturnValue) == 0x000008, "Member 'DISessionSubsystem_CanDIItemBePurchased::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.CanPurchaseItemWithCurrency
// 0x0020 (0x0020 - 0x0000)
struct DISessionSubsystem_CanPurchaseItemWithCurrency final
{
public:
	const class UDIItem*                          ItemToCheck;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrencyId;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DISessionSubsystem_CanPurchaseItemWithCurrency) == 0x000008, "Wrong alignment on DISessionSubsystem_CanPurchaseItemWithCurrency");
static_assert(sizeof(DISessionSubsystem_CanPurchaseItemWithCurrency) == 0x000020, "Wrong size on DISessionSubsystem_CanPurchaseItemWithCurrency");
static_assert(offsetof(DISessionSubsystem_CanPurchaseItemWithCurrency, ItemToCheck) == 0x000000, "Member 'DISessionSubsystem_CanPurchaseItemWithCurrency::ItemToCheck' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_CanPurchaseItemWithCurrency, CurrencyId) == 0x000008, "Member 'DISessionSubsystem_CanPurchaseItemWithCurrency::CurrencyId' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_CanPurchaseItemWithCurrency, ReturnValue) == 0x000018, "Member 'DISessionSubsystem_CanPurchaseItemWithCurrency::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.CanPurchaseStringItemWithCurrency
// 0x0028 (0x0028 - 0x0000)
struct DISessionSubsystem_CanPurchaseStringItemWithCurrency final
{
public:
	class FString                                 ItemToCheck;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrencyId;                                        // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DISessionSubsystem_CanPurchaseStringItemWithCurrency) == 0x000008, "Wrong alignment on DISessionSubsystem_CanPurchaseStringItemWithCurrency");
static_assert(sizeof(DISessionSubsystem_CanPurchaseStringItemWithCurrency) == 0x000028, "Wrong size on DISessionSubsystem_CanPurchaseStringItemWithCurrency");
static_assert(offsetof(DISessionSubsystem_CanPurchaseStringItemWithCurrency, ItemToCheck) == 0x000000, "Member 'DISessionSubsystem_CanPurchaseStringItemWithCurrency::ItemToCheck' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_CanPurchaseStringItemWithCurrency, CurrencyId) == 0x000010, "Member 'DISessionSubsystem_CanPurchaseStringItemWithCurrency::CurrencyId' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_CanPurchaseStringItemWithCurrency, ReturnValue) == 0x000020, "Member 'DISessionSubsystem_CanPurchaseStringItemWithCurrency::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.CanShowAssetInMenu
// 0x0014 (0x0014 - 0x0000)
struct DISessionSubsystem_CanShowAssetInMenu final
{
public:
	struct FPrimaryAssetId                        AssetId;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DISessionSubsystem_CanShowAssetInMenu) == 0x000004, "Wrong alignment on DISessionSubsystem_CanShowAssetInMenu");
static_assert(sizeof(DISessionSubsystem_CanShowAssetInMenu) == 0x000014, "Wrong size on DISessionSubsystem_CanShowAssetInMenu");
static_assert(offsetof(DISessionSubsystem_CanShowAssetInMenu, AssetId) == 0x000000, "Member 'DISessionSubsystem_CanShowAssetInMenu::AssetId' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_CanShowAssetInMenu, ReturnValue) == 0x000010, "Member 'DISessionSubsystem_CanShowAssetInMenu::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.DIITemIsOwned
// 0x0010 (0x0010 - 0x0000)
struct DISessionSubsystem_DIITemIsOwned final
{
public:
	const class UDIItem*                          ItemToCheck;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DISessionSubsystem_DIITemIsOwned) == 0x000008, "Wrong alignment on DISessionSubsystem_DIITemIsOwned");
static_assert(sizeof(DISessionSubsystem_DIITemIsOwned) == 0x000010, "Wrong size on DISessionSubsystem_DIITemIsOwned");
static_assert(offsetof(DISessionSubsystem_DIITemIsOwned, ItemToCheck) == 0x000000, "Member 'DISessionSubsystem_DIITemIsOwned::ItemToCheck' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_DIITemIsOwned, ReturnValue) == 0x000008, "Member 'DISessionSubsystem_DIITemIsOwned::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.GetCheatFreeLootAmount
// 0x0004 (0x0004 - 0x0000)
struct DISessionSubsystem_GetCheatFreeLootAmount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSubsystem_GetCheatFreeLootAmount) == 0x000004, "Wrong alignment on DISessionSubsystem_GetCheatFreeLootAmount");
static_assert(sizeof(DISessionSubsystem_GetCheatFreeLootAmount) == 0x000004, "Wrong size on DISessionSubsystem_GetCheatFreeLootAmount");
static_assert(offsetof(DISessionSubsystem_GetCheatFreeLootAmount, ReturnValue) == 0x000000, "Member 'DISessionSubsystem_GetCheatFreeLootAmount::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.GetPlayerTotalMasteries
// 0x0004 (0x0004 - 0x0000)
struct DISessionSubsystem_GetPlayerTotalMasteries final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSubsystem_GetPlayerTotalMasteries) == 0x000004, "Wrong alignment on DISessionSubsystem_GetPlayerTotalMasteries");
static_assert(sizeof(DISessionSubsystem_GetPlayerTotalMasteries) == 0x000004, "Wrong size on DISessionSubsystem_GetPlayerTotalMasteries");
static_assert(offsetof(DISessionSubsystem_GetPlayerTotalMasteries, ReturnValue) == 0x000000, "Member 'DISessionSubsystem_GetPlayerTotalMasteries::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.IsAvailableForUse
// 0x0014 (0x0014 - 0x0000)
struct DISessionSubsystem_IsAvailableForUse final
{
public:
	struct FPrimaryAssetId                        AssetId;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DISessionSubsystem_IsAvailableForUse) == 0x000004, "Wrong alignment on DISessionSubsystem_IsAvailableForUse");
static_assert(sizeof(DISessionSubsystem_IsAvailableForUse) == 0x000014, "Wrong size on DISessionSubsystem_IsAvailableForUse");
static_assert(offsetof(DISessionSubsystem_IsAvailableForUse, AssetId) == 0x000000, "Member 'DISessionSubsystem_IsAvailableForUse::AssetId' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_IsAvailableForUse, ReturnValue) == 0x000010, "Member 'DISessionSubsystem_IsAvailableForUse::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.IsCheatFreeLootBundle
// 0x0001 (0x0001 - 0x0000)
struct DISessionSubsystem_IsCheatFreeLootBundle final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSubsystem_IsCheatFreeLootBundle) == 0x000001, "Wrong alignment on DISessionSubsystem_IsCheatFreeLootBundle");
static_assert(sizeof(DISessionSubsystem_IsCheatFreeLootBundle) == 0x000001, "Wrong size on DISessionSubsystem_IsCheatFreeLootBundle");
static_assert(offsetof(DISessionSubsystem_IsCheatFreeLootBundle, ReturnValue) == 0x000000, "Member 'DISessionSubsystem_IsCheatFreeLootBundle::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.IsConsumableDIItem
// 0x0010 (0x0010 - 0x0000)
struct DISessionSubsystem_IsConsumableDIItem final
{
public:
	const class UDIItem*                          ItemToCheck;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DISessionSubsystem_IsConsumableDIItem) == 0x000008, "Wrong alignment on DISessionSubsystem_IsConsumableDIItem");
static_assert(sizeof(DISessionSubsystem_IsConsumableDIItem) == 0x000010, "Wrong size on DISessionSubsystem_IsConsumableDIItem");
static_assert(offsetof(DISessionSubsystem_IsConsumableDIItem, ItemToCheck) == 0x000000, "Member 'DISessionSubsystem_IsConsumableDIItem::ItemToCheck' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_IsConsumableDIItem, ReturnValue) == 0x000008, "Member 'DISessionSubsystem_IsConsumableDIItem::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.IsConsumableItem
// 0x0018 (0x0018 - 0x0000)
struct DISessionSubsystem_IsConsumableItem final
{
public:
	class FString                                 ItemToCheck;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DISessionSubsystem_IsConsumableItem) == 0x000008, "Wrong alignment on DISessionSubsystem_IsConsumableItem");
static_assert(sizeof(DISessionSubsystem_IsConsumableItem) == 0x000018, "Wrong size on DISessionSubsystem_IsConsumableItem");
static_assert(offsetof(DISessionSubsystem_IsConsumableItem, ItemToCheck) == 0x000000, "Member 'DISessionSubsystem_IsConsumableItem::ItemToCheck' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_IsConsumableItem, ReturnValue) == 0x000010, "Member 'DISessionSubsystem_IsConsumableItem::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.IsGameplayAsset
// 0x0014 (0x0014 - 0x0000)
struct DISessionSubsystem_IsGameplayAsset final
{
public:
	struct FPrimaryAssetId                        AssetId;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DISessionSubsystem_IsGameplayAsset) == 0x000004, "Wrong alignment on DISessionSubsystem_IsGameplayAsset");
static_assert(sizeof(DISessionSubsystem_IsGameplayAsset) == 0x000014, "Wrong size on DISessionSubsystem_IsGameplayAsset");
static_assert(offsetof(DISessionSubsystem_IsGameplayAsset, AssetId) == 0x000000, "Member 'DISessionSubsystem_IsGameplayAsset::AssetId' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_IsGameplayAsset, ReturnValue) == 0x000010, "Member 'DISessionSubsystem_IsGameplayAsset::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.IsInPlayerInventory
// 0x0014 (0x0014 - 0x0000)
struct DISessionSubsystem_IsInPlayerInventory final
{
public:
	struct FPrimaryAssetId                        AssetId;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DISessionSubsystem_IsInPlayerInventory) == 0x000004, "Wrong alignment on DISessionSubsystem_IsInPlayerInventory");
static_assert(sizeof(DISessionSubsystem_IsInPlayerInventory) == 0x000014, "Wrong size on DISessionSubsystem_IsInPlayerInventory");
static_assert(offsetof(DISessionSubsystem_IsInPlayerInventory, AssetId) == 0x000000, "Member 'DISessionSubsystem_IsInPlayerInventory::AssetId' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_IsInPlayerInventory, ReturnValue) == 0x000010, "Member 'DISessionSubsystem_IsInPlayerInventory::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.IsLocalUserToxic
// 0x0001 (0x0001 - 0x0000)
struct DISessionSubsystem_IsLocalUserToxic final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSubsystem_IsLocalUserToxic) == 0x000001, "Wrong alignment on DISessionSubsystem_IsLocalUserToxic");
static_assert(sizeof(DISessionSubsystem_IsLocalUserToxic) == 0x000001, "Wrong size on DISessionSubsystem_IsLocalUserToxic");
static_assert(offsetof(DISessionSubsystem_IsLocalUserToxic, ReturnValue) == 0x000000, "Member 'DISessionSubsystem_IsLocalUserToxic::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.IsOwned
// 0x0014 (0x0014 - 0x0000)
struct DISessionSubsystem_IsOwned final
{
public:
	struct FPrimaryAssetId                        AssetId;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DISessionSubsystem_IsOwned) == 0x000004, "Wrong alignment on DISessionSubsystem_IsOwned");
static_assert(sizeof(DISessionSubsystem_IsOwned) == 0x000014, "Wrong size on DISessionSubsystem_IsOwned");
static_assert(offsetof(DISessionSubsystem_IsOwned, AssetId) == 0x000000, "Member 'DISessionSubsystem_IsOwned::AssetId' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_IsOwned, ReturnValue) == 0x000010, "Member 'DISessionSubsystem_IsOwned::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.IsOwnedItemID
// 0x0008 (0x0008 - 0x0000)
struct DISessionSubsystem_IsOwnedItemID final
{
public:
	int32                                         ItemId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DISessionSubsystem_IsOwnedItemID) == 0x000004, "Wrong alignment on DISessionSubsystem_IsOwnedItemID");
static_assert(sizeof(DISessionSubsystem_IsOwnedItemID) == 0x000008, "Wrong size on DISessionSubsystem_IsOwnedItemID");
static_assert(offsetof(DISessionSubsystem_IsOwnedItemID, ItemId) == 0x000000, "Member 'DISessionSubsystem_IsOwnedItemID::ItemId' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_IsOwnedItemID, ReturnValue) == 0x000004, "Member 'DISessionSubsystem_IsOwnedItemID::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSubsystem.QuantityOwnedStringItemID
// 0x0018 (0x0018 - 0x0000)
struct DISessionSubsystem_QuantityOwnedStringItemID final
{
public:
	class FString                                 ItemId;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DISessionSubsystem_QuantityOwnedStringItemID) == 0x000008, "Wrong alignment on DISessionSubsystem_QuantityOwnedStringItemID");
static_assert(sizeof(DISessionSubsystem_QuantityOwnedStringItemID) == 0x000018, "Wrong size on DISessionSubsystem_QuantityOwnedStringItemID");
static_assert(offsetof(DISessionSubsystem_QuantityOwnedStringItemID, ItemId) == 0x000000, "Member 'DISessionSubsystem_QuantityOwnedStringItemID::ItemId' has a wrong offset!");
static_assert(offsetof(DISessionSubsystem_QuantityOwnedStringItemID, ReturnValue) == 0x000010, "Member 'DISessionSubsystem_QuantityOwnedStringItemID::ReturnValue' has a wrong offset!");

// Function DeceiveInc.AceActiveAbility.GetTimeRemainingBeforeLastHitTargetReset
// 0x0004 (0x0004 - 0x0000)
struct AceActiveAbility_GetTimeRemainingBeforeLastHitTargetReset final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AceActiveAbility_GetTimeRemainingBeforeLastHitTargetReset) == 0x000004, "Wrong alignment on AceActiveAbility_GetTimeRemainingBeforeLastHitTargetReset");
static_assert(sizeof(AceActiveAbility_GetTimeRemainingBeforeLastHitTargetReset) == 0x000004, "Wrong size on AceActiveAbility_GetTimeRemainingBeforeLastHitTargetReset");
static_assert(offsetof(AceActiveAbility_GetTimeRemainingBeforeLastHitTargetReset, ReturnValue) == 0x000000, "Member 'AceActiveAbility_GetTimeRemainingBeforeLastHitTargetReset::ReturnValue' has a wrong offset!");

// Function DeceiveInc.AceActiveAbility.MarkByAceActive
// 0x0008 (0x0008 - 0x0000)
struct AceActiveAbility_MarkByAceActive final
{
public:
	class AActor*                                 MarkedTarget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AceActiveAbility_MarkByAceActive) == 0x000008, "Wrong alignment on AceActiveAbility_MarkByAceActive");
static_assert(sizeof(AceActiveAbility_MarkByAceActive) == 0x000008, "Wrong size on AceActiveAbility_MarkByAceActive");
static_assert(offsetof(AceActiveAbility_MarkByAceActive, MarkedTarget) == 0x000000, "Member 'AceActiveAbility_MarkByAceActive::MarkedTarget' has a wrong offset!");

// Function DeceiveInc.AceActiveAbility.NetMulticast_MarkByAceActive
// 0x0008 (0x0008 - 0x0000)
struct AceActiveAbility_NetMulticast_MarkByAceActive final
{
public:
	class AActor*                                 MarkedTarget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AceActiveAbility_NetMulticast_MarkByAceActive) == 0x000008, "Wrong alignment on AceActiveAbility_NetMulticast_MarkByAceActive");
static_assert(sizeof(AceActiveAbility_NetMulticast_MarkByAceActive) == 0x000008, "Wrong size on AceActiveAbility_NetMulticast_MarkByAceActive");
static_assert(offsetof(AceActiveAbility_NetMulticast_MarkByAceActive, MarkedTarget) == 0x000000, "Member 'AceActiveAbility_NetMulticast_MarkByAceActive::MarkedTarget' has a wrong offset!");

// Function DeceiveInc.AceActiveAbility.NetMulticast_OnActiveEndAnnouncement
// 0x0008 (0x0008 - 0x0000)
struct AceActiveAbility_NetMulticast_OnActiveEndAnnouncement final
{
public:
	class ASpy*                                   SpyTarget;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AceActiveAbility_NetMulticast_OnActiveEndAnnouncement) == 0x000008, "Wrong alignment on AceActiveAbility_NetMulticast_OnActiveEndAnnouncement");
static_assert(sizeof(AceActiveAbility_NetMulticast_OnActiveEndAnnouncement) == 0x000008, "Wrong size on AceActiveAbility_NetMulticast_OnActiveEndAnnouncement");
static_assert(offsetof(AceActiveAbility_NetMulticast_OnActiveEndAnnouncement, SpyTarget) == 0x000000, "Member 'AceActiveAbility_NetMulticast_OnActiveEndAnnouncement::SpyTarget' has a wrong offset!");

// Function DeceiveInc.AceActiveAbility.NetMulticast_OnActiveStartAnnouncement
// 0x0008 (0x0008 - 0x0000)
struct AceActiveAbility_NetMulticast_OnActiveStartAnnouncement final
{
public:
	class ASpy*                                   SpyTarget;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AceActiveAbility_NetMulticast_OnActiveStartAnnouncement) == 0x000008, "Wrong alignment on AceActiveAbility_NetMulticast_OnActiveStartAnnouncement");
static_assert(sizeof(AceActiveAbility_NetMulticast_OnActiveStartAnnouncement) == 0x000008, "Wrong size on AceActiveAbility_NetMulticast_OnActiveStartAnnouncement");
static_assert(offsetof(AceActiveAbility_NetMulticast_OnActiveStartAnnouncement, SpyTarget) == 0x000000, "Member 'AceActiveAbility_NetMulticast_OnActiveStartAnnouncement::SpyTarget' has a wrong offset!");

// Function DeceiveInc.AceActiveAbility.OnConfirmedDamageDealt
// 0x0028 (0x0028 - 0x0000)
struct AceActiveAbility_OnConfirmedDamageDealt final
{
public:
	class AActor*                                 DamagedActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UDamageType*                      DamageType;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AceActiveAbility_OnConfirmedDamageDealt) == 0x000008, "Wrong alignment on AceActiveAbility_OnConfirmedDamageDealt");
static_assert(sizeof(AceActiveAbility_OnConfirmedDamageDealt) == 0x000028, "Wrong size on AceActiveAbility_OnConfirmedDamageDealt");
static_assert(offsetof(AceActiveAbility_OnConfirmedDamageDealt, DamagedActor) == 0x000000, "Member 'AceActiveAbility_OnConfirmedDamageDealt::DamagedActor' has a wrong offset!");
static_assert(offsetof(AceActiveAbility_OnConfirmedDamageDealt, Damage) == 0x000008, "Member 'AceActiveAbility_OnConfirmedDamageDealt::Damage' has a wrong offset!");
static_assert(offsetof(AceActiveAbility_OnConfirmedDamageDealt, DamageType) == 0x000010, "Member 'AceActiveAbility_OnConfirmedDamageDealt::DamageType' has a wrong offset!");
static_assert(offsetof(AceActiveAbility_OnConfirmedDamageDealt, InstigatedBy) == 0x000018, "Member 'AceActiveAbility_OnConfirmedDamageDealt::InstigatedBy' has a wrong offset!");
static_assert(offsetof(AceActiveAbility_OnConfirmedDamageDealt, DamageCauser) == 0x000020, "Member 'AceActiveAbility_OnConfirmedDamageDealt::DamageCauser' has a wrong offset!");

// Function DeceiveInc.AceActiveAbility.OnConfirmedTargetDeath
// 0x0008 (0x0008 - 0x0000)
struct AceActiveAbility_OnConfirmedTargetDeath final
{
public:
	class AActor*                                 DeadActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AceActiveAbility_OnConfirmedTargetDeath) == 0x000008, "Wrong alignment on AceActiveAbility_OnConfirmedTargetDeath");
static_assert(sizeof(AceActiveAbility_OnConfirmedTargetDeath) == 0x000008, "Wrong size on AceActiveAbility_OnConfirmedTargetDeath");
static_assert(offsetof(AceActiveAbility_OnConfirmedTargetDeath, DeadActor) == 0x000000, "Member 'AceActiveAbility_OnConfirmedTargetDeath::DeadActor' has a wrong offset!");

// Function DeceiveInc.AceActiveAbility.OnLastHitTargetDeath
// 0x0008 (0x0008 - 0x0000)
struct AceActiveAbility_OnLastHitTargetDeath final
{
public:
	class AActor*                                 DeadActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AceActiveAbility_OnLastHitTargetDeath) == 0x000008, "Wrong alignment on AceActiveAbility_OnLastHitTargetDeath");
static_assert(sizeof(AceActiveAbility_OnLastHitTargetDeath) == 0x000008, "Wrong size on AceActiveAbility_OnLastHitTargetDeath");
static_assert(offsetof(AceActiveAbility_OnLastHitTargetDeath, DeadActor) == 0x000000, "Member 'AceActiveAbility_OnLastHitTargetDeath::DeadActor' has a wrong offset!");

// Function DeceiveInc.AceActiveAbility.OnLastHitTargetIsOnCooldownChange
// 0x0001 (0x0001 - 0x0000)
struct AceActiveAbility_OnLastHitTargetIsOnCooldownChange final
{
public:
	bool                                          OnCooldown;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AceActiveAbility_OnLastHitTargetIsOnCooldownChange) == 0x000001, "Wrong alignment on AceActiveAbility_OnLastHitTargetIsOnCooldownChange");
static_assert(sizeof(AceActiveAbility_OnLastHitTargetIsOnCooldownChange) == 0x000001, "Wrong size on AceActiveAbility_OnLastHitTargetIsOnCooldownChange");
static_assert(offsetof(AceActiveAbility_OnLastHitTargetIsOnCooldownChange, OnCooldown) == 0x000000, "Member 'AceActiveAbility_OnLastHitTargetIsOnCooldownChange::OnCooldown' has a wrong offset!");

// Function DeceiveInc.AceActiveAbility.OnRep_ConfirmedTarget
// 0x0008 (0x0008 - 0x0000)
struct AceActiveAbility_OnRep_ConfirmedTarget final
{
public:
	class AActor*                                 PrevConfirmedTarget;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AceActiveAbility_OnRep_ConfirmedTarget) == 0x000008, "Wrong alignment on AceActiveAbility_OnRep_ConfirmedTarget");
static_assert(sizeof(AceActiveAbility_OnRep_ConfirmedTarget) == 0x000008, "Wrong size on AceActiveAbility_OnRep_ConfirmedTarget");
static_assert(offsetof(AceActiveAbility_OnRep_ConfirmedTarget, PrevConfirmedTarget) == 0x000000, "Member 'AceActiveAbility_OnRep_ConfirmedTarget::PrevConfirmedTarget' has a wrong offset!");

// Function DeceiveInc.AceActiveAbility.HasValidLastHitTarget
// 0x0001 (0x0001 - 0x0000)
struct AceActiveAbility_HasValidLastHitTarget final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AceActiveAbility_HasValidLastHitTarget) == 0x000001, "Wrong alignment on AceActiveAbility_HasValidLastHitTarget");
static_assert(sizeof(AceActiveAbility_HasValidLastHitTarget) == 0x000001, "Wrong size on AceActiveAbility_HasValidLastHitTarget");
static_assert(offsetof(AceActiveAbility_HasValidLastHitTarget, ReturnValue) == 0x000000, "Member 'AceActiveAbility_HasValidLastHitTarget::ReturnValue' has a wrong offset!");

// Function DeceiveInc.AceActiveAbilityHeatVision.HandleSpyHeatChanged
// 0x0010 (0x0010 - 0x0000)
struct AceActiveAbilityHeatVision_HandleSpyHeatChanged final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewHeatValue;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeatDelta;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AceActiveAbilityHeatVision_HandleSpyHeatChanged) == 0x000008, "Wrong alignment on AceActiveAbilityHeatVision_HandleSpyHeatChanged");
static_assert(sizeof(AceActiveAbilityHeatVision_HandleSpyHeatChanged) == 0x000010, "Wrong size on AceActiveAbilityHeatVision_HandleSpyHeatChanged");
static_assert(offsetof(AceActiveAbilityHeatVision_HandleSpyHeatChanged, Spy) == 0x000000, "Member 'AceActiveAbilityHeatVision_HandleSpyHeatChanged::Spy' has a wrong offset!");
static_assert(offsetof(AceActiveAbilityHeatVision_HandleSpyHeatChanged, NewHeatValue) == 0x000008, "Member 'AceActiveAbilityHeatVision_HandleSpyHeatChanged::NewHeatValue' has a wrong offset!");
static_assert(offsetof(AceActiveAbilityHeatVision_HandleSpyHeatChanged, HeatDelta) == 0x00000C, "Member 'AceActiveAbilityHeatVision_HandleSpyHeatChanged::HeatDelta' has a wrong offset!");

// Function DeceiveInc.AceActiveAbilityHeatVision.NetMulticast_OnVictimEffectStart
// 0x0008 (0x0008 - 0x0000)
struct AceActiveAbilityHeatVision_NetMulticast_OnVictimEffectStart final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AceActiveAbilityHeatVision_NetMulticast_OnVictimEffectStart) == 0x000008, "Wrong alignment on AceActiveAbilityHeatVision_NetMulticast_OnVictimEffectStart");
static_assert(sizeof(AceActiveAbilityHeatVision_NetMulticast_OnVictimEffectStart) == 0x000008, "Wrong size on AceActiveAbilityHeatVision_NetMulticast_OnVictimEffectStart");
static_assert(offsetof(AceActiveAbilityHeatVision_NetMulticast_OnVictimEffectStart, Victim) == 0x000000, "Member 'AceActiveAbilityHeatVision_NetMulticast_OnVictimEffectStart::Victim' has a wrong offset!");

// Function DeceiveInc.AceActiveAbilityHeatVision.NetMulticast_SpyAffectedByZoneChange
// 0x0010 (0x0010 - 0x0000)
struct AceActiveAbilityHeatVision_NetMulticast_SpyAffectedByZoneChange final
{
public:
	class ASpy*                                   AffectedSpyIn;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectedIn;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AceActiveAbilityHeatVision_NetMulticast_SpyAffectedByZoneChange) == 0x000008, "Wrong alignment on AceActiveAbilityHeatVision_NetMulticast_SpyAffectedByZoneChange");
static_assert(sizeof(AceActiveAbilityHeatVision_NetMulticast_SpyAffectedByZoneChange) == 0x000010, "Wrong size on AceActiveAbilityHeatVision_NetMulticast_SpyAffectedByZoneChange");
static_assert(offsetof(AceActiveAbilityHeatVision_NetMulticast_SpyAffectedByZoneChange, AffectedSpyIn) == 0x000000, "Member 'AceActiveAbilityHeatVision_NetMulticast_SpyAffectedByZoneChange::AffectedSpyIn' has a wrong offset!");
static_assert(offsetof(AceActiveAbilityHeatVision_NetMulticast_SpyAffectedByZoneChange, bAffectedIn) == 0x000008, "Member 'AceActiveAbilityHeatVision_NetMulticast_SpyAffectedByZoneChange::bAffectedIn' has a wrong offset!");

// Function DeceiveInc.DIPrimaryDataAsset.BP_GetPrimaryAssetId
// 0x0010 (0x0010 - 0x0000)
struct DIPrimaryDataAsset_BP_GetPrimaryAssetId final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPrimaryDataAsset_BP_GetPrimaryAssetId) == 0x000004, "Wrong alignment on DIPrimaryDataAsset_BP_GetPrimaryAssetId");
static_assert(sizeof(DIPrimaryDataAsset_BP_GetPrimaryAssetId) == 0x000010, "Wrong size on DIPrimaryDataAsset_BP_GetPrimaryAssetId");
static_assert(offsetof(DIPrimaryDataAsset_BP_GetPrimaryAssetId, ReturnValue) == 0x000000, "Member 'DIPrimaryDataAsset_BP_GetPrimaryAssetId::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPrimaryDataAsset.GetIdentifierString
// 0x0010 (0x0010 - 0x0000)
struct DIPrimaryDataAsset_GetIdentifierString final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPrimaryDataAsset_GetIdentifierString) == 0x000008, "Wrong alignment on DIPrimaryDataAsset_GetIdentifierString");
static_assert(sizeof(DIPrimaryDataAsset_GetIdentifierString) == 0x000010, "Wrong size on DIPrimaryDataAsset_GetIdentifierString");
static_assert(offsetof(DIPrimaryDataAsset_GetIdentifierString, ReturnValue) == 0x000000, "Member 'DIPrimaryDataAsset_GetIdentifierString::ReturnValue' has a wrong offset!");

// Function DeceiveInc.AceActiveAbilityMod2.HandleMiscToolSpawned
// 0x0008 (0x0008 - 0x0000)
struct AceActiveAbilityMod2_HandleMiscToolSpawned final
{
public:
	class AActor*                                 SpawnedTool;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AceActiveAbilityMod2_HandleMiscToolSpawned) == 0x000008, "Wrong alignment on AceActiveAbilityMod2_HandleMiscToolSpawned");
static_assert(sizeof(AceActiveAbilityMod2_HandleMiscToolSpawned) == 0x000008, "Wrong size on AceActiveAbilityMod2_HandleMiscToolSpawned");
static_assert(offsetof(AceActiveAbilityMod2_HandleMiscToolSpawned, SpawnedTool) == 0x000000, "Member 'AceActiveAbilityMod2_HandleMiscToolSpawned::SpawnedTool' has a wrong offset!");

// Function DeceiveInc.DiActivitySubsystem.HandleMenuEvent
// 0x0018 (0x0018 - 0x0000)
struct DiActivitySubsystem_HandleMenuEvent final
{
public:
	class FString                                 EventName;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AnswerValue;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DiActivitySubsystem_HandleMenuEvent) == 0x000008, "Wrong alignment on DiActivitySubsystem_HandleMenuEvent");
static_assert(sizeof(DiActivitySubsystem_HandleMenuEvent) == 0x000018, "Wrong size on DiActivitySubsystem_HandleMenuEvent");
static_assert(offsetof(DiActivitySubsystem_HandleMenuEvent, EventName) == 0x000000, "Member 'DiActivitySubsystem_HandleMenuEvent::EventName' has a wrong offset!");
static_assert(offsetof(DiActivitySubsystem_HandleMenuEvent, AnswerValue) == 0x000010, "Member 'DiActivitySubsystem_HandleMenuEvent::AnswerValue' has a wrong offset!");

// Function DeceiveInc.DiActivitySubsystem.HandleStateChanged
// 0x0008 (0x0008 - 0x0000)
struct DiActivitySubsystem_HandleStateChanged final
{
public:
	class FName                                   CurrentState;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiActivitySubsystem_HandleStateChanged) == 0x000004, "Wrong alignment on DiActivitySubsystem_HandleStateChanged");
static_assert(sizeof(DiActivitySubsystem_HandleStateChanged) == 0x000008, "Wrong size on DiActivitySubsystem_HandleStateChanged");
static_assert(offsetof(DiActivitySubsystem_HandleStateChanged, CurrentState) == 0x000000, "Member 'DiActivitySubsystem_HandleStateChanged::CurrentState' has a wrong offset!");

// Function DeceiveInc.DiActivitySubsystem.OnPostLoadMap
// 0x0008 (0x0008 - 0x0000)
struct DiActivitySubsystem_OnPostLoadMap final
{
public:
	class UWorld*                                 LoadedWorld;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiActivitySubsystem_OnPostLoadMap) == 0x000008, "Wrong alignment on DiActivitySubsystem_OnPostLoadMap");
static_assert(sizeof(DiActivitySubsystem_OnPostLoadMap) == 0x000008, "Wrong size on DiActivitySubsystem_OnPostLoadMap");
static_assert(offsetof(DiActivitySubsystem_OnPostLoadMap, LoadedWorld) == 0x000000, "Member 'DiActivitySubsystem_OnPostLoadMap::LoadedWorld' has a wrong offset!");

// Function DeceiveInc.DiActivitySubsystem.OnWorldCleanup
// 0x0010 (0x0010 - 0x0000)
struct DiActivitySubsystem_OnWorldCleanup final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSessionEnded;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCleanupResources;                                 // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DiActivitySubsystem_OnWorldCleanup) == 0x000008, "Wrong alignment on DiActivitySubsystem_OnWorldCleanup");
static_assert(sizeof(DiActivitySubsystem_OnWorldCleanup) == 0x000010, "Wrong size on DiActivitySubsystem_OnWorldCleanup");
static_assert(offsetof(DiActivitySubsystem_OnWorldCleanup, World) == 0x000000, "Member 'DiActivitySubsystem_OnWorldCleanup::World' has a wrong offset!");
static_assert(offsetof(DiActivitySubsystem_OnWorldCleanup, bSessionEnded) == 0x000008, "Member 'DiActivitySubsystem_OnWorldCleanup::bSessionEnded' has a wrong offset!");
static_assert(offsetof(DiActivitySubsystem_OnWorldCleanup, bCleanupResources) == 0x000009, "Member 'DiActivitySubsystem_OnWorldCleanup::bCleanupResources' has a wrong offset!");

// Function DeceiveInc.AceHeatVisionZone.BP_OnZoneRadiusScaleFactorChange
// 0x0004 (0x0004 - 0x0000)
struct AceHeatVisionZone_BP_OnZoneRadiusScaleFactorChange final
{
public:
	float                                         NewScaleFactor;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AceHeatVisionZone_BP_OnZoneRadiusScaleFactorChange) == 0x000004, "Wrong alignment on AceHeatVisionZone_BP_OnZoneRadiusScaleFactorChange");
static_assert(sizeof(AceHeatVisionZone_BP_OnZoneRadiusScaleFactorChange) == 0x000004, "Wrong size on AceHeatVisionZone_BP_OnZoneRadiusScaleFactorChange");
static_assert(offsetof(AceHeatVisionZone_BP_OnZoneRadiusScaleFactorChange, NewScaleFactor) == 0x000000, "Member 'AceHeatVisionZone_BP_OnZoneRadiusScaleFactorChange::NewScaleFactor' has a wrong offset!");

// Function DeceiveInc.AceHeatVisionZone.HandleComponentOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct AceHeatVisionZone_HandleComponentOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AceHeatVisionZone_HandleComponentOverlapEnd) == 0x000008, "Wrong alignment on AceHeatVisionZone_HandleComponentOverlapEnd");
static_assert(sizeof(AceHeatVisionZone_HandleComponentOverlapEnd) == 0x000020, "Wrong size on AceHeatVisionZone_HandleComponentOverlapEnd");
static_assert(offsetof(AceHeatVisionZone_HandleComponentOverlapEnd, OverlappedComponent) == 0x000000, "Member 'AceHeatVisionZone_HandleComponentOverlapEnd::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(AceHeatVisionZone_HandleComponentOverlapEnd, OtherActor) == 0x000008, "Member 'AceHeatVisionZone_HandleComponentOverlapEnd::OtherActor' has a wrong offset!");
static_assert(offsetof(AceHeatVisionZone_HandleComponentOverlapEnd, OtherComp) == 0x000010, "Member 'AceHeatVisionZone_HandleComponentOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(AceHeatVisionZone_HandleComponentOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'AceHeatVisionZone_HandleComponentOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function DeceiveInc.AceHeatVisionZone.HandleComponentOverlapStart
// 0x00A8 (0x00A8 - 0x0000)
struct AceHeatVisionZone_HandleComponentOverlapStart final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(AceHeatVisionZone_HandleComponentOverlapStart) == 0x000008, "Wrong alignment on AceHeatVisionZone_HandleComponentOverlapStart");
static_assert(sizeof(AceHeatVisionZone_HandleComponentOverlapStart) == 0x0000A8, "Wrong size on AceHeatVisionZone_HandleComponentOverlapStart");
static_assert(offsetof(AceHeatVisionZone_HandleComponentOverlapStart, OverlappedComponent) == 0x000000, "Member 'AceHeatVisionZone_HandleComponentOverlapStart::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(AceHeatVisionZone_HandleComponentOverlapStart, OtherActor) == 0x000008, "Member 'AceHeatVisionZone_HandleComponentOverlapStart::OtherActor' has a wrong offset!");
static_assert(offsetof(AceHeatVisionZone_HandleComponentOverlapStart, OtherComp) == 0x000010, "Member 'AceHeatVisionZone_HandleComponentOverlapStart::OtherComp' has a wrong offset!");
static_assert(offsetof(AceHeatVisionZone_HandleComponentOverlapStart, OtherBodyIndex) == 0x000018, "Member 'AceHeatVisionZone_HandleComponentOverlapStart::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(AceHeatVisionZone_HandleComponentOverlapStart, bFromSweep) == 0x00001C, "Member 'AceHeatVisionZone_HandleComponentOverlapStart::bFromSweep' has a wrong offset!");
static_assert(offsetof(AceHeatVisionZone_HandleComponentOverlapStart, SweepResult) == 0x000020, "Member 'AceHeatVisionZone_HandleComponentOverlapStart::SweepResult' has a wrong offset!");

// Function DeceiveInc.AceHeatVisionZone.SetCollisionMesh
// 0x0008 (0x0008 - 0x0000)
struct AceHeatVisionZone_SetCollisionMesh final
{
public:
	class UStaticMeshComponent*                   CollisionMeshIn;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AceHeatVisionZone_SetCollisionMesh) == 0x000008, "Wrong alignment on AceHeatVisionZone_SetCollisionMesh");
static_assert(sizeof(AceHeatVisionZone_SetCollisionMesh) == 0x000008, "Wrong size on AceHeatVisionZone_SetCollisionMesh");
static_assert(offsetof(AceHeatVisionZone_SetCollisionMesh, CollisionMeshIn) == 0x000000, "Member 'AceHeatVisionZone_SetCollisionMesh::CollisionMeshIn' has a wrong offset!");

// Function DeceiveInc.AceHeatVisionZone.SetDefaultRadius
// 0x0004 (0x0004 - 0x0000)
struct AceHeatVisionZone_SetDefaultRadius final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AceHeatVisionZone_SetDefaultRadius) == 0x000004, "Wrong alignment on AceHeatVisionZone_SetDefaultRadius");
static_assert(sizeof(AceHeatVisionZone_SetDefaultRadius) == 0x000004, "Wrong size on AceHeatVisionZone_SetDefaultRadius");
static_assert(offsetof(AceHeatVisionZone_SetDefaultRadius, Radius) == 0x000000, "Member 'AceHeatVisionZone_SetDefaultRadius::Radius' has a wrong offset!");

// Function DeceiveInc.AceHeatVisionZone.GetDefaultRadius
// 0x0004 (0x0004 - 0x0000)
struct AceHeatVisionZone_GetDefaultRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AceHeatVisionZone_GetDefaultRadius) == 0x000004, "Wrong alignment on AceHeatVisionZone_GetDefaultRadius");
static_assert(sizeof(AceHeatVisionZone_GetDefaultRadius) == 0x000004, "Wrong size on AceHeatVisionZone_GetDefaultRadius");
static_assert(offsetof(AceHeatVisionZone_GetDefaultRadius, ReturnValue) == 0x000000, "Member 'AceHeatVisionZone_GetDefaultRadius::ReturnValue' has a wrong offset!");

// Function DeceiveInc.AceHeatVisionZone.GetZoneRadiusScaleFactor
// 0x0004 (0x0004 - 0x0000)
struct AceHeatVisionZone_GetZoneRadiusScaleFactor final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AceHeatVisionZone_GetZoneRadiusScaleFactor) == 0x000004, "Wrong alignment on AceHeatVisionZone_GetZoneRadiusScaleFactor");
static_assert(sizeof(AceHeatVisionZone_GetZoneRadiusScaleFactor) == 0x000004, "Wrong size on AceHeatVisionZone_GetZoneRadiusScaleFactor");
static_assert(offsetof(AceHeatVisionZone_GetZoneRadiusScaleFactor, ReturnValue) == 0x000000, "Member 'AceHeatVisionZone_GetZoneRadiusScaleFactor::ReturnValue' has a wrong offset!");

// Function DeceiveInc.AcePassiveAbility.HandleHitConfirmed
// 0x0040 (0x0040 - 0x0000)
struct AcePassiveAbility_HandleHitConfirmed final
{
public:
	struct FHitConfirmData                        HitConfirmData;                                    // 0x0000(0x0040)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(AcePassiveAbility_HandleHitConfirmed) == 0x000008, "Wrong alignment on AcePassiveAbility_HandleHitConfirmed");
static_assert(sizeof(AcePassiveAbility_HandleHitConfirmed) == 0x000040, "Wrong size on AcePassiveAbility_HandleHitConfirmed");
static_assert(offsetof(AcePassiveAbility_HandleHitConfirmed, HitConfirmData) == 0x000000, "Member 'AcePassiveAbility_HandleHitConfirmed::HitConfirmData' has a wrong offset!");

// Function DeceiveInc.AcePassiveAbility.HandleShotFired
// 0x0018 (0x0018 - 0x0000)
struct AcePassiveAbility_HandleShotFired final
{
public:
	struct FVector                                ShotEndPoint;                                      // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AProjectileWeapon*                      Weapon_0;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AcePassiveAbility_HandleShotFired) == 0x000008, "Wrong alignment on AcePassiveAbility_HandleShotFired");
static_assert(sizeof(AcePassiveAbility_HandleShotFired) == 0x000018, "Wrong size on AcePassiveAbility_HandleShotFired");
static_assert(offsetof(AcePassiveAbility_HandleShotFired, ShotEndPoint) == 0x000000, "Member 'AcePassiveAbility_HandleShotFired::ShotEndPoint' has a wrong offset!");
static_assert(offsetof(AcePassiveAbility_HandleShotFired, Weapon_0) == 0x000010, "Member 'AcePassiveAbility_HandleShotFired::Weapon_0' has a wrong offset!");

// Function DeceiveInc.AcePassiveAbility.OnChargeCanceledClient
// 0x0001 (0x0001 - 0x0000)
struct AcePassiveAbility_OnChargeCanceledClient final
{
public:
	bool                                          bShotFired;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AcePassiveAbility_OnChargeCanceledClient) == 0x000001, "Wrong alignment on AcePassiveAbility_OnChargeCanceledClient");
static_assert(sizeof(AcePassiveAbility_OnChargeCanceledClient) == 0x000001, "Wrong size on AcePassiveAbility_OnChargeCanceledClient");
static_assert(offsetof(AcePassiveAbility_OnChargeCanceledClient, bShotFired) == 0x000000, "Member 'AcePassiveAbility_OnChargeCanceledClient::bShotFired' has a wrong offset!");

// Function DeceiveInc.AcePassiveAbility.GetChargeRatio
// 0x0004 (0x0004 - 0x0000)
struct AcePassiveAbility_GetChargeRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AcePassiveAbility_GetChargeRatio) == 0x000004, "Wrong alignment on AcePassiveAbility_GetChargeRatio");
static_assert(sizeof(AcePassiveAbility_GetChargeRatio) == 0x000004, "Wrong size on AcePassiveAbility_GetChargeRatio");
static_assert(offsetof(AcePassiveAbility_GetChargeRatio, ReturnValue) == 0x000000, "Member 'AcePassiveAbility_GetChargeRatio::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BasePlaceable.OnDeath
// 0x0008 (0x0008 - 0x0000)
struct BasePlaceable_OnDeath final
{
public:
	class AActor*                                 DeadActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasePlaceable_OnDeath) == 0x000008, "Wrong alignment on BasePlaceable_OnDeath");
static_assert(sizeof(BasePlaceable_OnDeath) == 0x000008, "Wrong size on BasePlaceable_OnDeath");
static_assert(offsetof(BasePlaceable_OnDeath, DeadActor) == 0x000000, "Member 'BasePlaceable_OnDeath::DeadActor' has a wrong offset!");

// Function DeceiveInc.BasePlaceable.IsLocallyOwned
// 0x0001 (0x0001 - 0x0000)
struct BasePlaceable_IsLocallyOwned final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasePlaceable_IsLocallyOwned) == 0x000001, "Wrong alignment on BasePlaceable_IsLocallyOwned");
static_assert(sizeof(BasePlaceable_IsLocallyOwned) == 0x000001, "Wrong size on BasePlaceable_IsLocallyOwned");
static_assert(offsetof(BasePlaceable_IsLocallyOwned, ReturnValue) == 0x000000, "Member 'BasePlaceable_IsLocallyOwned::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BasePlaceable.IsOwnerFriendlyWith
// 0x0010 (0x0010 - 0x0000)
struct BasePlaceable_IsOwnerFriendlyWith final
{
public:
	const class AActor*                           ToCheck;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BasePlaceable_IsOwnerFriendlyWith) == 0x000008, "Wrong alignment on BasePlaceable_IsOwnerFriendlyWith");
static_assert(sizeof(BasePlaceable_IsOwnerFriendlyWith) == 0x000010, "Wrong size on BasePlaceable_IsOwnerFriendlyWith");
static_assert(offsetof(BasePlaceable_IsOwnerFriendlyWith, ToCheck) == 0x000000, "Member 'BasePlaceable_IsOwnerFriendlyWith::ToCheck' has a wrong offset!");
static_assert(offsetof(BasePlaceable_IsOwnerFriendlyWith, ReturnValue) == 0x000008, "Member 'BasePlaceable_IsOwnerFriendlyWith::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BasePickablePlaceable.BP_SetCanBePing
// 0x0001 (0x0001 - 0x0000)
struct BasePickablePlaceable_BP_SetCanBePing final
{
public:
	bool                                          bCanBePingIn;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasePickablePlaceable_BP_SetCanBePing) == 0x000001, "Wrong alignment on BasePickablePlaceable_BP_SetCanBePing");
static_assert(sizeof(BasePickablePlaceable_BP_SetCanBePing) == 0x000001, "Wrong size on BasePickablePlaceable_BP_SetCanBePing");
static_assert(offsetof(BasePickablePlaceable_BP_SetCanBePing, bCanBePingIn) == 0x000000, "Member 'BasePickablePlaceable_BP_SetCanBePing::bCanBePingIn' has a wrong offset!");

// Function DeceiveInc.BasePickablePlaceable.HandleDropDone
// 0x0020 (0x0020 - 0x0000)
struct BasePickablePlaceable_HandleDropDone final
{
public:
	class AActor*                                 ActorDropped;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndPos;                                            // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               EndRotation;                                       // 0x0014(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasePickablePlaceable_HandleDropDone) == 0x000008, "Wrong alignment on BasePickablePlaceable_HandleDropDone");
static_assert(sizeof(BasePickablePlaceable_HandleDropDone) == 0x000020, "Wrong size on BasePickablePlaceable_HandleDropDone");
static_assert(offsetof(BasePickablePlaceable_HandleDropDone, ActorDropped) == 0x000000, "Member 'BasePickablePlaceable_HandleDropDone::ActorDropped' has a wrong offset!");
static_assert(offsetof(BasePickablePlaceable_HandleDropDone, EndPos) == 0x000008, "Member 'BasePickablePlaceable_HandleDropDone::EndPos' has a wrong offset!");
static_assert(offsetof(BasePickablePlaceable_HandleDropDone, EndRotation) == 0x000014, "Member 'BasePickablePlaceable_HandleDropDone::EndRotation' has a wrong offset!");

// Function DeceiveInc.BasePickablePlaceable.HandleEMPIsAffectedChanged
// 0x0010 (0x0010 - 0x0000)
struct BasePickablePlaceable_HandleEMPIsAffectedChanged final
{
public:
	bool                                          bIsAffected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AffectedActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasePickablePlaceable_HandleEMPIsAffectedChanged) == 0x000008, "Wrong alignment on BasePickablePlaceable_HandleEMPIsAffectedChanged");
static_assert(sizeof(BasePickablePlaceable_HandleEMPIsAffectedChanged) == 0x000010, "Wrong size on BasePickablePlaceable_HandleEMPIsAffectedChanged");
static_assert(offsetof(BasePickablePlaceable_HandleEMPIsAffectedChanged, bIsAffected) == 0x000000, "Member 'BasePickablePlaceable_HandleEMPIsAffectedChanged::bIsAffected' has a wrong offset!");
static_assert(offsetof(BasePickablePlaceable_HandleEMPIsAffectedChanged, AffectedActor) == 0x000008, "Member 'BasePickablePlaceable_HandleEMPIsAffectedChanged::AffectedActor' has a wrong offset!");

// Function DeceiveInc.BasePickablePlaceable.HandleScramblerIsAffectedChanged
// 0x0010 (0x0010 - 0x0000)
struct BasePickablePlaceable_HandleScramblerIsAffectedChanged final
{
public:
	bool                                          bIsAffected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AffectedActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasePickablePlaceable_HandleScramblerIsAffectedChanged) == 0x000008, "Wrong alignment on BasePickablePlaceable_HandleScramblerIsAffectedChanged");
static_assert(sizeof(BasePickablePlaceable_HandleScramblerIsAffectedChanged) == 0x000010, "Wrong size on BasePickablePlaceable_HandleScramblerIsAffectedChanged");
static_assert(offsetof(BasePickablePlaceable_HandleScramblerIsAffectedChanged, bIsAffected) == 0x000000, "Member 'BasePickablePlaceable_HandleScramblerIsAffectedChanged::bIsAffected' has a wrong offset!");
static_assert(offsetof(BasePickablePlaceable_HandleScramblerIsAffectedChanged, AffectedActor) == 0x000008, "Member 'BasePickablePlaceable_HandleScramblerIsAffectedChanged::AffectedActor' has a wrong offset!");

// Function DeceiveInc.BouncingMat.MulticastNPCImpulse
// 0x0020 (0x0020 - 0x0000)
struct BouncingMat_MulticastNPCImpulse final
{
public:
	struct FVector_NetQuantize                    Impulse;                                           // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    VelocityIn;                                        // 0x000C(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANPCCharacter*                          ImpulsedNPC;                                       // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BouncingMat_MulticastNPCImpulse) == 0x000008, "Wrong alignment on BouncingMat_MulticastNPCImpulse");
static_assert(sizeof(BouncingMat_MulticastNPCImpulse) == 0x000020, "Wrong size on BouncingMat_MulticastNPCImpulse");
static_assert(offsetof(BouncingMat_MulticastNPCImpulse, Impulse) == 0x000000, "Member 'BouncingMat_MulticastNPCImpulse::Impulse' has a wrong offset!");
static_assert(offsetof(BouncingMat_MulticastNPCImpulse, VelocityIn) == 0x00000C, "Member 'BouncingMat_MulticastNPCImpulse::VelocityIn' has a wrong offset!");
static_assert(offsetof(BouncingMat_MulticastNPCImpulse, ImpulsedNPC) == 0x000018, "Member 'BouncingMat_MulticastNPCImpulse::ImpulsedNPC' has a wrong offset!");

// Function DeceiveInc.BouncingMat.OnBouncingMatOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct BouncingMat_OnBouncingMatOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(BouncingMat_OnBouncingMatOverlap) == 0x000008, "Wrong alignment on BouncingMat_OnBouncingMatOverlap");
static_assert(sizeof(BouncingMat_OnBouncingMatOverlap) == 0x0000A8, "Wrong size on BouncingMat_OnBouncingMatOverlap");
static_assert(offsetof(BouncingMat_OnBouncingMatOverlap, OverlappedComponent) == 0x000000, "Member 'BouncingMat_OnBouncingMatOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(BouncingMat_OnBouncingMatOverlap, OtherActor) == 0x000008, "Member 'BouncingMat_OnBouncingMatOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(BouncingMat_OnBouncingMatOverlap, OtherComp) == 0x000010, "Member 'BouncingMat_OnBouncingMatOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(BouncingMat_OnBouncingMatOverlap, OtherBodyIndex) == 0x000018, "Member 'BouncingMat_OnBouncingMatOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(BouncingMat_OnBouncingMatOverlap, bFromSweep) == 0x00001C, "Member 'BouncingMat_OnBouncingMatOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(BouncingMat_OnBouncingMatOverlap, SweepResult) == 0x000020, "Member 'BouncingMat_OnBouncingMatOverlap::SweepResult' has a wrong offset!");

// Function DeceiveInc.BouncingMat.ServerSetInflate
// 0x0001 (0x0001 - 0x0000)
struct BouncingMat_ServerSetInflate final
{
public:
	bool                                          bInflated;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BouncingMat_ServerSetInflate) == 0x000001, "Wrong alignment on BouncingMat_ServerSetInflate");
static_assert(sizeof(BouncingMat_ServerSetInflate) == 0x000001, "Wrong size on BouncingMat_ServerSetInflate");
static_assert(offsetof(BouncingMat_ServerSetInflate, bInflated) == 0x000000, "Member 'BouncingMat_ServerSetInflate::bInflated' has a wrong offset!");

// Function DeceiveInc.BouncingMat.ServerSpyBouncedLocalImpulse
// 0x0020 (0x0020 - 0x0000)
struct BouncingMat_ServerSpyBouncedLocalImpulse final
{
public:
	class ASpy*                                   BouncedSpyIn;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    Impulse;                                           // 0x0008(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    VelocityIn;                                        // 0x0014(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BouncingMat_ServerSpyBouncedLocalImpulse) == 0x000008, "Wrong alignment on BouncingMat_ServerSpyBouncedLocalImpulse");
static_assert(sizeof(BouncingMat_ServerSpyBouncedLocalImpulse) == 0x000020, "Wrong size on BouncingMat_ServerSpyBouncedLocalImpulse");
static_assert(offsetof(BouncingMat_ServerSpyBouncedLocalImpulse, BouncedSpyIn) == 0x000000, "Member 'BouncingMat_ServerSpyBouncedLocalImpulse::BouncedSpyIn' has a wrong offset!");
static_assert(offsetof(BouncingMat_ServerSpyBouncedLocalImpulse, Impulse) == 0x000008, "Member 'BouncingMat_ServerSpyBouncedLocalImpulse::Impulse' has a wrong offset!");
static_assert(offsetof(BouncingMat_ServerSpyBouncedLocalImpulse, VelocityIn) == 0x000014, "Member 'BouncingMat_ServerSpyBouncedLocalImpulse::VelocityIn' has a wrong offset!");

// Function DeceiveInc.BaseConditionComponent.IsConditionMet
// 0x0018 (0x0018 - 0x0000)
struct BaseConditionComponent_IsConditionMet final
{
public:
	const class UInteracterComponent*             InteracterComp;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 PlayerActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BaseConditionComponent_IsConditionMet) == 0x000008, "Wrong alignment on BaseConditionComponent_IsConditionMet");
static_assert(sizeof(BaseConditionComponent_IsConditionMet) == 0x000018, "Wrong size on BaseConditionComponent_IsConditionMet");
static_assert(offsetof(BaseConditionComponent_IsConditionMet, InteracterComp) == 0x000000, "Member 'BaseConditionComponent_IsConditionMet::InteracterComp' has a wrong offset!");
static_assert(offsetof(BaseConditionComponent_IsConditionMet, PlayerActor) == 0x000008, "Member 'BaseConditionComponent_IsConditionMet::PlayerActor' has a wrong offset!");
static_assert(offsetof(BaseConditionComponent_IsConditionMet, ReturnValue) == 0x000010, "Member 'BaseConditionComponent_IsConditionMet::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseConditionComponent.GetConditionType
// 0x0001 (0x0001 - 0x0000)
struct BaseConditionComponent_GetConditionType final
{
public:
	EConditionType                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseConditionComponent_GetConditionType) == 0x000001, "Wrong alignment on BaseConditionComponent_GetConditionType");
static_assert(sizeof(BaseConditionComponent_GetConditionType) == 0x000001, "Wrong size on BaseConditionComponent_GetConditionType");
static_assert(offsetof(BaseConditionComponent_GetConditionType, ReturnValue) == 0x000000, "Member 'BaseConditionComponent_GetConditionType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ValidateExtractionComponent.HandleInteractionComplete
// 0x0010 (0x0010 - 0x0000)
struct ValidateExtractionComponent_HandleInteractionComplete final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ValidateExtractionComponent_HandleInteractionComplete) == 0x000008, "Wrong alignment on ValidateExtractionComponent_HandleInteractionComplete");
static_assert(sizeof(ValidateExtractionComponent_HandleInteractionComplete) == 0x000010, "Wrong size on ValidateExtractionComponent_HandleInteractionComplete");
static_assert(offsetof(ValidateExtractionComponent_HandleInteractionComplete, Interacter) == 0x000000, "Member 'ValidateExtractionComponent_HandleInteractionComplete::Interacter' has a wrong offset!");
static_assert(offsetof(ValidateExtractionComponent_HandleInteractionComplete, Interactable) == 0x000008, "Member 'ValidateExtractionComponent_HandleInteractionComplete::Interactable' has a wrong offset!");

// Function DeceiveInc.AceTrailActiveAbility.BP_OnUpdateAceActiveTrail
// 0x0010 (0x0010 - 0x0000)
struct AceTrailActiveAbility_BP_OnUpdateAceActiveTrail final
{
public:
	TArray<struct FVector>                        TrailPoints;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AceTrailActiveAbility_BP_OnUpdateAceActiveTrail) == 0x000008, "Wrong alignment on AceTrailActiveAbility_BP_OnUpdateAceActiveTrail");
static_assert(sizeof(AceTrailActiveAbility_BP_OnUpdateAceActiveTrail) == 0x000010, "Wrong size on AceTrailActiveAbility_BP_OnUpdateAceActiveTrail");
static_assert(offsetof(AceTrailActiveAbility_BP_OnUpdateAceActiveTrail, TrailPoints) == 0x000000, "Member 'AceTrailActiveAbility_BP_OnUpdateAceActiveTrail::TrailPoints' has a wrong offset!");

// Function DeceiveInc.AchievementSubsystem.BP_UpdateAchievementProgress
// 0x0018 (0x0018 - 0x0000)
struct AchievementSubsystem_BP_UpdateAchievementProgress final
{
public:
	class FString                                 AchievementID;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Progress;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Increment;                                         // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AchievementSubsystem_BP_UpdateAchievementProgress) == 0x000008, "Wrong alignment on AchievementSubsystem_BP_UpdateAchievementProgress");
static_assert(sizeof(AchievementSubsystem_BP_UpdateAchievementProgress) == 0x000018, "Wrong size on AchievementSubsystem_BP_UpdateAchievementProgress");
static_assert(offsetof(AchievementSubsystem_BP_UpdateAchievementProgress, AchievementID) == 0x000000, "Member 'AchievementSubsystem_BP_UpdateAchievementProgress::AchievementID' has a wrong offset!");
static_assert(offsetof(AchievementSubsystem_BP_UpdateAchievementProgress, Progress) == 0x000010, "Member 'AchievementSubsystem_BP_UpdateAchievementProgress::Progress' has a wrong offset!");
static_assert(offsetof(AchievementSubsystem_BP_UpdateAchievementProgress, Increment) == 0x000014, "Member 'AchievementSubsystem_BP_UpdateAchievementProgress::Increment' has a wrong offset!");

// Function DeceiveInc.DISpectatorPawn.GetSpectatingPlayerState
// 0x0008 (0x0008 - 0x0000)
struct DISpectatorPawn_GetSpectatingPlayerState final
{
public:
	class ADIPlayerState*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISpectatorPawn_GetSpectatingPlayerState) == 0x000008, "Wrong alignment on DISpectatorPawn_GetSpectatingPlayerState");
static_assert(sizeof(DISpectatorPawn_GetSpectatingPlayerState) == 0x000008, "Wrong size on DISpectatorPawn_GetSpectatingPlayerState");
static_assert(offsetof(DISpectatorPawn_GetSpectatingPlayerState, ReturnValue) == 0x000000, "Member 'DISpectatorPawn_GetSpectatingPlayerState::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISpectatorPawn.HandleBooleanPlayerSettingChange
// 0x0002 (0x0002 - 0x0000)
struct DISpectatorPawn_HandleBooleanPlayerSettingChange final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewValue;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISpectatorPawn_HandleBooleanPlayerSettingChange) == 0x000001, "Wrong alignment on DISpectatorPawn_HandleBooleanPlayerSettingChange");
static_assert(sizeof(DISpectatorPawn_HandleBooleanPlayerSettingChange) == 0x000002, "Wrong size on DISpectatorPawn_HandleBooleanPlayerSettingChange");
static_assert(offsetof(DISpectatorPawn_HandleBooleanPlayerSettingChange, SettingType) == 0x000000, "Member 'DISpectatorPawn_HandleBooleanPlayerSettingChange::SettingType' has a wrong offset!");
static_assert(offsetof(DISpectatorPawn_HandleBooleanPlayerSettingChange, NewValue) == 0x000001, "Member 'DISpectatorPawn_HandleBooleanPlayerSettingChange::NewValue' has a wrong offset!");

// Function DeceiveInc.DISpectatorPawn.HandleFloatPlayerSettingChange
// 0x0008 (0x0008 - 0x0000)
struct DISpectatorPawn_HandleFloatPlayerSettingChange final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NewValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISpectatorPawn_HandleFloatPlayerSettingChange) == 0x000004, "Wrong alignment on DISpectatorPawn_HandleFloatPlayerSettingChange");
static_assert(sizeof(DISpectatorPawn_HandleFloatPlayerSettingChange) == 0x000008, "Wrong size on DISpectatorPawn_HandleFloatPlayerSettingChange");
static_assert(offsetof(DISpectatorPawn_HandleFloatPlayerSettingChange, SettingType) == 0x000000, "Member 'DISpectatorPawn_HandleFloatPlayerSettingChange::SettingType' has a wrong offset!");
static_assert(offsetof(DISpectatorPawn_HandleFloatPlayerSettingChange, NewValue) == 0x000004, "Member 'DISpectatorPawn_HandleFloatPlayerSettingChange::NewValue' has a wrong offset!");

// Function DeceiveInc.DISpectatorPawn.HandlePhaseChanged
// 0x0001 (0x0001 - 0x0000)
struct DISpectatorPawn_HandlePhaseChanged final
{
public:
	ESpyGamePhase                                 NewGamePhase;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISpectatorPawn_HandlePhaseChanged) == 0x000001, "Wrong alignment on DISpectatorPawn_HandlePhaseChanged");
static_assert(sizeof(DISpectatorPawn_HandlePhaseChanged) == 0x000001, "Wrong size on DISpectatorPawn_HandlePhaseChanged");
static_assert(offsetof(DISpectatorPawn_HandlePhaseChanged, NewGamePhase) == 0x000000, "Member 'DISpectatorPawn_HandlePhaseChanged::NewGamePhase' has a wrong offset!");

// Function DeceiveInc.DISpectatorPawn.LookHorizontal
// 0x0004 (0x0004 - 0x0000)
struct DISpectatorPawn_LookHorizontal final
{
public:
	float                                         AxisValue;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISpectatorPawn_LookHorizontal) == 0x000004, "Wrong alignment on DISpectatorPawn_LookHorizontal");
static_assert(sizeof(DISpectatorPawn_LookHorizontal) == 0x000004, "Wrong size on DISpectatorPawn_LookHorizontal");
static_assert(offsetof(DISpectatorPawn_LookHorizontal, AxisValue) == 0x000000, "Member 'DISpectatorPawn_LookHorizontal::AxisValue' has a wrong offset!");

// Function DeceiveInc.DISpectatorPawn.LookHorizontalRate
// 0x0004 (0x0004 - 0x0000)
struct DISpectatorPawn_LookHorizontalRate final
{
public:
	float                                         AxisValue;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISpectatorPawn_LookHorizontalRate) == 0x000004, "Wrong alignment on DISpectatorPawn_LookHorizontalRate");
static_assert(sizeof(DISpectatorPawn_LookHorizontalRate) == 0x000004, "Wrong size on DISpectatorPawn_LookHorizontalRate");
static_assert(offsetof(DISpectatorPawn_LookHorizontalRate, AxisValue) == 0x000000, "Member 'DISpectatorPawn_LookHorizontalRate::AxisValue' has a wrong offset!");

// Function DeceiveInc.DISpectatorPawn.LookVertical
// 0x0004 (0x0004 - 0x0000)
struct DISpectatorPawn_LookVertical final
{
public:
	float                                         AxisValue;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISpectatorPawn_LookVertical) == 0x000004, "Wrong alignment on DISpectatorPawn_LookVertical");
static_assert(sizeof(DISpectatorPawn_LookVertical) == 0x000004, "Wrong size on DISpectatorPawn_LookVertical");
static_assert(offsetof(DISpectatorPawn_LookVertical, AxisValue) == 0x000000, "Member 'DISpectatorPawn_LookVertical::AxisValue' has a wrong offset!");

// Function DeceiveInc.DISpectatorPawn.LookVerticalRate
// 0x0004 (0x0004 - 0x0000)
struct DISpectatorPawn_LookVerticalRate final
{
public:
	float                                         AxisValue;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISpectatorPawn_LookVerticalRate) == 0x000004, "Wrong alignment on DISpectatorPawn_LookVerticalRate");
static_assert(sizeof(DISpectatorPawn_LookVerticalRate) == 0x000004, "Wrong size on DISpectatorPawn_LookVerticalRate");
static_assert(offsetof(DISpectatorPawn_LookVerticalRate, AxisValue) == 0x000000, "Member 'DISpectatorPawn_LookVerticalRate::AxisValue' has a wrong offset!");

// Function DeceiveInc.DISpectatorPawn.OnAutoSpectatingChange
// 0x0010 (0x0010 - 0x0000)
struct DISpectatorPawn_OnAutoSpectatingChange final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoSpectatingIn;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DISpectatorPawn_OnAutoSpectatingChange) == 0x000008, "Wrong alignment on DISpectatorPawn_OnAutoSpectatingChange");
static_assert(sizeof(DISpectatorPawn_OnAutoSpectatingChange) == 0x000010, "Wrong size on DISpectatorPawn_OnAutoSpectatingChange");
static_assert(offsetof(DISpectatorPawn_OnAutoSpectatingChange, PlayerController) == 0x000000, "Member 'DISpectatorPawn_OnAutoSpectatingChange::PlayerController' has a wrong offset!");
static_assert(offsetof(DISpectatorPawn_OnAutoSpectatingChange, bAutoSpectatingIn) == 0x000008, "Member 'DISpectatorPawn_OnAutoSpectatingChange::bAutoSpectatingIn' has a wrong offset!");

// Function DeceiveInc.DISpectatorPawn.ShowUserInterface
// 0x0001 (0x0001 - 0x0000)
struct DISpectatorPawn_ShowUserInterface final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISpectatorPawn_ShowUserInterface) == 0x000001, "Wrong alignment on DISpectatorPawn_ShowUserInterface");
static_assert(sizeof(DISpectatorPawn_ShowUserInterface) == 0x000001, "Wrong size on DISpectatorPawn_ShowUserInterface");
static_assert(offsetof(DISpectatorPawn_ShowUserInterface, bShow) == 0x000000, "Member 'DISpectatorPawn_ShowUserInterface::bShow' has a wrong offset!");

// Function DeceiveInc.DISpectatorPawn.GetIsDedicatedSpectator
// 0x0001 (0x0001 - 0x0000)
struct DISpectatorPawn_GetIsDedicatedSpectator final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISpectatorPawn_GetIsDedicatedSpectator) == 0x000001, "Wrong alignment on DISpectatorPawn_GetIsDedicatedSpectator");
static_assert(sizeof(DISpectatorPawn_GetIsDedicatedSpectator) == 0x000001, "Wrong size on DISpectatorPawn_GetIsDedicatedSpectator");
static_assert(offsetof(DISpectatorPawn_GetIsDedicatedSpectator, ReturnValue) == 0x000000, "Member 'DISpectatorPawn_GetIsDedicatedSpectator::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISpectatorPawn.GetRevivePingCooldownRatio
// 0x0004 (0x0004 - 0x0000)
struct DISpectatorPawn_GetRevivePingCooldownRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISpectatorPawn_GetRevivePingCooldownRatio) == 0x000004, "Wrong alignment on DISpectatorPawn_GetRevivePingCooldownRatio");
static_assert(sizeof(DISpectatorPawn_GetRevivePingCooldownRatio) == 0x000004, "Wrong size on DISpectatorPawn_GetRevivePingCooldownRatio");
static_assert(offsetof(DISpectatorPawn_GetRevivePingCooldownRatio, ReturnValue) == 0x000000, "Member 'DISpectatorPawn_GetRevivePingCooldownRatio::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISpectatorPawn.GetSpectatingActor
// 0x0008 (0x0008 - 0x0000)
struct DISpectatorPawn_GetSpectatingActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISpectatorPawn_GetSpectatingActor) == 0x000008, "Wrong alignment on DISpectatorPawn_GetSpectatingActor");
static_assert(sizeof(DISpectatorPawn_GetSpectatingActor) == 0x000008, "Wrong size on DISpectatorPawn_GetSpectatingActor");
static_assert(offsetof(DISpectatorPawn_GetSpectatingActor, ReturnValue) == 0x000000, "Member 'DISpectatorPawn_GetSpectatingActor::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ChavezActiveAbility.HandleTakePointDamage
// 0x0058 (0x0058 - 0x0000)
struct ChavezActiveAbility_HandleTakePointDamage final
{
public:
	class AActor*                                 DamagedActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            InstigatedBy;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    FHitComponent;                                     // 0x0028(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ShotFromDirection;                                 // 0x0038(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UDamageType*                      DamageType;                                        // 0x0048(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0050(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChavezActiveAbility_HandleTakePointDamage) == 0x000008, "Wrong alignment on ChavezActiveAbility_HandleTakePointDamage");
static_assert(sizeof(ChavezActiveAbility_HandleTakePointDamage) == 0x000058, "Wrong size on ChavezActiveAbility_HandleTakePointDamage");
static_assert(offsetof(ChavezActiveAbility_HandleTakePointDamage, DamagedActor) == 0x000000, "Member 'ChavezActiveAbility_HandleTakePointDamage::DamagedActor' has a wrong offset!");
static_assert(offsetof(ChavezActiveAbility_HandleTakePointDamage, Damage) == 0x000008, "Member 'ChavezActiveAbility_HandleTakePointDamage::Damage' has a wrong offset!");
static_assert(offsetof(ChavezActiveAbility_HandleTakePointDamage, InstigatedBy) == 0x000010, "Member 'ChavezActiveAbility_HandleTakePointDamage::InstigatedBy' has a wrong offset!");
static_assert(offsetof(ChavezActiveAbility_HandleTakePointDamage, HitLocation) == 0x000018, "Member 'ChavezActiveAbility_HandleTakePointDamage::HitLocation' has a wrong offset!");
static_assert(offsetof(ChavezActiveAbility_HandleTakePointDamage, FHitComponent) == 0x000028, "Member 'ChavezActiveAbility_HandleTakePointDamage::FHitComponent' has a wrong offset!");
static_assert(offsetof(ChavezActiveAbility_HandleTakePointDamage, BoneName) == 0x000030, "Member 'ChavezActiveAbility_HandleTakePointDamage::BoneName' has a wrong offset!");
static_assert(offsetof(ChavezActiveAbility_HandleTakePointDamage, ShotFromDirection) == 0x000038, "Member 'ChavezActiveAbility_HandleTakePointDamage::ShotFromDirection' has a wrong offset!");
static_assert(offsetof(ChavezActiveAbility_HandleTakePointDamage, DamageType) == 0x000048, "Member 'ChavezActiveAbility_HandleTakePointDamage::DamageType' has a wrong offset!");
static_assert(offsetof(ChavezActiveAbility_HandleTakePointDamage, DamageCauser) == 0x000050, "Member 'ChavezActiveAbility_HandleTakePointDamage::DamageCauser' has a wrong offset!");

// Function DeceiveInc.ChavezActiveAbility.MulticastShieldHit
// 0x000C (0x000C - 0x0000)
struct ChavezActiveAbility_MulticastShieldHit final
{
public:
	struct FVector_NetQuantize                    HitPos;                                            // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChavezActiveAbility_MulticastShieldHit) == 0x000004, "Wrong alignment on ChavezActiveAbility_MulticastShieldHit");
static_assert(sizeof(ChavezActiveAbility_MulticastShieldHit) == 0x00000C, "Wrong size on ChavezActiveAbility_MulticastShieldHit");
static_assert(offsetof(ChavezActiveAbility_MulticastShieldHit, HitPos) == 0x000000, "Member 'ChavezActiveAbility_MulticastShieldHit::HitPos' has a wrong offset!");

// Function DeceiveInc.ChavezActiveAbilityMod1.HandleTakeAnyDamage
// 0x0028 (0x0028 - 0x0000)
struct ChavezActiveAbilityMod1_HandleTakeAnyDamage final
{
public:
	class AActor*                                 DamagedActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UDamageType*                      DamageType;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChavezActiveAbilityMod1_HandleTakeAnyDamage) == 0x000008, "Wrong alignment on ChavezActiveAbilityMod1_HandleTakeAnyDamage");
static_assert(sizeof(ChavezActiveAbilityMod1_HandleTakeAnyDamage) == 0x000028, "Wrong size on ChavezActiveAbilityMod1_HandleTakeAnyDamage");
static_assert(offsetof(ChavezActiveAbilityMod1_HandleTakeAnyDamage, DamagedActor) == 0x000000, "Member 'ChavezActiveAbilityMod1_HandleTakeAnyDamage::DamagedActor' has a wrong offset!");
static_assert(offsetof(ChavezActiveAbilityMod1_HandleTakeAnyDamage, Damage) == 0x000008, "Member 'ChavezActiveAbilityMod1_HandleTakeAnyDamage::Damage' has a wrong offset!");
static_assert(offsetof(ChavezActiveAbilityMod1_HandleTakeAnyDamage, DamageType) == 0x000010, "Member 'ChavezActiveAbilityMod1_HandleTakeAnyDamage::DamageType' has a wrong offset!");
static_assert(offsetof(ChavezActiveAbilityMod1_HandleTakeAnyDamage, InstigatedBy) == 0x000018, "Member 'ChavezActiveAbilityMod1_HandleTakeAnyDamage::InstigatedBy' has a wrong offset!");
static_assert(offsetof(ChavezActiveAbilityMod1_HandleTakeAnyDamage, DamageCauser) == 0x000020, "Member 'ChavezActiveAbilityMod1_HandleTakeAnyDamage::DamageCauser' has a wrong offset!");

// Function DeceiveInc.ChavezActiveAbilityMod1.HandleWeaponReloaded
// 0x0010 (0x0010 - 0x0000)
struct ChavezActiveAbilityMod1_HandleWeaponReloaded final
{
public:
	ESpyToolEvent                                 EventType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSpyTool*                           SpyTool;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChavezActiveAbilityMod1_HandleWeaponReloaded) == 0x000008, "Wrong alignment on ChavezActiveAbilityMod1_HandleWeaponReloaded");
static_assert(sizeof(ChavezActiveAbilityMod1_HandleWeaponReloaded) == 0x000010, "Wrong size on ChavezActiveAbilityMod1_HandleWeaponReloaded");
static_assert(offsetof(ChavezActiveAbilityMod1_HandleWeaponReloaded, EventType) == 0x000000, "Member 'ChavezActiveAbilityMod1_HandleWeaponReloaded::EventType' has a wrong offset!");
static_assert(offsetof(ChavezActiveAbilityMod1_HandleWeaponReloaded, SpyTool) == 0x000008, "Member 'ChavezActiveAbilityMod1_HandleWeaponReloaded::SpyTool' has a wrong offset!");

// Function DeceiveInc.SweetDataminingSubsystem.IsRecording
// 0x0001 (0x0001 - 0x0000)
struct SweetDataminingSubsystem_IsRecording final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetDataminingSubsystem_IsRecording) == 0x000001, "Wrong alignment on SweetDataminingSubsystem_IsRecording");
static_assert(sizeof(SweetDataminingSubsystem_IsRecording) == 0x000001, "Wrong size on SweetDataminingSubsystem_IsRecording");
static_assert(offsetof(SweetDataminingSubsystem_IsRecording, ReturnValue) == 0x000000, "Member 'SweetDataminingSubsystem_IsRecording::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ActorAffectedComponent.GetAffectedType
// 0x0001 (0x0001 - 0x0000)
struct ActorAffectedComponent_GetAffectedType final
{
public:
	EActorAffectedType                            ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorAffectedComponent_GetAffectedType) == 0x000001, "Wrong alignment on ActorAffectedComponent_GetAffectedType");
static_assert(sizeof(ActorAffectedComponent_GetAffectedType) == 0x000001, "Wrong size on ActorAffectedComponent_GetAffectedType");
static_assert(offsetof(ActorAffectedComponent_GetAffectedType, ReturnValue) == 0x000000, "Member 'ActorAffectedComponent_GetAffectedType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ActorAffectedComponent.OnRep_Sources
// 0x0010 (0x0010 - 0x0000)
struct ActorAffectedComponent_OnRep_Sources final
{
public:
	TArray<class AActor*>                         OldSources;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorAffectedComponent_OnRep_Sources) == 0x000008, "Wrong alignment on ActorAffectedComponent_OnRep_Sources");
static_assert(sizeof(ActorAffectedComponent_OnRep_Sources) == 0x000010, "Wrong size on ActorAffectedComponent_OnRep_Sources");
static_assert(offsetof(ActorAffectedComponent_OnRep_Sources, OldSources) == 0x000000, "Member 'ActorAffectedComponent_OnRep_Sources::OldSources' has a wrong offset!");

// Function DeceiveInc.ActorAffectedComponent.RegisterAffectingSource
// 0x0008 (0x0008 - 0x0000)
struct ActorAffectedComponent_RegisterAffectingSource final
{
public:
	class AActor*                                 AffectingSource;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorAffectedComponent_RegisterAffectingSource) == 0x000008, "Wrong alignment on ActorAffectedComponent_RegisterAffectingSource");
static_assert(sizeof(ActorAffectedComponent_RegisterAffectingSource) == 0x000008, "Wrong size on ActorAffectedComponent_RegisterAffectingSource");
static_assert(offsetof(ActorAffectedComponent_RegisterAffectingSource, AffectingSource) == 0x000000, "Member 'ActorAffectedComponent_RegisterAffectingSource::AffectingSource' has a wrong offset!");

// Function DeceiveInc.ActorAffectedComponent.UnregisterAffectingSource
// 0x0008 (0x0008 - 0x0000)
struct ActorAffectedComponent_UnregisterAffectingSource final
{
public:
	class AActor*                                 AffectingSource;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorAffectedComponent_UnregisterAffectingSource) == 0x000008, "Wrong alignment on ActorAffectedComponent_UnregisterAffectingSource");
static_assert(sizeof(ActorAffectedComponent_UnregisterAffectingSource) == 0x000008, "Wrong size on ActorAffectedComponent_UnregisterAffectingSource");
static_assert(offsetof(ActorAffectedComponent_UnregisterAffectingSource, AffectingSource) == 0x000000, "Member 'ActorAffectedComponent_UnregisterAffectingSource::AffectingSource' has a wrong offset!");

// Function DeceiveInc.ActorAffectedComponent.IsAffected
// 0x0001 (0x0001 - 0x0000)
struct ActorAffectedComponent_IsAffected final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorAffectedComponent_IsAffected) == 0x000001, "Wrong alignment on ActorAffectedComponent_IsAffected");
static_assert(sizeof(ActorAffectedComponent_IsAffected) == 0x000001, "Wrong size on ActorAffectedComponent_IsAffected");
static_assert(offsetof(ActorAffectedComponent_IsAffected, ReturnValue) == 0x000000, "Member 'ActorAffectedComponent_IsAffected::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ActorAffectedComponent.IsAffectedForFaction
// 0x0010 (0x0010 - 0x0000)
struct ActorAffectedComponent_IsAffectedForFaction final
{
public:
	class AActor*                                 ToCompare;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ActorAffectedComponent_IsAffectedForFaction) == 0x000008, "Wrong alignment on ActorAffectedComponent_IsAffectedForFaction");
static_assert(sizeof(ActorAffectedComponent_IsAffectedForFaction) == 0x000010, "Wrong size on ActorAffectedComponent_IsAffectedForFaction");
static_assert(offsetof(ActorAffectedComponent_IsAffectedForFaction, ToCompare) == 0x000000, "Member 'ActorAffectedComponent_IsAffectedForFaction::ToCompare' has a wrong offset!");
static_assert(offsetof(ActorAffectedComponent_IsAffectedForFaction, ReturnValue) == 0x000008, "Member 'ActorAffectedComponent_IsAffectedForFaction::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ActorAffectedComponent.IsDisabledByEffect
// 0x0001 (0x0001 - 0x0000)
struct ActorAffectedComponent_IsDisabledByEffect final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorAffectedComponent_IsDisabledByEffect) == 0x000001, "Wrong alignment on ActorAffectedComponent_IsDisabledByEffect");
static_assert(sizeof(ActorAffectedComponent_IsDisabledByEffect) == 0x000001, "Wrong size on ActorAffectedComponent_IsDisabledByEffect");
static_assert(offsetof(ActorAffectedComponent_IsDisabledByEffect, ReturnValue) == 0x000000, "Member 'ActorAffectedComponent_IsDisabledByEffect::ReturnValue' has a wrong offset!");

// Function DeceiveInc.HansPassiveAbilityMod2.HandleVictimEffectApplied
// 0x0010 (0x0010 - 0x0000)
struct HansPassiveAbilityMod2_HandleVictimEffectApplied final
{
public:
	class ASpy*                                   Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVictimEffect*                          Effect;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HansPassiveAbilityMod2_HandleVictimEffectApplied) == 0x000008, "Wrong alignment on HansPassiveAbilityMod2_HandleVictimEffectApplied");
static_assert(sizeof(HansPassiveAbilityMod2_HandleVictimEffectApplied) == 0x000010, "Wrong size on HansPassiveAbilityMod2_HandleVictimEffectApplied");
static_assert(offsetof(HansPassiveAbilityMod2_HandleVictimEffectApplied, Victim) == 0x000000, "Member 'HansPassiveAbilityMod2_HandleVictimEffectApplied::Victim' has a wrong offset!");
static_assert(offsetof(HansPassiveAbilityMod2_HandleVictimEffectApplied, Effect) == 0x000008, "Member 'HansPassiveAbilityMod2_HandleVictimEffectApplied::Effect' has a wrong offset!");

// Function DeceiveInc.DiPawnInterface.DisableDIPawnInput
// 0x0008 (0x0008 - 0x0000)
struct DiPawnInterface_DisableDIPawnInput final
{
public:
	class AActor*                                 Requester;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPawnInterface_DisableDIPawnInput) == 0x000008, "Wrong alignment on DiPawnInterface_DisableDIPawnInput");
static_assert(sizeof(DiPawnInterface_DisableDIPawnInput) == 0x000008, "Wrong size on DiPawnInterface_DisableDIPawnInput");
static_assert(offsetof(DiPawnInterface_DisableDIPawnInput, Requester) == 0x000000, "Member 'DiPawnInterface_DisableDIPawnInput::Requester' has a wrong offset!");

// Function DeceiveInc.DiPawnInterface.EnableDIPawnInput
// 0x0008 (0x0008 - 0x0000)
struct DiPawnInterface_EnableDIPawnInput final
{
public:
	class AActor*                                 Requester;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPawnInterface_EnableDIPawnInput) == 0x000008, "Wrong alignment on DiPawnInterface_EnableDIPawnInput");
static_assert(sizeof(DiPawnInterface_EnableDIPawnInput) == 0x000008, "Wrong size on DiPawnInterface_EnableDIPawnInput");
static_assert(offsetof(DiPawnInterface_EnableDIPawnInput, Requester) == 0x000000, "Member 'DiPawnInterface_EnableDIPawnInput::Requester' has a wrong offset!");

// Function DeceiveInc.BaseGamePhaseInfo.GetPhaseTimerTxt
// 0x0018 (0x0018 - 0x0000)
struct BaseGamePhaseInfo_GetPhaseTimerTxt final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseGamePhaseInfo_GetPhaseTimerTxt) == 0x000008, "Wrong alignment on BaseGamePhaseInfo_GetPhaseTimerTxt");
static_assert(sizeof(BaseGamePhaseInfo_GetPhaseTimerTxt) == 0x000018, "Wrong size on BaseGamePhaseInfo_GetPhaseTimerTxt");
static_assert(offsetof(BaseGamePhaseInfo_GetPhaseTimerTxt, ReturnValue) == 0x000000, "Member 'BaseGamePhaseInfo_GetPhaseTimerTxt::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SpyGamePhaseInfo.GetCriticalTimeAnnoucementDuration
// 0x0004 (0x0004 - 0x0000)
struct SpyGamePhaseInfo_GetCriticalTimeAnnoucementDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyGamePhaseInfo_GetCriticalTimeAnnoucementDuration) == 0x000004, "Wrong alignment on SpyGamePhaseInfo_GetCriticalTimeAnnoucementDuration");
static_assert(sizeof(SpyGamePhaseInfo_GetCriticalTimeAnnoucementDuration) == 0x000004, "Wrong size on SpyGamePhaseInfo_GetCriticalTimeAnnoucementDuration");
static_assert(offsetof(SpyGamePhaseInfo_GetCriticalTimeAnnoucementDuration, ReturnValue) == 0x000000, "Member 'SpyGamePhaseInfo_GetCriticalTimeAnnoucementDuration::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SpyGamePhaseInfo.GetCriticalTimeAnnoucementPriority
// 0x0004 (0x0004 - 0x0000)
struct SpyGamePhaseInfo_GetCriticalTimeAnnoucementPriority final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyGamePhaseInfo_GetCriticalTimeAnnoucementPriority) == 0x000004, "Wrong alignment on SpyGamePhaseInfo_GetCriticalTimeAnnoucementPriority");
static_assert(sizeof(SpyGamePhaseInfo_GetCriticalTimeAnnoucementPriority) == 0x000004, "Wrong size on SpyGamePhaseInfo_GetCriticalTimeAnnoucementPriority");
static_assert(offsetof(SpyGamePhaseInfo_GetCriticalTimeAnnoucementPriority, ReturnValue) == 0x000000, "Member 'SpyGamePhaseInfo_GetCriticalTimeAnnoucementPriority::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SpyGamePhaseInfo.GetCriticalTimeAnnoucementText
// 0x0018 (0x0018 - 0x0000)
struct SpyGamePhaseInfo_GetCriticalTimeAnnoucementText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyGamePhaseInfo_GetCriticalTimeAnnoucementText) == 0x000008, "Wrong alignment on SpyGamePhaseInfo_GetCriticalTimeAnnoucementText");
static_assert(sizeof(SpyGamePhaseInfo_GetCriticalTimeAnnoucementText) == 0x000018, "Wrong size on SpyGamePhaseInfo_GetCriticalTimeAnnoucementText");
static_assert(offsetof(SpyGamePhaseInfo_GetCriticalTimeAnnoucementText, ReturnValue) == 0x000000, "Member 'SpyGamePhaseInfo_GetCriticalTimeAnnoucementText::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SpyGamePhaseInfo.GetCriticalTimeAnnoucementType
// 0x0001 (0x0001 - 0x0000)
struct SpyGamePhaseInfo_GetCriticalTimeAnnoucementType final
{
public:
	EAnnouncementType                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyGamePhaseInfo_GetCriticalTimeAnnoucementType) == 0x000001, "Wrong alignment on SpyGamePhaseInfo_GetCriticalTimeAnnoucementType");
static_assert(sizeof(SpyGamePhaseInfo_GetCriticalTimeAnnoucementType) == 0x000001, "Wrong size on SpyGamePhaseInfo_GetCriticalTimeAnnoucementType");
static_assert(offsetof(SpyGamePhaseInfo_GetCriticalTimeAnnoucementType, ReturnValue) == 0x000000, "Member 'SpyGamePhaseInfo_GetCriticalTimeAnnoucementType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SpyGamePhaseInfo.GetCriticalTimeLeft
// 0x0004 (0x0004 - 0x0000)
struct SpyGamePhaseInfo_GetCriticalTimeLeft final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyGamePhaseInfo_GetCriticalTimeLeft) == 0x000004, "Wrong alignment on SpyGamePhaseInfo_GetCriticalTimeLeft");
static_assert(sizeof(SpyGamePhaseInfo_GetCriticalTimeLeft) == 0x000004, "Wrong size on SpyGamePhaseInfo_GetCriticalTimeLeft");
static_assert(offsetof(SpyGamePhaseInfo_GetCriticalTimeLeft, ReturnValue) == 0x000000, "Member 'SpyGamePhaseInfo_GetCriticalTimeLeft::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SpyGamePhaseInfo.GetGamePhase
// 0x0001 (0x0001 - 0x0000)
struct SpyGamePhaseInfo_GetGamePhase final
{
public:
	ESpyGamePhase                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyGamePhaseInfo_GetGamePhase) == 0x000001, "Wrong alignment on SpyGamePhaseInfo_GetGamePhase");
static_assert(sizeof(SpyGamePhaseInfo_GetGamePhase) == 0x000001, "Wrong size on SpyGamePhaseInfo_GetGamePhase");
static_assert(offsetof(SpyGamePhaseInfo_GetGamePhase, ReturnValue) == 0x000000, "Member 'SpyGamePhaseInfo_GetGamePhase::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SpyGamePhaseInfo.HasCriticalTime
// 0x0001 (0x0001 - 0x0000)
struct SpyGamePhaseInfo_HasCriticalTime final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyGamePhaseInfo_HasCriticalTime) == 0x000001, "Wrong alignment on SpyGamePhaseInfo_HasCriticalTime");
static_assert(sizeof(SpyGamePhaseInfo_HasCriticalTime) == 0x000001, "Wrong size on SpyGamePhaseInfo_HasCriticalTime");
static_assert(offsetof(SpyGamePhaseInfo_HasCriticalTime, ReturnValue) == 0x000000, "Member 'SpyGamePhaseInfo_HasCriticalTime::ReturnValue' has a wrong offset!");

// Function DeceiveInc.AgentData.ShouldShowAgent
// 0x0001 (0x0001 - 0x0000)
struct AgentData_ShouldShowAgent final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AgentData_ShouldShowAgent) == 0x000001, "Wrong alignment on AgentData_ShouldShowAgent");
static_assert(sizeof(AgentData_ShouldShowAgent) == 0x000001, "Wrong size on AgentData_ShouldShowAgent");
static_assert(offsetof(AgentData_ShouldShowAgent, ReturnValue) == 0x000000, "Member 'AgentData_ShouldShowAgent::ReturnValue' has a wrong offset!");

// Function DeceiveInc.AgentSkinData.GetAgentName
// 0x0018 (0x0018 - 0x0000)
struct AgentSkinData_GetAgentName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AgentSkinData_GetAgentName) == 0x000008, "Wrong alignment on AgentSkinData_GetAgentName");
static_assert(sizeof(AgentSkinData_GetAgentName) == 0x000018, "Wrong size on AgentSkinData_GetAgentName");
static_assert(offsetof(AgentSkinData_GetAgentName, ReturnValue) == 0x000000, "Member 'AgentSkinData_GetAgentName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.AgentSkinData.GetAgentTagline
// 0x0018 (0x0018 - 0x0000)
struct AgentSkinData_GetAgentTagline final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AgentSkinData_GetAgentTagline) == 0x000008, "Wrong alignment on AgentSkinData_GetAgentTagline");
static_assert(sizeof(AgentSkinData_GetAgentTagline) == 0x000018, "Wrong size on AgentSkinData_GetAgentTagline");
static_assert(offsetof(AgentSkinData_GetAgentTagline, ReturnValue) == 0x000000, "Member 'AgentSkinData_GetAgentTagline::ReturnValue' has a wrong offset!");

// Function DeceiveInc.AgentSkinData.GetDefaultIntroPoseForSkin
// 0x0008 (0x0008 - 0x0000)
struct AgentSkinData_GetDefaultIntroPoseForSkin final
{
public:
	class UAgentIntroPoseDataAsset*               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AgentSkinData_GetDefaultIntroPoseForSkin) == 0x000008, "Wrong alignment on AgentSkinData_GetDefaultIntroPoseForSkin");
static_assert(sizeof(AgentSkinData_GetDefaultIntroPoseForSkin) == 0x000008, "Wrong size on AgentSkinData_GetDefaultIntroPoseForSkin");
static_assert(offsetof(AgentSkinData_GetDefaultIntroPoseForSkin, ReturnValue) == 0x000000, "Member 'AgentSkinData_GetDefaultIntroPoseForSkin::ReturnValue' has a wrong offset!");

// Function DeceiveInc.HansPassiveAbility.BP_OnHansPassiveTrigger
// 0x0018 (0x0018 - 0x0000)
struct HansPassiveAbility_BP_OnHansPassiveTrigger final
{
public:
	class ASpy*                                   TriggeredSpy;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ASpy*>                           TriggeredSpies;                                    // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HansPassiveAbility_BP_OnHansPassiveTrigger) == 0x000008, "Wrong alignment on HansPassiveAbility_BP_OnHansPassiveTrigger");
static_assert(sizeof(HansPassiveAbility_BP_OnHansPassiveTrigger) == 0x000018, "Wrong size on HansPassiveAbility_BP_OnHansPassiveTrigger");
static_assert(offsetof(HansPassiveAbility_BP_OnHansPassiveTrigger, TriggeredSpy) == 0x000000, "Member 'HansPassiveAbility_BP_OnHansPassiveTrigger::TriggeredSpy' has a wrong offset!");
static_assert(offsetof(HansPassiveAbility_BP_OnHansPassiveTrigger, TriggeredSpies) == 0x000008, "Member 'HansPassiveAbility_BP_OnHansPassiveTrigger::TriggeredSpies' has a wrong offset!");

// Function DeceiveInc.HansPassiveAbility.MulticastNotifyTriggerHansPassive
// 0x0018 (0x0018 - 0x0000)
struct HansPassiveAbility_MulticastNotifyTriggerHansPassive final
{
public:
	class ASpy*                                   AffectedSpy;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ASpy*>                           TriggeredSpies;                                    // 0x0008(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HansPassiveAbility_MulticastNotifyTriggerHansPassive) == 0x000008, "Wrong alignment on HansPassiveAbility_MulticastNotifyTriggerHansPassive");
static_assert(sizeof(HansPassiveAbility_MulticastNotifyTriggerHansPassive) == 0x000018, "Wrong size on HansPassiveAbility_MulticastNotifyTriggerHansPassive");
static_assert(offsetof(HansPassiveAbility_MulticastNotifyTriggerHansPassive, AffectedSpy) == 0x000000, "Member 'HansPassiveAbility_MulticastNotifyTriggerHansPassive::AffectedSpy' has a wrong offset!");
static_assert(offsetof(HansPassiveAbility_MulticastNotifyTriggerHansPassive, TriggeredSpies) == 0x000008, "Member 'HansPassiveAbility_MulticastNotifyTriggerHansPassive::TriggeredSpies' has a wrong offset!");

// Function DeceiveInc.HansPassiveAbility.OnUndercoverChange
// 0x0001 (0x0001 - 0x0000)
struct HansPassiveAbility_OnUndercoverChange final
{
public:
	bool                                          Undercover;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HansPassiveAbility_OnUndercoverChange) == 0x000001, "Wrong alignment on HansPassiveAbility_OnUndercoverChange");
static_assert(sizeof(HansPassiveAbility_OnUndercoverChange) == 0x000001, "Wrong size on HansPassiveAbility_OnUndercoverChange");
static_assert(offsetof(HansPassiveAbility_OnUndercoverChange, Undercover) == 0x000000, "Member 'HansPassiveAbility_OnUndercoverChange::Undercover' has a wrong offset!");

// Function DeceiveInc.HansPassiveAbilityMod1.HandleCoverBlownEvent
// 0x0008 (0x0008 - 0x0000)
struct HansPassiveAbilityMod1_HandleCoverBlownEvent final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HansPassiveAbilityMod1_HandleCoverBlownEvent) == 0x000008, "Wrong alignment on HansPassiveAbilityMod1_HandleCoverBlownEvent");
static_assert(sizeof(HansPassiveAbilityMod1_HandleCoverBlownEvent) == 0x000008, "Wrong size on HansPassiveAbilityMod1_HandleCoverBlownEvent");
static_assert(offsetof(HansPassiveAbilityMod1_HandleCoverBlownEvent, Spy) == 0x000000, "Member 'HansPassiveAbilityMod1_HandleCoverBlownEvent::Spy' has a wrong offset!");

// Function DeceiveInc.AgonesDedicatedServerManager.AgonesErrorHandler
// 0x0010 (0x0010 - 0x0000)
struct AgonesDedicatedServerManager_AgonesErrorHandler final
{
public:
	struct FAgonesError                           Error;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AgonesDedicatedServerManager_AgonesErrorHandler) == 0x000008, "Wrong alignment on AgonesDedicatedServerManager_AgonesErrorHandler");
static_assert(sizeof(AgonesDedicatedServerManager_AgonesErrorHandler) == 0x000010, "Wrong size on AgonesDedicatedServerManager_AgonesErrorHandler");
static_assert(offsetof(AgonesDedicatedServerManager_AgonesErrorHandler, Error) == 0x000000, "Member 'AgonesDedicatedServerManager_AgonesErrorHandler::Error' has a wrong offset!");

// Function DeceiveInc.AgonesDedicatedServerManager.ReadySuccessHandler
// 0x0001 (0x0001 - 0x0000)
struct AgonesDedicatedServerManager_ReadySuccessHandler final
{
public:
	struct FEmptyResponse                         Response;                                          // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AgonesDedicatedServerManager_ReadySuccessHandler) == 0x000001, "Wrong alignment on AgonesDedicatedServerManager_ReadySuccessHandler");
static_assert(sizeof(AgonesDedicatedServerManager_ReadySuccessHandler) == 0x000001, "Wrong size on AgonesDedicatedServerManager_ReadySuccessHandler");
static_assert(offsetof(AgonesDedicatedServerManager_ReadySuccessHandler, Response) == 0x000000, "Member 'AgonesDedicatedServerManager_ReadySuccessHandler::Response' has a wrong offset!");

// Function DeceiveInc.AgonesDedicatedServerManager.ShutdownSuccessHandler
// 0x0001 (0x0001 - 0x0000)
struct AgonesDedicatedServerManager_ShutdownSuccessHandler final
{
public:
	struct FEmptyResponse                         Response;                                          // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AgonesDedicatedServerManager_ShutdownSuccessHandler) == 0x000001, "Wrong alignment on AgonesDedicatedServerManager_ShutdownSuccessHandler");
static_assert(sizeof(AgonesDedicatedServerManager_ShutdownSuccessHandler) == 0x000001, "Wrong size on AgonesDedicatedServerManager_ShutdownSuccessHandler");
static_assert(offsetof(AgonesDedicatedServerManager_ShutdownSuccessHandler, Response) == 0x000000, "Member 'AgonesDedicatedServerManager_ShutdownSuccessHandler::Response' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.AddTimeToPhase
// 0x0004 (0x0004 - 0x0000)
struct DeceiveIncGameStateBase_AddTimeToPhase final
{
public:
	int32                                         SecondsToAdd;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_AddTimeToPhase) == 0x000004, "Wrong alignment on DeceiveIncGameStateBase_AddTimeToPhase");
static_assert(sizeof(DeceiveIncGameStateBase_AddTimeToPhase) == 0x000004, "Wrong size on DeceiveIncGameStateBase_AddTimeToPhase");
static_assert(offsetof(DeceiveIncGameStateBase_AddTimeToPhase, SecondsToAdd) == 0x000000, "Member 'DeceiveIncGameStateBase_AddTimeToPhase::SecondsToAdd' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.CanGiveXpEvent
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncGameStateBase_CanGiveXpEvent final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_CanGiveXpEvent) == 0x000001, "Wrong alignment on DeceiveIncGameStateBase_CanGiveXpEvent");
static_assert(sizeof(DeceiveIncGameStateBase_CanGiveXpEvent) == 0x000001, "Wrong size on DeceiveIncGameStateBase_CanGiveXpEvent");
static_assert(offsetof(DeceiveIncGameStateBase_CanGiveXpEvent, ReturnValue) == 0x000000, "Member 'DeceiveIncGameStateBase_CanGiveXpEvent::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.GetAllXpEventDisplayInfoForPlayer
// 0x0018 (0x0018 - 0x0000)
struct DeceiveIncGameStateBase_GetAllXpEventDisplayInfoForPlayer final
{
public:
	class ADIPlayerState*                         DIPlayerState;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FXpTypeEventGroupDisplayInfo>   ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_GetAllXpEventDisplayInfoForPlayer) == 0x000008, "Wrong alignment on DeceiveIncGameStateBase_GetAllXpEventDisplayInfoForPlayer");
static_assert(sizeof(DeceiveIncGameStateBase_GetAllXpEventDisplayInfoForPlayer) == 0x000018, "Wrong size on DeceiveIncGameStateBase_GetAllXpEventDisplayInfoForPlayer");
static_assert(offsetof(DeceiveIncGameStateBase_GetAllXpEventDisplayInfoForPlayer, DIPlayerState) == 0x000000, "Member 'DeceiveIncGameStateBase_GetAllXpEventDisplayInfoForPlayer::DIPlayerState' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_GetAllXpEventDisplayInfoForPlayer, ReturnValue) == 0x000008, "Member 'DeceiveIncGameStateBase_GetAllXpEventDisplayInfoForPlayer::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.GetCommunityTrackerFromKey
// 0x0020 (0x0020 - 0x0000)
struct DeceiveIncGameStateBase_GetCommunityTrackerFromKey final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_GetCommunityTrackerFromKey) == 0x000008, "Wrong alignment on DeceiveIncGameStateBase_GetCommunityTrackerFromKey");
static_assert(sizeof(DeceiveIncGameStateBase_GetCommunityTrackerFromKey) == 0x000020, "Wrong size on DeceiveIncGameStateBase_GetCommunityTrackerFromKey");
static_assert(offsetof(DeceiveIncGameStateBase_GetCommunityTrackerFromKey, Key) == 0x000000, "Member 'DeceiveIncGameStateBase_GetCommunityTrackerFromKey::Key' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_GetCommunityTrackerFromKey, ReturnValue) == 0x000010, "Member 'DeceiveIncGameStateBase_GetCommunityTrackerFromKey::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.GetCurrentMapData
// 0x0008 (0x0008 - 0x0000)
struct DeceiveIncGameStateBase_GetCurrentMapData final
{
public:
	class UMapData*                               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_GetCurrentMapData) == 0x000008, "Wrong alignment on DeceiveIncGameStateBase_GetCurrentMapData");
static_assert(sizeof(DeceiveIncGameStateBase_GetCurrentMapData) == 0x000008, "Wrong size on DeceiveIncGameStateBase_GetCurrentMapData");
static_assert(offsetof(DeceiveIncGameStateBase_GetCurrentMapData, ReturnValue) == 0x000000, "Member 'DeceiveIncGameStateBase_GetCurrentMapData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.GetCurrentPhaseInfo
// 0x0008 (0x0008 - 0x0000)
struct DeceiveIncGameStateBase_GetCurrentPhaseInfo final
{
public:
	class UBaseGamePhaseInfo*                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_GetCurrentPhaseInfo) == 0x000008, "Wrong alignment on DeceiveIncGameStateBase_GetCurrentPhaseInfo");
static_assert(sizeof(DeceiveIncGameStateBase_GetCurrentPhaseInfo) == 0x000008, "Wrong size on DeceiveIncGameStateBase_GetCurrentPhaseInfo");
static_assert(offsetof(DeceiveIncGameStateBase_GetCurrentPhaseInfo, ReturnValue) == 0x000000, "Member 'DeceiveIncGameStateBase_GetCurrentPhaseInfo::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.GetDisplayNameForXPEvent
// 0x0020 (0x0020 - 0x0000)
struct DeceiveIncGameStateBase_GetDisplayNameForXPEvent final
{
public:
	EDIXPEvent                                    XPEventType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_GetDisplayNameForXPEvent) == 0x000008, "Wrong alignment on DeceiveIncGameStateBase_GetDisplayNameForXPEvent");
static_assert(sizeof(DeceiveIncGameStateBase_GetDisplayNameForXPEvent) == 0x000020, "Wrong size on DeceiveIncGameStateBase_GetDisplayNameForXPEvent");
static_assert(offsetof(DeceiveIncGameStateBase_GetDisplayNameForXPEvent, XPEventType) == 0x000000, "Member 'DeceiveIncGameStateBase_GetDisplayNameForXPEvent::XPEventType' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_GetDisplayNameForXPEvent, ReturnValue) == 0x000008, "Member 'DeceiveIncGameStateBase_GetDisplayNameForXPEvent::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.GetEventSpecificXpTypeToAffect
// 0x0018 (0x0018 - 0x0000)
struct DeceiveIncGameStateBase_GetEventSpecificXpTypeToAffect final
{
public:
	EDIXPEvent                                    XPEventType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_GetEventSpecificXpTypeToAffect) == 0x000008, "Wrong alignment on DeceiveIncGameStateBase_GetEventSpecificXpTypeToAffect");
static_assert(sizeof(DeceiveIncGameStateBase_GetEventSpecificXpTypeToAffect) == 0x000018, "Wrong size on DeceiveIncGameStateBase_GetEventSpecificXpTypeToAffect");
static_assert(offsetof(DeceiveIncGameStateBase_GetEventSpecificXpTypeToAffect, XPEventType) == 0x000000, "Member 'DeceiveIncGameStateBase_GetEventSpecificXpTypeToAffect::XPEventType' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_GetEventSpecificXpTypeToAffect, ReturnValue) == 0x000008, "Member 'DeceiveIncGameStateBase_GetEventSpecificXpTypeToAffect::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.GetLevelForXpValue
// 0x0010 (0x0010 - 0x0000)
struct DeceiveIncGameStateBase_GetLevelForXpValue final
{
public:
	int32                                         CurrentLevel;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XPTotal;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EXpProgressionType                            ProgressionType;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_GetLevelForXpValue) == 0x000004, "Wrong alignment on DeceiveIncGameStateBase_GetLevelForXpValue");
static_assert(sizeof(DeceiveIncGameStateBase_GetLevelForXpValue) == 0x000010, "Wrong size on DeceiveIncGameStateBase_GetLevelForXpValue");
static_assert(offsetof(DeceiveIncGameStateBase_GetLevelForXpValue, CurrentLevel) == 0x000000, "Member 'DeceiveIncGameStateBase_GetLevelForXpValue::CurrentLevel' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_GetLevelForXpValue, XPTotal) == 0x000004, "Member 'DeceiveIncGameStateBase_GetLevelForXpValue::XPTotal' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_GetLevelForXpValue, ProgressionType) == 0x000008, "Member 'DeceiveIncGameStateBase_GetLevelForXpValue::ProgressionType' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_GetLevelForXpValue, ReturnValue) == 0x00000C, "Member 'DeceiveIncGameStateBase_GetLevelForXpValue::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.GetMultiplicatorEventSpecificXpTypeToAffect
// 0x0018 (0x0018 - 0x0000)
struct DeceiveIncGameStateBase_GetMultiplicatorEventSpecificXpTypeToAffect final
{
public:
	EDIXPEvent                                    XPEventType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_GetMultiplicatorEventSpecificXpTypeToAffect) == 0x000008, "Wrong alignment on DeceiveIncGameStateBase_GetMultiplicatorEventSpecificXpTypeToAffect");
static_assert(sizeof(DeceiveIncGameStateBase_GetMultiplicatorEventSpecificXpTypeToAffect) == 0x000018, "Wrong size on DeceiveIncGameStateBase_GetMultiplicatorEventSpecificXpTypeToAffect");
static_assert(offsetof(DeceiveIncGameStateBase_GetMultiplicatorEventSpecificXpTypeToAffect, XPEventType) == 0x000000, "Member 'DeceiveIncGameStateBase_GetMultiplicatorEventSpecificXpTypeToAffect::XPEventType' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_GetMultiplicatorEventSpecificXpTypeToAffect, ReturnValue) == 0x000008, "Member 'DeceiveIncGameStateBase_GetMultiplicatorEventSpecificXpTypeToAffect::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.GetNextMapName
// 0x0018 (0x0018 - 0x0000)
struct DeceiveIncGameStateBase_GetNextMapName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_GetNextMapName) == 0x000008, "Wrong alignment on DeceiveIncGameStateBase_GetNextMapName");
static_assert(sizeof(DeceiveIncGameStateBase_GetNextMapName) == 0x000018, "Wrong size on DeceiveIncGameStateBase_GetNextMapName");
static_assert(offsetof(DeceiveIncGameStateBase_GetNextMapName, ReturnValue) == 0x000000, "Member 'DeceiveIncGameStateBase_GetNextMapName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.GetProgressionMaxLevel
// 0x0008 (0x0008 - 0x0000)
struct DeceiveIncGameStateBase_GetProgressionMaxLevel final
{
public:
	EXpProgressionType                            ProgressionType;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_GetProgressionMaxLevel) == 0x000004, "Wrong alignment on DeceiveIncGameStateBase_GetProgressionMaxLevel");
static_assert(sizeof(DeceiveIncGameStateBase_GetProgressionMaxLevel) == 0x000008, "Wrong size on DeceiveIncGameStateBase_GetProgressionMaxLevel");
static_assert(offsetof(DeceiveIncGameStateBase_GetProgressionMaxLevel, ProgressionType) == 0x000000, "Member 'DeceiveIncGameStateBase_GetProgressionMaxLevel::ProgressionType' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_GetProgressionMaxLevel, ReturnValue) == 0x000004, "Member 'DeceiveIncGameStateBase_GetProgressionMaxLevel::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.GetProgressionPercent
// 0x0010 (0x0010 - 0x0000)
struct DeceiveIncGameStateBase_GetProgressionPercent final
{
public:
	int32                                         CurrentLevel;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XPTotal;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EXpProgressionType                            ProgressionType;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_GetProgressionPercent) == 0x000004, "Wrong alignment on DeceiveIncGameStateBase_GetProgressionPercent");
static_assert(sizeof(DeceiveIncGameStateBase_GetProgressionPercent) == 0x000010, "Wrong size on DeceiveIncGameStateBase_GetProgressionPercent");
static_assert(offsetof(DeceiveIncGameStateBase_GetProgressionPercent, CurrentLevel) == 0x000000, "Member 'DeceiveIncGameStateBase_GetProgressionPercent::CurrentLevel' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_GetProgressionPercent, XPTotal) == 0x000004, "Member 'DeceiveIncGameStateBase_GetProgressionPercent::XPTotal' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_GetProgressionPercent, ProgressionType) == 0x000008, "Member 'DeceiveIncGameStateBase_GetProgressionPercent::ProgressionType' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_GetProgressionPercent, ReturnValue) == 0x00000C, "Member 'DeceiveIncGameStateBase_GetProgressionPercent::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.GetRequiredXPForLevel
// 0x000C (0x000C - 0x0000)
struct DeceiveIncGameStateBase_GetRequiredXPForLevel final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EXpProgressionType                            ProgressionType;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_GetRequiredXPForLevel) == 0x000004, "Wrong alignment on DeceiveIncGameStateBase_GetRequiredXPForLevel");
static_assert(sizeof(DeceiveIncGameStateBase_GetRequiredXPForLevel) == 0x00000C, "Wrong size on DeceiveIncGameStateBase_GetRequiredXPForLevel");
static_assert(offsetof(DeceiveIncGameStateBase_GetRequiredXPForLevel, Level) == 0x000000, "Member 'DeceiveIncGameStateBase_GetRequiredXPForLevel::Level' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_GetRequiredXPForLevel, ProgressionType) == 0x000004, "Member 'DeceiveIncGameStateBase_GetRequiredXPForLevel::ProgressionType' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_GetRequiredXPForLevel, ReturnValue) == 0x000008, "Member 'DeceiveIncGameStateBase_GetRequiredXPForLevel::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.GetXpEventDisplayInfoForPlayer
// 0x0058 (0x0058 - 0x0000)
struct DeceiveIncGameStateBase_GetXpEventDisplayInfoForPlayer final
{
public:
	class ADIPlayerState*                         DIPlayerState;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FXpEventGroupDisplayInfo> ReturnValue;                                       // 0x0008(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_GetXpEventDisplayInfoForPlayer) == 0x000008, "Wrong alignment on DeceiveIncGameStateBase_GetXpEventDisplayInfoForPlayer");
static_assert(sizeof(DeceiveIncGameStateBase_GetXpEventDisplayInfoForPlayer) == 0x000058, "Wrong size on DeceiveIncGameStateBase_GetXpEventDisplayInfoForPlayer");
static_assert(offsetof(DeceiveIncGameStateBase_GetXpEventDisplayInfoForPlayer, DIPlayerState) == 0x000000, "Member 'DeceiveIncGameStateBase_GetXpEventDisplayInfoForPlayer::DIPlayerState' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_GetXpEventDisplayInfoForPlayer, ReturnValue) == 0x000008, "Member 'DeceiveIncGameStateBase_GetXpEventDisplayInfoForPlayer::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.GetXpMultiplicatorEventDisplayInfoForPlayer
// 0x0058 (0x0058 - 0x0000)
struct DeceiveIncGameStateBase_GetXpMultiplicatorEventDisplayInfoForPlayer final
{
public:
	class ADIPlayerState*                         DIPlayerState;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FXpEventGroupDisplayInfo> ReturnValue;                                       // 0x0008(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_GetXpMultiplicatorEventDisplayInfoForPlayer) == 0x000008, "Wrong alignment on DeceiveIncGameStateBase_GetXpMultiplicatorEventDisplayInfoForPlayer");
static_assert(sizeof(DeceiveIncGameStateBase_GetXpMultiplicatorEventDisplayInfoForPlayer) == 0x000058, "Wrong size on DeceiveIncGameStateBase_GetXpMultiplicatorEventDisplayInfoForPlayer");
static_assert(offsetof(DeceiveIncGameStateBase_GetXpMultiplicatorEventDisplayInfoForPlayer, DIPlayerState) == 0x000000, "Member 'DeceiveIncGameStateBase_GetXpMultiplicatorEventDisplayInfoForPlayer::DIPlayerState' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_GetXpMultiplicatorEventDisplayInfoForPlayer, ReturnValue) == 0x000008, "Member 'DeceiveIncGameStateBase_GetXpMultiplicatorEventDisplayInfoForPlayer::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.GetXpMultiplicatorValueForEvent
// 0x0008 (0x0008 - 0x0000)
struct DeceiveIncGameStateBase_GetXpMultiplicatorValueForEvent final
{
public:
	EDIXPEvent                                    XPEventType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_GetXpMultiplicatorValueForEvent) == 0x000004, "Wrong alignment on DeceiveIncGameStateBase_GetXpMultiplicatorValueForEvent");
static_assert(sizeof(DeceiveIncGameStateBase_GetXpMultiplicatorValueForEvent) == 0x000008, "Wrong size on DeceiveIncGameStateBase_GetXpMultiplicatorValueForEvent");
static_assert(offsetof(DeceiveIncGameStateBase_GetXpMultiplicatorValueForEvent, XPEventType) == 0x000000, "Member 'DeceiveIncGameStateBase_GetXpMultiplicatorValueForEvent::XPEventType' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_GetXpMultiplicatorValueForEvent, ReturnValue) == 0x000004, "Member 'DeceiveIncGameStateBase_GetXpMultiplicatorValueForEvent::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.GetXpValueForEvent
// 0x0008 (0x0008 - 0x0000)
struct DeceiveIncGameStateBase_GetXpValueForEvent final
{
public:
	EDIXPEvent                                    XPEventType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_GetXpValueForEvent) == 0x000004, "Wrong alignment on DeceiveIncGameStateBase_GetXpValueForEvent");
static_assert(sizeof(DeceiveIncGameStateBase_GetXpValueForEvent) == 0x000008, "Wrong size on DeceiveIncGameStateBase_GetXpValueForEvent");
static_assert(offsetof(DeceiveIncGameStateBase_GetXpValueForEvent, XPEventType) == 0x000000, "Member 'DeceiveIncGameStateBase_GetXpValueForEvent::XPEventType' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_GetXpValueForEvent, ReturnValue) == 0x000004, "Member 'DeceiveIncGameStateBase_GetXpValueForEvent::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.HandleCommunityTrackerEvent
// 0x0008 (0x0008 - 0x0000)
struct DeceiveIncGameStateBase_HandleCommunityTrackerEvent final
{
public:
	EDICommunityTrackerEvent                      CommunityTrackerEventType;                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EventAmount;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_HandleCommunityTrackerEvent) == 0x000004, "Wrong alignment on DeceiveIncGameStateBase_HandleCommunityTrackerEvent");
static_assert(sizeof(DeceiveIncGameStateBase_HandleCommunityTrackerEvent) == 0x000008, "Wrong size on DeceiveIncGameStateBase_HandleCommunityTrackerEvent");
static_assert(offsetof(DeceiveIncGameStateBase_HandleCommunityTrackerEvent, CommunityTrackerEventType) == 0x000000, "Member 'DeceiveIncGameStateBase_HandleCommunityTrackerEvent::CommunityTrackerEventType' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_HandleCommunityTrackerEvent, EventAmount) == 0x000004, "Member 'DeceiveIncGameStateBase_HandleCommunityTrackerEvent::EventAmount' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.HandleSpyDespawnedEvent
// 0x0008 (0x0008 - 0x0000)
struct DeceiveIncGameStateBase_HandleSpyDespawnedEvent final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_HandleSpyDespawnedEvent) == 0x000008, "Wrong alignment on DeceiveIncGameStateBase_HandleSpyDespawnedEvent");
static_assert(sizeof(DeceiveIncGameStateBase_HandleSpyDespawnedEvent) == 0x000008, "Wrong size on DeceiveIncGameStateBase_HandleSpyDespawnedEvent");
static_assert(offsetof(DeceiveIncGameStateBase_HandleSpyDespawnedEvent, Spy) == 0x000000, "Member 'DeceiveIncGameStateBase_HandleSpyDespawnedEvent::Spy' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.HandleSpySpawnedEvent
// 0x0008 (0x0008 - 0x0000)
struct DeceiveIncGameStateBase_HandleSpySpawnedEvent final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_HandleSpySpawnedEvent) == 0x000008, "Wrong alignment on DeceiveIncGameStateBase_HandleSpySpawnedEvent");
static_assert(sizeof(DeceiveIncGameStateBase_HandleSpySpawnedEvent) == 0x000008, "Wrong size on DeceiveIncGameStateBase_HandleSpySpawnedEvent");
static_assert(offsetof(DeceiveIncGameStateBase_HandleSpySpawnedEvent, Spy) == 0x000000, "Member 'DeceiveIncGameStateBase_HandleSpySpawnedEvent::Spy' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.HandleVaultTerminalDeactivation
// 0x0008 (0x0008 - 0x0000)
struct DeceiveIncGameStateBase_HandleVaultTerminalDeactivation final
{
public:
	class ADIPlayerState*                         DIPlayerState;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_HandleVaultTerminalDeactivation) == 0x000008, "Wrong alignment on DeceiveIncGameStateBase_HandleVaultTerminalDeactivation");
static_assert(sizeof(DeceiveIncGameStateBase_HandleVaultTerminalDeactivation) == 0x000008, "Wrong size on DeceiveIncGameStateBase_HandleVaultTerminalDeactivation");
static_assert(offsetof(DeceiveIncGameStateBase_HandleVaultTerminalDeactivation, DIPlayerState) == 0x000000, "Member 'DeceiveIncGameStateBase_HandleVaultTerminalDeactivation::DIPlayerState' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.HandleXPEvent
// 0x0010 (0x0010 - 0x0000)
struct DeceiveIncGameStateBase_HandleXPEvent final
{
public:
	class ADIPlayerState*                         DIPlayerState;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDIXPEvent                                    XPEventType;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EventAmount;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_HandleXPEvent) == 0x000008, "Wrong alignment on DeceiveIncGameStateBase_HandleXPEvent");
static_assert(sizeof(DeceiveIncGameStateBase_HandleXPEvent) == 0x000010, "Wrong size on DeceiveIncGameStateBase_HandleXPEvent");
static_assert(offsetof(DeceiveIncGameStateBase_HandleXPEvent, DIPlayerState) == 0x000000, "Member 'DeceiveIncGameStateBase_HandleXPEvent::DIPlayerState' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_HandleXPEvent, XPEventType) == 0x000008, "Member 'DeceiveIncGameStateBase_HandleXPEvent::XPEventType' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_HandleXPEvent, EventAmount) == 0x00000C, "Member 'DeceiveIncGameStateBase_HandleXPEvent::EventAmount' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.IncrementVaultDeactivationCount
// 0x0008 (0x0008 - 0x0000)
struct DeceiveIncGameStateBase_IncrementVaultDeactivationCount final
{
public:
	class ADIPlayerState*                         DIPlayerState;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_IncrementVaultDeactivationCount) == 0x000008, "Wrong alignment on DeceiveIncGameStateBase_IncrementVaultDeactivationCount");
static_assert(sizeof(DeceiveIncGameStateBase_IncrementVaultDeactivationCount) == 0x000008, "Wrong size on DeceiveIncGameStateBase_IncrementVaultDeactivationCount");
static_assert(offsetof(DeceiveIncGameStateBase_IncrementVaultDeactivationCount, DIPlayerState) == 0x000000, "Member 'DeceiveIncGameStateBase_IncrementVaultDeactivationCount::DIPlayerState' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.IsPrivateLobbyMatch
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncGameStateBase_IsPrivateLobbyMatch final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_IsPrivateLobbyMatch) == 0x000001, "Wrong alignment on DeceiveIncGameStateBase_IsPrivateLobbyMatch");
static_assert(sizeof(DeceiveIncGameStateBase_IsPrivateLobbyMatch) == 0x000001, "Wrong size on DeceiveIncGameStateBase_IsPrivateLobbyMatch");
static_assert(offsetof(DeceiveIncGameStateBase_IsPrivateLobbyMatch, ReturnValue) == 0x000000, "Member 'DeceiveIncGameStateBase_IsPrivateLobbyMatch::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.IsXpEventAffectingRegularXpType
// 0x0002 (0x0002 - 0x0000)
struct DeceiveIncGameStateBase_IsXpEventAffectingRegularXpType final
{
public:
	EDIXPEvent                                    XPEventType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_IsXpEventAffectingRegularXpType) == 0x000001, "Wrong alignment on DeceiveIncGameStateBase_IsXpEventAffectingRegularXpType");
static_assert(sizeof(DeceiveIncGameStateBase_IsXpEventAffectingRegularXpType) == 0x000002, "Wrong size on DeceiveIncGameStateBase_IsXpEventAffectingRegularXpType");
static_assert(offsetof(DeceiveIncGameStateBase_IsXpEventAffectingRegularXpType, XPEventType) == 0x000000, "Member 'DeceiveIncGameStateBase_IsXpEventAffectingRegularXpType::XPEventType' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_IsXpEventAffectingRegularXpType, ReturnValue) == 0x000001, "Member 'DeceiveIncGameStateBase_IsXpEventAffectingRegularXpType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.IsXpEventSharedToFaction
// 0x0002 (0x0002 - 0x0000)
struct DeceiveIncGameStateBase_IsXpEventSharedToFaction final
{
public:
	EDIXPEvent                                    XPEventType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_IsXpEventSharedToFaction) == 0x000001, "Wrong alignment on DeceiveIncGameStateBase_IsXpEventSharedToFaction");
static_assert(sizeof(DeceiveIncGameStateBase_IsXpEventSharedToFaction) == 0x000002, "Wrong size on DeceiveIncGameStateBase_IsXpEventSharedToFaction");
static_assert(offsetof(DeceiveIncGameStateBase_IsXpEventSharedToFaction, XPEventType) == 0x000000, "Member 'DeceiveIncGameStateBase_IsXpEventSharedToFaction::XPEventType' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_IsXpEventSharedToFaction, ReturnValue) == 0x000001, "Member 'DeceiveIncGameStateBase_IsXpEventSharedToFaction::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.IsXpMultiplicatorEventAffectingRegularXpType
// 0x0002 (0x0002 - 0x0000)
struct DeceiveIncGameStateBase_IsXpMultiplicatorEventAffectingRegularXpType final
{
public:
	EDIXPEvent                                    XPEventType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_IsXpMultiplicatorEventAffectingRegularXpType) == 0x000001, "Wrong alignment on DeceiveIncGameStateBase_IsXpMultiplicatorEventAffectingRegularXpType");
static_assert(sizeof(DeceiveIncGameStateBase_IsXpMultiplicatorEventAffectingRegularXpType) == 0x000002, "Wrong size on DeceiveIncGameStateBase_IsXpMultiplicatorEventAffectingRegularXpType");
static_assert(offsetof(DeceiveIncGameStateBase_IsXpMultiplicatorEventAffectingRegularXpType, XPEventType) == 0x000000, "Member 'DeceiveIncGameStateBase_IsXpMultiplicatorEventAffectingRegularXpType::XPEventType' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_IsXpMultiplicatorEventAffectingRegularXpType, ReturnValue) == 0x000001, "Member 'DeceiveIncGameStateBase_IsXpMultiplicatorEventAffectingRegularXpType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.LockPlayerControlsMulticast
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncGameStateBase_LockPlayerControlsMulticast final
{
public:
	bool                                          bLock;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_LockPlayerControlsMulticast) == 0x000001, "Wrong alignment on DeceiveIncGameStateBase_LockPlayerControlsMulticast");
static_assert(sizeof(DeceiveIncGameStateBase_LockPlayerControlsMulticast) == 0x000001, "Wrong size on DeceiveIncGameStateBase_LockPlayerControlsMulticast");
static_assert(offsetof(DeceiveIncGameStateBase_LockPlayerControlsMulticast, bLock) == 0x000000, "Member 'DeceiveIncGameStateBase_LockPlayerControlsMulticast::bLock' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.NetMulticast_SignalGlobalEventToClients
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncGameStateBase_NetMulticast_SignalGlobalEventToClients final
{
public:
	EGameStateClientEventType                     ClientEvent;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_NetMulticast_SignalGlobalEventToClients) == 0x000001, "Wrong alignment on DeceiveIncGameStateBase_NetMulticast_SignalGlobalEventToClients");
static_assert(sizeof(DeceiveIncGameStateBase_NetMulticast_SignalGlobalEventToClients) == 0x000001, "Wrong size on DeceiveIncGameStateBase_NetMulticast_SignalGlobalEventToClients");
static_assert(offsetof(DeceiveIncGameStateBase_NetMulticast_SignalGlobalEventToClients, ClientEvent) == 0x000000, "Member 'DeceiveIncGameStateBase_NetMulticast_SignalGlobalEventToClients::ClientEvent' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.NetMulticast_SignalVaultTerminalDeactivationToClient
// 0x0010 (0x0010 - 0x0000)
struct DeceiveIncGameStateBase_NetMulticast_SignalVaultTerminalDeactivationToClient final
{
public:
	class ADIPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FactionID;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DeceiveIncGameStateBase_NetMulticast_SignalVaultTerminalDeactivationToClient) == 0x000008, "Wrong alignment on DeceiveIncGameStateBase_NetMulticast_SignalVaultTerminalDeactivationToClient");
static_assert(sizeof(DeceiveIncGameStateBase_NetMulticast_SignalVaultTerminalDeactivationToClient) == 0x000010, "Wrong size on DeceiveIncGameStateBase_NetMulticast_SignalVaultTerminalDeactivationToClient");
static_assert(offsetof(DeceiveIncGameStateBase_NetMulticast_SignalVaultTerminalDeactivationToClient, PlayerState) == 0x000000, "Member 'DeceiveIncGameStateBase_NetMulticast_SignalVaultTerminalDeactivationToClient::PlayerState' has a wrong offset!");
static_assert(offsetof(DeceiveIncGameStateBase_NetMulticast_SignalVaultTerminalDeactivationToClient, FactionID) == 0x000008, "Member 'DeceiveIncGameStateBase_NetMulticast_SignalVaultTerminalDeactivationToClient::FactionID' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.OnRep_CurrentPhaseElapsedTime
// 0x0004 (0x0004 - 0x0000)
struct DeceiveIncGameStateBase_OnRep_CurrentPhaseElapsedTime final
{
public:
	int32                                         OldValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_OnRep_CurrentPhaseElapsedTime) == 0x000004, "Wrong alignment on DeceiveIncGameStateBase_OnRep_CurrentPhaseElapsedTime");
static_assert(sizeof(DeceiveIncGameStateBase_OnRep_CurrentPhaseElapsedTime) == 0x000004, "Wrong size on DeceiveIncGameStateBase_OnRep_CurrentPhaseElapsedTime");
static_assert(offsetof(DeceiveIncGameStateBase_OnRep_CurrentPhaseElapsedTime, OldValue) == 0x000000, "Member 'DeceiveIncGameStateBase_OnRep_CurrentPhaseElapsedTime::OldValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.SetCurrentPhaseTimeLeftInSeconds
// 0x0004 (0x0004 - 0x0000)
struct DeceiveIncGameStateBase_SetCurrentPhaseTimeLeftInSeconds final
{
public:
	int32                                         SecondsLeft;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_SetCurrentPhaseTimeLeftInSeconds) == 0x000004, "Wrong alignment on DeceiveIncGameStateBase_SetCurrentPhaseTimeLeftInSeconds");
static_assert(sizeof(DeceiveIncGameStateBase_SetCurrentPhaseTimeLeftInSeconds) == 0x000004, "Wrong size on DeceiveIncGameStateBase_SetCurrentPhaseTimeLeftInSeconds");
static_assert(offsetof(DeceiveIncGameStateBase_SetCurrentPhaseTimeLeftInSeconds, SecondsLeft) == 0x000000, "Member 'DeceiveIncGameStateBase_SetCurrentPhaseTimeLeftInSeconds::SecondsLeft' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.SetPauseTimer
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncGameStateBase_SetPauseTimer final
{
public:
	bool                                          bPause;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_SetPauseTimer) == 0x000001, "Wrong alignment on DeceiveIncGameStateBase_SetPauseTimer");
static_assert(sizeof(DeceiveIncGameStateBase_SetPauseTimer) == 0x000001, "Wrong size on DeceiveIncGameStateBase_SetPauseTimer");
static_assert(offsetof(DeceiveIncGameStateBase_SetPauseTimer, bPause) == 0x000000, "Member 'DeceiveIncGameStateBase_SetPauseTimer::bPause' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.GetCurrentLimitedEventId
// 0x0010 (0x0010 - 0x0000)
struct DeceiveIncGameStateBase_GetCurrentLimitedEventId final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_GetCurrentLimitedEventId) == 0x000008, "Wrong alignment on DeceiveIncGameStateBase_GetCurrentLimitedEventId");
static_assert(sizeof(DeceiveIncGameStateBase_GetCurrentLimitedEventId) == 0x000010, "Wrong size on DeceiveIncGameStateBase_GetCurrentLimitedEventId");
static_assert(offsetof(DeceiveIncGameStateBase_GetCurrentLimitedEventId, ReturnValue) == 0x000000, "Member 'DeceiveIncGameStateBase_GetCurrentLimitedEventId::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.GetCurrentPhaseTimeLeftInSeconds
// 0x0004 (0x0004 - 0x0000)
struct DeceiveIncGameStateBase_GetCurrentPhaseTimeLeftInSeconds final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_GetCurrentPhaseTimeLeftInSeconds) == 0x000004, "Wrong alignment on DeceiveIncGameStateBase_GetCurrentPhaseTimeLeftInSeconds");
static_assert(sizeof(DeceiveIncGameStateBase_GetCurrentPhaseTimeLeftInSeconds) == 0x000004, "Wrong size on DeceiveIncGameStateBase_GetCurrentPhaseTimeLeftInSeconds");
static_assert(offsetof(DeceiveIncGameStateBase_GetCurrentPhaseTimeLeftInSeconds, ReturnValue) == 0x000000, "Member 'DeceiveIncGameStateBase_GetCurrentPhaseTimeLeftInSeconds::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameStateBase.GetMaximumPlayerCountForCurrentMode
// 0x0004 (0x0004 - 0x0000)
struct DeceiveIncGameStateBase_GetMaximumPlayerCountForCurrentMode final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameStateBase_GetMaximumPlayerCountForCurrentMode) == 0x000004, "Wrong alignment on DeceiveIncGameStateBase_GetMaximumPlayerCountForCurrentMode");
static_assert(sizeof(DeceiveIncGameStateBase_GetMaximumPlayerCountForCurrentMode) == 0x000004, "Wrong size on DeceiveIncGameStateBase_GetMaximumPlayerCountForCurrentMode");
static_assert(offsetof(DeceiveIncGameStateBase_GetMaximumPlayerCountForCurrentMode, ReturnValue) == 0x000000, "Member 'DeceiveIncGameStateBase_GetMaximumPlayerCountForCurrentMode::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncMatchGameState.AdvancePhase
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncMatchGameState_AdvancePhase final
{
public:
	bool                                          bViaTimer;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncMatchGameState_AdvancePhase) == 0x000001, "Wrong alignment on DeceiveIncMatchGameState_AdvancePhase");
static_assert(sizeof(DeceiveIncMatchGameState_AdvancePhase) == 0x000001, "Wrong size on DeceiveIncMatchGameState_AdvancePhase");
static_assert(offsetof(DeceiveIncMatchGameState_AdvancePhase, bViaTimer) == 0x000000, "Member 'DeceiveIncMatchGameState_AdvancePhase::bViaTimer' has a wrong offset!");

// Function DeceiveInc.DeceiveIncMatchGameState.GetGameMode
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncMatchGameState_GetGameMode final
{
public:
	EDIGameMode                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncMatchGameState_GetGameMode) == 0x000001, "Wrong alignment on DeceiveIncMatchGameState_GetGameMode");
static_assert(sizeof(DeceiveIncMatchGameState_GetGameMode) == 0x000001, "Wrong size on DeceiveIncMatchGameState_GetGameMode");
static_assert(offsetof(DeceiveIncMatchGameState_GetGameMode, ReturnValue) == 0x000000, "Member 'DeceiveIncMatchGameState_GetGameMode::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncMatchGameState.HandleNewSpyLoadoutCompleted
// 0x0008 (0x0008 - 0x0000)
struct DeceiveIncMatchGameState_HandleNewSpyLoadoutCompleted final
{
public:
	class UToolLoadoutComponent*                  ToolLoadout;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncMatchGameState_HandleNewSpyLoadoutCompleted) == 0x000008, "Wrong alignment on DeceiveIncMatchGameState_HandleNewSpyLoadoutCompleted");
static_assert(sizeof(DeceiveIncMatchGameState_HandleNewSpyLoadoutCompleted) == 0x000008, "Wrong size on DeceiveIncMatchGameState_HandleNewSpyLoadoutCompleted");
static_assert(offsetof(DeceiveIncMatchGameState_HandleNewSpyLoadoutCompleted, ToolLoadout) == 0x000000, "Member 'DeceiveIncMatchGameState_HandleNewSpyLoadoutCompleted::ToolLoadout' has a wrong offset!");

// Function DeceiveInc.DeceiveIncMatchGameState.IsInPregamePhase
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncMatchGameState_IsInPregamePhase final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncMatchGameState_IsInPregamePhase) == 0x000001, "Wrong alignment on DeceiveIncMatchGameState_IsInPregamePhase");
static_assert(sizeof(DeceiveIncMatchGameState_IsInPregamePhase) == 0x000001, "Wrong size on DeceiveIncMatchGameState_IsInPregamePhase");
static_assert(offsetof(DeceiveIncMatchGameState_IsInPregamePhase, ReturnValue) == 0x000000, "Member 'DeceiveIncMatchGameState_IsInPregamePhase::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncMatchGameState.OnRep_MatchResult
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncMatchGameState_OnRep_MatchResult final
{
public:
	EMatchResult                                  PreviousResult;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncMatchGameState_OnRep_MatchResult) == 0x000001, "Wrong alignment on DeceiveIncMatchGameState_OnRep_MatchResult");
static_assert(sizeof(DeceiveIncMatchGameState_OnRep_MatchResult) == 0x000001, "Wrong size on DeceiveIncMatchGameState_OnRep_MatchResult");
static_assert(offsetof(DeceiveIncMatchGameState_OnRep_MatchResult, PreviousResult) == 0x000000, "Member 'DeceiveIncMatchGameState_OnRep_MatchResult::PreviousResult' has a wrong offset!");

// Function DeceiveInc.DeceiveIncMatchGameState.OnRep_ObjectiveCarrier
// 0x0008 (0x0008 - 0x0000)
struct DeceiveIncMatchGameState_OnRep_ObjectiveCarrier final
{
public:
	class ASpy*                                   OldValue;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncMatchGameState_OnRep_ObjectiveCarrier) == 0x000008, "Wrong alignment on DeceiveIncMatchGameState_OnRep_ObjectiveCarrier");
static_assert(sizeof(DeceiveIncMatchGameState_OnRep_ObjectiveCarrier) == 0x000008, "Wrong size on DeceiveIncMatchGameState_OnRep_ObjectiveCarrier");
static_assert(offsetof(DeceiveIncMatchGameState_OnRep_ObjectiveCarrier, OldValue) == 0x000000, "Member 'DeceiveIncMatchGameState_OnRep_ObjectiveCarrier::OldValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncMatchGameState.SetVaultTerminalUnlockedCount
// 0x0004 (0x0004 - 0x0000)
struct DeceiveIncMatchGameState_SetVaultTerminalUnlockedCount final
{
public:
	int32                                         NewCount;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncMatchGameState_SetVaultTerminalUnlockedCount) == 0x000004, "Wrong alignment on DeceiveIncMatchGameState_SetVaultTerminalUnlockedCount");
static_assert(sizeof(DeceiveIncMatchGameState_SetVaultTerminalUnlockedCount) == 0x000004, "Wrong size on DeceiveIncMatchGameState_SetVaultTerminalUnlockedCount");
static_assert(offsetof(DeceiveIncMatchGameState_SetVaultTerminalUnlockedCount, NewCount) == 0x000000, "Member 'DeceiveIncMatchGameState_SetVaultTerminalUnlockedCount::NewCount' has a wrong offset!");

// Function DeceiveInc.DeceiveIncMatchGameState.SetVaultTerminalUnlockedRequirementCount
// 0x0004 (0x0004 - 0x0000)
struct DeceiveIncMatchGameState_SetVaultTerminalUnlockedRequirementCount final
{
public:
	int32                                         NewCount;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncMatchGameState_SetVaultTerminalUnlockedRequirementCount) == 0x000004, "Wrong alignment on DeceiveIncMatchGameState_SetVaultTerminalUnlockedRequirementCount");
static_assert(sizeof(DeceiveIncMatchGameState_SetVaultTerminalUnlockedRequirementCount) == 0x000004, "Wrong size on DeceiveIncMatchGameState_SetVaultTerminalUnlockedRequirementCount");
static_assert(offsetof(DeceiveIncMatchGameState_SetVaultTerminalUnlockedRequirementCount, NewCount) == 0x000000, "Member 'DeceiveIncMatchGameState_SetVaultTerminalUnlockedRequirementCount::NewCount' has a wrong offset!");

// Function DeceiveInc.DeceiveIncMatchGameState.ShouldShowTimer
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncMatchGameState_ShouldShowTimer final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncMatchGameState_ShouldShowTimer) == 0x000001, "Wrong alignment on DeceiveIncMatchGameState_ShouldShowTimer");
static_assert(sizeof(DeceiveIncMatchGameState_ShouldShowTimer) == 0x000001, "Wrong size on DeceiveIncMatchGameState_ShouldShowTimer");
static_assert(offsetof(DeceiveIncMatchGameState_ShouldShowTimer, ReturnValue) == 0x000000, "Member 'DeceiveIncMatchGameState_ShouldShowTimer::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncMatchGameState.GetCurrentGamePhaseTimeLeft
// 0x0004 (0x0004 - 0x0000)
struct DeceiveIncMatchGameState_GetCurrentGamePhaseTimeLeft final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncMatchGameState_GetCurrentGamePhaseTimeLeft) == 0x000004, "Wrong alignment on DeceiveIncMatchGameState_GetCurrentGamePhaseTimeLeft");
static_assert(sizeof(DeceiveIncMatchGameState_GetCurrentGamePhaseTimeLeft) == 0x000004, "Wrong size on DeceiveIncMatchGameState_GetCurrentGamePhaseTimeLeft");
static_assert(offsetof(DeceiveIncMatchGameState_GetCurrentGamePhaseTimeLeft, ReturnValue) == 0x000000, "Member 'DeceiveIncMatchGameState_GetCurrentGamePhaseTimeLeft::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncMatchGameState.GetPlayerExtracted
// 0x0008 (0x0008 - 0x0000)
struct DeceiveIncMatchGameState_GetPlayerExtracted final
{
public:
	class ADIPlayerState*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncMatchGameState_GetPlayerExtracted) == 0x000008, "Wrong alignment on DeceiveIncMatchGameState_GetPlayerExtracted");
static_assert(sizeof(DeceiveIncMatchGameState_GetPlayerExtracted) == 0x000008, "Wrong size on DeceiveIncMatchGameState_GetPlayerExtracted");
static_assert(offsetof(DeceiveIncMatchGameState_GetPlayerExtracted, ReturnValue) == 0x000000, "Member 'DeceiveIncMatchGameState_GetPlayerExtracted::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncMatchGameState.GetTimeLeftforHUD
// 0x0004 (0x0004 - 0x0000)
struct DeceiveIncMatchGameState_GetTimeLeftforHUD final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncMatchGameState_GetTimeLeftforHUD) == 0x000004, "Wrong alignment on DeceiveIncMatchGameState_GetTimeLeftforHUD");
static_assert(sizeof(DeceiveIncMatchGameState_GetTimeLeftforHUD) == 0x000004, "Wrong size on DeceiveIncMatchGameState_GetTimeLeftforHUD");
static_assert(offsetof(DeceiveIncMatchGameState_GetTimeLeftforHUD, ReturnValue) == 0x000000, "Member 'DeceiveIncMatchGameState_GetTimeLeftforHUD::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncMatchGameState.GetVaultTerminalUnlockedCount
// 0x0004 (0x0004 - 0x0000)
struct DeceiveIncMatchGameState_GetVaultTerminalUnlockedCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncMatchGameState_GetVaultTerminalUnlockedCount) == 0x000004, "Wrong alignment on DeceiveIncMatchGameState_GetVaultTerminalUnlockedCount");
static_assert(sizeof(DeceiveIncMatchGameState_GetVaultTerminalUnlockedCount) == 0x000004, "Wrong size on DeceiveIncMatchGameState_GetVaultTerminalUnlockedCount");
static_assert(offsetof(DeceiveIncMatchGameState_GetVaultTerminalUnlockedCount, ReturnValue) == 0x000000, "Member 'DeceiveIncMatchGameState_GetVaultTerminalUnlockedCount::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncMatchGameState.GetVaultTerminalUnlockedRequirementCount
// 0x0004 (0x0004 - 0x0000)
struct DeceiveIncMatchGameState_GetVaultTerminalUnlockedRequirementCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncMatchGameState_GetVaultTerminalUnlockedRequirementCount) == 0x000004, "Wrong alignment on DeceiveIncMatchGameState_GetVaultTerminalUnlockedRequirementCount");
static_assert(sizeof(DeceiveIncMatchGameState_GetVaultTerminalUnlockedRequirementCount) == 0x000004, "Wrong size on DeceiveIncMatchGameState_GetVaultTerminalUnlockedRequirementCount");
static_assert(offsetof(DeceiveIncMatchGameState_GetVaultTerminalUnlockedRequirementCount, ReturnValue) == 0x000000, "Member 'DeceiveIncMatchGameState_GetVaultTerminalUnlockedRequirementCount::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncMatchGameState.HasReachedVaultTerminalUnlockedRequirement
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncMatchGameState_HasReachedVaultTerminalUnlockedRequirement final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncMatchGameState_HasReachedVaultTerminalUnlockedRequirement) == 0x000001, "Wrong alignment on DeceiveIncMatchGameState_HasReachedVaultTerminalUnlockedRequirement");
static_assert(sizeof(DeceiveIncMatchGameState_HasReachedVaultTerminalUnlockedRequirement) == 0x000001, "Wrong size on DeceiveIncMatchGameState_HasReachedVaultTerminalUnlockedRequirement");
static_assert(offsetof(DeceiveIncMatchGameState_HasReachedVaultTerminalUnlockedRequirement, ReturnValue) == 0x000000, "Member 'DeceiveIncMatchGameState_HasReachedVaultTerminalUnlockedRequirement::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncMatchGameState.IsMatchFinished
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncMatchGameState_IsMatchFinished final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncMatchGameState_IsMatchFinished) == 0x000001, "Wrong alignment on DeceiveIncMatchGameState_IsMatchFinished");
static_assert(sizeof(DeceiveIncMatchGameState_IsMatchFinished) == 0x000001, "Wrong size on DeceiveIncMatchGameState_IsMatchFinished");
static_assert(offsetof(DeceiveIncMatchGameState_IsMatchFinished, ReturnValue) == 0x000000, "Member 'DeceiveIncMatchGameState_IsMatchFinished::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncMatchGameState.IsMatchOnGoing
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncMatchGameState_IsMatchOnGoing final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncMatchGameState_IsMatchOnGoing) == 0x000001, "Wrong alignment on DeceiveIncMatchGameState_IsMatchOnGoing");
static_assert(sizeof(DeceiveIncMatchGameState_IsMatchOnGoing) == 0x000001, "Wrong size on DeceiveIncMatchGameState_IsMatchOnGoing");
static_assert(offsetof(DeceiveIncMatchGameState_IsMatchOnGoing, ReturnValue) == 0x000000, "Member 'DeceiveIncMatchGameState_IsMatchOnGoing::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncMatchGameState.IsOnlyBotsAreAlive
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncMatchGameState_IsOnlyBotsAreAlive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncMatchGameState_IsOnlyBotsAreAlive) == 0x000001, "Wrong alignment on DeceiveIncMatchGameState_IsOnlyBotsAreAlive");
static_assert(sizeof(DeceiveIncMatchGameState_IsOnlyBotsAreAlive) == 0x000001, "Wrong size on DeceiveIncMatchGameState_IsOnlyBotsAreAlive");
static_assert(offsetof(DeceiveIncMatchGameState_IsOnlyBotsAreAlive, ReturnValue) == 0x000000, "Member 'DeceiveIncMatchGameState_IsOnlyBotsAreAlive::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncMatchGameState.IsSandboxGame
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncMatchGameState_IsSandboxGame final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncMatchGameState_IsSandboxGame) == 0x000001, "Wrong alignment on DeceiveIncMatchGameState_IsSandboxGame");
static_assert(sizeof(DeceiveIncMatchGameState_IsSandboxGame) == 0x000001, "Wrong size on DeceiveIncMatchGameState_IsSandboxGame");
static_assert(offsetof(DeceiveIncMatchGameState_IsSandboxGame, ReturnValue) == 0x000000, "Member 'DeceiveIncMatchGameState_IsSandboxGame::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncBotController.OnSpyDeath
// 0x0008 (0x0008 - 0x0000)
struct DeceiveIncBotController_OnSpyDeath final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncBotController_OnSpyDeath) == 0x000008, "Wrong alignment on DeceiveIncBotController_OnSpyDeath");
static_assert(sizeof(DeceiveIncBotController_OnSpyDeath) == 0x000008, "Wrong size on DeceiveIncBotController_OnSpyDeath");
static_assert(offsetof(DeceiveIncBotController_OnSpyDeath, Spy) == 0x000000, "Member 'DeceiveIncBotController_OnSpyDeath::Spy' has a wrong offset!");

// Function DeceiveInc.DeceiveIncBotController.ScriptedMoveTo
// 0x0018 (0x0018 - 0x0000)
struct DeceiveIncBotController_ScriptedMoveTo final
{
public:
	struct FVector                                MovePosition;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBotAction*                             ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncBotController_ScriptedMoveTo) == 0x000008, "Wrong alignment on DeceiveIncBotController_ScriptedMoveTo");
static_assert(sizeof(DeceiveIncBotController_ScriptedMoveTo) == 0x000018, "Wrong size on DeceiveIncBotController_ScriptedMoveTo");
static_assert(offsetof(DeceiveIncBotController_ScriptedMoveTo, MovePosition) == 0x000000, "Member 'DeceiveIncBotController_ScriptedMoveTo::MovePosition' has a wrong offset!");
static_assert(offsetof(DeceiveIncBotController_ScriptedMoveTo, ReturnValue) == 0x000010, "Member 'DeceiveIncBotController_ScriptedMoveTo::ReturnValue' has a wrong offset!");

// Function DeceiveInc.AnalogCursorSubsystem.Global_DisableVirtualCursor
// 0x0008 (0x0008 - 0x0000)
struct AnalogCursorSubsystem_Global_DisableVirtualCursor final
{
public:
	class APlayerController*                      PC;                                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnalogCursorSubsystem_Global_DisableVirtualCursor) == 0x000008, "Wrong alignment on AnalogCursorSubsystem_Global_DisableVirtualCursor");
static_assert(sizeof(AnalogCursorSubsystem_Global_DisableVirtualCursor) == 0x000008, "Wrong size on AnalogCursorSubsystem_Global_DisableVirtualCursor");
static_assert(offsetof(AnalogCursorSubsystem_Global_DisableVirtualCursor, PC) == 0x000000, "Member 'AnalogCursorSubsystem_Global_DisableVirtualCursor::PC' has a wrong offset!");

// Function DeceiveInc.AnalogCursorSubsystem.Global_EnableVirtualCursor
// 0x0008 (0x0008 - 0x0000)
struct AnalogCursorSubsystem_Global_EnableVirtualCursor final
{
public:
	class APlayerController*                      PC;                                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnalogCursorSubsystem_Global_EnableVirtualCursor) == 0x000008, "Wrong alignment on AnalogCursorSubsystem_Global_EnableVirtualCursor");
static_assert(sizeof(AnalogCursorSubsystem_Global_EnableVirtualCursor) == 0x000008, "Wrong size on AnalogCursorSubsystem_Global_EnableVirtualCursor");
static_assert(offsetof(AnalogCursorSubsystem_Global_EnableVirtualCursor, PC) == 0x000000, "Member 'AnalogCursorSubsystem_Global_EnableVirtualCursor::PC' has a wrong offset!");

// Function DeceiveInc.AnalogCursorSubsystem.Global_IsCursorOverInteractableWidget
// 0x0010 (0x0010 - 0x0000)
struct AnalogCursorSubsystem_Global_IsCursorOverInteractableWidget final
{
public:
	class APlayerController*                      PC;                                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnalogCursorSubsystem_Global_IsCursorOverInteractableWidget) == 0x000008, "Wrong alignment on AnalogCursorSubsystem_Global_IsCursorOverInteractableWidget");
static_assert(sizeof(AnalogCursorSubsystem_Global_IsCursorOverInteractableWidget) == 0x000010, "Wrong size on AnalogCursorSubsystem_Global_IsCursorOverInteractableWidget");
static_assert(offsetof(AnalogCursorSubsystem_Global_IsCursorOverInteractableWidget, PC) == 0x000000, "Member 'AnalogCursorSubsystem_Global_IsCursorOverInteractableWidget::PC' has a wrong offset!");
static_assert(offsetof(AnalogCursorSubsystem_Global_IsCursorOverInteractableWidget, ReturnValue) == 0x000008, "Member 'AnalogCursorSubsystem_Global_IsCursorOverInteractableWidget::ReturnValue' has a wrong offset!");

// Function DeceiveInc.AnalogCursorSubsystem.ContainsGamepadCursorInputProcessor
// 0x0001 (0x0001 - 0x0000)
struct AnalogCursorSubsystem_ContainsGamepadCursorInputProcessor final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnalogCursorSubsystem_ContainsGamepadCursorInputProcessor) == 0x000001, "Wrong alignment on AnalogCursorSubsystem_ContainsGamepadCursorInputProcessor");
static_assert(sizeof(AnalogCursorSubsystem_ContainsGamepadCursorInputProcessor) == 0x000001, "Wrong size on AnalogCursorSubsystem_ContainsGamepadCursorInputProcessor");
static_assert(offsetof(AnalogCursorSubsystem_ContainsGamepadCursorInputProcessor, ReturnValue) == 0x000000, "Member 'AnalogCursorSubsystem_ContainsGamepadCursorInputProcessor::ReturnValue' has a wrong offset!");

// Function DeceiveInc.AnalogCursorSubsystem.IsCursorOverInteractableWidget
// 0x0001 (0x0001 - 0x0000)
struct AnalogCursorSubsystem_IsCursorOverInteractableWidget final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnalogCursorSubsystem_IsCursorOverInteractableWidget) == 0x000001, "Wrong alignment on AnalogCursorSubsystem_IsCursorOverInteractableWidget");
static_assert(sizeof(AnalogCursorSubsystem_IsCursorOverInteractableWidget) == 0x000001, "Wrong size on AnalogCursorSubsystem_IsCursorOverInteractableWidget");
static_assert(offsetof(AnalogCursorSubsystem_IsCursorOverInteractableWidget, ReturnValue) == 0x000000, "Member 'AnalogCursorSubsystem_IsCursorOverInteractableWidget::ReturnValue' has a wrong offset!");

// Function DeceiveInc.AnalogCursorSubsystem.IsCursorValid
// 0x0001 (0x0001 - 0x0000)
struct AnalogCursorSubsystem_IsCursorValid final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnalogCursorSubsystem_IsCursorValid) == 0x000001, "Wrong alignment on AnalogCursorSubsystem_IsCursorValid");
static_assert(sizeof(AnalogCursorSubsystem_IsCursorValid) == 0x000001, "Wrong size on AnalogCursorSubsystem_IsCursorValid");
static_assert(offsetof(AnalogCursorSubsystem_IsCursorValid, ReturnValue) == 0x000000, "Member 'AnalogCursorSubsystem_IsCursorValid::ReturnValue' has a wrong offset!");

// Function DeceiveInc.AnnouncementSubsystem.ClearAnnouncementGroup
// 0x0010 (0x0010 - 0x0000)
struct AnnouncementSubsystem_ClearAnnouncementGroup final
{
public:
	class AActor*                                 CallerActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnnouncementGroup                            Group;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnnouncementSubsystem_ClearAnnouncementGroup) == 0x000008, "Wrong alignment on AnnouncementSubsystem_ClearAnnouncementGroup");
static_assert(sizeof(AnnouncementSubsystem_ClearAnnouncementGroup) == 0x000010, "Wrong size on AnnouncementSubsystem_ClearAnnouncementGroup");
static_assert(offsetof(AnnouncementSubsystem_ClearAnnouncementGroup, CallerActor) == 0x000000, "Member 'AnnouncementSubsystem_ClearAnnouncementGroup::CallerActor' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_ClearAnnouncementGroup, Group) == 0x000008, "Member 'AnnouncementSubsystem_ClearAnnouncementGroup::Group' has a wrong offset!");

// Function DeceiveInc.AnnouncementSubsystem.ConfirmAnnouncementHidden
// 0x0010 (0x0010 - 0x0000)
struct AnnouncementSubsystem_ConfirmAnnouncementHidden final
{
public:
	class AActor*                                 CallerActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnnouncementInstanceID;                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnnouncementSubsystem_ConfirmAnnouncementHidden) == 0x000008, "Wrong alignment on AnnouncementSubsystem_ConfirmAnnouncementHidden");
static_assert(sizeof(AnnouncementSubsystem_ConfirmAnnouncementHidden) == 0x000010, "Wrong size on AnnouncementSubsystem_ConfirmAnnouncementHidden");
static_assert(offsetof(AnnouncementSubsystem_ConfirmAnnouncementHidden, CallerActor) == 0x000000, "Member 'AnnouncementSubsystem_ConfirmAnnouncementHidden::CallerActor' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_ConfirmAnnouncementHidden, AnnouncementInstanceID) == 0x000008, "Member 'AnnouncementSubsystem_ConfirmAnnouncementHidden::AnnouncementInstanceID' has a wrong offset!");

// Function DeceiveInc.AnnouncementSubsystem.ShowAnnouncement
// 0x0030 (0x0030 - 0x0000)
struct AnnouncementSubsystem_ShowAnnouncement final
{
public:
	class AActor*                                 CallerActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TextToDisplay;                                     // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	EAnnouncementType                             AnnouncementType;                                  // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnnouncementGroup                            Group;                                             // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeQueued;                                      // 0x002C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnnouncementSubsystem_ShowAnnouncement) == 0x000008, "Wrong alignment on AnnouncementSubsystem_ShowAnnouncement");
static_assert(sizeof(AnnouncementSubsystem_ShowAnnouncement) == 0x000030, "Wrong size on AnnouncementSubsystem_ShowAnnouncement");
static_assert(offsetof(AnnouncementSubsystem_ShowAnnouncement, CallerActor) == 0x000000, "Member 'AnnouncementSubsystem_ShowAnnouncement::CallerActor' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_ShowAnnouncement, TextToDisplay) == 0x000008, "Member 'AnnouncementSubsystem_ShowAnnouncement::TextToDisplay' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_ShowAnnouncement, AnnouncementType) == 0x000020, "Member 'AnnouncementSubsystem_ShowAnnouncement::AnnouncementType' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_ShowAnnouncement, Group) == 0x000021, "Member 'AnnouncementSubsystem_ShowAnnouncement::Group' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_ShowAnnouncement, Priority) == 0x000024, "Member 'AnnouncementSubsystem_ShowAnnouncement::Priority' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_ShowAnnouncement, Duration) == 0x000028, "Member 'AnnouncementSubsystem_ShowAnnouncement::Duration' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_ShowAnnouncement, bCanBeQueued) == 0x00002C, "Member 'AnnouncementSubsystem_ShowAnnouncement::bCanBeQueued' has a wrong offset!");

// Function DeceiveInc.AnnouncementSubsystem.ShowAnnouncementWithSubText
// 0x0048 (0x0048 - 0x0000)
struct AnnouncementSubsystem_ShowAnnouncementWithSubText final
{
public:
	class AActor*                                 CallerActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TextToDisplay;                                     // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   SubTextToDisplay;                                  // 0x0020(0x0018)(Parm, NativeAccessSpecifierPublic)
	EAnnouncementType                             AnnouncementType;                                  // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnnouncementGroup                            Group;                                             // 0x0039(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeQueued;                                      // 0x0044(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnnouncementSubsystem_ShowAnnouncementWithSubText) == 0x000008, "Wrong alignment on AnnouncementSubsystem_ShowAnnouncementWithSubText");
static_assert(sizeof(AnnouncementSubsystem_ShowAnnouncementWithSubText) == 0x000048, "Wrong size on AnnouncementSubsystem_ShowAnnouncementWithSubText");
static_assert(offsetof(AnnouncementSubsystem_ShowAnnouncementWithSubText, CallerActor) == 0x000000, "Member 'AnnouncementSubsystem_ShowAnnouncementWithSubText::CallerActor' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_ShowAnnouncementWithSubText, TextToDisplay) == 0x000008, "Member 'AnnouncementSubsystem_ShowAnnouncementWithSubText::TextToDisplay' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_ShowAnnouncementWithSubText, SubTextToDisplay) == 0x000020, "Member 'AnnouncementSubsystem_ShowAnnouncementWithSubText::SubTextToDisplay' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_ShowAnnouncementWithSubText, AnnouncementType) == 0x000038, "Member 'AnnouncementSubsystem_ShowAnnouncementWithSubText::AnnouncementType' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_ShowAnnouncementWithSubText, Group) == 0x000039, "Member 'AnnouncementSubsystem_ShowAnnouncementWithSubText::Group' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_ShowAnnouncementWithSubText, Priority) == 0x00003C, "Member 'AnnouncementSubsystem_ShowAnnouncementWithSubText::Priority' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_ShowAnnouncementWithSubText, Duration) == 0x000040, "Member 'AnnouncementSubsystem_ShowAnnouncementWithSubText::Duration' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_ShowAnnouncementWithSubText, bCanBeQueued) == 0x000044, "Member 'AnnouncementSubsystem_ShowAnnouncementWithSubText::bCanBeQueued' has a wrong offset!");

// DelegateFunction DeceiveInc.AnnouncementSubsystem.OnClearAnnouncementGroupDelegate__DelegateSignature
// 0x0020 (0x0020 - 0x0000)
struct AnnouncementSubsystem_OnClearAnnouncementGroupDelegate__DelegateSignature final
{
public:
	int32                                         DisplayedAnnouncementInstanceID;                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 QueuedAnnouncementInstanceID;                      // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EAnnouncementGroup                            Group;                                             // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnnouncementSubsystem_OnClearAnnouncementGroupDelegate__DelegateSignature) == 0x000008, "Wrong alignment on AnnouncementSubsystem_OnClearAnnouncementGroupDelegate__DelegateSignature");
static_assert(sizeof(AnnouncementSubsystem_OnClearAnnouncementGroupDelegate__DelegateSignature) == 0x000020, "Wrong size on AnnouncementSubsystem_OnClearAnnouncementGroupDelegate__DelegateSignature");
static_assert(offsetof(AnnouncementSubsystem_OnClearAnnouncementGroupDelegate__DelegateSignature, DisplayedAnnouncementInstanceID) == 0x000000, "Member 'AnnouncementSubsystem_OnClearAnnouncementGroupDelegate__DelegateSignature::DisplayedAnnouncementInstanceID' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_OnClearAnnouncementGroupDelegate__DelegateSignature, QueuedAnnouncementInstanceID) == 0x000008, "Member 'AnnouncementSubsystem_OnClearAnnouncementGroupDelegate__DelegateSignature::QueuedAnnouncementInstanceID' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_OnClearAnnouncementGroupDelegate__DelegateSignature, Group) == 0x000018, "Member 'AnnouncementSubsystem_OnClearAnnouncementGroupDelegate__DelegateSignature::Group' has a wrong offset!");

// DelegateFunction DeceiveInc.AnnouncementSubsystem.OnHideAnnouncementDelegate__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct AnnouncementSubsystem_OnHideAnnouncementDelegate__DelegateSignature final
{
public:
	int32                                         AnnouncementInstanceID;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnnouncementType                             AnnouncementType;                                  // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnnouncementGroup                            Group;                                             // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnnouncementSubsystem_OnHideAnnouncementDelegate__DelegateSignature) == 0x000004, "Wrong alignment on AnnouncementSubsystem_OnHideAnnouncementDelegate__DelegateSignature");
static_assert(sizeof(AnnouncementSubsystem_OnHideAnnouncementDelegate__DelegateSignature) == 0x000008, "Wrong size on AnnouncementSubsystem_OnHideAnnouncementDelegate__DelegateSignature");
static_assert(offsetof(AnnouncementSubsystem_OnHideAnnouncementDelegate__DelegateSignature, AnnouncementInstanceID) == 0x000000, "Member 'AnnouncementSubsystem_OnHideAnnouncementDelegate__DelegateSignature::AnnouncementInstanceID' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_OnHideAnnouncementDelegate__DelegateSignature, AnnouncementType) == 0x000004, "Member 'AnnouncementSubsystem_OnHideAnnouncementDelegate__DelegateSignature::AnnouncementType' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_OnHideAnnouncementDelegate__DelegateSignature, Group) == 0x000005, "Member 'AnnouncementSubsystem_OnHideAnnouncementDelegate__DelegateSignature::Group' has a wrong offset!");

// DelegateFunction DeceiveInc.AnnouncementSubsystem.OnShowAnnouncementDelegate__DelegateSignature
// 0x0040 (0x0040 - 0x0000)
struct AnnouncementSubsystem_OnShowAnnouncementDelegate__DelegateSignature final
{
public:
	int32                                         AnnouncementInstanceID;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TextToDisplay;                                     // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   SubTextToDisplay;                                  // 0x0020(0x0018)(Parm, NativeAccessSpecifierPublic)
	EAnnouncementType                             AnnouncementType;                                  // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnnouncementGroup                            Group;                                             // 0x0039(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnnouncementSubsystem_OnShowAnnouncementDelegate__DelegateSignature) == 0x000008, "Wrong alignment on AnnouncementSubsystem_OnShowAnnouncementDelegate__DelegateSignature");
static_assert(sizeof(AnnouncementSubsystem_OnShowAnnouncementDelegate__DelegateSignature) == 0x000040, "Wrong size on AnnouncementSubsystem_OnShowAnnouncementDelegate__DelegateSignature");
static_assert(offsetof(AnnouncementSubsystem_OnShowAnnouncementDelegate__DelegateSignature, AnnouncementInstanceID) == 0x000000, "Member 'AnnouncementSubsystem_OnShowAnnouncementDelegate__DelegateSignature::AnnouncementInstanceID' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_OnShowAnnouncementDelegate__DelegateSignature, TextToDisplay) == 0x000008, "Member 'AnnouncementSubsystem_OnShowAnnouncementDelegate__DelegateSignature::TextToDisplay' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_OnShowAnnouncementDelegate__DelegateSignature, SubTextToDisplay) == 0x000020, "Member 'AnnouncementSubsystem_OnShowAnnouncementDelegate__DelegateSignature::SubTextToDisplay' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_OnShowAnnouncementDelegate__DelegateSignature, AnnouncementType) == 0x000038, "Member 'AnnouncementSubsystem_OnShowAnnouncementDelegate__DelegateSignature::AnnouncementType' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_OnShowAnnouncementDelegate__DelegateSignature, Group) == 0x000039, "Member 'AnnouncementSubsystem_OnShowAnnouncementDelegate__DelegateSignature::Group' has a wrong offset!");
static_assert(offsetof(AnnouncementSubsystem_OnShowAnnouncementDelegate__DelegateSignature, Duration) == 0x00003C, "Member 'AnnouncementSubsystem_OnShowAnnouncementDelegate__DelegateSignature::Duration' has a wrong offset!");

// Function DeceiveInc.DiMenuPageUserWidget.BP_OnGotoMenuCommand
// 0x0010 (0x0010 - 0x0000)
struct DiMenuPageUserWidget_BP_OnGotoMenuCommand final
{
public:
	TArray<class FString>                         CommandParams;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiMenuPageUserWidget_BP_OnGotoMenuCommand) == 0x000008, "Wrong alignment on DiMenuPageUserWidget_BP_OnGotoMenuCommand");
static_assert(sizeof(DiMenuPageUserWidget_BP_OnGotoMenuCommand) == 0x000010, "Wrong size on DiMenuPageUserWidget_BP_OnGotoMenuCommand");
static_assert(offsetof(DiMenuPageUserWidget_BP_OnGotoMenuCommand, CommandParams) == 0x000000, "Member 'DiMenuPageUserWidget_BP_OnGotoMenuCommand::CommandParams' has a wrong offset!");

// Function DeceiveInc.DiMenuPageUserWidget.GetDefaultFocusWidget
// 0x0008 (0x0008 - 0x0000)
struct DiMenuPageUserWidget_GetDefaultFocusWidget final
{
public:
	class UWidget*                                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiMenuPageUserWidget_GetDefaultFocusWidget) == 0x000008, "Wrong alignment on DiMenuPageUserWidget_GetDefaultFocusWidget");
static_assert(sizeof(DiMenuPageUserWidget_GetDefaultFocusWidget) == 0x000008, "Wrong size on DiMenuPageUserWidget_GetDefaultFocusWidget");
static_assert(offsetof(DiMenuPageUserWidget_GetDefaultFocusWidget, ReturnValue) == 0x000000, "Member 'DiMenuPageUserWidget_GetDefaultFocusWidget::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiMenuPageUserWidget.HandleGOTOMENUCommandAction
// 0x0010 (0x0010 - 0x0000)
struct DiMenuPageUserWidget_HandleGOTOMENUCommandAction final
{
public:
	TArray<class FString>                         CommandParams;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiMenuPageUserWidget_HandleGOTOMENUCommandAction) == 0x000008, "Wrong alignment on DiMenuPageUserWidget_HandleGOTOMENUCommandAction");
static_assert(sizeof(DiMenuPageUserWidget_HandleGOTOMENUCommandAction) == 0x000010, "Wrong size on DiMenuPageUserWidget_HandleGOTOMENUCommandAction");
static_assert(offsetof(DiMenuPageUserWidget_HandleGOTOMENUCommandAction, CommandParams) == 0x000000, "Member 'DiMenuPageUserWidget_HandleGOTOMENUCommandAction::CommandParams' has a wrong offset!");

// Function DeceiveInc.DiMenuPageUserWidget.SetAsDefaultFocusWidget
// 0x0008 (0x0008 - 0x0000)
struct DiMenuPageUserWidget_SetAsDefaultFocusWidget final
{
public:
	class UWidget*                                DefaultFocus;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiMenuPageUserWidget_SetAsDefaultFocusWidget) == 0x000008, "Wrong alignment on DiMenuPageUserWidget_SetAsDefaultFocusWidget");
static_assert(sizeof(DiMenuPageUserWidget_SetAsDefaultFocusWidget) == 0x000008, "Wrong size on DiMenuPageUserWidget_SetAsDefaultFocusWidget");
static_assert(offsetof(DiMenuPageUserWidget_SetAsDefaultFocusWidget, DefaultFocus) == 0x000000, "Member 'DiMenuPageUserWidget_SetAsDefaultFocusWidget::DefaultFocus' has a wrong offset!");

// Function DeceiveInc.DiCharacterMenuPageUserWidget.BP_OnSelectCharacterRequest
// 0x0008 (0x0008 - 0x0000)
struct DiCharacterMenuPageUserWidget_BP_OnSelectCharacterRequest final
{
public:
	const class UAgentData*                       AgentToSelect;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiCharacterMenuPageUserWidget_BP_OnSelectCharacterRequest) == 0x000008, "Wrong alignment on DiCharacterMenuPageUserWidget_BP_OnSelectCharacterRequest");
static_assert(sizeof(DiCharacterMenuPageUserWidget_BP_OnSelectCharacterRequest) == 0x000008, "Wrong size on DiCharacterMenuPageUserWidget_BP_OnSelectCharacterRequest");
static_assert(offsetof(DiCharacterMenuPageUserWidget_BP_OnSelectCharacterRequest, AgentToSelect) == 0x000000, "Member 'DiCharacterMenuPageUserWidget_BP_OnSelectCharacterRequest::AgentToSelect' has a wrong offset!");

// Function DeceiveInc.AOEWeaponComponent.HandleWeaponProjectileImpact
// 0x0050 (0x0050 - 0x0000)
struct AOEWeaponComponent_HandleWeaponProjectileImpact final
{
public:
	struct FWeaponImpactData                      WeaponImpactData;                                  // 0x0000(0x0050)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(AOEWeaponComponent_HandleWeaponProjectileImpact) == 0x000008, "Wrong alignment on AOEWeaponComponent_HandleWeaponProjectileImpact");
static_assert(sizeof(AOEWeaponComponent_HandleWeaponProjectileImpact) == 0x000050, "Wrong size on AOEWeaponComponent_HandleWeaponProjectileImpact");
static_assert(offsetof(AOEWeaponComponent_HandleWeaponProjectileImpact, WeaponImpactData) == 0x000000, "Member 'AOEWeaponComponent_HandleWeaponProjectileImpact::WeaponImpactData' has a wrong offset!");

// Function DeceiveInc.AOEWeaponComponent.Server_AOEDamage
// 0x0050 (0x0050 - 0x0000)
struct AOEWeaponComponent_Server_AOEDamage final
{
public:
	struct FWeaponImpactData                      WeaponImpactData;                                  // 0x0000(0x0050)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(AOEWeaponComponent_Server_AOEDamage) == 0x000008, "Wrong alignment on AOEWeaponComponent_Server_AOEDamage");
static_assert(sizeof(AOEWeaponComponent_Server_AOEDamage) == 0x000050, "Wrong size on AOEWeaponComponent_Server_AOEDamage");
static_assert(offsetof(AOEWeaponComponent_Server_AOEDamage, WeaponImpactData) == 0x000000, "Member 'AOEWeaponComponent_Server_AOEDamage::WeaponImpactData' has a wrong offset!");

// Function DeceiveInc.AttachToSpyComponent.HandleCoverChanged
// 0x0008 (0x0008 - 0x0000)
struct AttachToSpyComponent_HandleCoverChanged final
{
public:
	class ANPCCharacter*                          Disguise;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttachToSpyComponent_HandleCoverChanged) == 0x000008, "Wrong alignment on AttachToSpyComponent_HandleCoverChanged");
static_assert(sizeof(AttachToSpyComponent_HandleCoverChanged) == 0x000008, "Wrong size on AttachToSpyComponent_HandleCoverChanged");
static_assert(offsetof(AttachToSpyComponent_HandleCoverChanged, Disguise) == 0x000000, "Member 'AttachToSpyComponent_HandleCoverChanged::Disguise' has a wrong offset!");

// Function DeceiveInc.AttachToSpyComponent.HandleMimicChanged
// 0x0008 (0x0008 - 0x0000)
struct AttachToSpyComponent_HandleMimicChanged final
{
public:
	class ABaseMimicScannableActor*               NewMimic;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttachToSpyComponent_HandleMimicChanged) == 0x000008, "Wrong alignment on AttachToSpyComponent_HandleMimicChanged");
static_assert(sizeof(AttachToSpyComponent_HandleMimicChanged) == 0x000008, "Wrong size on AttachToSpyComponent_HandleMimicChanged");
static_assert(offsetof(AttachToSpyComponent_HandleMimicChanged, NewMimic) == 0x000000, "Member 'AttachToSpyComponent_HandleMimicChanged::NewMimic' has a wrong offset!");

// Function DeceiveInc.AttachToSpyComponent.HandleResourceChanged
// 0x0028 (0x0028 - 0x0000)
struct AttachToSpyComponent_HandleResourceChanged final
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ResourceDisplayName;                               // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AttachToSpyComponent_HandleResourceChanged) == 0x000008, "Wrong alignment on AttachToSpyComponent_HandleResourceChanged");
static_assert(sizeof(AttachToSpyComponent_HandleResourceChanged) == 0x000028, "Wrong size on AttachToSpyComponent_HandleResourceChanged");
static_assert(offsetof(AttachToSpyComponent_HandleResourceChanged, ResourceType) == 0x000000, "Member 'AttachToSpyComponent_HandleResourceChanged::ResourceType' has a wrong offset!");
static_assert(offsetof(AttachToSpyComponent_HandleResourceChanged, ResourceDisplayName) == 0x000008, "Member 'AttachToSpyComponent_HandleResourceChanged::ResourceDisplayName' has a wrong offset!");
static_assert(offsetof(AttachToSpyComponent_HandleResourceChanged, Amount) == 0x000020, "Member 'AttachToSpyComponent_HandleResourceChanged::Amount' has a wrong offset!");

// Function DeceiveInc.AttachToSpyComponent.HandleUnderCoverChanged
// 0x0001 (0x0001 - 0x0000)
struct AttachToSpyComponent_HandleUnderCoverChanged final
{
public:
	bool                                          IsUndercover;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttachToSpyComponent_HandleUnderCoverChanged) == 0x000001, "Wrong alignment on AttachToSpyComponent_HandleUnderCoverChanged");
static_assert(sizeof(AttachToSpyComponent_HandleUnderCoverChanged) == 0x000001, "Wrong size on AttachToSpyComponent_HandleUnderCoverChanged");
static_assert(offsetof(AttachToSpyComponent_HandleUnderCoverChanged, IsUndercover) == 0x000000, "Member 'AttachToSpyComponent_HandleUnderCoverChanged::IsUndercover' has a wrong offset!");

// Function DeceiveInc.AttachToSpyComponent.HandleVisibilityChanged
// 0x0001 (0x0001 - 0x0000)
struct AttachToSpyComponent_HandleVisibilityChanged final
{
public:
	bool                                          bIs1P;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttachToSpyComponent_HandleVisibilityChanged) == 0x000001, "Wrong alignment on AttachToSpyComponent_HandleVisibilityChanged");
static_assert(sizeof(AttachToSpyComponent_HandleVisibilityChanged) == 0x000001, "Wrong size on AttachToSpyComponent_HandleVisibilityChanged");
static_assert(offsetof(AttachToSpyComponent_HandleVisibilityChanged, bIs1P) == 0x000000, "Member 'AttachToSpyComponent_HandleVisibilityChanged::bIs1P' has a wrong offset!");

// Function DeceiveInc.InteractionIconComponent.GetTooltipText
// 0x0018 (0x0018 - 0x0000)
struct InteractionIconComponent_GetTooltipText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractionIconComponent_GetTooltipText) == 0x000008, "Wrong alignment on InteractionIconComponent_GetTooltipText");
static_assert(sizeof(InteractionIconComponent_GetTooltipText) == 0x000018, "Wrong size on InteractionIconComponent_GetTooltipText");
static_assert(offsetof(InteractionIconComponent_GetTooltipText, ReturnValue) == 0x000000, "Member 'InteractionIconComponent_GetTooltipText::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteractionIconComponent.SetEnabled
// 0x0001 (0x0001 - 0x0000)
struct InteractionIconComponent_SetEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractionIconComponent_SetEnabled) == 0x000001, "Wrong alignment on InteractionIconComponent_SetEnabled");
static_assert(sizeof(InteractionIconComponent_SetEnabled) == 0x000001, "Wrong size on InteractionIconComponent_SetEnabled");
static_assert(offsetof(InteractionIconComponent_SetEnabled, bEnabled) == 0x000000, "Member 'InteractionIconComponent_SetEnabled::bEnabled' has a wrong offset!");

// Function DeceiveInc.InteractionIconComponent.SetEnabledLocal
// 0x0001 (0x0001 - 0x0000)
struct InteractionIconComponent_SetEnabledLocal final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractionIconComponent_SetEnabledLocal) == 0x000001, "Wrong alignment on InteractionIconComponent_SetEnabledLocal");
static_assert(sizeof(InteractionIconComponent_SetEnabledLocal) == 0x000001, "Wrong size on InteractionIconComponent_SetEnabledLocal");
static_assert(offsetof(InteractionIconComponent_SetEnabledLocal, bEnabled) == 0x000000, "Member 'InteractionIconComponent_SetEnabledLocal::bEnabled' has a wrong offset!");

// Function DeceiveInc.InteractionIconComponent.SetToolTipText
// 0x0018 (0x0018 - 0x0000)
struct InteractionIconComponent_SetToolTipText final
{
public:
	class FText                                   NewText;                                           // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractionIconComponent_SetToolTipText) == 0x000008, "Wrong alignment on InteractionIconComponent_SetToolTipText");
static_assert(sizeof(InteractionIconComponent_SetToolTipText) == 0x000018, "Wrong size on InteractionIconComponent_SetToolTipText");
static_assert(offsetof(InteractionIconComponent_SetToolTipText, NewText) == 0x000000, "Member 'InteractionIconComponent_SetToolTipText::NewText' has a wrong offset!");

// Function DeceiveInc.InteractionIconComponent.StartInteraction
// 0x0010 (0x0010 - 0x0000)
struct InteractionIconComponent_StartInteraction final
{
public:
	float                                         PercentToSet;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UProgressBar*                           ProgressBar;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractionIconComponent_StartInteraction) == 0x000008, "Wrong alignment on InteractionIconComponent_StartInteraction");
static_assert(sizeof(InteractionIconComponent_StartInteraction) == 0x000010, "Wrong size on InteractionIconComponent_StartInteraction");
static_assert(offsetof(InteractionIconComponent_StartInteraction, PercentToSet) == 0x000000, "Member 'InteractionIconComponent_StartInteraction::PercentToSet' has a wrong offset!");
static_assert(offsetof(InteractionIconComponent_StartInteraction, ProgressBar) == 0x000008, "Member 'InteractionIconComponent_StartInteraction::ProgressBar' has a wrong offset!");

// Function DeceiveInc.InteractionIconComponent.StopInteraction
// 0x0004 (0x0004 - 0x0000)
struct InteractionIconComponent_StopInteraction final
{
public:
	float                                         PercentToSet;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractionIconComponent_StopInteraction) == 0x000004, "Wrong alignment on InteractionIconComponent_StopInteraction");
static_assert(sizeof(InteractionIconComponent_StopInteraction) == 0x000004, "Wrong size on InteractionIconComponent_StopInteraction");
static_assert(offsetof(InteractionIconComponent_StopInteraction, PercentToSet) == 0x000000, "Member 'InteractionIconComponent_StopInteraction::PercentToSet' has a wrong offset!");

// Function DeceiveInc.InteractionIconComponent.GetInteractionIconState
// 0x0001 (0x0001 - 0x0000)
struct InteractionIconComponent_GetInteractionIconState final
{
public:
	EInteractionIconState                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractionIconComponent_GetInteractionIconState) == 0x000001, "Wrong alignment on InteractionIconComponent_GetInteractionIconState");
static_assert(sizeof(InteractionIconComponent_GetInteractionIconState) == 0x000001, "Wrong size on InteractionIconComponent_GetInteractionIconState");
static_assert(offsetof(InteractionIconComponent_GetInteractionIconState, ReturnValue) == 0x000000, "Member 'InteractionIconComponent_GetInteractionIconState::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteractionIconComponent.IsEnabled
// 0x0001 (0x0001 - 0x0000)
struct InteractionIconComponent_IsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractionIconComponent_IsEnabled) == 0x000001, "Wrong alignment on InteractionIconComponent_IsEnabled");
static_assert(sizeof(InteractionIconComponent_IsEnabled) == 0x000001, "Wrong size on InteractionIconComponent_IsEnabled");
static_assert(offsetof(InteractionIconComponent_IsEnabled, ReturnValue) == 0x000000, "Member 'InteractionIconComponent_IsEnabled::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuUserWidget.BP_OnCustomActionTriggered
// 0x0010 (0x0010 - 0x0000)
struct DIMenuUserWidget_BP_OnCustomActionTriggered final
{
public:
	const class UInputAction*                     TriggeredAction;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIMenuUserWidget_BP_OnCustomActionTriggered) == 0x000008, "Wrong alignment on DIMenuUserWidget_BP_OnCustomActionTriggered");
static_assert(sizeof(DIMenuUserWidget_BP_OnCustomActionTriggered) == 0x000010, "Wrong size on DIMenuUserWidget_BP_OnCustomActionTriggered");
static_assert(offsetof(DIMenuUserWidget_BP_OnCustomActionTriggered, TriggeredAction) == 0x000000, "Member 'DIMenuUserWidget_BP_OnCustomActionTriggered::TriggeredAction' has a wrong offset!");
static_assert(offsetof(DIMenuUserWidget_BP_OnCustomActionTriggered, Value) == 0x000008, "Member 'DIMenuUserWidget_BP_OnCustomActionTriggered::Value' has a wrong offset!");

// Function DeceiveInc.DIMenuUserWidget.BP_OnGotoMenuCommand
// 0x0010 (0x0010 - 0x0000)
struct DIMenuUserWidget_BP_OnGotoMenuCommand final
{
public:
	TArray<class FString>                         CommandParams;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuUserWidget_BP_OnGotoMenuCommand) == 0x000008, "Wrong alignment on DIMenuUserWidget_BP_OnGotoMenuCommand");
static_assert(sizeof(DIMenuUserWidget_BP_OnGotoMenuCommand) == 0x000010, "Wrong size on DIMenuUserWidget_BP_OnGotoMenuCommand");
static_assert(offsetof(DIMenuUserWidget_BP_OnGotoMenuCommand, CommandParams) == 0x000000, "Member 'DIMenuUserWidget_BP_OnGotoMenuCommand::CommandParams' has a wrong offset!");

// Function DeceiveInc.DIMenuUserWidget.DisplayMenuPage
// 0x0004 (0x0004 - 0x0000)
struct DIMenuUserWidget_DisplayMenuPage final
{
public:
	int32                                         PageIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuUserWidget_DisplayMenuPage) == 0x000004, "Wrong alignment on DIMenuUserWidget_DisplayMenuPage");
static_assert(sizeof(DIMenuUserWidget_DisplayMenuPage) == 0x000004, "Wrong size on DIMenuUserWidget_DisplayMenuPage");
static_assert(offsetof(DIMenuUserWidget_DisplayMenuPage, PageIndex) == 0x000000, "Member 'DIMenuUserWidget_DisplayMenuPage::PageIndex' has a wrong offset!");

// Function DeceiveInc.DIMenuUserWidget.GetMenuPageNavigation
// 0x0008 (0x0008 - 0x0000)
struct DIMenuUserWidget_GetMenuPageNavigation final
{
public:
	class UDiMenuPageNavigationWidget*            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuUserWidget_GetMenuPageNavigation) == 0x000008, "Wrong alignment on DIMenuUserWidget_GetMenuPageNavigation");
static_assert(sizeof(DIMenuUserWidget_GetMenuPageNavigation) == 0x000008, "Wrong size on DIMenuUserWidget_GetMenuPageNavigation");
static_assert(offsetof(DIMenuUserWidget_GetMenuPageNavigation, ReturnValue) == 0x000000, "Member 'DIMenuUserWidget_GetMenuPageNavigation::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuUserWidget.GetMenuSwitcher
// 0x0008 (0x0008 - 0x0000)
struct DIMenuUserWidget_GetMenuSwitcher final
{
public:
	class UWidgetSwitcher*                        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuUserWidget_GetMenuSwitcher) == 0x000008, "Wrong alignment on DIMenuUserWidget_GetMenuSwitcher");
static_assert(sizeof(DIMenuUserWidget_GetMenuSwitcher) == 0x000008, "Wrong size on DIMenuUserWidget_GetMenuSwitcher");
static_assert(offsetof(DIMenuUserWidget_GetMenuSwitcher, ReturnValue) == 0x000000, "Member 'DIMenuUserWidget_GetMenuSwitcher::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuUserWidget.HandleGOTOMENUCommandAction
// 0x0010 (0x0010 - 0x0000)
struct DIMenuUserWidget_HandleGOTOMENUCommandAction final
{
public:
	TArray<class FString>                         CommandParams;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuUserWidget_HandleGOTOMENUCommandAction) == 0x000008, "Wrong alignment on DIMenuUserWidget_HandleGOTOMENUCommandAction");
static_assert(sizeof(DIMenuUserWidget_HandleGOTOMENUCommandAction) == 0x000010, "Wrong size on DIMenuUserWidget_HandleGOTOMENUCommandAction");
static_assert(offsetof(DIMenuUserWidget_HandleGOTOMENUCommandAction, CommandParams) == 0x000000, "Member 'DIMenuUserWidget_HandleGOTOMENUCommandAction::CommandParams' has a wrong offset!");

// Function DeceiveInc.DIMenuUserWidget.HandlePhaseTick
// 0x0004 (0x0004 - 0x0000)
struct DIMenuUserWidget_HandlePhaseTick final
{
public:
	int32                                         TimeRemainingInSeconds;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuUserWidget_HandlePhaseTick) == 0x000004, "Wrong alignment on DIMenuUserWidget_HandlePhaseTick");
static_assert(sizeof(DIMenuUserWidget_HandlePhaseTick) == 0x000004, "Wrong size on DIMenuUserWidget_HandlePhaseTick");
static_assert(offsetof(DIMenuUserWidget_HandlePhaseTick, TimeRemainingInSeconds) == 0x000000, "Member 'DIMenuUserWidget_HandlePhaseTick::TimeRemainingInSeconds' has a wrong offset!");

// Function DeceiveInc.DIMenuUserWidget.SetMenuName
// 0x0008 (0x0008 - 0x0000)
struct DIMenuUserWidget_SetMenuName final
{
public:
	class FName                                   InMenuName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuUserWidget_SetMenuName) == 0x000004, "Wrong alignment on DIMenuUserWidget_SetMenuName");
static_assert(sizeof(DIMenuUserWidget_SetMenuName) == 0x000008, "Wrong size on DIMenuUserWidget_SetMenuName");
static_assert(offsetof(DIMenuUserWidget_SetMenuName, InMenuName) == 0x000000, "Member 'DIMenuUserWidget_SetMenuName::InMenuName' has a wrong offset!");

// Function DeceiveInc.DIMenuUserWidget.GetMenuName
// 0x0008 (0x0008 - 0x0000)
struct DIMenuUserWidget_GetMenuName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuUserWidget_GetMenuName) == 0x000004, "Wrong alignment on DIMenuUserWidget_GetMenuName");
static_assert(sizeof(DIMenuUserWidget_GetMenuName) == 0x000008, "Wrong size on DIMenuUserWidget_GetMenuName");
static_assert(offsetof(DIMenuUserWidget_GetMenuName, ReturnValue) == 0x000000, "Member 'DIMenuUserWidget_GetMenuName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuUserWidget.IsMenuShown
// 0x0001 (0x0001 - 0x0000)
struct DIMenuUserWidget_IsMenuShown final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuUserWidget_IsMenuShown) == 0x000001, "Wrong alignment on DIMenuUserWidget_IsMenuShown");
static_assert(sizeof(DIMenuUserWidget_IsMenuShown) == 0x000001, "Wrong size on DIMenuUserWidget_IsMenuShown");
static_assert(offsetof(DIMenuUserWidget_IsMenuShown, ReturnValue) == 0x000000, "Member 'DIMenuUserWidget_IsMenuShown::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuStoreShowcaseWidget.BP_ShowItemInMenu
// 0x0008 (0x0008 - 0x0000)
struct DIMenuStoreShowcaseWidget_BP_ShowItemInMenu final
{
public:
	class UDIItem*                                NewItem;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuStoreShowcaseWidget_BP_ShowItemInMenu) == 0x000008, "Wrong alignment on DIMenuStoreShowcaseWidget_BP_ShowItemInMenu");
static_assert(sizeof(DIMenuStoreShowcaseWidget_BP_ShowItemInMenu) == 0x000008, "Wrong size on DIMenuStoreShowcaseWidget_BP_ShowItemInMenu");
static_assert(offsetof(DIMenuStoreShowcaseWidget_BP_ShowItemInMenu, NewItem) == 0x000000, "Member 'DIMenuStoreShowcaseWidget_BP_ShowItemInMenu::NewItem' has a wrong offset!");

// Function DeceiveInc.DIMenuStoreShowcaseWidget.PrepareItemShowcase
// 0x0008 (0x0008 - 0x0000)
struct DIMenuStoreShowcaseWidget_PrepareItemShowcase final
{
public:
	class UDIItem*                                ShowcaseItem;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuStoreShowcaseWidget_PrepareItemShowcase) == 0x000008, "Wrong alignment on DIMenuStoreShowcaseWidget_PrepareItemShowcase");
static_assert(sizeof(DIMenuStoreShowcaseWidget_PrepareItemShowcase) == 0x000008, "Wrong size on DIMenuStoreShowcaseWidget_PrepareItemShowcase");
static_assert(offsetof(DIMenuStoreShowcaseWidget_PrepareItemShowcase, ShowcaseItem) == 0x000000, "Member 'DIMenuStoreShowcaseWidget_PrepareItemShowcase::ShowcaseItem' has a wrong offset!");

// Function DeceiveInc.AYumiPassiveAbilityMod1_2.HandleHitConfirmed
// 0x0040 (0x0040 - 0x0000)
struct AYumiPassiveAbilityMod1_2_HandleHitConfirmed final
{
public:
	struct FHitConfirmData                        HitConfirmData;                                    // 0x0000(0x0040)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(AYumiPassiveAbilityMod1_2_HandleHitConfirmed) == 0x000008, "Wrong alignment on AYumiPassiveAbilityMod1_2_HandleHitConfirmed");
static_assert(sizeof(AYumiPassiveAbilityMod1_2_HandleHitConfirmed) == 0x000040, "Wrong size on AYumiPassiveAbilityMod1_2_HandleHitConfirmed");
static_assert(offsetof(AYumiPassiveAbilityMod1_2_HandleHitConfirmed, HitConfirmData) == 0x000000, "Member 'AYumiPassiveAbilityMod1_2_HandleHitConfirmed::HitConfirmData' has a wrong offset!");

// Function DeceiveInc.AYumiPassiveAbilityMod1_2.HandleMeleeDamageConfirmed
// 0x0068 (0x0068 - 0x0000)
struct AYumiPassiveAbilityMod1_2_HandleMeleeDamageConfirmed final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPoint;                                       // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChargeLevel;                                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageDone;                                        // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultingHealthPercentage;                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitType                                      HitType;                                           // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMeleeHitConfirmedData                 HitConfirmedData;                                  // 0x0028(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(AYumiPassiveAbilityMod1_2_HandleMeleeDamageConfirmed) == 0x000008, "Wrong alignment on AYumiPassiveAbilityMod1_2_HandleMeleeDamageConfirmed");
static_assert(sizeof(AYumiPassiveAbilityMod1_2_HandleMeleeDamageConfirmed) == 0x000068, "Wrong size on AYumiPassiveAbilityMod1_2_HandleMeleeDamageConfirmed");
static_assert(offsetof(AYumiPassiveAbilityMod1_2_HandleMeleeDamageConfirmed, Victim) == 0x000000, "Member 'AYumiPassiveAbilityMod1_2_HandleMeleeDamageConfirmed::Victim' has a wrong offset!");
static_assert(offsetof(AYumiPassiveAbilityMod1_2_HandleMeleeDamageConfirmed, ImpactPoint) == 0x000008, "Member 'AYumiPassiveAbilityMod1_2_HandleMeleeDamageConfirmed::ImpactPoint' has a wrong offset!");
static_assert(offsetof(AYumiPassiveAbilityMod1_2_HandleMeleeDamageConfirmed, ChargeLevel) == 0x000014, "Member 'AYumiPassiveAbilityMod1_2_HandleMeleeDamageConfirmed::ChargeLevel' has a wrong offset!");
static_assert(offsetof(AYumiPassiveAbilityMod1_2_HandleMeleeDamageConfirmed, DamageDone) == 0x000018, "Member 'AYumiPassiveAbilityMod1_2_HandleMeleeDamageConfirmed::DamageDone' has a wrong offset!");
static_assert(offsetof(AYumiPassiveAbilityMod1_2_HandleMeleeDamageConfirmed, ResultingHealthPercentage) == 0x00001C, "Member 'AYumiPassiveAbilityMod1_2_HandleMeleeDamageConfirmed::ResultingHealthPercentage' has a wrong offset!");
static_assert(offsetof(AYumiPassiveAbilityMod1_2_HandleMeleeDamageConfirmed, HitType) == 0x000020, "Member 'AYumiPassiveAbilityMod1_2_HandleMeleeDamageConfirmed::HitType' has a wrong offset!");
static_assert(offsetof(AYumiPassiveAbilityMod1_2_HandleMeleeDamageConfirmed, HitConfirmedData) == 0x000028, "Member 'AYumiPassiveAbilityMod1_2_HandleMeleeDamageConfirmed::HitConfirmedData' has a wrong offset!");

// Function DeceiveInc.AYumiPassiveAbilityMod1_2.HandleSpyToolLoadComplete
// 0x0008 (0x0008 - 0x0000)
struct AYumiPassiveAbilityMod1_2_HandleSpyToolLoadComplete final
{
public:
	class UToolLoadoutComponent*                  ToolLoadout;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AYumiPassiveAbilityMod1_2_HandleSpyToolLoadComplete) == 0x000008, "Wrong alignment on AYumiPassiveAbilityMod1_2_HandleSpyToolLoadComplete");
static_assert(sizeof(AYumiPassiveAbilityMod1_2_HandleSpyToolLoadComplete) == 0x000008, "Wrong size on AYumiPassiveAbilityMod1_2_HandleSpyToolLoadComplete");
static_assert(offsetof(AYumiPassiveAbilityMod1_2_HandleSpyToolLoadComplete, ToolLoadout) == 0x000000, "Member 'AYumiPassiveAbilityMod1_2_HandleSpyToolLoadComplete::ToolLoadout' has a wrong offset!");

// Function DeceiveInc.BaseAoEActor.BP_OnAoEUpdateInterval
// 0x0020 (0x0020 - 0x0000)
struct BaseAoEActor_BP_OnAoEUpdateInterval final
{
public:
	TArray<class AActor*>                         AddedActors;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         RemovedActors;                                     // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseAoEActor_BP_OnAoEUpdateInterval) == 0x000008, "Wrong alignment on BaseAoEActor_BP_OnAoEUpdateInterval");
static_assert(sizeof(BaseAoEActor_BP_OnAoEUpdateInterval) == 0x000020, "Wrong size on BaseAoEActor_BP_OnAoEUpdateInterval");
static_assert(offsetof(BaseAoEActor_BP_OnAoEUpdateInterval, AddedActors) == 0x000000, "Member 'BaseAoEActor_BP_OnAoEUpdateInterval::AddedActors' has a wrong offset!");
static_assert(offsetof(BaseAoEActor_BP_OnAoEUpdateInterval, RemovedActors) == 0x000010, "Member 'BaseAoEActor_BP_OnAoEUpdateInterval::RemovedActors' has a wrong offset!");

// Function DeceiveInc.BaseAoEActor.EnableAoE
// 0x0001 (0x0001 - 0x0000)
struct BaseAoEActor_EnableAoE final
{
public:
	bool                                          bEnableIn;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseAoEActor_EnableAoE) == 0x000001, "Wrong alignment on BaseAoEActor_EnableAoE");
static_assert(sizeof(BaseAoEActor_EnableAoE) == 0x000001, "Wrong size on BaseAoEActor_EnableAoE");
static_assert(offsetof(BaseAoEActor_EnableAoE, bEnableIn) == 0x000000, "Member 'BaseAoEActor_EnableAoE::bEnableIn' has a wrong offset!");

// Function DeceiveInc.BaseBreadcrumbsActor.BP_OnBreacrumbStart
// 0x0010 (0x0010 - 0x0000)
struct BaseBreadcrumbsActor_BP_OnBreacrumbStart final
{
public:
	float                                         Lifetime;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewPosition;                                       // 0x0004(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseBreadcrumbsActor_BP_OnBreacrumbStart) == 0x000004, "Wrong alignment on BaseBreadcrumbsActor_BP_OnBreacrumbStart");
static_assert(sizeof(BaseBreadcrumbsActor_BP_OnBreacrumbStart) == 0x000010, "Wrong size on BaseBreadcrumbsActor_BP_OnBreacrumbStart");
static_assert(offsetof(BaseBreadcrumbsActor_BP_OnBreacrumbStart, Lifetime) == 0x000000, "Member 'BaseBreadcrumbsActor_BP_OnBreacrumbStart::Lifetime' has a wrong offset!");
static_assert(offsetof(BaseBreadcrumbsActor_BP_OnBreacrumbStart, NewPosition) == 0x000004, "Member 'BaseBreadcrumbsActor_BP_OnBreacrumbStart::NewPosition' has a wrong offset!");

// Function DeceiveInc.BaseBreadcrumbsActor.IsUsable
// 0x0001 (0x0001 - 0x0000)
struct BaseBreadcrumbsActor_IsUsable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseBreadcrumbsActor_IsUsable) == 0x000001, "Wrong alignment on BaseBreadcrumbsActor_IsUsable");
static_assert(sizeof(BaseBreadcrumbsActor_IsUsable) == 0x000001, "Wrong size on BaseBreadcrumbsActor_IsUsable");
static_assert(offsetof(BaseBreadcrumbsActor_IsUsable, ReturnValue) == 0x000000, "Member 'BaseBreadcrumbsActor_IsUsable::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseBreadcrumbsActor.GetInteractableType
// 0x0001 (0x0001 - 0x0000)
struct BaseBreadcrumbsActor_GetInteractableType final
{
public:
	EInteractableType                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseBreadcrumbsActor_GetInteractableType) == 0x000001, "Wrong alignment on BaseBreadcrumbsActor_GetInteractableType");
static_assert(sizeof(BaseBreadcrumbsActor_GetInteractableType) == 0x000001, "Wrong size on BaseBreadcrumbsActor_GetInteractableType");
static_assert(offsetof(BaseBreadcrumbsActor_GetInteractableType, ReturnValue) == 0x000000, "Member 'BaseBreadcrumbsActor_GetInteractableType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.CheckRuleApply_Base.IsActiveForCurrentRules
// 0x0001 (0x0001 - 0x0000)
struct CheckRuleApply_Base_IsActiveForCurrentRules final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheckRuleApply_Base_IsActiveForCurrentRules) == 0x000001, "Wrong alignment on CheckRuleApply_Base_IsActiveForCurrentRules");
static_assert(sizeof(CheckRuleApply_Base_IsActiveForCurrentRules) == 0x000001, "Wrong size on CheckRuleApply_Base_IsActiveForCurrentRules");
static_assert(offsetof(CheckRuleApply_Base_IsActiveForCurrentRules, ReturnValue) == 0x000000, "Member 'CheckRuleApply_Base_IsActiveForCurrentRules::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseInteractableActor.BP_OnHiddenInContainerChange
// 0x0001 (0x0001 - 0x0000)
struct BaseInteractableActor_BP_OnHiddenInContainerChange final
{
public:
	bool                                          bNowHidden;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseInteractableActor_BP_OnHiddenInContainerChange) == 0x000001, "Wrong alignment on BaseInteractableActor_BP_OnHiddenInContainerChange");
static_assert(sizeof(BaseInteractableActor_BP_OnHiddenInContainerChange) == 0x000001, "Wrong size on BaseInteractableActor_BP_OnHiddenInContainerChange");
static_assert(offsetof(BaseInteractableActor_BP_OnHiddenInContainerChange, bNowHidden) == 0x000000, "Member 'BaseInteractableActor_BP_OnHiddenInContainerChange::bNowHidden' has a wrong offset!");

// Function DeceiveInc.BaseInteractableActor.BP_OnInteractionComplete
// 0x0010 (0x0010 - 0x0000)
struct BaseInteractableActor_BP_OnInteractionComplete final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseInteractableActor_BP_OnInteractionComplete) == 0x000008, "Wrong alignment on BaseInteractableActor_BP_OnInteractionComplete");
static_assert(sizeof(BaseInteractableActor_BP_OnInteractionComplete) == 0x000010, "Wrong size on BaseInteractableActor_BP_OnInteractionComplete");
static_assert(offsetof(BaseInteractableActor_BP_OnInteractionComplete, Interacter) == 0x000000, "Member 'BaseInteractableActor_BP_OnInteractionComplete::Interacter' has a wrong offset!");
static_assert(offsetof(BaseInteractableActor_BP_OnInteractionComplete, Interactable) == 0x000008, "Member 'BaseInteractableActor_BP_OnInteractionComplete::Interactable' has a wrong offset!");

// Function DeceiveInc.BaseInteractableActor.BP_SetCanBePing
// 0x0001 (0x0001 - 0x0000)
struct BaseInteractableActor_BP_SetCanBePing final
{
public:
	bool                                          bCanBePingIn;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseInteractableActor_BP_SetCanBePing) == 0x000001, "Wrong alignment on BaseInteractableActor_BP_SetCanBePing");
static_assert(sizeof(BaseInteractableActor_BP_SetCanBePing) == 0x000001, "Wrong size on BaseInteractableActor_BP_SetCanBePing");
static_assert(offsetof(BaseInteractableActor_BP_SetCanBePing, bCanBePingIn) == 0x000000, "Member 'BaseInteractableActor_BP_SetCanBePing::bCanBePingIn' has a wrong offset!");

// Function DeceiveInc.BaseInteractableActor.HandleInteractionComplete
// 0x0010 (0x0010 - 0x0000)
struct BaseInteractableActor_HandleInteractionComplete final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseInteractableActor_HandleInteractionComplete) == 0x000008, "Wrong alignment on BaseInteractableActor_HandleInteractionComplete");
static_assert(sizeof(BaseInteractableActor_HandleInteractionComplete) == 0x000010, "Wrong size on BaseInteractableActor_HandleInteractionComplete");
static_assert(offsetof(BaseInteractableActor_HandleInteractionComplete, Interacter) == 0x000000, "Member 'BaseInteractableActor_HandleInteractionComplete::Interacter' has a wrong offset!");
static_assert(offsetof(BaseInteractableActor_HandleInteractionComplete, Interactable) == 0x000008, "Member 'BaseInteractableActor_HandleInteractionComplete::Interactable' has a wrong offset!");

// Function DeceiveInc.BaseInteractableActor.IsUsable
// 0x0001 (0x0001 - 0x0000)
struct BaseInteractableActor_IsUsable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseInteractableActor_IsUsable) == 0x000001, "Wrong alignment on BaseInteractableActor_IsUsable");
static_assert(sizeof(BaseInteractableActor_IsUsable) == 0x000001, "Wrong size on BaseInteractableActor_IsUsable");
static_assert(offsetof(BaseInteractableActor_IsUsable, ReturnValue) == 0x000000, "Member 'BaseInteractableActor_IsUsable::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseInteractableActor.SetHiddenInContainer
// 0x0002 (0x0002 - 0x0000)
struct BaseInteractableActor_SetHiddenInContainer final
{
public:
	bool                                          InHidden;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseInteractableActor_SetHiddenInContainer) == 0x000001, "Wrong alignment on BaseInteractableActor_SetHiddenInContainer");
static_assert(sizeof(BaseInteractableActor_SetHiddenInContainer) == 0x000002, "Wrong size on BaseInteractableActor_SetHiddenInContainer");
static_assert(offsetof(BaseInteractableActor_SetHiddenInContainer, InHidden) == 0x000000, "Member 'BaseInteractableActor_SetHiddenInContainer::InHidden' has a wrong offset!");
static_assert(offsetof(BaseInteractableActor_SetHiddenInContainer, ReturnValue) == 0x000001, "Member 'BaseInteractableActor_SetHiddenInContainer::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseInteractableActor.GetInteractableComponent
// 0x0008 (0x0008 - 0x0000)
struct BaseInteractableActor_GetInteractableComponent final
{
public:
	class UInteractableComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseInteractableActor_GetInteractableComponent) == 0x000008, "Wrong alignment on BaseInteractableActor_GetInteractableComponent");
static_assert(sizeof(BaseInteractableActor_GetInteractableComponent) == 0x000008, "Wrong size on BaseInteractableActor_GetInteractableComponent");
static_assert(offsetof(BaseInteractableActor_GetInteractableComponent, ReturnValue) == 0x000000, "Member 'BaseInteractableActor_GetInteractableComponent::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseInteractableActor.GetInteractableType
// 0x0001 (0x0001 - 0x0000)
struct BaseInteractableActor_GetInteractableType final
{
public:
	EInteractableType                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseInteractableActor_GetInteractableType) == 0x000001, "Wrong alignment on BaseInteractableActor_GetInteractableType");
static_assert(sizeof(BaseInteractableActor_GetInteractableType) == 0x000001, "Wrong size on BaseInteractableActor_GetInteractableType");
static_assert(offsetof(BaseInteractableActor_GetInteractableType, ReturnValue) == 0x000000, "Member 'BaseInteractableActor_GetInteractableType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteractionAuthorityComponent.NetMulticastCancelInteraction
// 0x0010 (0x0010 - 0x0000)
struct InteractionAuthorityComponent_NetMulticastCancelInteraction final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractionAuthorityComponent_NetMulticastCancelInteraction) == 0x000008, "Wrong alignment on InteractionAuthorityComponent_NetMulticastCancelInteraction");
static_assert(sizeof(InteractionAuthorityComponent_NetMulticastCancelInteraction) == 0x000010, "Wrong size on InteractionAuthorityComponent_NetMulticastCancelInteraction");
static_assert(offsetof(InteractionAuthorityComponent_NetMulticastCancelInteraction, Interacter) == 0x000000, "Member 'InteractionAuthorityComponent_NetMulticastCancelInteraction::Interacter' has a wrong offset!");
static_assert(offsetof(InteractionAuthorityComponent_NetMulticastCancelInteraction, Interactable) == 0x000008, "Member 'InteractionAuthorityComponent_NetMulticastCancelInteraction::Interactable' has a wrong offset!");

// Function DeceiveInc.InteractionAuthorityComponent.NetMulticastCompleteInteraction
// 0x0010 (0x0010 - 0x0000)
struct InteractionAuthorityComponent_NetMulticastCompleteInteraction final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractionAuthorityComponent_NetMulticastCompleteInteraction) == 0x000008, "Wrong alignment on InteractionAuthorityComponent_NetMulticastCompleteInteraction");
static_assert(sizeof(InteractionAuthorityComponent_NetMulticastCompleteInteraction) == 0x000010, "Wrong size on InteractionAuthorityComponent_NetMulticastCompleteInteraction");
static_assert(offsetof(InteractionAuthorityComponent_NetMulticastCompleteInteraction, Interacter) == 0x000000, "Member 'InteractionAuthorityComponent_NetMulticastCompleteInteraction::Interacter' has a wrong offset!");
static_assert(offsetof(InteractionAuthorityComponent_NetMulticastCompleteInteraction, Interactable) == 0x000008, "Member 'InteractionAuthorityComponent_NetMulticastCompleteInteraction::Interactable' has a wrong offset!");

// Function DeceiveInc.InteractionAuthorityComponent.NetMulticastStartInteraction
// 0x0010 (0x0010 - 0x0000)
struct InteractionAuthorityComponent_NetMulticastStartInteraction final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractionAuthorityComponent_NetMulticastStartInteraction) == 0x000008, "Wrong alignment on InteractionAuthorityComponent_NetMulticastStartInteraction");
static_assert(sizeof(InteractionAuthorityComponent_NetMulticastStartInteraction) == 0x000010, "Wrong size on InteractionAuthorityComponent_NetMulticastStartInteraction");
static_assert(offsetof(InteractionAuthorityComponent_NetMulticastStartInteraction, Interacter) == 0x000000, "Member 'InteractionAuthorityComponent_NetMulticastStartInteraction::Interacter' has a wrong offset!");
static_assert(offsetof(InteractionAuthorityComponent_NetMulticastStartInteraction, Interactable) == 0x000008, "Member 'InteractionAuthorityComponent_NetMulticastStartInteraction::Interactable' has a wrong offset!");

// Function DeceiveInc.BaseContainerActor.OnPostInitRooms
// 0x0008 (0x0008 - 0x0000)
struct BaseContainerActor_OnPostInitRooms final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseContainerActor_OnPostInitRooms) == 0x000008, "Wrong alignment on BaseContainerActor_OnPostInitRooms");
static_assert(sizeof(BaseContainerActor_OnPostInitRooms) == 0x000008, "Wrong size on BaseContainerActor_OnPostInitRooms");
static_assert(offsetof(BaseContainerActor_OnPostInitRooms, World) == 0x000000, "Member 'BaseContainerActor_OnPostInitRooms::World' has a wrong offset!");

// Function DeceiveInc.BaseContainerActor.OnRep_ContainerState
// 0x0001 (0x0001 - 0x0000)
struct BaseContainerActor_OnRep_ContainerState final
{
public:
	EContainerState                               PreviousState;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseContainerActor_OnRep_ContainerState) == 0x000001, "Wrong alignment on BaseContainerActor_OnRep_ContainerState");
static_assert(sizeof(BaseContainerActor_OnRep_ContainerState) == 0x000001, "Wrong size on BaseContainerActor_OnRep_ContainerState");
static_assert(offsetof(BaseContainerActor_OnRep_ContainerState, PreviousState) == 0x000000, "Member 'BaseContainerActor_OnRep_ContainerState::PreviousState' has a wrong offset!");

// Function DeceiveInc.BaseDispenserActor.BP_OnLocalDispenserJammed
// 0x0001 (0x0001 - 0x0000)
struct BaseDispenserActor_BP_OnLocalDispenserJammed final
{
public:
	bool                                          bIsJammed;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseDispenserActor_BP_OnLocalDispenserJammed) == 0x000001, "Wrong alignment on BaseDispenserActor_BP_OnLocalDispenserJammed");
static_assert(sizeof(BaseDispenserActor_BP_OnLocalDispenserJammed) == 0x000001, "Wrong size on BaseDispenserActor_BP_OnLocalDispenserJammed");
static_assert(offsetof(BaseDispenserActor_BP_OnLocalDispenserJammed, bIsJammed) == 0x000000, "Member 'BaseDispenserActor_BP_OnLocalDispenserJammed::bIsJammed' has a wrong offset!");

// Function DeceiveInc.BaseDoorActor.BP_IsDoorJammedForActor
// 0x0010 (0x0010 - 0x0000)
struct BaseDoorActor_BP_IsDoorJammedForActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BaseDoorActor_BP_IsDoorJammedForActor) == 0x000008, "Wrong alignment on BaseDoorActor_BP_IsDoorJammedForActor");
static_assert(sizeof(BaseDoorActor_BP_IsDoorJammedForActor) == 0x000010, "Wrong size on BaseDoorActor_BP_IsDoorJammedForActor");
static_assert(offsetof(BaseDoorActor_BP_IsDoorJammedForActor, Actor) == 0x000000, "Member 'BaseDoorActor_BP_IsDoorJammedForActor::Actor' has a wrong offset!");
static_assert(offsetof(BaseDoorActor_BP_IsDoorJammedForActor, ReturnValue) == 0x000008, "Member 'BaseDoorActor_BP_IsDoorJammedForActor::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseDoorActor.BP_OnLocalDoorJammed
// 0x0001 (0x0001 - 0x0000)
struct BaseDoorActor_BP_OnLocalDoorJammed final
{
public:
	bool                                          bIsJammed;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseDoorActor_BP_OnLocalDoorJammed) == 0x000001, "Wrong alignment on BaseDoorActor_BP_OnLocalDoorJammed");
static_assert(sizeof(BaseDoorActor_BP_OnLocalDoorJammed) == 0x000001, "Wrong size on BaseDoorActor_BP_OnLocalDoorJammed");
static_assert(offsetof(BaseDoorActor_BP_OnLocalDoorJammed, bIsJammed) == 0x000000, "Member 'BaseDoorActor_BP_OnLocalDoorJammed::bIsJammed' has a wrong offset!");

// Function DeceiveInc.BaseDoorActor.BP_OpenDoor
// 0x0010 (0x0010 - 0x0000)
struct BaseDoorActor_BP_OpenDoor final
{
public:
	class AActor*                                 ActorOpening;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValidate;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KeepOpenDuration;                                  // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseDoorActor_BP_OpenDoor) == 0x000008, "Wrong alignment on BaseDoorActor_BP_OpenDoor");
static_assert(sizeof(BaseDoorActor_BP_OpenDoor) == 0x000010, "Wrong size on BaseDoorActor_BP_OpenDoor");
static_assert(offsetof(BaseDoorActor_BP_OpenDoor, ActorOpening) == 0x000000, "Member 'BaseDoorActor_BP_OpenDoor::ActorOpening' has a wrong offset!");
static_assert(offsetof(BaseDoorActor_BP_OpenDoor, bValidate) == 0x000008, "Member 'BaseDoorActor_BP_OpenDoor::bValidate' has a wrong offset!");
static_assert(offsetof(BaseDoorActor_BP_OpenDoor, KeepOpenDuration) == 0x00000C, "Member 'BaseDoorActor_BP_OpenDoor::KeepOpenDuration' has a wrong offset!");

// Function DeceiveInc.BaseDoorActor.HandleDoorUnlocked
// 0x0004 (0x0004 - 0x0000)
struct BaseDoorActor_HandleDoorUnlocked final
{
public:
	int32                                         PlayerIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseDoorActor_HandleDoorUnlocked) == 0x000004, "Wrong alignment on BaseDoorActor_HandleDoorUnlocked");
static_assert(sizeof(BaseDoorActor_HandleDoorUnlocked) == 0x000004, "Wrong size on BaseDoorActor_HandleDoorUnlocked");
static_assert(offsetof(BaseDoorActor_HandleDoorUnlocked, PlayerIndex) == 0x000000, "Member 'BaseDoorActor_HandleDoorUnlocked::PlayerIndex' has a wrong offset!");

// Function DeceiveInc.BaseDoorActor.HandleLocalSpyResourcesNewAmount
// 0x0018 (0x0018 - 0x0000)
struct BaseDoorActor_HandleLocalSpyResourcesNewAmount final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayResourcesType                        AffectedResource;                                  // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NewResourceCount;                                  // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseDoorActor_HandleLocalSpyResourcesNewAmount) == 0x000008, "Wrong alignment on BaseDoorActor_HandleLocalSpyResourcesNewAmount");
static_assert(sizeof(BaseDoorActor_HandleLocalSpyResourcesNewAmount) == 0x000018, "Wrong size on BaseDoorActor_HandleLocalSpyResourcesNewAmount");
static_assert(offsetof(BaseDoorActor_HandleLocalSpyResourcesNewAmount, PlayerController) == 0x000000, "Member 'BaseDoorActor_HandleLocalSpyResourcesNewAmount::PlayerController' has a wrong offset!");
static_assert(offsetof(BaseDoorActor_HandleLocalSpyResourcesNewAmount, Spy) == 0x000008, "Member 'BaseDoorActor_HandleLocalSpyResourcesNewAmount::Spy' has a wrong offset!");
static_assert(offsetof(BaseDoorActor_HandleLocalSpyResourcesNewAmount, AffectedResource) == 0x000010, "Member 'BaseDoorActor_HandleLocalSpyResourcesNewAmount::AffectedResource' has a wrong offset!");
static_assert(offsetof(BaseDoorActor_HandleLocalSpyResourcesNewAmount, NewResourceCount) == 0x000014, "Member 'BaseDoorActor_HandleLocalSpyResourcesNewAmount::NewResourceCount' has a wrong offset!");

// Function DeceiveInc.BaseDoorActor.HandleResourceSpent
// 0x0010 (0x0010 - 0x0000)
struct BaseDoorActor_HandleResourceSpent final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayResourcesType                        ResourceType;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseDoorActor_HandleResourceSpent) == 0x000008, "Wrong alignment on BaseDoorActor_HandleResourceSpent");
static_assert(sizeof(BaseDoorActor_HandleResourceSpent) == 0x000010, "Wrong size on BaseDoorActor_HandleResourceSpent");
static_assert(offsetof(BaseDoorActor_HandleResourceSpent, Interacter) == 0x000000, "Member 'BaseDoorActor_HandleResourceSpent::Interacter' has a wrong offset!");
static_assert(offsetof(BaseDoorActor_HandleResourceSpent, ResourceType) == 0x000008, "Member 'BaseDoorActor_HandleResourceSpent::ResourceType' has a wrong offset!");
static_assert(offsetof(BaseDoorActor_HandleResourceSpent, Amount) == 0x00000C, "Member 'BaseDoorActor_HandleResourceSpent::Amount' has a wrong offset!");

// Function DeceiveInc.BaseDoorActor.OnRep_DoorState
// 0x0001 (0x0001 - 0x0000)
struct BaseDoorActor_OnRep_DoorState final
{
public:
	EDoorState                                    PreviousState;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseDoorActor_OnRep_DoorState) == 0x000001, "Wrong alignment on BaseDoorActor_OnRep_DoorState");
static_assert(sizeof(BaseDoorActor_OnRep_DoorState) == 0x000001, "Wrong size on BaseDoorActor_OnRep_DoorState");
static_assert(offsetof(BaseDoorActor_OnRep_DoorState, PreviousState) == 0x000000, "Member 'BaseDoorActor_OnRep_DoorState::PreviousState' has a wrong offset!");

// Function DeceiveInc.BaseDoorActor.GetSecurityLevel
// 0x0001 (0x0001 - 0x0000)
struct BaseDoorActor_GetSecurityLevel final
{
public:
	ESecurityLevel                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseDoorActor_GetSecurityLevel) == 0x000001, "Wrong alignment on BaseDoorActor_GetSecurityLevel");
static_assert(sizeof(BaseDoorActor_GetSecurityLevel) == 0x000001, "Wrong size on BaseDoorActor_GetSecurityLevel");
static_assert(offsetof(BaseDoorActor_GetSecurityLevel, ReturnValue) == 0x000000, "Member 'BaseDoorActor_GetSecurityLevel::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseDoorActor.IsActorBehindDoor
// 0x0010 (0x0010 - 0x0000)
struct BaseDoorActor_IsActorBehindDoor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BaseDoorActor_IsActorBehindDoor) == 0x000008, "Wrong alignment on BaseDoorActor_IsActorBehindDoor");
static_assert(sizeof(BaseDoorActor_IsActorBehindDoor) == 0x000010, "Wrong size on BaseDoorActor_IsActorBehindDoor");
static_assert(offsetof(BaseDoorActor_IsActorBehindDoor, Actor) == 0x000000, "Member 'BaseDoorActor_IsActorBehindDoor::Actor' has a wrong offset!");
static_assert(offsetof(BaseDoorActor_IsActorBehindDoor, ReturnValue) == 0x000008, "Member 'BaseDoorActor_IsActorBehindDoor::ReturnValue' has a wrong offset!");

// Function DeceiveInc.YumiPassiveAbility.OnSpyToolLoadComplete
// 0x0008 (0x0008 - 0x0000)
struct YumiPassiveAbility_OnSpyToolLoadComplete final
{
public:
	class UToolLoadoutComponent*                  ToolLoadout;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(YumiPassiveAbility_OnSpyToolLoadComplete) == 0x000008, "Wrong alignment on YumiPassiveAbility_OnSpyToolLoadComplete");
static_assert(sizeof(YumiPassiveAbility_OnSpyToolLoadComplete) == 0x000008, "Wrong size on YumiPassiveAbility_OnSpyToolLoadComplete");
static_assert(offsetof(YumiPassiveAbility_OnSpyToolLoadComplete, ToolLoadout) == 0x000000, "Member 'YumiPassiveAbility_OnSpyToolLoadComplete::ToolLoadout' has a wrong offset!");

// Function DeceiveInc.BaseIntelActor.BP_IsJammedForActor
// 0x0010 (0x0010 - 0x0000)
struct BaseIntelActor_BP_IsJammedForActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BaseIntelActor_BP_IsJammedForActor) == 0x000008, "Wrong alignment on BaseIntelActor_BP_IsJammedForActor");
static_assert(sizeof(BaseIntelActor_BP_IsJammedForActor) == 0x000010, "Wrong size on BaseIntelActor_BP_IsJammedForActor");
static_assert(offsetof(BaseIntelActor_BP_IsJammedForActor, Actor) == 0x000000, "Member 'BaseIntelActor_BP_IsJammedForActor::Actor' has a wrong offset!");
static_assert(offsetof(BaseIntelActor_BP_IsJammedForActor, ReturnValue) == 0x000008, "Member 'BaseIntelActor_BP_IsJammedForActor::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseIntelActor.BP_OnIntelEffectedByDrainChange
// 0x0002 (0x0002 - 0x0000)
struct BaseIntelActor_BP_OnIntelEffectedByDrainChange final
{
public:
	bool                                          bEffectedByDrain;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEffectedByEnemy;                                  // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseIntelActor_BP_OnIntelEffectedByDrainChange) == 0x000001, "Wrong alignment on BaseIntelActor_BP_OnIntelEffectedByDrainChange");
static_assert(sizeof(BaseIntelActor_BP_OnIntelEffectedByDrainChange) == 0x000002, "Wrong size on BaseIntelActor_BP_OnIntelEffectedByDrainChange");
static_assert(offsetof(BaseIntelActor_BP_OnIntelEffectedByDrainChange, bEffectedByDrain) == 0x000000, "Member 'BaseIntelActor_BP_OnIntelEffectedByDrainChange::bEffectedByDrain' has a wrong offset!");
static_assert(offsetof(BaseIntelActor_BP_OnIntelEffectedByDrainChange, bEffectedByEnemy) == 0x000001, "Member 'BaseIntelActor_BP_OnIntelEffectedByDrainChange::bEffectedByEnemy' has a wrong offset!");

// Function DeceiveInc.BaseIntelActor.BP_OnIntelRebooted
// 0x0008 (0x0008 - 0x0000)
struct BaseIntelActor_BP_OnIntelRebooted final
{
public:
	class AActor*                                 Instigater;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseIntelActor_BP_OnIntelRebooted) == 0x000008, "Wrong alignment on BaseIntelActor_BP_OnIntelRebooted");
static_assert(sizeof(BaseIntelActor_BP_OnIntelRebooted) == 0x000008, "Wrong size on BaseIntelActor_BP_OnIntelRebooted");
static_assert(offsetof(BaseIntelActor_BP_OnIntelRebooted, Instigater) == 0x000000, "Member 'BaseIntelActor_BP_OnIntelRebooted::Instigater' has a wrong offset!");

// Function DeceiveInc.BaseIntelActor.BP_OnLocalActorJammed
// 0x0001 (0x0001 - 0x0000)
struct BaseIntelActor_BP_OnLocalActorJammed final
{
public:
	bool                                          bIsJammed;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseIntelActor_BP_OnLocalActorJammed) == 0x000001, "Wrong alignment on BaseIntelActor_BP_OnLocalActorJammed");
static_assert(sizeof(BaseIntelActor_BP_OnLocalActorJammed) == 0x000001, "Wrong size on BaseIntelActor_BP_OnLocalActorJammed");
static_assert(offsetof(BaseIntelActor_BP_OnLocalActorJammed, bIsJammed) == 0x000000, "Member 'BaseIntelActor_BP_OnLocalActorJammed::bIsJammed' has a wrong offset!");

// Function DeceiveInc.BaseIntelActor.IsDisabledByExternalSourceForActor
// 0x0010 (0x0010 - 0x0000)
struct BaseIntelActor_IsDisabledByExternalSourceForActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BaseIntelActor_IsDisabledByExternalSourceForActor) == 0x000008, "Wrong alignment on BaseIntelActor_IsDisabledByExternalSourceForActor");
static_assert(sizeof(BaseIntelActor_IsDisabledByExternalSourceForActor) == 0x000010, "Wrong size on BaseIntelActor_IsDisabledByExternalSourceForActor");
static_assert(offsetof(BaseIntelActor_IsDisabledByExternalSourceForActor, Actor) == 0x000000, "Member 'BaseIntelActor_IsDisabledByExternalSourceForActor::Actor' has a wrong offset!");
static_assert(offsetof(BaseIntelActor_IsDisabledByExternalSourceForActor, ReturnValue) == 0x000008, "Member 'BaseIntelActor_IsDisabledByExternalSourceForActor::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseIntelActor.IsDisabledByExternalSourceForLocalPlayer
// 0x0001 (0x0001 - 0x0000)
struct BaseIntelActor_IsDisabledByExternalSourceForLocalPlayer final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseIntelActor_IsDisabledByExternalSourceForLocalPlayer) == 0x000001, "Wrong alignment on BaseIntelActor_IsDisabledByExternalSourceForLocalPlayer");
static_assert(sizeof(BaseIntelActor_IsDisabledByExternalSourceForLocalPlayer) == 0x000001, "Wrong size on BaseIntelActor_IsDisabledByExternalSourceForLocalPlayer");
static_assert(offsetof(BaseIntelActor_IsDisabledByExternalSourceForLocalPlayer, ReturnValue) == 0x000000, "Member 'BaseIntelActor_IsDisabledByExternalSourceForLocalPlayer::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseIntelActor.IsJammedForLocalPlayer
// 0x0001 (0x0001 - 0x0000)
struct BaseIntelActor_IsJammedForLocalPlayer final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseIntelActor_IsJammedForLocalPlayer) == 0x000001, "Wrong alignment on BaseIntelActor_IsJammedForLocalPlayer");
static_assert(sizeof(BaseIntelActor_IsJammedForLocalPlayer) == 0x000001, "Wrong size on BaseIntelActor_IsJammedForLocalPlayer");
static_assert(offsetof(BaseIntelActor_IsJammedForLocalPlayer, ReturnValue) == 0x000000, "Member 'BaseIntelActor_IsJammedForLocalPlayer::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseIntelActor.GetResourceCountToGive
// 0x0004 (0x0004 - 0x0000)
struct BaseIntelActor_GetResourceCountToGive final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseIntelActor_GetResourceCountToGive) == 0x000004, "Wrong alignment on BaseIntelActor_GetResourceCountToGive");
static_assert(sizeof(BaseIntelActor_GetResourceCountToGive) == 0x000004, "Wrong size on BaseIntelActor_GetResourceCountToGive");
static_assert(offsetof(BaseIntelActor_GetResourceCountToGive, ReturnValue) == 0x000000, "Member 'BaseIntelActor_GetResourceCountToGive::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseIntelActor.GetResourceTypeToGive
// 0x0001 (0x0001 - 0x0000)
struct BaseIntelActor_GetResourceTypeToGive final
{
public:
	EGameplayResourcesType                        ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseIntelActor_GetResourceTypeToGive) == 0x000001, "Wrong alignment on BaseIntelActor_GetResourceTypeToGive");
static_assert(sizeof(BaseIntelActor_GetResourceTypeToGive) == 0x000001, "Wrong size on BaseIntelActor_GetResourceTypeToGive");
static_assert(offsetof(BaseIntelActor_GetResourceTypeToGive, ReturnValue) == 0x000000, "Member 'BaseIntelActor_GetResourceTypeToGive::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ExtractionArrivingPhaseInfo.GetObjectiveDescCarrier
// 0x0018 (0x0018 - 0x0000)
struct ExtractionArrivingPhaseInfo_GetObjectiveDescCarrier final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExtractionArrivingPhaseInfo_GetObjectiveDescCarrier) == 0x000008, "Wrong alignment on ExtractionArrivingPhaseInfo_GetObjectiveDescCarrier");
static_assert(sizeof(ExtractionArrivingPhaseInfo_GetObjectiveDescCarrier) == 0x000018, "Wrong size on ExtractionArrivingPhaseInfo_GetObjectiveDescCarrier");
static_assert(offsetof(ExtractionArrivingPhaseInfo_GetObjectiveDescCarrier, ReturnValue) == 0x000000, "Member 'ExtractionArrivingPhaseInfo_GetObjectiveDescCarrier::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ExtractionArrivingPhaseInfo.GetObjectiveDescNonCarrier
// 0x0018 (0x0018 - 0x0000)
struct ExtractionArrivingPhaseInfo_GetObjectiveDescNonCarrier final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExtractionArrivingPhaseInfo_GetObjectiveDescNonCarrier) == 0x000008, "Wrong alignment on ExtractionArrivingPhaseInfo_GetObjectiveDescNonCarrier");
static_assert(sizeof(ExtractionArrivingPhaseInfo_GetObjectiveDescNonCarrier) == 0x000018, "Wrong size on ExtractionArrivingPhaseInfo_GetObjectiveDescNonCarrier");
static_assert(offsetof(ExtractionArrivingPhaseInfo_GetObjectiveDescNonCarrier, ReturnValue) == 0x000000, "Member 'ExtractionArrivingPhaseInfo_GetObjectiveDescNonCarrier::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ExtractionArrivingPhaseInfo.GetObjectiveDescNonCarrierTeammate
// 0x0018 (0x0018 - 0x0000)
struct ExtractionArrivingPhaseInfo_GetObjectiveDescNonCarrierTeammate final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExtractionArrivingPhaseInfo_GetObjectiveDescNonCarrierTeammate) == 0x000008, "Wrong alignment on ExtractionArrivingPhaseInfo_GetObjectiveDescNonCarrierTeammate");
static_assert(sizeof(ExtractionArrivingPhaseInfo_GetObjectiveDescNonCarrierTeammate) == 0x000018, "Wrong size on ExtractionArrivingPhaseInfo_GetObjectiveDescNonCarrierTeammate");
static_assert(offsetof(ExtractionArrivingPhaseInfo_GetObjectiveDescNonCarrierTeammate, ReturnValue) == 0x000000, "Member 'ExtractionArrivingPhaseInfo_GetObjectiveDescNonCarrierTeammate::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseGenericChestActor.HandleResourceSpent
// 0x0010 (0x0010 - 0x0000)
struct BaseGenericChestActor_HandleResourceSpent final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayResourcesType                        ResourceType;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseGenericChestActor_HandleResourceSpent) == 0x000008, "Wrong alignment on BaseGenericChestActor_HandleResourceSpent");
static_assert(sizeof(BaseGenericChestActor_HandleResourceSpent) == 0x000010, "Wrong size on BaseGenericChestActor_HandleResourceSpent");
static_assert(offsetof(BaseGenericChestActor_HandleResourceSpent, Interacter) == 0x000000, "Member 'BaseGenericChestActor_HandleResourceSpent::Interacter' has a wrong offset!");
static_assert(offsetof(BaseGenericChestActor_HandleResourceSpent, ResourceType) == 0x000008, "Member 'BaseGenericChestActor_HandleResourceSpent::ResourceType' has a wrong offset!");
static_assert(offsetof(BaseGenericChestActor_HandleResourceSpent, Amount) == 0x00000C, "Member 'BaseGenericChestActor_HandleResourceSpent::Amount' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.GetWeaponBalancingDataForClass
// 0x0010 (0x0010 - 0x0000)
struct BaseMeleeAttack_GetWeaponBalancingDataForClass final
{
public:
	class UClass*                                 WeaponClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseDamage_0;                                      // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BaseMeleeAttack_GetWeaponBalancingDataForClass) == 0x000008, "Wrong alignment on BaseMeleeAttack_GetWeaponBalancingDataForClass");
static_assert(sizeof(BaseMeleeAttack_GetWeaponBalancingDataForClass) == 0x000010, "Wrong size on BaseMeleeAttack_GetWeaponBalancingDataForClass");
static_assert(offsetof(BaseMeleeAttack_GetWeaponBalancingDataForClass, WeaponClass) == 0x000000, "Member 'BaseMeleeAttack_GetWeaponBalancingDataForClass::WeaponClass' has a wrong offset!");
static_assert(offsetof(BaseMeleeAttack_GetWeaponBalancingDataForClass, BaseDamage_0) == 0x000008, "Member 'BaseMeleeAttack_GetWeaponBalancingDataForClass::BaseDamage_0' has a wrong offset!");
static_assert(offsetof(BaseMeleeAttack_GetWeaponBalancingDataForClass, ReturnValue) == 0x00000C, "Member 'BaseMeleeAttack_GetWeaponBalancingDataForClass::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.BP_OnChargeLevelChange
// 0x0004 (0x0004 - 0x0000)
struct BaseMeleeAttack_BP_OnChargeLevelChange final
{
public:
	int32                                         NewChargeLevel;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMeleeAttack_BP_OnChargeLevelChange) == 0x000004, "Wrong alignment on BaseMeleeAttack_BP_OnChargeLevelChange");
static_assert(sizeof(BaseMeleeAttack_BP_OnChargeLevelChange) == 0x000004, "Wrong size on BaseMeleeAttack_BP_OnChargeLevelChange");
static_assert(offsetof(BaseMeleeAttack_BP_OnChargeLevelChange, NewChargeLevel) == 0x000000, "Member 'BaseMeleeAttack_BP_OnChargeLevelChange::NewChargeLevel' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.BP_OnMeleeAttack
// 0x0004 (0x0004 - 0x0000)
struct BaseMeleeAttack_BP_OnMeleeAttack final
{
public:
	int32                                         ChargeLevel;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMeleeAttack_BP_OnMeleeAttack) == 0x000004, "Wrong alignment on BaseMeleeAttack_BP_OnMeleeAttack");
static_assert(sizeof(BaseMeleeAttack_BP_OnMeleeAttack) == 0x000004, "Wrong size on BaseMeleeAttack_BP_OnMeleeAttack");
static_assert(offsetof(BaseMeleeAttack_BP_OnMeleeAttack, ChargeLevel) == 0x000000, "Member 'BaseMeleeAttack_BP_OnMeleeAttack::ChargeLevel' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.BP_OnMeleeAttackHit
// 0x0068 (0x0068 - 0x0000)
struct BaseMeleeAttack_BP_OnMeleeAttackHit final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPoint;                                       // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChargeLevel;                                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultingHealthPercentage;                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitType                                      HitType;                                           // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMeleeHitConfirmedData                 HitConfirmedData;                                  // 0x0028(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMeleeAttack_BP_OnMeleeAttackHit) == 0x000008, "Wrong alignment on BaseMeleeAttack_BP_OnMeleeAttackHit");
static_assert(sizeof(BaseMeleeAttack_BP_OnMeleeAttackHit) == 0x000068, "Wrong size on BaseMeleeAttack_BP_OnMeleeAttackHit");
static_assert(offsetof(BaseMeleeAttack_BP_OnMeleeAttackHit, Victim) == 0x000000, "Member 'BaseMeleeAttack_BP_OnMeleeAttackHit::Victim' has a wrong offset!");
static_assert(offsetof(BaseMeleeAttack_BP_OnMeleeAttackHit, ImpactPoint) == 0x000008, "Member 'BaseMeleeAttack_BP_OnMeleeAttackHit::ImpactPoint' has a wrong offset!");
static_assert(offsetof(BaseMeleeAttack_BP_OnMeleeAttackHit, ChargeLevel) == 0x000014, "Member 'BaseMeleeAttack_BP_OnMeleeAttackHit::ChargeLevel' has a wrong offset!");
static_assert(offsetof(BaseMeleeAttack_BP_OnMeleeAttackHit, Damage) == 0x000018, "Member 'BaseMeleeAttack_BP_OnMeleeAttackHit::Damage' has a wrong offset!");
static_assert(offsetof(BaseMeleeAttack_BP_OnMeleeAttackHit, ResultingHealthPercentage) == 0x00001C, "Member 'BaseMeleeAttack_BP_OnMeleeAttackHit::ResultingHealthPercentage' has a wrong offset!");
static_assert(offsetof(BaseMeleeAttack_BP_OnMeleeAttackHit, HitType) == 0x000020, "Member 'BaseMeleeAttack_BP_OnMeleeAttackHit::HitType' has a wrong offset!");
static_assert(offsetof(BaseMeleeAttack_BP_OnMeleeAttackHit, HitConfirmedData) == 0x000028, "Member 'BaseMeleeAttack_BP_OnMeleeAttackHit::HitConfirmedData' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.Multicast_DoImpulseMelee
// 0x0030 (0x0030 - 0x0000)
struct BaseMeleeAttack_Multicast_DoImpulseMelee final
{
public:
	struct FVector_NetQuantize                    OriginPos;                                         // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    DestinationPos;                                    // 0x000C(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          ChargeLevel;                                       // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     ActorHit;                                          // 0x0020(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMeleeAttack_Multicast_DoImpulseMelee) == 0x000008, "Wrong alignment on BaseMeleeAttack_Multicast_DoImpulseMelee");
static_assert(sizeof(BaseMeleeAttack_Multicast_DoImpulseMelee) == 0x000030, "Wrong size on BaseMeleeAttack_Multicast_DoImpulseMelee");
static_assert(offsetof(BaseMeleeAttack_Multicast_DoImpulseMelee, OriginPos) == 0x000000, "Member 'BaseMeleeAttack_Multicast_DoImpulseMelee::OriginPos' has a wrong offset!");
static_assert(offsetof(BaseMeleeAttack_Multicast_DoImpulseMelee, DestinationPos) == 0x00000C, "Member 'BaseMeleeAttack_Multicast_DoImpulseMelee::DestinationPos' has a wrong offset!");
static_assert(offsetof(BaseMeleeAttack_Multicast_DoImpulseMelee, ChargeLevel) == 0x000018, "Member 'BaseMeleeAttack_Multicast_DoImpulseMelee::ChargeLevel' has a wrong offset!");
static_assert(offsetof(BaseMeleeAttack_Multicast_DoImpulseMelee, ActorHit) == 0x000020, "Member 'BaseMeleeAttack_Multicast_DoImpulseMelee::ActorHit' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.Multicast_DoStrike
// 0x0010 (0x0010 - 0x0000)
struct BaseMeleeAttack_Multicast_DoStrike final
{
public:
	struct FVector_NetQuantize                    DestinationPos;                                    // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          ChargeLevel;                                       // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BaseMeleeAttack_Multicast_DoStrike) == 0x000004, "Wrong alignment on BaseMeleeAttack_Multicast_DoStrike");
static_assert(sizeof(BaseMeleeAttack_Multicast_DoStrike) == 0x000010, "Wrong size on BaseMeleeAttack_Multicast_DoStrike");
static_assert(offsetof(BaseMeleeAttack_Multicast_DoStrike, DestinationPos) == 0x000000, "Member 'BaseMeleeAttack_Multicast_DoStrike::DestinationPos' has a wrong offset!");
static_assert(offsetof(BaseMeleeAttack_Multicast_DoStrike, ChargeLevel) == 0x00000C, "Member 'BaseMeleeAttack_Multicast_DoStrike::ChargeLevel' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.Multicast_EnvHit
// 0x0040 (0x0040 - 0x0000)
struct BaseMeleeAttack_Multicast_EnvHit final
{
public:
	struct FMeleeHitConfirmedData                 HitConfirmedData;                                  // 0x0000(0x0040)(ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMeleeAttack_Multicast_EnvHit) == 0x000008, "Wrong alignment on BaseMeleeAttack_Multicast_EnvHit");
static_assert(sizeof(BaseMeleeAttack_Multicast_EnvHit) == 0x000040, "Wrong size on BaseMeleeAttack_Multicast_EnvHit");
static_assert(offsetof(BaseMeleeAttack_Multicast_EnvHit, HitConfirmedData) == 0x000000, "Member 'BaseMeleeAttack_Multicast_EnvHit::HitConfirmedData' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.Multicast_HitConfirmed
// 0x0040 (0x0040 - 0x0000)
struct BaseMeleeAttack_Multicast_HitConfirmed final
{
public:
	struct FMeleeHitConfirmedData                 HitConfirmedData;                                  // 0x0000(0x0040)(ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMeleeAttack_Multicast_HitConfirmed) == 0x000008, "Wrong alignment on BaseMeleeAttack_Multicast_HitConfirmed");
static_assert(sizeof(BaseMeleeAttack_Multicast_HitConfirmed) == 0x000040, "Wrong size on BaseMeleeAttack_Multicast_HitConfirmed");
static_assert(offsetof(BaseMeleeAttack_Multicast_HitConfirmed, HitConfirmedData) == 0x000000, "Member 'BaseMeleeAttack_Multicast_HitConfirmed::HitConfirmedData' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.NetMulticast_SetupTargetInfo
// 0x0010 (0x0010 - 0x0000)
struct BaseMeleeAttack_NetMulticast_SetupTargetInfo final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImpulse;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BaseMeleeAttack_NetMulticast_SetupTargetInfo) == 0x000008, "Wrong alignment on BaseMeleeAttack_NetMulticast_SetupTargetInfo");
static_assert(sizeof(BaseMeleeAttack_NetMulticast_SetupTargetInfo) == 0x000010, "Wrong size on BaseMeleeAttack_NetMulticast_SetupTargetInfo");
static_assert(offsetof(BaseMeleeAttack_NetMulticast_SetupTargetInfo, Target) == 0x000000, "Member 'BaseMeleeAttack_NetMulticast_SetupTargetInfo::Target' has a wrong offset!");
static_assert(offsetof(BaseMeleeAttack_NetMulticast_SetupTargetInfo, bImpulse) == 0x000008, "Member 'BaseMeleeAttack_NetMulticast_SetupTargetInfo::bImpulse' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.OnRep_CurrentChargeLevel
// 0x0001 (0x0001 - 0x0000)
struct BaseMeleeAttack_OnRep_CurrentChargeLevel final
{
public:
	int8                                          OldChargeLevel;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMeleeAttack_OnRep_CurrentChargeLevel) == 0x000001, "Wrong alignment on BaseMeleeAttack_OnRep_CurrentChargeLevel");
static_assert(sizeof(BaseMeleeAttack_OnRep_CurrentChargeLevel) == 0x000001, "Wrong size on BaseMeleeAttack_OnRep_CurrentChargeLevel");
static_assert(offsetof(BaseMeleeAttack_OnRep_CurrentChargeLevel, OldChargeLevel) == 0x000000, "Member 'BaseMeleeAttack_OnRep_CurrentChargeLevel::OldChargeLevel' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.Server_DoImpulseMelee
// 0x0030 (0x0030 - 0x0000)
struct BaseMeleeAttack_Server_DoImpulseMelee final
{
public:
	struct FVector_NetQuantize                    OriginPos;                                         // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    DestinationPos;                                    // 0x000C(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     HitTargets;                                        // 0x0018(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int8                                          ChargeLevel;                                       // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BaseMeleeAttack_Server_DoImpulseMelee) == 0x000008, "Wrong alignment on BaseMeleeAttack_Server_DoImpulseMelee");
static_assert(sizeof(BaseMeleeAttack_Server_DoImpulseMelee) == 0x000030, "Wrong size on BaseMeleeAttack_Server_DoImpulseMelee");
static_assert(offsetof(BaseMeleeAttack_Server_DoImpulseMelee, OriginPos) == 0x000000, "Member 'BaseMeleeAttack_Server_DoImpulseMelee::OriginPos' has a wrong offset!");
static_assert(offsetof(BaseMeleeAttack_Server_DoImpulseMelee, DestinationPos) == 0x00000C, "Member 'BaseMeleeAttack_Server_DoImpulseMelee::DestinationPos' has a wrong offset!");
static_assert(offsetof(BaseMeleeAttack_Server_DoImpulseMelee, HitTargets) == 0x000018, "Member 'BaseMeleeAttack_Server_DoImpulseMelee::HitTargets' has a wrong offset!");
static_assert(offsetof(BaseMeleeAttack_Server_DoImpulseMelee, ChargeLevel) == 0x000028, "Member 'BaseMeleeAttack_Server_DoImpulseMelee::ChargeLevel' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.Server_DoStrike
// 0x0030 (0x0030 - 0x0000)
struct BaseMeleeAttack_Server_DoStrike final
{
public:
	struct FVector_NetQuantize                    OriginPos;                                         // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    DestinationPos;                                    // 0x000C(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     HitTargets;                                        // 0x0018(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int8                                          ChargeLevel;                                       // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BaseMeleeAttack_Server_DoStrike) == 0x000008, "Wrong alignment on BaseMeleeAttack_Server_DoStrike");
static_assert(sizeof(BaseMeleeAttack_Server_DoStrike) == 0x000030, "Wrong size on BaseMeleeAttack_Server_DoStrike");
static_assert(offsetof(BaseMeleeAttack_Server_DoStrike, OriginPos) == 0x000000, "Member 'BaseMeleeAttack_Server_DoStrike::OriginPos' has a wrong offset!");
static_assert(offsetof(BaseMeleeAttack_Server_DoStrike, DestinationPos) == 0x00000C, "Member 'BaseMeleeAttack_Server_DoStrike::DestinationPos' has a wrong offset!");
static_assert(offsetof(BaseMeleeAttack_Server_DoStrike, HitTargets) == 0x000018, "Member 'BaseMeleeAttack_Server_DoStrike::HitTargets' has a wrong offset!");
static_assert(offsetof(BaseMeleeAttack_Server_DoStrike, ChargeLevel) == 0x000028, "Member 'BaseMeleeAttack_Server_DoStrike::ChargeLevel' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.Server_ResetCharge
// 0x0001 (0x0001 - 0x0000)
struct BaseMeleeAttack_Server_ResetCharge final
{
public:
	bool                                          bIsCancel;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMeleeAttack_Server_ResetCharge) == 0x000001, "Wrong alignment on BaseMeleeAttack_Server_ResetCharge");
static_assert(sizeof(BaseMeleeAttack_Server_ResetCharge) == 0x000001, "Wrong size on BaseMeleeAttack_Server_ResetCharge");
static_assert(offsetof(BaseMeleeAttack_Server_ResetCharge, bIsCancel) == 0x000000, "Member 'BaseMeleeAttack_Server_ResetCharge::bIsCancel' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.Server_SetupTargetInfo
// 0x0010 (0x0010 - 0x0000)
struct BaseMeleeAttack_Server_SetupTargetInfo final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImpulse;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BaseMeleeAttack_Server_SetupTargetInfo) == 0x000008, "Wrong alignment on BaseMeleeAttack_Server_SetupTargetInfo");
static_assert(sizeof(BaseMeleeAttack_Server_SetupTargetInfo) == 0x000010, "Wrong size on BaseMeleeAttack_Server_SetupTargetInfo");
static_assert(offsetof(BaseMeleeAttack_Server_SetupTargetInfo, Target) == 0x000000, "Member 'BaseMeleeAttack_Server_SetupTargetInfo::Target' has a wrong offset!");
static_assert(offsetof(BaseMeleeAttack_Server_SetupTargetInfo, bImpulse) == 0x000008, "Member 'BaseMeleeAttack_Server_SetupTargetInfo::bImpulse' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.GetChargeLevel
// 0x0004 (0x0004 - 0x0000)
struct BaseMeleeAttack_GetChargeLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMeleeAttack_GetChargeLevel) == 0x000004, "Wrong alignment on BaseMeleeAttack_GetChargeLevel");
static_assert(sizeof(BaseMeleeAttack_GetChargeLevel) == 0x000004, "Wrong size on BaseMeleeAttack_GetChargeLevel");
static_assert(offsetof(BaseMeleeAttack_GetChargeLevel, ReturnValue) == 0x000000, "Member 'BaseMeleeAttack_GetChargeLevel::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.GetCooldownBeforeShooting
// 0x0008 (0x0008 - 0x0000)
struct BaseMeleeAttack_GetCooldownBeforeShooting final
{
public:
	int32                                         ChargeLevel;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMeleeAttack_GetCooldownBeforeShooting) == 0x000004, "Wrong alignment on BaseMeleeAttack_GetCooldownBeforeShooting");
static_assert(sizeof(BaseMeleeAttack_GetCooldownBeforeShooting) == 0x000008, "Wrong size on BaseMeleeAttack_GetCooldownBeforeShooting");
static_assert(offsetof(BaseMeleeAttack_GetCooldownBeforeShooting, ChargeLevel) == 0x000000, "Member 'BaseMeleeAttack_GetCooldownBeforeShooting::ChargeLevel' has a wrong offset!");
static_assert(offsetof(BaseMeleeAttack_GetCooldownBeforeShooting, ReturnValue) == 0x000004, "Member 'BaseMeleeAttack_GetCooldownBeforeShooting::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.GetCooldownBetweenStrikes
// 0x0008 (0x0008 - 0x0000)
struct BaseMeleeAttack_GetCooldownBetweenStrikes final
{
public:
	int32                                         ChargeLevel;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMeleeAttack_GetCooldownBetweenStrikes) == 0x000004, "Wrong alignment on BaseMeleeAttack_GetCooldownBetweenStrikes");
static_assert(sizeof(BaseMeleeAttack_GetCooldownBetweenStrikes) == 0x000008, "Wrong size on BaseMeleeAttack_GetCooldownBetweenStrikes");
static_assert(offsetof(BaseMeleeAttack_GetCooldownBetweenStrikes, ChargeLevel) == 0x000000, "Member 'BaseMeleeAttack_GetCooldownBetweenStrikes::ChargeLevel' has a wrong offset!");
static_assert(offsetof(BaseMeleeAttack_GetCooldownBetweenStrikes, ReturnValue) == 0x000004, "Member 'BaseMeleeAttack_GetCooldownBetweenStrikes::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.GetLastAttackCooldownBetweenStrikes
// 0x0004 (0x0004 - 0x0000)
struct BaseMeleeAttack_GetLastAttackCooldownBetweenStrikes final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMeleeAttack_GetLastAttackCooldownBetweenStrikes) == 0x000004, "Wrong alignment on BaseMeleeAttack_GetLastAttackCooldownBetweenStrikes");
static_assert(sizeof(BaseMeleeAttack_GetLastAttackCooldownBetweenStrikes) == 0x000004, "Wrong size on BaseMeleeAttack_GetLastAttackCooldownBetweenStrikes");
static_assert(offsetof(BaseMeleeAttack_GetLastAttackCooldownBetweenStrikes, ReturnValue) == 0x000000, "Member 'BaseMeleeAttack_GetLastAttackCooldownBetweenStrikes::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.GetLastAttckChargeLevel
// 0x0004 (0x0004 - 0x0000)
struct BaseMeleeAttack_GetLastAttckChargeLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMeleeAttack_GetLastAttckChargeLevel) == 0x000004, "Wrong alignment on BaseMeleeAttack_GetLastAttckChargeLevel");
static_assert(sizeof(BaseMeleeAttack_GetLastAttckChargeLevel) == 0x000004, "Wrong size on BaseMeleeAttack_GetLastAttckChargeLevel");
static_assert(offsetof(BaseMeleeAttack_GetLastAttckChargeLevel, ReturnValue) == 0x000000, "Member 'BaseMeleeAttack_GetLastAttckChargeLevel::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.GetMaxChargeTime
// 0x0004 (0x0004 - 0x0000)
struct BaseMeleeAttack_GetMaxChargeTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMeleeAttack_GetMaxChargeTime) == 0x000004, "Wrong alignment on BaseMeleeAttack_GetMaxChargeTime");
static_assert(sizeof(BaseMeleeAttack_GetMaxChargeTime) == 0x000004, "Wrong size on BaseMeleeAttack_GetMaxChargeTime");
static_assert(offsetof(BaseMeleeAttack_GetMaxChargeTime, ReturnValue) == 0x000000, "Member 'BaseMeleeAttack_GetMaxChargeTime::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.GetMeleeCogOffset
// 0x0004 (0x0004 - 0x0000)
struct BaseMeleeAttack_GetMeleeCogOffset final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMeleeAttack_GetMeleeCogOffset) == 0x000004, "Wrong alignment on BaseMeleeAttack_GetMeleeCogOffset");
static_assert(sizeof(BaseMeleeAttack_GetMeleeCogOffset) == 0x000004, "Wrong size on BaseMeleeAttack_GetMeleeCogOffset");
static_assert(offsetof(BaseMeleeAttack_GetMeleeCogOffset, ReturnValue) == 0x000000, "Member 'BaseMeleeAttack_GetMeleeCogOffset::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.IsCanCancelMelee
// 0x0001 (0x0001 - 0x0000)
struct BaseMeleeAttack_IsCanCancelMelee final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMeleeAttack_IsCanCancelMelee) == 0x000001, "Wrong alignment on BaseMeleeAttack_IsCanCancelMelee");
static_assert(sizeof(BaseMeleeAttack_IsCanCancelMelee) == 0x000001, "Wrong size on BaseMeleeAttack_IsCanCancelMelee");
static_assert(offsetof(BaseMeleeAttack_IsCanCancelMelee, ReturnValue) == 0x000000, "Member 'BaseMeleeAttack_IsCanCancelMelee::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.IsCharging
// 0x0001 (0x0001 - 0x0000)
struct BaseMeleeAttack_IsCharging final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMeleeAttack_IsCharging) == 0x000001, "Wrong alignment on BaseMeleeAttack_IsCharging");
static_assert(sizeof(BaseMeleeAttack_IsCharging) == 0x000001, "Wrong size on BaseMeleeAttack_IsCharging");
static_assert(offsetof(BaseMeleeAttack_IsCharging, ReturnValue) == 0x000000, "Member 'BaseMeleeAttack_IsCharging::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseMeleeAttack.IsFullyCharge
// 0x0001 (0x0001 - 0x0000)
struct BaseMeleeAttack_IsFullyCharge final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMeleeAttack_IsFullyCharge) == 0x000001, "Wrong alignment on BaseMeleeAttack_IsFullyCharge");
static_assert(sizeof(BaseMeleeAttack_IsFullyCharge) == 0x000001, "Wrong size on BaseMeleeAttack_IsFullyCharge");
static_assert(offsetof(BaseMeleeAttack_IsFullyCharge, ReturnValue) == 0x000000, "Member 'BaseMeleeAttack_IsFullyCharge::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseMimicScannableActor.HandleLocalSpyMovingChanged
// 0x0010 (0x0010 - 0x0000)
struct BaseMimicScannableActor_HandleLocalSpyMovingChanged final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoving;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BaseMimicScannableActor_HandleLocalSpyMovingChanged) == 0x000008, "Wrong alignment on BaseMimicScannableActor_HandleLocalSpyMovingChanged");
static_assert(sizeof(BaseMimicScannableActor_HandleLocalSpyMovingChanged) == 0x000010, "Wrong size on BaseMimicScannableActor_HandleLocalSpyMovingChanged");
static_assert(offsetof(BaseMimicScannableActor_HandleLocalSpyMovingChanged, Spy) == 0x000000, "Member 'BaseMimicScannableActor_HandleLocalSpyMovingChanged::Spy' has a wrong offset!");
static_assert(offsetof(BaseMimicScannableActor_HandleLocalSpyMovingChanged, bMoving) == 0x000008, "Member 'BaseMimicScannableActor_HandleLocalSpyMovingChanged::bMoving' has a wrong offset!");

// Function DeceiveInc.BaseMimicScannableActor.HandleSpectatingPlayerChangeEvent
// 0x0018 (0x0018 - 0x0000)
struct BaseMimicScannableActor_HandleSpectatingPlayerChangeEvent final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SpectatingActor;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADIPlayerState*                         SpectatingPlayerState;                             // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMimicScannableActor_HandleSpectatingPlayerChangeEvent) == 0x000008, "Wrong alignment on BaseMimicScannableActor_HandleSpectatingPlayerChangeEvent");
static_assert(sizeof(BaseMimicScannableActor_HandleSpectatingPlayerChangeEvent) == 0x000018, "Wrong size on BaseMimicScannableActor_HandleSpectatingPlayerChangeEvent");
static_assert(offsetof(BaseMimicScannableActor_HandleSpectatingPlayerChangeEvent, PlayerController) == 0x000000, "Member 'BaseMimicScannableActor_HandleSpectatingPlayerChangeEvent::PlayerController' has a wrong offset!");
static_assert(offsetof(BaseMimicScannableActor_HandleSpectatingPlayerChangeEvent, SpectatingActor) == 0x000008, "Member 'BaseMimicScannableActor_HandleSpectatingPlayerChangeEvent::SpectatingActor' has a wrong offset!");
static_assert(offsetof(BaseMimicScannableActor_HandleSpectatingPlayerChangeEvent, SpectatingPlayerState) == 0x000010, "Member 'BaseMimicScannableActor_HandleSpectatingPlayerChangeEvent::SpectatingPlayerState' has a wrong offset!");

// Function DeceiveInc.BaseMimicScannableActor.NetMulticast_EnableInteract
// 0x0001 (0x0001 - 0x0000)
struct BaseMimicScannableActor_NetMulticast_EnableInteract final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMimicScannableActor_NetMulticast_EnableInteract) == 0x000001, "Wrong alignment on BaseMimicScannableActor_NetMulticast_EnableInteract");
static_assert(sizeof(BaseMimicScannableActor_NetMulticast_EnableInteract) == 0x000001, "Wrong size on BaseMimicScannableActor_NetMulticast_EnableInteract");
static_assert(offsetof(BaseMimicScannableActor_NetMulticast_EnableInteract, bEnable) == 0x000000, "Member 'BaseMimicScannableActor_NetMulticast_EnableInteract::bEnable' has a wrong offset!");

// Function DeceiveInc.BaseMimicScannableActor.Server_EnableInteract
// 0x0001 (0x0001 - 0x0000)
struct BaseMimicScannableActor_Server_EnableInteract final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseMimicScannableActor_Server_EnableInteract) == 0x000001, "Wrong alignment on BaseMimicScannableActor_Server_EnableInteract");
static_assert(sizeof(BaseMimicScannableActor_Server_EnableInteract) == 0x000001, "Wrong size on BaseMimicScannableActor_Server_EnableInteract");
static_assert(offsetof(BaseMimicScannableActor_Server_EnableInteract, bEnable) == 0x000000, "Member 'BaseMimicScannableActor_Server_EnableInteract::bEnable' has a wrong offset!");

// Function DeceiveInc.LarcinActiveAbility.BP_IsLarcinActiveTriggered
// 0x0001 (0x0001 - 0x0000)
struct LarcinActiveAbility_BP_IsLarcinActiveTriggered final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LarcinActiveAbility_BP_IsLarcinActiveTriggered) == 0x000001, "Wrong alignment on LarcinActiveAbility_BP_IsLarcinActiveTriggered");
static_assert(sizeof(LarcinActiveAbility_BP_IsLarcinActiveTriggered) == 0x000001, "Wrong size on LarcinActiveAbility_BP_IsLarcinActiveTriggered");
static_assert(offsetof(LarcinActiveAbility_BP_IsLarcinActiveTriggered, ReturnValue) == 0x000000, "Member 'LarcinActiveAbility_BP_IsLarcinActiveTriggered::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BasePickableActor.OnRep_Collected
// 0x0001 (0x0001 - 0x0000)
struct BasePickableActor_OnRep_Collected final
{
public:
	bool                                          PreviousCollected;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasePickableActor_OnRep_Collected) == 0x000001, "Wrong alignment on BasePickableActor_OnRep_Collected");
static_assert(sizeof(BasePickableActor_OnRep_Collected) == 0x000001, "Wrong size on BasePickableActor_OnRep_Collected");
static_assert(offsetof(BasePickableActor_OnRep_Collected, PreviousCollected) == 0x000000, "Member 'BasePickableActor_OnRep_Collected::PreviousCollected' has a wrong offset!");

// Function DeceiveInc.BasePickableActor.BP_OverrideGivenRessource
// 0x0010 (0x0010 - 0x0000)
struct BasePickableActor_BP_OverrideGivenRessource final
{
public:
	class AActor*                                 Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayResourcesType                        OverrideRessourceType;                             // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OverrideRessourceCount;                            // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasePickableActor_BP_OverrideGivenRessource) == 0x000008, "Wrong alignment on BasePickableActor_BP_OverrideGivenRessource");
static_assert(sizeof(BasePickableActor_BP_OverrideGivenRessource) == 0x000010, "Wrong size on BasePickableActor_BP_OverrideGivenRessource");
static_assert(offsetof(BasePickableActor_BP_OverrideGivenRessource, Interacter) == 0x000000, "Member 'BasePickableActor_BP_OverrideGivenRessource::Interacter' has a wrong offset!");
static_assert(offsetof(BasePickableActor_BP_OverrideGivenRessource, OverrideRessourceType) == 0x000008, "Member 'BasePickableActor_BP_OverrideGivenRessource::OverrideRessourceType' has a wrong offset!");
static_assert(offsetof(BasePickableActor_BP_OverrideGivenRessource, OverrideRessourceCount) == 0x00000C, "Member 'BasePickableActor_BP_OverrideGivenRessource::OverrideRessourceCount' has a wrong offset!");

// Function DeceiveInc.BasePickableActor.GetResourceCountToGive
// 0x0010 (0x0010 - 0x0000)
struct BasePickableActor_GetResourceCountToGive final
{
public:
	class AActor*                                 Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BasePickableActor_GetResourceCountToGive) == 0x000008, "Wrong alignment on BasePickableActor_GetResourceCountToGive");
static_assert(sizeof(BasePickableActor_GetResourceCountToGive) == 0x000010, "Wrong size on BasePickableActor_GetResourceCountToGive");
static_assert(offsetof(BasePickableActor_GetResourceCountToGive, Interacter) == 0x000000, "Member 'BasePickableActor_GetResourceCountToGive::Interacter' has a wrong offset!");
static_assert(offsetof(BasePickableActor_GetResourceCountToGive, ReturnValue) == 0x000008, "Member 'BasePickableActor_GetResourceCountToGive::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BasePickableActor.GetResourceTypeToGive
// 0x0010 (0x0010 - 0x0000)
struct BasePickableActor_GetResourceTypeToGive final
{
public:
	class AActor*                                 Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayResourcesType                        ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BasePickableActor_GetResourceTypeToGive) == 0x000008, "Wrong alignment on BasePickableActor_GetResourceTypeToGive");
static_assert(sizeof(BasePickableActor_GetResourceTypeToGive) == 0x000010, "Wrong size on BasePickableActor_GetResourceTypeToGive");
static_assert(offsetof(BasePickableActor_GetResourceTypeToGive, Interacter) == 0x000000, "Member 'BasePickableActor_GetResourceTypeToGive::Interacter' has a wrong offset!");
static_assert(offsetof(BasePickableActor_GetResourceTypeToGive, ReturnValue) == 0x000008, "Member 'BasePickableActor_GetResourceTypeToGive::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BasePickableToolActor.OnRep_Collected
// 0x0001 (0x0001 - 0x0000)
struct BasePickableToolActor_OnRep_Collected final
{
public:
	bool                                          PreviousCollected;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasePickableToolActor_OnRep_Collected) == 0x000001, "Wrong alignment on BasePickableToolActor_OnRep_Collected");
static_assert(sizeof(BasePickableToolActor_OnRep_Collected) == 0x000001, "Wrong size on BasePickableToolActor_OnRep_Collected");
static_assert(offsetof(BasePickableToolActor_OnRep_Collected, PreviousCollected) == 0x000000, "Member 'BasePickableToolActor_OnRep_Collected::PreviousCollected' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.BlockAllInteractableTypes
// 0x0018 (0x0018 - 0x0000)
struct InteracterComponent_BlockAllInteractableTypes final
{
public:
	TArray<EInteractableType>                     TypesToNotBlock;                                   // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	class AActor*                                 Requester;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteracterComponent_BlockAllInteractableTypes) == 0x000008, "Wrong alignment on InteracterComponent_BlockAllInteractableTypes");
static_assert(sizeof(InteracterComponent_BlockAllInteractableTypes) == 0x000018, "Wrong size on InteracterComponent_BlockAllInteractableTypes");
static_assert(offsetof(InteracterComponent_BlockAllInteractableTypes, TypesToNotBlock) == 0x000000, "Member 'InteracterComponent_BlockAllInteractableTypes::TypesToNotBlock' has a wrong offset!");
static_assert(offsetof(InteracterComponent_BlockAllInteractableTypes, Requester) == 0x000010, "Member 'InteracterComponent_BlockAllInteractableTypes::Requester' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.BlockInteractableTypes
// 0x0018 (0x0018 - 0x0000)
struct InteracterComponent_BlockInteractableTypes final
{
public:
	TArray<EInteractableType>                     TypesToBlock;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	class AActor*                                 Requester;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteracterComponent_BlockInteractableTypes) == 0x000008, "Wrong alignment on InteracterComponent_BlockInteractableTypes");
static_assert(sizeof(InteracterComponent_BlockInteractableTypes) == 0x000018, "Wrong size on InteracterComponent_BlockInteractableTypes");
static_assert(offsetof(InteracterComponent_BlockInteractableTypes, TypesToBlock) == 0x000000, "Member 'InteracterComponent_BlockInteractableTypes::TypesToBlock' has a wrong offset!");
static_assert(offsetof(InteracterComponent_BlockInteractableTypes, Requester) == 0x000010, "Member 'InteracterComponent_BlockInteractableTypes::Requester' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.EnableInteracter
// 0x0010 (0x0010 - 0x0000)
struct InteracterComponent_EnableInteracter final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Requester;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteracterComponent_EnableInteracter) == 0x000008, "Wrong alignment on InteracterComponent_EnableInteracter");
static_assert(sizeof(InteracterComponent_EnableInteracter) == 0x000010, "Wrong size on InteracterComponent_EnableInteracter");
static_assert(offsetof(InteracterComponent_EnableInteracter, bEnable) == 0x000000, "Member 'InteracterComponent_EnableInteracter::bEnable' has a wrong offset!");
static_assert(offsetof(InteracterComponent_EnableInteracter, Requester) == 0x000008, "Member 'InteracterComponent_EnableInteracter::Requester' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.ExternalServerCompleteInteraction
// 0x0008 (0x0008 - 0x0000)
struct InteracterComponent_ExternalServerCompleteInteraction final
{
public:
	class UInteractableComponent*                 InteractableComp;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteracterComponent_ExternalServerCompleteInteraction) == 0x000008, "Wrong alignment on InteracterComponent_ExternalServerCompleteInteraction");
static_assert(sizeof(InteracterComponent_ExternalServerCompleteInteraction) == 0x000008, "Wrong size on InteracterComponent_ExternalServerCompleteInteraction");
static_assert(offsetof(InteracterComponent_ExternalServerCompleteInteraction, InteractableComp) == 0x000000, "Member 'InteracterComponent_ExternalServerCompleteInteraction::InteractableComp' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.HandleBooleanPlayerSettingChange
// 0x0002 (0x0002 - 0x0000)
struct InteracterComponent_HandleBooleanPlayerSettingChange final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewValue;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteracterComponent_HandleBooleanPlayerSettingChange) == 0x000001, "Wrong alignment on InteracterComponent_HandleBooleanPlayerSettingChange");
static_assert(sizeof(InteracterComponent_HandleBooleanPlayerSettingChange) == 0x000002, "Wrong size on InteracterComponent_HandleBooleanPlayerSettingChange");
static_assert(offsetof(InteracterComponent_HandleBooleanPlayerSettingChange, SettingType) == 0x000000, "Member 'InteracterComponent_HandleBooleanPlayerSettingChange::SettingType' has a wrong offset!");
static_assert(offsetof(InteracterComponent_HandleBooleanPlayerSettingChange, NewValue) == 0x000001, "Member 'InteracterComponent_HandleBooleanPlayerSettingChange::NewValue' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.HandleInteractCancelEvent
// 0x0010 (0x0010 - 0x0000)
struct InteracterComponent_HandleInteractCancelEvent final
{
public:
	class ADeceiveIncPlayerController*            Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractCancelType                           InteractCancelType;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InteracterComponent_HandleInteractCancelEvent) == 0x000008, "Wrong alignment on InteracterComponent_HandleInteractCancelEvent");
static_assert(sizeof(InteracterComponent_HandleInteractCancelEvent) == 0x000010, "Wrong size on InteracterComponent_HandleInteractCancelEvent");
static_assert(offsetof(InteracterComponent_HandleInteractCancelEvent, Spy) == 0x000000, "Member 'InteracterComponent_HandleInteractCancelEvent::Spy' has a wrong offset!");
static_assert(offsetof(InteracterComponent_HandleInteractCancelEvent, InteractCancelType) == 0x000008, "Member 'InteracterComponent_HandleInteractCancelEvent::InteractCancelType' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.ServerCancelInteraction
// 0x0008 (0x0008 - 0x0000)
struct InteracterComponent_ServerCancelInteraction final
{
public:
	class UInteractableComponent*                 InteractableComp;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteracterComponent_ServerCancelInteraction) == 0x000008, "Wrong alignment on InteracterComponent_ServerCancelInteraction");
static_assert(sizeof(InteracterComponent_ServerCancelInteraction) == 0x000008, "Wrong size on InteracterComponent_ServerCancelInteraction");
static_assert(offsetof(InteracterComponent_ServerCancelInteraction, InteractableComp) == 0x000000, "Member 'InteracterComponent_ServerCancelInteraction::InteractableComp' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.ServerCompleteInteraction
// 0x0010 (0x0010 - 0x0000)
struct InteracterComponent_ServerCompleteInteraction final
{
public:
	class UInteractableComponent*                 InteractableComp;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConditionType                                ConditionType;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InteracterComponent_ServerCompleteInteraction) == 0x000008, "Wrong alignment on InteracterComponent_ServerCompleteInteraction");
static_assert(sizeof(InteracterComponent_ServerCompleteInteraction) == 0x000010, "Wrong size on InteracterComponent_ServerCompleteInteraction");
static_assert(offsetof(InteracterComponent_ServerCompleteInteraction, InteractableComp) == 0x000000, "Member 'InteracterComponent_ServerCompleteInteraction::InteractableComp' has a wrong offset!");
static_assert(offsetof(InteracterComponent_ServerCompleteInteraction, ConditionType) == 0x000008, "Member 'InteracterComponent_ServerCompleteInteraction::ConditionType' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.ServerStartInteraction
// 0x0008 (0x0008 - 0x0000)
struct InteracterComponent_ServerStartInteraction final
{
public:
	class UInteractableComponent*                 InteractableComp;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteracterComponent_ServerStartInteraction) == 0x000008, "Wrong alignment on InteracterComponent_ServerStartInteraction");
static_assert(sizeof(InteracterComponent_ServerStartInteraction) == 0x000008, "Wrong size on InteracterComponent_ServerStartInteraction");
static_assert(offsetof(InteracterComponent_ServerStartInteraction, InteractableComp) == 0x000000, "Member 'InteracterComponent_ServerStartInteraction::InteractableComp' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.UnblockAllInteractableTypesForRequester
// 0x0008 (0x0008 - 0x0000)
struct InteracterComponent_UnblockAllInteractableTypesForRequester final
{
public:
	class AActor*                                 Requester;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteracterComponent_UnblockAllInteractableTypesForRequester) == 0x000008, "Wrong alignment on InteracterComponent_UnblockAllInteractableTypesForRequester");
static_assert(sizeof(InteracterComponent_UnblockAllInteractableTypesForRequester) == 0x000008, "Wrong size on InteracterComponent_UnblockAllInteractableTypesForRequester");
static_assert(offsetof(InteracterComponent_UnblockAllInteractableTypesForRequester, Requester) == 0x000000, "Member 'InteracterComponent_UnblockAllInteractableTypesForRequester::Requester' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.UnblockInteractableTypesForRequester
// 0x0018 (0x0018 - 0x0000)
struct InteracterComponent_UnblockInteractableTypesForRequester final
{
public:
	TArray<EInteractableType>                     TypesToUnblock;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	class AActor*                                 Requester;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteracterComponent_UnblockInteractableTypesForRequester) == 0x000008, "Wrong alignment on InteracterComponent_UnblockInteractableTypesForRequester");
static_assert(sizeof(InteracterComponent_UnblockInteractableTypesForRequester) == 0x000018, "Wrong size on InteracterComponent_UnblockInteractableTypesForRequester");
static_assert(offsetof(InteracterComponent_UnblockInteractableTypesForRequester, TypesToUnblock) == 0x000000, "Member 'InteracterComponent_UnblockInteractableTypesForRequester::TypesToUnblock' has a wrong offset!");
static_assert(offsetof(InteracterComponent_UnblockInteractableTypesForRequester, Requester) == 0x000010, "Member 'InteracterComponent_UnblockInteractableTypesForRequester::Requester' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.GetCurrentInteractionDuration
// 0x0004 (0x0004 - 0x0000)
struct InteracterComponent_GetCurrentInteractionDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteracterComponent_GetCurrentInteractionDuration) == 0x000004, "Wrong alignment on InteracterComponent_GetCurrentInteractionDuration");
static_assert(sizeof(InteracterComponent_GetCurrentInteractionDuration) == 0x000004, "Wrong size on InteracterComponent_GetCurrentInteractionDuration");
static_assert(offsetof(InteracterComponent_GetCurrentInteractionDuration, ReturnValue) == 0x000000, "Member 'InteracterComponent_GetCurrentInteractionDuration::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.GetCustomInteractionDuration
// 0x0004 (0x0004 - 0x0000)
struct InteracterComponent_GetCustomInteractionDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteracterComponent_GetCustomInteractionDuration) == 0x000004, "Wrong alignment on InteracterComponent_GetCustomInteractionDuration");
static_assert(sizeof(InteracterComponent_GetCustomInteractionDuration) == 0x000004, "Wrong size on InteracterComponent_GetCustomInteractionDuration");
static_assert(offsetof(InteracterComponent_GetCustomInteractionDuration, ReturnValue) == 0x000000, "Member 'InteracterComponent_GetCustomInteractionDuration::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.GetInRangeInteractableList
// 0x0010 (0x0010 - 0x0000)
struct InteracterComponent_GetInRangeInteractableList final
{
public:
	TArray<class UInteractableComponent*>         ReturnValue;                                       // 0x0000(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteracterComponent_GetInRangeInteractableList) == 0x000008, "Wrong alignment on InteracterComponent_GetInRangeInteractableList");
static_assert(sizeof(InteracterComponent_GetInRangeInteractableList) == 0x000010, "Wrong size on InteracterComponent_GetInRangeInteractableList");
static_assert(offsetof(InteracterComponent_GetInRangeInteractableList, ReturnValue) == 0x000000, "Member 'InteracterComponent_GetInRangeInteractableList::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.GetInteractableList
// 0x0010 (0x0010 - 0x0000)
struct InteracterComponent_GetInteractableList final
{
public:
	TArray<struct FInteractableState>             ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteracterComponent_GetInteractableList) == 0x000008, "Wrong alignment on InteracterComponent_GetInteractableList");
static_assert(sizeof(InteracterComponent_GetInteractableList) == 0x000010, "Wrong size on InteracterComponent_GetInteractableList");
static_assert(offsetof(InteracterComponent_GetInteractableList, ReturnValue) == 0x000000, "Member 'InteracterComponent_GetInteractableList::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.GetInteractionDistance
// 0x0004 (0x0004 - 0x0000)
struct InteracterComponent_GetInteractionDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteracterComponent_GetInteractionDistance) == 0x000004, "Wrong alignment on InteracterComponent_GetInteractionDistance");
static_assert(sizeof(InteracterComponent_GetInteractionDistance) == 0x000004, "Wrong size on InteracterComponent_GetInteractionDistance");
static_assert(offsetof(InteracterComponent_GetInteractionDistance, ReturnValue) == 0x000000, "Member 'InteracterComponent_GetInteractionDistance::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.GetInteractionDuration
// 0x0010 (0x0010 - 0x0000)
struct InteracterComponent_GetInteractionDuration final
{
public:
	class UInteractableComponent*                 InteractableComp;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InteracterComponent_GetInteractionDuration) == 0x000008, "Wrong alignment on InteracterComponent_GetInteractionDuration");
static_assert(sizeof(InteracterComponent_GetInteractionDuration) == 0x000010, "Wrong size on InteracterComponent_GetInteractionDuration");
static_assert(offsetof(InteracterComponent_GetInteractionDuration, InteractableComp) == 0x000000, "Member 'InteracterComponent_GetInteractionDuration::InteractableComp' has a wrong offset!");
static_assert(offsetof(InteracterComponent_GetInteractionDuration, ReturnValue) == 0x000008, "Member 'InteracterComponent_GetInteractionDuration::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.GetInteractionDurationWithReduction
// 0x000C (0x000C - 0x0000)
struct InteracterComponent_GetInteractionDurationWithReduction final
{
public:
	float                                         InteractableDuration;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowPowerupReduction;                             // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteracterComponent_GetInteractionDurationWithReduction) == 0x000004, "Wrong alignment on InteracterComponent_GetInteractionDurationWithReduction");
static_assert(sizeof(InteracterComponent_GetInteractionDurationWithReduction) == 0x00000C, "Wrong size on InteracterComponent_GetInteractionDurationWithReduction");
static_assert(offsetof(InteracterComponent_GetInteractionDurationWithReduction, InteractableDuration) == 0x000000, "Member 'InteracterComponent_GetInteractionDurationWithReduction::InteractableDuration' has a wrong offset!");
static_assert(offsetof(InteracterComponent_GetInteractionDurationWithReduction, AllowPowerupReduction) == 0x000004, "Member 'InteracterComponent_GetInteractionDurationWithReduction::AllowPowerupReduction' has a wrong offset!");
static_assert(offsetof(InteracterComponent_GetInteractionDurationWithReduction, ReturnValue) == 0x000008, "Member 'InteracterComponent_GetInteractionDurationWithReduction::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.GetInteractionTimePercent
// 0x0004 (0x0004 - 0x0000)
struct InteracterComponent_GetInteractionTimePercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteracterComponent_GetInteractionTimePercent) == 0x000004, "Wrong alignment on InteracterComponent_GetInteractionTimePercent");
static_assert(sizeof(InteracterComponent_GetInteractionTimePercent) == 0x000004, "Wrong size on InteracterComponent_GetInteractionTimePercent");
static_assert(offsetof(InteracterComponent_GetInteractionTimePercent, ReturnValue) == 0x000000, "Member 'InteracterComponent_GetInteractionTimePercent::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.GetSpyActor
// 0x0008 (0x0008 - 0x0000)
struct InteracterComponent_GetSpyActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteracterComponent_GetSpyActor) == 0x000008, "Wrong alignment on InteracterComponent_GetSpyActor");
static_assert(sizeof(InteracterComponent_GetSpyActor) == 0x000008, "Wrong size on InteracterComponent_GetSpyActor");
static_assert(offsetof(InteracterComponent_GetSpyActor, ReturnValue) == 0x000000, "Member 'InteracterComponent_GetSpyActor::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.GetSpyOwner
// 0x0008 (0x0008 - 0x0000)
struct InteracterComponent_GetSpyOwner final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteracterComponent_GetSpyOwner) == 0x000008, "Wrong alignment on InteracterComponent_GetSpyOwner");
static_assert(sizeof(InteracterComponent_GetSpyOwner) == 0x000008, "Wrong size on InteracterComponent_GetSpyOwner");
static_assert(offsetof(InteracterComponent_GetSpyOwner, ReturnValue) == 0x000000, "Member 'InteracterComponent_GetSpyOwner::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.GetSpyOwnerPlayerState
// 0x0008 (0x0008 - 0x0000)
struct InteracterComponent_GetSpyOwnerPlayerState final
{
public:
	class ADIPlayerState*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteracterComponent_GetSpyOwnerPlayerState) == 0x000008, "Wrong alignment on InteracterComponent_GetSpyOwnerPlayerState");
static_assert(sizeof(InteracterComponent_GetSpyOwnerPlayerState) == 0x000008, "Wrong size on InteracterComponent_GetSpyOwnerPlayerState");
static_assert(offsetof(InteracterComponent_GetSpyOwnerPlayerState, ReturnValue) == 0x000000, "Member 'InteracterComponent_GetSpyOwnerPlayerState::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.IsBot
// 0x0001 (0x0001 - 0x0000)
struct InteracterComponent_IsBot final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteracterComponent_IsBot) == 0x000001, "Wrong alignment on InteracterComponent_IsBot");
static_assert(sizeof(InteracterComponent_IsBot) == 0x000001, "Wrong size on InteracterComponent_IsBot");
static_assert(offsetof(InteracterComponent_IsBot, ReturnValue) == 0x000000, "Member 'InteracterComponent_IsBot::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.IsInteracting
// 0x0001 (0x0001 - 0x0000)
struct InteracterComponent_IsInteracting final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteracterComponent_IsInteracting) == 0x000001, "Wrong alignment on InteracterComponent_IsInteracting");
static_assert(sizeof(InteracterComponent_IsInteracting) == 0x000001, "Wrong size on InteracterComponent_IsInteracting");
static_assert(offsetof(InteracterComponent_IsInteracting, ReturnValue) == 0x000000, "Member 'InteracterComponent_IsInteracting::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.IsInteractTypeBlocked
// 0x0010 (0x0010 - 0x0000)
struct InteracterComponent_IsInteractTypeBlocked final
{
public:
	class UInteractableComponent*                 InteractableComp;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InteracterComponent_IsInteractTypeBlocked) == 0x000008, "Wrong alignment on InteracterComponent_IsInteractTypeBlocked");
static_assert(sizeof(InteracterComponent_IsInteractTypeBlocked) == 0x000010, "Wrong size on InteracterComponent_IsInteractTypeBlocked");
static_assert(offsetof(InteracterComponent_IsInteractTypeBlocked, InteractableComp) == 0x000000, "Member 'InteracterComponent_IsInteractTypeBlocked::InteractableComp' has a wrong offset!");
static_assert(offsetof(InteracterComponent_IsInteractTypeBlocked, ReturnValue) == 0x000008, "Member 'InteracterComponent_IsInteractTypeBlocked::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.IsLocalInteracter
// 0x0001 (0x0001 - 0x0000)
struct InteracterComponent_IsLocalInteracter final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteracterComponent_IsLocalInteracter) == 0x000001, "Wrong alignment on InteracterComponent_IsLocalInteracter");
static_assert(sizeof(InteracterComponent_IsLocalInteracter) == 0x000001, "Wrong size on InteracterComponent_IsLocalInteracter");
static_assert(offsetof(InteracterComponent_IsLocalInteracter, ReturnValue) == 0x000000, "Member 'InteracterComponent_IsLocalInteracter::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.IsValidInteractCancelType
// 0x0002 (0x0002 - 0x0000)
struct InteracterComponent_IsValidInteractCancelType final
{
public:
	EInteractCancelType                           InteractCancelType;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteracterComponent_IsValidInteractCancelType) == 0x000001, "Wrong alignment on InteracterComponent_IsValidInteractCancelType");
static_assert(sizeof(InteracterComponent_IsValidInteractCancelType) == 0x000002, "Wrong size on InteracterComponent_IsValidInteractCancelType");
static_assert(offsetof(InteracterComponent_IsValidInteractCancelType, InteractCancelType) == 0x000000, "Member 'InteracterComponent_IsValidInteractCancelType::InteractCancelType' has a wrong offset!");
static_assert(offsetof(InteracterComponent_IsValidInteractCancelType, ReturnValue) == 0x000001, "Member 'InteracterComponent_IsValidInteractCancelType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteracterComponent.IsValidInteractType
// 0x0010 (0x0010 - 0x0000)
struct InteracterComponent_IsValidInteractType final
{
public:
	class UInteractableComponent*                 InteractableComp;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckIfBlocked;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InteracterComponent_IsValidInteractType) == 0x000008, "Wrong alignment on InteracterComponent_IsValidInteractType");
static_assert(sizeof(InteracterComponent_IsValidInteractType) == 0x000010, "Wrong size on InteracterComponent_IsValidInteractType");
static_assert(offsetof(InteracterComponent_IsValidInteractType, InteractableComp) == 0x000000, "Member 'InteracterComponent_IsValidInteractType::InteractableComp' has a wrong offset!");
static_assert(offsetof(InteracterComponent_IsValidInteractType, bCheckIfBlocked) == 0x000008, "Member 'InteracterComponent_IsValidInteractType::bCheckIfBlocked' has a wrong offset!");
static_assert(offsetof(InteracterComponent_IsValidInteractType, ReturnValue) == 0x000009, "Member 'InteracterComponent_IsValidInteractType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.RangeInteracterComponent.HandleComponentBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct RangeInteracterComponent_HandleComponentBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangeInteracterComponent_HandleComponentBeginOverlap) == 0x000008, "Wrong alignment on RangeInteracterComponent_HandleComponentBeginOverlap");
static_assert(sizeof(RangeInteracterComponent_HandleComponentBeginOverlap) == 0x0000A8, "Wrong size on RangeInteracterComponent_HandleComponentBeginOverlap");
static_assert(offsetof(RangeInteracterComponent_HandleComponentBeginOverlap, OverlappedComponent) == 0x000000, "Member 'RangeInteracterComponent_HandleComponentBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(RangeInteracterComponent_HandleComponentBeginOverlap, OtherActor) == 0x000008, "Member 'RangeInteracterComponent_HandleComponentBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(RangeInteracterComponent_HandleComponentBeginOverlap, OtherComp) == 0x000010, "Member 'RangeInteracterComponent_HandleComponentBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(RangeInteracterComponent_HandleComponentBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'RangeInteracterComponent_HandleComponentBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(RangeInteracterComponent_HandleComponentBeginOverlap, bFromSweep) == 0x00001C, "Member 'RangeInteracterComponent_HandleComponentBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(RangeInteracterComponent_HandleComponentBeginOverlap, SweepResult) == 0x000020, "Member 'RangeInteracterComponent_HandleComponentBeginOverlap::SweepResult' has a wrong offset!");

// Function DeceiveInc.RangeInteracterComponent.HandleComponentEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct RangeInteracterComponent_HandleComponentEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RangeInteracterComponent_HandleComponentEndOverlap) == 0x000008, "Wrong alignment on RangeInteracterComponent_HandleComponentEndOverlap");
static_assert(sizeof(RangeInteracterComponent_HandleComponentEndOverlap) == 0x000020, "Wrong size on RangeInteracterComponent_HandleComponentEndOverlap");
static_assert(offsetof(RangeInteracterComponent_HandleComponentEndOverlap, OverlappedComponent) == 0x000000, "Member 'RangeInteracterComponent_HandleComponentEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(RangeInteracterComponent_HandleComponentEndOverlap, OtherActor) == 0x000008, "Member 'RangeInteracterComponent_HandleComponentEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(RangeInteracterComponent_HandleComponentEndOverlap, OtherComp) == 0x000010, "Member 'RangeInteracterComponent_HandleComponentEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(RangeInteracterComponent_HandleComponentEndOverlap, OtherBodyIndex) == 0x000018, "Member 'RangeInteracterComponent_HandleComponentEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function DeceiveInc.BasePlaceableSpyTool.Client_OnDeployedToolDestroyed
// 0x0001 (0x0001 - 0x0000)
struct BasePlaceableSpyTool_Client_OnDeployedToolDestroyed final
{
public:
	bool                                          bRecycled;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasePlaceableSpyTool_Client_OnDeployedToolDestroyed) == 0x000001, "Wrong alignment on BasePlaceableSpyTool_Client_OnDeployedToolDestroyed");
static_assert(sizeof(BasePlaceableSpyTool_Client_OnDeployedToolDestroyed) == 0x000001, "Wrong size on BasePlaceableSpyTool_Client_OnDeployedToolDestroyed");
static_assert(offsetof(BasePlaceableSpyTool_Client_OnDeployedToolDestroyed, bRecycled) == 0x000000, "Member 'BasePlaceableSpyTool_Client_OnDeployedToolDestroyed::bRecycled' has a wrong offset!");

// Function DeceiveInc.BasePlaceableSpyTool.GetPlaceableActor
// 0x0010 (0x0010 - 0x0000)
struct BasePlaceableSpyTool_GetPlaceableActor final
{
public:
	TArray<class ABasePlaceable*>                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasePlaceableSpyTool_GetPlaceableActor) == 0x000008, "Wrong alignment on BasePlaceableSpyTool_GetPlaceableActor");
static_assert(sizeof(BasePlaceableSpyTool_GetPlaceableActor) == 0x000010, "Wrong size on BasePlaceableSpyTool_GetPlaceableActor");
static_assert(offsetof(BasePlaceableSpyTool_GetPlaceableActor, ReturnValue) == 0x000000, "Member 'BasePlaceableSpyTool_GetPlaceableActor::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BasePlaceableSpyTool.HandleChargeAmountChange
// 0x0004 (0x0004 - 0x0000)
struct BasePlaceableSpyTool_HandleChargeAmountChange final
{
public:
	int32                                         Amount;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasePlaceableSpyTool_HandleChargeAmountChange) == 0x000004, "Wrong alignment on BasePlaceableSpyTool_HandleChargeAmountChange");
static_assert(sizeof(BasePlaceableSpyTool_HandleChargeAmountChange) == 0x000004, "Wrong size on BasePlaceableSpyTool_HandleChargeAmountChange");
static_assert(offsetof(BasePlaceableSpyTool_HandleChargeAmountChange, Amount) == 0x000000, "Member 'BasePlaceableSpyTool_HandleChargeAmountChange::Amount' has a wrong offset!");

// Function DeceiveInc.BasePlaceableSpyTool.HandleIsEnableChanged
// 0x0001 (0x0001 - 0x0000)
struct BasePlaceableSpyTool_HandleIsEnableChanged final
{
public:
	bool                                          bIsEnabled;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasePlaceableSpyTool_HandleIsEnableChanged) == 0x000001, "Wrong alignment on BasePlaceableSpyTool_HandleIsEnableChanged");
static_assert(sizeof(BasePlaceableSpyTool_HandleIsEnableChanged) == 0x000001, "Wrong size on BasePlaceableSpyTool_HandleIsEnableChanged");
static_assert(offsetof(BasePlaceableSpyTool_HandleIsEnableChanged, bIsEnabled) == 0x000000, "Member 'BasePlaceableSpyTool_HandleIsEnableChanged::bIsEnabled' has a wrong offset!");

// Function DeceiveInc.BasePlaceableSpyTool.OnCooldownChange
// 0x0001 (0x0001 - 0x0000)
struct BasePlaceableSpyTool_OnCooldownChange final
{
public:
	bool                                          bOnCooldown;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasePlaceableSpyTool_OnCooldownChange) == 0x000001, "Wrong alignment on BasePlaceableSpyTool_OnCooldownChange");
static_assert(sizeof(BasePlaceableSpyTool_OnCooldownChange) == 0x000001, "Wrong size on BasePlaceableSpyTool_OnCooldownChange");
static_assert(offsetof(BasePlaceableSpyTool_OnCooldownChange, bOnCooldown) == 0x000000, "Member 'BasePlaceableSpyTool_OnCooldownChange::bOnCooldown' has a wrong offset!");

// Function DeceiveInc.BasePlaceableSpyTool.OnPlaceableActorDestroyed
// 0x0008 (0x0008 - 0x0000)
struct BasePlaceableSpyTool_OnPlaceableActorDestroyed final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasePlaceableSpyTool_OnPlaceableActorDestroyed) == 0x000008, "Wrong alignment on BasePlaceableSpyTool_OnPlaceableActorDestroyed");
static_assert(sizeof(BasePlaceableSpyTool_OnPlaceableActorDestroyed) == 0x000008, "Wrong size on BasePlaceableSpyTool_OnPlaceableActorDestroyed");
static_assert(offsetof(BasePlaceableSpyTool_OnPlaceableActorDestroyed, DestroyedActor) == 0x000000, "Member 'BasePlaceableSpyTool_OnPlaceableActorDestroyed::DestroyedActor' has a wrong offset!");

// Function DeceiveInc.BasePlaceableSpyTool.OnPlaceableSpawned
// 0x0008 (0x0008 - 0x0000)
struct BasePlaceableSpyTool_OnPlaceableSpawned final
{
public:
	class ABasePlaceable*                         NewPlaceable;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasePlaceableSpyTool_OnPlaceableSpawned) == 0x000008, "Wrong alignment on BasePlaceableSpyTool_OnPlaceableSpawned");
static_assert(sizeof(BasePlaceableSpyTool_OnPlaceableSpawned) == 0x000008, "Wrong size on BasePlaceableSpyTool_OnPlaceableSpawned");
static_assert(offsetof(BasePlaceableSpyTool_OnPlaceableSpawned, NewPlaceable) == 0x000000, "Member 'BasePlaceableSpyTool_OnPlaceableSpawned::NewPlaceable' has a wrong offset!");

// Function DeceiveInc.BasePlaceableSpyTool.IsToolOrPlaceableEnable
// 0x0001 (0x0001 - 0x0000)
struct BasePlaceableSpyTool_IsToolOrPlaceableEnable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasePlaceableSpyTool_IsToolOrPlaceableEnable) == 0x000001, "Wrong alignment on BasePlaceableSpyTool_IsToolOrPlaceableEnable");
static_assert(sizeof(BasePlaceableSpyTool_IsToolOrPlaceableEnable) == 0x000001, "Wrong size on BasePlaceableSpyTool_IsToolOrPlaceableEnable");
static_assert(offsetof(BasePlaceableSpyTool_IsToolOrPlaceableEnable, ReturnValue) == 0x000000, "Member 'BasePlaceableSpyTool_IsToolOrPlaceableEnable::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SquirePassiveAbilityMod1.HandlePingDurationCooldownChange
// 0x0001 (0x0001 - 0x0000)
struct SquirePassiveAbilityMod1_HandlePingDurationCooldownChange final
{
public:
	bool                                          OnCooldown;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SquirePassiveAbilityMod1_HandlePingDurationCooldownChange) == 0x000001, "Wrong alignment on SquirePassiveAbilityMod1_HandlePingDurationCooldownChange");
static_assert(sizeof(SquirePassiveAbilityMod1_HandlePingDurationCooldownChange) == 0x000001, "Wrong size on SquirePassiveAbilityMod1_HandlePingDurationCooldownChange");
static_assert(offsetof(SquirePassiveAbilityMod1_HandlePingDurationCooldownChange, OnCooldown) == 0x000000, "Member 'SquirePassiveAbilityMod1_HandlePingDurationCooldownChange::OnCooldown' has a wrong offset!");

// Function DeceiveInc.SquirePassiveAbilityMod1.HandleUnderCoverChanged
// 0x0001 (0x0001 - 0x0000)
struct SquirePassiveAbilityMod1_HandleUnderCoverChanged final
{
public:
	bool                                          bUndercover;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SquirePassiveAbilityMod1_HandleUnderCoverChanged) == 0x000001, "Wrong alignment on SquirePassiveAbilityMod1_HandleUnderCoverChanged");
static_assert(sizeof(SquirePassiveAbilityMod1_HandleUnderCoverChanged) == 0x000001, "Wrong size on SquirePassiveAbilityMod1_HandleUnderCoverChanged");
static_assert(offsetof(SquirePassiveAbilityMod1_HandleUnderCoverChanged, bUndercover) == 0x000000, "Member 'SquirePassiveAbilityMod1_HandleUnderCoverChanged::bUndercover' has a wrong offset!");

// Function DeceiveInc.BasePositionerComponent.BP_OnPositioningActorSpawned
// 0x0008 (0x0008 - 0x0000)
struct BasePositionerComponent_BP_OnPositioningActorSpawned final
{
public:
	class AActor*                                 ActorSpawned;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasePositionerComponent_BP_OnPositioningActorSpawned) == 0x000008, "Wrong alignment on BasePositionerComponent_BP_OnPositioningActorSpawned");
static_assert(sizeof(BasePositionerComponent_BP_OnPositioningActorSpawned) == 0x000008, "Wrong size on BasePositionerComponent_BP_OnPositioningActorSpawned");
static_assert(offsetof(BasePositionerComponent_BP_OnPositioningActorSpawned, ActorSpawned) == 0x000000, "Member 'BasePositionerComponent_BP_OnPositioningActorSpawned::ActorSpawned' has a wrong offset!");

// Function DeceiveInc.BasePositionerComponent.IsPositioningActorVisible
// 0x0001 (0x0001 - 0x0000)
struct BasePositionerComponent_IsPositioningActorVisible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasePositionerComponent_IsPositioningActorVisible) == 0x000001, "Wrong alignment on BasePositionerComponent_IsPositioningActorVisible");
static_assert(sizeof(BasePositionerComponent_IsPositioningActorVisible) == 0x000001, "Wrong size on BasePositionerComponent_IsPositioningActorVisible");
static_assert(offsetof(BasePositionerComponent_IsPositioningActorVisible, ReturnValue) == 0x000000, "Member 'BasePositionerComponent_IsPositioningActorVisible::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BasePowerupChestActor.HandleResourceSpent
// 0x0010 (0x0010 - 0x0000)
struct BasePowerupChestActor_HandleResourceSpent final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayResourcesType                        ResourceType;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasePowerupChestActor_HandleResourceSpent) == 0x000008, "Wrong alignment on BasePowerupChestActor_HandleResourceSpent");
static_assert(sizeof(BasePowerupChestActor_HandleResourceSpent) == 0x000010, "Wrong size on BasePowerupChestActor_HandleResourceSpent");
static_assert(offsetof(BasePowerupChestActor_HandleResourceSpent, Interacter) == 0x000000, "Member 'BasePowerupChestActor_HandleResourceSpent::Interacter' has a wrong offset!");
static_assert(offsetof(BasePowerupChestActor_HandleResourceSpent, ResourceType) == 0x000008, "Member 'BasePowerupChestActor_HandleResourceSpent::ResourceType' has a wrong offset!");
static_assert(offsetof(BasePowerupChestActor_HandleResourceSpent, Amount) == 0x00000C, "Member 'BasePowerupChestActor_HandleResourceSpent::Amount' has a wrong offset!");

// Function DeceiveInc.BaseScannerTool.Server_CompleteScan
// 0x0008 (0x0008 - 0x0000)
struct BaseScannerTool_Server_CompleteScan final
{
public:
	class UScannableComponent*                    Scannable;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseScannerTool_Server_CompleteScan) == 0x000008, "Wrong alignment on BaseScannerTool_Server_CompleteScan");
static_assert(sizeof(BaseScannerTool_Server_CompleteScan) == 0x000008, "Wrong size on BaseScannerTool_Server_CompleteScan");
static_assert(offsetof(BaseScannerTool_Server_CompleteScan, Scannable) == 0x000000, "Member 'BaseScannerTool_Server_CompleteScan::Scannable' has a wrong offset!");

// Function DeceiveInc.BaseScannerTool.GetScanDistance
// 0x0004 (0x0004 - 0x0000)
struct BaseScannerTool_GetScanDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseScannerTool_GetScanDistance) == 0x000004, "Wrong alignment on BaseScannerTool_GetScanDistance");
static_assert(sizeof(BaseScannerTool_GetScanDistance) == 0x000004, "Wrong size on BaseScannerTool_GetScanDistance");
static_assert(offsetof(BaseScannerTool_GetScanDistance, ReturnValue) == 0x000000, "Member 'BaseScannerTool_GetScanDistance::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BaseScannerTool.GetScanDuration
// 0x0004 (0x0004 - 0x0000)
struct BaseScannerTool_GetScanDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseScannerTool_GetScanDuration) == 0x000004, "Wrong alignment on BaseScannerTool_GetScanDuration");
static_assert(sizeof(BaseScannerTool_GetScanDuration) == 0x000004, "Wrong size on BaseScannerTool_GetScanDuration");
static_assert(offsetof(BaseScannerTool_GetScanDuration, ReturnValue) == 0x000000, "Member 'BaseScannerTool_GetScanDuration::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiCharacterSelectCheckBox.GetAgentAvailabilityState
// 0x0001 (0x0001 - 0x0000)
struct DiCharacterSelectCheckBox_GetAgentAvailabilityState final
{
public:
	ECharacterSelectAgentAvailability             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiCharacterSelectCheckBox_GetAgentAvailabilityState) == 0x000001, "Wrong alignment on DiCharacterSelectCheckBox_GetAgentAvailabilityState");
static_assert(sizeof(DiCharacterSelectCheckBox_GetAgentAvailabilityState) == 0x000001, "Wrong size on DiCharacterSelectCheckBox_GetAgentAvailabilityState");
static_assert(offsetof(DiCharacterSelectCheckBox_GetAgentAvailabilityState, ReturnValue) == 0x000000, "Member 'DiCharacterSelectCheckBox_GetAgentAvailabilityState::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiCharacterSelectCheckBox.SetAgentData
// 0x0008 (0x0008 - 0x0000)
struct DiCharacterSelectCheckBox_SetAgentData final
{
public:
	class UAgentData*                             InAgentData;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiCharacterSelectCheckBox_SetAgentData) == 0x000008, "Wrong alignment on DiCharacterSelectCheckBox_SetAgentData");
static_assert(sizeof(DiCharacterSelectCheckBox_SetAgentData) == 0x000008, "Wrong size on DiCharacterSelectCheckBox_SetAgentData");
static_assert(offsetof(DiCharacterSelectCheckBox_SetAgentData, InAgentData) == 0x000000, "Member 'DiCharacterSelectCheckBox_SetAgentData::InAgentData' has a wrong offset!");

// Function DeceiveInc.DiCharacterSelectCheckBox.GetAgentData
// 0x0008 (0x0008 - 0x0000)
struct DiCharacterSelectCheckBox_GetAgentData final
{
public:
	class UAgentData*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiCharacterSelectCheckBox_GetAgentData) == 0x000008, "Wrong alignment on DiCharacterSelectCheckBox_GetAgentData");
static_assert(sizeof(DiCharacterSelectCheckBox_GetAgentData) == 0x000008, "Wrong size on DiCharacterSelectCheckBox_GetAgentData");
static_assert(offsetof(DiCharacterSelectCheckBox_GetAgentData, ReturnValue) == 0x000000, "Member 'DiCharacterSelectCheckBox_GetAgentData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.CHEATGetHideFriendlyGadgetOverlay
// 0x0001 (0x0001 - 0x0000)
struct SweetBPLibrary_CHEATGetHideFriendlyGadgetOverlay final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_CHEATGetHideFriendlyGadgetOverlay) == 0x000001, "Wrong alignment on SweetBPLibrary_CHEATGetHideFriendlyGadgetOverlay");
static_assert(sizeof(SweetBPLibrary_CHEATGetHideFriendlyGadgetOverlay) == 0x000001, "Wrong size on SweetBPLibrary_CHEATGetHideFriendlyGadgetOverlay");
static_assert(offsetof(SweetBPLibrary_CHEATGetHideFriendlyGadgetOverlay, ReturnValue) == 0x000000, "Member 'SweetBPLibrary_CHEATGetHideFriendlyGadgetOverlay::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.DisableParticleSystemNom
// 0x0008 (0x0008 - 0x0000)
struct SweetBPLibrary_DisableParticleSystemNom final
{
public:
	class UFXSystemComponent*                     ParticleSystem;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_DisableParticleSystemNom) == 0x000008, "Wrong alignment on SweetBPLibrary_DisableParticleSystemNom");
static_assert(sizeof(SweetBPLibrary_DisableParticleSystemNom) == 0x000008, "Wrong size on SweetBPLibrary_DisableParticleSystemNom");
static_assert(offsetof(SweetBPLibrary_DisableParticleSystemNom, ParticleSystem) == 0x000000, "Member 'SweetBPLibrary_DisableParticleSystemNom::ParticleSystem' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.EnableDrawActorMeshCollisions
// 0x0010 (0x0010 - 0x0000)
struct SweetBPLibrary_EnableDrawActorMeshCollisions final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDraw;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SweetBPLibrary_EnableDrawActorMeshCollisions) == 0x000008, "Wrong alignment on SweetBPLibrary_EnableDrawActorMeshCollisions");
static_assert(sizeof(SweetBPLibrary_EnableDrawActorMeshCollisions) == 0x000010, "Wrong size on SweetBPLibrary_EnableDrawActorMeshCollisions");
static_assert(offsetof(SweetBPLibrary_EnableDrawActorMeshCollisions, TargetActor) == 0x000000, "Member 'SweetBPLibrary_EnableDrawActorMeshCollisions::TargetActor' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_EnableDrawActorMeshCollisions, bEnableDraw) == 0x000008, "Member 'SweetBPLibrary_EnableDrawActorMeshCollisions::bEnableDraw' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.EnumToIETFTag
// 0x0018 (0x0018 - 0x0000)
struct SweetBPLibrary_EnumToIETFTag final
{
public:
	ELocalizationLanguage                         LocEnum;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_EnumToIETFTag) == 0x000008, "Wrong alignment on SweetBPLibrary_EnumToIETFTag");
static_assert(sizeof(SweetBPLibrary_EnumToIETFTag) == 0x000018, "Wrong size on SweetBPLibrary_EnumToIETFTag");
static_assert(offsetof(SweetBPLibrary_EnumToIETFTag, LocEnum) == 0x000000, "Member 'SweetBPLibrary_EnumToIETFTag::LocEnum' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_EnumToIETFTag, ReturnValue) == 0x000008, "Member 'SweetBPLibrary_EnumToIETFTag::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.GetCurrentMapData
// 0x0010 (0x0010 - 0x0000)
struct SweetBPLibrary_GetCurrentMapData final
{
public:
	class UObject*                                Context;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMapData*                               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_GetCurrentMapData) == 0x000008, "Wrong alignment on SweetBPLibrary_GetCurrentMapData");
static_assert(sizeof(SweetBPLibrary_GetCurrentMapData) == 0x000010, "Wrong size on SweetBPLibrary_GetCurrentMapData");
static_assert(offsetof(SweetBPLibrary_GetCurrentMapData, Context) == 0x000000, "Member 'SweetBPLibrary_GetCurrentMapData::Context' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_GetCurrentMapData, ReturnValue) == 0x000008, "Member 'SweetBPLibrary_GetCurrentMapData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.GetCurrentMapName
// 0x0010 (0x0010 - 0x0000)
struct SweetBPLibrary_GetCurrentMapName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_GetCurrentMapName) == 0x000008, "Wrong alignment on SweetBPLibrary_GetCurrentMapName");
static_assert(sizeof(SweetBPLibrary_GetCurrentMapName) == 0x000010, "Wrong size on SweetBPLibrary_GetCurrentMapName");
static_assert(offsetof(SweetBPLibrary_GetCurrentMapName, ReturnValue) == 0x000000, "Member 'SweetBPLibrary_GetCurrentMapName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.GetCustomGamesAvailableMaps
// 0x0010 (0x0010 - 0x0000)
struct SweetBPLibrary_GetCustomGamesAvailableMaps final
{
public:
	TArray<class UMapData*>                       ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_GetCustomGamesAvailableMaps) == 0x000008, "Wrong alignment on SweetBPLibrary_GetCustomGamesAvailableMaps");
static_assert(sizeof(SweetBPLibrary_GetCustomGamesAvailableMaps) == 0x000010, "Wrong size on SweetBPLibrary_GetCustomGamesAvailableMaps");
static_assert(offsetof(SweetBPLibrary_GetCustomGamesAvailableMaps, ReturnValue) == 0x000000, "Member 'SweetBPLibrary_GetCustomGamesAvailableMaps::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.GetDeceiveIncGameState
// 0x0010 (0x0010 - 0x0000)
struct SweetBPLibrary_GetDeceiveIncGameState final
{
public:
	const class AActor*                           ContextActor;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGameStateBase*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_GetDeceiveIncGameState) == 0x000008, "Wrong alignment on SweetBPLibrary_GetDeceiveIncGameState");
static_assert(sizeof(SweetBPLibrary_GetDeceiveIncGameState) == 0x000010, "Wrong size on SweetBPLibrary_GetDeceiveIncGameState");
static_assert(offsetof(SweetBPLibrary_GetDeceiveIncGameState, ContextActor) == 0x000000, "Member 'SweetBPLibrary_GetDeceiveIncGameState::ContextActor' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_GetDeceiveIncGameState, ReturnValue) == 0x000008, "Member 'SweetBPLibrary_GetDeceiveIncGameState::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.GetDIPlayerControllerFromState
// 0x0010 (0x0010 - 0x0000)
struct SweetBPLibrary_GetDIPlayerControllerFromState final
{
public:
	const class ADIPlayerState*                   PlayerState;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADeceiveIncPlayerController*            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_GetDIPlayerControllerFromState) == 0x000008, "Wrong alignment on SweetBPLibrary_GetDIPlayerControllerFromState");
static_assert(sizeof(SweetBPLibrary_GetDIPlayerControllerFromState) == 0x000010, "Wrong size on SweetBPLibrary_GetDIPlayerControllerFromState");
static_assert(offsetof(SweetBPLibrary_GetDIPlayerControllerFromState, PlayerState) == 0x000000, "Member 'SweetBPLibrary_GetDIPlayerControllerFromState::PlayerState' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_GetDIPlayerControllerFromState, ReturnValue) == 0x000008, "Member 'SweetBPLibrary_GetDIPlayerControllerFromState::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.GetEditorDecryptedGUID
// 0x0020 (0x0020 - 0x0000)
struct SweetBPLibrary_GetEditorDecryptedGUID final
{
public:
	class FString                                 GuidToDecrypt;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_GetEditorDecryptedGUID) == 0x000008, "Wrong alignment on SweetBPLibrary_GetEditorDecryptedGUID");
static_assert(sizeof(SweetBPLibrary_GetEditorDecryptedGUID) == 0x000020, "Wrong size on SweetBPLibrary_GetEditorDecryptedGUID");
static_assert(offsetof(SweetBPLibrary_GetEditorDecryptedGUID, GuidToDecrypt) == 0x000000, "Member 'SweetBPLibrary_GetEditorDecryptedGUID::GuidToDecrypt' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_GetEditorDecryptedGUID, ReturnValue) == 0x000010, "Member 'SweetBPLibrary_GetEditorDecryptedGUID::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.GetEditorEncryptedGUID
// 0x0020 (0x0020 - 0x0000)
struct SweetBPLibrary_GetEditorEncryptedGUID final
{
public:
	class FString                                 GuidToEncrypt;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_GetEditorEncryptedGUID) == 0x000008, "Wrong alignment on SweetBPLibrary_GetEditorEncryptedGUID");
static_assert(sizeof(SweetBPLibrary_GetEditorEncryptedGUID) == 0x000020, "Wrong size on SweetBPLibrary_GetEditorEncryptedGUID");
static_assert(offsetof(SweetBPLibrary_GetEditorEncryptedGUID, GuidToEncrypt) == 0x000000, "Member 'SweetBPLibrary_GetEditorEncryptedGUID::GuidToEncrypt' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_GetEditorEncryptedGUID, ReturnValue) == 0x000010, "Member 'SweetBPLibrary_GetEditorEncryptedGUID::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.GetFirstLocalDIPlayerController
// 0x0008 (0x0008 - 0x0000)
struct SweetBPLibrary_GetFirstLocalDIPlayerController final
{
public:
	class ADeceiveIncPlayerController*            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_GetFirstLocalDIPlayerController) == 0x000008, "Wrong alignment on SweetBPLibrary_GetFirstLocalDIPlayerController");
static_assert(sizeof(SweetBPLibrary_GetFirstLocalDIPlayerController) == 0x000008, "Wrong size on SweetBPLibrary_GetFirstLocalDIPlayerController");
static_assert(offsetof(SweetBPLibrary_GetFirstLocalDIPlayerController, ReturnValue) == 0x000000, "Member 'SweetBPLibrary_GetFirstLocalDIPlayerController::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.GetKeysForAction
// 0x0028 (0x0028 - 0x0000)
struct SweetBPLibrary_GetKeysForAction final
{
public:
	class UInputAction*                           Action;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AxisScale;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKey>                           Bindings;                                          // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	EInputDeviceType                              DeviceType;                                        // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SweetBPLibrary_GetKeysForAction) == 0x000008, "Wrong alignment on SweetBPLibrary_GetKeysForAction");
static_assert(sizeof(SweetBPLibrary_GetKeysForAction) == 0x000028, "Wrong size on SweetBPLibrary_GetKeysForAction");
static_assert(offsetof(SweetBPLibrary_GetKeysForAction, Action) == 0x000000, "Member 'SweetBPLibrary_GetKeysForAction::Action' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_GetKeysForAction, AxisScale) == 0x000008, "Member 'SweetBPLibrary_GetKeysForAction::AxisScale' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_GetKeysForAction, Bindings) == 0x000010, "Member 'SweetBPLibrary_GetKeysForAction::Bindings' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_GetKeysForAction, DeviceType) == 0x000020, "Member 'SweetBPLibrary_GetKeysForAction::DeviceType' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.GetKeysForActionName
// 0x0028 (0x0028 - 0x0000)
struct SweetBPLibrary_GetKeysForActionName final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AxisScale;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKey>                           Bindings;                                          // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	EInputDeviceType                              DeviceType;                                        // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SweetBPLibrary_GetKeysForActionName) == 0x000008, "Wrong alignment on SweetBPLibrary_GetKeysForActionName");
static_assert(sizeof(SweetBPLibrary_GetKeysForActionName) == 0x000028, "Wrong size on SweetBPLibrary_GetKeysForActionName");
static_assert(offsetof(SweetBPLibrary_GetKeysForActionName, ActionName) == 0x000000, "Member 'SweetBPLibrary_GetKeysForActionName::ActionName' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_GetKeysForActionName, AxisScale) == 0x000008, "Member 'SweetBPLibrary_GetKeysForActionName::AxisScale' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_GetKeysForActionName, Bindings) == 0x000010, "Member 'SweetBPLibrary_GetKeysForActionName::Bindings' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_GetKeysForActionName, DeviceType) == 0x000020, "Member 'SweetBPLibrary_GetKeysForActionName::DeviceType' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.GetLastUsedInputDeviceType
// 0x0001 (0x0001 - 0x0000)
struct SweetBPLibrary_GetLastUsedInputDeviceType final
{
public:
	EInputDeviceType                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_GetLastUsedInputDeviceType) == 0x000001, "Wrong alignment on SweetBPLibrary_GetLastUsedInputDeviceType");
static_assert(sizeof(SweetBPLibrary_GetLastUsedInputDeviceType) == 0x000001, "Wrong size on SweetBPLibrary_GetLastUsedInputDeviceType");
static_assert(offsetof(SweetBPLibrary_GetLastUsedInputDeviceType, ReturnValue) == 0x000000, "Member 'SweetBPLibrary_GetLastUsedInputDeviceType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.GetLocalDIPlayerController
// 0x0010 (0x0010 - 0x0000)
struct SweetBPLibrary_GetLocalDIPlayerController final
{
public:
	class UObject*                                Context;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADeceiveIncPlayerController*            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_GetLocalDIPlayerController) == 0x000008, "Wrong alignment on SweetBPLibrary_GetLocalDIPlayerController");
static_assert(sizeof(SweetBPLibrary_GetLocalDIPlayerController) == 0x000010, "Wrong size on SweetBPLibrary_GetLocalDIPlayerController");
static_assert(offsetof(SweetBPLibrary_GetLocalDIPlayerController, Context) == 0x000000, "Member 'SweetBPLibrary_GetLocalDIPlayerController::Context' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_GetLocalDIPlayerController, ReturnValue) == 0x000008, "Member 'SweetBPLibrary_GetLocalDIPlayerController::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.GetLocalisedValueInEnumMap
// 0x0068 (0x0068 - 0x0000)
struct SweetBPLibrary_GetLocalisedValueInEnumMap final
{
public:
	TMap<ELocalizationLanguage, class FText>      LocalisedMap;                                      // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0050(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_GetLocalisedValueInEnumMap) == 0x000008, "Wrong alignment on SweetBPLibrary_GetLocalisedValueInEnumMap");
static_assert(sizeof(SweetBPLibrary_GetLocalisedValueInEnumMap) == 0x000068, "Wrong size on SweetBPLibrary_GetLocalisedValueInEnumMap");
static_assert(offsetof(SweetBPLibrary_GetLocalisedValueInEnumMap, LocalisedMap) == 0x000000, "Member 'SweetBPLibrary_GetLocalisedValueInEnumMap::LocalisedMap' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_GetLocalisedValueInEnumMap, ReturnValue) == 0x000050, "Member 'SweetBPLibrary_GetLocalisedValueInEnumMap::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.GetLocalisedValueInMap
// 0x0068 (0x0068 - 0x0000)
struct SweetBPLibrary_GetLocalisedValueInMap final
{
public:
	TMap<class FString, class FString>            LocalisedMap;                                      // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0050(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_GetLocalisedValueInMap) == 0x000008, "Wrong alignment on SweetBPLibrary_GetLocalisedValueInMap");
static_assert(sizeof(SweetBPLibrary_GetLocalisedValueInMap) == 0x000068, "Wrong size on SweetBPLibrary_GetLocalisedValueInMap");
static_assert(offsetof(SweetBPLibrary_GetLocalisedValueInMap, LocalisedMap) == 0x000000, "Member 'SweetBPLibrary_GetLocalisedValueInMap::LocalisedMap' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_GetLocalisedValueInMap, ReturnValue) == 0x000050, "Member 'SweetBPLibrary_GetLocalisedValueInMap::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.GetNameOfKey
// 0x0028 (0x0028 - 0x0000)
struct SweetBPLibrary_GetNameOfKey final
{
public:
	struct FKey                                   TheKey;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_GetNameOfKey) == 0x000008, "Wrong alignment on SweetBPLibrary_GetNameOfKey");
static_assert(sizeof(SweetBPLibrary_GetNameOfKey) == 0x000028, "Wrong size on SweetBPLibrary_GetNameOfKey");
static_assert(offsetof(SweetBPLibrary_GetNameOfKey, TheKey) == 0x000000, "Member 'SweetBPLibrary_GetNameOfKey::TheKey' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_GetNameOfKey, ReturnValue) == 0x000018, "Member 'SweetBPLibrary_GetNameOfKey::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.GetRandomlyGeneratedUserName
// 0x0010 (0x0010 - 0x0000)
struct SweetBPLibrary_GetRandomlyGeneratedUserName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_GetRandomlyGeneratedUserName) == 0x000008, "Wrong alignment on SweetBPLibrary_GetRandomlyGeneratedUserName");
static_assert(sizeof(SweetBPLibrary_GetRandomlyGeneratedUserName) == 0x000010, "Wrong size on SweetBPLibrary_GetRandomlyGeneratedUserName");
static_assert(offsetof(SweetBPLibrary_GetRandomlyGeneratedUserName, ReturnValue) == 0x000000, "Member 'SweetBPLibrary_GetRandomlyGeneratedUserName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.GetUtcNowInSeconds
// 0x0008 (0x0008 - 0x0000)
struct SweetBPLibrary_GetUtcNowInSeconds final
{
public:
	int64                                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_GetUtcNowInSeconds) == 0x000008, "Wrong alignment on SweetBPLibrary_GetUtcNowInSeconds");
static_assert(sizeof(SweetBPLibrary_GetUtcNowInSeconds) == 0x000008, "Wrong size on SweetBPLibrary_GetUtcNowInSeconds");
static_assert(offsetof(SweetBPLibrary_GetUtcNowInSeconds, ReturnValue) == 0x000000, "Member 'SweetBPLibrary_GetUtcNowInSeconds::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.IETFTagToEnum
// 0x0018 (0x0018 - 0x0000)
struct SweetBPLibrary_IETFTagToEnum final
{
public:
	class FString                                 IETFTag;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocalizationLanguage                         ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SweetBPLibrary_IETFTagToEnum) == 0x000008, "Wrong alignment on SweetBPLibrary_IETFTagToEnum");
static_assert(sizeof(SweetBPLibrary_IETFTagToEnum) == 0x000018, "Wrong size on SweetBPLibrary_IETFTagToEnum");
static_assert(offsetof(SweetBPLibrary_IETFTagToEnum, IETFTag) == 0x000000, "Member 'SweetBPLibrary_IETFTagToEnum::IETFTag' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_IETFTagToEnum, ReturnValue) == 0x000010, "Member 'SweetBPLibrary_IETFTagToEnum::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.IsAllowingCheats
// 0x0001 (0x0001 - 0x0000)
struct SweetBPLibrary_IsAllowingCheats final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_IsAllowingCheats) == 0x000001, "Wrong alignment on SweetBPLibrary_IsAllowingCheats");
static_assert(sizeof(SweetBPLibrary_IsAllowingCheats) == 0x000001, "Wrong size on SweetBPLibrary_IsAllowingCheats");
static_assert(offsetof(SweetBPLibrary_IsAllowingCheats, ReturnValue) == 0x000000, "Member 'SweetBPLibrary_IsAllowingCheats::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.IsBodyHit
// 0x0002 (0x0002 - 0x0000)
struct SweetBPLibrary_IsBodyHit final
{
public:
	EHitType                                      HitType;                                           // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_IsBodyHit) == 0x000001, "Wrong alignment on SweetBPLibrary_IsBodyHit");
static_assert(sizeof(SweetBPLibrary_IsBodyHit) == 0x000002, "Wrong size on SweetBPLibrary_IsBodyHit");
static_assert(offsetof(SweetBPLibrary_IsBodyHit, HitType) == 0x000000, "Member 'SweetBPLibrary_IsBodyHit::HitType' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_IsBodyHit, ReturnValue) == 0x000001, "Member 'SweetBPLibrary_IsBodyHit::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.IsConsoleBuild
// 0x0001 (0x0001 - 0x0000)
struct SweetBPLibrary_IsConsoleBuild final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_IsConsoleBuild) == 0x000001, "Wrong alignment on SweetBPLibrary_IsConsoleBuild");
static_assert(sizeof(SweetBPLibrary_IsConsoleBuild) == 0x000001, "Wrong size on SweetBPLibrary_IsConsoleBuild");
static_assert(offsetof(SweetBPLibrary_IsConsoleBuild, ReturnValue) == 0x000000, "Member 'SweetBPLibrary_IsConsoleBuild::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.IsCriticalHit
// 0x0002 (0x0002 - 0x0000)
struct SweetBPLibrary_IsCriticalHit final
{
public:
	EHitType                                      HitType;                                           // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_IsCriticalHit) == 0x000001, "Wrong alignment on SweetBPLibrary_IsCriticalHit");
static_assert(sizeof(SweetBPLibrary_IsCriticalHit) == 0x000002, "Wrong size on SweetBPLibrary_IsCriticalHit");
static_assert(offsetof(SweetBPLibrary_IsCriticalHit, HitType) == 0x000000, "Member 'SweetBPLibrary_IsCriticalHit::HitType' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_IsCriticalHit, ReturnValue) == 0x000001, "Member 'SweetBPLibrary_IsCriticalHit::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.IsDebugBuild
// 0x0001 (0x0001 - 0x0000)
struct SweetBPLibrary_IsDebugBuild final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_IsDebugBuild) == 0x000001, "Wrong alignment on SweetBPLibrary_IsDebugBuild");
static_assert(sizeof(SweetBPLibrary_IsDebugBuild) == 0x000001, "Wrong size on SweetBPLibrary_IsDebugBuild");
static_assert(offsetof(SweetBPLibrary_IsDebugBuild, ReturnValue) == 0x000000, "Member 'SweetBPLibrary_IsDebugBuild::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.IsEditorBuild
// 0x0001 (0x0001 - 0x0000)
struct SweetBPLibrary_IsEditorBuild final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_IsEditorBuild) == 0x000001, "Wrong alignment on SweetBPLibrary_IsEditorBuild");
static_assert(sizeof(SweetBPLibrary_IsEditorBuild) == 0x000001, "Wrong size on SweetBPLibrary_IsEditorBuild");
static_assert(offsetof(SweetBPLibrary_IsEditorBuild, ReturnValue) == 0x000000, "Member 'SweetBPLibrary_IsEditorBuild::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.IsInKillcamReplay
// 0x0010 (0x0010 - 0x0000)
struct SweetBPLibrary_IsInKillcamReplay final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SweetBPLibrary_IsInKillcamReplay) == 0x000008, "Wrong alignment on SweetBPLibrary_IsInKillcamReplay");
static_assert(sizeof(SweetBPLibrary_IsInKillcamReplay) == 0x000010, "Wrong size on SweetBPLibrary_IsInKillcamReplay");
static_assert(offsetof(SweetBPLibrary_IsInKillcamReplay, WorldContextObject) == 0x000000, "Member 'SweetBPLibrary_IsInKillcamReplay::WorldContextObject' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_IsInKillcamReplay, ReturnValue) == 0x000008, "Member 'SweetBPLibrary_IsInKillcamReplay::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.IsInMainMenuLevel
// 0x0001 (0x0001 - 0x0000)
struct SweetBPLibrary_IsInMainMenuLevel final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_IsInMainMenuLevel) == 0x000001, "Wrong alignment on SweetBPLibrary_IsInMainMenuLevel");
static_assert(sizeof(SweetBPLibrary_IsInMainMenuLevel) == 0x000001, "Wrong size on SweetBPLibrary_IsInMainMenuLevel");
static_assert(offsetof(SweetBPLibrary_IsInMainMenuLevel, ReturnValue) == 0x000000, "Member 'SweetBPLibrary_IsInMainMenuLevel::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.IsLimbHit
// 0x0002 (0x0002 - 0x0000)
struct SweetBPLibrary_IsLimbHit final
{
public:
	EHitType                                      HitType;                                           // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_IsLimbHit) == 0x000001, "Wrong alignment on SweetBPLibrary_IsLimbHit");
static_assert(sizeof(SweetBPLibrary_IsLimbHit) == 0x000002, "Wrong size on SweetBPLibrary_IsLimbHit");
static_assert(offsetof(SweetBPLibrary_IsLimbHit, HitType) == 0x000000, "Member 'SweetBPLibrary_IsLimbHit::HitType' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_IsLimbHit, ReturnValue) == 0x000001, "Member 'SweetBPLibrary_IsLimbHit::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.IsLockheartConsole
// 0x0001 (0x0001 - 0x0000)
struct SweetBPLibrary_IsLockheartConsole final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_IsLockheartConsole) == 0x000001, "Wrong alignment on SweetBPLibrary_IsLockheartConsole");
static_assert(sizeof(SweetBPLibrary_IsLockheartConsole) == 0x000001, "Wrong size on SweetBPLibrary_IsLockheartConsole");
static_assert(offsetof(SweetBPLibrary_IsLockheartConsole, ReturnValue) == 0x000000, "Member 'SweetBPLibrary_IsLockheartConsole::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.IsMapDisabledForPrivateLobby
// 0x0018 (0x0018 - 0x0000)
struct SweetBPLibrary_IsMapDisabledForPrivateLobby final
{
public:
	class FString                                 MapName;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SweetBPLibrary_IsMapDisabledForPrivateLobby) == 0x000008, "Wrong alignment on SweetBPLibrary_IsMapDisabledForPrivateLobby");
static_assert(sizeof(SweetBPLibrary_IsMapDisabledForPrivateLobby) == 0x000018, "Wrong size on SweetBPLibrary_IsMapDisabledForPrivateLobby");
static_assert(offsetof(SweetBPLibrary_IsMapDisabledForPrivateLobby, MapName) == 0x000000, "Member 'SweetBPLibrary_IsMapDisabledForPrivateLobby::MapName' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_IsMapDisabledForPrivateLobby, ReturnValue) == 0x000010, "Member 'SweetBPLibrary_IsMapDisabledForPrivateLobby::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.IsOfflineBuild
// 0x0001 (0x0001 - 0x0000)
struct SweetBPLibrary_IsOfflineBuild final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_IsOfflineBuild) == 0x000001, "Wrong alignment on SweetBPLibrary_IsOfflineBuild");
static_assert(sizeof(SweetBPLibrary_IsOfflineBuild) == 0x000001, "Wrong size on SweetBPLibrary_IsOfflineBuild");
static_assert(offsetof(SweetBPLibrary_IsOfflineBuild, ReturnValue) == 0x000000, "Member 'SweetBPLibrary_IsOfflineBuild::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.IsShippingBuild
// 0x0001 (0x0001 - 0x0000)
struct SweetBPLibrary_IsShippingBuild final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_IsShippingBuild) == 0x000001, "Wrong alignment on SweetBPLibrary_IsShippingBuild");
static_assert(sizeof(SweetBPLibrary_IsShippingBuild) == 0x000001, "Wrong size on SweetBPLibrary_IsShippingBuild");
static_assert(offsetof(SweetBPLibrary_IsShippingBuild, ReturnValue) == 0x000000, "Member 'SweetBPLibrary_IsShippingBuild::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.SB_ApplyZoomFactorToFOV
// 0x000C (0x000C - 0x0000)
struct SweetBPLibrary_SB_ApplyZoomFactorToFOV final
{
public:
	float                                         BaseFOV;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomFactor;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_SB_ApplyZoomFactorToFOV) == 0x000004, "Wrong alignment on SweetBPLibrary_SB_ApplyZoomFactorToFOV");
static_assert(sizeof(SweetBPLibrary_SB_ApplyZoomFactorToFOV) == 0x00000C, "Wrong size on SweetBPLibrary_SB_ApplyZoomFactorToFOV");
static_assert(offsetof(SweetBPLibrary_SB_ApplyZoomFactorToFOV, BaseFOV) == 0x000000, "Member 'SweetBPLibrary_SB_ApplyZoomFactorToFOV::BaseFOV' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_ApplyZoomFactorToFOV, ZoomFactor) == 0x000004, "Member 'SweetBPLibrary_SB_ApplyZoomFactorToFOV::ZoomFactor' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_ApplyZoomFactorToFOV, ReturnValue) == 0x000008, "Member 'SweetBPLibrary_SB_ApplyZoomFactorToFOV::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.SB_AttachActorBoneToBone
// 0x0030 (0x0030 - 0x0000)
struct SweetBPLibrary_SB_AttachActorBoneToBone final
{
public:
	class USceneComponent*                        ToAttach;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ToAttachActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Parent;                                            // 0x0018(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParentSocket;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               ScaleRule;                                         // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeldSimulatedBodies;                              // 0x0029(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SweetBPLibrary_SB_AttachActorBoneToBone) == 0x000008, "Wrong alignment on SweetBPLibrary_SB_AttachActorBoneToBone");
static_assert(sizeof(SweetBPLibrary_SB_AttachActorBoneToBone) == 0x000030, "Wrong size on SweetBPLibrary_SB_AttachActorBoneToBone");
static_assert(offsetof(SweetBPLibrary_SB_AttachActorBoneToBone, ToAttach) == 0x000000, "Member 'SweetBPLibrary_SB_AttachActorBoneToBone::ToAttach' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_AttachActorBoneToBone, ToAttachActor) == 0x000008, "Member 'SweetBPLibrary_SB_AttachActorBoneToBone::ToAttachActor' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_AttachActorBoneToBone, Socket) == 0x000010, "Member 'SweetBPLibrary_SB_AttachActorBoneToBone::Socket' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_AttachActorBoneToBone, Parent) == 0x000018, "Member 'SweetBPLibrary_SB_AttachActorBoneToBone::Parent' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_AttachActorBoneToBone, ParentSocket) == 0x000020, "Member 'SweetBPLibrary_SB_AttachActorBoneToBone::ParentSocket' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_AttachActorBoneToBone, ScaleRule) == 0x000028, "Member 'SweetBPLibrary_SB_AttachActorBoneToBone::ScaleRule' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_AttachActorBoneToBone, bWeldSimulatedBodies) == 0x000029, "Member 'SweetBPLibrary_SB_AttachActorBoneToBone::bWeldSimulatedBodies' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.SB_AttachToActorValidateSocket
// 0x0020 (0x0020 - 0x0000)
struct SweetBPLibrary_SB_AttachToActorValidateSocket final
{
public:
	class AActor*                                 ToAttach;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ParentActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               LocationRule;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               RotationRule;                                      // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               ScaleRule;                                         // 0x001A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeldSimulatedBodies;                              // 0x001B(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SweetBPLibrary_SB_AttachToActorValidateSocket) == 0x000008, "Wrong alignment on SweetBPLibrary_SB_AttachToActorValidateSocket");
static_assert(sizeof(SweetBPLibrary_SB_AttachToActorValidateSocket) == 0x000020, "Wrong size on SweetBPLibrary_SB_AttachToActorValidateSocket");
static_assert(offsetof(SweetBPLibrary_SB_AttachToActorValidateSocket, ToAttach) == 0x000000, "Member 'SweetBPLibrary_SB_AttachToActorValidateSocket::ToAttach' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_AttachToActorValidateSocket, ParentActor) == 0x000008, "Member 'SweetBPLibrary_SB_AttachToActorValidateSocket::ParentActor' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_AttachToActorValidateSocket, SocketName) == 0x000010, "Member 'SweetBPLibrary_SB_AttachToActorValidateSocket::SocketName' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_AttachToActorValidateSocket, LocationRule) == 0x000018, "Member 'SweetBPLibrary_SB_AttachToActorValidateSocket::LocationRule' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_AttachToActorValidateSocket, RotationRule) == 0x000019, "Member 'SweetBPLibrary_SB_AttachToActorValidateSocket::RotationRule' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_AttachToActorValidateSocket, ScaleRule) == 0x00001A, "Member 'SweetBPLibrary_SB_AttachToActorValidateSocket::ScaleRule' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_AttachToActorValidateSocket, bWeldSimulatedBodies) == 0x00001B, "Member 'SweetBPLibrary_SB_AttachToActorValidateSocket::bWeldSimulatedBodies' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.SB_FindScreenEdgeLocationForWorldLocation
// 0x0040 (0x0040 - 0x0000)
struct SweetBPLibrary_SB_FindScreenEdgeLocationForWorldLocation final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InLocation;                                        // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      InPlayerController;                                // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EdgePercent;                                       // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ViewportCenterLoc;                                 // 0x0024(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OutScreenPosition;                                 // 0x002C(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutRotationAngleDegrees;                           // 0x0034(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOnScreen;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SweetBPLibrary_SB_FindScreenEdgeLocationForWorldLocation) == 0x000008, "Wrong alignment on SweetBPLibrary_SB_FindScreenEdgeLocationForWorldLocation");
static_assert(sizeof(SweetBPLibrary_SB_FindScreenEdgeLocationForWorldLocation) == 0x000040, "Wrong size on SweetBPLibrary_SB_FindScreenEdgeLocationForWorldLocation");
static_assert(offsetof(SweetBPLibrary_SB_FindScreenEdgeLocationForWorldLocation, WorldContextObject) == 0x000000, "Member 'SweetBPLibrary_SB_FindScreenEdgeLocationForWorldLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_FindScreenEdgeLocationForWorldLocation, InLocation) == 0x000008, "Member 'SweetBPLibrary_SB_FindScreenEdgeLocationForWorldLocation::InLocation' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_FindScreenEdgeLocationForWorldLocation, InPlayerController) == 0x000018, "Member 'SweetBPLibrary_SB_FindScreenEdgeLocationForWorldLocation::InPlayerController' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_FindScreenEdgeLocationForWorldLocation, EdgePercent) == 0x000020, "Member 'SweetBPLibrary_SB_FindScreenEdgeLocationForWorldLocation::EdgePercent' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_FindScreenEdgeLocationForWorldLocation, ViewportCenterLoc) == 0x000024, "Member 'SweetBPLibrary_SB_FindScreenEdgeLocationForWorldLocation::ViewportCenterLoc' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_FindScreenEdgeLocationForWorldLocation, OutScreenPosition) == 0x00002C, "Member 'SweetBPLibrary_SB_FindScreenEdgeLocationForWorldLocation::OutScreenPosition' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_FindScreenEdgeLocationForWorldLocation, OutRotationAngleDegrees) == 0x000034, "Member 'SweetBPLibrary_SB_FindScreenEdgeLocationForWorldLocation::OutRotationAngleDegrees' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_FindScreenEdgeLocationForWorldLocation, bIsOnScreen) == 0x000038, "Member 'SweetBPLibrary_SB_FindScreenEdgeLocationForWorldLocation::bIsOnScreen' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.SB_IsInPregame
// 0x0010 (0x0010 - 0x0000)
struct SweetBPLibrary_SB_IsInPregame final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SweetBPLibrary_SB_IsInPregame) == 0x000008, "Wrong alignment on SweetBPLibrary_SB_IsInPregame");
static_assert(sizeof(SweetBPLibrary_SB_IsInPregame) == 0x000010, "Wrong size on SweetBPLibrary_SB_IsInPregame");
static_assert(offsetof(SweetBPLibrary_SB_IsInPregame, WorldContextObject) == 0x000000, "Member 'SweetBPLibrary_SB_IsInPregame::WorldContextObject' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_IsInPregame, ReturnValue) == 0x000008, "Member 'SweetBPLibrary_SB_IsInPregame::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.SB_SpawnProjectilesInSpray
// 0x0060 (0x0060 - 0x0000)
struct SweetBPLibrary_SB_SpawnProjectilesInSpray final
{
public:
	struct FTransform                             ProjectileTransform;                               // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 OwnerActor;                                        // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SpawnerWeapon;                                     // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 ProjectileClass;                                   // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponSprayDataAsset*                  SprayData;                                         // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprayPlaneDepth;                                   // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprayPlaneWidth;                                   // 0x0054(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprayPlaneHeight;                                  // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSimulated;                                      // 0x005C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SweetBPLibrary_SB_SpawnProjectilesInSpray) == 0x000010, "Wrong alignment on SweetBPLibrary_SB_SpawnProjectilesInSpray");
static_assert(sizeof(SweetBPLibrary_SB_SpawnProjectilesInSpray) == 0x000060, "Wrong size on SweetBPLibrary_SB_SpawnProjectilesInSpray");
static_assert(offsetof(SweetBPLibrary_SB_SpawnProjectilesInSpray, ProjectileTransform) == 0x000000, "Member 'SweetBPLibrary_SB_SpawnProjectilesInSpray::ProjectileTransform' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_SpawnProjectilesInSpray, OwnerActor) == 0x000030, "Member 'SweetBPLibrary_SB_SpawnProjectilesInSpray::OwnerActor' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_SpawnProjectilesInSpray, SpawnerWeapon) == 0x000038, "Member 'SweetBPLibrary_SB_SpawnProjectilesInSpray::SpawnerWeapon' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_SpawnProjectilesInSpray, ProjectileClass) == 0x000040, "Member 'SweetBPLibrary_SB_SpawnProjectilesInSpray::ProjectileClass' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_SpawnProjectilesInSpray, SprayData) == 0x000048, "Member 'SweetBPLibrary_SB_SpawnProjectilesInSpray::SprayData' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_SpawnProjectilesInSpray, SprayPlaneDepth) == 0x000050, "Member 'SweetBPLibrary_SB_SpawnProjectilesInSpray::SprayPlaneDepth' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_SpawnProjectilesInSpray, SprayPlaneWidth) == 0x000054, "Member 'SweetBPLibrary_SB_SpawnProjectilesInSpray::SprayPlaneWidth' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_SpawnProjectilesInSpray, SprayPlaneHeight) == 0x000058, "Member 'SweetBPLibrary_SB_SpawnProjectilesInSpray::SprayPlaneHeight' has a wrong offset!");
static_assert(offsetof(SweetBPLibrary_SB_SpawnProjectilesInSpray, bIsSimulated) == 0x00005C, "Member 'SweetBPLibrary_SB_SpawnProjectilesInSpray::bIsSimulated' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.SBDevPrint
// 0x0010 (0x0010 - 0x0000)
struct SweetBPLibrary_SBDevPrint final
{
public:
	class FString                                 InString;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_SBDevPrint) == 0x000008, "Wrong alignment on SweetBPLibrary_SBDevPrint");
static_assert(sizeof(SweetBPLibrary_SBDevPrint) == 0x000010, "Wrong size on SweetBPLibrary_SBDevPrint");
static_assert(offsetof(SweetBPLibrary_SBDevPrint, InString) == 0x000000, "Member 'SweetBPLibrary_SBDevPrint::InString' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.SBPerfBookmark
// 0x0010 (0x0010 - 0x0000)
struct SweetBPLibrary_SBPerfBookmark final
{
public:
	class FString                                 InString;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_SBPerfBookmark) == 0x000008, "Wrong alignment on SweetBPLibrary_SBPerfBookmark");
static_assert(sizeof(SweetBPLibrary_SBPerfBookmark) == 0x000010, "Wrong size on SweetBPLibrary_SBPerfBookmark");
static_assert(offsetof(SweetBPLibrary_SBPerfBookmark, InString) == 0x000000, "Member 'SweetBPLibrary_SBPerfBookmark::InString' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.SetMontageDefaultLength
// 0x0008 (0x0008 - 0x0000)
struct SweetBPLibrary_SetMontageDefaultLength final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_SetMontageDefaultLength) == 0x000008, "Wrong alignment on SweetBPLibrary_SetMontageDefaultLength");
static_assert(sizeof(SweetBPLibrary_SetMontageDefaultLength) == 0x000008, "Wrong size on SweetBPLibrary_SetMontageDefaultLength");
static_assert(offsetof(SweetBPLibrary_SetMontageDefaultLength, Montage) == 0x000000, "Member 'SweetBPLibrary_SetMontageDefaultLength::Montage' has a wrong offset!");

// Function DeceiveInc.SweetBPLibrary.SetupPostProcessSystem
// 0x0008 (0x0008 - 0x0000)
struct SweetBPLibrary_SetupPostProcessSystem final
{
public:
	class UPostProcessComponent*                  PPComponent;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetBPLibrary_SetupPostProcessSystem) == 0x000008, "Wrong alignment on SweetBPLibrary_SetupPostProcessSystem");
static_assert(sizeof(SweetBPLibrary_SetupPostProcessSystem) == 0x000008, "Wrong size on SweetBPLibrary_SetupPostProcessSystem");
static_assert(offsetof(SweetBPLibrary_SetupPostProcessSystem, PPComponent) == 0x000000, "Member 'SweetBPLibrary_SetupPostProcessSystem::PPComponent' has a wrong offset!");

// Function DeceiveInc.DeceiveIncMenuGameModeBase.HostCustomMatch
// 0x0010 (0x0010 - 0x0000)
struct DeceiveIncMenuGameModeBase_HostCustomMatch final
{
public:
	class FString                                 LevelToPlay;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncMenuGameModeBase_HostCustomMatch) == 0x000008, "Wrong alignment on DeceiveIncMenuGameModeBase_HostCustomMatch");
static_assert(sizeof(DeceiveIncMenuGameModeBase_HostCustomMatch) == 0x000010, "Wrong size on DeceiveIncMenuGameModeBase_HostCustomMatch");
static_assert(offsetof(DeceiveIncMenuGameModeBase_HostCustomMatch, LevelToPlay) == 0x000000, "Member 'DeceiveIncMenuGameModeBase_HostCustomMatch::LevelToPlay' has a wrong offset!");

// Function DeceiveInc.DeceiveIncMenuGameModeBase.JoinCustomMatch
// 0x0010 (0x0010 - 0x0000)
struct DeceiveIncMenuGameModeBase_JoinCustomMatch final
{
public:
	class FString                                 HostUrl;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncMenuGameModeBase_JoinCustomMatch) == 0x000008, "Wrong alignment on DeceiveIncMenuGameModeBase_JoinCustomMatch");
static_assert(sizeof(DeceiveIncMenuGameModeBase_JoinCustomMatch) == 0x000010, "Wrong size on DeceiveIncMenuGameModeBase_JoinCustomMatch");
static_assert(offsetof(DeceiveIncMenuGameModeBase_JoinCustomMatch, HostUrl) == 0x000000, "Member 'DeceiveIncMenuGameModeBase_JoinCustomMatch::HostUrl' has a wrong offset!");

// Function DeceiveInc.BotActionChangeCover.OnLocaInteractionCompleted
// 0x0010 (0x0010 - 0x0000)
struct BotActionChangeCover_OnLocaInteractionCompleted final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BotActionChangeCover_OnLocaInteractionCompleted) == 0x000008, "Wrong alignment on BotActionChangeCover_OnLocaInteractionCompleted");
static_assert(sizeof(BotActionChangeCover_OnLocaInteractionCompleted) == 0x000010, "Wrong size on BotActionChangeCover_OnLocaInteractionCompleted");
static_assert(offsetof(BotActionChangeCover_OnLocaInteractionCompleted, Interacter) == 0x000000, "Member 'BotActionChangeCover_OnLocaInteractionCompleted::Interacter' has a wrong offset!");
static_assert(offsetof(BotActionChangeCover_OnLocaInteractionCompleted, Interactable) == 0x000008, "Member 'BotActionChangeCover_OnLocaInteractionCompleted::Interactable' has a wrong offset!");

// Function DeceiveInc.BotActionChangeCover.OnReceiveMoveCompleted
// 0x0008 (0x0008 - 0x0000)
struct BotActionChangeCover_OnReceiveMoveCompleted final
{
public:
	struct FAIRequestID                           RequestId;                                         // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPathFollowingResult                          Result;                                            // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BotActionChangeCover_OnReceiveMoveCompleted) == 0x000004, "Wrong alignment on BotActionChangeCover_OnReceiveMoveCompleted");
static_assert(sizeof(BotActionChangeCover_OnReceiveMoveCompleted) == 0x000008, "Wrong size on BotActionChangeCover_OnReceiveMoveCompleted");
static_assert(offsetof(BotActionChangeCover_OnReceiveMoveCompleted, RequestId) == 0x000000, "Member 'BotActionChangeCover_OnReceiveMoveCompleted::RequestId' has a wrong offset!");
static_assert(offsetof(BotActionChangeCover_OnReceiveMoveCompleted, Result) == 0x000004, "Member 'BotActionChangeCover_OnReceiveMoveCompleted::Result' has a wrong offset!");

// Function DeceiveInc.DiAnimInstance.ApplyMotionSet
// 0x0010 (0x0010 - 0x0000)
struct DiAnimInstance_ApplyMotionSet final
{
public:
	const class UDiAnimationMotionSet*            MotionSet;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DiAnimInstance_ApplyMotionSet) == 0x000008, "Wrong alignment on DiAnimInstance_ApplyMotionSet");
static_assert(sizeof(DiAnimInstance_ApplyMotionSet) == 0x000010, "Wrong size on DiAnimInstance_ApplyMotionSet");
static_assert(offsetof(DiAnimInstance_ApplyMotionSet, MotionSet) == 0x000000, "Member 'DiAnimInstance_ApplyMotionSet::MotionSet' has a wrong offset!");
static_assert(offsetof(DiAnimInstance_ApplyMotionSet, ReturnValue) == 0x000008, "Member 'DiAnimInstance_ApplyMotionSet::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiAnimInstance.BP_OnApplyMotionSet
// 0x0008 (0x0008 - 0x0000)
struct DiAnimInstance_BP_OnApplyMotionSet final
{
public:
	const class UDiAnimationMotionSet*            MotionSet;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiAnimInstance_BP_OnApplyMotionSet) == 0x000008, "Wrong alignment on DiAnimInstance_BP_OnApplyMotionSet");
static_assert(sizeof(DiAnimInstance_BP_OnApplyMotionSet) == 0x000008, "Wrong size on DiAnimInstance_BP_OnApplyMotionSet");
static_assert(offsetof(DiAnimInstance_BP_OnApplyMotionSet, MotionSet) == 0x000000, "Member 'DiAnimInstance_BP_OnApplyMotionSet::MotionSet' has a wrong offset!");

// Function DeceiveInc.DiAnimInstance.GetAnimMotionBlendspace
// 0x0010 (0x0010 - 0x0000)
struct DiAnimInstance_GetAnimMotionBlendspace final
{
public:
	class FName                                   MotionName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiAnimInstance_GetAnimMotionBlendspace) == 0x000008, "Wrong alignment on DiAnimInstance_GetAnimMotionBlendspace");
static_assert(sizeof(DiAnimInstance_GetAnimMotionBlendspace) == 0x000010, "Wrong size on DiAnimInstance_GetAnimMotionBlendspace");
static_assert(offsetof(DiAnimInstance_GetAnimMotionBlendspace, MotionName) == 0x000000, "Member 'DiAnimInstance_GetAnimMotionBlendspace::MotionName' has a wrong offset!");
static_assert(offsetof(DiAnimInstance_GetAnimMotionBlendspace, ReturnValue) == 0x000008, "Member 'DiAnimInstance_GetAnimMotionBlendspace::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiAnimInstance.GetAnimMotionSequence
// 0x0010 (0x0010 - 0x0000)
struct DiAnimInstance_GetAnimMotionSequence final
{
public:
	class FName                                   MotionName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiAnimInstance_GetAnimMotionSequence) == 0x000008, "Wrong alignment on DiAnimInstance_GetAnimMotionSequence");
static_assert(sizeof(DiAnimInstance_GetAnimMotionSequence) == 0x000010, "Wrong size on DiAnimInstance_GetAnimMotionSequence");
static_assert(offsetof(DiAnimInstance_GetAnimMotionSequence, MotionName) == 0x000000, "Member 'DiAnimInstance_GetAnimMotionSequence::MotionName' has a wrong offset!");
static_assert(offsetof(DiAnimInstance_GetAnimMotionSequence, ReturnValue) == 0x000008, "Member 'DiAnimInstance_GetAnimMotionSequence::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiAnimInstance.HasAnimMotion
// 0x000C (0x000C - 0x0000)
struct DiAnimInstance_HasAnimMotion final
{
public:
	class FName                                   MotionName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DiAnimInstance_HasAnimMotion) == 0x000004, "Wrong alignment on DiAnimInstance_HasAnimMotion");
static_assert(sizeof(DiAnimInstance_HasAnimMotion) == 0x00000C, "Wrong size on DiAnimInstance_HasAnimMotion");
static_assert(offsetof(DiAnimInstance_HasAnimMotion, MotionName) == 0x000000, "Member 'DiAnimInstance_HasAnimMotion::MotionName' has a wrong offset!");
static_assert(offsetof(DiAnimInstance_HasAnimMotion, ReturnValue) == 0x000008, "Member 'DiAnimInstance_HasAnimMotion::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BotBrain.OnObjectivePing
// 0x0008 (0x0008 - 0x0000)
struct BotBrain_OnObjectivePing final
{
public:
	class ASpy*                                   PingingSpy;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BotBrain_OnObjectivePing) == 0x000008, "Wrong alignment on BotBrain_OnObjectivePing");
static_assert(sizeof(BotBrain_OnObjectivePing) == 0x000008, "Wrong size on BotBrain_OnObjectivePing");
static_assert(offsetof(BotBrain_OnObjectivePing, PingingSpy) == 0x000000, "Member 'BotBrain_OnObjectivePing::PingingSpy' has a wrong offset!");

// Function DeceiveInc.TargetPracticeDummy.HandleTakePointDamage
// 0x0058 (0x0058 - 0x0000)
struct TargetPracticeDummy_HandleTakePointDamage final
{
public:
	class AActor*                                 DamagedActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            InstigatedBy;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    FHitComponent;                                     // 0x0028(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ShotFromDirection;                                 // 0x0038(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UDamageType*                      DamageType;                                        // 0x0048(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0050(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetPracticeDummy_HandleTakePointDamage) == 0x000008, "Wrong alignment on TargetPracticeDummy_HandleTakePointDamage");
static_assert(sizeof(TargetPracticeDummy_HandleTakePointDamage) == 0x000058, "Wrong size on TargetPracticeDummy_HandleTakePointDamage");
static_assert(offsetof(TargetPracticeDummy_HandleTakePointDamage, DamagedActor) == 0x000000, "Member 'TargetPracticeDummy_HandleTakePointDamage::DamagedActor' has a wrong offset!");
static_assert(offsetof(TargetPracticeDummy_HandleTakePointDamage, Damage) == 0x000008, "Member 'TargetPracticeDummy_HandleTakePointDamage::Damage' has a wrong offset!");
static_assert(offsetof(TargetPracticeDummy_HandleTakePointDamage, InstigatedBy) == 0x000010, "Member 'TargetPracticeDummy_HandleTakePointDamage::InstigatedBy' has a wrong offset!");
static_assert(offsetof(TargetPracticeDummy_HandleTakePointDamage, HitLocation) == 0x000018, "Member 'TargetPracticeDummy_HandleTakePointDamage::HitLocation' has a wrong offset!");
static_assert(offsetof(TargetPracticeDummy_HandleTakePointDamage, FHitComponent) == 0x000028, "Member 'TargetPracticeDummy_HandleTakePointDamage::FHitComponent' has a wrong offset!");
static_assert(offsetof(TargetPracticeDummy_HandleTakePointDamage, BoneName) == 0x000030, "Member 'TargetPracticeDummy_HandleTakePointDamage::BoneName' has a wrong offset!");
static_assert(offsetof(TargetPracticeDummy_HandleTakePointDamage, ShotFromDirection) == 0x000038, "Member 'TargetPracticeDummy_HandleTakePointDamage::ShotFromDirection' has a wrong offset!");
static_assert(offsetof(TargetPracticeDummy_HandleTakePointDamage, DamageType) == 0x000048, "Member 'TargetPracticeDummy_HandleTakePointDamage::DamageType' has a wrong offset!");
static_assert(offsetof(TargetPracticeDummy_HandleTakePointDamage, DamageCauser) == 0x000050, "Member 'TargetPracticeDummy_HandleTakePointDamage::DamageCauser' has a wrong offset!");

// Function DeceiveInc.TargetPracticeDummy.MulticastTakeDamage
// 0x0018 (0x0018 - 0x0000)
struct TargetPracticeDummy_MulticastTakeDamage final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0004(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetPracticeDummy_MulticastTakeDamage) == 0x000004, "Wrong alignment on TargetPracticeDummy_MulticastTakeDamage");
static_assert(sizeof(TargetPracticeDummy_MulticastTakeDamage) == 0x000018, "Wrong size on TargetPracticeDummy_MulticastTakeDamage");
static_assert(offsetof(TargetPracticeDummy_MulticastTakeDamage, Damage) == 0x000000, "Member 'TargetPracticeDummy_MulticastTakeDamage::Damage' has a wrong offset!");
static_assert(offsetof(TargetPracticeDummy_MulticastTakeDamage, HitLocation) == 0x000004, "Member 'TargetPracticeDummy_MulticastTakeDamage::HitLocation' has a wrong offset!");
static_assert(offsetof(TargetPracticeDummy_MulticastTakeDamage, BoneName) == 0x000010, "Member 'TargetPracticeDummy_MulticastTakeDamage::BoneName' has a wrong offset!");

// Function DeceiveInc.CavalierePassiveAbilityMod1.HandleMeleeAttackDamageDoneServer
// 0x0068 (0x0068 - 0x0000)
struct CavalierePassiveAbilityMod1_HandleMeleeAttackDamageDoneServer final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPoint;                                       // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChargeLevel;                                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageDone;                                        // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultingHealthPercentage;                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitType                                      HitType;                                           // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMeleeHitConfirmedData                 HitConfirmedData;                                  // 0x0028(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavalierePassiveAbilityMod1_HandleMeleeAttackDamageDoneServer) == 0x000008, "Wrong alignment on CavalierePassiveAbilityMod1_HandleMeleeAttackDamageDoneServer");
static_assert(sizeof(CavalierePassiveAbilityMod1_HandleMeleeAttackDamageDoneServer) == 0x000068, "Wrong size on CavalierePassiveAbilityMod1_HandleMeleeAttackDamageDoneServer");
static_assert(offsetof(CavalierePassiveAbilityMod1_HandleMeleeAttackDamageDoneServer, Victim) == 0x000000, "Member 'CavalierePassiveAbilityMod1_HandleMeleeAttackDamageDoneServer::Victim' has a wrong offset!");
static_assert(offsetof(CavalierePassiveAbilityMod1_HandleMeleeAttackDamageDoneServer, ImpactPoint) == 0x000008, "Member 'CavalierePassiveAbilityMod1_HandleMeleeAttackDamageDoneServer::ImpactPoint' has a wrong offset!");
static_assert(offsetof(CavalierePassiveAbilityMod1_HandleMeleeAttackDamageDoneServer, ChargeLevel) == 0x000014, "Member 'CavalierePassiveAbilityMod1_HandleMeleeAttackDamageDoneServer::ChargeLevel' has a wrong offset!");
static_assert(offsetof(CavalierePassiveAbilityMod1_HandleMeleeAttackDamageDoneServer, DamageDone) == 0x000018, "Member 'CavalierePassiveAbilityMod1_HandleMeleeAttackDamageDoneServer::DamageDone' has a wrong offset!");
static_assert(offsetof(CavalierePassiveAbilityMod1_HandleMeleeAttackDamageDoneServer, ResultingHealthPercentage) == 0x00001C, "Member 'CavalierePassiveAbilityMod1_HandleMeleeAttackDamageDoneServer::ResultingHealthPercentage' has a wrong offset!");
static_assert(offsetof(CavalierePassiveAbilityMod1_HandleMeleeAttackDamageDoneServer, HitType) == 0x000020, "Member 'CavalierePassiveAbilityMod1_HandleMeleeAttackDamageDoneServer::HitType' has a wrong offset!");
static_assert(offsetof(CavalierePassiveAbilityMod1_HandleMeleeAttackDamageDoneServer, HitConfirmedData) == 0x000028, "Member 'CavalierePassiveAbilityMod1_HandleMeleeAttackDamageDoneServer::HitConfirmedData' has a wrong offset!");

// Function DeceiveInc.CavalierePassiveAbilityMod1.HandleMeleeAttackLoadComplete
// 0x0008 (0x0008 - 0x0000)
struct CavalierePassiveAbilityMod1_HandleMeleeAttackLoadComplete final
{
public:
	class UToolLoadoutComponent*                  LoadoutComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavalierePassiveAbilityMod1_HandleMeleeAttackLoadComplete) == 0x000008, "Wrong alignment on CavalierePassiveAbilityMod1_HandleMeleeAttackLoadComplete");
static_assert(sizeof(CavalierePassiveAbilityMod1_HandleMeleeAttackLoadComplete) == 0x000008, "Wrong size on CavalierePassiveAbilityMod1_HandleMeleeAttackLoadComplete");
static_assert(offsetof(CavalierePassiveAbilityMod1_HandleMeleeAttackLoadComplete, LoadoutComponent) == 0x000000, "Member 'CavalierePassiveAbilityMod1_HandleMeleeAttackLoadComplete::LoadoutComponent' has a wrong offset!");

// Function DeceiveInc.CavalierePassiveAbilityMod1.NetMulticast_OnFillUpMagazine
// 0x0008 (0x0008 - 0x0000)
struct CavalierePassiveAbilityMod1_NetMulticast_OnFillUpMagazine final
{
public:
	class AProjectileWeapon*                      Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavalierePassiveAbilityMod1_NetMulticast_OnFillUpMagazine) == 0x000008, "Wrong alignment on CavalierePassiveAbilityMod1_NetMulticast_OnFillUpMagazine");
static_assert(sizeof(CavalierePassiveAbilityMod1_NetMulticast_OnFillUpMagazine) == 0x000008, "Wrong size on CavalierePassiveAbilityMod1_NetMulticast_OnFillUpMagazine");
static_assert(offsetof(CavalierePassiveAbilityMod1_NetMulticast_OnFillUpMagazine, Weapon) == 0x000000, "Member 'CavalierePassiveAbilityMod1_NetMulticast_OnFillUpMagazine::Weapon' has a wrong offset!");

// Function DeceiveInc.TrainingBotBrain.OnFightTargetLost
// 0x0010 (0x0010 - 0x0000)
struct TrainingBotBrain_OnFightTargetLost final
{
public:
	class UBotPlanFight*                          BotPlanFight;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   LostTarget;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TrainingBotBrain_OnFightTargetLost) == 0x000008, "Wrong alignment on TrainingBotBrain_OnFightTargetLost");
static_assert(sizeof(TrainingBotBrain_OnFightTargetLost) == 0x000010, "Wrong size on TrainingBotBrain_OnFightTargetLost");
static_assert(offsetof(TrainingBotBrain_OnFightTargetLost, BotPlanFight) == 0x000000, "Member 'TrainingBotBrain_OnFightTargetLost::BotPlanFight' has a wrong offset!");
static_assert(offsetof(TrainingBotBrain_OnFightTargetLost, LostTarget) == 0x000008, "Member 'TrainingBotBrain_OnFightTargetLost::LostTarget' has a wrong offset!");

// Function DeceiveInc.TrainingBotBrain.OnUndercoverChange
// 0x0001 (0x0001 - 0x0000)
struct TrainingBotBrain_OnUndercoverChange final
{
public:
	bool                                          bUndercover;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TrainingBotBrain_OnUndercoverChange) == 0x000001, "Wrong alignment on TrainingBotBrain_OnUndercoverChange");
static_assert(sizeof(TrainingBotBrain_OnUndercoverChange) == 0x000001, "Wrong size on TrainingBotBrain_OnUndercoverChange");
static_assert(offsetof(TrainingBotBrain_OnUndercoverChange, bUndercover) == 0x000000, "Member 'TrainingBotBrain_OnUndercoverChange::bUndercover' has a wrong offset!");

// Function DeceiveInc.DIAnimationBlueprintLibrary.GetAnimationNotifyTime
// 0x0018 (0x0018 - 0x0000)
struct DIAnimationBlueprintLibrary_GetAnimationNotifyTime final
{
public:
	const class UAnimSequence*                    AnimationSequence;                                 // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NotifyName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnAnimationDurationOnNotifyNotFound;           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIAnimationBlueprintLibrary_GetAnimationNotifyTime) == 0x000008, "Wrong alignment on DIAnimationBlueprintLibrary_GetAnimationNotifyTime");
static_assert(sizeof(DIAnimationBlueprintLibrary_GetAnimationNotifyTime) == 0x000018, "Wrong size on DIAnimationBlueprintLibrary_GetAnimationNotifyTime");
static_assert(offsetof(DIAnimationBlueprintLibrary_GetAnimationNotifyTime, AnimationSequence) == 0x000000, "Member 'DIAnimationBlueprintLibrary_GetAnimationNotifyTime::AnimationSequence' has a wrong offset!");
static_assert(offsetof(DIAnimationBlueprintLibrary_GetAnimationNotifyTime, NotifyName) == 0x000008, "Member 'DIAnimationBlueprintLibrary_GetAnimationNotifyTime::NotifyName' has a wrong offset!");
static_assert(offsetof(DIAnimationBlueprintLibrary_GetAnimationNotifyTime, ReturnAnimationDurationOnNotifyNotFound) == 0x000010, "Member 'DIAnimationBlueprintLibrary_GetAnimationNotifyTime::ReturnAnimationDurationOnNotifyNotFound' has a wrong offset!");
static_assert(offsetof(DIAnimationBlueprintLibrary_GetAnimationNotifyTime, ReturnValue) == 0x000014, "Member 'DIAnimationBlueprintLibrary_GetAnimationNotifyTime::ReturnValue' has a wrong offset!");

// Function DeceiveInc.OutOfBoundsEntity.OnOutOfBoundsActorBeginOverlap
// 0x0008 (0x0008 - 0x0000)
struct OutOfBoundsEntity_OnOutOfBoundsActorBeginOverlap final
{
public:
	class AActor*                                 InOutOfBoundsActor;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OutOfBoundsEntity_OnOutOfBoundsActorBeginOverlap) == 0x000008, "Wrong alignment on OutOfBoundsEntity_OnOutOfBoundsActorBeginOverlap");
static_assert(sizeof(OutOfBoundsEntity_OnOutOfBoundsActorBeginOverlap) == 0x000008, "Wrong size on OutOfBoundsEntity_OnOutOfBoundsActorBeginOverlap");
static_assert(offsetof(OutOfBoundsEntity_OnOutOfBoundsActorBeginOverlap, InOutOfBoundsActor) == 0x000000, "Member 'OutOfBoundsEntity_OnOutOfBoundsActorBeginOverlap::InOutOfBoundsActor' has a wrong offset!");

// Function DeceiveInc.OutOfBoundsEntity.OnOutOfBoundsActorEndOverlap
// 0x0008 (0x0008 - 0x0000)
struct OutOfBoundsEntity_OnOutOfBoundsActorEndOverlap final
{
public:
	class AActor*                                 InOutOfBoundsActor;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OutOfBoundsEntity_OnOutOfBoundsActorEndOverlap) == 0x000008, "Wrong alignment on OutOfBoundsEntity_OnOutOfBoundsActorEndOverlap");
static_assert(sizeof(OutOfBoundsEntity_OnOutOfBoundsActorEndOverlap) == 0x000008, "Wrong size on OutOfBoundsEntity_OnOutOfBoundsActorEndOverlap");
static_assert(offsetof(OutOfBoundsEntity_OnOutOfBoundsActorEndOverlap, InOutOfBoundsActor) == 0x000000, "Member 'OutOfBoundsEntity_OnOutOfBoundsActorEndOverlap::InOutOfBoundsActor' has a wrong offset!");

// Function DeceiveInc.OctoActiveAbility.BP_OnHackableHacked
// 0x0010 (0x0010 - 0x0000)
struct OctoActiveAbility_BP_OnHackableHacked final
{
public:
	class AActor*                                 InteractableActor;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractableType                             InteractableType;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StencilValue;                                      // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OctoActiveAbility_BP_OnHackableHacked) == 0x000008, "Wrong alignment on OctoActiveAbility_BP_OnHackableHacked");
static_assert(sizeof(OctoActiveAbility_BP_OnHackableHacked) == 0x000010, "Wrong size on OctoActiveAbility_BP_OnHackableHacked");
static_assert(offsetof(OctoActiveAbility_BP_OnHackableHacked, InteractableActor) == 0x000000, "Member 'OctoActiveAbility_BP_OnHackableHacked::InteractableActor' has a wrong offset!");
static_assert(offsetof(OctoActiveAbility_BP_OnHackableHacked, InteractableType) == 0x000008, "Member 'OctoActiveAbility_BP_OnHackableHacked::InteractableType' has a wrong offset!");
static_assert(offsetof(OctoActiveAbility_BP_OnHackableHacked, StencilValue) == 0x000009, "Member 'OctoActiveAbility_BP_OnHackableHacked::StencilValue' has a wrong offset!");

// Function DeceiveInc.OctoActiveAbility.BP_OnHackableRebooted
// 0x0010 (0x0010 - 0x0000)
struct OctoActiveAbility_BP_OnHackableRebooted final
{
public:
	class AActor*                                 InteractableActor;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractableType                             InteractableType;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StencilValue;                                      // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OctoActiveAbility_BP_OnHackableRebooted) == 0x000008, "Wrong alignment on OctoActiveAbility_BP_OnHackableRebooted");
static_assert(sizeof(OctoActiveAbility_BP_OnHackableRebooted) == 0x000010, "Wrong size on OctoActiveAbility_BP_OnHackableRebooted");
static_assert(offsetof(OctoActiveAbility_BP_OnHackableRebooted, InteractableActor) == 0x000000, "Member 'OctoActiveAbility_BP_OnHackableRebooted::InteractableActor' has a wrong offset!");
static_assert(offsetof(OctoActiveAbility_BP_OnHackableRebooted, InteractableType) == 0x000008, "Member 'OctoActiveAbility_BP_OnHackableRebooted::InteractableType' has a wrong offset!");
static_assert(offsetof(OctoActiveAbility_BP_OnHackableRebooted, StencilValue) == 0x000009, "Member 'OctoActiveAbility_BP_OnHackableRebooted::StencilValue' has a wrong offset!");

// Function DeceiveInc.OctoActiveAbility.MulticastActiveResult
// 0x0020 (0x0020 - 0x0000)
struct OctoActiveAbility_MulticastActiveResult final
{
public:
	struct FOctoActiveAbilityResultReplication    InteractableComp;                                  // 0x0000(0x0020)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OctoActiveAbility_MulticastActiveResult) == 0x000008, "Wrong alignment on OctoActiveAbility_MulticastActiveResult");
static_assert(sizeof(OctoActiveAbility_MulticastActiveResult) == 0x000020, "Wrong size on OctoActiveAbility_MulticastActiveResult");
static_assert(offsetof(OctoActiveAbility_MulticastActiveResult, InteractableComp) == 0x000000, "Member 'OctoActiveAbility_MulticastActiveResult::InteractableComp' has a wrong offset!");

// Function DeceiveInc.OctoActiveAbility.ServerActiveResult
// 0x0020 (0x0020 - 0x0000)
struct OctoActiveAbility_ServerActiveResult final
{
public:
	struct FOctoActiveAbilityResultReplication    InteractableComp;                                  // 0x0000(0x0020)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OctoActiveAbility_ServerActiveResult) == 0x000008, "Wrong alignment on OctoActiveAbility_ServerActiveResult");
static_assert(sizeof(OctoActiveAbility_ServerActiveResult) == 0x000020, "Wrong size on OctoActiveAbility_ServerActiveResult");
static_assert(offsetof(OctoActiveAbility_ServerActiveResult, InteractableComp) == 0x000000, "Member 'OctoActiveAbility_ServerActiveResult::InteractableComp' has a wrong offset!");

// Function DeceiveInc.BotPlanFight.OnInstantLoseAggroFromBots
// 0x0008 (0x0008 - 0x0000)
struct BotPlanFight_OnInstantLoseAggroFromBots final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BotPlanFight_OnInstantLoseAggroFromBots) == 0x000008, "Wrong alignment on BotPlanFight_OnInstantLoseAggroFromBots");
static_assert(sizeof(BotPlanFight_OnInstantLoseAggroFromBots) == 0x000008, "Wrong size on BotPlanFight_OnInstantLoseAggroFromBots");
static_assert(offsetof(BotPlanFight_OnInstantLoseAggroFromBots, Spy) == 0x000000, "Member 'BotPlanFight_OnInstantLoseAggroFromBots::Spy' has a wrong offset!");

// Function DeceiveInc.BotPlanFight.OnMoveActionEnd
// 0x0010 (0x0010 - 0x0000)
struct BotPlanFight_OnMoveActionEnd final
{
public:
	class UBotAction*                             ActionEnding;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBotActionResult                              ActionResult;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BotPlanFight_OnMoveActionEnd) == 0x000008, "Wrong alignment on BotPlanFight_OnMoveActionEnd");
static_assert(sizeof(BotPlanFight_OnMoveActionEnd) == 0x000010, "Wrong size on BotPlanFight_OnMoveActionEnd");
static_assert(offsetof(BotPlanFight_OnMoveActionEnd, ActionEnding) == 0x000000, "Member 'BotPlanFight_OnMoveActionEnd::ActionEnding' has a wrong offset!");
static_assert(offsetof(BotPlanFight_OnMoveActionEnd, ActionResult) == 0x000008, "Member 'BotPlanFight_OnMoveActionEnd::ActionResult' has a wrong offset!");

// Function DeceiveInc.OctoPassiveAbilityLuckBased.BP_LuckEventResult
// 0x0008 (0x0008 - 0x0000)
struct OctoPassiveAbilityLuckBased_BP_LuckEventResult final
{
public:
	int32                                         IntelChangeAmount;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSucesssful;                                       // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OctoPassiveAbilityLuckBased_BP_LuckEventResult) == 0x000004, "Wrong alignment on OctoPassiveAbilityLuckBased_BP_LuckEventResult");
static_assert(sizeof(OctoPassiveAbilityLuckBased_BP_LuckEventResult) == 0x000008, "Wrong size on OctoPassiveAbilityLuckBased_BP_LuckEventResult");
static_assert(offsetof(OctoPassiveAbilityLuckBased_BP_LuckEventResult, IntelChangeAmount) == 0x000000, "Member 'OctoPassiveAbilityLuckBased_BP_LuckEventResult::IntelChangeAmount' has a wrong offset!");
static_assert(offsetof(OctoPassiveAbilityLuckBased_BP_LuckEventResult, bSucesssful) == 0x000004, "Member 'OctoPassiveAbilityLuckBased_BP_LuckEventResult::bSucesssful' has a wrong offset!");

// Function DeceiveInc.OctoPassiveAbilityLuckBased.BP_StartLuckEvent
// 0x0004 (0x0004 - 0x0000)
struct OctoPassiveAbilityLuckBased_BP_StartLuckEvent final
{
public:
	int32                                         IntelChangeAmount;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OctoPassiveAbilityLuckBased_BP_StartLuckEvent) == 0x000004, "Wrong alignment on OctoPassiveAbilityLuckBased_BP_StartLuckEvent");
static_assert(sizeof(OctoPassiveAbilityLuckBased_BP_StartLuckEvent) == 0x000004, "Wrong size on OctoPassiveAbilityLuckBased_BP_StartLuckEvent");
static_assert(offsetof(OctoPassiveAbilityLuckBased_BP_StartLuckEvent, IntelChangeAmount) == 0x000000, "Member 'OctoPassiveAbilityLuckBased_BP_StartLuckEvent::IntelChangeAmount' has a wrong offset!");

// Function DeceiveInc.OctoPassiveAbilityLuckBased.NetMulticast_OctoLuckEventResult
// 0x0008 (0x0008 - 0x0000)
struct OctoPassiveAbilityLuckBased_NetMulticast_OctoLuckEventResult final
{
public:
	bool                                          bSuccessful;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AmountIn;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OctoPassiveAbilityLuckBased_NetMulticast_OctoLuckEventResult) == 0x000004, "Wrong alignment on OctoPassiveAbilityLuckBased_NetMulticast_OctoLuckEventResult");
static_assert(sizeof(OctoPassiveAbilityLuckBased_NetMulticast_OctoLuckEventResult) == 0x000008, "Wrong size on OctoPassiveAbilityLuckBased_NetMulticast_OctoLuckEventResult");
static_assert(offsetof(OctoPassiveAbilityLuckBased_NetMulticast_OctoLuckEventResult, bSuccessful) == 0x000000, "Member 'OctoPassiveAbilityLuckBased_NetMulticast_OctoLuckEventResult::bSuccessful' has a wrong offset!");
static_assert(offsetof(OctoPassiveAbilityLuckBased_NetMulticast_OctoLuckEventResult, AmountIn) == 0x000004, "Member 'OctoPassiveAbilityLuckBased_NetMulticast_OctoLuckEventResult::AmountIn' has a wrong offset!");

// Function DeceiveInc.OctoPassiveAbilityLuckBased.OnResourceChange
// 0x0028 (0x0028 - 0x0000)
struct OctoPassiveAbilityLuckBased_OnResourceChange final
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ResourceDisplayName;                               // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OctoPassiveAbilityLuckBased_OnResourceChange) == 0x000008, "Wrong alignment on OctoPassiveAbilityLuckBased_OnResourceChange");
static_assert(sizeof(OctoPassiveAbilityLuckBased_OnResourceChange) == 0x000028, "Wrong size on OctoPassiveAbilityLuckBased_OnResourceChange");
static_assert(offsetof(OctoPassiveAbilityLuckBased_OnResourceChange, ResourceType) == 0x000000, "Member 'OctoPassiveAbilityLuckBased_OnResourceChange::ResourceType' has a wrong offset!");
static_assert(offsetof(OctoPassiveAbilityLuckBased_OnResourceChange, ResourceDisplayName) == 0x000008, "Member 'OctoPassiveAbilityLuckBased_OnResourceChange::ResourceDisplayName' has a wrong offset!");
static_assert(offsetof(OctoPassiveAbilityLuckBased_OnResourceChange, Amount) == 0x000020, "Member 'OctoPassiveAbilityLuckBased_OnResourceChange::Amount' has a wrong offset!");

// Function DeceiveInc.BotPlanProgressFlow.OnCurrentGoalChanged
// 0x0010 (0x0010 - 0x0000)
struct BotPlanProgressFlow_OnCurrentGoalChanged final
{
public:
	class UBotObjective*                          PrevGoal;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBotObjective*                          NewGoal;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BotPlanProgressFlow_OnCurrentGoalChanged) == 0x000008, "Wrong alignment on BotPlanProgressFlow_OnCurrentGoalChanged");
static_assert(sizeof(BotPlanProgressFlow_OnCurrentGoalChanged) == 0x000010, "Wrong size on BotPlanProgressFlow_OnCurrentGoalChanged");
static_assert(offsetof(BotPlanProgressFlow_OnCurrentGoalChanged, PrevGoal) == 0x000000, "Member 'BotPlanProgressFlow_OnCurrentGoalChanged::PrevGoal' has a wrong offset!");
static_assert(offsetof(BotPlanProgressFlow_OnCurrentGoalChanged, NewGoal) == 0x000008, "Member 'BotPlanProgressFlow_OnCurrentGoalChanged::NewGoal' has a wrong offset!");

// Function DeceiveInc.BotPlanProgressFlow.OnGamePhaseChange
// 0x0001 (0x0001 - 0x0000)
struct BotPlanProgressFlow_OnGamePhaseChange final
{
public:
	ESpyGamePhase                                 NewGamePhase;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BotPlanProgressFlow_OnGamePhaseChange) == 0x000001, "Wrong alignment on BotPlanProgressFlow_OnGamePhaseChange");
static_assert(sizeof(BotPlanProgressFlow_OnGamePhaseChange) == 0x000001, "Wrong size on BotPlanProgressFlow_OnGamePhaseChange");
static_assert(offsetof(BotPlanProgressFlow_OnGamePhaseChange, NewGamePhase) == 0x000000, "Member 'BotPlanProgressFlow_OnGamePhaseChange::NewGamePhase' has a wrong offset!");

// Function DeceiveInc.BotPlanProgressFlow.OnMoveActionEnd
// 0x0010 (0x0010 - 0x0000)
struct BotPlanProgressFlow_OnMoveActionEnd final
{
public:
	class UBotAction*                             ActionEnding;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBotActionResult                              ActionResult;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BotPlanProgressFlow_OnMoveActionEnd) == 0x000008, "Wrong alignment on BotPlanProgressFlow_OnMoveActionEnd");
static_assert(sizeof(BotPlanProgressFlow_OnMoveActionEnd) == 0x000010, "Wrong size on BotPlanProgressFlow_OnMoveActionEnd");
static_assert(offsetof(BotPlanProgressFlow_OnMoveActionEnd, ActionEnding) == 0x000000, "Member 'BotPlanProgressFlow_OnMoveActionEnd::ActionEnding' has a wrong offset!");
static_assert(offsetof(BotPlanProgressFlow_OnMoveActionEnd, ActionResult) == 0x000008, "Member 'BotPlanProgressFlow_OnMoveActionEnd::ActionResult' has a wrong offset!");

// Function DeceiveInc.PlayerInfoWidget.Init
// 0x0008 (0x0008 - 0x0000)
struct PlayerInfoWidget_Init final
{
public:
	class ADIPlayerState*                         InPlayerState;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerInfoWidget_Init) == 0x000008, "Wrong alignment on PlayerInfoWidget_Init");
static_assert(sizeof(PlayerInfoWidget_Init) == 0x000008, "Wrong size on PlayerInfoWidget_Init");
static_assert(offsetof(PlayerInfoWidget_Init, InPlayerState) == 0x000000, "Member 'PlayerInfoWidget_Init::InPlayerState' has a wrong offset!");

// Function DeceiveInc.PlayerInfoWidget.InitWithPartyMemberInfo
// 0x0008 (0x0008 - 0x0000)
struct PlayerInfoWidget_InitWithPartyMemberInfo final
{
public:
	class UDIOnlinePartyMemberInfo*               OnlinePartyMemberInfo;                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerInfoWidget_InitWithPartyMemberInfo) == 0x000008, "Wrong alignment on PlayerInfoWidget_InitWithPartyMemberInfo");
static_assert(sizeof(PlayerInfoWidget_InitWithPartyMemberInfo) == 0x000008, "Wrong size on PlayerInfoWidget_InitWithPartyMemberInfo");
static_assert(offsetof(PlayerInfoWidget_InitWithPartyMemberInfo, OnlinePartyMemberInfo) == 0x000000, "Member 'PlayerInfoWidget_InitWithPartyMemberInfo::OnlinePartyMemberInfo' has a wrong offset!");

// Function DeceiveInc.PlayerInfoWidget.InitWithSpy
// 0x0008 (0x0008 - 0x0000)
struct PlayerInfoWidget_InitWithSpy final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerInfoWidget_InitWithSpy) == 0x000008, "Wrong alignment on PlayerInfoWidget_InitWithSpy");
static_assert(sizeof(PlayerInfoWidget_InitWithSpy) == 0x000008, "Wrong size on PlayerInfoWidget_InitWithSpy");
static_assert(offsetof(PlayerInfoWidget_InitWithSpy, Spy) == 0x000000, "Member 'PlayerInfoWidget_InitWithSpy::Spy' has a wrong offset!");

// Function DeceiveInc.PlayerInfoWidget.GetPlayerState
// 0x0008 (0x0008 - 0x0000)
struct PlayerInfoWidget_GetPlayerState final
{
public:
	class ADIPlayerState*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerInfoWidget_GetPlayerState) == 0x000008, "Wrong alignment on PlayerInfoWidget_GetPlayerState");
static_assert(sizeof(PlayerInfoWidget_GetPlayerState) == 0x000008, "Wrong size on PlayerInfoWidget_GetPlayerState");
static_assert(offsetof(PlayerInfoWidget_GetPlayerState, ReturnValue) == 0x000000, "Member 'PlayerInfoWidget_GetPlayerState::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PlayerInfoWidget.GetUserName
// 0x0010 (0x0010 - 0x0000)
struct PlayerInfoWidget_GetUserName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerInfoWidget_GetUserName) == 0x000008, "Wrong alignment on PlayerInfoWidget_GetUserName");
static_assert(sizeof(PlayerInfoWidget_GetUserName) == 0x000010, "Wrong size on PlayerInfoWidget_GetUserName");
static_assert(offsetof(PlayerInfoWidget_GetUserName, ReturnValue) == 0x000000, "Member 'PlayerInfoWidget_GetUserName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PlayerInfoWidget.GetUserPlatform
// 0x0001 (0x0001 - 0x0000)
struct PlayerInfoWidget_GetUserPlatform final
{
public:
	EPlatformType                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerInfoWidget_GetUserPlatform) == 0x000001, "Wrong alignment on PlayerInfoWidget_GetUserPlatform");
static_assert(sizeof(PlayerInfoWidget_GetUserPlatform) == 0x000001, "Wrong size on PlayerInfoWidget_GetUserPlatform");
static_assert(offsetof(PlayerInfoWidget_GetUserPlatform, ReturnValue) == 0x000000, "Member 'PlayerInfoWidget_GetUserPlatform::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PlayerInfoWidget.IsInitialized
// 0x0001 (0x0001 - 0x0000)
struct PlayerInfoWidget_IsInitialized final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerInfoWidget_IsInitialized) == 0x000001, "Wrong alignment on PlayerInfoWidget_IsInitialized");
static_assert(sizeof(PlayerInfoWidget_IsInitialized) == 0x000001, "Wrong size on PlayerInfoWidget_IsInitialized");
static_assert(offsetof(PlayerInfoWidget_IsInitialized, ReturnValue) == 0x000000, "Member 'PlayerInfoWidget_IsInitialized::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BotSpawner.SpawnBot
// 0x0008 (0x0008 - 0x0000)
struct BotSpawner_SpawnBot final
{
public:
	class ADeceiveIncBotController*               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BotSpawner_SpawnBot) == 0x000008, "Wrong alignment on BotSpawner_SpawnBot");
static_assert(sizeof(BotSpawner_SpawnBot) == 0x000008, "Wrong size on BotSpawner_SpawnBot");
static_assert(offsetof(BotSpawner_SpawnBot, ReturnValue) == 0x000000, "Member 'BotSpawner_SpawnBot::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BotSpawner.GetLastSpawnedBot
// 0x0008 (0x0008 - 0x0000)
struct BotSpawner_GetLastSpawnedBot final
{
public:
	class ADeceiveIncBotController*               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BotSpawner_GetLastSpawnedBot) == 0x000008, "Wrong alignment on BotSpawner_GetLastSpawnedBot");
static_assert(sizeof(BotSpawner_GetLastSpawnedBot) == 0x000008, "Wrong size on BotSpawner_GetLastSpawnedBot");
static_assert(offsetof(BotSpawner_GetLastSpawnedBot, ReturnValue) == 0x000000, "Member 'BotSpawner_GetLastSpawnedBot::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PingInGameUserWidget.SelectPingIndex
// 0x0004 (0x0004 - 0x0000)
struct PingInGameUserWidget_SelectPingIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PingInGameUserWidget_SelectPingIndex) == 0x000004, "Wrong alignment on PingInGameUserWidget_SelectPingIndex");
static_assert(sizeof(PingInGameUserWidget_SelectPingIndex) == 0x000004, "Wrong size on PingInGameUserWidget_SelectPingIndex");
static_assert(offsetof(PingInGameUserWidget_SelectPingIndex, Index_0) == 0x000000, "Member 'PingInGameUserWidget_SelectPingIndex::Index_0' has a wrong offset!");

// Function DeceiveInc.OctoPassiveAbility.HandleResourceChange
// 0x0028 (0x0028 - 0x0000)
struct OctoPassiveAbility_HandleResourceChange final
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ResourceDisplayName;                               // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	int32                                         DeltaAmount;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OctoPassiveAbility_HandleResourceChange) == 0x000008, "Wrong alignment on OctoPassiveAbility_HandleResourceChange");
static_assert(sizeof(OctoPassiveAbility_HandleResourceChange) == 0x000028, "Wrong size on OctoPassiveAbility_HandleResourceChange");
static_assert(offsetof(OctoPassiveAbility_HandleResourceChange, ResourceType) == 0x000000, "Member 'OctoPassiveAbility_HandleResourceChange::ResourceType' has a wrong offset!");
static_assert(offsetof(OctoPassiveAbility_HandleResourceChange, ResourceDisplayName) == 0x000008, "Member 'OctoPassiveAbility_HandleResourceChange::ResourceDisplayName' has a wrong offset!");
static_assert(offsetof(OctoPassiveAbility_HandleResourceChange, DeltaAmount) == 0x000020, "Member 'OctoPassiveAbility_HandleResourceChange::DeltaAmount' has a wrong offset!");

// Function DeceiveInc.BouncingMatTool.HandleNotifyDeflate
// 0x0008 (0x0008 - 0x0000)
struct BouncingMatTool_HandleNotifyDeflate final
{
public:
	class ABouncingMat*                           DeflatingBounceMat;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BouncingMatTool_HandleNotifyDeflate) == 0x000008, "Wrong alignment on BouncingMatTool_HandleNotifyDeflate");
static_assert(sizeof(BouncingMatTool_HandleNotifyDeflate) == 0x000008, "Wrong size on BouncingMatTool_HandleNotifyDeflate");
static_assert(offsetof(BouncingMatTool_HandleNotifyDeflate, DeflatingBounceMat) == 0x000000, "Member 'BouncingMatTool_HandleNotifyDeflate::DeflatingBounceMat' has a wrong offset!");

// Function DeceiveInc.BriefcaseLoot.BP_OnLootClaimError
// 0x0010 (0x0010 - 0x0000)
struct BriefcaseLoot_BP_OnLootClaimError final
{
public:
	class FString                                 ErrorMessage;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BriefcaseLoot_BP_OnLootClaimError) == 0x000008, "Wrong alignment on BriefcaseLoot_BP_OnLootClaimError");
static_assert(sizeof(BriefcaseLoot_BP_OnLootClaimError) == 0x000010, "Wrong size on BriefcaseLoot_BP_OnLootClaimError");
static_assert(offsetof(BriefcaseLoot_BP_OnLootClaimError, ErrorMessage) == 0x000000, "Member 'BriefcaseLoot_BP_OnLootClaimError::ErrorMessage' has a wrong offset!");

// Function DeceiveInc.BriefcaseLoot.BP_OnLootClaimResponseSet
// 0x0020 (0x0020 - 0x0000)
struct BriefcaseLoot_BP_OnLootClaimResponseSet final
{
public:
	struct FLootClaimResponse                     NewLootClaimResponse;                              // 0x0000(0x0020)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BriefcaseLoot_BP_OnLootClaimResponseSet) == 0x000008, "Wrong alignment on BriefcaseLoot_BP_OnLootClaimResponseSet");
static_assert(sizeof(BriefcaseLoot_BP_OnLootClaimResponseSet) == 0x000020, "Wrong size on BriefcaseLoot_BP_OnLootClaimResponseSet");
static_assert(offsetof(BriefcaseLoot_BP_OnLootClaimResponseSet, NewLootClaimResponse) == 0x000000, "Member 'BriefcaseLoot_BP_OnLootClaimResponseSet::NewLootClaimResponse' has a wrong offset!");

// Function DeceiveInc.BriefcaseLoot.BP_OnPedestalsSpawned
// 0x0010 (0x0010 - 0x0000)
struct BriefcaseLoot_BP_OnPedestalsSpawned final
{
public:
	TArray<class ALootItemShowcase*>              SpawnedPedestals;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BriefcaseLoot_BP_OnPedestalsSpawned) == 0x000008, "Wrong alignment on BriefcaseLoot_BP_OnPedestalsSpawned");
static_assert(sizeof(BriefcaseLoot_BP_OnPedestalsSpawned) == 0x000010, "Wrong size on BriefcaseLoot_BP_OnPedestalsSpawned");
static_assert(offsetof(BriefcaseLoot_BP_OnPedestalsSpawned, SpawnedPedestals) == 0x000000, "Member 'BriefcaseLoot_BP_OnPedestalsSpawned::SpawnedPedestals' has a wrong offset!");

// Function DeceiveInc.BriefcaseLoot.GetPedestals
// 0x0010 (0x0010 - 0x0000)
struct BriefcaseLoot_GetPedestals final
{
public:
	TArray<class ALootItemShowcase*>              ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BriefcaseLoot_GetPedestals) == 0x000008, "Wrong alignment on BriefcaseLoot_GetPedestals");
static_assert(sizeof(BriefcaseLoot_GetPedestals) == 0x000010, "Wrong size on BriefcaseLoot_GetPedestals");
static_assert(offsetof(BriefcaseLoot_GetPedestals, ReturnValue) == 0x000000, "Member 'BriefcaseLoot_GetPedestals::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BriefcaseLoot.OnClaimLootBundleResponse
// 0x0048 (0x0048 - 0x0000)
struct BriefcaseLoot_OnClaimLootBundleResponse final
{
public:
	class FString                                 LootBundleId;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLootClaimResponse                     Response;                                          // 0x0010(0x0020)(Parm, NativeAccessSpecifierPublic)
	class FString                                 Error;                                             // 0x0030(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuccess;                                          // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BriefcaseLoot_OnClaimLootBundleResponse) == 0x000008, "Wrong alignment on BriefcaseLoot_OnClaimLootBundleResponse");
static_assert(sizeof(BriefcaseLoot_OnClaimLootBundleResponse) == 0x000048, "Wrong size on BriefcaseLoot_OnClaimLootBundleResponse");
static_assert(offsetof(BriefcaseLoot_OnClaimLootBundleResponse, LootBundleId) == 0x000000, "Member 'BriefcaseLoot_OnClaimLootBundleResponse::LootBundleId' has a wrong offset!");
static_assert(offsetof(BriefcaseLoot_OnClaimLootBundleResponse, Response) == 0x000010, "Member 'BriefcaseLoot_OnClaimLootBundleResponse::Response' has a wrong offset!");
static_assert(offsetof(BriefcaseLoot_OnClaimLootBundleResponse, Error) == 0x000030, "Member 'BriefcaseLoot_OnClaimLootBundleResponse::Error' has a wrong offset!");
static_assert(offsetof(BriefcaseLoot_OnClaimLootBundleResponse, bSuccess) == 0x000040, "Member 'BriefcaseLoot_OnClaimLootBundleResponse::bSuccess' has a wrong offset!");

// Function DeceiveInc.BriefcaseLoot.StartDespawn
// 0x0004 (0x0004 - 0x0000)
struct BriefcaseLoot_StartDespawn final
{
public:
	float                                         DespawnDurationIn;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BriefcaseLoot_StartDespawn) == 0x000004, "Wrong alignment on BriefcaseLoot_StartDespawn");
static_assert(sizeof(BriefcaseLoot_StartDespawn) == 0x000004, "Wrong size on BriefcaseLoot_StartDespawn");
static_assert(offsetof(BriefcaseLoot_StartDespawn, DespawnDurationIn) == 0x000000, "Member 'BriefcaseLoot_StartDespawn::DespawnDurationIn' has a wrong offset!");

// Function DeceiveInc.BriefcaseLoot.GetLootClaimResponse
// 0x0020 (0x0020 - 0x0000)
struct BriefcaseLoot_GetLootClaimResponse final
{
public:
	struct FLootClaimResponse                     ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BriefcaseLoot_GetLootClaimResponse) == 0x000008, "Wrong alignment on BriefcaseLoot_GetLootClaimResponse");
static_assert(sizeof(BriefcaseLoot_GetLootClaimResponse) == 0x000020, "Wrong size on BriefcaseLoot_GetLootClaimResponse");
static_assert(offsetof(BriefcaseLoot_GetLootClaimResponse, ReturnValue) == 0x000000, "Member 'BriefcaseLoot_GetLootClaimResponse::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PlayerBotsSubsystem.OnGamePhaseChanged
// 0x0001 (0x0001 - 0x0000)
struct PlayerBotsSubsystem_OnGamePhaseChanged final
{
public:
	ESpyGamePhase                                 NewGamePhase;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerBotsSubsystem_OnGamePhaseChanged) == 0x000001, "Wrong alignment on PlayerBotsSubsystem_OnGamePhaseChanged");
static_assert(sizeof(PlayerBotsSubsystem_OnGamePhaseChanged) == 0x000001, "Wrong size on PlayerBotsSubsystem_OnGamePhaseChanged");
static_assert(offsetof(PlayerBotsSubsystem_OnGamePhaseChanged, NewGamePhase) == 0x000000, "Member 'PlayerBotsSubsystem_OnGamePhaseChanged::NewGamePhase' has a wrong offset!");

// Function DeceiveInc.PlayerBotsSubsystem.OnSpyBotDeath
// 0x0008 (0x0008 - 0x0000)
struct PlayerBotsSubsystem_OnSpyBotDeath final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerBotsSubsystem_OnSpyBotDeath) == 0x000008, "Wrong alignment on PlayerBotsSubsystem_OnSpyBotDeath");
static_assert(sizeof(PlayerBotsSubsystem_OnSpyBotDeath) == 0x000008, "Wrong size on PlayerBotsSubsystem_OnSpyBotDeath");
static_assert(offsetof(PlayerBotsSubsystem_OnSpyBotDeath, Spy) == 0x000000, "Member 'PlayerBotsSubsystem_OnSpyBotDeath::Spy' has a wrong offset!");

// Function DeceiveInc.BuildMetadataSubsystem.GetFilteredReleaseNoteLines
// 0x0018 (0x0018 - 0x0000)
struct BuildMetadataSubsystem_GetFilteredReleaseNoteLines final
{
public:
	bool                                          bRemoveBuildNumberLines;                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveHashtagRN;                                  // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BuildMetadataSubsystem_GetFilteredReleaseNoteLines) == 0x000008, "Wrong alignment on BuildMetadataSubsystem_GetFilteredReleaseNoteLines");
static_assert(sizeof(BuildMetadataSubsystem_GetFilteredReleaseNoteLines) == 0x000018, "Wrong size on BuildMetadataSubsystem_GetFilteredReleaseNoteLines");
static_assert(offsetof(BuildMetadataSubsystem_GetFilteredReleaseNoteLines, bRemoveBuildNumberLines) == 0x000000, "Member 'BuildMetadataSubsystem_GetFilteredReleaseNoteLines::bRemoveBuildNumberLines' has a wrong offset!");
static_assert(offsetof(BuildMetadataSubsystem_GetFilteredReleaseNoteLines, bRemoveHashtagRN) == 0x000001, "Member 'BuildMetadataSubsystem_GetFilteredReleaseNoteLines::bRemoveHashtagRN' has a wrong offset!");
static_assert(offsetof(BuildMetadataSubsystem_GetFilteredReleaseNoteLines, ReturnValue) == 0x000008, "Member 'BuildMetadataSubsystem_GetFilteredReleaseNoteLines::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BuildMetadataSubsystem.GetFilteredReleaseNoteLinesForBuild
// 0x0018 (0x0018 - 0x0000)
struct BuildMetadataSubsystem_GetFilteredReleaseNoteLinesForBuild final
{
public:
	int32                                         buildChangelist;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveBuildNumberLines;                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveHashtagRN;                                  // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BuildMetadataSubsystem_GetFilteredReleaseNoteLinesForBuild) == 0x000008, "Wrong alignment on BuildMetadataSubsystem_GetFilteredReleaseNoteLinesForBuild");
static_assert(sizeof(BuildMetadataSubsystem_GetFilteredReleaseNoteLinesForBuild) == 0x000018, "Wrong size on BuildMetadataSubsystem_GetFilteredReleaseNoteLinesForBuild");
static_assert(offsetof(BuildMetadataSubsystem_GetFilteredReleaseNoteLinesForBuild, buildChangelist) == 0x000000, "Member 'BuildMetadataSubsystem_GetFilteredReleaseNoteLinesForBuild::buildChangelist' has a wrong offset!");
static_assert(offsetof(BuildMetadataSubsystem_GetFilteredReleaseNoteLinesForBuild, bRemoveBuildNumberLines) == 0x000004, "Member 'BuildMetadataSubsystem_GetFilteredReleaseNoteLinesForBuild::bRemoveBuildNumberLines' has a wrong offset!");
static_assert(offsetof(BuildMetadataSubsystem_GetFilteredReleaseNoteLinesForBuild, bRemoveHashtagRN) == 0x000005, "Member 'BuildMetadataSubsystem_GetFilteredReleaseNoteLinesForBuild::bRemoveHashtagRN' has a wrong offset!");
static_assert(offsetof(BuildMetadataSubsystem_GetFilteredReleaseNoteLinesForBuild, ReturnValue) == 0x000008, "Member 'BuildMetadataSubsystem_GetFilteredReleaseNoteLinesForBuild::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BuildMetadataSubsystem.GetRawReleaseNoteLines
// 0x0010 (0x0010 - 0x0000)
struct BuildMetadataSubsystem_GetRawReleaseNoteLines final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BuildMetadataSubsystem_GetRawReleaseNoteLines) == 0x000008, "Wrong alignment on BuildMetadataSubsystem_GetRawReleaseNoteLines");
static_assert(sizeof(BuildMetadataSubsystem_GetRawReleaseNoteLines) == 0x000010, "Wrong size on BuildMetadataSubsystem_GetRawReleaseNoteLines");
static_assert(offsetof(BuildMetadataSubsystem_GetRawReleaseNoteLines, ReturnValue) == 0x000000, "Member 'BuildMetadataSubsystem_GetRawReleaseNoteLines::ReturnValue' has a wrong offset!");

// Function DeceiveInc.BuildMetadataSubsystem.GetReleaseNoteBuildChangelistNumbers
// 0x0010 (0x0010 - 0x0000)
struct BuildMetadataSubsystem_GetReleaseNoteBuildChangelistNumbers final
{
public:
	TArray<int32>                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BuildMetadataSubsystem_GetReleaseNoteBuildChangelistNumbers) == 0x000008, "Wrong alignment on BuildMetadataSubsystem_GetReleaseNoteBuildChangelistNumbers");
static_assert(sizeof(BuildMetadataSubsystem_GetReleaseNoteBuildChangelistNumbers) == 0x000010, "Wrong size on BuildMetadataSubsystem_GetReleaseNoteBuildChangelistNumbers");
static_assert(offsetof(BuildMetadataSubsystem_GetReleaseNoteBuildChangelistNumbers, ReturnValue) == 0x000000, "Member 'BuildMetadataSubsystem_GetReleaseNoteBuildChangelistNumbers::ReturnValue' has a wrong offset!");

// Function DeceiveInc.CallingCardInGameUserWidget.SelectCallingcard
// 0x0001 (0x0001 - 0x0000)
struct CallingCardInGameUserWidget_SelectCallingcard final
{
public:
	ECallingCardPosition                          CardPosition;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CallingCardInGameUserWidget_SelectCallingcard) == 0x000001, "Wrong alignment on CallingCardInGameUserWidget_SelectCallingcard");
static_assert(sizeof(CallingCardInGameUserWidget_SelectCallingcard) == 0x000001, "Wrong size on CallingCardInGameUserWidget_SelectCallingcard");
static_assert(offsetof(CallingCardInGameUserWidget_SelectCallingcard, CardPosition) == 0x000000, "Member 'CallingCardInGameUserWidget_SelectCallingcard::CardPosition' has a wrong offset!");

// Function DeceiveInc.CallingCardInGameUserWidget.SelectCallingcardIndex
// 0x0004 (0x0004 - 0x0000)
struct CallingCardInGameUserWidget_SelectCallingcardIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CallingCardInGameUserWidget_SelectCallingcardIndex) == 0x000004, "Wrong alignment on CallingCardInGameUserWidget_SelectCallingcardIndex");
static_assert(sizeof(CallingCardInGameUserWidget_SelectCallingcardIndex) == 0x000004, "Wrong size on CallingCardInGameUserWidget_SelectCallingcardIndex");
static_assert(offsetof(CallingCardInGameUserWidget_SelectCallingcardIndex, Index_0) == 0x000000, "Member 'CallingCardInGameUserWidget_SelectCallingcardIndex::Index_0' has a wrong offset!");

// Function DeceiveInc.PlatformDataAsset.GetCurrentPlatformName
// 0x0010 (0x0010 - 0x0000)
struct PlatformDataAsset_GetCurrentPlatformName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlatformDataAsset_GetCurrentPlatformName) == 0x000008, "Wrong alignment on PlatformDataAsset_GetCurrentPlatformName");
static_assert(sizeof(PlatformDataAsset_GetCurrentPlatformName) == 0x000010, "Wrong size on PlatformDataAsset_GetCurrentPlatformName");
static_assert(offsetof(PlatformDataAsset_GetCurrentPlatformName, ReturnValue) == 0x000000, "Member 'PlatformDataAsset_GetCurrentPlatformName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PlatformDataAsset.GetCurrentPlatformType
// 0x0001 (0x0001 - 0x0000)
struct PlatformDataAsset_GetCurrentPlatformType final
{
public:
	EPlatformType                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlatformDataAsset_GetCurrentPlatformType) == 0x000001, "Wrong alignment on PlatformDataAsset_GetCurrentPlatformType");
static_assert(sizeof(PlatformDataAsset_GetCurrentPlatformType) == 0x000001, "Wrong size on PlatformDataAsset_GetCurrentPlatformType");
static_assert(offsetof(PlatformDataAsset_GetCurrentPlatformType, ReturnValue) == 0x000000, "Member 'PlatformDataAsset_GetCurrentPlatformType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PlatformDataAsset.GetPlatformType
// 0x0018 (0x0018 - 0x0000)
struct PlatformDataAsset_GetPlatformType final
{
public:
	class FString                                 PlateformName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlatformType                                 ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlatformDataAsset_GetPlatformType) == 0x000008, "Wrong alignment on PlatformDataAsset_GetPlatformType");
static_assert(sizeof(PlatformDataAsset_GetPlatformType) == 0x000018, "Wrong size on PlatformDataAsset_GetPlatformType");
static_assert(offsetof(PlatformDataAsset_GetPlatformType, PlateformName) == 0x000000, "Member 'PlatformDataAsset_GetPlatformType::PlateformName' has a wrong offset!");
static_assert(offsetof(PlatformDataAsset_GetPlatformType, ReturnValue) == 0x000010, "Member 'PlatformDataAsset_GetPlatformType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.CallingCardPlaceableTool.HandleOnNewDropActorDropped
// 0x0028 (0x0028 - 0x0000)
struct CallingCardPlaceableTool_HandleOnNewDropActorDropped final
{
public:
	class AActor*                                 ServerActorToDrop;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 LocalActorToDrop;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocation;                                       // 0x0010(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               EndRotation;                                       // 0x001C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(CallingCardPlaceableTool_HandleOnNewDropActorDropped) == 0x000008, "Wrong alignment on CallingCardPlaceableTool_HandleOnNewDropActorDropped");
static_assert(sizeof(CallingCardPlaceableTool_HandleOnNewDropActorDropped) == 0x000028, "Wrong size on CallingCardPlaceableTool_HandleOnNewDropActorDropped");
static_assert(offsetof(CallingCardPlaceableTool_HandleOnNewDropActorDropped, ServerActorToDrop) == 0x000000, "Member 'CallingCardPlaceableTool_HandleOnNewDropActorDropped::ServerActorToDrop' has a wrong offset!");
static_assert(offsetof(CallingCardPlaceableTool_HandleOnNewDropActorDropped, LocalActorToDrop) == 0x000008, "Member 'CallingCardPlaceableTool_HandleOnNewDropActorDropped::LocalActorToDrop' has a wrong offset!");
static_assert(offsetof(CallingCardPlaceableTool_HandleOnNewDropActorDropped, EndLocation) == 0x000010, "Member 'CallingCardPlaceableTool_HandleOnNewDropActorDropped::EndLocation' has a wrong offset!");
static_assert(offsetof(CallingCardPlaceableTool_HandleOnNewDropActorDropped, EndRotation) == 0x00001C, "Member 'CallingCardPlaceableTool_HandleOnNewDropActorDropped::EndRotation' has a wrong offset!");

// Function DeceiveInc.CallingCardPlaceableTool.NetMulticast_OnNewSelectedCallingCard
// 0x0004 (0x0004 - 0x0000)
struct CallingCardPlaceableTool_NetMulticast_OnNewSelectedCallingCard final
{
public:
	int32                                         NewSelectedCallingCard;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CallingCardPlaceableTool_NetMulticast_OnNewSelectedCallingCard) == 0x000004, "Wrong alignment on CallingCardPlaceableTool_NetMulticast_OnNewSelectedCallingCard");
static_assert(sizeof(CallingCardPlaceableTool_NetMulticast_OnNewSelectedCallingCard) == 0x000004, "Wrong size on CallingCardPlaceableTool_NetMulticast_OnNewSelectedCallingCard");
static_assert(offsetof(CallingCardPlaceableTool_NetMulticast_OnNewSelectedCallingCard, NewSelectedCallingCard) == 0x000000, "Member 'CallingCardPlaceableTool_NetMulticast_OnNewSelectedCallingCard::NewSelectedCallingCard' has a wrong offset!");

// Function DeceiveInc.CallingCardPlaceableTool.Server_OnNewSelectedCallingCard
// 0x0004 (0x0004 - 0x0000)
struct CallingCardPlaceableTool_Server_OnNewSelectedCallingCard final
{
public:
	int32                                         NewSelectedCallingCard;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CallingCardPlaceableTool_Server_OnNewSelectedCallingCard) == 0x000004, "Wrong alignment on CallingCardPlaceableTool_Server_OnNewSelectedCallingCard");
static_assert(sizeof(CallingCardPlaceableTool_Server_OnNewSelectedCallingCard) == 0x000004, "Wrong size on CallingCardPlaceableTool_Server_OnNewSelectedCallingCard");
static_assert(offsetof(CallingCardPlaceableTool_Server_OnNewSelectedCallingCard, NewSelectedCallingCard) == 0x000000, "Member 'CallingCardPlaceableTool_Server_OnNewSelectedCallingCard::NewSelectedCallingCard' has a wrong offset!");

// Function DeceiveInc.CallingCardPlaceableTool.IsThrowingCard
// 0x0001 (0x0001 - 0x0000)
struct CallingCardPlaceableTool_IsThrowingCard final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CallingCardPlaceableTool_IsThrowingCard) == 0x000001, "Wrong alignment on CallingCardPlaceableTool_IsThrowingCard");
static_assert(sizeof(CallingCardPlaceableTool_IsThrowingCard) == 0x000001, "Wrong size on CallingCardPlaceableTool_IsThrowingCard");
static_assert(offsetof(CallingCardPlaceableTool_IsThrowingCard, ReturnValue) == 0x000000, "Member 'CallingCardPlaceableTool_IsThrowingCard::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PoisonAoEActor.HandleLoadoutSpawnComplete
// 0x0008 (0x0008 - 0x0000)
struct PoisonAoEActor_HandleLoadoutSpawnComplete final
{
public:
	class UToolLoadoutComponent*                  ToolLoadout;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PoisonAoEActor_HandleLoadoutSpawnComplete) == 0x000008, "Wrong alignment on PoisonAoEActor_HandleLoadoutSpawnComplete");
static_assert(sizeof(PoisonAoEActor_HandleLoadoutSpawnComplete) == 0x000008, "Wrong size on PoisonAoEActor_HandleLoadoutSpawnComplete");
static_assert(offsetof(PoisonAoEActor_HandleLoadoutSpawnComplete, ToolLoadout) == 0x000000, "Member 'PoisonAoEActor_HandleLoadoutSpawnComplete::ToolLoadout' has a wrong offset!");

// Function DeceiveInc.CavaliereActiveAbility.HandleCavActiveInteractionCancel
// 0x0010 (0x0010 - 0x0000)
struct CavaliereActiveAbility_HandleCavActiveInteractionCancel final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavaliereActiveAbility_HandleCavActiveInteractionCancel) == 0x000008, "Wrong alignment on CavaliereActiveAbility_HandleCavActiveInteractionCancel");
static_assert(sizeof(CavaliereActiveAbility_HandleCavActiveInteractionCancel) == 0x000010, "Wrong size on CavaliereActiveAbility_HandleCavActiveInteractionCancel");
static_assert(offsetof(CavaliereActiveAbility_HandleCavActiveInteractionCancel, Interacter) == 0x000000, "Member 'CavaliereActiveAbility_HandleCavActiveInteractionCancel::Interacter' has a wrong offset!");
static_assert(offsetof(CavaliereActiveAbility_HandleCavActiveInteractionCancel, Interactable) == 0x000008, "Member 'CavaliereActiveAbility_HandleCavActiveInteractionCancel::Interactable' has a wrong offset!");

// Function DeceiveInc.CavaliereActiveAbility.HandleCavActiveInteractionComplete
// 0x0020 (0x0020 - 0x0000)
struct CavaliereActiveAbility_HandleCavActiveInteractionComplete final
{
public:
	struct FInteractableData                      InteractableData;                                  // 0x0000(0x0020)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavaliereActiveAbility_HandleCavActiveInteractionComplete) == 0x000008, "Wrong alignment on CavaliereActiveAbility_HandleCavActiveInteractionComplete");
static_assert(sizeof(CavaliereActiveAbility_HandleCavActiveInteractionComplete) == 0x000020, "Wrong size on CavaliereActiveAbility_HandleCavActiveInteractionComplete");
static_assert(offsetof(CavaliereActiveAbility_HandleCavActiveInteractionComplete, InteractableData) == 0x000000, "Member 'CavaliereActiveAbility_HandleCavActiveInteractionComplete::InteractableData' has a wrong offset!");

// Function DeceiveInc.CavaliereActiveAbility.HandleCavActiveInteractionStart
// 0x0010 (0x0010 - 0x0000)
struct CavaliereActiveAbility_HandleCavActiveInteractionStart final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavaliereActiveAbility_HandleCavActiveInteractionStart) == 0x000008, "Wrong alignment on CavaliereActiveAbility_HandleCavActiveInteractionStart");
static_assert(sizeof(CavaliereActiveAbility_HandleCavActiveInteractionStart) == 0x000010, "Wrong size on CavaliereActiveAbility_HandleCavActiveInteractionStart");
static_assert(offsetof(CavaliereActiveAbility_HandleCavActiveInteractionStart, Interacter) == 0x000000, "Member 'CavaliereActiveAbility_HandleCavActiveInteractionStart::Interacter' has a wrong offset!");
static_assert(offsetof(CavaliereActiveAbility_HandleCavActiveInteractionStart, Interactable) == 0x000008, "Member 'CavaliereActiveAbility_HandleCavActiveInteractionStart::Interactable' has a wrong offset!");

// Function DeceiveInc.CavaliereActiveAbility.HandleCavActiveRegisterInteractable
// 0x0020 (0x0020 - 0x0000)
struct CavaliereActiveAbility_HandleCavActiveRegisterInteractable final
{
public:
	struct FInteractableData                      InteractableData;                                  // 0x0000(0x0020)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavaliereActiveAbility_HandleCavActiveRegisterInteractable) == 0x000008, "Wrong alignment on CavaliereActiveAbility_HandleCavActiveRegisterInteractable");
static_assert(sizeof(CavaliereActiveAbility_HandleCavActiveRegisterInteractable) == 0x000020, "Wrong size on CavaliereActiveAbility_HandleCavActiveRegisterInteractable");
static_assert(offsetof(CavaliereActiveAbility_HandleCavActiveRegisterInteractable, InteractableData) == 0x000000, "Member 'CavaliereActiveAbility_HandleCavActiveRegisterInteractable::InteractableData' has a wrong offset!");

// Function DeceiveInc.CavaliereActiveAbility.HandleNewFocusedInteractable
// 0x0008 (0x0008 - 0x0000)
struct CavaliereActiveAbility_HandleNewFocusedInteractable final
{
public:
	class UInteractableComponent*                 NewFocusedInteractable;                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavaliereActiveAbility_HandleNewFocusedInteractable) == 0x000008, "Wrong alignment on CavaliereActiveAbility_HandleNewFocusedInteractable");
static_assert(sizeof(CavaliereActiveAbility_HandleNewFocusedInteractable) == 0x000008, "Wrong size on CavaliereActiveAbility_HandleNewFocusedInteractable");
static_assert(offsetof(CavaliereActiveAbility_HandleNewFocusedInteractable, NewFocusedInteractable) == 0x000000, "Member 'CavaliereActiveAbility_HandleNewFocusedInteractable::NewFocusedInteractable' has a wrong offset!");

// Function DeceiveInc.CavaliereActiveAbility.NetMulticast_OnChasingEnd
// 0x0008 (0x0008 - 0x0000)
struct CavaliereActiveAbility_NetMulticast_OnChasingEnd final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavaliereActiveAbility_NetMulticast_OnChasingEnd) == 0x000008, "Wrong alignment on CavaliereActiveAbility_NetMulticast_OnChasingEnd");
static_assert(sizeof(CavaliereActiveAbility_NetMulticast_OnChasingEnd) == 0x000008, "Wrong size on CavaliereActiveAbility_NetMulticast_OnChasingEnd");
static_assert(offsetof(CavaliereActiveAbility_NetMulticast_OnChasingEnd, Victim) == 0x000000, "Member 'CavaliereActiveAbility_NetMulticast_OnChasingEnd::Victim' has a wrong offset!");

// Function DeceiveInc.CavaliereActiveAbility.NetMulticast_OnChasingStart
// 0x0008 (0x0008 - 0x0000)
struct CavaliereActiveAbility_NetMulticast_OnChasingStart final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavaliereActiveAbility_NetMulticast_OnChasingStart) == 0x000008, "Wrong alignment on CavaliereActiveAbility_NetMulticast_OnChasingStart");
static_assert(sizeof(CavaliereActiveAbility_NetMulticast_OnChasingStart) == 0x000008, "Wrong size on CavaliereActiveAbility_NetMulticast_OnChasingStart");
static_assert(offsetof(CavaliereActiveAbility_NetMulticast_OnChasingStart, Victim) == 0x000000, "Member 'CavaliereActiveAbility_NetMulticast_OnChasingStart::Victim' has a wrong offset!");

// Function DeceiveInc.CavaliereActiveAbility.OnChasingEnd
// 0x0008 (0x0008 - 0x0000)
struct CavaliereActiveAbility_OnChasingEnd final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavaliereActiveAbility_OnChasingEnd) == 0x000008, "Wrong alignment on CavaliereActiveAbility_OnChasingEnd");
static_assert(sizeof(CavaliereActiveAbility_OnChasingEnd) == 0x000008, "Wrong size on CavaliereActiveAbility_OnChasingEnd");
static_assert(offsetof(CavaliereActiveAbility_OnChasingEnd, Victim) == 0x000000, "Member 'CavaliereActiveAbility_OnChasingEnd::Victim' has a wrong offset!");

// Function DeceiveInc.CavaliereActiveAbility.Server_OnCavActiveInteractionCancel
// 0x0010 (0x0010 - 0x0000)
struct CavaliereActiveAbility_Server_OnCavActiveInteractionCancel final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavaliereActiveAbility_Server_OnCavActiveInteractionCancel) == 0x000008, "Wrong alignment on CavaliereActiveAbility_Server_OnCavActiveInteractionCancel");
static_assert(sizeof(CavaliereActiveAbility_Server_OnCavActiveInteractionCancel) == 0x000010, "Wrong size on CavaliereActiveAbility_Server_OnCavActiveInteractionCancel");
static_assert(offsetof(CavaliereActiveAbility_Server_OnCavActiveInteractionCancel, Interacter) == 0x000000, "Member 'CavaliereActiveAbility_Server_OnCavActiveInteractionCancel::Interacter' has a wrong offset!");
static_assert(offsetof(CavaliereActiveAbility_Server_OnCavActiveInteractionCancel, Interactable) == 0x000008, "Member 'CavaliereActiveAbility_Server_OnCavActiveInteractionCancel::Interactable' has a wrong offset!");

// Function DeceiveInc.CavaliereActiveAbility.Server_OnCavActiveInteractionComplete
// 0x0010 (0x0010 - 0x0000)
struct CavaliereActiveAbility_Server_OnCavActiveInteractionComplete final
{
public:
	class UInteractableComponent*                 Interactable;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         TimeOfRequest;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavaliereActiveAbility_Server_OnCavActiveInteractionComplete) == 0x000008, "Wrong alignment on CavaliereActiveAbility_Server_OnCavActiveInteractionComplete");
static_assert(sizeof(CavaliereActiveAbility_Server_OnCavActiveInteractionComplete) == 0x000010, "Wrong size on CavaliereActiveAbility_Server_OnCavActiveInteractionComplete");
static_assert(offsetof(CavaliereActiveAbility_Server_OnCavActiveInteractionComplete, Interactable) == 0x000000, "Member 'CavaliereActiveAbility_Server_OnCavActiveInteractionComplete::Interactable' has a wrong offset!");
static_assert(offsetof(CavaliereActiveAbility_Server_OnCavActiveInteractionComplete, TimeOfRequest) == 0x000008, "Member 'CavaliereActiveAbility_Server_OnCavActiveInteractionComplete::TimeOfRequest' has a wrong offset!");

// Function DeceiveInc.CavaliereActiveAbility.Server_OnCavActiveInteractionStart
// 0x0010 (0x0010 - 0x0000)
struct CavaliereActiveAbility_Server_OnCavActiveInteractionStart final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavaliereActiveAbility_Server_OnCavActiveInteractionStart) == 0x000008, "Wrong alignment on CavaliereActiveAbility_Server_OnCavActiveInteractionStart");
static_assert(sizeof(CavaliereActiveAbility_Server_OnCavActiveInteractionStart) == 0x000010, "Wrong size on CavaliereActiveAbility_Server_OnCavActiveInteractionStart");
static_assert(offsetof(CavaliereActiveAbility_Server_OnCavActiveInteractionStart, Interacter) == 0x000000, "Member 'CavaliereActiveAbility_Server_OnCavActiveInteractionStart::Interacter' has a wrong offset!");
static_assert(offsetof(CavaliereActiveAbility_Server_OnCavActiveInteractionStart, Interactable) == 0x000008, "Member 'CavaliereActiveAbility_Server_OnCavActiveInteractionStart::Interactable' has a wrong offset!");

// Function DeceiveInc.CavaliereActiveAbility.SetInteractionProgressBar
// 0x0008 (0x0008 - 0x0000)
struct CavaliereActiveAbility_SetInteractionProgressBar final
{
public:
	class UProgressBar*                           ProgressBar;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavaliereActiveAbility_SetInteractionProgressBar) == 0x000008, "Wrong alignment on CavaliereActiveAbility_SetInteractionProgressBar");
static_assert(sizeof(CavaliereActiveAbility_SetInteractionProgressBar) == 0x000008, "Wrong size on CavaliereActiveAbility_SetInteractionProgressBar");
static_assert(offsetof(CavaliereActiveAbility_SetInteractionProgressBar, ProgressBar) == 0x000000, "Member 'CavaliereActiveAbility_SetInteractionProgressBar::ProgressBar' has a wrong offset!");

// Function DeceiveInc.PointOfInterestComponent.EnablePOI
// 0x0001 (0x0001 - 0x0000)
struct PointOfInterestComponent_EnablePOI final
{
public:
	bool                                          bEnableIn;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PointOfInterestComponent_EnablePOI) == 0x000001, "Wrong alignment on PointOfInterestComponent_EnablePOI");
static_assert(sizeof(PointOfInterestComponent_EnablePOI) == 0x000001, "Wrong size on PointOfInterestComponent_EnablePOI");
static_assert(offsetof(PointOfInterestComponent_EnablePOI, bEnableIn) == 0x000000, "Member 'PointOfInterestComponent_EnablePOI::bEnableIn' has a wrong offset!");

// Function DeceiveInc.PointOfInterestComponent.IsEnabled
// 0x0001 (0x0001 - 0x0000)
struct PointOfInterestComponent_IsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PointOfInterestComponent_IsEnabled) == 0x000001, "Wrong alignment on PointOfInterestComponent_IsEnabled");
static_assert(sizeof(PointOfInterestComponent_IsEnabled) == 0x000001, "Wrong size on PointOfInterestComponent_IsEnabled");
static_assert(offsetof(PointOfInterestComponent_IsEnabled, ReturnValue) == 0x000000, "Member 'PointOfInterestComponent_IsEnabled::ReturnValue' has a wrong offset!");

// Function DeceiveInc.CavaliereActiveAbilityMod2.Client_OnSpyTrapped
// 0x0008 (0x0008 - 0x0000)
struct CavaliereActiveAbilityMod2_Client_OnSpyTrapped final
{
public:
	class AActor*                                 TrappedSpy;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavaliereActiveAbilityMod2_Client_OnSpyTrapped) == 0x000008, "Wrong alignment on CavaliereActiveAbilityMod2_Client_OnSpyTrapped");
static_assert(sizeof(CavaliereActiveAbilityMod2_Client_OnSpyTrapped) == 0x000008, "Wrong size on CavaliereActiveAbilityMod2_Client_OnSpyTrapped");
static_assert(offsetof(CavaliereActiveAbilityMod2_Client_OnSpyTrapped, TrappedSpy) == 0x000000, "Member 'CavaliereActiveAbilityMod2_Client_OnSpyTrapped::TrappedSpy' has a wrong offset!");

// Function DeceiveInc.CavaliereActiveAbilityMod2.HandleMiscToolSpawned
// 0x0008 (0x0008 - 0x0000)
struct CavaliereActiveAbilityMod2_HandleMiscToolSpawned final
{
public:
	class AActor*                                 SpawnedTool;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavaliereActiveAbilityMod2_HandleMiscToolSpawned) == 0x000008, "Wrong alignment on CavaliereActiveAbilityMod2_HandleMiscToolSpawned");
static_assert(sizeof(CavaliereActiveAbilityMod2_HandleMiscToolSpawned) == 0x000008, "Wrong size on CavaliereActiveAbilityMod2_HandleMiscToolSpawned");
static_assert(offsetof(CavaliereActiveAbilityMod2_HandleMiscToolSpawned, SpawnedTool) == 0x000000, "Member 'CavaliereActiveAbilityMod2_HandleMiscToolSpawned::SpawnedTool' has a wrong offset!");

// Function DeceiveInc.CavaliereActiveAbilityMod2.HandleTrappedSpy
// 0x0008 (0x0008 - 0x0000)
struct CavaliereActiveAbilityMod2_HandleTrappedSpy final
{
public:
	class AActor*                                 TrappedSpy;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavaliereActiveAbilityMod2_HandleTrappedSpy) == 0x000008, "Wrong alignment on CavaliereActiveAbilityMod2_HandleTrappedSpy");
static_assert(sizeof(CavaliereActiveAbilityMod2_HandleTrappedSpy) == 0x000008, "Wrong size on CavaliereActiveAbilityMod2_HandleTrappedSpy");
static_assert(offsetof(CavaliereActiveAbilityMod2_HandleTrappedSpy, TrappedSpy) == 0x000000, "Member 'CavaliereActiveAbilityMod2_HandleTrappedSpy::TrappedSpy' has a wrong offset!");

// Function DeceiveInc.CavalierePassiveAbility.BP_OnMeleeAttackEvent
// 0x0010 (0x0010 - 0x0000)
struct CavalierePassiveAbility_BP_OnMeleeAttackEvent final
{
public:
	ESpyMeleeAttackEvent                          EventType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseMeleeAttack*                       MeleeAttack;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavalierePassiveAbility_BP_OnMeleeAttackEvent) == 0x000008, "Wrong alignment on CavalierePassiveAbility_BP_OnMeleeAttackEvent");
static_assert(sizeof(CavalierePassiveAbility_BP_OnMeleeAttackEvent) == 0x000010, "Wrong size on CavalierePassiveAbility_BP_OnMeleeAttackEvent");
static_assert(offsetof(CavalierePassiveAbility_BP_OnMeleeAttackEvent, EventType) == 0x000000, "Member 'CavalierePassiveAbility_BP_OnMeleeAttackEvent::EventType' has a wrong offset!");
static_assert(offsetof(CavalierePassiveAbility_BP_OnMeleeAttackEvent, MeleeAttack) == 0x000008, "Member 'CavalierePassiveAbility_BP_OnMeleeAttackEvent::MeleeAttack' has a wrong offset!");

// Function DeceiveInc.CavalierePassiveAbility.HandleMeleeAttackEvent
// 0x0010 (0x0010 - 0x0000)
struct CavalierePassiveAbility_HandleMeleeAttackEvent final
{
public:
	ESpyMeleeAttackEvent                          EventType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseMeleeAttack*                       MeleeAttack;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavalierePassiveAbility_HandleMeleeAttackEvent) == 0x000008, "Wrong alignment on CavalierePassiveAbility_HandleMeleeAttackEvent");
static_assert(sizeof(CavalierePassiveAbility_HandleMeleeAttackEvent) == 0x000010, "Wrong size on CavalierePassiveAbility_HandleMeleeAttackEvent");
static_assert(offsetof(CavalierePassiveAbility_HandleMeleeAttackEvent, EventType) == 0x000000, "Member 'CavalierePassiveAbility_HandleMeleeAttackEvent::EventType' has a wrong offset!");
static_assert(offsetof(CavalierePassiveAbility_HandleMeleeAttackEvent, MeleeAttack) == 0x000008, "Member 'CavalierePassiveAbility_HandleMeleeAttackEvent::MeleeAttack' has a wrong offset!");

// Function DeceiveInc.CavalierePassiveAbility.HandleMeleeAttackLoadComplete
// 0x0008 (0x0008 - 0x0000)
struct CavalierePassiveAbility_HandleMeleeAttackLoadComplete final
{
public:
	class UToolLoadoutComponent*                  LoadoutComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavalierePassiveAbility_HandleMeleeAttackLoadComplete) == 0x000008, "Wrong alignment on CavalierePassiveAbility_HandleMeleeAttackLoadComplete");
static_assert(sizeof(CavalierePassiveAbility_HandleMeleeAttackLoadComplete) == 0x000008, "Wrong size on CavalierePassiveAbility_HandleMeleeAttackLoadComplete");
static_assert(offsetof(CavalierePassiveAbility_HandleMeleeAttackLoadComplete, LoadoutComponent) == 0x000000, "Member 'CavalierePassiveAbility_HandleMeleeAttackLoadComplete::LoadoutComponent' has a wrong offset!");

// Function DeceiveInc.CavalierePassiveAbility.NonLocalClientHandleMeleeAttackEvent
// 0x0010 (0x0010 - 0x0000)
struct CavalierePassiveAbility_NonLocalClientHandleMeleeAttackEvent final
{
public:
	ESpyMeleeAttackEvent                          EventType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseMeleeAttack*                       MeleeAttack;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavalierePassiveAbility_NonLocalClientHandleMeleeAttackEvent) == 0x000008, "Wrong alignment on CavalierePassiveAbility_NonLocalClientHandleMeleeAttackEvent");
static_assert(sizeof(CavalierePassiveAbility_NonLocalClientHandleMeleeAttackEvent) == 0x000010, "Wrong size on CavalierePassiveAbility_NonLocalClientHandleMeleeAttackEvent");
static_assert(offsetof(CavalierePassiveAbility_NonLocalClientHandleMeleeAttackEvent, EventType) == 0x000000, "Member 'CavalierePassiveAbility_NonLocalClientHandleMeleeAttackEvent::EventType' has a wrong offset!");
static_assert(offsetof(CavalierePassiveAbility_NonLocalClientHandleMeleeAttackEvent, MeleeAttack) == 0x000008, "Member 'CavalierePassiveAbility_NonLocalClientHandleMeleeAttackEvent::MeleeAttack' has a wrong offset!");

// Function DeceiveInc.CavalierePassiveAbilityMod2.HandleMeleeAttackDamageDoneServer
// 0x0068 (0x0068 - 0x0000)
struct CavalierePassiveAbilityMod2_HandleMeleeAttackDamageDoneServer final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPoint;                                       // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChargeLevel;                                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageDone;                                        // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultingHealthPercentage;                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitType                                      HitType;                                           // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMeleeHitConfirmedData                 HitConfirmedData;                                  // 0x0028(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavalierePassiveAbilityMod2_HandleMeleeAttackDamageDoneServer) == 0x000008, "Wrong alignment on CavalierePassiveAbilityMod2_HandleMeleeAttackDamageDoneServer");
static_assert(sizeof(CavalierePassiveAbilityMod2_HandleMeleeAttackDamageDoneServer) == 0x000068, "Wrong size on CavalierePassiveAbilityMod2_HandleMeleeAttackDamageDoneServer");
static_assert(offsetof(CavalierePassiveAbilityMod2_HandleMeleeAttackDamageDoneServer, Victim) == 0x000000, "Member 'CavalierePassiveAbilityMod2_HandleMeleeAttackDamageDoneServer::Victim' has a wrong offset!");
static_assert(offsetof(CavalierePassiveAbilityMod2_HandleMeleeAttackDamageDoneServer, ImpactPoint) == 0x000008, "Member 'CavalierePassiveAbilityMod2_HandleMeleeAttackDamageDoneServer::ImpactPoint' has a wrong offset!");
static_assert(offsetof(CavalierePassiveAbilityMod2_HandleMeleeAttackDamageDoneServer, ChargeLevel) == 0x000014, "Member 'CavalierePassiveAbilityMod2_HandleMeleeAttackDamageDoneServer::ChargeLevel' has a wrong offset!");
static_assert(offsetof(CavalierePassiveAbilityMod2_HandleMeleeAttackDamageDoneServer, DamageDone) == 0x000018, "Member 'CavalierePassiveAbilityMod2_HandleMeleeAttackDamageDoneServer::DamageDone' has a wrong offset!");
static_assert(offsetof(CavalierePassiveAbilityMod2_HandleMeleeAttackDamageDoneServer, ResultingHealthPercentage) == 0x00001C, "Member 'CavalierePassiveAbilityMod2_HandleMeleeAttackDamageDoneServer::ResultingHealthPercentage' has a wrong offset!");
static_assert(offsetof(CavalierePassiveAbilityMod2_HandleMeleeAttackDamageDoneServer, HitType) == 0x000020, "Member 'CavalierePassiveAbilityMod2_HandleMeleeAttackDamageDoneServer::HitType' has a wrong offset!");
static_assert(offsetof(CavalierePassiveAbilityMod2_HandleMeleeAttackDamageDoneServer, HitConfirmedData) == 0x000028, "Member 'CavalierePassiveAbilityMod2_HandleMeleeAttackDamageDoneServer::HitConfirmedData' has a wrong offset!");

// Function DeceiveInc.CavalierePassiveAbilityMod2.HandleMeleeAttackLoadComplete
// 0x0008 (0x0008 - 0x0000)
struct CavalierePassiveAbilityMod2_HandleMeleeAttackLoadComplete final
{
public:
	class UToolLoadoutComponent*                  LoadoutComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CavalierePassiveAbilityMod2_HandleMeleeAttackLoadComplete) == 0x000008, "Wrong alignment on CavalierePassiveAbilityMod2_HandleMeleeAttackLoadComplete");
static_assert(sizeof(CavalierePassiveAbilityMod2_HandleMeleeAttackLoadComplete) == 0x000008, "Wrong size on CavalierePassiveAbilityMod2_HandleMeleeAttackLoadComplete");
static_assert(offsetof(CavalierePassiveAbilityMod2_HandleMeleeAttackLoadComplete, LoadoutComponent) == 0x000000, "Member 'CavalierePassiveAbilityMod2_HandleMeleeAttackLoadComplete::LoadoutComponent' has a wrong offset!");

// Function DeceiveInc.ChangePhaseComponent.HandleInteractionComplete
// 0x0010 (0x0010 - 0x0000)
struct ChangePhaseComponent_HandleInteractionComplete final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChangePhaseComponent_HandleInteractionComplete) == 0x000008, "Wrong alignment on ChangePhaseComponent_HandleInteractionComplete");
static_assert(sizeof(ChangePhaseComponent_HandleInteractionComplete) == 0x000010, "Wrong size on ChangePhaseComponent_HandleInteractionComplete");
static_assert(offsetof(ChangePhaseComponent_HandleInteractionComplete, Interacter) == 0x000000, "Member 'ChangePhaseComponent_HandleInteractionComplete::Interacter' has a wrong offset!");
static_assert(offsetof(ChangePhaseComponent_HandleInteractionComplete, Interactable) == 0x000008, "Member 'ChangePhaseComponent_HandleInteractionComplete::Interactable' has a wrong offset!");

// Function DeceiveInc.ChargeLevelsWeaponComponent.GetCurrentChargeLevel
// 0x0004 (0x0004 - 0x0000)
struct ChargeLevelsWeaponComponent_GetCurrentChargeLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChargeLevelsWeaponComponent_GetCurrentChargeLevel) == 0x000004, "Wrong alignment on ChargeLevelsWeaponComponent_GetCurrentChargeLevel");
static_assert(sizeof(ChargeLevelsWeaponComponent_GetCurrentChargeLevel) == 0x000004, "Wrong size on ChargeLevelsWeaponComponent_GetCurrentChargeLevel");
static_assert(offsetof(ChargeLevelsWeaponComponent_GetCurrentChargeLevel, ReturnValue) == 0x000000, "Member 'ChargeLevelsWeaponComponent_GetCurrentChargeLevel::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ChargeLevelsWeaponComponent.HandleWeaponProjectileImpact
// 0x0050 (0x0050 - 0x0000)
struct ChargeLevelsWeaponComponent_HandleWeaponProjectileImpact final
{
public:
	struct FWeaponImpactData                      WeaponImpactData;                                  // 0x0000(0x0050)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChargeLevelsWeaponComponent_HandleWeaponProjectileImpact) == 0x000008, "Wrong alignment on ChargeLevelsWeaponComponent_HandleWeaponProjectileImpact");
static_assert(sizeof(ChargeLevelsWeaponComponent_HandleWeaponProjectileImpact) == 0x000050, "Wrong size on ChargeLevelsWeaponComponent_HandleWeaponProjectileImpact");
static_assert(offsetof(ChargeLevelsWeaponComponent_HandleWeaponProjectileImpact, WeaponImpactData) == 0x000000, "Member 'ChargeLevelsWeaponComponent_HandleWeaponProjectileImpact::WeaponImpactData' has a wrong offset!");

// Function DeceiveInc.ChargeLevelsWeaponComponent.OnChargeChanged
// 0x0010 (0x0010 - 0x0000)
struct ChargeLevelsWeaponComponent_OnChargeChanged final
{
public:
	bool                                          bIsCharging;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AChargeSpawnerWeapon*                   ChargeWeapon;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChargeLevelsWeaponComponent_OnChargeChanged) == 0x000008, "Wrong alignment on ChargeLevelsWeaponComponent_OnChargeChanged");
static_assert(sizeof(ChargeLevelsWeaponComponent_OnChargeChanged) == 0x000010, "Wrong size on ChargeLevelsWeaponComponent_OnChargeChanged");
static_assert(offsetof(ChargeLevelsWeaponComponent_OnChargeChanged, bIsCharging) == 0x000000, "Member 'ChargeLevelsWeaponComponent_OnChargeChanged::bIsCharging' has a wrong offset!");
static_assert(offsetof(ChargeLevelsWeaponComponent_OnChargeChanged, ChargeWeapon) == 0x000008, "Member 'ChargeLevelsWeaponComponent_OnChargeChanged::ChargeWeapon' has a wrong offset!");

// Function DeceiveInc.ChargeLevelsWeaponComponent.OnLoadoutSpawnComplete
// 0x0008 (0x0008 - 0x0000)
struct ChargeLevelsWeaponComponent_OnLoadoutSpawnComplete final
{
public:
	class UToolLoadoutComponent*                  ToolLoadout;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChargeLevelsWeaponComponent_OnLoadoutSpawnComplete) == 0x000008, "Wrong alignment on ChargeLevelsWeaponComponent_OnLoadoutSpawnComplete");
static_assert(sizeof(ChargeLevelsWeaponComponent_OnLoadoutSpawnComplete) == 0x000008, "Wrong size on ChargeLevelsWeaponComponent_OnLoadoutSpawnComplete");
static_assert(offsetof(ChargeLevelsWeaponComponent_OnLoadoutSpawnComplete, ToolLoadout) == 0x000000, "Member 'ChargeLevelsWeaponComponent_OnLoadoutSpawnComplete::ToolLoadout' has a wrong offset!");

// Function DeceiveInc.ChargeLevelsWeaponComponent.OnProjectilesReleased
// 0x000C (0x000C - 0x0000)
struct ChargeLevelsWeaponComponent_OnProjectilesReleased final
{
public:
	struct FVector                                AimedPosition;                                     // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChargeLevelsWeaponComponent_OnProjectilesReleased) == 0x000004, "Wrong alignment on ChargeLevelsWeaponComponent_OnProjectilesReleased");
static_assert(sizeof(ChargeLevelsWeaponComponent_OnProjectilesReleased) == 0x00000C, "Wrong size on ChargeLevelsWeaponComponent_OnProjectilesReleased");
static_assert(offsetof(ChargeLevelsWeaponComponent_OnProjectilesReleased, AimedPosition) == 0x000000, "Member 'ChargeLevelsWeaponComponent_OnProjectilesReleased::AimedPosition' has a wrong offset!");

// Function DeceiveInc.ChargeLevelsWeaponComponent.OnRep_ChargeLevel
// 0x0004 (0x0004 - 0x0000)
struct ChargeLevelsWeaponComponent_OnRep_ChargeLevel final
{
public:
	int32                                         PrevChargeLevel;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChargeLevelsWeaponComponent_OnRep_ChargeLevel) == 0x000004, "Wrong alignment on ChargeLevelsWeaponComponent_OnRep_ChargeLevel");
static_assert(sizeof(ChargeLevelsWeaponComponent_OnRep_ChargeLevel) == 0x000004, "Wrong size on ChargeLevelsWeaponComponent_OnRep_ChargeLevel");
static_assert(offsetof(ChargeLevelsWeaponComponent_OnRep_ChargeLevel, PrevChargeLevel) == 0x000000, "Member 'ChargeLevelsWeaponComponent_OnRep_ChargeLevel::PrevChargeLevel' has a wrong offset!");

// Function DeceiveInc.ChargeLevelsWeaponComponent.Server_AOEDamage
// 0x0058 (0x0058 - 0x0000)
struct ChargeLevelsWeaponComponent_Server_AOEDamage final
{
public:
	struct FWeaponImpactData                      WeaponImpactData;                                  // 0x0000(0x0050)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         ChargeLevelIn;                                     // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChargeLevelsWeaponComponent_Server_AOEDamage) == 0x000008, "Wrong alignment on ChargeLevelsWeaponComponent_Server_AOEDamage");
static_assert(sizeof(ChargeLevelsWeaponComponent_Server_AOEDamage) == 0x000058, "Wrong size on ChargeLevelsWeaponComponent_Server_AOEDamage");
static_assert(offsetof(ChargeLevelsWeaponComponent_Server_AOEDamage, WeaponImpactData) == 0x000000, "Member 'ChargeLevelsWeaponComponent_Server_AOEDamage::WeaponImpactData' has a wrong offset!");
static_assert(offsetof(ChargeLevelsWeaponComponent_Server_AOEDamage, ChargeLevelIn) == 0x000050, "Member 'ChargeLevelsWeaponComponent_Server_AOEDamage::ChargeLevelIn' has a wrong offset!");

// Function DeceiveInc.ChargeLevelsWeaponComponent.GetChargeLevelData
// 0x0010 (0x0010 - 0x0000)
struct ChargeLevelsWeaponComponent_GetChargeLevelData final
{
public:
	int32                                         ChargeLevelDataIn;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FChargeLevelWeaponData                 ReturnValue;                                       // 0x0004(0x000C)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChargeLevelsWeaponComponent_GetChargeLevelData) == 0x000004, "Wrong alignment on ChargeLevelsWeaponComponent_GetChargeLevelData");
static_assert(sizeof(ChargeLevelsWeaponComponent_GetChargeLevelData) == 0x000010, "Wrong size on ChargeLevelsWeaponComponent_GetChargeLevelData");
static_assert(offsetof(ChargeLevelsWeaponComponent_GetChargeLevelData, ChargeLevelDataIn) == 0x000000, "Member 'ChargeLevelsWeaponComponent_GetChargeLevelData::ChargeLevelDataIn' has a wrong offset!");
static_assert(offsetof(ChargeLevelsWeaponComponent_GetChargeLevelData, ReturnValue) == 0x000004, "Member 'ChargeLevelsWeaponComponent_GetChargeLevelData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ChargeLevelsWeaponComponent.GetCurrentChargeLevelData
// 0x000C (0x000C - 0x0000)
struct ChargeLevelsWeaponComponent_GetCurrentChargeLevelData final
{
public:
	struct FChargeLevelWeaponData                 ReturnValue;                                       // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChargeLevelsWeaponComponent_GetCurrentChargeLevelData) == 0x000004, "Wrong alignment on ChargeLevelsWeaponComponent_GetCurrentChargeLevelData");
static_assert(sizeof(ChargeLevelsWeaponComponent_GetCurrentChargeLevelData) == 0x00000C, "Wrong size on ChargeLevelsWeaponComponent_GetCurrentChargeLevelData");
static_assert(offsetof(ChargeLevelsWeaponComponent_GetCurrentChargeLevelData, ReturnValue) == 0x000000, "Member 'ChargeLevelsWeaponComponent_GetCurrentChargeLevelData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ChargeLevelsWeaponComponent.GetProjectileChargeLevelData
// 0x0018 (0x0018 - 0x0000)
struct ChargeLevelsWeaponComponent_GetProjectileChargeLevelData final
{
public:
	class ASpawnerWeaponRound*                    RoundIn;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FChargeLevelWeaponData                 ReturnValue;                                       // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChargeLevelsWeaponComponent_GetProjectileChargeLevelData) == 0x000008, "Wrong alignment on ChargeLevelsWeaponComponent_GetProjectileChargeLevelData");
static_assert(sizeof(ChargeLevelsWeaponComponent_GetProjectileChargeLevelData) == 0x000018, "Wrong size on ChargeLevelsWeaponComponent_GetProjectileChargeLevelData");
static_assert(offsetof(ChargeLevelsWeaponComponent_GetProjectileChargeLevelData, RoundIn) == 0x000000, "Member 'ChargeLevelsWeaponComponent_GetProjectileChargeLevelData::RoundIn' has a wrong offset!");
static_assert(offsetof(ChargeLevelsWeaponComponent_GetProjectileChargeLevelData, ReturnValue) == 0x000008, "Member 'ChargeLevelsWeaponComponent_GetProjectileChargeLevelData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.GetBurstInfoForWeaponClass
// 0x0018 (0x0018 - 0x0000)
struct ProjectileWeapon_GetBurstInfoForWeaponClass final
{
public:
	class UClass*                                 WeaponClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BurstPerShot;                                      // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BurstShotDelay;                                    // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ProjectileWeapon_GetBurstInfoForWeaponClass) == 0x000008, "Wrong alignment on ProjectileWeapon_GetBurstInfoForWeaponClass");
static_assert(sizeof(ProjectileWeapon_GetBurstInfoForWeaponClass) == 0x000018, "Wrong size on ProjectileWeapon_GetBurstInfoForWeaponClass");
static_assert(offsetof(ProjectileWeapon_GetBurstInfoForWeaponClass, WeaponClass) == 0x000000, "Member 'ProjectileWeapon_GetBurstInfoForWeaponClass::WeaponClass' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_GetBurstInfoForWeaponClass, BurstPerShot) == 0x000008, "Member 'ProjectileWeapon_GetBurstInfoForWeaponClass::BurstPerShot' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_GetBurstInfoForWeaponClass, BurstShotDelay) == 0x00000C, "Member 'ProjectileWeapon_GetBurstInfoForWeaponClass::BurstShotDelay' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_GetBurstInfoForWeaponClass, ReturnValue) == 0x000010, "Member 'ProjectileWeapon_GetBurstInfoForWeaponClass::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.GetWeaponBalancingDataForClass
// 0x0068 (0x0068 - 0x0000)
struct ProjectileWeapon_GetWeaponBalancingDataForClass final
{
public:
	class UClass*                                 WeaponClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FProjectileWeaponBalancingData         Result;                                            // 0x0008(0x0058)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0060(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ProjectileWeapon_GetWeaponBalancingDataForClass) == 0x000008, "Wrong alignment on ProjectileWeapon_GetWeaponBalancingDataForClass");
static_assert(sizeof(ProjectileWeapon_GetWeaponBalancingDataForClass) == 0x000068, "Wrong size on ProjectileWeapon_GetWeaponBalancingDataForClass");
static_assert(offsetof(ProjectileWeapon_GetWeaponBalancingDataForClass, WeaponClass) == 0x000000, "Member 'ProjectileWeapon_GetWeaponBalancingDataForClass::WeaponClass' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_GetWeaponBalancingDataForClass, Result) == 0x000008, "Member 'ProjectileWeapon_GetWeaponBalancingDataForClass::Result' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_GetWeaponBalancingDataForClass, ReturnValue) == 0x000060, "Member 'ProjectileWeapon_GetWeaponBalancingDataForClass::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.AddOrReplaceDamageBehavior
// 0x00E0 (0x00E0 - 0x0000)
struct ProjectileWeapon_AddOrReplaceDamageBehavior final
{
public:
	class FName                                   BehaviorName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDamageBehavior                        ReturnValue;                                       // 0x0008(0x00D8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_AddOrReplaceDamageBehavior) == 0x000008, "Wrong alignment on ProjectileWeapon_AddOrReplaceDamageBehavior");
static_assert(sizeof(ProjectileWeapon_AddOrReplaceDamageBehavior) == 0x0000E0, "Wrong size on ProjectileWeapon_AddOrReplaceDamageBehavior");
static_assert(offsetof(ProjectileWeapon_AddOrReplaceDamageBehavior, BehaviorName) == 0x000000, "Member 'ProjectileWeapon_AddOrReplaceDamageBehavior::BehaviorName' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_AddOrReplaceDamageBehavior, ReturnValue) == 0x000008, "Member 'ProjectileWeapon_AddOrReplaceDamageBehavior::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.BP_OnBurstFirstShot
// 0x0018 (0x0018 - 0x0000)
struct ProjectileWeapon_BP_OnBurstFirstShot final
{
public:
	struct FVector                                ShotEndPoint;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AProjectileWeapon*                      Weapon;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_BP_OnBurstFirstShot) == 0x000008, "Wrong alignment on ProjectileWeapon_BP_OnBurstFirstShot");
static_assert(sizeof(ProjectileWeapon_BP_OnBurstFirstShot) == 0x000018, "Wrong size on ProjectileWeapon_BP_OnBurstFirstShot");
static_assert(offsetof(ProjectileWeapon_BP_OnBurstFirstShot, ShotEndPoint) == 0x000000, "Member 'ProjectileWeapon_BP_OnBurstFirstShot::ShotEndPoint' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_BP_OnBurstFirstShot, Weapon) == 0x000010, "Member 'ProjectileWeapon_BP_OnBurstFirstShot::Weapon' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.BP_OnHitConfirmed
// 0x0040 (0x0040 - 0x0000)
struct ProjectileWeapon_BP_OnHitConfirmed final
{
public:
	struct FHitConfirmData                        HitConfirmedData;                                  // 0x0000(0x0040)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_BP_OnHitConfirmed) == 0x000008, "Wrong alignment on ProjectileWeapon_BP_OnHitConfirmed");
static_assert(sizeof(ProjectileWeapon_BP_OnHitConfirmed) == 0x000040, "Wrong size on ProjectileWeapon_BP_OnHitConfirmed");
static_assert(offsetof(ProjectileWeapon_BP_OnHitConfirmed, HitConfirmedData) == 0x000000, "Member 'ProjectileWeapon_BP_OnHitConfirmed::HitConfirmedData' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.BP_OnProjectileImpact
// 0x0050 (0x0050 - 0x0000)
struct ProjectileWeapon_BP_OnProjectileImpact final
{
public:
	struct FWeaponImpactData                      WeaponImpactData;                                  // 0x0000(0x0050)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_BP_OnProjectileImpact) == 0x000008, "Wrong alignment on ProjectileWeapon_BP_OnProjectileImpact");
static_assert(sizeof(ProjectileWeapon_BP_OnProjectileImpact) == 0x000050, "Wrong size on ProjectileWeapon_BP_OnProjectileImpact");
static_assert(offsetof(ProjectileWeapon_BP_OnProjectileImpact, WeaponImpactData) == 0x000000, "Member 'ProjectileWeapon_BP_OnProjectileImpact::WeaponImpactData' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.BP_OnShotFired
// 0x0018 (0x0018 - 0x0000)
struct ProjectileWeapon_BP_OnShotFired final
{
public:
	struct FVector                                ShotEndPoint;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AProjectileWeapon*                      Weapon;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_BP_OnShotFired) == 0x000008, "Wrong alignment on ProjectileWeapon_BP_OnShotFired");
static_assert(sizeof(ProjectileWeapon_BP_OnShotFired) == 0x000018, "Wrong size on ProjectileWeapon_BP_OnShotFired");
static_assert(offsetof(ProjectileWeapon_BP_OnShotFired, ShotEndPoint) == 0x000000, "Member 'ProjectileWeapon_BP_OnShotFired::ShotEndPoint' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_BP_OnShotFired, Weapon) == 0x000010, "Member 'ProjectileWeapon_BP_OnShotFired::Weapon' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.GetDelayBetweenShots
// 0x0004 (0x0004 - 0x0000)
struct ProjectileWeapon_GetDelayBetweenShots final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_GetDelayBetweenShots) == 0x000004, "Wrong alignment on ProjectileWeapon_GetDelayBetweenShots");
static_assert(sizeof(ProjectileWeapon_GetDelayBetweenShots) == 0x000004, "Wrong size on ProjectileWeapon_GetDelayBetweenShots");
static_assert(offsetof(ProjectileWeapon_GetDelayBetweenShots, ReturnValue) == 0x000000, "Member 'ProjectileWeapon_GetDelayBetweenShots::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.HandleBooleanPlayerSettingChange
// 0x0002 (0x0002 - 0x0000)
struct ProjectileWeapon_HandleBooleanPlayerSettingChange final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewValue;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_HandleBooleanPlayerSettingChange) == 0x000001, "Wrong alignment on ProjectileWeapon_HandleBooleanPlayerSettingChange");
static_assert(sizeof(ProjectileWeapon_HandleBooleanPlayerSettingChange) == 0x000002, "Wrong size on ProjectileWeapon_HandleBooleanPlayerSettingChange");
static_assert(offsetof(ProjectileWeapon_HandleBooleanPlayerSettingChange, SettingType) == 0x000000, "Member 'ProjectileWeapon_HandleBooleanPlayerSettingChange::SettingType' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_HandleBooleanPlayerSettingChange, NewValue) == 0x000001, "Member 'ProjectileWeapon_HandleBooleanPlayerSettingChange::NewValue' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.HideADSMesh
// 0x0001 (0x0001 - 0x0000)
struct ProjectileWeapon_HideADSMesh final
{
public:
	bool                                          bHideIn;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_HideADSMesh) == 0x000001, "Wrong alignment on ProjectileWeapon_HideADSMesh");
static_assert(sizeof(ProjectileWeapon_HideADSMesh) == 0x000001, "Wrong size on ProjectileWeapon_HideADSMesh");
static_assert(offsetof(ProjectileWeapon_HideADSMesh, bHideIn) == 0x000000, "Member 'ProjectileWeapon_HideADSMesh::bHideIn' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.Multicast_HitConfirmed
// 0x0040 (0x0040 - 0x0000)
struct ProjectileWeapon_Multicast_HitConfirmed final
{
public:
	struct FHitConfirmData                        HitConfirmedData;                                  // 0x0000(0x0040)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_Multicast_HitConfirmed) == 0x000008, "Wrong alignment on ProjectileWeapon_Multicast_HitConfirmed");
static_assert(sizeof(ProjectileWeapon_Multicast_HitConfirmed) == 0x000040, "Wrong size on ProjectileWeapon_Multicast_HitConfirmed");
static_assert(offsetof(ProjectileWeapon_Multicast_HitConfirmed, HitConfirmedData) == 0x000000, "Member 'ProjectileWeapon_Multicast_HitConfirmed::HitConfirmedData' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.MulticastFireMissingShot
// 0x000C (0x000C - 0x0000)
struct ProjectileWeapon_MulticastFireMissingShot final
{
public:
	struct FVector_NetQuantize                    DestinationPos;                                    // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_MulticastFireMissingShot) == 0x000004, "Wrong alignment on ProjectileWeapon_MulticastFireMissingShot");
static_assert(sizeof(ProjectileWeapon_MulticastFireMissingShot) == 0x00000C, "Wrong size on ProjectileWeapon_MulticastFireMissingShot");
static_assert(offsetof(ProjectileWeapon_MulticastFireMissingShot, DestinationPos) == 0x000000, "Member 'ProjectileWeapon_MulticastFireMissingShot::DestinationPos' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.MulticastFireShot
// 0x000C (0x000C - 0x0000)
struct ProjectileWeapon_MulticastFireShot final
{
public:
	struct FVector_NetQuantize                    DestinationPos;                                    // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_MulticastFireShot) == 0x000004, "Wrong alignment on ProjectileWeapon_MulticastFireShot");
static_assert(sizeof(ProjectileWeapon_MulticastFireShot) == 0x00000C, "Wrong size on ProjectileWeapon_MulticastFireShot");
static_assert(offsetof(ProjectileWeapon_MulticastFireShot, DestinationPos) == 0x000000, "Member 'ProjectileWeapon_MulticastFireShot::DestinationPos' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.MulticastReleaseTrigger
// 0x0018 (0x0018 - 0x0000)
struct ProjectileWeapon_MulticastReleaseTrigger final
{
public:
	struct FVector_NetQuantize                    OriginPos;                                         // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    DestinationPos;                                    // 0x000C(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_MulticastReleaseTrigger) == 0x000004, "Wrong alignment on ProjectileWeapon_MulticastReleaseTrigger");
static_assert(sizeof(ProjectileWeapon_MulticastReleaseTrigger) == 0x000018, "Wrong size on ProjectileWeapon_MulticastReleaseTrigger");
static_assert(offsetof(ProjectileWeapon_MulticastReleaseTrigger, OriginPos) == 0x000000, "Member 'ProjectileWeapon_MulticastReleaseTrigger::OriginPos' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_MulticastReleaseTrigger, DestinationPos) == 0x00000C, "Member 'ProjectileWeapon_MulticastReleaseTrigger::DestinationPos' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.OnDisarmedChange
// 0x0001 (0x0001 - 0x0000)
struct ProjectileWeapon_OnDisarmedChange final
{
public:
	bool                                          bDisarmed;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_OnDisarmedChange) == 0x000001, "Wrong alignment on ProjectileWeapon_OnDisarmedChange");
static_assert(sizeof(ProjectileWeapon_OnDisarmedChange) == 0x000001, "Wrong size on ProjectileWeapon_OnDisarmedChange");
static_assert(offsetof(ProjectileWeapon_OnDisarmedChange, bDisarmed) == 0x000000, "Member 'ProjectileWeapon_OnDisarmedChange::bDisarmed' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.OnRep_ADSPressed
// 0x0001 (0x0001 - 0x0000)
struct ProjectileWeapon_OnRep_ADSPressed final
{
public:
	bool                                          PrevADSPressed;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_OnRep_ADSPressed) == 0x000001, "Wrong alignment on ProjectileWeapon_OnRep_ADSPressed");
static_assert(sizeof(ProjectileWeapon_OnRep_ADSPressed) == 0x000001, "Wrong size on ProjectileWeapon_OnRep_ADSPressed");
static_assert(offsetof(ProjectileWeapon_OnRep_ADSPressed, PrevADSPressed) == 0x000000, "Member 'ProjectileWeapon_OnRep_ADSPressed::PrevADSPressed' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.OnResourceChange
// 0x0028 (0x0028 - 0x0000)
struct ProjectileWeapon_OnResourceChange final
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ResourceDisplayName;                               // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	int32                                         DeltaAmount;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ProjectileWeapon_OnResourceChange) == 0x000008, "Wrong alignment on ProjectileWeapon_OnResourceChange");
static_assert(sizeof(ProjectileWeapon_OnResourceChange) == 0x000028, "Wrong size on ProjectileWeapon_OnResourceChange");
static_assert(offsetof(ProjectileWeapon_OnResourceChange, ResourceType) == 0x000000, "Member 'ProjectileWeapon_OnResourceChange::ResourceType' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_OnResourceChange, ResourceDisplayName) == 0x000008, "Member 'ProjectileWeapon_OnResourceChange::ResourceDisplayName' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_OnResourceChange, DeltaAmount) == 0x000020, "Member 'ProjectileWeapon_OnResourceChange::DeltaAmount' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.OnResourceNewMaxAmount
// 0x0028 (0x0028 - 0x0000)
struct ProjectileWeapon_OnResourceNewMaxAmount final
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ResourceDisplayName;                               // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	int32                                         MaxAmount;                                         // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ProjectileWeapon_OnResourceNewMaxAmount) == 0x000008, "Wrong alignment on ProjectileWeapon_OnResourceNewMaxAmount");
static_assert(sizeof(ProjectileWeapon_OnResourceNewMaxAmount) == 0x000028, "Wrong size on ProjectileWeapon_OnResourceNewMaxAmount");
static_assert(offsetof(ProjectileWeapon_OnResourceNewMaxAmount, ResourceType) == 0x000000, "Member 'ProjectileWeapon_OnResourceNewMaxAmount::ResourceType' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_OnResourceNewMaxAmount, ResourceDisplayName) == 0x000008, "Member 'ProjectileWeapon_OnResourceNewMaxAmount::ResourceDisplayName' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_OnResourceNewMaxAmount, MaxAmount) == 0x000020, "Member 'ProjectileWeapon_OnResourceNewMaxAmount::MaxAmount' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.OnResrouceNewAmount
// 0x0028 (0x0028 - 0x0000)
struct ProjectileWeapon_OnResrouceNewAmount final
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ResourceDisplayName;                               // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ProjectileWeapon_OnResrouceNewAmount) == 0x000008, "Wrong alignment on ProjectileWeapon_OnResrouceNewAmount");
static_assert(sizeof(ProjectileWeapon_OnResrouceNewAmount) == 0x000028, "Wrong size on ProjectileWeapon_OnResrouceNewAmount");
static_assert(offsetof(ProjectileWeapon_OnResrouceNewAmount, ResourceType) == 0x000000, "Member 'ProjectileWeapon_OnResrouceNewAmount::ResourceType' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_OnResrouceNewAmount, ResourceDisplayName) == 0x000008, "Member 'ProjectileWeapon_OnResrouceNewAmount::ResourceDisplayName' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_OnResrouceNewAmount, Amount) == 0x000020, "Member 'ProjectileWeapon_OnResrouceNewAmount::Amount' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.OnSpyOwnerRevived
// 0x0008 (0x0008 - 0x0000)
struct ProjectileWeapon_OnSpyOwnerRevived final
{
public:
	class ASpy*                                   SpyIn;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_OnSpyOwnerRevived) == 0x000008, "Wrong alignment on ProjectileWeapon_OnSpyOwnerRevived");
static_assert(sizeof(ProjectileWeapon_OnSpyOwnerRevived) == 0x000008, "Wrong size on ProjectileWeapon_OnSpyOwnerRevived");
static_assert(offsetof(ProjectileWeapon_OnSpyOwnerRevived, SpyIn) == 0x000000, "Member 'ProjectileWeapon_OnSpyOwnerRevived::SpyIn' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.Server_ADSInputChange
// 0x0001 (0x0001 - 0x0000)
struct ProjectileWeapon_Server_ADSInputChange final
{
public:
	bool                                          bADSPressedIn;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_Server_ADSInputChange) == 0x000001, "Wrong alignment on ProjectileWeapon_Server_ADSInputChange");
static_assert(sizeof(ProjectileWeapon_Server_ADSInputChange) == 0x000001, "Wrong size on ProjectileWeapon_Server_ADSInputChange");
static_assert(offsetof(ProjectileWeapon_Server_ADSInputChange, bADSPressedIn) == 0x000000, "Member 'ProjectileWeapon_Server_ADSInputChange::bADSPressedIn' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.ServerFireShot
// 0x0018 (0x0018 - 0x0000)
struct ProjectileWeapon_ServerFireShot final
{
public:
	struct FVector_NetQuantize                    OriginPos;                                         // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    DestinationPos;                                    // 0x000C(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_ServerFireShot) == 0x000004, "Wrong alignment on ProjectileWeapon_ServerFireShot");
static_assert(sizeof(ProjectileWeapon_ServerFireShot) == 0x000018, "Wrong size on ProjectileWeapon_ServerFireShot");
static_assert(offsetof(ProjectileWeapon_ServerFireShot, OriginPos) == 0x000000, "Member 'ProjectileWeapon_ServerFireShot::OriginPos' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_ServerFireShot, DestinationPos) == 0x00000C, "Member 'ProjectileWeapon_ServerFireShot::DestinationPos' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.ServerInformOfDirectHit
// 0x00B8 (0x00B8 - 0x0000)
struct ProjectileWeapon_ServerInformOfDirectHit final
{
public:
	struct FVector_NetQuantize                    OriginPos;                                         // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x000C(0x0088)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0094(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitType                                      HitType;                                           // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDamageContextData                     DamageContext;                                     // 0x00A0(0x0010)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	class ASpawnerWeaponRound*                    HittingProjectile;                                 // 0x00B0(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_ServerInformOfDirectHit) == 0x000008, "Wrong alignment on ProjectileWeapon_ServerInformOfDirectHit");
static_assert(sizeof(ProjectileWeapon_ServerInformOfDirectHit) == 0x0000B8, "Wrong size on ProjectileWeapon_ServerInformOfDirectHit");
static_assert(offsetof(ProjectileWeapon_ServerInformOfDirectHit, OriginPos) == 0x000000, "Member 'ProjectileWeapon_ServerInformOfDirectHit::OriginPos' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_ServerInformOfDirectHit, Hit) == 0x00000C, "Member 'ProjectileWeapon_ServerInformOfDirectHit::Hit' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_ServerInformOfDirectHit, Damage) == 0x000094, "Member 'ProjectileWeapon_ServerInformOfDirectHit::Damage' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_ServerInformOfDirectHit, HitType) == 0x000098, "Member 'ProjectileWeapon_ServerInformOfDirectHit::HitType' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_ServerInformOfDirectHit, DamageContext) == 0x0000A0, "Member 'ProjectileWeapon_ServerInformOfDirectHit::DamageContext' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_ServerInformOfDirectHit, HittingProjectile) == 0x0000B0, "Member 'ProjectileWeapon_ServerInformOfDirectHit::HittingProjectile' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.ServerReleaseTrigger
// 0x0018 (0x0018 - 0x0000)
struct ProjectileWeapon_ServerReleaseTrigger final
{
public:
	struct FVector_NetQuantize                    OriginPos;                                         // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    DestinationPos;                                    // 0x000C(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_ServerReleaseTrigger) == 0x000004, "Wrong alignment on ProjectileWeapon_ServerReleaseTrigger");
static_assert(sizeof(ProjectileWeapon_ServerReleaseTrigger) == 0x000018, "Wrong size on ProjectileWeapon_ServerReleaseTrigger");
static_assert(offsetof(ProjectileWeapon_ServerReleaseTrigger, OriginPos) == 0x000000, "Member 'ProjectileWeapon_ServerReleaseTrigger::OriginPos' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_ServerReleaseTrigger, DestinationPos) == 0x00000C, "Member 'ProjectileWeapon_ServerReleaseTrigger::DestinationPos' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.SetDefaultDamageBehaviorName
// 0x0008 (0x0008 - 0x0000)
struct ProjectileWeapon_SetDefaultDamageBehaviorName final
{
public:
	class FName                                   BehaviorName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_SetDefaultDamageBehaviorName) == 0x000004, "Wrong alignment on ProjectileWeapon_SetDefaultDamageBehaviorName");
static_assert(sizeof(ProjectileWeapon_SetDefaultDamageBehaviorName) == 0x000008, "Wrong size on ProjectileWeapon_SetDefaultDamageBehaviorName");
static_assert(offsetof(ProjectileWeapon_SetDefaultDamageBehaviorName, BehaviorName) == 0x000000, "Member 'ProjectileWeapon_SetDefaultDamageBehaviorName::BehaviorName' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.SetWeaponBuffs
// 0x0008 (0x0008 - 0x0000)
struct ProjectileWeapon_SetWeaponBuffs final
{
public:
	float                                         ReloadBuff;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ROFBuff;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_SetWeaponBuffs) == 0x000004, "Wrong alignment on ProjectileWeapon_SetWeaponBuffs");
static_assert(sizeof(ProjectileWeapon_SetWeaponBuffs) == 0x000008, "Wrong size on ProjectileWeapon_SetWeaponBuffs");
static_assert(offsetof(ProjectileWeapon_SetWeaponBuffs, ReloadBuff) == 0x000000, "Member 'ProjectileWeapon_SetWeaponBuffs::ReloadBuff' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_SetWeaponBuffs, ROFBuff) == 0x000004, "Member 'ProjectileWeapon_SetWeaponBuffs::ROFBuff' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.UpdateRoF
// 0x0004 (0x0004 - 0x0000)
struct ProjectileWeapon_UpdateRoF final
{
public:
	float                                         NewRoF;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_UpdateRoF) == 0x000004, "Wrong alignment on ProjectileWeapon_UpdateRoF");
static_assert(sizeof(ProjectileWeapon_UpdateRoF) == 0x000004, "Wrong size on ProjectileWeapon_UpdateRoF");
static_assert(offsetof(ProjectileWeapon_UpdateRoF, NewRoF) == 0x000000, "Member 'ProjectileWeapon_UpdateRoF::NewRoF' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.GetAimedPosition
// 0x000C (0x000C - 0x0000)
struct ProjectileWeapon_GetAimedPosition final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_GetAimedPosition) == 0x000004, "Wrong alignment on ProjectileWeapon_GetAimedPosition");
static_assert(sizeof(ProjectileWeapon_GetAimedPosition) == 0x00000C, "Wrong size on ProjectileWeapon_GetAimedPosition");
static_assert(offsetof(ProjectileWeapon_GetAimedPosition, ReturnValue) == 0x000000, "Member 'ProjectileWeapon_GetAimedPosition::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.GetBulletsInCurrentMagazine
// 0x0004 (0x0004 - 0x0000)
struct ProjectileWeapon_GetBulletsInCurrentMagazine final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_GetBulletsInCurrentMagazine) == 0x000004, "Wrong alignment on ProjectileWeapon_GetBulletsInCurrentMagazine");
static_assert(sizeof(ProjectileWeapon_GetBulletsInCurrentMagazine) == 0x000004, "Wrong size on ProjectileWeapon_GetBulletsInCurrentMagazine");
static_assert(offsetof(ProjectileWeapon_GetBulletsInCurrentMagazine, ReturnValue) == 0x000000, "Member 'ProjectileWeapon_GetBulletsInCurrentMagazine::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.GetCooldownBeforeMelee
// 0x0004 (0x0004 - 0x0000)
struct ProjectileWeapon_GetCooldownBeforeMelee final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_GetCooldownBeforeMelee) == 0x000004, "Wrong alignment on ProjectileWeapon_GetCooldownBeforeMelee");
static_assert(sizeof(ProjectileWeapon_GetCooldownBeforeMelee) == 0x000004, "Wrong size on ProjectileWeapon_GetCooldownBeforeMelee");
static_assert(offsetof(ProjectileWeapon_GetCooldownBeforeMelee, ReturnValue) == 0x000000, "Member 'ProjectileWeapon_GetCooldownBeforeMelee::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.GetDefaultDamageBehaviorName
// 0x0008 (0x0008 - 0x0000)
struct ProjectileWeapon_GetDefaultDamageBehaviorName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_GetDefaultDamageBehaviorName) == 0x000004, "Wrong alignment on ProjectileWeapon_GetDefaultDamageBehaviorName");
static_assert(sizeof(ProjectileWeapon_GetDefaultDamageBehaviorName) == 0x000008, "Wrong size on ProjectileWeapon_GetDefaultDamageBehaviorName");
static_assert(offsetof(ProjectileWeapon_GetDefaultDamageBehaviorName, ReturnValue) == 0x000000, "Member 'ProjectileWeapon_GetDefaultDamageBehaviorName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.GetMuzzlePosition
// 0x000C (0x000C - 0x0000)
struct ProjectileWeapon_GetMuzzlePosition final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_GetMuzzlePosition) == 0x000004, "Wrong alignment on ProjectileWeapon_GetMuzzlePosition");
static_assert(sizeof(ProjectileWeapon_GetMuzzlePosition) == 0x00000C, "Wrong size on ProjectileWeapon_GetMuzzlePosition");
static_assert(offsetof(ProjectileWeapon_GetMuzzlePosition, ReturnValue) == 0x000000, "Member 'ProjectileWeapon_GetMuzzlePosition::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.GetResourcesAtMaximumAmmo
// 0x0004 (0x0004 - 0x0000)
struct ProjectileWeapon_GetResourcesAtMaximumAmmo final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_GetResourcesAtMaximumAmmo) == 0x000004, "Wrong alignment on ProjectileWeapon_GetResourcesAtMaximumAmmo");
static_assert(sizeof(ProjectileWeapon_GetResourcesAtMaximumAmmo) == 0x000004, "Wrong size on ProjectileWeapon_GetResourcesAtMaximumAmmo");
static_assert(offsetof(ProjectileWeapon_GetResourcesAtMaximumAmmo, ReturnValue) == 0x000000, "Member 'ProjectileWeapon_GetResourcesAtMaximumAmmo::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.GetResourcesPerDispenserAmmoPack
// 0x0004 (0x0004 - 0x0000)
struct ProjectileWeapon_GetResourcesPerDispenserAmmoPack final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_GetResourcesPerDispenserAmmoPack) == 0x000004, "Wrong alignment on ProjectileWeapon_GetResourcesPerDispenserAmmoPack");
static_assert(sizeof(ProjectileWeapon_GetResourcesPerDispenserAmmoPack) == 0x000004, "Wrong size on ProjectileWeapon_GetResourcesPerDispenserAmmoPack");
static_assert(offsetof(ProjectileWeapon_GetResourcesPerDispenserAmmoPack, ReturnValue) == 0x000000, "Member 'ProjectileWeapon_GetResourcesPerDispenserAmmoPack::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.GetResourcesPerFullAmmoPack
// 0x0004 (0x0004 - 0x0000)
struct ProjectileWeapon_GetResourcesPerFullAmmoPack final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_GetResourcesPerFullAmmoPack) == 0x000004, "Wrong alignment on ProjectileWeapon_GetResourcesPerFullAmmoPack");
static_assert(sizeof(ProjectileWeapon_GetResourcesPerFullAmmoPack) == 0x000004, "Wrong size on ProjectileWeapon_GetResourcesPerFullAmmoPack");
static_assert(offsetof(ProjectileWeapon_GetResourcesPerFullAmmoPack, ReturnValue) == 0x000000, "Member 'ProjectileWeapon_GetResourcesPerFullAmmoPack::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.GetWeaponBalancingData
// 0x0060 (0x0060 - 0x0000)
struct ProjectileWeapon_GetWeaponBalancingData final
{
public:
	struct FProjectileWeaponBalancingData         Result;                                            // 0x0000(0x0058)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0058(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ProjectileWeapon_GetWeaponBalancingData) == 0x000008, "Wrong alignment on ProjectileWeapon_GetWeaponBalancingData");
static_assert(sizeof(ProjectileWeapon_GetWeaponBalancingData) == 0x000060, "Wrong size on ProjectileWeapon_GetWeaponBalancingData");
static_assert(offsetof(ProjectileWeapon_GetWeaponBalancingData, Result) == 0x000000, "Member 'ProjectileWeapon_GetWeaponBalancingData::Result' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_GetWeaponBalancingData, ReturnValue) == 0x000058, "Member 'ProjectileWeapon_GetWeaponBalancingData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.HasDamageBehavior
// 0x000C (0x000C - 0x0000)
struct ProjectileWeapon_HasDamageBehavior final
{
public:
	class FName                                   BehaviorName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ProjectileWeapon_HasDamageBehavior) == 0x000004, "Wrong alignment on ProjectileWeapon_HasDamageBehavior");
static_assert(sizeof(ProjectileWeapon_HasDamageBehavior) == 0x00000C, "Wrong size on ProjectileWeapon_HasDamageBehavior");
static_assert(offsetof(ProjectileWeapon_HasDamageBehavior, BehaviorName) == 0x000000, "Member 'ProjectileWeapon_HasDamageBehavior::BehaviorName' has a wrong offset!");
static_assert(offsetof(ProjectileWeapon_HasDamageBehavior, ReturnValue) == 0x000008, "Member 'ProjectileWeapon_HasDamageBehavior::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.IsClipEmpty
// 0x0001 (0x0001 - 0x0000)
struct ProjectileWeapon_IsClipEmpty final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_IsClipEmpty) == 0x000001, "Wrong alignment on ProjectileWeapon_IsClipEmpty");
static_assert(sizeof(ProjectileWeapon_IsClipEmpty) == 0x000001, "Wrong size on ProjectileWeapon_IsClipEmpty");
static_assert(offsetof(ProjectileWeapon_IsClipEmpty, ReturnValue) == 0x000000, "Member 'ProjectileWeapon_IsClipEmpty::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ProjectileWeapon.IsInADS
// 0x0001 (0x0001 - 0x0000)
struct ProjectileWeapon_IsInADS final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileWeapon_IsInADS) == 0x000001, "Wrong alignment on ProjectileWeapon_IsInADS");
static_assert(sizeof(ProjectileWeapon_IsInADS) == 0x000001, "Wrong size on ProjectileWeapon_IsInADS");
static_assert(offsetof(ProjectileWeapon_IsInADS, ReturnValue) == 0x000000, "Member 'ProjectileWeapon_IsInADS::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PosingSpy.CreateAnimationProp
// 0x0068 (0x0068 - 0x0000)
struct PosingSpy_CreateAnimationProp final
{
public:
	struct FAnimationPropData                     PropIn;                                            // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PosingSpy_CreateAnimationProp) == 0x000008, "Wrong alignment on PosingSpy_CreateAnimationProp");
static_assert(sizeof(PosingSpy_CreateAnimationProp) == 0x000068, "Wrong size on PosingSpy_CreateAnimationProp");
static_assert(offsetof(PosingSpy_CreateAnimationProp, PropIn) == 0x000000, "Member 'PosingSpy_CreateAnimationProp::PropIn' has a wrong offset!");
static_assert(offsetof(PosingSpy_CreateAnimationProp, bLooping) == 0x000060, "Member 'PosingSpy_CreateAnimationProp::bLooping' has a wrong offset!");

// Function DeceiveInc.PosingSpy.CreateAnimationProps
// 0x0018 (0x0018 - 0x0000)
struct PosingSpy_CreateAnimationProps final
{
public:
	TArray<struct FAnimationPropData>             PropsIn;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PosingSpy_CreateAnimationProps) == 0x000008, "Wrong alignment on PosingSpy_CreateAnimationProps");
static_assert(sizeof(PosingSpy_CreateAnimationProps) == 0x000018, "Wrong size on PosingSpy_CreateAnimationProps");
static_assert(offsetof(PosingSpy_CreateAnimationProps, PropsIn) == 0x000000, "Member 'PosingSpy_CreateAnimationProps::PropsIn' has a wrong offset!");
static_assert(offsetof(PosingSpy_CreateAnimationProps, bLooping) == 0x000010, "Member 'PosingSpy_CreateAnimationProps::bLooping' has a wrong offset!");

// Function DeceiveInc.PosingSpy.DestroyAnimationProp
// 0x0008 (0x0008 - 0x0000)
struct PosingSpy_DestroyAnimationProp final
{
public:
	class FName                                   NameID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PosingSpy_DestroyAnimationProp) == 0x000004, "Wrong alignment on PosingSpy_DestroyAnimationProp");
static_assert(sizeof(PosingSpy_DestroyAnimationProp) == 0x000008, "Wrong size on PosingSpy_DestroyAnimationProp");
static_assert(offsetof(PosingSpy_DestroyAnimationProp, NameID) == 0x000000, "Member 'PosingSpy_DestroyAnimationProp::NameID' has a wrong offset!");

// Function DeceiveInc.PosingSpy.NotifyIntroPoseAnimationStart
// 0x0008 (0x0008 - 0x0000)
struct PosingSpy_NotifyIntroPoseAnimationStart final
{
public:
	class UAgentIntroPoseDataAsset*               IntroPose;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PosingSpy_NotifyIntroPoseAnimationStart) == 0x000008, "Wrong alignment on PosingSpy_NotifyIntroPoseAnimationStart");
static_assert(sizeof(PosingSpy_NotifyIntroPoseAnimationStart) == 0x000008, "Wrong size on PosingSpy_NotifyIntroPoseAnimationStart");
static_assert(offsetof(PosingSpy_NotifyIntroPoseAnimationStart, IntroPose) == 0x000000, "Member 'PosingSpy_NotifyIntroPoseAnimationStart::IntroPose' has a wrong offset!");

// Function DeceiveInc.PosingSpy.ShowWeapon
// 0x0001 (0x0001 - 0x0000)
struct PosingSpy_ShowWeapon final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PosingSpy_ShowWeapon) == 0x000001, "Wrong alignment on PosingSpy_ShowWeapon");
static_assert(sizeof(PosingSpy_ShowWeapon) == 0x000001, "Wrong size on PosingSpy_ShowWeapon");
static_assert(offsetof(PosingSpy_ShowWeapon, bShow) == 0x000000, "Member 'PosingSpy_ShowWeapon::bShow' has a wrong offset!");

// Function DeceiveInc.SpawnerWeapon.NetMulticast_SwitchRound
// 0x0010 (0x0010 - 0x0000)
struct SpawnerWeapon_NetMulticast_SwitchRound final
{
public:
	class UClass*                                 NewFireShotClass;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayResourcesType                        NewRoundResource;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SpawnerWeapon_NetMulticast_SwitchRound) == 0x000008, "Wrong alignment on SpawnerWeapon_NetMulticast_SwitchRound");
static_assert(sizeof(SpawnerWeapon_NetMulticast_SwitchRound) == 0x000010, "Wrong size on SpawnerWeapon_NetMulticast_SwitchRound");
static_assert(offsetof(SpawnerWeapon_NetMulticast_SwitchRound, NewFireShotClass) == 0x000000, "Member 'SpawnerWeapon_NetMulticast_SwitchRound::NewFireShotClass' has a wrong offset!");
static_assert(offsetof(SpawnerWeapon_NetMulticast_SwitchRound, NewRoundResource) == 0x000008, "Member 'SpawnerWeapon_NetMulticast_SwitchRound::NewRoundResource' has a wrong offset!");

// Function DeceiveInc.SpawnerWeapon.OnRetrySPACOTimerEnd
// 0x000C (0x000C - 0x0000)
struct SpawnerWeapon_OnRetrySPACOTimerEnd final
{
public:
	struct FVector                                Pos;                                               // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpawnerWeapon_OnRetrySPACOTimerEnd) == 0x000004, "Wrong alignment on SpawnerWeapon_OnRetrySPACOTimerEnd");
static_assert(sizeof(SpawnerWeapon_OnRetrySPACOTimerEnd) == 0x00000C, "Wrong size on SpawnerWeapon_OnRetrySPACOTimerEnd");
static_assert(offsetof(SpawnerWeapon_OnRetrySPACOTimerEnd, Pos) == 0x000000, "Member 'SpawnerWeapon_OnRetrySPACOTimerEnd::Pos' has a wrong offset!");

// Function DeceiveInc.SpawnerWeapon.Server_SpawnOnHitActor
// 0x00A0 (0x00A0 - 0x0000)
struct SpawnerWeapon_Server_SpawnOnHitActor final
{
public:
	class UClass*                                 ActorToSpawnClass;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0008(0x0088)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                HitDirection;                                      // 0x0090(0x000C)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SpawnerWeapon_Server_SpawnOnHitActor) == 0x000008, "Wrong alignment on SpawnerWeapon_Server_SpawnOnHitActor");
static_assert(sizeof(SpawnerWeapon_Server_SpawnOnHitActor) == 0x0000A0, "Wrong size on SpawnerWeapon_Server_SpawnOnHitActor");
static_assert(offsetof(SpawnerWeapon_Server_SpawnOnHitActor, ActorToSpawnClass) == 0x000000, "Member 'SpawnerWeapon_Server_SpawnOnHitActor::ActorToSpawnClass' has a wrong offset!");
static_assert(offsetof(SpawnerWeapon_Server_SpawnOnHitActor, HitResult) == 0x000008, "Member 'SpawnerWeapon_Server_SpawnOnHitActor::HitResult' has a wrong offset!");
static_assert(offsetof(SpawnerWeapon_Server_SpawnOnHitActor, HitDirection) == 0x000090, "Member 'SpawnerWeapon_Server_SpawnOnHitActor::HitDirection' has a wrong offset!");

// Function DeceiveInc.SpawnerWeapon.Server_SwitchRound
// 0x0010 (0x0010 - 0x0000)
struct SpawnerWeapon_Server_SwitchRound final
{
public:
	class UClass*                                 NewFireShotClass;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayResourcesType                        NewRoundResource;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SpawnerWeapon_Server_SwitchRound) == 0x000008, "Wrong alignment on SpawnerWeapon_Server_SwitchRound");
static_assert(sizeof(SpawnerWeapon_Server_SwitchRound) == 0x000010, "Wrong size on SpawnerWeapon_Server_SwitchRound");
static_assert(offsetof(SpawnerWeapon_Server_SwitchRound, NewFireShotClass) == 0x000000, "Member 'SpawnerWeapon_Server_SwitchRound::NewFireShotClass' has a wrong offset!");
static_assert(offsetof(SpawnerWeapon_Server_SwitchRound, NewRoundResource) == 0x000008, "Member 'SpawnerWeapon_Server_SwitchRound::NewRoundResource' has a wrong offset!");

// Function DeceiveInc.SpawnerWeapon.GetHeldProjectile
// 0x0008 (0x0008 - 0x0000)
struct SpawnerWeapon_GetHeldProjectile final
{
public:
	class ASpawnerWeaponRound*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpawnerWeapon_GetHeldProjectile) == 0x000008, "Wrong alignment on SpawnerWeapon_GetHeldProjectile");
static_assert(sizeof(SpawnerWeapon_GetHeldProjectile) == 0x000008, "Wrong size on SpawnerWeapon_GetHeldProjectile");
static_assert(offsetof(SpawnerWeapon_GetHeldProjectile, ReturnValue) == 0x000000, "Member 'SpawnerWeapon_GetHeldProjectile::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SpawnerWeapon.HasHeldProjectile
// 0x0001 (0x0001 - 0x0000)
struct SpawnerWeapon_HasHeldProjectile final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpawnerWeapon_HasHeldProjectile) == 0x000001, "Wrong alignment on SpawnerWeapon_HasHeldProjectile");
static_assert(sizeof(SpawnerWeapon_HasHeldProjectile) == 0x000001, "Wrong size on SpawnerWeapon_HasHeldProjectile");
static_assert(offsetof(SpawnerWeapon_HasHeldProjectile, ReturnValue) == 0x000000, "Member 'SpawnerWeapon_HasHeldProjectile::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ChargeSpawnerWeapon.GetChargedSpawnerWeaponBalancingDataForClass
// 0x0070 (0x0070 - 0x0000)
struct ChargeSpawnerWeapon_GetChargedSpawnerWeaponBalancingDataForClass final
{
public:
	class UClass*                                 WeaponClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSpawnerWeaponBalancingData            Result;                                            // 0x0008(0x0060)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0068(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChargeSpawnerWeapon_GetChargedSpawnerWeaponBalancingDataForClass) == 0x000008, "Wrong alignment on ChargeSpawnerWeapon_GetChargedSpawnerWeaponBalancingDataForClass");
static_assert(sizeof(ChargeSpawnerWeapon_GetChargedSpawnerWeaponBalancingDataForClass) == 0x000070, "Wrong size on ChargeSpawnerWeapon_GetChargedSpawnerWeaponBalancingDataForClass");
static_assert(offsetof(ChargeSpawnerWeapon_GetChargedSpawnerWeaponBalancingDataForClass, WeaponClass) == 0x000000, "Member 'ChargeSpawnerWeapon_GetChargedSpawnerWeaponBalancingDataForClass::WeaponClass' has a wrong offset!");
static_assert(offsetof(ChargeSpawnerWeapon_GetChargedSpawnerWeaponBalancingDataForClass, Result) == 0x000008, "Member 'ChargeSpawnerWeapon_GetChargedSpawnerWeaponBalancingDataForClass::Result' has a wrong offset!");
static_assert(offsetof(ChargeSpawnerWeapon_GetChargedSpawnerWeaponBalancingDataForClass, ReturnValue) == 0x000068, "Member 'ChargeSpawnerWeapon_GetChargedSpawnerWeaponBalancingDataForClass::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ChargeSpawnerWeapon.GetChargeRatio
// 0x0004 (0x0004 - 0x0000)
struct ChargeSpawnerWeapon_GetChargeRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChargeSpawnerWeapon_GetChargeRatio) == 0x000004, "Wrong alignment on ChargeSpawnerWeapon_GetChargeRatio");
static_assert(sizeof(ChargeSpawnerWeapon_GetChargeRatio) == 0x000004, "Wrong size on ChargeSpawnerWeapon_GetChargeRatio");
static_assert(offsetof(ChargeSpawnerWeapon_GetChargeRatio, ReturnValue) == 0x000000, "Member 'ChargeSpawnerWeapon_GetChargeRatio::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ChargeSpawnerWeapon.IsFullyCharged
// 0x0001 (0x0001 - 0x0000)
struct ChargeSpawnerWeapon_IsFullyCharged final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChargeSpawnerWeapon_IsFullyCharged) == 0x000001, "Wrong alignment on ChargeSpawnerWeapon_IsFullyCharged");
static_assert(sizeof(ChargeSpawnerWeapon_IsFullyCharged) == 0x000001, "Wrong size on ChargeSpawnerWeapon_IsFullyCharged");
static_assert(offsetof(ChargeSpawnerWeapon_IsFullyCharged, ReturnValue) == 0x000000, "Member 'ChargeSpawnerWeapon_IsFullyCharged::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ChargeSpawnerWeapon.OnMainWeaponADSChanged
// 0x0001 (0x0001 - 0x0000)
struct ChargeSpawnerWeapon_OnMainWeaponADSChanged final
{
public:
	bool                                          bInADS;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChargeSpawnerWeapon_OnMainWeaponADSChanged) == 0x000001, "Wrong alignment on ChargeSpawnerWeapon_OnMainWeaponADSChanged");
static_assert(sizeof(ChargeSpawnerWeapon_OnMainWeaponADSChanged) == 0x000001, "Wrong size on ChargeSpawnerWeapon_OnMainWeaponADSChanged");
static_assert(offsetof(ChargeSpawnerWeapon_OnMainWeaponADSChanged, bInADS) == 0x000000, "Member 'ChargeSpawnerWeapon_OnMainWeaponADSChanged::bInADS' has a wrong offset!");

// Function DeceiveInc.ChargeSpawnerWeapon.OnRep_IsCharging
// 0x0002 (0x0002 - 0x0000)
struct ChargeSpawnerWeapon_OnRep_IsCharging final
{
public:
	struct FChargeStateInfo                       PrevInfo;                                          // 0x0000(0x0002)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChargeSpawnerWeapon_OnRep_IsCharging) == 0x000001, "Wrong alignment on ChargeSpawnerWeapon_OnRep_IsCharging");
static_assert(sizeof(ChargeSpawnerWeapon_OnRep_IsCharging) == 0x000002, "Wrong size on ChargeSpawnerWeapon_OnRep_IsCharging");
static_assert(offsetof(ChargeSpawnerWeapon_OnRep_IsCharging, PrevInfo) == 0x000000, "Member 'ChargeSpawnerWeapon_OnRep_IsCharging::PrevInfo' has a wrong offset!");

// Function DeceiveInc.ChargeSpawnerWeapon.OnRep_IsFullyCharged
// 0x0001 (0x0001 - 0x0000)
struct ChargeSpawnerWeapon_OnRep_IsFullyCharged final
{
public:
	bool                                          bPrevIsCharging;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChargeSpawnerWeapon_OnRep_IsFullyCharged) == 0x000001, "Wrong alignment on ChargeSpawnerWeapon_OnRep_IsFullyCharged");
static_assert(sizeof(ChargeSpawnerWeapon_OnRep_IsFullyCharged) == 0x000001, "Wrong size on ChargeSpawnerWeapon_OnRep_IsFullyCharged");
static_assert(offsetof(ChargeSpawnerWeapon_OnRep_IsFullyCharged, bPrevIsCharging) == 0x000000, "Member 'ChargeSpawnerWeapon_OnRep_IsFullyCharged::bPrevIsCharging' has a wrong offset!");

// Function DeceiveInc.ChargeSpawnerWeapon.Server_StopCharging
// 0x0001 (0x0001 - 0x0000)
struct ChargeSpawnerWeapon_Server_StopCharging final
{
public:
	bool                                          bIsCancel;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChargeSpawnerWeapon_Server_StopCharging) == 0x000001, "Wrong alignment on ChargeSpawnerWeapon_Server_StopCharging");
static_assert(sizeof(ChargeSpawnerWeapon_Server_StopCharging) == 0x000001, "Wrong size on ChargeSpawnerWeapon_Server_StopCharging");
static_assert(offsetof(ChargeSpawnerWeapon_Server_StopCharging, bIsCancel) == 0x000000, "Member 'ChargeSpawnerWeapon_Server_StopCharging::bIsCancel' has a wrong offset!");

// Function DeceiveInc.ChargeSpawnerWeapon.GetChargedSpawnerWeaponBalancingData
// 0x0068 (0x0068 - 0x0000)
struct ChargeSpawnerWeapon_GetChargedSpawnerWeaponBalancingData final
{
public:
	struct FSpawnerWeaponBalancingData            Result;                                            // 0x0000(0x0060)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0060(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChargeSpawnerWeapon_GetChargedSpawnerWeaponBalancingData) == 0x000008, "Wrong alignment on ChargeSpawnerWeapon_GetChargedSpawnerWeaponBalancingData");
static_assert(sizeof(ChargeSpawnerWeapon_GetChargedSpawnerWeaponBalancingData) == 0x000068, "Wrong size on ChargeSpawnerWeapon_GetChargedSpawnerWeaponBalancingData");
static_assert(offsetof(ChargeSpawnerWeapon_GetChargedSpawnerWeaponBalancingData, Result) == 0x000000, "Member 'ChargeSpawnerWeapon_GetChargedSpawnerWeaponBalancingData::Result' has a wrong offset!");
static_assert(offsetof(ChargeSpawnerWeapon_GetChargedSpawnerWeaponBalancingData, ReturnValue) == 0x000060, "Member 'ChargeSpawnerWeapon_GetChargedSpawnerWeaponBalancingData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ChargeSpawnerWeapon.IsCharging
// 0x0001 (0x0001 - 0x0000)
struct ChargeSpawnerWeapon_IsCharging final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChargeSpawnerWeapon_IsCharging) == 0x000001, "Wrong alignment on ChargeSpawnerWeapon_IsCharging");
static_assert(sizeof(ChargeSpawnerWeapon_IsCharging) == 0x000001, "Wrong size on ChargeSpawnerWeapon_IsCharging");
static_assert(offsetof(ChargeSpawnerWeapon_IsCharging, ReturnValue) == 0x000000, "Member 'ChargeSpawnerWeapon_IsCharging::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ChargeSpawnerWeapon.TimeLeftToFullyCharged
// 0x0004 (0x0004 - 0x0000)
struct ChargeSpawnerWeapon_TimeLeftToFullyCharged final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChargeSpawnerWeapon_TimeLeftToFullyCharged) == 0x000004, "Wrong alignment on ChargeSpawnerWeapon_TimeLeftToFullyCharged");
static_assert(sizeof(ChargeSpawnerWeapon_TimeLeftToFullyCharged) == 0x000004, "Wrong size on ChargeSpawnerWeapon_TimeLeftToFullyCharged");
static_assert(offsetof(ChargeSpawnerWeapon_TimeLeftToFullyCharged, ReturnValue) == 0x000000, "Member 'ChargeSpawnerWeapon_TimeLeftToFullyCharged::ReturnValue' has a wrong offset!");

// Function DeceiveInc.RewardBundleDataAsset.GetBundleForAssetData
// 0x0110 (0x0110 - 0x0000)
struct RewardBundleDataAsset_GetBundleForAssetData final
{
public:
	class UDIPrimaryDataAsset*                    DataAsset;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRewardBundleInfo                      ReturnValue;                                       // 0x0008(0x0108)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(RewardBundleDataAsset_GetBundleForAssetData) == 0x000008, "Wrong alignment on RewardBundleDataAsset_GetBundleForAssetData");
static_assert(sizeof(RewardBundleDataAsset_GetBundleForAssetData) == 0x000110, "Wrong size on RewardBundleDataAsset_GetBundleForAssetData");
static_assert(offsetof(RewardBundleDataAsset_GetBundleForAssetData, DataAsset) == 0x000000, "Member 'RewardBundleDataAsset_GetBundleForAssetData::DataAsset' has a wrong offset!");
static_assert(offsetof(RewardBundleDataAsset_GetBundleForAssetData, ReturnValue) == 0x000008, "Member 'RewardBundleDataAsset_GetBundleForAssetData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.RemoteTurretAIComponent.OnRep_NewTurretAState
// 0x0001 (0x0001 - 0x0000)
struct RemoteTurretAIComponent_OnRep_NewTurretAState final
{
public:
	ERemoteTurretAIState                          OldState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RemoteTurretAIComponent_OnRep_NewTurretAState) == 0x000001, "Wrong alignment on RemoteTurretAIComponent_OnRep_NewTurretAState");
static_assert(sizeof(RemoteTurretAIComponent_OnRep_NewTurretAState) == 0x000001, "Wrong size on RemoteTurretAIComponent_OnRep_NewTurretAState");
static_assert(offsetof(RemoteTurretAIComponent_OnRep_NewTurretAState, OldState) == 0x000000, "Member 'RemoteTurretAIComponent_OnRep_NewTurretAState::OldState' has a wrong offset!");

// Function DeceiveInc.ChavezPassiveAbility.MulticastDamageTaken
// 0x0008 (0x0008 - 0x0000)
struct ChavezPassiveAbility_MulticastDamageTaken final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChavezPassiveAbility_MulticastDamageTaken) == 0x000008, "Wrong alignment on ChavezPassiveAbility_MulticastDamageTaken");
static_assert(sizeof(ChavezPassiveAbility_MulticastDamageTaken) == 0x000008, "Wrong size on ChavezPassiveAbility_MulticastDamageTaken");
static_assert(offsetof(ChavezPassiveAbility_MulticastDamageTaken, Spy) == 0x000000, "Member 'ChavezPassiveAbility_MulticastDamageTaken::Spy' has a wrong offset!");

// Function DeceiveInc.ChavezPassiveAbility.MulticastRegenCompleted
// 0x0008 (0x0008 - 0x0000)
struct ChavezPassiveAbility_MulticastRegenCompleted final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChavezPassiveAbility_MulticastRegenCompleted) == 0x000008, "Wrong alignment on ChavezPassiveAbility_MulticastRegenCompleted");
static_assert(sizeof(ChavezPassiveAbility_MulticastRegenCompleted) == 0x000008, "Wrong size on ChavezPassiveAbility_MulticastRegenCompleted");
static_assert(offsetof(ChavezPassiveAbility_MulticastRegenCompleted, Spy) == 0x000000, "Member 'ChavezPassiveAbility_MulticastRegenCompleted::Spy' has a wrong offset!");

// Function DeceiveInc.ChavezPassiveAbility.MulticastRegenStarted
// 0x0008 (0x0008 - 0x0000)
struct ChavezPassiveAbility_MulticastRegenStarted final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChavezPassiveAbility_MulticastRegenStarted) == 0x000008, "Wrong alignment on ChavezPassiveAbility_MulticastRegenStarted");
static_assert(sizeof(ChavezPassiveAbility_MulticastRegenStarted) == 0x000008, "Wrong size on ChavezPassiveAbility_MulticastRegenStarted");
static_assert(offsetof(ChavezPassiveAbility_MulticastRegenStarted, Spy) == 0x000000, "Member 'ChavezPassiveAbility_MulticastRegenStarted::Spy' has a wrong offset!");

// Function DeceiveInc.ChavezPassiveAbility.OnHealthChanged
// 0x0030 (0x0030 - 0x0000)
struct ChavezPassiveAbility_OnHealthChanged final
{
public:
	class UHealthComponent*                       OwningHealthComp;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthDelta;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDamageType*                      DamageType;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RawDamage;                                         // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChavezPassiveAbility_OnHealthChanged) == 0x000008, "Wrong alignment on ChavezPassiveAbility_OnHealthChanged");
static_assert(sizeof(ChavezPassiveAbility_OnHealthChanged) == 0x000030, "Wrong size on ChavezPassiveAbility_OnHealthChanged");
static_assert(offsetof(ChavezPassiveAbility_OnHealthChanged, OwningHealthComp) == 0x000000, "Member 'ChavezPassiveAbility_OnHealthChanged::OwningHealthComp' has a wrong offset!");
static_assert(offsetof(ChavezPassiveAbility_OnHealthChanged, Health) == 0x000008, "Member 'ChavezPassiveAbility_OnHealthChanged::Health' has a wrong offset!");
static_assert(offsetof(ChavezPassiveAbility_OnHealthChanged, HealthDelta) == 0x00000C, "Member 'ChavezPassiveAbility_OnHealthChanged::HealthDelta' has a wrong offset!");
static_assert(offsetof(ChavezPassiveAbility_OnHealthChanged, DamageType) == 0x000010, "Member 'ChavezPassiveAbility_OnHealthChanged::DamageType' has a wrong offset!");
static_assert(offsetof(ChavezPassiveAbility_OnHealthChanged, InstigatedBy) == 0x000018, "Member 'ChavezPassiveAbility_OnHealthChanged::InstigatedBy' has a wrong offset!");
static_assert(offsetof(ChavezPassiveAbility_OnHealthChanged, DamageCauser) == 0x000020, "Member 'ChavezPassiveAbility_OnHealthChanged::DamageCauser' has a wrong offset!");
static_assert(offsetof(ChavezPassiveAbility_OnHealthChanged, RawDamage) == 0x000028, "Member 'ChavezPassiveAbility_OnHealthChanged::RawDamage' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.GetLatencyForRegion
// 0x0018 (0x0018 - 0x0000)
struct PrivateLobbySubsystem_GetLatencyForRegion final
{
public:
	class FString                                 Region;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrivateLobbySubsystem_GetLatencyForRegion) == 0x000008, "Wrong alignment on PrivateLobbySubsystem_GetLatencyForRegion");
static_assert(sizeof(PrivateLobbySubsystem_GetLatencyForRegion) == 0x000018, "Wrong size on PrivateLobbySubsystem_GetLatencyForRegion");
static_assert(offsetof(PrivateLobbySubsystem_GetLatencyForRegion, Region) == 0x000000, "Member 'PrivateLobbySubsystem_GetLatencyForRegion::Region' has a wrong offset!");
static_assert(offsetof(PrivateLobbySubsystem_GetLatencyForRegion, ReturnValue) == 0x000010, "Member 'PrivateLobbySubsystem_GetLatencyForRegion::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.GetLatencyForRegionIndex
// 0x0008 (0x0008 - 0x0000)
struct PrivateLobbySubsystem_GetLatencyForRegionIndex final
{
public:
	int32                                         RegionIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_GetLatencyForRegionIndex) == 0x000004, "Wrong alignment on PrivateLobbySubsystem_GetLatencyForRegionIndex");
static_assert(sizeof(PrivateLobbySubsystem_GetLatencyForRegionIndex) == 0x000008, "Wrong size on PrivateLobbySubsystem_GetLatencyForRegionIndex");
static_assert(offsetof(PrivateLobbySubsystem_GetLatencyForRegionIndex, RegionIndex) == 0x000000, "Member 'PrivateLobbySubsystem_GetLatencyForRegionIndex::RegionIndex' has a wrong offset!");
static_assert(offsetof(PrivateLobbySubsystem_GetLatencyForRegionIndex, ReturnValue) == 0x000004, "Member 'PrivateLobbySubsystem_GetLatencyForRegionIndex::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.HandlePlayerSettingChange
// 0x0001 (0x0001 - 0x0000)
struct PrivateLobbySubsystem_HandlePlayerSettingChange final
{
public:
	EPlayerSettingsType                           SettingChanged;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_HandlePlayerSettingChange) == 0x000001, "Wrong alignment on PrivateLobbySubsystem_HandlePlayerSettingChange");
static_assert(sizeof(PrivateLobbySubsystem_HandlePlayerSettingChange) == 0x000001, "Wrong size on PrivateLobbySubsystem_HandlePlayerSettingChange");
static_assert(offsetof(PrivateLobbySubsystem_HandlePlayerSettingChange, SettingChanged) == 0x000000, "Member 'PrivateLobbySubsystem_HandlePlayerSettingChange::SettingChanged' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.SetAllObjectsToSpawnCount
// 0x0010 (0x0010 - 0x0000)
struct PrivateLobbySubsystem_SetAllObjectsToSpawnCount final
{
public:
	TArray<struct FObjectToSpawnCount>            ObjectsToSpawnCount;                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_SetAllObjectsToSpawnCount) == 0x000008, "Wrong alignment on PrivateLobbySubsystem_SetAllObjectsToSpawnCount");
static_assert(sizeof(PrivateLobbySubsystem_SetAllObjectsToSpawnCount) == 0x000010, "Wrong size on PrivateLobbySubsystem_SetAllObjectsToSpawnCount");
static_assert(offsetof(PrivateLobbySubsystem_SetAllObjectsToSpawnCount, ObjectsToSpawnCount) == 0x000000, "Member 'PrivateLobbySubsystem_SetAllObjectsToSpawnCount::ObjectsToSpawnCount' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.SetLobbyBotsAmount
// 0x0004 (0x0004 - 0x0000)
struct PrivateLobbySubsystem_SetLobbyBotsAmount final
{
public:
	int32                                         BotsAmount;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_SetLobbyBotsAmount) == 0x000004, "Wrong alignment on PrivateLobbySubsystem_SetLobbyBotsAmount");
static_assert(sizeof(PrivateLobbySubsystem_SetLobbyBotsAmount) == 0x000004, "Wrong size on PrivateLobbySubsystem_SetLobbyBotsAmount");
static_assert(offsetof(PrivateLobbySubsystem_SetLobbyBotsAmount, BotsAmount) == 0x000000, "Member 'PrivateLobbySubsystem_SetLobbyBotsAmount::BotsAmount' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.SetLobbyBotsDifficulty
// 0x0001 (0x0001 - 0x0000)
struct PrivateLobbySubsystem_SetLobbyBotsDifficulty final
{
public:
	EBotsDifficulty                               BotsDifficulty;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_SetLobbyBotsDifficulty) == 0x000001, "Wrong alignment on PrivateLobbySubsystem_SetLobbyBotsDifficulty");
static_assert(sizeof(PrivateLobbySubsystem_SetLobbyBotsDifficulty) == 0x000001, "Wrong size on PrivateLobbySubsystem_SetLobbyBotsDifficulty");
static_assert(offsetof(PrivateLobbySubsystem_SetLobbyBotsDifficulty, BotsDifficulty) == 0x000000, "Member 'PrivateLobbySubsystem_SetLobbyBotsDifficulty::BotsDifficulty' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.SetLobbyFillWithBots
// 0x0001 (0x0001 - 0x0000)
struct PrivateLobbySubsystem_SetLobbyFillWithBots final
{
public:
	bool                                          bFillWithBots;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_SetLobbyFillWithBots) == 0x000001, "Wrong alignment on PrivateLobbySubsystem_SetLobbyFillWithBots");
static_assert(sizeof(PrivateLobbySubsystem_SetLobbyFillWithBots) == 0x000001, "Wrong size on PrivateLobbySubsystem_SetLobbyFillWithBots");
static_assert(offsetof(PrivateLobbySubsystem_SetLobbyFillWithBots, bFillWithBots) == 0x000000, "Member 'PrivateLobbySubsystem_SetLobbyFillWithBots::bFillWithBots' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.SetLobbyGameMode
// 0x0001 (0x0001 - 0x0000)
struct PrivateLobbySubsystem_SetLobbyGameMode final
{
public:
	EDIGameMode                                   NewGameMode;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_SetLobbyGameMode) == 0x000001, "Wrong alignment on PrivateLobbySubsystem_SetLobbyGameMode");
static_assert(sizeof(PrivateLobbySubsystem_SetLobbyGameMode) == 0x000001, "Wrong size on PrivateLobbySubsystem_SetLobbyGameMode");
static_assert(offsetof(PrivateLobbySubsystem_SetLobbyGameMode, NewGameMode) == 0x000000, "Member 'PrivateLobbySubsystem_SetLobbyGameMode::NewGameMode' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.SetLobbyHeatSettings
// 0x0050 (0x0050 - 0x0000)
struct PrivateLobbySubsystem_SetLobbyHeatSettings final
{
public:
	struct FHeatSetupData                         HeatSettings;                                      // 0x0000(0x0050)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_SetLobbyHeatSettings) == 0x000008, "Wrong alignment on PrivateLobbySubsystem_SetLobbyHeatSettings");
static_assert(sizeof(PrivateLobbySubsystem_SetLobbyHeatSettings) == 0x000050, "Wrong size on PrivateLobbySubsystem_SetLobbyHeatSettings");
static_assert(offsetof(PrivateLobbySubsystem_SetLobbyHeatSettings, HeatSettings) == 0x000000, "Member 'PrivateLobbySubsystem_SetLobbyHeatSettings::HeatSettings' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.SetLobbyOperationMap
// 0x0008 (0x0008 - 0x0000)
struct PrivateLobbySubsystem_SetLobbyOperationMap final
{
public:
	class UMapData*                               NewOperationMapData;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_SetLobbyOperationMap) == 0x000008, "Wrong alignment on PrivateLobbySubsystem_SetLobbyOperationMap");
static_assert(sizeof(PrivateLobbySubsystem_SetLobbyOperationMap) == 0x000008, "Wrong size on PrivateLobbySubsystem_SetLobbyOperationMap");
static_assert(offsetof(PrivateLobbySubsystem_SetLobbyOperationMap, NewOperationMapData) == 0x000000, "Member 'PrivateLobbySubsystem_SetLobbyOperationMap::NewOperationMapData' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.SetLobbySandboxMode
// 0x0001 (0x0001 - 0x0000)
struct PrivateLobbySubsystem_SetLobbySandboxMode final
{
public:
	bool                                          bSandboxMode;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_SetLobbySandboxMode) == 0x000001, "Wrong alignment on PrivateLobbySubsystem_SetLobbySandboxMode");
static_assert(sizeof(PrivateLobbySubsystem_SetLobbySandboxMode) == 0x000001, "Wrong size on PrivateLobbySubsystem_SetLobbySandboxMode");
static_assert(offsetof(PrivateLobbySubsystem_SetLobbySandboxMode, bSandboxMode) == 0x000000, "Member 'PrivateLobbySubsystem_SetLobbySandboxMode::bSandboxMode' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.SetNPCPopulation
// 0x0010 (0x0010 - 0x0000)
struct PrivateLobbySubsystem_SetNPCPopulation final
{
public:
	TArray<int32>                                 NPCPopulation;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_SetNPCPopulation) == 0x000008, "Wrong alignment on PrivateLobbySubsystem_SetNPCPopulation");
static_assert(sizeof(PrivateLobbySubsystem_SetNPCPopulation) == 0x000010, "Wrong size on PrivateLobbySubsystem_SetNPCPopulation");
static_assert(offsetof(PrivateLobbySubsystem_SetNPCPopulation, NPCPopulation) == 0x000000, "Member 'PrivateLobbySubsystem_SetNPCPopulation::NPCPopulation' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.SetNPCPopulationByPool
// 0x0008 (0x0008 - 0x0000)
struct PrivateLobbySubsystem_SetNPCPopulationByPool final
{
public:
	int32                                         NPCPool;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NPCAmount;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_SetNPCPopulationByPool) == 0x000004, "Wrong alignment on PrivateLobbySubsystem_SetNPCPopulationByPool");
static_assert(sizeof(PrivateLobbySubsystem_SetNPCPopulationByPool) == 0x000008, "Wrong size on PrivateLobbySubsystem_SetNPCPopulationByPool");
static_assert(offsetof(PrivateLobbySubsystem_SetNPCPopulationByPool, NPCPool) == 0x000000, "Member 'PrivateLobbySubsystem_SetNPCPopulationByPool::NPCPool' has a wrong offset!");
static_assert(offsetof(PrivateLobbySubsystem_SetNPCPopulationByPool, NPCAmount) == 0x000004, "Member 'PrivateLobbySubsystem_SetNPCPopulationByPool::NPCAmount' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.SetObjectsToSpawnCount
// 0x0018 (0x0018 - 0x0000)
struct PrivateLobbySubsystem_SetObjectsToSpawnCount final
{
public:
	struct FObjectToSpawnCount                    ObjectsToSpawnCount;                               // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_SetObjectsToSpawnCount) == 0x000008, "Wrong alignment on PrivateLobbySubsystem_SetObjectsToSpawnCount");
static_assert(sizeof(PrivateLobbySubsystem_SetObjectsToSpawnCount) == 0x000018, "Wrong size on PrivateLobbySubsystem_SetObjectsToSpawnCount");
static_assert(offsetof(PrivateLobbySubsystem_SetObjectsToSpawnCount, ObjectsToSpawnCount) == 0x000000, "Member 'PrivateLobbySubsystem_SetObjectsToSpawnCount::ObjectsToSpawnCount' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.SetSelectedRegionIndex
// 0x0004 (0x0004 - 0x0000)
struct PrivateLobbySubsystem_SetSelectedRegionIndex final
{
public:
	int32                                         NewSelectedRegion;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_SetSelectedRegionIndex) == 0x000004, "Wrong alignment on PrivateLobbySubsystem_SetSelectedRegionIndex");
static_assert(sizeof(PrivateLobbySubsystem_SetSelectedRegionIndex) == 0x000004, "Wrong size on PrivateLobbySubsystem_SetSelectedRegionIndex");
static_assert(offsetof(PrivateLobbySubsystem_SetSelectedRegionIndex, NewSelectedRegion) == 0x000000, "Member 'PrivateLobbySubsystem_SetSelectedRegionIndex::NewSelectedRegion' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.TrySetTeamForLocaPlayer
// 0x0008 (0x0008 - 0x0000)
struct PrivateLobbySubsystem_TrySetTeamForLocaPlayer final
{
public:
	int32                                         TeamIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrivateLobbySubsystem_TrySetTeamForLocaPlayer) == 0x000004, "Wrong alignment on PrivateLobbySubsystem_TrySetTeamForLocaPlayer");
static_assert(sizeof(PrivateLobbySubsystem_TrySetTeamForLocaPlayer) == 0x000008, "Wrong size on PrivateLobbySubsystem_TrySetTeamForLocaPlayer");
static_assert(offsetof(PrivateLobbySubsystem_TrySetTeamForLocaPlayer, TeamIndex) == 0x000000, "Member 'PrivateLobbySubsystem_TrySetTeamForLocaPlayer::TeamIndex' has a wrong offset!");
static_assert(offsetof(PrivateLobbySubsystem_TrySetTeamForLocaPlayer, ReturnValue) == 0x000004, "Member 'PrivateLobbySubsystem_TrySetTeamForLocaPlayer::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.TrySetTeamForPlayer
// 0x0010 (0x0010 - 0x0000)
struct PrivateLobbySubsystem_TrySetTeamForPlayer final
{
public:
	class UDIOnlinePartyMemberInfo*               Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrivateLobbySubsystem_TrySetTeamForPlayer) == 0x000008, "Wrong alignment on PrivateLobbySubsystem_TrySetTeamForPlayer");
static_assert(sizeof(PrivateLobbySubsystem_TrySetTeamForPlayer) == 0x000010, "Wrong size on PrivateLobbySubsystem_TrySetTeamForPlayer");
static_assert(offsetof(PrivateLobbySubsystem_TrySetTeamForPlayer, Player) == 0x000000, "Member 'PrivateLobbySubsystem_TrySetTeamForPlayer::Player' has a wrong offset!");
static_assert(offsetof(PrivateLobbySubsystem_TrySetTeamForPlayer, TeamIndex) == 0x000008, "Member 'PrivateLobbySubsystem_TrySetTeamForPlayer::TeamIndex' has a wrong offset!");
static_assert(offsetof(PrivateLobbySubsystem_TrySetTeamForPlayer, ReturnValue) == 0x00000C, "Member 'PrivateLobbySubsystem_TrySetTeamForPlayer::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.CanLocalPlayerEditLobbyData
// 0x0001 (0x0001 - 0x0000)
struct PrivateLobbySubsystem_CanLocalPlayerEditLobbyData final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_CanLocalPlayerEditLobbyData) == 0x000001, "Wrong alignment on PrivateLobbySubsystem_CanLocalPlayerEditLobbyData");
static_assert(sizeof(PrivateLobbySubsystem_CanLocalPlayerEditLobbyData) == 0x000001, "Wrong size on PrivateLobbySubsystem_CanLocalPlayerEditLobbyData");
static_assert(offsetof(PrivateLobbySubsystem_CanLocalPlayerEditLobbyData, ReturnValue) == 0x000000, "Member 'PrivateLobbySubsystem_CanLocalPlayerEditLobbyData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.GetAssignedMembers
// 0x0010 (0x0010 - 0x0000)
struct PrivateLobbySubsystem_GetAssignedMembers final
{
public:
	TArray<class UDIOnlinePartyMemberInfo*>       ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_GetAssignedMembers) == 0x000008, "Wrong alignment on PrivateLobbySubsystem_GetAssignedMembers");
static_assert(sizeof(PrivateLobbySubsystem_GetAssignedMembers) == 0x000010, "Wrong size on PrivateLobbySubsystem_GetAssignedMembers");
static_assert(offsetof(PrivateLobbySubsystem_GetAssignedMembers, ReturnValue) == 0x000000, "Member 'PrivateLobbySubsystem_GetAssignedMembers::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.GetAvailableOperationMaps
// 0x0010 (0x0010 - 0x0000)
struct PrivateLobbySubsystem_GetAvailableOperationMaps final
{
public:
	TArray<class UMapData*>                       ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_GetAvailableOperationMaps) == 0x000008, "Wrong alignment on PrivateLobbySubsystem_GetAvailableOperationMaps");
static_assert(sizeof(PrivateLobbySubsystem_GetAvailableOperationMaps) == 0x000010, "Wrong size on PrivateLobbySubsystem_GetAvailableOperationMaps");
static_assert(offsetof(PrivateLobbySubsystem_GetAvailableOperationMaps, ReturnValue) == 0x000000, "Member 'PrivateLobbySubsystem_GetAvailableOperationMaps::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.GetAvailableRegions
// 0x0010 (0x0010 - 0x0000)
struct PrivateLobbySubsystem_GetAvailableRegions final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_GetAvailableRegions) == 0x000008, "Wrong alignment on PrivateLobbySubsystem_GetAvailableRegions");
static_assert(sizeof(PrivateLobbySubsystem_GetAvailableRegions) == 0x000010, "Wrong size on PrivateLobbySubsystem_GetAvailableRegions");
static_assert(offsetof(PrivateLobbySubsystem_GetAvailableRegions, ReturnValue) == 0x000000, "Member 'PrivateLobbySubsystem_GetAvailableRegions::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.GetHeatSettings
// 0x0050 (0x0050 - 0x0000)
struct PrivateLobbySubsystem_GetHeatSettings final
{
public:
	struct FHeatSetupData                         ReturnValue;                                       // 0x0000(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_GetHeatSettings) == 0x000008, "Wrong alignment on PrivateLobbySubsystem_GetHeatSettings");
static_assert(sizeof(PrivateLobbySubsystem_GetHeatSettings) == 0x000050, "Wrong size on PrivateLobbySubsystem_GetHeatSettings");
static_assert(offsetof(PrivateLobbySubsystem_GetHeatSettings, ReturnValue) == 0x000000, "Member 'PrivateLobbySubsystem_GetHeatSettings::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.GetLobbyGameMode
// 0x0001 (0x0001 - 0x0000)
struct PrivateLobbySubsystem_GetLobbyGameMode final
{
public:
	EDIGameMode                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_GetLobbyGameMode) == 0x000001, "Wrong alignment on PrivateLobbySubsystem_GetLobbyGameMode");
static_assert(sizeof(PrivateLobbySubsystem_GetLobbyGameMode) == 0x000001, "Wrong size on PrivateLobbySubsystem_GetLobbyGameMode");
static_assert(offsetof(PrivateLobbySubsystem_GetLobbyGameMode, ReturnValue) == 0x000000, "Member 'PrivateLobbySubsystem_GetLobbyGameMode::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.GetLobbyOperationMap
// 0x0008 (0x0008 - 0x0000)
struct PrivateLobbySubsystem_GetLobbyOperationMap final
{
public:
	class UMapData*                               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_GetLobbyOperationMap) == 0x000008, "Wrong alignment on PrivateLobbySubsystem_GetLobbyOperationMap");
static_assert(sizeof(PrivateLobbySubsystem_GetLobbyOperationMap) == 0x000008, "Wrong size on PrivateLobbySubsystem_GetLobbyOperationMap");
static_assert(offsetof(PrivateLobbySubsystem_GetLobbyOperationMap, ReturnValue) == 0x000000, "Member 'PrivateLobbySubsystem_GetLobbyOperationMap::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.GetNPCPopulation
// 0x0010 (0x0010 - 0x0000)
struct PrivateLobbySubsystem_GetNPCPopulation final
{
public:
	TArray<int32>                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_GetNPCPopulation) == 0x000008, "Wrong alignment on PrivateLobbySubsystem_GetNPCPopulation");
static_assert(sizeof(PrivateLobbySubsystem_GetNPCPopulation) == 0x000010, "Wrong size on PrivateLobbySubsystem_GetNPCPopulation");
static_assert(offsetof(PrivateLobbySubsystem_GetNPCPopulation, ReturnValue) == 0x000000, "Member 'PrivateLobbySubsystem_GetNPCPopulation::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.GetNPCPopulationByType
// 0x0008 (0x0008 - 0x0000)
struct PrivateLobbySubsystem_GetNPCPopulationByType final
{
public:
	int32                                         NPCPool;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_GetNPCPopulationByType) == 0x000004, "Wrong alignment on PrivateLobbySubsystem_GetNPCPopulationByType");
static_assert(sizeof(PrivateLobbySubsystem_GetNPCPopulationByType) == 0x000008, "Wrong size on PrivateLobbySubsystem_GetNPCPopulationByType");
static_assert(offsetof(PrivateLobbySubsystem_GetNPCPopulationByType, NPCPool) == 0x000000, "Member 'PrivateLobbySubsystem_GetNPCPopulationByType::NPCPool' has a wrong offset!");
static_assert(offsetof(PrivateLobbySubsystem_GetNPCPopulationByType, ReturnValue) == 0x000004, "Member 'PrivateLobbySubsystem_GetNPCPopulationByType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.GetObjectsToSpawnCount
// 0x0010 (0x0010 - 0x0000)
struct PrivateLobbySubsystem_GetObjectsToSpawnCount final
{
public:
	TArray<struct FObjectToSpawnCount>            ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_GetObjectsToSpawnCount) == 0x000008, "Wrong alignment on PrivateLobbySubsystem_GetObjectsToSpawnCount");
static_assert(sizeof(PrivateLobbySubsystem_GetObjectsToSpawnCount) == 0x000010, "Wrong size on PrivateLobbySubsystem_GetObjectsToSpawnCount");
static_assert(offsetof(PrivateLobbySubsystem_GetObjectsToSpawnCount, ReturnValue) == 0x000000, "Member 'PrivateLobbySubsystem_GetObjectsToSpawnCount::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.GetObjectsToSpawnCountByObjectType
// 0x0028 (0x0028 - 0x0000)
struct PrivateLobbySubsystem_GetObjectsToSpawnCountByObjectType final
{
public:
	class FString                                 ObjectType;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FObjectToSpawnCount                    ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_GetObjectsToSpawnCountByObjectType) == 0x000008, "Wrong alignment on PrivateLobbySubsystem_GetObjectsToSpawnCountByObjectType");
static_assert(sizeof(PrivateLobbySubsystem_GetObjectsToSpawnCountByObjectType) == 0x000028, "Wrong size on PrivateLobbySubsystem_GetObjectsToSpawnCountByObjectType");
static_assert(offsetof(PrivateLobbySubsystem_GetObjectsToSpawnCountByObjectType, ObjectType) == 0x000000, "Member 'PrivateLobbySubsystem_GetObjectsToSpawnCountByObjectType::ObjectType' has a wrong offset!");
static_assert(offsetof(PrivateLobbySubsystem_GetObjectsToSpawnCountByObjectType, ReturnValue) == 0x000010, "Member 'PrivateLobbySubsystem_GetObjectsToSpawnCountByObjectType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.GetPartyMembers
// 0x0010 (0x0010 - 0x0000)
struct PrivateLobbySubsystem_GetPartyMembers final
{
public:
	TArray<class UDIOnlinePartyMemberInfo*>       ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_GetPartyMembers) == 0x000008, "Wrong alignment on PrivateLobbySubsystem_GetPartyMembers");
static_assert(sizeof(PrivateLobbySubsystem_GetPartyMembers) == 0x000010, "Wrong size on PrivateLobbySubsystem_GetPartyMembers");
static_assert(offsetof(PrivateLobbySubsystem_GetPartyMembers, ReturnValue) == 0x000000, "Member 'PrivateLobbySubsystem_GetPartyMembers::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.GetPartyMembersForTeam
// 0x0018 (0x0018 - 0x0000)
struct PrivateLobbySubsystem_GetPartyMembersForTeam final
{
public:
	int32                                         TeamIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDIOnlinePartyMemberInfo*>       ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_GetPartyMembersForTeam) == 0x000008, "Wrong alignment on PrivateLobbySubsystem_GetPartyMembersForTeam");
static_assert(sizeof(PrivateLobbySubsystem_GetPartyMembersForTeam) == 0x000018, "Wrong size on PrivateLobbySubsystem_GetPartyMembersForTeam");
static_assert(offsetof(PrivateLobbySubsystem_GetPartyMembersForTeam, TeamIndex) == 0x000000, "Member 'PrivateLobbySubsystem_GetPartyMembersForTeam::TeamIndex' has a wrong offset!");
static_assert(offsetof(PrivateLobbySubsystem_GetPartyMembersForTeam, ReturnValue) == 0x000008, "Member 'PrivateLobbySubsystem_GetPartyMembersForTeam::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.GetSelectedRegion
// 0x0010 (0x0010 - 0x0000)
struct PrivateLobbySubsystem_GetSelectedRegion final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_GetSelectedRegion) == 0x000008, "Wrong alignment on PrivateLobbySubsystem_GetSelectedRegion");
static_assert(sizeof(PrivateLobbySubsystem_GetSelectedRegion) == 0x000010, "Wrong size on PrivateLobbySubsystem_GetSelectedRegion");
static_assert(offsetof(PrivateLobbySubsystem_GetSelectedRegion, ReturnValue) == 0x000000, "Member 'PrivateLobbySubsystem_GetSelectedRegion::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.GetSelectedRegionIndex
// 0x0004 (0x0004 - 0x0000)
struct PrivateLobbySubsystem_GetSelectedRegionIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_GetSelectedRegionIndex) == 0x000004, "Wrong alignment on PrivateLobbySubsystem_GetSelectedRegionIndex");
static_assert(sizeof(PrivateLobbySubsystem_GetSelectedRegionIndex) == 0x000004, "Wrong size on PrivateLobbySubsystem_GetSelectedRegionIndex");
static_assert(offsetof(PrivateLobbySubsystem_GetSelectedRegionIndex, ReturnValue) == 0x000000, "Member 'PrivateLobbySubsystem_GetSelectedRegionIndex::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.GetSpectatingMembers
// 0x0010 (0x0010 - 0x0000)
struct PrivateLobbySubsystem_GetSpectatingMembers final
{
public:
	TArray<class UDIOnlinePartyMemberInfo*>       ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_GetSpectatingMembers) == 0x000008, "Wrong alignment on PrivateLobbySubsystem_GetSpectatingMembers");
static_assert(sizeof(PrivateLobbySubsystem_GetSpectatingMembers) == 0x000010, "Wrong size on PrivateLobbySubsystem_GetSpectatingMembers");
static_assert(offsetof(PrivateLobbySubsystem_GetSpectatingMembers, ReturnValue) == 0x000000, "Member 'PrivateLobbySubsystem_GetSpectatingMembers::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.GetTeamForPlayer
// 0x0010 (0x0010 - 0x0000)
struct PrivateLobbySubsystem_GetTeamForPlayer final
{
public:
	class UDIOnlinePartyMemberInfo*               Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrivateLobbySubsystem_GetTeamForPlayer) == 0x000008, "Wrong alignment on PrivateLobbySubsystem_GetTeamForPlayer");
static_assert(sizeof(PrivateLobbySubsystem_GetTeamForPlayer) == 0x000010, "Wrong size on PrivateLobbySubsystem_GetTeamForPlayer");
static_assert(offsetof(PrivateLobbySubsystem_GetTeamForPlayer, Player) == 0x000000, "Member 'PrivateLobbySubsystem_GetTeamForPlayer::Player' has a wrong offset!");
static_assert(offsetof(PrivateLobbySubsystem_GetTeamForPlayer, ReturnValue) == 0x000008, "Member 'PrivateLobbySubsystem_GetTeamForPlayer::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PrivateLobbySubsystem.GetUnassignedMembers
// 0x0010 (0x0010 - 0x0000)
struct PrivateLobbySubsystem_GetUnassignedMembers final
{
public:
	TArray<class UDIOnlinePartyMemberInfo*>       ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrivateLobbySubsystem_GetUnassignedMembers) == 0x000008, "Wrong alignment on PrivateLobbySubsystem_GetUnassignedMembers");
static_assert(sizeof(PrivateLobbySubsystem_GetUnassignedMembers) == 0x000010, "Wrong size on PrivateLobbySubsystem_GetUnassignedMembers");
static_assert(offsetof(PrivateLobbySubsystem_GetUnassignedMembers, ReturnValue) == 0x000000, "Member 'PrivateLobbySubsystem_GetUnassignedMembers::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ChavezPassiveAbilityMod2.HandleConfirmedDamageDealt
// 0x0028 (0x0028 - 0x0000)
struct ChavezPassiveAbilityMod2_HandleConfirmedDamageDealt final
{
public:
	class AActor*                                 DamagedActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UDamageType*                      DamageType;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChavezPassiveAbilityMod2_HandleConfirmedDamageDealt) == 0x000008, "Wrong alignment on ChavezPassiveAbilityMod2_HandleConfirmedDamageDealt");
static_assert(sizeof(ChavezPassiveAbilityMod2_HandleConfirmedDamageDealt) == 0x000028, "Wrong size on ChavezPassiveAbilityMod2_HandleConfirmedDamageDealt");
static_assert(offsetof(ChavezPassiveAbilityMod2_HandleConfirmedDamageDealt, DamagedActor) == 0x000000, "Member 'ChavezPassiveAbilityMod2_HandleConfirmedDamageDealt::DamagedActor' has a wrong offset!");
static_assert(offsetof(ChavezPassiveAbilityMod2_HandleConfirmedDamageDealt, Damage) == 0x000008, "Member 'ChavezPassiveAbilityMod2_HandleConfirmedDamageDealt::Damage' has a wrong offset!");
static_assert(offsetof(ChavezPassiveAbilityMod2_HandleConfirmedDamageDealt, DamageType) == 0x000010, "Member 'ChavezPassiveAbilityMod2_HandleConfirmedDamageDealt::DamageType' has a wrong offset!");
static_assert(offsetof(ChavezPassiveAbilityMod2_HandleConfirmedDamageDealt, InstigatedBy) == 0x000018, "Member 'ChavezPassiveAbilityMod2_HandleConfirmedDamageDealt::InstigatedBy' has a wrong offset!");
static_assert(offsetof(ChavezPassiveAbilityMod2_HandleConfirmedDamageDealt, DamageCauser) == 0x000020, "Member 'ChavezPassiveAbilityMod2_HandleConfirmedDamageDealt::DamageCauser' has a wrong offset!");

// Function DeceiveInc.ChavezPassiveAbilityMod2.HandleHealthChanged
// 0x0030 (0x0030 - 0x0000)
struct ChavezPassiveAbilityMod2_HandleHealthChanged final
{
public:
	class UHealthComponent*                       OwningHealthComp;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthDelta;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDamageType*                      DamageType;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RawDamage;                                         // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChavezPassiveAbilityMod2_HandleHealthChanged) == 0x000008, "Wrong alignment on ChavezPassiveAbilityMod2_HandleHealthChanged");
static_assert(sizeof(ChavezPassiveAbilityMod2_HandleHealthChanged) == 0x000030, "Wrong size on ChavezPassiveAbilityMod2_HandleHealthChanged");
static_assert(offsetof(ChavezPassiveAbilityMod2_HandleHealthChanged, OwningHealthComp) == 0x000000, "Member 'ChavezPassiveAbilityMod2_HandleHealthChanged::OwningHealthComp' has a wrong offset!");
static_assert(offsetof(ChavezPassiveAbilityMod2_HandleHealthChanged, Health) == 0x000008, "Member 'ChavezPassiveAbilityMod2_HandleHealthChanged::Health' has a wrong offset!");
static_assert(offsetof(ChavezPassiveAbilityMod2_HandleHealthChanged, HealthDelta) == 0x00000C, "Member 'ChavezPassiveAbilityMod2_HandleHealthChanged::HealthDelta' has a wrong offset!");
static_assert(offsetof(ChavezPassiveAbilityMod2_HandleHealthChanged, DamageType) == 0x000010, "Member 'ChavezPassiveAbilityMod2_HandleHealthChanged::DamageType' has a wrong offset!");
static_assert(offsetof(ChavezPassiveAbilityMod2_HandleHealthChanged, InstigatedBy) == 0x000018, "Member 'ChavezPassiveAbilityMod2_HandleHealthChanged::InstigatedBy' has a wrong offset!");
static_assert(offsetof(ChavezPassiveAbilityMod2_HandleHealthChanged, DamageCauser) == 0x000020, "Member 'ChavezPassiveAbilityMod2_HandleHealthChanged::DamageCauser' has a wrong offset!");
static_assert(offsetof(ChavezPassiveAbilityMod2_HandleHealthChanged, RawDamage) == 0x000028, "Member 'ChavezPassiveAbilityMod2_HandleHealthChanged::RawDamage' has a wrong offset!");

// Function DeceiveInc.ChavezPassiveAbilityMod2.MulticastDamageTaken
// 0x0008 (0x0008 - 0x0000)
struct ChavezPassiveAbilityMod2_MulticastDamageTaken final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChavezPassiveAbilityMod2_MulticastDamageTaken) == 0x000008, "Wrong alignment on ChavezPassiveAbilityMod2_MulticastDamageTaken");
static_assert(sizeof(ChavezPassiveAbilityMod2_MulticastDamageTaken) == 0x000008, "Wrong size on ChavezPassiveAbilityMod2_MulticastDamageTaken");
static_assert(offsetof(ChavezPassiveAbilityMod2_MulticastDamageTaken, Spy) == 0x000000, "Member 'ChavezPassiveAbilityMod2_MulticastDamageTaken::Spy' has a wrong offset!");

// Function DeceiveInc.ChavezPassiveAbilityMod2.MulticastHeal
// 0x0004 (0x0004 - 0x0000)
struct ChavezPassiveAbilityMod2_MulticastHeal final
{
public:
	float                                         HealAmount;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChavezPassiveAbilityMod2_MulticastHeal) == 0x000004, "Wrong alignment on ChavezPassiveAbilityMod2_MulticastHeal");
static_assert(sizeof(ChavezPassiveAbilityMod2_MulticastHeal) == 0x000004, "Wrong size on ChavezPassiveAbilityMod2_MulticastHeal");
static_assert(offsetof(ChavezPassiveAbilityMod2_MulticastHeal, HealAmount) == 0x000000, "Member 'ChavezPassiveAbilityMod2_MulticastHeal::HealAmount' has a wrong offset!");

// Function DeceiveInc.RevivePartyComponent.GetFailureCause
// 0x0001 (0x0001 - 0x0000)
struct RevivePartyComponent_GetFailureCause final
{
public:
	ERevivePartyFailedCause                       ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RevivePartyComponent_GetFailureCause) == 0x000001, "Wrong alignment on RevivePartyComponent_GetFailureCause");
static_assert(sizeof(RevivePartyComponent_GetFailureCause) == 0x000001, "Wrong size on RevivePartyComponent_GetFailureCause");
static_assert(offsetof(RevivePartyComponent_GetFailureCause, ReturnValue) == 0x000000, "Member 'RevivePartyComponent_GetFailureCause::ReturnValue' has a wrong offset!");

// Function DeceiveInc.RevivePartyComponent.HandleInteractionBegin
// 0x0010 (0x0010 - 0x0000)
struct RevivePartyComponent_HandleInteractionBegin final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RevivePartyComponent_HandleInteractionBegin) == 0x000008, "Wrong alignment on RevivePartyComponent_HandleInteractionBegin");
static_assert(sizeof(RevivePartyComponent_HandleInteractionBegin) == 0x000010, "Wrong size on RevivePartyComponent_HandleInteractionBegin");
static_assert(offsetof(RevivePartyComponent_HandleInteractionBegin, Interacter) == 0x000000, "Member 'RevivePartyComponent_HandleInteractionBegin::Interacter' has a wrong offset!");
static_assert(offsetof(RevivePartyComponent_HandleInteractionBegin, Interactable) == 0x000008, "Member 'RevivePartyComponent_HandleInteractionBegin::Interactable' has a wrong offset!");

// Function DeceiveInc.RevivePartyComponent.HandleInteractionCancel
// 0x0010 (0x0010 - 0x0000)
struct RevivePartyComponent_HandleInteractionCancel final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RevivePartyComponent_HandleInteractionCancel) == 0x000008, "Wrong alignment on RevivePartyComponent_HandleInteractionCancel");
static_assert(sizeof(RevivePartyComponent_HandleInteractionCancel) == 0x000010, "Wrong size on RevivePartyComponent_HandleInteractionCancel");
static_assert(offsetof(RevivePartyComponent_HandleInteractionCancel, Interacter) == 0x000000, "Member 'RevivePartyComponent_HandleInteractionCancel::Interacter' has a wrong offset!");
static_assert(offsetof(RevivePartyComponent_HandleInteractionCancel, Interactable) == 0x000008, "Member 'RevivePartyComponent_HandleInteractionCancel::Interactable' has a wrong offset!");

// Function DeceiveInc.RevivePartyComponent.HandleInteractionComplete
// 0x0010 (0x0010 - 0x0000)
struct RevivePartyComponent_HandleInteractionComplete final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RevivePartyComponent_HandleInteractionComplete) == 0x000008, "Wrong alignment on RevivePartyComponent_HandleInteractionComplete");
static_assert(sizeof(RevivePartyComponent_HandleInteractionComplete) == 0x000010, "Wrong size on RevivePartyComponent_HandleInteractionComplete");
static_assert(offsetof(RevivePartyComponent_HandleInteractionComplete, Interacter) == 0x000000, "Member 'RevivePartyComponent_HandleInteractionComplete::Interacter' has a wrong offset!");
static_assert(offsetof(RevivePartyComponent_HandleInteractionComplete, Interactable) == 0x000008, "Member 'RevivePartyComponent_HandleInteractionComplete::Interactable' has a wrong offset!");

// Function DeceiveInc.ChromaticFeedbackSubsystem.AddEffect
// 0x0018 (0x0018 - 0x0000)
struct ChromaticFeedbackSubsystem_AddEffect final
{
public:
	class FString                                 EffectNameToPlay;                                  // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChromaticFeedbackPriority                    Priority;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHighlightMappedKeys;                              // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChromaticFeedbackSubsystem_AddEffect) == 0x000008, "Wrong alignment on ChromaticFeedbackSubsystem_AddEffect");
static_assert(sizeof(ChromaticFeedbackSubsystem_AddEffect) == 0x000018, "Wrong size on ChromaticFeedbackSubsystem_AddEffect");
static_assert(offsetof(ChromaticFeedbackSubsystem_AddEffect, EffectNameToPlay) == 0x000000, "Member 'ChromaticFeedbackSubsystem_AddEffect::EffectNameToPlay' has a wrong offset!");
static_assert(offsetof(ChromaticFeedbackSubsystem_AddEffect, Priority) == 0x000010, "Member 'ChromaticFeedbackSubsystem_AddEffect::Priority' has a wrong offset!");
static_assert(offsetof(ChromaticFeedbackSubsystem_AddEffect, bLoop) == 0x000011, "Member 'ChromaticFeedbackSubsystem_AddEffect::bLoop' has a wrong offset!");
static_assert(offsetof(ChromaticFeedbackSubsystem_AddEffect, bHighlightMappedKeys) == 0x000012, "Member 'ChromaticFeedbackSubsystem_AddEffect::bHighlightMappedKeys' has a wrong offset!");

// Function DeceiveInc.ChromaticFeedbackSubsystem.EnableChromaticFeedback
// 0x0001 (0x0001 - 0x0000)
struct ChromaticFeedbackSubsystem_EnableChromaticFeedback final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChromaticFeedbackSubsystem_EnableChromaticFeedback) == 0x000001, "Wrong alignment on ChromaticFeedbackSubsystem_EnableChromaticFeedback");
static_assert(sizeof(ChromaticFeedbackSubsystem_EnableChromaticFeedback) == 0x000001, "Wrong size on ChromaticFeedbackSubsystem_EnableChromaticFeedback");
static_assert(offsetof(ChromaticFeedbackSubsystem_EnableChromaticFeedback, bEnable) == 0x000000, "Member 'ChromaticFeedbackSubsystem_EnableChromaticFeedback::bEnable' has a wrong offset!");

// Function DeceiveInc.ChromaticFeedbackSubsystem.HandleBooleanPlayerSettingChange
// 0x0002 (0x0002 - 0x0000)
struct ChromaticFeedbackSubsystem_HandleBooleanPlayerSettingChange final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewValue;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChromaticFeedbackSubsystem_HandleBooleanPlayerSettingChange) == 0x000001, "Wrong alignment on ChromaticFeedbackSubsystem_HandleBooleanPlayerSettingChange");
static_assert(sizeof(ChromaticFeedbackSubsystem_HandleBooleanPlayerSettingChange) == 0x000002, "Wrong size on ChromaticFeedbackSubsystem_HandleBooleanPlayerSettingChange");
static_assert(offsetof(ChromaticFeedbackSubsystem_HandleBooleanPlayerSettingChange, SettingType) == 0x000000, "Member 'ChromaticFeedbackSubsystem_HandleBooleanPlayerSettingChange::SettingType' has a wrong offset!");
static_assert(offsetof(ChromaticFeedbackSubsystem_HandleBooleanPlayerSettingChange, NewValue) == 0x000001, "Member 'ChromaticFeedbackSubsystem_HandleBooleanPlayerSettingChange::NewValue' has a wrong offset!");

// Function DeceiveInc.ChromaticFeedbackSubsystem.RemoveEffect
// 0x0018 (0x0018 - 0x0000)
struct ChromaticFeedbackSubsystem_RemoveEffect final
{
public:
	class FString                                 EffectNameToRemove;                                // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChromaticFeedbackPriority                    Priority;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChromaticFeedbackSubsystem_RemoveEffect) == 0x000008, "Wrong alignment on ChromaticFeedbackSubsystem_RemoveEffect");
static_assert(sizeof(ChromaticFeedbackSubsystem_RemoveEffect) == 0x000018, "Wrong size on ChromaticFeedbackSubsystem_RemoveEffect");
static_assert(offsetof(ChromaticFeedbackSubsystem_RemoveEffect, EffectNameToRemove) == 0x000000, "Member 'ChromaticFeedbackSubsystem_RemoveEffect::EffectNameToRemove' has a wrong offset!");
static_assert(offsetof(ChromaticFeedbackSubsystem_RemoveEffect, Priority) == 0x000010, "Member 'ChromaticFeedbackSubsystem_RemoveEffect::Priority' has a wrong offset!");

// Function DeceiveInc.ChromaticFeedbackSubsystem.RemoveEffectAtPriority
// 0x0001 (0x0001 - 0x0000)
struct ChromaticFeedbackSubsystem_RemoveEffectAtPriority final
{
public:
	EChromaticFeedbackPriority                    Priority;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChromaticFeedbackSubsystem_RemoveEffectAtPriority) == 0x000001, "Wrong alignment on ChromaticFeedbackSubsystem_RemoveEffectAtPriority");
static_assert(sizeof(ChromaticFeedbackSubsystem_RemoveEffectAtPriority) == 0x000001, "Wrong size on ChromaticFeedbackSubsystem_RemoveEffectAtPriority");
static_assert(offsetof(ChromaticFeedbackSubsystem_RemoveEffectAtPriority, Priority) == 0x000000, "Member 'ChromaticFeedbackSubsystem_RemoveEffectAtPriority::Priority' has a wrong offset!");

// Function DeceiveInc.ChromaticFeedbackSubsystem.StartEvent
// 0x0001 (0x0001 - 0x0000)
struct ChromaticFeedbackSubsystem_StartEvent final
{
public:
	EChromaFeedbackEventType                      EventType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChromaticFeedbackSubsystem_StartEvent) == 0x000001, "Wrong alignment on ChromaticFeedbackSubsystem_StartEvent");
static_assert(sizeof(ChromaticFeedbackSubsystem_StartEvent) == 0x000001, "Wrong size on ChromaticFeedbackSubsystem_StartEvent");
static_assert(offsetof(ChromaticFeedbackSubsystem_StartEvent, EventType) == 0x000000, "Member 'ChromaticFeedbackSubsystem_StartEvent::EventType' has a wrong offset!");

// Function DeceiveInc.ChromaticFeedbackSubsystem.StopEvent
// 0x0001 (0x0001 - 0x0000)
struct ChromaticFeedbackSubsystem_StopEvent final
{
public:
	EChromaFeedbackEventType                      EventType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChromaticFeedbackSubsystem_StopEvent) == 0x000001, "Wrong alignment on ChromaticFeedbackSubsystem_StopEvent");
static_assert(sizeof(ChromaticFeedbackSubsystem_StopEvent) == 0x000001, "Wrong size on ChromaticFeedbackSubsystem_StopEvent");
static_assert(offsetof(ChromaticFeedbackSubsystem_StopEvent, EventType) == 0x000000, "Member 'ChromaticFeedbackSubsystem_StopEvent::EventType' has a wrong offset!");

// Function DeceiveInc.ClientInformation.GetBuildChangelist
// 0x0004 (0x0004 - 0x0000)
struct ClientInformation_GetBuildChangelist final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientInformation_GetBuildChangelist) == 0x000004, "Wrong alignment on ClientInformation_GetBuildChangelist");
static_assert(sizeof(ClientInformation_GetBuildChangelist) == 0x000004, "Wrong size on ClientInformation_GetBuildChangelist");
static_assert(offsetof(ClientInformation_GetBuildChangelist, ReturnValue) == 0x000000, "Member 'ClientInformation_GetBuildChangelist::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ClientInformation.GetBuildClientBranch
// 0x0010 (0x0010 - 0x0000)
struct ClientInformation_GetBuildClientBranch final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientInformation_GetBuildClientBranch) == 0x000008, "Wrong alignment on ClientInformation_GetBuildClientBranch");
static_assert(sizeof(ClientInformation_GetBuildClientBranch) == 0x000010, "Wrong size on ClientInformation_GetBuildClientBranch");
static_assert(offsetof(ClientInformation_GetBuildClientBranch, ReturnValue) == 0x000000, "Member 'ClientInformation_GetBuildClientBranch::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ClientInformation.GetBuildVersion
// 0x0010 (0x0010 - 0x0000)
struct ClientInformation_GetBuildVersion final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientInformation_GetBuildVersion) == 0x000008, "Wrong alignment on ClientInformation_GetBuildVersion");
static_assert(sizeof(ClientInformation_GetBuildVersion) == 0x000010, "Wrong size on ClientInformation_GetBuildVersion");
static_assert(offsetof(ClientInformation_GetBuildVersion, ReturnValue) == 0x000000, "Member 'ClientInformation_GetBuildVersion::ReturnValue' has a wrong offset!");

// Function DeceiveInc.CooldownComponent.OnRep_ServerCooldownEndTime
// 0x0004 (0x0004 - 0x0000)
struct CooldownComponent_OnRep_ServerCooldownEndTime final
{
public:
	float                                         PreviousServerCooldownEndTime;                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CooldownComponent_OnRep_ServerCooldownEndTime) == 0x000004, "Wrong alignment on CooldownComponent_OnRep_ServerCooldownEndTime");
static_assert(sizeof(CooldownComponent_OnRep_ServerCooldownEndTime) == 0x000004, "Wrong size on CooldownComponent_OnRep_ServerCooldownEndTime");
static_assert(offsetof(CooldownComponent_OnRep_ServerCooldownEndTime, PreviousServerCooldownEndTime) == 0x000000, "Member 'CooldownComponent_OnRep_ServerCooldownEndTime::PreviousServerCooldownEndTime' has a wrong offset!");

// Function DeceiveInc.CooldownComponent.GetCooldownDuration
// 0x0004 (0x0004 - 0x0000)
struct CooldownComponent_GetCooldownDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CooldownComponent_GetCooldownDuration) == 0x000004, "Wrong alignment on CooldownComponent_GetCooldownDuration");
static_assert(sizeof(CooldownComponent_GetCooldownDuration) == 0x000004, "Wrong size on CooldownComponent_GetCooldownDuration");
static_assert(offsetof(CooldownComponent_GetCooldownDuration, ReturnValue) == 0x000000, "Member 'CooldownComponent_GetCooldownDuration::ReturnValue' has a wrong offset!");

// Function DeceiveInc.CooldownComponent.GetCooldownRatio
// 0x0004 (0x0004 - 0x0000)
struct CooldownComponent_GetCooldownRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CooldownComponent_GetCooldownRatio) == 0x000004, "Wrong alignment on CooldownComponent_GetCooldownRatio");
static_assert(sizeof(CooldownComponent_GetCooldownRatio) == 0x000004, "Wrong size on CooldownComponent_GetCooldownRatio");
static_assert(offsetof(CooldownComponent_GetCooldownRatio, ReturnValue) == 0x000000, "Member 'CooldownComponent_GetCooldownRatio::ReturnValue' has a wrong offset!");

// Function DeceiveInc.CooldownComponent.GetCooldownTimeLeft
// 0x0004 (0x0004 - 0x0000)
struct CooldownComponent_GetCooldownTimeLeft final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CooldownComponent_GetCooldownTimeLeft) == 0x000004, "Wrong alignment on CooldownComponent_GetCooldownTimeLeft");
static_assert(sizeof(CooldownComponent_GetCooldownTimeLeft) == 0x000004, "Wrong size on CooldownComponent_GetCooldownTimeLeft");
static_assert(offsetof(CooldownComponent_GetCooldownTimeLeft, ReturnValue) == 0x000000, "Member 'CooldownComponent_GetCooldownTimeLeft::ReturnValue' has a wrong offset!");

// Function DeceiveInc.CooldownComponent.IsOnCooldown
// 0x0001 (0x0001 - 0x0000)
struct CooldownComponent_IsOnCooldown final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CooldownComponent_IsOnCooldown) == 0x000001, "Wrong alignment on CooldownComponent_IsOnCooldown");
static_assert(sizeof(CooldownComponent_IsOnCooldown) == 0x000001, "Wrong size on CooldownComponent_IsOnCooldown");
static_assert(offsetof(CooldownComponent_IsOnCooldown, ReturnValue) == 0x000000, "Member 'CooldownComponent_IsOnCooldown::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ReplicatedDebugDraws.NetMulticast_DrawDebugAACross
// 0x0024 (0x0024 - 0x0000)
struct ReplicatedDebugDraws_NetMulticast_DrawDebugAACross final
{
public:
	struct FVector                                CrossCenter;                                       // 0x0000(0x000C)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrossSize;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lifetime;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ReplicatedDebugDraws_NetMulticast_DrawDebugAACross) == 0x000004, "Wrong alignment on ReplicatedDebugDraws_NetMulticast_DrawDebugAACross");
static_assert(sizeof(ReplicatedDebugDraws_NetMulticast_DrawDebugAACross) == 0x000024, "Wrong size on ReplicatedDebugDraws_NetMulticast_DrawDebugAACross");
static_assert(offsetof(ReplicatedDebugDraws_NetMulticast_DrawDebugAACross, CrossCenter) == 0x000000, "Member 'ReplicatedDebugDraws_NetMulticast_DrawDebugAACross::CrossCenter' has a wrong offset!");
static_assert(offsetof(ReplicatedDebugDraws_NetMulticast_DrawDebugAACross, CrossSize) == 0x00000C, "Member 'ReplicatedDebugDraws_NetMulticast_DrawDebugAACross::CrossSize' has a wrong offset!");
static_assert(offsetof(ReplicatedDebugDraws_NetMulticast_DrawDebugAACross, Color) == 0x000010, "Member 'ReplicatedDebugDraws_NetMulticast_DrawDebugAACross::Color' has a wrong offset!");
static_assert(offsetof(ReplicatedDebugDraws_NetMulticast_DrawDebugAACross, bPersistentLines) == 0x000014, "Member 'ReplicatedDebugDraws_NetMulticast_DrawDebugAACross::bPersistentLines' has a wrong offset!");
static_assert(offsetof(ReplicatedDebugDraws_NetMulticast_DrawDebugAACross, Lifetime) == 0x000018, "Member 'ReplicatedDebugDraws_NetMulticast_DrawDebugAACross::Lifetime' has a wrong offset!");
static_assert(offsetof(ReplicatedDebugDraws_NetMulticast_DrawDebugAACross, DepthPriority) == 0x00001C, "Member 'ReplicatedDebugDraws_NetMulticast_DrawDebugAACross::DepthPriority' has a wrong offset!");
static_assert(offsetof(ReplicatedDebugDraws_NetMulticast_DrawDebugAACross, Thickness) == 0x000020, "Member 'ReplicatedDebugDraws_NetMulticast_DrawDebugAACross::Thickness' has a wrong offset!");

// Function DeceiveInc.ReplicatedDebugDraws.NetMulticast_DrawDebugLine
// 0x002C (0x002C - 0x0000)
struct ReplicatedDebugDraws_NetMulticast_DrawDebugLine final
{
public:
	struct FVector                                LineStart;                                         // 0x0000(0x000C)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineEnd;                                           // 0x000C(0x000C)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lifetime;                                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ReplicatedDebugDraws_NetMulticast_DrawDebugLine) == 0x000004, "Wrong alignment on ReplicatedDebugDraws_NetMulticast_DrawDebugLine");
static_assert(sizeof(ReplicatedDebugDraws_NetMulticast_DrawDebugLine) == 0x00002C, "Wrong size on ReplicatedDebugDraws_NetMulticast_DrawDebugLine");
static_assert(offsetof(ReplicatedDebugDraws_NetMulticast_DrawDebugLine, LineStart) == 0x000000, "Member 'ReplicatedDebugDraws_NetMulticast_DrawDebugLine::LineStart' has a wrong offset!");
static_assert(offsetof(ReplicatedDebugDraws_NetMulticast_DrawDebugLine, LineEnd) == 0x00000C, "Member 'ReplicatedDebugDraws_NetMulticast_DrawDebugLine::LineEnd' has a wrong offset!");
static_assert(offsetof(ReplicatedDebugDraws_NetMulticast_DrawDebugLine, Color) == 0x000018, "Member 'ReplicatedDebugDraws_NetMulticast_DrawDebugLine::Color' has a wrong offset!");
static_assert(offsetof(ReplicatedDebugDraws_NetMulticast_DrawDebugLine, bPersistentLines) == 0x00001C, "Member 'ReplicatedDebugDraws_NetMulticast_DrawDebugLine::bPersistentLines' has a wrong offset!");
static_assert(offsetof(ReplicatedDebugDraws_NetMulticast_DrawDebugLine, Lifetime) == 0x000020, "Member 'ReplicatedDebugDraws_NetMulticast_DrawDebugLine::Lifetime' has a wrong offset!");
static_assert(offsetof(ReplicatedDebugDraws_NetMulticast_DrawDebugLine, DepthPriority) == 0x000024, "Member 'ReplicatedDebugDraws_NetMulticast_DrawDebugLine::DepthPriority' has a wrong offset!");
static_assert(offsetof(ReplicatedDebugDraws_NetMulticast_DrawDebugLine, Thickness) == 0x000028, "Member 'ReplicatedDebugDraws_NetMulticast_DrawDebugLine::Thickness' has a wrong offset!");

// Function DeceiveInc.DamageAoEActor.BP_OnDoDamageToActor
// 0x0008 (0x0008 - 0x0000)
struct DamageAoEActor_BP_OnDoDamageToActor final
{
public:
	class AActor*                                 ActorToDamage;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageAoEActor_BP_OnDoDamageToActor) == 0x000008, "Wrong alignment on DamageAoEActor_BP_OnDoDamageToActor");
static_assert(sizeof(DamageAoEActor_BP_OnDoDamageToActor) == 0x000008, "Wrong size on DamageAoEActor_BP_OnDoDamageToActor");
static_assert(offsetof(DamageAoEActor_BP_OnDoDamageToActor, ActorToDamage) == 0x000000, "Member 'DamageAoEActor_BP_OnDoDamageToActor::ActorToDamage' has a wrong offset!");

// Function DeceiveInc.DamageAoEActor.NetMulticast_OnDoDamage
// 0x0008 (0x0008 - 0x0000)
struct DamageAoEActor_NetMulticast_OnDoDamage final
{
public:
	class AActor*                                 ActorToDamage;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageAoEActor_NetMulticast_OnDoDamage) == 0x000008, "Wrong alignment on DamageAoEActor_NetMulticast_OnDoDamage");
static_assert(sizeof(DamageAoEActor_NetMulticast_OnDoDamage) == 0x000008, "Wrong size on DamageAoEActor_NetMulticast_OnDoDamage");
static_assert(offsetof(DamageAoEActor_NetMulticast_OnDoDamage, ActorToDamage) == 0x000000, "Member 'DamageAoEActor_NetMulticast_OnDoDamage::ActorToDamage' has a wrong offset!");

// Function DeceiveInc.OctoDrainingActiveAbility.BP_OnLocalAlliedPlayerDrainingChange
// 0x0001 (0x0001 - 0x0000)
struct OctoDrainingActiveAbility_BP_OnLocalAlliedPlayerDrainingChange final
{
public:
	bool                                          bDraining;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OctoDrainingActiveAbility_BP_OnLocalAlliedPlayerDrainingChange) == 0x000001, "Wrong alignment on OctoDrainingActiveAbility_BP_OnLocalAlliedPlayerDrainingChange");
static_assert(sizeof(OctoDrainingActiveAbility_BP_OnLocalAlliedPlayerDrainingChange) == 0x000001, "Wrong size on OctoDrainingActiveAbility_BP_OnLocalAlliedPlayerDrainingChange");
static_assert(offsetof(OctoDrainingActiveAbility_BP_OnLocalAlliedPlayerDrainingChange, bDraining) == 0x000000, "Member 'OctoDrainingActiveAbility_BP_OnLocalAlliedPlayerDrainingChange::bDraining' has a wrong offset!");

// Function DeceiveInc.OctoDrainingActiveAbility.BP_OnLocalPlayerDrainingChange
// 0x0001 (0x0001 - 0x0000)
struct OctoDrainingActiveAbility_BP_OnLocalPlayerDrainingChange final
{
public:
	bool                                          bDraining;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OctoDrainingActiveAbility_BP_OnLocalPlayerDrainingChange) == 0x000001, "Wrong alignment on OctoDrainingActiveAbility_BP_OnLocalPlayerDrainingChange");
static_assert(sizeof(OctoDrainingActiveAbility_BP_OnLocalPlayerDrainingChange) == 0x000001, "Wrong size on OctoDrainingActiveAbility_BP_OnLocalPlayerDrainingChange");
static_assert(offsetof(OctoDrainingActiveAbility_BP_OnLocalPlayerDrainingChange, bDraining) == 0x000000, "Member 'OctoDrainingActiveAbility_BP_OnLocalPlayerDrainingChange::bDraining' has a wrong offset!");

// Function DeceiveInc.OctoDrainingActiveAbility.BP_OnLocalVictimPlayerBeingDrainedChange
// 0x0010 (0x0010 - 0x0000)
struct OctoDrainingActiveAbility_BP_OnLocalVictimPlayerBeingDrainedChange final
{
public:
	bool                                          bDrained;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseIntelActor*                        BeingDrainedByHackableIntel;                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OctoDrainingActiveAbility_BP_OnLocalVictimPlayerBeingDrainedChange) == 0x000008, "Wrong alignment on OctoDrainingActiveAbility_BP_OnLocalVictimPlayerBeingDrainedChange");
static_assert(sizeof(OctoDrainingActiveAbility_BP_OnLocalVictimPlayerBeingDrainedChange) == 0x000010, "Wrong size on OctoDrainingActiveAbility_BP_OnLocalVictimPlayerBeingDrainedChange");
static_assert(offsetof(OctoDrainingActiveAbility_BP_OnLocalVictimPlayerBeingDrainedChange, bDrained) == 0x000000, "Member 'OctoDrainingActiveAbility_BP_OnLocalVictimPlayerBeingDrainedChange::bDrained' has a wrong offset!");
static_assert(offsetof(OctoDrainingActiveAbility_BP_OnLocalVictimPlayerBeingDrainedChange, BeingDrainedByHackableIntel) == 0x000008, "Member 'OctoDrainingActiveAbility_BP_OnLocalVictimPlayerBeingDrainedChange::BeingDrainedByHackableIntel' has a wrong offset!");

// Function DeceiveInc.OctoDrainingActiveAbility.BP_OnLocalVictimPlayerDrained
// 0x0008 (0x0008 - 0x0000)
struct OctoDrainingActiveAbility_BP_OnLocalVictimPlayerDrained final
{
public:
	class ABaseIntelActor*                        DrainedByHackableIntel;                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OctoDrainingActiveAbility_BP_OnLocalVictimPlayerDrained) == 0x000008, "Wrong alignment on OctoDrainingActiveAbility_BP_OnLocalVictimPlayerDrained");
static_assert(sizeof(OctoDrainingActiveAbility_BP_OnLocalVictimPlayerDrained) == 0x000008, "Wrong size on OctoDrainingActiveAbility_BP_OnLocalVictimPlayerDrained");
static_assert(offsetof(OctoDrainingActiveAbility_BP_OnLocalVictimPlayerDrained, DrainedByHackableIntel) == 0x000000, "Member 'OctoDrainingActiveAbility_BP_OnLocalVictimPlayerDrained::DrainedByHackableIntel' has a wrong offset!");

// Function DeceiveInc.OctoDrainingActiveAbility.NetMulticast_NotifyPlayerBeingDrained
// 0x0018 (0x0018 - 0x0000)
struct OctoDrainingActiveAbility_NetMulticast_NotifyPlayerBeingDrained final
{
public:
	class ASpy*                                   PlayerBeingDrained;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseIntelActor*                        DrainedByHackableIntel;                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrained;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OctoDrainingActiveAbility_NetMulticast_NotifyPlayerBeingDrained) == 0x000008, "Wrong alignment on OctoDrainingActiveAbility_NetMulticast_NotifyPlayerBeingDrained");
static_assert(sizeof(OctoDrainingActiveAbility_NetMulticast_NotifyPlayerBeingDrained) == 0x000018, "Wrong size on OctoDrainingActiveAbility_NetMulticast_NotifyPlayerBeingDrained");
static_assert(offsetof(OctoDrainingActiveAbility_NetMulticast_NotifyPlayerBeingDrained, PlayerBeingDrained) == 0x000000, "Member 'OctoDrainingActiveAbility_NetMulticast_NotifyPlayerBeingDrained::PlayerBeingDrained' has a wrong offset!");
static_assert(offsetof(OctoDrainingActiveAbility_NetMulticast_NotifyPlayerBeingDrained, DrainedByHackableIntel) == 0x000008, "Member 'OctoDrainingActiveAbility_NetMulticast_NotifyPlayerBeingDrained::DrainedByHackableIntel' has a wrong offset!");
static_assert(offsetof(OctoDrainingActiveAbility_NetMulticast_NotifyPlayerBeingDrained, bDrained) == 0x000010, "Member 'OctoDrainingActiveAbility_NetMulticast_NotifyPlayerBeingDrained::bDrained' has a wrong offset!");

// Function DeceiveInc.OctoDrainingActiveAbility.NetMulticast_NotifyPlayerDrained
// 0x0010 (0x0010 - 0x0000)
struct OctoDrainingActiveAbility_NetMulticast_NotifyPlayerDrained final
{
public:
	class ASpy*                                   PlayerDrained;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseIntelActor*                        DrainedByHackableIntel;                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OctoDrainingActiveAbility_NetMulticast_NotifyPlayerDrained) == 0x000008, "Wrong alignment on OctoDrainingActiveAbility_NetMulticast_NotifyPlayerDrained");
static_assert(sizeof(OctoDrainingActiveAbility_NetMulticast_NotifyPlayerDrained) == 0x000010, "Wrong size on OctoDrainingActiveAbility_NetMulticast_NotifyPlayerDrained");
static_assert(offsetof(OctoDrainingActiveAbility_NetMulticast_NotifyPlayerDrained, PlayerDrained) == 0x000000, "Member 'OctoDrainingActiveAbility_NetMulticast_NotifyPlayerDrained::PlayerDrained' has a wrong offset!");
static_assert(offsetof(OctoDrainingActiveAbility_NetMulticast_NotifyPlayerDrained, DrainedByHackableIntel) == 0x000008, "Member 'OctoDrainingActiveAbility_NetMulticast_NotifyPlayerDrained::DrainedByHackableIntel' has a wrong offset!");

// Function DeceiveInc.OctoActiveAbilityMod1.OnAffectedHackableHacked
// 0x0018 (0x0018 - 0x0000)
struct OctoActiveAbilityMod1_OnAffectedHackableHacked final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseIntelActor*                        IntelActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayResourcesType                        ResourceType;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ResourceAmount;                                    // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OctoActiveAbilityMod1_OnAffectedHackableHacked) == 0x000008, "Wrong alignment on OctoActiveAbilityMod1_OnAffectedHackableHacked");
static_assert(sizeof(OctoActiveAbilityMod1_OnAffectedHackableHacked) == 0x000018, "Wrong size on OctoActiveAbilityMod1_OnAffectedHackableHacked");
static_assert(offsetof(OctoActiveAbilityMod1_OnAffectedHackableHacked, Spy) == 0x000000, "Member 'OctoActiveAbilityMod1_OnAffectedHackableHacked::Spy' has a wrong offset!");
static_assert(offsetof(OctoActiveAbilityMod1_OnAffectedHackableHacked, IntelActor) == 0x000008, "Member 'OctoActiveAbilityMod1_OnAffectedHackableHacked::IntelActor' has a wrong offset!");
static_assert(offsetof(OctoActiveAbilityMod1_OnAffectedHackableHacked, ResourceType) == 0x000010, "Member 'OctoActiveAbilityMod1_OnAffectedHackableHacked::ResourceType' has a wrong offset!");
static_assert(offsetof(OctoActiveAbilityMod1_OnAffectedHackableHacked, ResourceAmount) == 0x000014, "Member 'OctoActiveAbilityMod1_OnAffectedHackableHacked::ResourceAmount' has a wrong offset!");

// Function DeceiveInc.OctoActiveAbilityMod1.OnHackedIntel
// 0x0018 (0x0018 - 0x0000)
struct OctoActiveAbilityMod1_OnHackedIntel final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseIntelActor*                        IntelActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayResourcesType                        ResourceType;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ResourceAmount;                                    // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OctoActiveAbilityMod1_OnHackedIntel) == 0x000008, "Wrong alignment on OctoActiveAbilityMod1_OnHackedIntel");
static_assert(sizeof(OctoActiveAbilityMod1_OnHackedIntel) == 0x000018, "Wrong size on OctoActiveAbilityMod1_OnHackedIntel");
static_assert(offsetof(OctoActiveAbilityMod1_OnHackedIntel, Spy) == 0x000000, "Member 'OctoActiveAbilityMod1_OnHackedIntel::Spy' has a wrong offset!");
static_assert(offsetof(OctoActiveAbilityMod1_OnHackedIntel, IntelActor) == 0x000008, "Member 'OctoActiveAbilityMod1_OnHackedIntel::IntelActor' has a wrong offset!");
static_assert(offsetof(OctoActiveAbilityMod1_OnHackedIntel, ResourceType) == 0x000010, "Member 'OctoActiveAbilityMod1_OnHackedIntel::ResourceType' has a wrong offset!");
static_assert(offsetof(OctoActiveAbilityMod1_OnHackedIntel, ResourceAmount) == 0x000014, "Member 'OctoActiveAbilityMod1_OnHackedIntel::ResourceAmount' has a wrong offset!");

// Function DeceiveInc.OctoActiveAbilityMod1.GetCurrentHackingZone
// 0x0008 (0x0008 - 0x0000)
struct OctoActiveAbilityMod1_GetCurrentHackingZone final
{
public:
	class AOctoHackingZone*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OctoActiveAbilityMod1_GetCurrentHackingZone) == 0x000008, "Wrong alignment on OctoActiveAbilityMod1_GetCurrentHackingZone");
static_assert(sizeof(OctoActiveAbilityMod1_GetCurrentHackingZone) == 0x000008, "Wrong size on OctoActiveAbilityMod1_GetCurrentHackingZone");
static_assert(offsetof(OctoActiveAbilityMod1_GetCurrentHackingZone, ReturnValue) == 0x000000, "Member 'OctoActiveAbilityMod1_GetCurrentHackingZone::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SasoriBaseActiveAbility.HandleInteractionComplete
// 0x0010 (0x0010 - 0x0000)
struct SasoriBaseActiveAbility_HandleInteractionComplete final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SasoriBaseActiveAbility_HandleInteractionComplete) == 0x000008, "Wrong alignment on SasoriBaseActiveAbility_HandleInteractionComplete");
static_assert(sizeof(SasoriBaseActiveAbility_HandleInteractionComplete) == 0x000010, "Wrong size on SasoriBaseActiveAbility_HandleInteractionComplete");
static_assert(offsetof(SasoriBaseActiveAbility_HandleInteractionComplete, Interacter) == 0x000000, "Member 'SasoriBaseActiveAbility_HandleInteractionComplete::Interacter' has a wrong offset!");
static_assert(offsetof(SasoriBaseActiveAbility_HandleInteractionComplete, Interactable) == 0x000008, "Member 'SasoriBaseActiveAbility_HandleInteractionComplete::Interactable' has a wrong offset!");

// Function DeceiveInc.SasoriActiveAbilityMod1.HandleProjectileEndPlay
// 0x0010 (0x0010 - 0x0000)
struct SasoriActiveAbilityMod1_HandleProjectileEndPlay final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndPlayReason                                EndPlayReason;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SasoriActiveAbilityMod1_HandleProjectileEndPlay) == 0x000008, "Wrong alignment on SasoriActiveAbilityMod1_HandleProjectileEndPlay");
static_assert(sizeof(SasoriActiveAbilityMod1_HandleProjectileEndPlay) == 0x000010, "Wrong size on SasoriActiveAbilityMod1_HandleProjectileEndPlay");
static_assert(offsetof(SasoriActiveAbilityMod1_HandleProjectileEndPlay, Actor) == 0x000000, "Member 'SasoriActiveAbilityMod1_HandleProjectileEndPlay::Actor' has a wrong offset!");
static_assert(offsetof(SasoriActiveAbilityMod1_HandleProjectileEndPlay, EndPlayReason) == 0x000008, "Member 'SasoriActiveAbilityMod1_HandleProjectileEndPlay::EndPlayReason' has a wrong offset!");

// Function DeceiveInc.SasoriActiveAbilityMod1.MulticastFireShot
// 0x000C (0x000C - 0x0000)
struct SasoriActiveAbilityMod1_MulticastFireShot final
{
public:
	struct FVector_NetQuantize                    DestinationPos;                                    // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SasoriActiveAbilityMod1_MulticastFireShot) == 0x000004, "Wrong alignment on SasoriActiveAbilityMod1_MulticastFireShot");
static_assert(sizeof(SasoriActiveAbilityMod1_MulticastFireShot) == 0x00000C, "Wrong size on SasoriActiveAbilityMod1_MulticastFireShot");
static_assert(offsetof(SasoriActiveAbilityMod1_MulticastFireShot, DestinationPos) == 0x000000, "Member 'SasoriActiveAbilityMod1_MulticastFireShot::DestinationPos' has a wrong offset!");

// Function DeceiveInc.VaultLockedPhaseInfo.GetObjectiveDesc
// 0x0018 (0x0018 - 0x0000)
struct VaultLockedPhaseInfo_GetObjectiveDesc final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VaultLockedPhaseInfo_GetObjectiveDesc) == 0x000008, "Wrong alignment on VaultLockedPhaseInfo_GetObjectiveDesc");
static_assert(sizeof(VaultLockedPhaseInfo_GetObjectiveDesc) == 0x000018, "Wrong size on VaultLockedPhaseInfo_GetObjectiveDesc");
static_assert(offsetof(VaultLockedPhaseInfo_GetObjectiveDesc, ReturnValue) == 0x000000, "Member 'VaultLockedPhaseInfo_GetObjectiveDesc::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VaultUnlockedPhaseInfo.GetObjectiveDescInsideVault
// 0x0018 (0x0018 - 0x0000)
struct VaultUnlockedPhaseInfo_GetObjectiveDescInsideVault final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VaultUnlockedPhaseInfo_GetObjectiveDescInsideVault) == 0x000008, "Wrong alignment on VaultUnlockedPhaseInfo_GetObjectiveDescInsideVault");
static_assert(sizeof(VaultUnlockedPhaseInfo_GetObjectiveDescInsideVault) == 0x000018, "Wrong size on VaultUnlockedPhaseInfo_GetObjectiveDescInsideVault");
static_assert(offsetof(VaultUnlockedPhaseInfo_GetObjectiveDescInsideVault, ReturnValue) == 0x000000, "Member 'VaultUnlockedPhaseInfo_GetObjectiveDescInsideVault::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VaultUnlockedPhaseInfo.GetObjectiveDescOutsideVault
// 0x0018 (0x0018 - 0x0000)
struct VaultUnlockedPhaseInfo_GetObjectiveDescOutsideVault final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VaultUnlockedPhaseInfo_GetObjectiveDescOutsideVault) == 0x000008, "Wrong alignment on VaultUnlockedPhaseInfo_GetObjectiveDescOutsideVault");
static_assert(sizeof(VaultUnlockedPhaseInfo_GetObjectiveDescOutsideVault) == 0x000018, "Wrong size on VaultUnlockedPhaseInfo_GetObjectiveDescOutsideVault");
static_assert(offsetof(VaultUnlockedPhaseInfo_GetObjectiveDescOutsideVault, ReturnValue) == 0x000000, "Member 'VaultUnlockedPhaseInfo_GetObjectiveDescOutsideVault::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ExtractionArrivedPhaseInfo.GetObjectiveDescCarrier
// 0x0018 (0x0018 - 0x0000)
struct ExtractionArrivedPhaseInfo_GetObjectiveDescCarrier final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExtractionArrivedPhaseInfo_GetObjectiveDescCarrier) == 0x000008, "Wrong alignment on ExtractionArrivedPhaseInfo_GetObjectiveDescCarrier");
static_assert(sizeof(ExtractionArrivedPhaseInfo_GetObjectiveDescCarrier) == 0x000018, "Wrong size on ExtractionArrivedPhaseInfo_GetObjectiveDescCarrier");
static_assert(offsetof(ExtractionArrivedPhaseInfo_GetObjectiveDescCarrier, ReturnValue) == 0x000000, "Member 'ExtractionArrivedPhaseInfo_GetObjectiveDescCarrier::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ExtractionArrivedPhaseInfo.GetObjectiveDescNonCarrier
// 0x0018 (0x0018 - 0x0000)
struct ExtractionArrivedPhaseInfo_GetObjectiveDescNonCarrier final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExtractionArrivedPhaseInfo_GetObjectiveDescNonCarrier) == 0x000008, "Wrong alignment on ExtractionArrivedPhaseInfo_GetObjectiveDescNonCarrier");
static_assert(sizeof(ExtractionArrivedPhaseInfo_GetObjectiveDescNonCarrier) == 0x000018, "Wrong size on ExtractionArrivedPhaseInfo_GetObjectiveDescNonCarrier");
static_assert(offsetof(ExtractionArrivedPhaseInfo_GetObjectiveDescNonCarrier, ReturnValue) == 0x000000, "Member 'ExtractionArrivedPhaseInfo_GetObjectiveDescNonCarrier::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ExtractionArrivedPhaseInfo.GetObjectiveDescNonCarrierTeammate
// 0x0018 (0x0018 - 0x0000)
struct ExtractionArrivedPhaseInfo_GetObjectiveDescNonCarrierTeammate final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExtractionArrivedPhaseInfo_GetObjectiveDescNonCarrierTeammate) == 0x000008, "Wrong alignment on ExtractionArrivedPhaseInfo_GetObjectiveDescNonCarrierTeammate");
static_assert(sizeof(ExtractionArrivedPhaseInfo_GetObjectiveDescNonCarrierTeammate) == 0x000018, "Wrong size on ExtractionArrivedPhaseInfo_GetObjectiveDescNonCarrierTeammate");
static_assert(offsetof(ExtractionArrivedPhaseInfo_GetObjectiveDescNonCarrierTeammate, ReturnValue) == 0x000000, "Member 'ExtractionArrivedPhaseInfo_GetObjectiveDescNonCarrierTeammate::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameModeBase.SetGeneralVoicechatEnabled
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncGameModeBase_SetGeneralVoicechatEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameModeBase_SetGeneralVoicechatEnabled) == 0x000001, "Wrong alignment on DeceiveIncGameModeBase_SetGeneralVoicechatEnabled");
static_assert(sizeof(DeceiveIncGameModeBase_SetGeneralVoicechatEnabled) == 0x000001, "Wrong size on DeceiveIncGameModeBase_SetGeneralVoicechatEnabled");
static_assert(offsetof(DeceiveIncGameModeBase_SetGeneralVoicechatEnabled, bEnabled) == 0x000000, "Member 'DeceiveIncGameModeBase_SetGeneralVoicechatEnabled::bEnabled' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameModeBase.SetPS5MatchId
// 0x0010 (0x0010 - 0x0000)
struct DeceiveIncGameModeBase_SetPS5MatchId final
{
public:
	class FString                                 NewPS5MatchId;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameModeBase_SetPS5MatchId) == 0x000008, "Wrong alignment on DeceiveIncGameModeBase_SetPS5MatchId");
static_assert(sizeof(DeceiveIncGameModeBase_SetPS5MatchId) == 0x000010, "Wrong size on DeceiveIncGameModeBase_SetPS5MatchId");
static_assert(offsetof(DeceiveIncGameModeBase_SetPS5MatchId, NewPS5MatchId) == 0x000000, "Member 'DeceiveIncGameModeBase_SetPS5MatchId::NewPS5MatchId' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameModeBase.SetPS5MatchResponsiblePlayer
// 0x0008 (0x0008 - 0x0000)
struct DeceiveIncGameModeBase_SetPS5MatchResponsiblePlayer final
{
public:
	class ADIPlayerState*                         NewPlayerState;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameModeBase_SetPS5MatchResponsiblePlayer) == 0x000008, "Wrong alignment on DeceiveIncGameModeBase_SetPS5MatchResponsiblePlayer");
static_assert(sizeof(DeceiveIncGameModeBase_SetPS5MatchResponsiblePlayer) == 0x000008, "Wrong size on DeceiveIncGameModeBase_SetPS5MatchResponsiblePlayer");
static_assert(offsetof(DeceiveIncGameModeBase_SetPS5MatchResponsiblePlayer, NewPlayerState) == 0x000000, "Member 'DeceiveIncGameModeBase_SetPS5MatchResponsiblePlayer::NewPlayerState' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameModeBase.SetSpawningRule
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncGameModeBase_SetSpawningRule final
{
public:
	ESpawningRule                                 NewRule;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameModeBase_SetSpawningRule) == 0x000001, "Wrong alignment on DeceiveIncGameModeBase_SetSpawningRule");
static_assert(sizeof(DeceiveIncGameModeBase_SetSpawningRule) == 0x000001, "Wrong size on DeceiveIncGameModeBase_SetSpawningRule");
static_assert(offsetof(DeceiveIncGameModeBase_SetSpawningRule, NewRule) == 0x000000, "Member 'DeceiveIncGameModeBase_SetSpawningRule::NewRule' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameModeBase.UpdatePS5MatchResponsibility
// 0x0008 (0x0008 - 0x0000)
struct DeceiveIncGameModeBase_UpdatePS5MatchResponsibility final
{
public:
	class APlayerController*                      ExcludePlayer;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameModeBase_UpdatePS5MatchResponsibility) == 0x000008, "Wrong alignment on DeceiveIncGameModeBase_UpdatePS5MatchResponsibility");
static_assert(sizeof(DeceiveIncGameModeBase_UpdatePS5MatchResponsibility) == 0x000008, "Wrong size on DeceiveIncGameModeBase_UpdatePS5MatchResponsibility");
static_assert(offsetof(DeceiveIncGameModeBase_UpdatePS5MatchResponsibility, ExcludePlayer) == 0x000000, "Member 'DeceiveIncGameModeBase_UpdatePS5MatchResponsibility::ExcludePlayer' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameModeBase.GetAllActiveSpies
// 0x0010 (0x0010 - 0x0000)
struct DeceiveIncGameModeBase_GetAllActiveSpies final
{
public:
	TArray<class ASpy*>                           ReturnValue;                                       // 0x0000(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameModeBase_GetAllActiveSpies) == 0x000008, "Wrong alignment on DeceiveIncGameModeBase_GetAllActiveSpies");
static_assert(sizeof(DeceiveIncGameModeBase_GetAllActiveSpies) == 0x000010, "Wrong size on DeceiveIncGameModeBase_GetAllActiveSpies");
static_assert(offsetof(DeceiveIncGameModeBase_GetAllActiveSpies, ReturnValue) == 0x000000, "Member 'DeceiveIncGameModeBase_GetAllActiveSpies::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameModeBase.GetSpawningRule
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncGameModeBase_GetSpawningRule final
{
public:
	ESpawningRule                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameModeBase_GetSpawningRule) == 0x000001, "Wrong alignment on DeceiveIncGameModeBase_GetSpawningRule");
static_assert(sizeof(DeceiveIncGameModeBase_GetSpawningRule) == 0x000001, "Wrong size on DeceiveIncGameModeBase_GetSpawningRule");
static_assert(offsetof(DeceiveIncGameModeBase_GetSpawningRule, ReturnValue) == 0x000000, "Member 'DeceiveIncGameModeBase_GetSpawningRule::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncGameModeBase.IsGeneralVoicechatEnabled
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncGameModeBase_IsGeneralVoicechatEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncGameModeBase_IsGeneralVoicechatEnabled) == 0x000001, "Wrong alignment on DeceiveIncGameModeBase_IsGeneralVoicechatEnabled");
static_assert(sizeof(DeceiveIncGameModeBase_IsGeneralVoicechatEnabled) == 0x000001, "Wrong size on DeceiveIncGameModeBase_IsGeneralVoicechatEnabled");
static_assert(offsetof(DeceiveIncGameModeBase_IsGeneralVoicechatEnabled, ReturnValue) == 0x000000, "Member 'DeceiveIncGameModeBase_IsGeneralVoicechatEnabled::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.Client_AgentSelectionFailed
// 0x0014 (0x0014 - 0x0000)
struct DeceiveIncPlayerController_Client_AgentSelectionFailed final
{
public:
	ESelectionValidationResult                    Reason;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetId                        RecommendedAgentId;                                // 0x0004(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_Client_AgentSelectionFailed) == 0x000004, "Wrong alignment on DeceiveIncPlayerController_Client_AgentSelectionFailed");
static_assert(sizeof(DeceiveIncPlayerController_Client_AgentSelectionFailed) == 0x000014, "Wrong size on DeceiveIncPlayerController_Client_AgentSelectionFailed");
static_assert(offsetof(DeceiveIncPlayerController_Client_AgentSelectionFailed, Reason) == 0x000000, "Member 'DeceiveIncPlayerController_Client_AgentSelectionFailed::Reason' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_Client_AgentSelectionFailed, RecommendedAgentId) == 0x000004, "Member 'DeceiveIncPlayerController_Client_AgentSelectionFailed::RecommendedAgentId' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.Client_IncomingEACMessage
// 0x0030 (0x0030 - 0x0000)
struct DeceiveIncPlayerController_Client_IncomingEACMessage final
{
public:
	TArray<uint8>                                 Data;                                              // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 SourceId;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetId;                                          // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_Client_IncomingEACMessage) == 0x000008, "Wrong alignment on DeceiveIncPlayerController_Client_IncomingEACMessage");
static_assert(sizeof(DeceiveIncPlayerController_Client_IncomingEACMessage) == 0x000030, "Wrong size on DeceiveIncPlayerController_Client_IncomingEACMessage");
static_assert(offsetof(DeceiveIncPlayerController_Client_IncomingEACMessage, Data) == 0x000000, "Member 'DeceiveIncPlayerController_Client_IncomingEACMessage::Data' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_Client_IncomingEACMessage, SourceId) == 0x000010, "Member 'DeceiveIncPlayerController_Client_IncomingEACMessage::SourceId' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_Client_IncomingEACMessage, TargetId) == 0x000020, "Member 'DeceiveIncPlayerController_Client_IncomingEACMessage::TargetId' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.Client_JoinVoiceChannel
// 0x0020 (0x0020 - 0x0000)
struct DeceiveIncPlayerController_Client_JoinVoiceChannel final
{
public:
	class FString                                 ChannelName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChannelCredentials;                                // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_Client_JoinVoiceChannel) == 0x000008, "Wrong alignment on DeceiveIncPlayerController_Client_JoinVoiceChannel");
static_assert(sizeof(DeceiveIncPlayerController_Client_JoinVoiceChannel) == 0x000020, "Wrong size on DeceiveIncPlayerController_Client_JoinVoiceChannel");
static_assert(offsetof(DeceiveIncPlayerController_Client_JoinVoiceChannel, ChannelName) == 0x000000, "Member 'DeceiveIncPlayerController_Client_JoinVoiceChannel::ChannelName' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_Client_JoinVoiceChannel, ChannelCredentials) == 0x000010, "Member 'DeceiveIncPlayerController_Client_JoinVoiceChannel::ChannelCredentials' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.ClientKillcamTimeout
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerController_ClientKillcamTimeout final
{
public:
	bool                                          bTriggerSetup;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_ClientKillcamTimeout) == 0x000001, "Wrong alignment on DeceiveIncPlayerController_ClientKillcamTimeout");
static_assert(sizeof(DeceiveIncPlayerController_ClientKillcamTimeout) == 0x000001, "Wrong size on DeceiveIncPlayerController_ClientKillcamTimeout");
static_assert(offsetof(DeceiveIncPlayerController_ClientKillcamTimeout, bTriggerSetup) == 0x000000, "Member 'DeceiveIncPlayerController_ClientKillcamTimeout::bTriggerSetup' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.ClientRecordKillcamFocusData
// 0x0010 (0x0010 - 0x0000)
struct DeceiveIncPlayerController_ClientRecordKillcamFocusData final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerState*                           InPlayerState;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_ClientRecordKillcamFocusData) == 0x000008, "Wrong alignment on DeceiveIncPlayerController_ClientRecordKillcamFocusData");
static_assert(sizeof(DeceiveIncPlayerController_ClientRecordKillcamFocusData) == 0x000010, "Wrong size on DeceiveIncPlayerController_ClientRecordKillcamFocusData");
static_assert(offsetof(DeceiveIncPlayerController_ClientRecordKillcamFocusData, InActor) == 0x000000, "Member 'DeceiveIncPlayerController_ClientRecordKillcamFocusData::InActor' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_ClientRecordKillcamFocusData, InPlayerState) == 0x000008, "Member 'DeceiveIncPlayerController_ClientRecordKillcamFocusData::InPlayerState' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.ClientReportServerTime
// 0x0008 (0x0008 - 0x0000)
struct DeceiveIncPlayerController_ClientReportServerTime final
{
public:
	float                                         RequestWorldTime;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerTime;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_ClientReportServerTime) == 0x000004, "Wrong alignment on DeceiveIncPlayerController_ClientReportServerTime");
static_assert(sizeof(DeceiveIncPlayerController_ClientReportServerTime) == 0x000008, "Wrong size on DeceiveIncPlayerController_ClientReportServerTime");
static_assert(offsetof(DeceiveIncPlayerController_ClientReportServerTime, RequestWorldTime) == 0x000000, "Member 'DeceiveIncPlayerController_ClientReportServerTime::RequestWorldTime' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_ClientReportServerTime, ServerTime) == 0x000004, "Member 'DeceiveIncPlayerController_ClientReportServerTime::ServerTime' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.ClientStartKillcam
// 0x0008 (0x0008 - 0x0000)
struct DeceiveIncPlayerController_ClientStartKillcam final
{
public:
	float                                         TimeToRewind;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerTimestamp;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_ClientStartKillcam) == 0x000004, "Wrong alignment on DeceiveIncPlayerController_ClientStartKillcam");
static_assert(sizeof(DeceiveIncPlayerController_ClientStartKillcam) == 0x000008, "Wrong size on DeceiveIncPlayerController_ClientStartKillcam");
static_assert(offsetof(DeceiveIncPlayerController_ClientStartKillcam, TimeToRewind) == 0x000000, "Member 'DeceiveIncPlayerController_ClientStartKillcam::TimeToRewind' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_ClientStartKillcam, ServerTimestamp) == 0x000004, "Member 'DeceiveIncPlayerController_ClientStartKillcam::ServerTimestamp' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.DEBUG_Randomize_CallingCardSelection
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerController_DEBUG_Randomize_CallingCardSelection final
{
public:
	bool                                          bCommitSelectionToSavegame;                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_DEBUG_Randomize_CallingCardSelection) == 0x000001, "Wrong alignment on DeceiveIncPlayerController_DEBUG_Randomize_CallingCardSelection");
static_assert(sizeof(DeceiveIncPlayerController_DEBUG_Randomize_CallingCardSelection) == 0x000001, "Wrong size on DeceiveIncPlayerController_DEBUG_Randomize_CallingCardSelection");
static_assert(offsetof(DeceiveIncPlayerController_DEBUG_Randomize_CallingCardSelection, bCommitSelectionToSavegame) == 0x000000, "Member 'DeceiveIncPlayerController_DEBUG_Randomize_CallingCardSelection::bCommitSelectionToSavegame' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.DEBUG_Randomize_CharacterSelection
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerController_DEBUG_Randomize_CharacterSelection final
{
public:
	bool                                          bCommitSelectionToSavegame;                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_DEBUG_Randomize_CharacterSelection) == 0x000001, "Wrong alignment on DeceiveIncPlayerController_DEBUG_Randomize_CharacterSelection");
static_assert(sizeof(DeceiveIncPlayerController_DEBUG_Randomize_CharacterSelection) == 0x000001, "Wrong size on DeceiveIncPlayerController_DEBUG_Randomize_CharacterSelection");
static_assert(offsetof(DeceiveIncPlayerController_DEBUG_Randomize_CharacterSelection, bCommitSelectionToSavegame) == 0x000000, "Member 'DeceiveIncPlayerController_DEBUG_Randomize_CharacterSelection::bCommitSelectionToSavegame' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.DEBUG_Randomize_GadgetSelection
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerController_DEBUG_Randomize_GadgetSelection final
{
public:
	bool                                          bCommitSelectionToSavegame;                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_DEBUG_Randomize_GadgetSelection) == 0x000001, "Wrong alignment on DeceiveIncPlayerController_DEBUG_Randomize_GadgetSelection");
static_assert(sizeof(DeceiveIncPlayerController_DEBUG_Randomize_GadgetSelection) == 0x000001, "Wrong size on DeceiveIncPlayerController_DEBUG_Randomize_GadgetSelection");
static_assert(offsetof(DeceiveIncPlayerController_DEBUG_Randomize_GadgetSelection, bCommitSelectionToSavegame) == 0x000000, "Member 'DeceiveIncPlayerController_DEBUG_Randomize_GadgetSelection::bCommitSelectionToSavegame' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.DEBUG_Randomize_Powerups
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerController_DEBUG_Randomize_Powerups final
{
public:
	bool                                          bCommitSelectionToSavegame;                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_DEBUG_Randomize_Powerups) == 0x000001, "Wrong alignment on DeceiveIncPlayerController_DEBUG_Randomize_Powerups");
static_assert(sizeof(DeceiveIncPlayerController_DEBUG_Randomize_Powerups) == 0x000001, "Wrong size on DeceiveIncPlayerController_DEBUG_Randomize_Powerups");
static_assert(offsetof(DeceiveIncPlayerController_DEBUG_Randomize_Powerups, bCommitSelectionToSavegame) == 0x000000, "Member 'DeceiveIncPlayerController_DEBUG_Randomize_Powerups::bCommitSelectionToSavegame' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.DEBUG_Randomize_ProfileSelection
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerController_DEBUG_Randomize_ProfileSelection final
{
public:
	bool                                          bCommitSelectionToSavegame;                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_DEBUG_Randomize_ProfileSelection) == 0x000001, "Wrong alignment on DeceiveIncPlayerController_DEBUG_Randomize_ProfileSelection");
static_assert(sizeof(DeceiveIncPlayerController_DEBUG_Randomize_ProfileSelection) == 0x000001, "Wrong size on DeceiveIncPlayerController_DEBUG_Randomize_ProfileSelection");
static_assert(offsetof(DeceiveIncPlayerController_DEBUG_Randomize_ProfileSelection, bCommitSelectionToSavegame) == 0x000000, "Member 'DeceiveIncPlayerController_DEBUG_Randomize_ProfileSelection::bCommitSelectionToSavegame' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.GetAgentId
// 0x0010 (0x0010 - 0x0000)
struct DeceiveIncPlayerController_GetAgentId final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_GetAgentId) == 0x000004, "Wrong alignment on DeceiveIncPlayerController_GetAgentId");
static_assert(sizeof(DeceiveIncPlayerController_GetAgentId) == 0x000010, "Wrong size on DeceiveIncPlayerController_GetAgentId");
static_assert(offsetof(DeceiveIncPlayerController_GetAgentId, ReturnValue) == 0x000000, "Member 'DeceiveIncPlayerController_GetAgentId::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.GetAliveTeammates
// 0x0010 (0x0010 - 0x0000)
struct DeceiveIncPlayerController_GetAliveTeammates final
{
public:
	TArray<class ADIPlayerState*>                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_GetAliveTeammates) == 0x000008, "Wrong alignment on DeceiveIncPlayerController_GetAliveTeammates");
static_assert(sizeof(DeceiveIncPlayerController_GetAliveTeammates) == 0x000010, "Wrong size on DeceiveIncPlayerController_GetAliveTeammates");
static_assert(offsetof(DeceiveIncPlayerController_GetAliveTeammates, ReturnValue) == 0x000000, "Member 'DeceiveIncPlayerController_GetAliveTeammates::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.GetKillcamViewTargetInfo
// 0x0018 (0x0018 - 0x0000)
struct DeceiveIncPlayerController_GetKillcamViewTargetInfo final
{
public:
	class ADIPlayerState*                         DIPlayerState;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 KillingActor;                                      // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DeceiveIncPlayerController_GetKillcamViewTargetInfo) == 0x000008, "Wrong alignment on DeceiveIncPlayerController_GetKillcamViewTargetInfo");
static_assert(sizeof(DeceiveIncPlayerController_GetKillcamViewTargetInfo) == 0x000018, "Wrong size on DeceiveIncPlayerController_GetKillcamViewTargetInfo");
static_assert(offsetof(DeceiveIncPlayerController_GetKillcamViewTargetInfo, DIPlayerState) == 0x000000, "Member 'DeceiveIncPlayerController_GetKillcamViewTargetInfo::DIPlayerState' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_GetKillcamViewTargetInfo, KillingActor) == 0x000008, "Member 'DeceiveIncPlayerController_GetKillcamViewTargetInfo::KillingActor' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_GetKillcamViewTargetInfo, ReturnValue) == 0x000010, "Member 'DeceiveIncPlayerController_GetKillcamViewTargetInfo::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.GetOwnedSpyPawn
// 0x0008 (0x0008 - 0x0000)
struct DeceiveIncPlayerController_GetOwnedSpyPawn final
{
public:
	class ASpy*                                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_GetOwnedSpyPawn) == 0x000008, "Wrong alignment on DeceiveIncPlayerController_GetOwnedSpyPawn");
static_assert(sizeof(DeceiveIncPlayerController_GetOwnedSpyPawn) == 0x000008, "Wrong size on DeceiveIncPlayerController_GetOwnedSpyPawn");
static_assert(offsetof(DeceiveIncPlayerController_GetOwnedSpyPawn, ReturnValue) == 0x000000, "Member 'DeceiveIncPlayerController_GetOwnedSpyPawn::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.GetPlaceableWrapMaterial
// 0x0018 (0x0018 - 0x0000)
struct DeceiveIncPlayerController_GetPlaceableWrapMaterial final
{
public:
	ELoadoutSlot                                  ToolSlot;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UMaterialInstance>> ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_GetPlaceableWrapMaterial) == 0x000008, "Wrong alignment on DeceiveIncPlayerController_GetPlaceableWrapMaterial");
static_assert(sizeof(DeceiveIncPlayerController_GetPlaceableWrapMaterial) == 0x000018, "Wrong size on DeceiveIncPlayerController_GetPlaceableWrapMaterial");
static_assert(offsetof(DeceiveIncPlayerController_GetPlaceableWrapMaterial, ToolSlot) == 0x000000, "Member 'DeceiveIncPlayerController_GetPlaceableWrapMaterial::ToolSlot' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_GetPlaceableWrapMaterial, ReturnValue) == 0x000008, "Member 'DeceiveIncPlayerController_GetPlaceableWrapMaterial::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.GetToolWrapMaterial
// 0x0018 (0x0018 - 0x0000)
struct DeceiveIncPlayerController_GetToolWrapMaterial final
{
public:
	ELoadoutSlot                                  ToolSlot;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UMaterialInstance>> ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_GetToolWrapMaterial) == 0x000008, "Wrong alignment on DeceiveIncPlayerController_GetToolWrapMaterial");
static_assert(sizeof(DeceiveIncPlayerController_GetToolWrapMaterial) == 0x000018, "Wrong size on DeceiveIncPlayerController_GetToolWrapMaterial");
static_assert(offsetof(DeceiveIncPlayerController_GetToolWrapMaterial, ToolSlot) == 0x000000, "Member 'DeceiveIncPlayerController_GetToolWrapMaterial::ToolSlot' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_GetToolWrapMaterial, ReturnValue) == 0x000008, "Member 'DeceiveIncPlayerController_GetToolWrapMaterial::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.HandleBooleanPlayerSettingChange
// 0x0002 (0x0002 - 0x0000)
struct DeceiveIncPlayerController_HandleBooleanPlayerSettingChange final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewValue;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_HandleBooleanPlayerSettingChange) == 0x000001, "Wrong alignment on DeceiveIncPlayerController_HandleBooleanPlayerSettingChange");
static_assert(sizeof(DeceiveIncPlayerController_HandleBooleanPlayerSettingChange) == 0x000002, "Wrong size on DeceiveIncPlayerController_HandleBooleanPlayerSettingChange");
static_assert(offsetof(DeceiveIncPlayerController_HandleBooleanPlayerSettingChange, SettingType) == 0x000000, "Member 'DeceiveIncPlayerController_HandleBooleanPlayerSettingChange::SettingType' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_HandleBooleanPlayerSettingChange, NewValue) == 0x000001, "Member 'DeceiveIncPlayerController_HandleBooleanPlayerSettingChange::NewValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.HandleGamePhaseChange
// 0x0010 (0x0010 - 0x0000)
struct DeceiveIncPlayerController_HandleGamePhaseChange final
{
public:
	ESpyGamePhase                                 NewPhase;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class ADeceiveIncMatchGameState*        GameState;                                         // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_HandleGamePhaseChange) == 0x000008, "Wrong alignment on DeceiveIncPlayerController_HandleGamePhaseChange");
static_assert(sizeof(DeceiveIncPlayerController_HandleGamePhaseChange) == 0x000010, "Wrong size on DeceiveIncPlayerController_HandleGamePhaseChange");
static_assert(offsetof(DeceiveIncPlayerController_HandleGamePhaseChange, NewPhase) == 0x000000, "Member 'DeceiveIncPlayerController_HandleGamePhaseChange::NewPhase' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_HandleGamePhaseChange, GameState) == 0x000008, "Member 'DeceiveIncPlayerController_HandleGamePhaseChange::GameState' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.HandleIntegerPlayerSettingChange
// 0x0008 (0x0008 - 0x0000)
struct DeceiveIncPlayerController_HandleIntegerPlayerSettingChange final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NewValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_HandleIntegerPlayerSettingChange) == 0x000004, "Wrong alignment on DeceiveIncPlayerController_HandleIntegerPlayerSettingChange");
static_assert(sizeof(DeceiveIncPlayerController_HandleIntegerPlayerSettingChange) == 0x000008, "Wrong size on DeceiveIncPlayerController_HandleIntegerPlayerSettingChange");
static_assert(offsetof(DeceiveIncPlayerController_HandleIntegerPlayerSettingChange, SettingType) == 0x000000, "Member 'DeceiveIncPlayerController_HandleIntegerPlayerSettingChange::SettingType' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_HandleIntegerPlayerSettingChange, NewValue) == 0x000004, "Member 'DeceiveIncPlayerController_HandleIntegerPlayerSettingChange::NewValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.IsKillcamPlaying
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerController_IsKillcamPlaying final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_IsKillcamPlaying) == 0x000001, "Wrong alignment on DeceiveIncPlayerController_IsKillcamPlaying");
static_assert(sizeof(DeceiveIncPlayerController_IsKillcamPlaying) == 0x000001, "Wrong size on DeceiveIncPlayerController_IsKillcamPlaying");
static_assert(offsetof(DeceiveIncPlayerController_IsKillcamPlaying, ReturnValue) == 0x000000, "Member 'DeceiveIncPlayerController_IsKillcamPlaying::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.IsKillcamStartingUp
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerController_IsKillcamStartingUp final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_IsKillcamStartingUp) == 0x000001, "Wrong alignment on DeceiveIncPlayerController_IsKillcamStartingUp");
static_assert(sizeof(DeceiveIncPlayerController_IsKillcamStartingUp) == 0x000001, "Wrong size on DeceiveIncPlayerController_IsKillcamStartingUp");
static_assert(offsetof(DeceiveIncPlayerController_IsKillcamStartingUp, ReturnValue) == 0x000000, "Member 'DeceiveIncPlayerController_IsKillcamStartingUp::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.IsTeamAlive
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerController_IsTeamAlive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_IsTeamAlive) == 0x000001, "Wrong alignment on DeceiveIncPlayerController_IsTeamAlive");
static_assert(sizeof(DeceiveIncPlayerController_IsTeamAlive) == 0x000001, "Wrong size on DeceiveIncPlayerController_IsTeamAlive");
static_assert(offsetof(DeceiveIncPlayerController_IsTeamAlive, ReturnValue) == 0x000000, "Member 'DeceiveIncPlayerController_IsTeamAlive::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.OnKillcamStartCompleted
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerController_OnKillcamStartCompleted final
{
public:
	bool                                          bSuccessful;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_OnKillcamStartCompleted) == 0x000001, "Wrong alignment on DeceiveIncPlayerController_OnKillcamStartCompleted");
static_assert(sizeof(DeceiveIncPlayerController_OnKillcamStartCompleted) == 0x000001, "Wrong size on DeceiveIncPlayerController_OnKillcamStartCompleted");
static_assert(offsetof(DeceiveIncPlayerController_OnKillcamStartCompleted, bSuccessful) == 0x000000, "Member 'DeceiveIncPlayerController_OnKillcamStartCompleted::bSuccessful' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.OnKillcamStopCompleted
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerController_OnKillcamStopCompleted final
{
public:
	bool                                          bTriggerSetup;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_OnKillcamStopCompleted) == 0x000001, "Wrong alignment on DeceiveIncPlayerController_OnKillcamStopCompleted");
static_assert(sizeof(DeceiveIncPlayerController_OnKillcamStopCompleted) == 0x000001, "Wrong size on DeceiveIncPlayerController_OnKillcamStopCompleted");
static_assert(offsetof(DeceiveIncPlayerController_OnKillcamStopCompleted, bTriggerSetup) == 0x000000, "Member 'DeceiveIncPlayerController_OnKillcamStopCompleted::bTriggerSetup' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.OnSessionSelectionsModified
// 0x0008 (0x0008 - 0x0000)
struct DeceiveIncPlayerController_OnSessionSelectionsModified final
{
public:
	const class UDISessionSelections*             SessionSelection;                                  // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_OnSessionSelectionsModified) == 0x000008, "Wrong alignment on DeceiveIncPlayerController_OnSessionSelectionsModified");
static_assert(sizeof(DeceiveIncPlayerController_OnSessionSelectionsModified) == 0x000008, "Wrong size on DeceiveIncPlayerController_OnSessionSelectionsModified");
static_assert(offsetof(DeceiveIncPlayerController_OnSessionSelectionsModified, SessionSelection) == 0x000000, "Member 'DeceiveIncPlayerController_OnSessionSelectionsModified::SessionSelection' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.PlayerReadyForSpawn
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerController_PlayerReadyForSpawn final
{
public:
	bool                                          bForceSpawn;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_PlayerReadyForSpawn) == 0x000001, "Wrong alignment on DeceiveIncPlayerController_PlayerReadyForSpawn");
static_assert(sizeof(DeceiveIncPlayerController_PlayerReadyForSpawn) == 0x000001, "Wrong size on DeceiveIncPlayerController_PlayerReadyForSpawn");
static_assert(offsetof(DeceiveIncPlayerController_PlayerReadyForSpawn, bForceSpawn) == 0x000000, "Member 'DeceiveIncPlayerController_PlayerReadyForSpawn::bForceSpawn' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.RPC_ClientInformOfEvent
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerController_RPC_ClientInformOfEvent final
{
public:
	EClientEvent                                  ClientEvent;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_RPC_ClientInformOfEvent) == 0x000001, "Wrong alignment on DeceiveIncPlayerController_RPC_ClientInformOfEvent");
static_assert(sizeof(DeceiveIncPlayerController_RPC_ClientInformOfEvent) == 0x000001, "Wrong size on DeceiveIncPlayerController_RPC_ClientInformOfEvent");
static_assert(offsetof(DeceiveIncPlayerController_RPC_ClientInformOfEvent, ClientEvent) == 0x000000, "Member 'DeceiveIncPlayerController_RPC_ClientInformOfEvent::ClientEvent' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.RPC_SpectateActor
// 0x0010 (0x0010 - 0x0000)
struct DeceiveIncPlayerController_RPC_SpectateActor final
{
public:
	class AActor*                                 ActorToSpectate;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADIPlayerState*                         PlayerStateToSpectate;                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_RPC_SpectateActor) == 0x000008, "Wrong alignment on DeceiveIncPlayerController_RPC_SpectateActor");
static_assert(sizeof(DeceiveIncPlayerController_RPC_SpectateActor) == 0x000010, "Wrong size on DeceiveIncPlayerController_RPC_SpectateActor");
static_assert(offsetof(DeceiveIncPlayerController_RPC_SpectateActor, ActorToSpectate) == 0x000000, "Member 'DeceiveIncPlayerController_RPC_SpectateActor::ActorToSpectate' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_RPC_SpectateActor, PlayerStateToSpectate) == 0x000008, "Member 'DeceiveIncPlayerController_RPC_SpectateActor::PlayerStateToSpectate' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.Server_AskForNextSpectatedActor
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerController_Server_AskForNextSpectatedActor final
{
public:
	bool                                          bNext;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_Server_AskForNextSpectatedActor) == 0x000001, "Wrong alignment on DeceiveIncPlayerController_Server_AskForNextSpectatedActor");
static_assert(sizeof(DeceiveIncPlayerController_Server_AskForNextSpectatedActor) == 0x000001, "Wrong size on DeceiveIncPlayerController_Server_AskForNextSpectatedActor");
static_assert(offsetof(DeceiveIncPlayerController_Server_AskForNextSpectatedActor, bNext) == 0x000000, "Member 'DeceiveIncPlayerController_Server_AskForNextSpectatedActor::bNext' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.Server_ClientIsReady
// 0x0010 (0x0010 - 0x0000)
struct DeceiveIncPlayerController_Server_ClientIsReady final
{
public:
	class FString                                 Payload;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_Server_ClientIsReady) == 0x000008, "Wrong alignment on DeceiveIncPlayerController_Server_ClientIsReady");
static_assert(sizeof(DeceiveIncPlayerController_Server_ClientIsReady) == 0x000010, "Wrong size on DeceiveIncPlayerController_Server_ClientIsReady");
static_assert(offsetof(DeceiveIncPlayerController_Server_ClientIsReady, Payload) == 0x000000, "Member 'DeceiveIncPlayerController_Server_ClientIsReady::Payload' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.Server_IncomingEACMessage
// 0x0030 (0x0030 - 0x0000)
struct DeceiveIncPlayerController_Server_IncomingEACMessage final
{
public:
	TArray<uint8>                                 Data;                                              // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 SourceId;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetId;                                          // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_Server_IncomingEACMessage) == 0x000008, "Wrong alignment on DeceiveIncPlayerController_Server_IncomingEACMessage");
static_assert(sizeof(DeceiveIncPlayerController_Server_IncomingEACMessage) == 0x000030, "Wrong size on DeceiveIncPlayerController_Server_IncomingEACMessage");
static_assert(offsetof(DeceiveIncPlayerController_Server_IncomingEACMessage, Data) == 0x000000, "Member 'DeceiveIncPlayerController_Server_IncomingEACMessage::Data' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_Server_IncomingEACMessage, SourceId) == 0x000010, "Member 'DeceiveIncPlayerController_Server_IncomingEACMessage::SourceId' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_Server_IncomingEACMessage, TargetId) == 0x000020, "Member 'DeceiveIncPlayerController_Server_IncomingEACMessage::TargetId' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.Server_SetKillcamIsPlaying
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerController_Server_SetKillcamIsPlaying final
{
public:
	bool                                          bIsPlaying;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_Server_SetKillcamIsPlaying) == 0x000001, "Wrong alignment on DeceiveIncPlayerController_Server_SetKillcamIsPlaying");
static_assert(sizeof(DeceiveIncPlayerController_Server_SetKillcamIsPlaying) == 0x000001, "Wrong size on DeceiveIncPlayerController_Server_SetKillcamIsPlaying");
static_assert(offsetof(DeceiveIncPlayerController_Server_SetKillcamIsPlaying, bIsPlaying) == 0x000000, "Member 'DeceiveIncPlayerController_Server_SetKillcamIsPlaying::bIsPlaying' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.Server_SetPlayerName
// 0x0010 (0x0010 - 0x0000)
struct DeceiveIncPlayerController_Server_SetPlayerName final
{
public:
	class FString                                 Username;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_Server_SetPlayerName) == 0x000008, "Wrong alignment on DeceiveIncPlayerController_Server_SetPlayerName");
static_assert(sizeof(DeceiveIncPlayerController_Server_SetPlayerName) == 0x000010, "Wrong size on DeceiveIncPlayerController_Server_SetPlayerName");
static_assert(offsetof(DeceiveIncPlayerController_Server_SetPlayerName, Username) == 0x000000, "Member 'DeceiveIncPlayerController_Server_SetPlayerName::Username' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.ServerForceKillcam
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerController_ServerForceKillcam final
{
public:
	bool                                          bReviveAfterKillcamIn;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_ServerForceKillcam) == 0x000001, "Wrong alignment on DeceiveIncPlayerController_ServerForceKillcam");
static_assert(sizeof(DeceiveIncPlayerController_ServerForceKillcam) == 0x000001, "Wrong size on DeceiveIncPlayerController_ServerForceKillcam");
static_assert(offsetof(DeceiveIncPlayerController_ServerForceKillcam, bReviveAfterKillcamIn) == 0x000000, "Member 'DeceiveIncPlayerController_ServerForceKillcam::bReviveAfterKillcamIn' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.ServerInitAccelByte
// 0x0040 (0x0040 - 0x0000)
struct DeceiveIncPlayerController_ServerInitAccelByte final
{
public:
	struct FAccelByteUniqueIdComposite            UniqueNetId;                                       // 0x0000(0x0030)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 InMatchId;                                         // 0x0030(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_ServerInitAccelByte) == 0x000008, "Wrong alignment on DeceiveIncPlayerController_ServerInitAccelByte");
static_assert(sizeof(DeceiveIncPlayerController_ServerInitAccelByte) == 0x000040, "Wrong size on DeceiveIncPlayerController_ServerInitAccelByte");
static_assert(offsetof(DeceiveIncPlayerController_ServerInitAccelByte, UniqueNetId) == 0x000000, "Member 'DeceiveIncPlayerController_ServerInitAccelByte::UniqueNetId' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_ServerInitAccelByte, InMatchId) == 0x000030, "Member 'DeceiveIncPlayerController_ServerInitAccelByte::InMatchId' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.ServerInitPlayerInfos
// 0x0198 (0x0198 - 0x0000)
struct DeceiveIncPlayerController_ServerInitPlayerInfos final
{
public:
	class FString                                 BanditIdIn;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameLiftPlayerSessionIdIn;                         // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerAgentSelectionInfo              AgentSelectionIn;                                  // 0x0020(0x00B4)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDISerializedAccessories               AccessoriesIn;                                     // 0x00D8(0x0098)(Parm, NativeAccessSpecifierPublic)
	struct FDISerializedDeckEntry                 DeckIn;                                            // 0x0170(0x0010)(Parm, NativeAccessSpecifierPublic)
	EPlatformType                                 PlateformType;                                     // 0x0180(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDIOnlinePartyMemberInfo*>       PartyMembers;                                      // 0x0188(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_ServerInitPlayerInfos) == 0x000008, "Wrong alignment on DeceiveIncPlayerController_ServerInitPlayerInfos");
static_assert(sizeof(DeceiveIncPlayerController_ServerInitPlayerInfos) == 0x000198, "Wrong size on DeceiveIncPlayerController_ServerInitPlayerInfos");
static_assert(offsetof(DeceiveIncPlayerController_ServerInitPlayerInfos, BanditIdIn) == 0x000000, "Member 'DeceiveIncPlayerController_ServerInitPlayerInfos::BanditIdIn' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_ServerInitPlayerInfos, GameLiftPlayerSessionIdIn) == 0x000010, "Member 'DeceiveIncPlayerController_ServerInitPlayerInfos::GameLiftPlayerSessionIdIn' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_ServerInitPlayerInfos, AgentSelectionIn) == 0x000020, "Member 'DeceiveIncPlayerController_ServerInitPlayerInfos::AgentSelectionIn' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_ServerInitPlayerInfos, AccessoriesIn) == 0x0000D8, "Member 'DeceiveIncPlayerController_ServerInitPlayerInfos::AccessoriesIn' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_ServerInitPlayerInfos, DeckIn) == 0x000170, "Member 'DeceiveIncPlayerController_ServerInitPlayerInfos::DeckIn' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_ServerInitPlayerInfos, PlateformType) == 0x000180, "Member 'DeceiveIncPlayerController_ServerInitPlayerInfos::PlateformType' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_ServerInitPlayerInfos, PartyMembers) == 0x000188, "Member 'DeceiveIncPlayerController_ServerInitPlayerInfos::PartyMembers' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.ServerRequestServerTime
// 0x0004 (0x0004 - 0x0000)
struct DeceiveIncPlayerController_ServerRequestServerTime final
{
public:
	float                                         RequestWorldTime;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_ServerRequestServerTime) == 0x000004, "Wrong alignment on DeceiveIncPlayerController_ServerRequestServerTime");
static_assert(sizeof(DeceiveIncPlayerController_ServerRequestServerTime) == 0x000004, "Wrong size on DeceiveIncPlayerController_ServerRequestServerTime");
static_assert(offsetof(DeceiveIncPlayerController_ServerRequestServerTime, RequestWorldTime) == 0x000000, "Member 'DeceiveIncPlayerController_ServerRequestServerTime::RequestWorldTime' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.ServerSelectAgent
// 0x0168 (0x0168 - 0x0000)
struct DeceiveIncPlayerController_ServerSelectAgent final
{
public:
	struct FPlayerAgentSelectionInfo              AgentSelectionIn;                                  // 0x0000(0x00B4)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDISerializedAccessories               AccessoriesIn;                                     // 0x00B8(0x0098)(Parm, NativeAccessSpecifierPublic)
	struct FDISerializedDeckEntry                 NewDeck;                                           // 0x0150(0x0010)(Parm, NativeAccessSpecifierPublic)
	bool                                          bForceSpawn;                                       // 0x0160(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DeceiveIncPlayerController_ServerSelectAgent) == 0x000008, "Wrong alignment on DeceiveIncPlayerController_ServerSelectAgent");
static_assert(sizeof(DeceiveIncPlayerController_ServerSelectAgent) == 0x000168, "Wrong size on DeceiveIncPlayerController_ServerSelectAgent");
static_assert(offsetof(DeceiveIncPlayerController_ServerSelectAgent, AgentSelectionIn) == 0x000000, "Member 'DeceiveIncPlayerController_ServerSelectAgent::AgentSelectionIn' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_ServerSelectAgent, AccessoriesIn) == 0x0000B8, "Member 'DeceiveIncPlayerController_ServerSelectAgent::AccessoriesIn' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_ServerSelectAgent, NewDeck) == 0x000150, "Member 'DeceiveIncPlayerController_ServerSelectAgent::NewDeck' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerController_ServerSelectAgent, bForceSpawn) == 0x000160, "Member 'DeceiveIncPlayerController_ServerSelectAgent::bForceSpawn' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.ServerSetPS5MatchId
// 0x0010 (0x0010 - 0x0000)
struct DeceiveIncPlayerController_ServerSetPS5MatchId final
{
public:
	class FString                                 NewPS5MatchId;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_ServerSetPS5MatchId) == 0x000008, "Wrong alignment on DeceiveIncPlayerController_ServerSetPS5MatchId");
static_assert(sizeof(DeceiveIncPlayerController_ServerSetPS5MatchId) == 0x000010, "Wrong size on DeceiveIncPlayerController_ServerSetPS5MatchId");
static_assert(offsetof(DeceiveIncPlayerController_ServerSetPS5MatchId, NewPS5MatchId) == 0x000000, "Member 'DeceiveIncPlayerController_ServerSetPS5MatchId::NewPS5MatchId' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.TryTogglePauseMenu
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerController_TryTogglePauseMenu final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_TryTogglePauseMenu) == 0x000001, "Wrong alignment on DeceiveIncPlayerController_TryTogglePauseMenu");
static_assert(sizeof(DeceiveIncPlayerController_TryTogglePauseMenu) == 0x000001, "Wrong size on DeceiveIncPlayerController_TryTogglePauseMenu");
static_assert(offsetof(DeceiveIncPlayerController_TryTogglePauseMenu, ReturnValue) == 0x000000, "Member 'DeceiveIncPlayerController_TryTogglePauseMenu::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.WantsToPlayKillcam
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerController_WantsToPlayKillcam final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_WantsToPlayKillcam) == 0x000001, "Wrong alignment on DeceiveIncPlayerController_WantsToPlayKillcam");
static_assert(sizeof(DeceiveIncPlayerController_WantsToPlayKillcam) == 0x000001, "Wrong size on DeceiveIncPlayerController_WantsToPlayKillcam");
static_assert(offsetof(DeceiveIncPlayerController_WantsToPlayKillcam, ReturnValue) == 0x000000, "Member 'DeceiveIncPlayerController_WantsToPlayKillcam::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.IsInTeamVoicechat
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerController_IsInTeamVoicechat final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_IsInTeamVoicechat) == 0x000001, "Wrong alignment on DeceiveIncPlayerController_IsInTeamVoicechat");
static_assert(sizeof(DeceiveIncPlayerController_IsInTeamVoicechat) == 0x000001, "Wrong size on DeceiveIncPlayerController_IsInTeamVoicechat");
static_assert(offsetof(DeceiveIncPlayerController_IsInTeamVoicechat, ReturnValue) == 0x000000, "Member 'DeceiveIncPlayerController_IsInTeamVoicechat::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerController.IsJoiningTeamVoicechat
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerController_IsJoiningTeamVoicechat final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerController_IsJoiningTeamVoicechat) == 0x000001, "Wrong alignment on DeceiveIncPlayerController_IsJoiningTeamVoicechat");
static_assert(sizeof(DeceiveIncPlayerController_IsJoiningTeamVoicechat) == 0x000001, "Wrong size on DeceiveIncPlayerController_IsJoiningTeamVoicechat");
static_assert(offsetof(DeceiveIncPlayerController_IsJoiningTeamVoicechat, ReturnValue) == 0x000000, "Member 'DeceiveIncPlayerController_IsJoiningTeamVoicechat::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.JoinVoiceChannel
// 0x0028 (0x0028 - 0x0000)
struct DeceiveIncPlayerVoiceChat_JoinVoiceChannel final
{
public:
	class FString                                 ChannelName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChannelCredentials;                                // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_JoinVoiceChannel) == 0x000008, "Wrong alignment on DeceiveIncPlayerVoiceChat_JoinVoiceChannel");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_JoinVoiceChannel) == 0x000028, "Wrong size on DeceiveIncPlayerVoiceChat_JoinVoiceChannel");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_JoinVoiceChannel, ChannelName) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_JoinVoiceChannel::ChannelName' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_JoinVoiceChannel, ChannelCredentials) == 0x000010, "Member 'DeceiveIncPlayerVoiceChat_JoinVoiceChannel::ChannelCredentials' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_JoinVoiceChannel, ReturnValue) == 0x000020, "Member 'DeceiveIncPlayerVoiceChat_JoinVoiceChannel::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.LeaveAllVoiceChannels
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerVoiceChat_LeaveAllVoiceChannels final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_LeaveAllVoiceChannels) == 0x000001, "Wrong alignment on DeceiveIncPlayerVoiceChat_LeaveAllVoiceChannels");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_LeaveAllVoiceChannels) == 0x000001, "Wrong size on DeceiveIncPlayerVoiceChat_LeaveAllVoiceChannels");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_LeaveAllVoiceChannels, ReturnValue) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_LeaveAllVoiceChannels::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.LeaveVoiceChannel
// 0x0018 (0x0018 - 0x0000)
struct DeceiveIncPlayerVoiceChat_LeaveVoiceChannel final
{
public:
	class FString                                 ChannelName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_LeaveVoiceChannel) == 0x000008, "Wrong alignment on DeceiveIncPlayerVoiceChat_LeaveVoiceChannel");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_LeaveVoiceChannel) == 0x000018, "Wrong size on DeceiveIncPlayerVoiceChat_LeaveVoiceChannel");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_LeaveVoiceChannel, ChannelName) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_LeaveVoiceChannel::ChannelName' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_LeaveVoiceChannel, ReturnValue) == 0x000010, "Member 'DeceiveIncPlayerVoiceChat_LeaveVoiceChannel::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.SetInputMuted
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerVoiceChat_SetInputMuted final
{
public:
	bool                                          bMuted;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_SetInputMuted) == 0x000001, "Wrong alignment on DeceiveIncPlayerVoiceChat_SetInputMuted");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_SetInputMuted) == 0x000001, "Wrong size on DeceiveIncPlayerVoiceChat_SetInputMuted");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_SetInputMuted, bMuted) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_SetInputMuted::bMuted' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.SetInputVolume
// 0x0004 (0x0004 - 0x0000)
struct DeceiveIncPlayerVoiceChat_SetInputVolume final
{
public:
	float                                         Volume;                                            // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_SetInputVolume) == 0x000004, "Wrong alignment on DeceiveIncPlayerVoiceChat_SetInputVolume");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_SetInputVolume) == 0x000004, "Wrong size on DeceiveIncPlayerVoiceChat_SetInputVolume");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_SetInputVolume, Volume) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_SetInputVolume::Volume' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.SetLocalVoiceActivationThreshold
// 0x0004 (0x0004 - 0x0000)
struct DeceiveIncPlayerVoiceChat_SetLocalVoiceActivationThreshold final
{
public:
	float                                         FNormalizedThreshold;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_SetLocalVoiceActivationThreshold) == 0x000004, "Wrong alignment on DeceiveIncPlayerVoiceChat_SetLocalVoiceActivationThreshold");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_SetLocalVoiceActivationThreshold) == 0x000004, "Wrong size on DeceiveIncPlayerVoiceChat_SetLocalVoiceActivationThreshold");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_SetLocalVoiceActivationThreshold, FNormalizedThreshold) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_SetLocalVoiceActivationThreshold::FNormalizedThreshold' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.SetOutputMuted
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerVoiceChat_SetOutputMuted final
{
public:
	bool                                          bMuted;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_SetOutputMuted) == 0x000001, "Wrong alignment on DeceiveIncPlayerVoiceChat_SetOutputMuted");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_SetOutputMuted) == 0x000001, "Wrong size on DeceiveIncPlayerVoiceChat_SetOutputMuted");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_SetOutputMuted, bMuted) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_SetOutputMuted::bMuted' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.SetOutputVolume
// 0x0004 (0x0004 - 0x0000)
struct DeceiveIncPlayerVoiceChat_SetOutputVolume final
{
public:
	float                                         Volume;                                            // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_SetOutputVolume) == 0x000004, "Wrong alignment on DeceiveIncPlayerVoiceChat_SetOutputVolume");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_SetOutputVolume) == 0x000004, "Wrong size on DeceiveIncPlayerVoiceChat_SetOutputVolume");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_SetOutputVolume, Volume) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_SetOutputVolume::Volume' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.SetPlayerMuted
// 0x0018 (0x0018 - 0x0000)
struct DeceiveIncPlayerVoiceChat_SetPlayerMuted final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAudioMuted;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_SetPlayerMuted) == 0x000008, "Wrong alignment on DeceiveIncPlayerVoiceChat_SetPlayerMuted");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_SetPlayerMuted) == 0x000018, "Wrong size on DeceiveIncPlayerVoiceChat_SetPlayerMuted");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_SetPlayerMuted, PlayerName) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_SetPlayerMuted::PlayerName' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_SetPlayerMuted, bAudioMuted) == 0x000010, "Member 'DeceiveIncPlayerVoiceChat_SetPlayerMuted::bAudioMuted' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.SetPlayerVolume
// 0x0018 (0x0018 - 0x0000)
struct DeceiveIncPlayerVoiceChat_SetPlayerVolume final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_SetPlayerVolume) == 0x000008, "Wrong alignment on DeceiveIncPlayerVoiceChat_SetPlayerVolume");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_SetPlayerVolume) == 0x000018, "Wrong size on DeceiveIncPlayerVoiceChat_SetPlayerVolume");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_SetPlayerVolume, PlayerName) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_SetPlayerVolume::PlayerName' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_SetPlayerVolume, Volume) == 0x000010, "Member 'DeceiveIncPlayerVoiceChat_SetPlayerVolume::Volume' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.SetTransmitMode
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerVoiceChat_SetTransmitMode final
{
public:
	EPlayerVoiceChatTransmitMode                  TransmitMode;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_SetTransmitMode) == 0x000001, "Wrong alignment on DeceiveIncPlayerVoiceChat_SetTransmitMode");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_SetTransmitMode) == 0x000001, "Wrong size on DeceiveIncPlayerVoiceChat_SetTransmitMode");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_SetTransmitMode, TransmitMode) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_SetTransmitMode::TransmitMode' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.GetInputMuted
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerVoiceChat_GetInputMuted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_GetInputMuted) == 0x000001, "Wrong alignment on DeceiveIncPlayerVoiceChat_GetInputMuted");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_GetInputMuted) == 0x000001, "Wrong size on DeceiveIncPlayerVoiceChat_GetInputMuted");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_GetInputMuted, ReturnValue) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_GetInputMuted::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.GetInputVolume
// 0x0004 (0x0004 - 0x0000)
struct DeceiveIncPlayerVoiceChat_GetInputVolume final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_GetInputVolume) == 0x000004, "Wrong alignment on DeceiveIncPlayerVoiceChat_GetInputVolume");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_GetInputVolume) == 0x000004, "Wrong size on DeceiveIncPlayerVoiceChat_GetInputVolume");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_GetInputVolume, ReturnValue) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_GetInputVolume::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.GetJoinedChannels
// 0x0010 (0x0010 - 0x0000)
struct DeceiveIncPlayerVoiceChat_GetJoinedChannels final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_GetJoinedChannels) == 0x000008, "Wrong alignment on DeceiveIncPlayerVoiceChat_GetJoinedChannels");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_GetJoinedChannels) == 0x000010, "Wrong size on DeceiveIncPlayerVoiceChat_GetJoinedChannels");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_GetJoinedChannels, ReturnValue) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_GetJoinedChannels::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.GetLocalVoiceActivationThreshold
// 0x0004 (0x0004 - 0x0000)
struct DeceiveIncPlayerVoiceChat_GetLocalVoiceActivationThreshold final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_GetLocalVoiceActivationThreshold) == 0x000004, "Wrong alignment on DeceiveIncPlayerVoiceChat_GetLocalVoiceActivationThreshold");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_GetLocalVoiceActivationThreshold) == 0x000004, "Wrong size on DeceiveIncPlayerVoiceChat_GetLocalVoiceActivationThreshold");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_GetLocalVoiceActivationThreshold, ReturnValue) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_GetLocalVoiceActivationThreshold::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.GetLoggedInPlayerName
// 0x0010 (0x0010 - 0x0000)
struct DeceiveIncPlayerVoiceChat_GetLoggedInPlayerName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_GetLoggedInPlayerName) == 0x000008, "Wrong alignment on DeceiveIncPlayerVoiceChat_GetLoggedInPlayerName");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_GetLoggedInPlayerName) == 0x000010, "Wrong size on DeceiveIncPlayerVoiceChat_GetLoggedInPlayerName");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_GetLoggedInPlayerName, ReturnValue) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_GetLoggedInPlayerName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.GetOutputMuted
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerVoiceChat_GetOutputMuted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_GetOutputMuted) == 0x000001, "Wrong alignment on DeceiveIncPlayerVoiceChat_GetOutputMuted");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_GetOutputMuted) == 0x000001, "Wrong size on DeceiveIncPlayerVoiceChat_GetOutputMuted");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_GetOutputMuted, ReturnValue) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_GetOutputMuted::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.GetOutputVolume
// 0x0004 (0x0004 - 0x0000)
struct DeceiveIncPlayerVoiceChat_GetOutputVolume final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_GetOutputVolume) == 0x000004, "Wrong alignment on DeceiveIncPlayerVoiceChat_GetOutputVolume");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_GetOutputVolume) == 0x000004, "Wrong size on DeceiveIncPlayerVoiceChat_GetOutputVolume");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_GetOutputVolume, ReturnValue) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_GetOutputVolume::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.GetPlayersInChannel
// 0x0020 (0x0020 - 0x0000)
struct DeceiveIncPlayerVoiceChat_GetPlayersInChannel final
{
public:
	class FString                                 ChannelName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_GetPlayersInChannel) == 0x000008, "Wrong alignment on DeceiveIncPlayerVoiceChat_GetPlayersInChannel");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_GetPlayersInChannel) == 0x000020, "Wrong size on DeceiveIncPlayerVoiceChat_GetPlayersInChannel");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_GetPlayersInChannel, ChannelName) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_GetPlayersInChannel::ChannelName' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_GetPlayersInChannel, ReturnValue) == 0x000010, "Member 'DeceiveIncPlayerVoiceChat_GetPlayersInChannel::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.GetPlayerVolume
// 0x0018 (0x0018 - 0x0000)
struct DeceiveIncPlayerVoiceChat_GetPlayerVolume final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_GetPlayerVolume) == 0x000008, "Wrong alignment on DeceiveIncPlayerVoiceChat_GetPlayerVolume");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_GetPlayerVolume) == 0x000018, "Wrong size on DeceiveIncPlayerVoiceChat_GetPlayerVolume");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_GetPlayerVolume, PlayerName) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_GetPlayerVolume::PlayerName' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_GetPlayerVolume, ReturnValue) == 0x000010, "Member 'DeceiveIncPlayerVoiceChat_GetPlayerVolume::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.GetTransmitMode
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerVoiceChat_GetTransmitMode final
{
public:
	EPlayerVoiceChatTransmitMode                  ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_GetTransmitMode) == 0x000001, "Wrong alignment on DeceiveIncPlayerVoiceChat_GetTransmitMode");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_GetTransmitMode) == 0x000001, "Wrong size on DeceiveIncPlayerVoiceChat_GetTransmitMode");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_GetTransmitMode, ReturnValue) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_GetTransmitMode::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.IsLocalPlayerTalking
// 0x0001 (0x0001 - 0x0000)
struct DeceiveIncPlayerVoiceChat_IsLocalPlayerTalking final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_IsLocalPlayerTalking) == 0x000001, "Wrong alignment on DeceiveIncPlayerVoiceChat_IsLocalPlayerTalking");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_IsLocalPlayerTalking) == 0x000001, "Wrong size on DeceiveIncPlayerVoiceChat_IsLocalPlayerTalking");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_IsLocalPlayerTalking, ReturnValue) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_IsLocalPlayerTalking::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.IsPlayerMuted
// 0x0018 (0x0018 - 0x0000)
struct DeceiveIncPlayerVoiceChat_IsPlayerMuted final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_IsPlayerMuted) == 0x000008, "Wrong alignment on DeceiveIncPlayerVoiceChat_IsPlayerMuted");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_IsPlayerMuted) == 0x000018, "Wrong size on DeceiveIncPlayerVoiceChat_IsPlayerMuted");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_IsPlayerMuted, PlayerName) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_IsPlayerMuted::PlayerName' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_IsPlayerMuted, ReturnValue) == 0x000010, "Member 'DeceiveIncPlayerVoiceChat_IsPlayerMuted::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeceiveIncPlayerVoiceChat.IsPlayerTalking
// 0x0018 (0x0018 - 0x0000)
struct DeceiveIncPlayerVoiceChat_IsPlayerTalking final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DeceiveIncPlayerVoiceChat_IsPlayerTalking) == 0x000008, "Wrong alignment on DeceiveIncPlayerVoiceChat_IsPlayerTalking");
static_assert(sizeof(DeceiveIncPlayerVoiceChat_IsPlayerTalking) == 0x000018, "Wrong size on DeceiveIncPlayerVoiceChat_IsPlayerTalking");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_IsPlayerTalking, PlayerName) == 0x000000, "Member 'DeceiveIncPlayerVoiceChat_IsPlayerTalking::PlayerName' has a wrong offset!");
static_assert(offsetof(DeceiveIncPlayerVoiceChat_IsPlayerTalking, ReturnValue) == 0x000010, "Member 'DeceiveIncPlayerVoiceChat_IsPlayerTalking::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeployedShieldbrella.BP_OnShieldActivate
// 0x0001 (0x0001 - 0x0000)
struct DeployedShieldbrella_BP_OnShieldActivate final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeployedShieldbrella_BP_OnShieldActivate) == 0x000001, "Wrong alignment on DeployedShieldbrella_BP_OnShieldActivate");
static_assert(sizeof(DeployedShieldbrella_BP_OnShieldActivate) == 0x000001, "Wrong size on DeployedShieldbrella_BP_OnShieldActivate");
static_assert(offsetof(DeployedShieldbrella_BP_OnShieldActivate, bActive) == 0x000000, "Member 'DeployedShieldbrella_BP_OnShieldActivate::bActive' has a wrong offset!");

// Function DeceiveInc.DeployedShieldbrella.IsShieldActive
// 0x0001 (0x0001 - 0x0000)
struct DeployedShieldbrella_IsShieldActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeployedShieldbrella_IsShieldActive) == 0x000001, "Wrong alignment on DeployedShieldbrella_IsShieldActive");
static_assert(sizeof(DeployedShieldbrella_IsShieldActive) == 0x000001, "Wrong size on DeployedShieldbrella_IsShieldActive");
static_assert(offsetof(DeployedShieldbrella_IsShieldActive, ReturnValue) == 0x000000, "Member 'DeployedShieldbrella_IsShieldActive::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DeployedShieldbrella.NetMulticast_EnableShield
// 0x0001 (0x0001 - 0x0000)
struct DeployedShieldbrella_NetMulticast_EnableShield final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeployedShieldbrella_NetMulticast_EnableShield) == 0x000001, "Wrong alignment on DeployedShieldbrella_NetMulticast_EnableShield");
static_assert(sizeof(DeployedShieldbrella_NetMulticast_EnableShield) == 0x000001, "Wrong size on DeployedShieldbrella_NetMulticast_EnableShield");
static_assert(offsetof(DeployedShieldbrella_NetMulticast_EnableShield, bEnable) == 0x000000, "Member 'DeployedShieldbrella_NetMulticast_EnableShield::bEnable' has a wrong offset!");

// Function DeceiveInc.DeployedShieldbrella.OnEMPIsAffectedChanged
// 0x0010 (0x0010 - 0x0000)
struct DeployedShieldbrella_OnEMPIsAffectedChanged final
{
public:
	bool                                          bIsAffected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AffectedActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeployedShieldbrella_OnEMPIsAffectedChanged) == 0x000008, "Wrong alignment on DeployedShieldbrella_OnEMPIsAffectedChanged");
static_assert(sizeof(DeployedShieldbrella_OnEMPIsAffectedChanged) == 0x000010, "Wrong size on DeployedShieldbrella_OnEMPIsAffectedChanged");
static_assert(offsetof(DeployedShieldbrella_OnEMPIsAffectedChanged, bIsAffected) == 0x000000, "Member 'DeployedShieldbrella_OnEMPIsAffectedChanged::bIsAffected' has a wrong offset!");
static_assert(offsetof(DeployedShieldbrella_OnEMPIsAffectedChanged, AffectedActor) == 0x000008, "Member 'DeployedShieldbrella_OnEMPIsAffectedChanged::AffectedActor' has a wrong offset!");

// Function DeceiveInc.DeployedShieldbrella.OnScramblerIsAffectedChanged
// 0x0010 (0x0010 - 0x0000)
struct DeployedShieldbrella_OnScramblerIsAffectedChanged final
{
public:
	bool                                          bIsAffected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AffectedActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeployedShieldbrella_OnScramblerIsAffectedChanged) == 0x000008, "Wrong alignment on DeployedShieldbrella_OnScramblerIsAffectedChanged");
static_assert(sizeof(DeployedShieldbrella_OnScramblerIsAffectedChanged) == 0x000010, "Wrong size on DeployedShieldbrella_OnScramblerIsAffectedChanged");
static_assert(offsetof(DeployedShieldbrella_OnScramblerIsAffectedChanged, bIsAffected) == 0x000000, "Member 'DeployedShieldbrella_OnScramblerIsAffectedChanged::bIsAffected' has a wrong offset!");
static_assert(offsetof(DeployedShieldbrella_OnScramblerIsAffectedChanged, AffectedActor) == 0x000008, "Member 'DeployedShieldbrella_OnScramblerIsAffectedChanged::AffectedActor' has a wrong offset!");

// Function DeceiveInc.DeployedShieldbrella.Server_EnableShield
// 0x0001 (0x0001 - 0x0000)
struct DeployedShieldbrella_Server_EnableShield final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeployedShieldbrella_Server_EnableShield) == 0x000001, "Wrong alignment on DeployedShieldbrella_Server_EnableShield");
static_assert(sizeof(DeployedShieldbrella_Server_EnableShield) == 0x000001, "Wrong size on DeployedShieldbrella_Server_EnableShield");
static_assert(offsetof(DeployedShieldbrella_Server_EnableShield, bEnable) == 0x000000, "Member 'DeployedShieldbrella_Server_EnableShield::bEnable' has a wrong offset!");

// Function DeceiveInc.DIAllowedGameModesHandler.GetAllowedGameModes
// 0x0002 (0x0002 - 0x0000)
struct DIAllowedGameModesHandler_GetAllowedGameModes final
{
public:
	struct FDescribeAllowedGameModesResponse      ReturnValue;                                       // 0x0000(0x0002)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIAllowedGameModesHandler_GetAllowedGameModes) == 0x000001, "Wrong alignment on DIAllowedGameModesHandler_GetAllowedGameModes");
static_assert(sizeof(DIAllowedGameModesHandler_GetAllowedGameModes) == 0x000002, "Wrong size on DIAllowedGameModesHandler_GetAllowedGameModes");
static_assert(offsetof(DIAllowedGameModesHandler_GetAllowedGameModes, ReturnValue) == 0x000000, "Member 'DIAllowedGameModesHandler_GetAllowedGameModes::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiAnimationMotionSet.GetAnimMotionAsset
// 0x0010 (0x0010 - 0x0000)
struct DiAnimationMotionSet_GetAnimMotionAsset final
{
public:
	class FName                                   MotionName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiAnimationMotionSet_GetAnimMotionAsset) == 0x000008, "Wrong alignment on DiAnimationMotionSet_GetAnimMotionAsset");
static_assert(sizeof(DiAnimationMotionSet_GetAnimMotionAsset) == 0x000010, "Wrong size on DiAnimationMotionSet_GetAnimMotionAsset");
static_assert(offsetof(DiAnimationMotionSet_GetAnimMotionAsset, MotionName) == 0x000000, "Member 'DiAnimationMotionSet_GetAnimMotionAsset::MotionName' has a wrong offset!");
static_assert(offsetof(DiAnimationMotionSet_GetAnimMotionAsset, ReturnValue) == 0x000008, "Member 'DiAnimationMotionSet_GetAnimMotionAsset::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiAnimationMotionSet.HasAnimMotion
// 0x000C (0x000C - 0x0000)
struct DiAnimationMotionSet_HasAnimMotion final
{
public:
	class FName                                   MotionName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DiAnimationMotionSet_HasAnimMotion) == 0x000004, "Wrong alignment on DiAnimationMotionSet_HasAnimMotion");
static_assert(sizeof(DiAnimationMotionSet_HasAnimMotion) == 0x00000C, "Wrong size on DiAnimationMotionSet_HasAnimMotion");
static_assert(offsetof(DiAnimationMotionSet_HasAnimMotion, MotionName) == 0x000000, "Member 'DiAnimationMotionSet_HasAnimMotion::MotionName' has a wrong offset!");
static_assert(offsetof(DiAnimationMotionSet_HasAnimMotion, ReturnValue) == 0x000008, "Member 'DiAnimationMotionSet_HasAnimMotion::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiAnimationMotionSet.TryGetAnimMotionBlendSpace
// 0x0018 (0x0018 - 0x0000)
struct DiAnimationMotionSet_TryGetAnimMotionBlendSpace final
{
public:
	class FName                                   MotionName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        Destination;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DiAnimationMotionSet_TryGetAnimMotionBlendSpace) == 0x000008, "Wrong alignment on DiAnimationMotionSet_TryGetAnimMotionBlendSpace");
static_assert(sizeof(DiAnimationMotionSet_TryGetAnimMotionBlendSpace) == 0x000018, "Wrong size on DiAnimationMotionSet_TryGetAnimMotionBlendSpace");
static_assert(offsetof(DiAnimationMotionSet_TryGetAnimMotionBlendSpace, MotionName) == 0x000000, "Member 'DiAnimationMotionSet_TryGetAnimMotionBlendSpace::MotionName' has a wrong offset!");
static_assert(offsetof(DiAnimationMotionSet_TryGetAnimMotionBlendSpace, Destination) == 0x000008, "Member 'DiAnimationMotionSet_TryGetAnimMotionBlendSpace::Destination' has a wrong offset!");
static_assert(offsetof(DiAnimationMotionSet_TryGetAnimMotionBlendSpace, ReturnValue) == 0x000010, "Member 'DiAnimationMotionSet_TryGetAnimMotionBlendSpace::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiAnimationMotionSet.TryGetAnimMotionSequence
// 0x0018 (0x0018 - 0x0000)
struct DiAnimationMotionSet_TryGetAnimMotionSequence final
{
public:
	class FName                                   MotionName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Destination;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DiAnimationMotionSet_TryGetAnimMotionSequence) == 0x000008, "Wrong alignment on DiAnimationMotionSet_TryGetAnimMotionSequence");
static_assert(sizeof(DiAnimationMotionSet_TryGetAnimMotionSequence) == 0x000018, "Wrong size on DiAnimationMotionSet_TryGetAnimMotionSequence");
static_assert(offsetof(DiAnimationMotionSet_TryGetAnimMotionSequence, MotionName) == 0x000000, "Member 'DiAnimationMotionSet_TryGetAnimMotionSequence::MotionName' has a wrong offset!");
static_assert(offsetof(DiAnimationMotionSet_TryGetAnimMotionSequence, Destination) == 0x000008, "Member 'DiAnimationMotionSet_TryGetAnimMotionSequence::Destination' has a wrong offset!");
static_assert(offsetof(DiAnimationMotionSet_TryGetAnimMotionSequence, ReturnValue) == 0x000010, "Member 'DiAnimationMotionSet_TryGetAnimMotionSequence::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIAssetManager.GetLimitedEventItemsDataAsset
// 0x0008 (0x0008 - 0x0000)
struct DIAssetManager_GetLimitedEventItemsDataAsset final
{
public:
	class ULimitedEventItemsDataAsset*            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIAssetManager_GetLimitedEventItemsDataAsset) == 0x000008, "Wrong alignment on DIAssetManager_GetLimitedEventItemsDataAsset");
static_assert(sizeof(DIAssetManager_GetLimitedEventItemsDataAsset) == 0x000008, "Wrong size on DIAssetManager_GetLimitedEventItemsDataAsset");
static_assert(offsetof(DIAssetManager_GetLimitedEventItemsDataAsset, ReturnValue) == 0x000000, "Member 'DIAssetManager_GetLimitedEventItemsDataAsset::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIAssetManager.GetLimitedEventProgression
// 0x0008 (0x0008 - 0x0000)
struct DIAssetManager_GetLimitedEventProgression final
{
public:
	class ULimitedEventXpProgressionData*         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIAssetManager_GetLimitedEventProgression) == 0x000008, "Wrong alignment on DIAssetManager_GetLimitedEventProgression");
static_assert(sizeof(DIAssetManager_GetLimitedEventProgression) == 0x000008, "Wrong size on DIAssetManager_GetLimitedEventProgression");
static_assert(offsetof(DIAssetManager_GetLimitedEventProgression, ReturnValue) == 0x000000, "Member 'DIAssetManager_GetLimitedEventProgression::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIAssetManager.GetPingSystemDataAsset
// 0x0008 (0x0008 - 0x0000)
struct DIAssetManager_GetPingSystemDataAsset final
{
public:
	class UPingSystemDataAsset*                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIAssetManager_GetPingSystemDataAsset) == 0x000008, "Wrong alignment on DIAssetManager_GetPingSystemDataAsset");
static_assert(sizeof(DIAssetManager_GetPingSystemDataAsset) == 0x000008, "Wrong size on DIAssetManager_GetPingSystemDataAsset");
static_assert(offsetof(DIAssetManager_GetPingSystemDataAsset, ReturnValue) == 0x000000, "Member 'DIAssetManager_GetPingSystemDataAsset::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIAssetManager.GetProgressionRewardByXpType
// 0x0018 (0x0018 - 0x0000)
struct DIAssetManager_GetProgressionRewardByXpType final
{
public:
	class FString                                 XpType;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProgressionRewardData*                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIAssetManager_GetProgressionRewardByXpType) == 0x000008, "Wrong alignment on DIAssetManager_GetProgressionRewardByXpType");
static_assert(sizeof(DIAssetManager_GetProgressionRewardByXpType) == 0x000018, "Wrong size on DIAssetManager_GetProgressionRewardByXpType");
static_assert(offsetof(DIAssetManager_GetProgressionRewardByXpType, XpType) == 0x000000, "Member 'DIAssetManager_GetProgressionRewardByXpType::XpType' has a wrong offset!");
static_assert(offsetof(DIAssetManager_GetProgressionRewardByXpType, ReturnValue) == 0x000010, "Member 'DIAssetManager_GetProgressionRewardByXpType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIAssetManager.HandleActorEndPlay
// 0x0010 (0x0010 - 0x0000)
struct DIAssetManager_HandleActorEndPlay final
{
public:
	class AActor*                                 EndingActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndPlayReason                                EndPlayReason;                                     // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIAssetManager_HandleActorEndPlay) == 0x000008, "Wrong alignment on DIAssetManager_HandleActorEndPlay");
static_assert(sizeof(DIAssetManager_HandleActorEndPlay) == 0x000010, "Wrong size on DIAssetManager_HandleActorEndPlay");
static_assert(offsetof(DIAssetManager_HandleActorEndPlay, EndingActor) == 0x000000, "Member 'DIAssetManager_HandleActorEndPlay::EndingActor' has a wrong offset!");
static_assert(offsetof(DIAssetManager_HandleActorEndPlay, EndPlayReason) == 0x000008, "Member 'DIAssetManager_HandleActorEndPlay::EndPlayReason' has a wrong offset!");

// Function DeceiveInc.DIAssetManager.NecessaryAssetLoadCompleted
// 0x0001 (0x0001 - 0x0000)
struct DIAssetManager_NecessaryAssetLoadCompleted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIAssetManager_NecessaryAssetLoadCompleted) == 0x000001, "Wrong alignment on DIAssetManager_NecessaryAssetLoadCompleted");
static_assert(sizeof(DIAssetManager_NecessaryAssetLoadCompleted) == 0x000001, "Wrong size on DIAssetManager_NecessaryAssetLoadCompleted");
static_assert(offsetof(DIAssetManager_NecessaryAssetLoadCompleted, ReturnValue) == 0x000000, "Member 'DIAssetManager_NecessaryAssetLoadCompleted::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DICameraSubsystem.GetCameraLense
// 0x0010 (0x0010 - 0x0000)
struct DICameraSubsystem_GetCameraLense final
{
public:
	const class UWorld*                           WorldIn;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADICameraLense*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DICameraSubsystem_GetCameraLense) == 0x000008, "Wrong alignment on DICameraSubsystem_GetCameraLense");
static_assert(sizeof(DICameraSubsystem_GetCameraLense) == 0x000010, "Wrong size on DICameraSubsystem_GetCameraLense");
static_assert(offsetof(DICameraSubsystem_GetCameraLense, WorldIn) == 0x000000, "Member 'DICameraSubsystem_GetCameraLense::WorldIn' has a wrong offset!");
static_assert(offsetof(DICameraSubsystem_GetCameraLense, ReturnValue) == 0x000008, "Member 'DICameraSubsystem_GetCameraLense::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DICameraSubsystem.SB_RegisterCamera
// 0x0018 (0x0018 - 0x0000)
struct DICameraSubsystem_SB_RegisterCamera final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                CameraRefIn;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraPriority                               PriorityIn;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DICameraSubsystem_SB_RegisterCamera) == 0x000008, "Wrong alignment on DICameraSubsystem_SB_RegisterCamera");
static_assert(sizeof(DICameraSubsystem_SB_RegisterCamera) == 0x000018, "Wrong size on DICameraSubsystem_SB_RegisterCamera");
static_assert(offsetof(DICameraSubsystem_SB_RegisterCamera, WorldContextObject) == 0x000000, "Member 'DICameraSubsystem_SB_RegisterCamera::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DICameraSubsystem_SB_RegisterCamera, CameraRefIn) == 0x000008, "Member 'DICameraSubsystem_SB_RegisterCamera::CameraRefIn' has a wrong offset!");
static_assert(offsetof(DICameraSubsystem_SB_RegisterCamera, PriorityIn) == 0x000010, "Member 'DICameraSubsystem_SB_RegisterCamera::PriorityIn' has a wrong offset!");

// Function DeceiveInc.DICameraSubsystem.SB_RegisterCameraWithTransition
// 0x0020 (0x0020 - 0x0000)
struct DICameraSubsystem_SB_RegisterCameraWithTransition final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                CameraRefIn;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraPriority                               PriorityIn;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TransitionDuration;                                // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationExp;                                  // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DICameraSubsystem_SB_RegisterCameraWithTransition) == 0x000008, "Wrong alignment on DICameraSubsystem_SB_RegisterCameraWithTransition");
static_assert(sizeof(DICameraSubsystem_SB_RegisterCameraWithTransition) == 0x000020, "Wrong size on DICameraSubsystem_SB_RegisterCameraWithTransition");
static_assert(offsetof(DICameraSubsystem_SB_RegisterCameraWithTransition, WorldContextObject) == 0x000000, "Member 'DICameraSubsystem_SB_RegisterCameraWithTransition::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DICameraSubsystem_SB_RegisterCameraWithTransition, CameraRefIn) == 0x000008, "Member 'DICameraSubsystem_SB_RegisterCameraWithTransition::CameraRefIn' has a wrong offset!");
static_assert(offsetof(DICameraSubsystem_SB_RegisterCameraWithTransition, PriorityIn) == 0x000010, "Member 'DICameraSubsystem_SB_RegisterCameraWithTransition::PriorityIn' has a wrong offset!");
static_assert(offsetof(DICameraSubsystem_SB_RegisterCameraWithTransition, TransitionDuration) == 0x000014, "Member 'DICameraSubsystem_SB_RegisterCameraWithTransition::TransitionDuration' has a wrong offset!");
static_assert(offsetof(DICameraSubsystem_SB_RegisterCameraWithTransition, InterpolationExp) == 0x000018, "Member 'DICameraSubsystem_SB_RegisterCameraWithTransition::InterpolationExp' has a wrong offset!");

// Function DeceiveInc.DICameraSubsystem.SB_UnregisterCamera
// 0x0018 (0x0018 - 0x0000)
struct DICameraSubsystem_SB_UnregisterCamera final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                CameraRefIn;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraPriority                               PriorityIn;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DICameraSubsystem_SB_UnregisterCamera) == 0x000008, "Wrong alignment on DICameraSubsystem_SB_UnregisterCamera");
static_assert(sizeof(DICameraSubsystem_SB_UnregisterCamera) == 0x000018, "Wrong size on DICameraSubsystem_SB_UnregisterCamera");
static_assert(offsetof(DICameraSubsystem_SB_UnregisterCamera, WorldContextObject) == 0x000000, "Member 'DICameraSubsystem_SB_UnregisterCamera::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DICameraSubsystem_SB_UnregisterCamera, CameraRefIn) == 0x000008, "Member 'DICameraSubsystem_SB_UnregisterCamera::CameraRefIn' has a wrong offset!");
static_assert(offsetof(DICameraSubsystem_SB_UnregisterCamera, PriorityIn) == 0x000010, "Member 'DICameraSubsystem_SB_UnregisterCamera::PriorityIn' has a wrong offset!");

// Function DeceiveInc.DICameraSubsystem.SB_UnregisterCameraWithTransition
// 0x0020 (0x0020 - 0x0000)
struct DICameraSubsystem_SB_UnregisterCameraWithTransition final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                CameraRefIn;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraPriority                               PriorityIn;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TransitionDuration;                                // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationExp;                                  // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DICameraSubsystem_SB_UnregisterCameraWithTransition) == 0x000008, "Wrong alignment on DICameraSubsystem_SB_UnregisterCameraWithTransition");
static_assert(sizeof(DICameraSubsystem_SB_UnregisterCameraWithTransition) == 0x000020, "Wrong size on DICameraSubsystem_SB_UnregisterCameraWithTransition");
static_assert(offsetof(DICameraSubsystem_SB_UnregisterCameraWithTransition, WorldContextObject) == 0x000000, "Member 'DICameraSubsystem_SB_UnregisterCameraWithTransition::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DICameraSubsystem_SB_UnregisterCameraWithTransition, CameraRefIn) == 0x000008, "Member 'DICameraSubsystem_SB_UnregisterCameraWithTransition::CameraRefIn' has a wrong offset!");
static_assert(offsetof(DICameraSubsystem_SB_UnregisterCameraWithTransition, PriorityIn) == 0x000010, "Member 'DICameraSubsystem_SB_UnregisterCameraWithTransition::PriorityIn' has a wrong offset!");
static_assert(offsetof(DICameraSubsystem_SB_UnregisterCameraWithTransition, TransitionDuration) == 0x000014, "Member 'DICameraSubsystem_SB_UnregisterCameraWithTransition::TransitionDuration' has a wrong offset!");
static_assert(offsetof(DICameraSubsystem_SB_UnregisterCameraWithTransition, InterpolationExp) == 0x000018, "Member 'DICameraSubsystem_SB_UnregisterCameraWithTransition::InterpolationExp' has a wrong offset!");

// DelegateFunction DeceiveInc.DICameraSubsystem.OnCameraChangeEvent__DelegateSignature
// 0x0010 (0x0010 - 0x0000)
struct DICameraSubsystem_OnCameraChangeEvent__DelegateSignature final
{
public:
	class UObject*                                NewActiveCamera;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraPriority                               NewCameraPriority;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DICameraSubsystem_OnCameraChangeEvent__DelegateSignature) == 0x000008, "Wrong alignment on DICameraSubsystem_OnCameraChangeEvent__DelegateSignature");
static_assert(sizeof(DICameraSubsystem_OnCameraChangeEvent__DelegateSignature) == 0x000010, "Wrong size on DICameraSubsystem_OnCameraChangeEvent__DelegateSignature");
static_assert(offsetof(DICameraSubsystem_OnCameraChangeEvent__DelegateSignature, NewActiveCamera) == 0x000000, "Member 'DICameraSubsystem_OnCameraChangeEvent__DelegateSignature::NewActiveCamera' has a wrong offset!");
static_assert(offsetof(DICameraSubsystem_OnCameraChangeEvent__DelegateSignature, NewCameraPriority) == 0x000008, "Member 'DICameraSubsystem_OnCameraChangeEvent__DelegateSignature::NewCameraPriority' has a wrong offset!");

// Function DeceiveInc.DiCharacterAnimInstance.TryGetCharacterOwner
// 0x0008 (0x0008 - 0x0000)
struct DiCharacterAnimInstance_TryGetCharacterOwner final
{
public:
	class ACharacter*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiCharacterAnimInstance_TryGetCharacterOwner) == 0x000008, "Wrong alignment on DiCharacterAnimInstance_TryGetCharacterOwner");
static_assert(sizeof(DiCharacterAnimInstance_TryGetCharacterOwner) == 0x000008, "Wrong size on DiCharacterAnimInstance_TryGetCharacterOwner");
static_assert(offsetof(DiCharacterAnimInstance_TryGetCharacterOwner, ReturnValue) == 0x000000, "Member 'DiCharacterAnimInstance_TryGetCharacterOwner::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DICharacterMovementComponent.AddImpulse
// 0x0010 (0x0010 - 0x0000)
struct DICharacterMovementComponent_AddImpulse final
{
public:
	struct FVector                                Impulse;                                           // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVelocityChange;                                   // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DICharacterMovementComponent_AddImpulse) == 0x000004, "Wrong alignment on DICharacterMovementComponent_AddImpulse");
static_assert(sizeof(DICharacterMovementComponent_AddImpulse) == 0x000010, "Wrong size on DICharacterMovementComponent_AddImpulse");
static_assert(offsetof(DICharacterMovementComponent_AddImpulse, Impulse) == 0x000000, "Member 'DICharacterMovementComponent_AddImpulse::Impulse' has a wrong offset!");
static_assert(offsetof(DICharacterMovementComponent_AddImpulse, bVelocityChange) == 0x00000C, "Member 'DICharacterMovementComponent_AddImpulse::bVelocityChange' has a wrong offset!");

// Function DeceiveInc.DICharacterMovementComponent.AddSlowSource
// 0x0010 (0x0010 - 0x0000)
struct DICharacterMovementComponent_AddSlowSource final
{
public:
	class AActor*                                 NewSlowSource;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewSlowPercent;                                    // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DICharacterMovementComponent_AddSlowSource) == 0x000008, "Wrong alignment on DICharacterMovementComponent_AddSlowSource");
static_assert(sizeof(DICharacterMovementComponent_AddSlowSource) == 0x000010, "Wrong size on DICharacterMovementComponent_AddSlowSource");
static_assert(offsetof(DICharacterMovementComponent_AddSlowSource, NewSlowSource) == 0x000000, "Member 'DICharacterMovementComponent_AddSlowSource::NewSlowSource' has a wrong offset!");
static_assert(offsetof(DICharacterMovementComponent_AddSlowSource, NewSlowPercent) == 0x000008, "Member 'DICharacterMovementComponent_AddSlowSource::NewSlowPercent' has a wrong offset!");

// Function DeceiveInc.DICharacterMovementComponent.CalcVelocity
// 0x0010 (0x0010 - 0x0000)
struct DICharacterMovementComponent_CalcVelocity final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Friction;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFluid;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BrakingDeceleration;                               // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DICharacterMovementComponent_CalcVelocity) == 0x000004, "Wrong alignment on DICharacterMovementComponent_CalcVelocity");
static_assert(sizeof(DICharacterMovementComponent_CalcVelocity) == 0x000010, "Wrong size on DICharacterMovementComponent_CalcVelocity");
static_assert(offsetof(DICharacterMovementComponent_CalcVelocity, DeltaTime) == 0x000000, "Member 'DICharacterMovementComponent_CalcVelocity::DeltaTime' has a wrong offset!");
static_assert(offsetof(DICharacterMovementComponent_CalcVelocity, Friction) == 0x000004, "Member 'DICharacterMovementComponent_CalcVelocity::Friction' has a wrong offset!");
static_assert(offsetof(DICharacterMovementComponent_CalcVelocity, bFluid) == 0x000008, "Member 'DICharacterMovementComponent_CalcVelocity::bFluid' has a wrong offset!");
static_assert(offsetof(DICharacterMovementComponent_CalcVelocity, BrakingDeceleration) == 0x00000C, "Member 'DICharacterMovementComponent_CalcVelocity::BrakingDeceleration' has a wrong offset!");

// Function DeceiveInc.DICharacterMovementComponent.CapsuleTouched
// 0x00A8 (0x00A8 - 0x0000)
struct DICharacterMovementComponent_CapsuleTouched final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DICharacterMovementComponent_CapsuleTouched) == 0x000008, "Wrong alignment on DICharacterMovementComponent_CapsuleTouched");
static_assert(sizeof(DICharacterMovementComponent_CapsuleTouched) == 0x0000A8, "Wrong size on DICharacterMovementComponent_CapsuleTouched");
static_assert(offsetof(DICharacterMovementComponent_CapsuleTouched, OverlappedComp) == 0x000000, "Member 'DICharacterMovementComponent_CapsuleTouched::OverlappedComp' has a wrong offset!");
static_assert(offsetof(DICharacterMovementComponent_CapsuleTouched, Other) == 0x000008, "Member 'DICharacterMovementComponent_CapsuleTouched::Other' has a wrong offset!");
static_assert(offsetof(DICharacterMovementComponent_CapsuleTouched, OtherComp) == 0x000010, "Member 'DICharacterMovementComponent_CapsuleTouched::OtherComp' has a wrong offset!");
static_assert(offsetof(DICharacterMovementComponent_CapsuleTouched, OtherBodyIndex) == 0x000018, "Member 'DICharacterMovementComponent_CapsuleTouched::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(DICharacterMovementComponent_CapsuleTouched, bFromSweep) == 0x00001C, "Member 'DICharacterMovementComponent_CapsuleTouched::bFromSweep' has a wrong offset!");
static_assert(offsetof(DICharacterMovementComponent_CapsuleTouched, SweepResult) == 0x000020, "Member 'DICharacterMovementComponent_CapsuleTouched::SweepResult' has a wrong offset!");

// Function DeceiveInc.DICharacterMovementComponent.RemoveSlowSource
// 0x0008 (0x0008 - 0x0000)
struct DICharacterMovementComponent_RemoveSlowSource final
{
public:
	class AActor*                                 SlowSourceToRemove;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DICharacterMovementComponent_RemoveSlowSource) == 0x000008, "Wrong alignment on DICharacterMovementComponent_RemoveSlowSource");
static_assert(sizeof(DICharacterMovementComponent_RemoveSlowSource) == 0x000008, "Wrong size on DICharacterMovementComponent_RemoveSlowSource");
static_assert(offsetof(DICharacterMovementComponent_RemoveSlowSource, SlowSourceToRemove) == 0x000000, "Member 'DICharacterMovementComponent_RemoveSlowSource::SlowSourceToRemove' has a wrong offset!");

// Function DeceiveInc.DICharacterMovementComponent.SetWalkableFloorAngle
// 0x0004 (0x0004 - 0x0000)
struct DICharacterMovementComponent_SetWalkableFloorAngle final
{
public:
	float                                         InWalkableFloorAngle;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DICharacterMovementComponent_SetWalkableFloorAngle) == 0x000004, "Wrong alignment on DICharacterMovementComponent_SetWalkableFloorAngle");
static_assert(sizeof(DICharacterMovementComponent_SetWalkableFloorAngle) == 0x000004, "Wrong size on DICharacterMovementComponent_SetWalkableFloorAngle");
static_assert(offsetof(DICharacterMovementComponent_SetWalkableFloorAngle, InWalkableFloorAngle) == 0x000000, "Member 'DICharacterMovementComponent_SetWalkableFloorAngle::InWalkableFloorAngle' has a wrong offset!");

// Function DeceiveInc.DICharacterMovementComponent.SetWalkableFloorZ
// 0x0004 (0x0004 - 0x0000)
struct DICharacterMovementComponent_SetWalkableFloorZ final
{
public:
	float                                         InWalkableFloorZ;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DICharacterMovementComponent_SetWalkableFloorZ) == 0x000004, "Wrong alignment on DICharacterMovementComponent_SetWalkableFloorZ");
static_assert(sizeof(DICharacterMovementComponent_SetWalkableFloorZ) == 0x000004, "Wrong size on DICharacterMovementComponent_SetWalkableFloorZ");
static_assert(offsetof(DICharacterMovementComponent_SetWalkableFloorZ, InWalkableFloorZ) == 0x000000, "Member 'DICharacterMovementComponent_SetWalkableFloorZ::InWalkableFloorZ' has a wrong offset!");

// Function DeceiveInc.DICharacterMovementComponent.GetImpartedMovementBaseVelocity
// 0x000C (0x000C - 0x0000)
struct DICharacterMovementComponent_GetImpartedMovementBaseVelocity final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DICharacterMovementComponent_GetImpartedMovementBaseVelocity) == 0x000004, "Wrong alignment on DICharacterMovementComponent_GetImpartedMovementBaseVelocity");
static_assert(sizeof(DICharacterMovementComponent_GetImpartedMovementBaseVelocity) == 0x00000C, "Wrong size on DICharacterMovementComponent_GetImpartedMovementBaseVelocity");
static_assert(offsetof(DICharacterMovementComponent_GetImpartedMovementBaseVelocity, ReturnValue) == 0x000000, "Member 'DICharacterMovementComponent_GetImpartedMovementBaseVelocity::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DICharacterMovementComponent.GetMaxAcceleration
// 0x0004 (0x0004 - 0x0000)
struct DICharacterMovementComponent_GetMaxAcceleration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DICharacterMovementComponent_GetMaxAcceleration) == 0x000004, "Wrong alignment on DICharacterMovementComponent_GetMaxAcceleration");
static_assert(sizeof(DICharacterMovementComponent_GetMaxAcceleration) == 0x000004, "Wrong size on DICharacterMovementComponent_GetMaxAcceleration");
static_assert(offsetof(DICharacterMovementComponent_GetMaxAcceleration, ReturnValue) == 0x000000, "Member 'DICharacterMovementComponent_GetMaxAcceleration::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DICharacterMovementComponent.GetMaxBrakingDeceleration
// 0x0004 (0x0004 - 0x0000)
struct DICharacterMovementComponent_GetMaxBrakingDeceleration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DICharacterMovementComponent_GetMaxBrakingDeceleration) == 0x000004, "Wrong alignment on DICharacterMovementComponent_GetMaxBrakingDeceleration");
static_assert(sizeof(DICharacterMovementComponent_GetMaxBrakingDeceleration) == 0x000004, "Wrong size on DICharacterMovementComponent_GetMaxBrakingDeceleration");
static_assert(offsetof(DICharacterMovementComponent_GetMaxBrakingDeceleration, ReturnValue) == 0x000000, "Member 'DICharacterMovementComponent_GetMaxBrakingDeceleration::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DICharacterMovementComponent.GetPerchRadiusThreshold
// 0x0004 (0x0004 - 0x0000)
struct DICharacterMovementComponent_GetPerchRadiusThreshold final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DICharacterMovementComponent_GetPerchRadiusThreshold) == 0x000004, "Wrong alignment on DICharacterMovementComponent_GetPerchRadiusThreshold");
static_assert(sizeof(DICharacterMovementComponent_GetPerchRadiusThreshold) == 0x000004, "Wrong size on DICharacterMovementComponent_GetPerchRadiusThreshold");
static_assert(offsetof(DICharacterMovementComponent_GetPerchRadiusThreshold, ReturnValue) == 0x000000, "Member 'DICharacterMovementComponent_GetPerchRadiusThreshold::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DICharacterMovementComponent.GetValidPerchRadius
// 0x0004 (0x0004 - 0x0000)
struct DICharacterMovementComponent_GetValidPerchRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DICharacterMovementComponent_GetValidPerchRadius) == 0x000004, "Wrong alignment on DICharacterMovementComponent_GetValidPerchRadius");
static_assert(sizeof(DICharacterMovementComponent_GetValidPerchRadius) == 0x000004, "Wrong size on DICharacterMovementComponent_GetValidPerchRadius");
static_assert(offsetof(DICharacterMovementComponent_GetValidPerchRadius, ReturnValue) == 0x000000, "Member 'DICharacterMovementComponent_GetValidPerchRadius::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DICharacterMovementComponent.IsWalkable
// 0x008C (0x008C - 0x0000)
struct DICharacterMovementComponent_IsWalkable final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0088(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DICharacterMovementComponent_IsWalkable) == 0x000004, "Wrong alignment on DICharacterMovementComponent_IsWalkable");
static_assert(sizeof(DICharacterMovementComponent_IsWalkable) == 0x00008C, "Wrong size on DICharacterMovementComponent_IsWalkable");
static_assert(offsetof(DICharacterMovementComponent_IsWalkable, Hit) == 0x000000, "Member 'DICharacterMovementComponent_IsWalkable::Hit' has a wrong offset!");
static_assert(offsetof(DICharacterMovementComponent_IsWalkable, ReturnValue) == 0x000088, "Member 'DICharacterMovementComponent_IsWalkable::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.IsErrorStatus
// 0x0002 (0x0002 - 0x0000)
struct DIClientWebServiceSession_IsErrorStatus final
{
public:
	EDescribeMatchmakingStatus                    StatusToCheck;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_IsErrorStatus) == 0x000001, "Wrong alignment on DIClientWebServiceSession_IsErrorStatus");
static_assert(sizeof(DIClientWebServiceSession_IsErrorStatus) == 0x000002, "Wrong size on DIClientWebServiceSession_IsErrorStatus");
static_assert(offsetof(DIClientWebServiceSession_IsErrorStatus, StatusToCheck) == 0x000000, "Member 'DIClientWebServiceSession_IsErrorStatus::StatusToCheck' has a wrong offset!");
static_assert(offsetof(DIClientWebServiceSession_IsErrorStatus, ReturnValue) == 0x000001, "Member 'DIClientWebServiceSession_IsErrorStatus::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.IsSearchEndedStatus
// 0x0002 (0x0002 - 0x0000)
struct DIClientWebServiceSession_IsSearchEndedStatus final
{
public:
	EDescribeMatchmakingStatus                    StatusToCheck;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_IsSearchEndedStatus) == 0x000001, "Wrong alignment on DIClientWebServiceSession_IsSearchEndedStatus");
static_assert(sizeof(DIClientWebServiceSession_IsSearchEndedStatus) == 0x000002, "Wrong size on DIClientWebServiceSession_IsSearchEndedStatus");
static_assert(offsetof(DIClientWebServiceSession_IsSearchEndedStatus, StatusToCheck) == 0x000000, "Member 'DIClientWebServiceSession_IsSearchEndedStatus::StatusToCheck' has a wrong offset!");
static_assert(offsetof(DIClientWebServiceSession_IsSearchEndedStatus, ReturnValue) == 0x000001, "Member 'DIClientWebServiceSession_IsSearchEndedStatus::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.IsSearchingStatus
// 0x0002 (0x0002 - 0x0000)
struct DIClientWebServiceSession_IsSearchingStatus final
{
public:
	EDescribeMatchmakingStatus                    StatusToCheck;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_IsSearchingStatus) == 0x000001, "Wrong alignment on DIClientWebServiceSession_IsSearchingStatus");
static_assert(sizeof(DIClientWebServiceSession_IsSearchingStatus) == 0x000002, "Wrong size on DIClientWebServiceSession_IsSearchingStatus");
static_assert(offsetof(DIClientWebServiceSession_IsSearchingStatus, StatusToCheck) == 0x000000, "Member 'DIClientWebServiceSession_IsSearchingStatus::StatusToCheck' has a wrong offset!");
static_assert(offsetof(DIClientWebServiceSession_IsSearchingStatus, ReturnValue) == 0x000001, "Member 'DIClientWebServiceSession_IsSearchingStatus::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.BuyItem
// 0x0020 (0x0020 - 0x0000)
struct DIClientWebServiceSession_BuyItem final
{
public:
	class FString                                 ItemId;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrencyId;                                        // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_BuyItem) == 0x000008, "Wrong alignment on DIClientWebServiceSession_BuyItem");
static_assert(sizeof(DIClientWebServiceSession_BuyItem) == 0x000020, "Wrong size on DIClientWebServiceSession_BuyItem");
static_assert(offsetof(DIClientWebServiceSession_BuyItem, ItemId) == 0x000000, "Member 'DIClientWebServiceSession_BuyItem::ItemId' has a wrong offset!");
static_assert(offsetof(DIClientWebServiceSession_BuyItem, CurrencyId) == 0x000010, "Member 'DIClientWebServiceSession_BuyItem::CurrencyId' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.BuyItemNoConf
// 0x0020 (0x0020 - 0x0000)
struct DIClientWebServiceSession_BuyItemNoConf final
{
public:
	class FString                                 ItemId;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrencyId;                                        // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_BuyItemNoConf) == 0x000008, "Wrong alignment on DIClientWebServiceSession_BuyItemNoConf");
static_assert(sizeof(DIClientWebServiceSession_BuyItemNoConf) == 0x000020, "Wrong size on DIClientWebServiceSession_BuyItemNoConf");
static_assert(offsetof(DIClientWebServiceSession_BuyItemNoConf, ItemId) == 0x000000, "Member 'DIClientWebServiceSession_BuyItemNoConf::ItemId' has a wrong offset!");
static_assert(offsetof(DIClientWebServiceSession_BuyItemNoConf, CurrencyId) == 0x000010, "Member 'DIClientWebServiceSession_BuyItemNoConf::CurrencyId' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.ClaimLootBundle
// 0x0010 (0x0010 - 0x0000)
struct DIClientWebServiceSession_ClaimLootBundle final
{
public:
	class FString                                 LootBundleId;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_ClaimLootBundle) == 0x000008, "Wrong alignment on DIClientWebServiceSession_ClaimLootBundle");
static_assert(sizeof(DIClientWebServiceSession_ClaimLootBundle) == 0x000010, "Wrong size on DIClientWebServiceSession_ClaimLootBundle");
static_assert(offsetof(DIClientWebServiceSession_ClaimLootBundle, LootBundleId) == 0x000000, "Member 'DIClientWebServiceSession_ClaimLootBundle::LootBundleId' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.ConsumeItem
// 0x0010 (0x0010 - 0x0000)
struct DIClientWebServiceSession_ConsumeItem final
{
public:
	class FString                                 ItemId;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_ConsumeItem) == 0x000008, "Wrong alignment on DIClientWebServiceSession_ConsumeItem");
static_assert(sizeof(DIClientWebServiceSession_ConsumeItem) == 0x000010, "Wrong size on DIClientWebServiceSession_ConsumeItem");
static_assert(offsetof(DIClientWebServiceSession_ConsumeItem, ItemId) == 0x000000, "Member 'DIClientWebServiceSession_ConsumeItem::ItemId' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.DoFetchAgreement
// 0x0010 (0x0010 - 0x0000)
struct DIClientWebServiceSession_DoFetchAgreement final
{
public:
	class FString                                 AgreementName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_DoFetchAgreement) == 0x000008, "Wrong alignment on DIClientWebServiceSession_DoFetchAgreement");
static_assert(sizeof(DIClientWebServiceSession_DoFetchAgreement) == 0x000010, "Wrong size on DIClientWebServiceSession_DoFetchAgreement");
static_assert(offsetof(DIClientWebServiceSession_DoFetchAgreement, AgreementName) == 0x000000, "Member 'DIClientWebServiceSession_DoFetchAgreement::AgreementName' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.DoSignAgreement
// 0x0010 (0x0010 - 0x0000)
struct DIClientWebServiceSession_DoSignAgreement final
{
public:
	class FString                                 AgreementName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_DoSignAgreement) == 0x000008, "Wrong alignment on DIClientWebServiceSession_DoSignAgreement");
static_assert(sizeof(DIClientWebServiceSession_DoSignAgreement) == 0x000010, "Wrong size on DIClientWebServiceSession_DoSignAgreement");
static_assert(offsetof(DIClientWebServiceSession_DoSignAgreement, AgreementName) == 0x000000, "Member 'DIClientWebServiceSession_DoSignAgreement::AgreementName' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.GetCurrentItemToBuy
// 0x0040 (0x0040 - 0x0000)
struct DIClientWebServiceSession_GetCurrentItemToBuy final
{
public:
	struct FBuyItemInfo                           ReturnValue;                                       // 0x0000(0x0040)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_GetCurrentItemToBuy) == 0x000008, "Wrong alignment on DIClientWebServiceSession_GetCurrentItemToBuy");
static_assert(sizeof(DIClientWebServiceSession_GetCurrentItemToBuy) == 0x000040, "Wrong size on DIClientWebServiceSession_GetCurrentItemToBuy");
static_assert(offsetof(DIClientWebServiceSession_GetCurrentItemToBuy, ReturnValue) == 0x000000, "Member 'DIClientWebServiceSession_GetCurrentItemToBuy::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.GetPlatformPurchaseItemMap
// 0x0070 (0x0070 - 0x0000)
struct DIClientWebServiceSession_GetPlatformPurchaseItemMap final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlatformPurchaseMapping               OutResult;                                         // 0x0010(0x0058)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0068(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIClientWebServiceSession_GetPlatformPurchaseItemMap) == 0x000008, "Wrong alignment on DIClientWebServiceSession_GetPlatformPurchaseItemMap");
static_assert(sizeof(DIClientWebServiceSession_GetPlatformPurchaseItemMap) == 0x000070, "Wrong size on DIClientWebServiceSession_GetPlatformPurchaseItemMap");
static_assert(offsetof(DIClientWebServiceSession_GetPlatformPurchaseItemMap, Key) == 0x000000, "Member 'DIClientWebServiceSession_GetPlatformPurchaseItemMap::Key' has a wrong offset!");
static_assert(offsetof(DIClientWebServiceSession_GetPlatformPurchaseItemMap, OutResult) == 0x000010, "Member 'DIClientWebServiceSession_GetPlatformPurchaseItemMap::OutResult' has a wrong offset!");
static_assert(offsetof(DIClientWebServiceSession_GetPlatformPurchaseItemMap, ReturnValue) == 0x000068, "Member 'DIClientWebServiceSession_GetPlatformPurchaseItemMap::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.GetSesssionId
// 0x0010 (0x0010 - 0x0000)
struct DIClientWebServiceSession_GetSesssionId final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_GetSesssionId) == 0x000008, "Wrong alignment on DIClientWebServiceSession_GetSesssionId");
static_assert(sizeof(DIClientWebServiceSession_GetSesssionId) == 0x000010, "Wrong size on DIClientWebServiceSession_GetSesssionId");
static_assert(offsetof(DIClientWebServiceSession_GetSesssionId, ReturnValue) == 0x000000, "Member 'DIClientWebServiceSession_GetSesssionId::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.HandleBooleanPlayerSettingChange
// 0x0002 (0x0002 - 0x0000)
struct DIClientWebServiceSession_HandleBooleanPlayerSettingChange final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewValue;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_HandleBooleanPlayerSettingChange) == 0x000001, "Wrong alignment on DIClientWebServiceSession_HandleBooleanPlayerSettingChange");
static_assert(sizeof(DIClientWebServiceSession_HandleBooleanPlayerSettingChange) == 0x000002, "Wrong size on DIClientWebServiceSession_HandleBooleanPlayerSettingChange");
static_assert(offsetof(DIClientWebServiceSession_HandleBooleanPlayerSettingChange, SettingType) == 0x000000, "Member 'DIClientWebServiceSession_HandleBooleanPlayerSettingChange::SettingType' has a wrong offset!");
static_assert(offsetof(DIClientWebServiceSession_HandleBooleanPlayerSettingChange, NewValue) == 0x000001, "Member 'DIClientWebServiceSession_HandleBooleanPlayerSettingChange::NewValue' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.HandleIntegerPlayerSettingChange
// 0x0008 (0x0008 - 0x0000)
struct DIClientWebServiceSession_HandleIntegerPlayerSettingChange final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NewValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_HandleIntegerPlayerSettingChange) == 0x000004, "Wrong alignment on DIClientWebServiceSession_HandleIntegerPlayerSettingChange");
static_assert(sizeof(DIClientWebServiceSession_HandleIntegerPlayerSettingChange) == 0x000008, "Wrong size on DIClientWebServiceSession_HandleIntegerPlayerSettingChange");
static_assert(offsetof(DIClientWebServiceSession_HandleIntegerPlayerSettingChange, SettingType) == 0x000000, "Member 'DIClientWebServiceSession_HandleIntegerPlayerSettingChange::SettingType' has a wrong offset!");
static_assert(offsetof(DIClientWebServiceSession_HandleIntegerPlayerSettingChange, NewValue) == 0x000004, "Member 'DIClientWebServiceSession_HandleIntegerPlayerSettingChange::NewValue' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.HandleMatchmakingStatusChanged
// 0x0001 (0x0001 - 0x0000)
struct DIClientWebServiceSession_HandleMatchmakingStatusChanged final
{
public:
	EDescribeMatchmakingStatus                    NewState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_HandleMatchmakingStatusChanged) == 0x000001, "Wrong alignment on DIClientWebServiceSession_HandleMatchmakingStatusChanged");
static_assert(sizeof(DIClientWebServiceSession_HandleMatchmakingStatusChanged) == 0x000001, "Wrong size on DIClientWebServiceSession_HandleMatchmakingStatusChanged");
static_assert(offsetof(DIClientWebServiceSession_HandleMatchmakingStatusChanged, NewState) == 0x000000, "Member 'DIClientWebServiceSession_HandleMatchmakingStatusChanged::NewState' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.HandleMenuEvent
// 0x0018 (0x0018 - 0x0000)
struct DIClientWebServiceSession_HandleMenuEvent final
{
public:
	class FString                                 EventName;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AnswerValue;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIClientWebServiceSession_HandleMenuEvent) == 0x000008, "Wrong alignment on DIClientWebServiceSession_HandleMenuEvent");
static_assert(sizeof(DIClientWebServiceSession_HandleMenuEvent) == 0x000018, "Wrong size on DIClientWebServiceSession_HandleMenuEvent");
static_assert(offsetof(DIClientWebServiceSession_HandleMenuEvent, EventName) == 0x000000, "Member 'DIClientWebServiceSession_HandleMenuEvent::EventName' has a wrong offset!");
static_assert(offsetof(DIClientWebServiceSession_HandleMenuEvent, AnswerValue) == 0x000010, "Member 'DIClientWebServiceSession_HandleMenuEvent::AnswerValue' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.IsClientSessionValid
// 0x0001 (0x0001 - 0x0000)
struct DIClientWebServiceSession_IsClientSessionValid final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_IsClientSessionValid) == 0x000001, "Wrong alignment on DIClientWebServiceSession_IsClientSessionValid");
static_assert(sizeof(DIClientWebServiceSession_IsClientSessionValid) == 0x000001, "Wrong size on DIClientWebServiceSession_IsClientSessionValid");
static_assert(offsetof(DIClientWebServiceSession_IsClientSessionValid, ReturnValue) == 0x000000, "Member 'DIClientWebServiceSession_IsClientSessionValid::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.OnMatchmakingFailed
// 0x0001 (0x0001 - 0x0000)
struct DIClientWebServiceSession_OnMatchmakingFailed final
{
public:
	EMatchmakingError                             MatchmakingError;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_OnMatchmakingFailed) == 0x000001, "Wrong alignment on DIClientWebServiceSession_OnMatchmakingFailed");
static_assert(sizeof(DIClientWebServiceSession_OnMatchmakingFailed) == 0x000001, "Wrong size on DIClientWebServiceSession_OnMatchmakingFailed");
static_assert(offsetof(DIClientWebServiceSession_OnMatchmakingFailed, MatchmakingError) == 0x000000, "Member 'DIClientWebServiceSession_OnMatchmakingFailed::MatchmakingError' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.OnMatchmakingSuccess
// 0x0030 (0x0030 - 0x0000)
struct DIClientWebServiceSession_OnMatchmakingSuccess final
{
public:
	struct FDescribeMatchmakingResponse           MatchDescription;                                  // 0x0000(0x0030)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_OnMatchmakingSuccess) == 0x000008, "Wrong alignment on DIClientWebServiceSession_OnMatchmakingSuccess");
static_assert(sizeof(DIClientWebServiceSession_OnMatchmakingSuccess) == 0x000030, "Wrong size on DIClientWebServiceSession_OnMatchmakingSuccess");
static_assert(offsetof(DIClientWebServiceSession_OnMatchmakingSuccess, MatchDescription) == 0x000000, "Member 'DIClientWebServiceSession_OnMatchmakingSuccess::MatchDescription' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.OnMatchmakingTokenChanged
// 0x0010 (0x0010 - 0x0000)
struct DIClientWebServiceSession_OnMatchmakingTokenChanged final
{
public:
	class FString                                 MatchmakingToken;                                  // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_OnMatchmakingTokenChanged) == 0x000008, "Wrong alignment on DIClientWebServiceSession_OnMatchmakingTokenChanged");
static_assert(sizeof(DIClientWebServiceSession_OnMatchmakingTokenChanged) == 0x000010, "Wrong size on DIClientWebServiceSession_OnMatchmakingTokenChanged");
static_assert(offsetof(DIClientWebServiceSession_OnMatchmakingTokenChanged, MatchmakingToken) == 0x000000, "Member 'DIClientWebServiceSession_OnMatchmakingTokenChanged::MatchmakingToken' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.OnPartyMatchmakingTicketReceived
// 0x0010 (0x0010 - 0x0000)
struct DIClientWebServiceSession_OnPartyMatchmakingTicketReceived final
{
public:
	class FString                                 MatchmakingTicketId;                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_OnPartyMatchmakingTicketReceived) == 0x000008, "Wrong alignment on DIClientWebServiceSession_OnPartyMatchmakingTicketReceived");
static_assert(sizeof(DIClientWebServiceSession_OnPartyMatchmakingTicketReceived) == 0x000010, "Wrong size on DIClientWebServiceSession_OnPartyMatchmakingTicketReceived");
static_assert(offsetof(DIClientWebServiceSession_OnPartyMatchmakingTicketReceived, MatchmakingTicketId) == 0x000000, "Member 'DIClientWebServiceSession_OnPartyMatchmakingTicketReceived::MatchmakingTicketId' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.OnSessionLogin
// 0x0020 (0x0020 - 0x0000)
struct DIClientWebServiceSession_OnSessionLogin final
{
public:
	struct FLoginResponse                         LoginResponse;                                     // 0x0000(0x0020)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_OnSessionLogin) == 0x000008, "Wrong alignment on DIClientWebServiceSession_OnSessionLogin");
static_assert(sizeof(DIClientWebServiceSession_OnSessionLogin) == 0x000020, "Wrong size on DIClientWebServiceSession_OnSessionLogin");
static_assert(offsetof(DIClientWebServiceSession_OnSessionLogin, LoginResponse) == 0x000000, "Member 'DIClientWebServiceSession_OnSessionLogin::LoginResponse' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.OnSessionRefresh
// 0x0010 (0x0010 - 0x0000)
struct DIClientWebServiceSession_OnSessionRefresh final
{
public:
	struct FSessionRefreshResponse                SessionRefreshResponse;                            // 0x0000(0x0010)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_OnSessionRefresh) == 0x000008, "Wrong alignment on DIClientWebServiceSession_OnSessionRefresh");
static_assert(sizeof(DIClientWebServiceSession_OnSessionRefresh) == 0x000010, "Wrong size on DIClientWebServiceSession_OnSessionRefresh");
static_assert(offsetof(DIClientWebServiceSession_OnSessionRefresh, SessionRefreshResponse) == 0x000000, "Member 'DIClientWebServiceSession_OnSessionRefresh::SessionRefreshResponse' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.PostLoadMapDelegate
// 0x0008 (0x0008 - 0x0000)
struct DIClientWebServiceSession_PostLoadMapDelegate final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_PostLoadMapDelegate) == 0x000008, "Wrong alignment on DIClientWebServiceSession_PostLoadMapDelegate");
static_assert(sizeof(DIClientWebServiceSession_PostLoadMapDelegate) == 0x000008, "Wrong size on DIClientWebServiceSession_PostLoadMapDelegate");
static_assert(offsetof(DIClientWebServiceSession_PostLoadMapDelegate, World) == 0x000000, "Member 'DIClientWebServiceSession_PostLoadMapDelegate::World' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.SendReport
// 0x0040 (0x0040 - 0x0000)
struct DIClientWebServiceSession_SendReport final
{
public:
	class FString                                 Reporter;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReporteeAccelbyteId;                               // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchId;                                           // 0x0030(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_SendReport) == 0x000008, "Wrong alignment on DIClientWebServiceSession_SendReport");
static_assert(sizeof(DIClientWebServiceSession_SendReport) == 0x000040, "Wrong size on DIClientWebServiceSession_SendReport");
static_assert(offsetof(DIClientWebServiceSession_SendReport, Reporter) == 0x000000, "Member 'DIClientWebServiceSession_SendReport::Reporter' has a wrong offset!");
static_assert(offsetof(DIClientWebServiceSession_SendReport, ReporteeAccelbyteId) == 0x000010, "Member 'DIClientWebServiceSession_SendReport::ReporteeAccelbyteId' has a wrong offset!");
static_assert(offsetof(DIClientWebServiceSession_SendReport, Message) == 0x000020, "Member 'DIClientWebServiceSession_SendReport::Message' has a wrong offset!");
static_assert(offsetof(DIClientWebServiceSession_SendReport, MatchId) == 0x000030, "Member 'DIClientWebServiceSession_SendReport::MatchId' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.StartPlatformTransaction
// 0x0010 (0x0010 - 0x0000)
struct DIClientWebServiceSession_StartPlatformTransaction final
{
public:
	class FString                                 KeyMap;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_StartPlatformTransaction) == 0x000008, "Wrong alignment on DIClientWebServiceSession_StartPlatformTransaction");
static_assert(sizeof(DIClientWebServiceSession_StartPlatformTransaction) == 0x000010, "Wrong size on DIClientWebServiceSession_StartPlatformTransaction");
static_assert(offsetof(DIClientWebServiceSession_StartPlatformTransaction, KeyMap) == 0x000000, "Member 'DIClientWebServiceSession_StartPlatformTransaction::KeyMap' has a wrong offset!");

// Function DeceiveInc.DIClientWebServiceSession.StartSteamTransaction
// 0x0004 (0x0004 - 0x0000)
struct DIClientWebServiceSession_StartSteamTransaction final
{
public:
	int32                                         SteamShopItemId;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIClientWebServiceSession_StartSteamTransaction) == 0x000004, "Wrong alignment on DIClientWebServiceSession_StartSteamTransaction");
static_assert(sizeof(DIClientWebServiceSession_StartSteamTransaction) == 0x000004, "Wrong size on DIClientWebServiceSession_StartSteamTransaction");
static_assert(offsetof(DIClientWebServiceSession_StartSteamTransaction, SteamShopItemId) == 0x000000, "Member 'DIClientWebServiceSession_StartSteamTransaction::SteamShopItemId' has a wrong offset!");

// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetAccountXpType
// 0x0010 (0x0010 - 0x0000)
struct DIDataStoreBlueprintLibrary_GetAccountXpType final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIDataStoreBlueprintLibrary_GetAccountXpType) == 0x000008, "Wrong alignment on DIDataStoreBlueprintLibrary_GetAccountXpType");
static_assert(sizeof(DIDataStoreBlueprintLibrary_GetAccountXpType) == 0x000010, "Wrong size on DIDataStoreBlueprintLibrary_GetAccountXpType");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetAccountXpType, ReturnValue) == 0x000000, "Member 'DIDataStoreBlueprintLibrary_GetAccountXpType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetActorPingInfo
// 0x0048 (0x0048 - 0x0000)
struct DIDataStoreBlueprintLibrary_GetActorPingInfo final
{
public:
	class AActor*                                 PingedActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPingInfo                              ReturnValue;                                       // 0x0008(0x0040)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIDataStoreBlueprintLibrary_GetActorPingInfo) == 0x000008, "Wrong alignment on DIDataStoreBlueprintLibrary_GetActorPingInfo");
static_assert(sizeof(DIDataStoreBlueprintLibrary_GetActorPingInfo) == 0x000048, "Wrong size on DIDataStoreBlueprintLibrary_GetActorPingInfo");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetActorPingInfo, PingedActor) == 0x000000, "Member 'DIDataStoreBlueprintLibrary_GetActorPingInfo::PingedActor' has a wrong offset!");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetActorPingInfo, ReturnValue) == 0x000008, "Member 'DIDataStoreBlueprintLibrary_GetActorPingInfo::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetAgentDataById
// 0x0018 (0x0018 - 0x0000)
struct DIDataStoreBlueprintLibrary_GetAgentDataById final
{
public:
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAgentData*                             ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIDataStoreBlueprintLibrary_GetAgentDataById) == 0x000008, "Wrong alignment on DIDataStoreBlueprintLibrary_GetAgentDataById");
static_assert(sizeof(DIDataStoreBlueprintLibrary_GetAgentDataById) == 0x000018, "Wrong size on DIDataStoreBlueprintLibrary_GetAgentDataById");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetAgentDataById, PrimaryAssetId) == 0x000000, "Member 'DIDataStoreBlueprintLibrary_GetAgentDataById::PrimaryAssetId' has a wrong offset!");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetAgentDataById, ReturnValue) == 0x000010, "Member 'DIDataStoreBlueprintLibrary_GetAgentDataById::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetAgentDataByPrimaryAssetName
// 0x0018 (0x0018 - 0x0000)
struct DIDataStoreBlueprintLibrary_GetAgentDataByPrimaryAssetName final
{
public:
	class FString                                 PrimaryAssetName;                                  // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAgentData*                             ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIDataStoreBlueprintLibrary_GetAgentDataByPrimaryAssetName) == 0x000008, "Wrong alignment on DIDataStoreBlueprintLibrary_GetAgentDataByPrimaryAssetName");
static_assert(sizeof(DIDataStoreBlueprintLibrary_GetAgentDataByPrimaryAssetName) == 0x000018, "Wrong size on DIDataStoreBlueprintLibrary_GetAgentDataByPrimaryAssetName");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetAgentDataByPrimaryAssetName, PrimaryAssetName) == 0x000000, "Member 'DIDataStoreBlueprintLibrary_GetAgentDataByPrimaryAssetName::PrimaryAssetName' has a wrong offset!");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetAgentDataByPrimaryAssetName, ReturnValue) == 0x000010, "Member 'DIDataStoreBlueprintLibrary_GetAgentDataByPrimaryAssetName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetAgentIntroPoseDataById
// 0x0018 (0x0018 - 0x0000)
struct DIDataStoreBlueprintLibrary_GetAgentIntroPoseDataById final
{
public:
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAgentIntroPoseDataAsset*               ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIDataStoreBlueprintLibrary_GetAgentIntroPoseDataById) == 0x000008, "Wrong alignment on DIDataStoreBlueprintLibrary_GetAgentIntroPoseDataById");
static_assert(sizeof(DIDataStoreBlueprintLibrary_GetAgentIntroPoseDataById) == 0x000018, "Wrong size on DIDataStoreBlueprintLibrary_GetAgentIntroPoseDataById");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetAgentIntroPoseDataById, PrimaryAssetId) == 0x000000, "Member 'DIDataStoreBlueprintLibrary_GetAgentIntroPoseDataById::PrimaryAssetId' has a wrong offset!");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetAgentIntroPoseDataById, ReturnValue) == 0x000010, "Member 'DIDataStoreBlueprintLibrary_GetAgentIntroPoseDataById::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetAgentSkinDataById
// 0x0018 (0x0018 - 0x0000)
struct DIDataStoreBlueprintLibrary_GetAgentSkinDataById final
{
public:
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAgentSkinData*                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIDataStoreBlueprintLibrary_GetAgentSkinDataById) == 0x000008, "Wrong alignment on DIDataStoreBlueprintLibrary_GetAgentSkinDataById");
static_assert(sizeof(DIDataStoreBlueprintLibrary_GetAgentSkinDataById) == 0x000018, "Wrong size on DIDataStoreBlueprintLibrary_GetAgentSkinDataById");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetAgentSkinDataById, PrimaryAssetId) == 0x000000, "Member 'DIDataStoreBlueprintLibrary_GetAgentSkinDataById::PrimaryAssetId' has a wrong offset!");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetAgentSkinDataById, ReturnValue) == 0x000010, "Member 'DIDataStoreBlueprintLibrary_GetAgentSkinDataById::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetAllAgentData
// 0x0010 (0x0010 - 0x0000)
struct DIDataStoreBlueprintLibrary_GetAllAgentData final
{
public:
	TArray<class UAgentData*>                     ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIDataStoreBlueprintLibrary_GetAllAgentData) == 0x000008, "Wrong alignment on DIDataStoreBlueprintLibrary_GetAllAgentData");
static_assert(sizeof(DIDataStoreBlueprintLibrary_GetAllAgentData) == 0x000010, "Wrong size on DIDataStoreBlueprintLibrary_GetAllAgentData");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetAllAgentData, ReturnValue) == 0x000000, "Member 'DIDataStoreBlueprintLibrary_GetAllAgentData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetAvatarDataById
// 0x0018 (0x0018 - 0x0000)
struct DIDataStoreBlueprintLibrary_GetAvatarDataById final
{
public:
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAvatarDataAsset*                       ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIDataStoreBlueprintLibrary_GetAvatarDataById) == 0x000008, "Wrong alignment on DIDataStoreBlueprintLibrary_GetAvatarDataById");
static_assert(sizeof(DIDataStoreBlueprintLibrary_GetAvatarDataById) == 0x000018, "Wrong size on DIDataStoreBlueprintLibrary_GetAvatarDataById");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetAvatarDataById, PrimaryAssetId) == 0x000000, "Member 'DIDataStoreBlueprintLibrary_GetAvatarDataById::PrimaryAssetId' has a wrong offset!");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetAvatarDataById, ReturnValue) == 0x000010, "Member 'DIDataStoreBlueprintLibrary_GetAvatarDataById::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetCatalogueXpType
// 0x0010 (0x0010 - 0x0000)
struct DIDataStoreBlueprintLibrary_GetCatalogueXpType final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIDataStoreBlueprintLibrary_GetCatalogueXpType) == 0x000008, "Wrong alignment on DIDataStoreBlueprintLibrary_GetCatalogueXpType");
static_assert(sizeof(DIDataStoreBlueprintLibrary_GetCatalogueXpType) == 0x000010, "Wrong size on DIDataStoreBlueprintLibrary_GetCatalogueXpType");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetCatalogueXpType, ReturnValue) == 0x000000, "Member 'DIDataStoreBlueprintLibrary_GetCatalogueXpType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetCoverAffectingSourceData
// 0x0008 (0x0008 - 0x0000)
struct DIDataStoreBlueprintLibrary_GetCoverAffectingSourceData final
{
public:
	class UCoverAffectingSourceDataAsset*         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIDataStoreBlueprintLibrary_GetCoverAffectingSourceData) == 0x000008, "Wrong alignment on DIDataStoreBlueprintLibrary_GetCoverAffectingSourceData");
static_assert(sizeof(DIDataStoreBlueprintLibrary_GetCoverAffectingSourceData) == 0x000008, "Wrong size on DIDataStoreBlueprintLibrary_GetCoverAffectingSourceData");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetCoverAffectingSourceData, ReturnValue) == 0x000000, "Member 'DIDataStoreBlueprintLibrary_GetCoverAffectingSourceData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetCurrencyData
// 0x0018 (0x0018 - 0x0000)
struct DIDataStoreBlueprintLibrary_GetCurrencyData final
{
public:
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDICurrencyType*                        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIDataStoreBlueprintLibrary_GetCurrencyData) == 0x000008, "Wrong alignment on DIDataStoreBlueprintLibrary_GetCurrencyData");
static_assert(sizeof(DIDataStoreBlueprintLibrary_GetCurrencyData) == 0x000018, "Wrong size on DIDataStoreBlueprintLibrary_GetCurrencyData");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetCurrencyData, PrimaryAssetId) == 0x000000, "Member 'DIDataStoreBlueprintLibrary_GetCurrencyData::PrimaryAssetId' has a wrong offset!");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetCurrencyData, ReturnValue) == 0x000010, "Member 'DIDataStoreBlueprintLibrary_GetCurrencyData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetExpertiseSkillDataById
// 0x0018 (0x0018 - 0x0000)
struct DIDataStoreBlueprintLibrary_GetExpertiseSkillDataById final
{
public:
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAgentExpertiseSkillData*               ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIDataStoreBlueprintLibrary_GetExpertiseSkillDataById) == 0x000008, "Wrong alignment on DIDataStoreBlueprintLibrary_GetExpertiseSkillDataById");
static_assert(sizeof(DIDataStoreBlueprintLibrary_GetExpertiseSkillDataById) == 0x000018, "Wrong size on DIDataStoreBlueprintLibrary_GetExpertiseSkillDataById");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetExpertiseSkillDataById, PrimaryAssetId) == 0x000000, "Member 'DIDataStoreBlueprintLibrary_GetExpertiseSkillDataById::PrimaryAssetId' has a wrong offset!");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetExpertiseSkillDataById, ReturnValue) == 0x000010, "Member 'DIDataStoreBlueprintLibrary_GetExpertiseSkillDataById::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetGadgetDataById
// 0x0018 (0x0018 - 0x0000)
struct DIDataStoreBlueprintLibrary_GetGadgetDataById final
{
public:
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGadgetData*                            ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIDataStoreBlueprintLibrary_GetGadgetDataById) == 0x000008, "Wrong alignment on DIDataStoreBlueprintLibrary_GetGadgetDataById");
static_assert(sizeof(DIDataStoreBlueprintLibrary_GetGadgetDataById) == 0x000018, "Wrong size on DIDataStoreBlueprintLibrary_GetGadgetDataById");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetGadgetDataById, PrimaryAssetId) == 0x000000, "Member 'DIDataStoreBlueprintLibrary_GetGadgetDataById::PrimaryAssetId' has a wrong offset!");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetGadgetDataById, ReturnValue) == 0x000010, "Member 'DIDataStoreBlueprintLibrary_GetGadgetDataById::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetLevelInventoryData
// 0x0008 (0x0008 - 0x0000)
struct DIDataStoreBlueprintLibrary_GetLevelInventoryData final
{
public:
	class ULevelInventoryData*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIDataStoreBlueprintLibrary_GetLevelInventoryData) == 0x000008, "Wrong alignment on DIDataStoreBlueprintLibrary_GetLevelInventoryData");
static_assert(sizeof(DIDataStoreBlueprintLibrary_GetLevelInventoryData) == 0x000008, "Wrong size on DIDataStoreBlueprintLibrary_GetLevelInventoryData");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetLevelInventoryData, ReturnValue) == 0x000000, "Member 'DIDataStoreBlueprintLibrary_GetLevelInventoryData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetPassiveSkillDataById
// 0x0018 (0x0018 - 0x0000)
struct DIDataStoreBlueprintLibrary_GetPassiveSkillDataById final
{
public:
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAgentPassiveSkillData*                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIDataStoreBlueprintLibrary_GetPassiveSkillDataById) == 0x000008, "Wrong alignment on DIDataStoreBlueprintLibrary_GetPassiveSkillDataById");
static_assert(sizeof(DIDataStoreBlueprintLibrary_GetPassiveSkillDataById) == 0x000018, "Wrong size on DIDataStoreBlueprintLibrary_GetPassiveSkillDataById");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetPassiveSkillDataById, PrimaryAssetId) == 0x000000, "Member 'DIDataStoreBlueprintLibrary_GetPassiveSkillDataById::PrimaryAssetId' has a wrong offset!");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetPassiveSkillDataById, ReturnValue) == 0x000010, "Member 'DIDataStoreBlueprintLibrary_GetPassiveSkillDataById::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetPlatformData
// 0x0008 (0x0008 - 0x0000)
struct DIDataStoreBlueprintLibrary_GetPlatformData final
{
public:
	class UPlatformDataAsset*                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIDataStoreBlueprintLibrary_GetPlatformData) == 0x000008, "Wrong alignment on DIDataStoreBlueprintLibrary_GetPlatformData");
static_assert(sizeof(DIDataStoreBlueprintLibrary_GetPlatformData) == 0x000008, "Wrong size on DIDataStoreBlueprintLibrary_GetPlatformData");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetPlatformData, ReturnValue) == 0x000000, "Member 'DIDataStoreBlueprintLibrary_GetPlatformData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetRadialPingInfoByIndex
// 0x0048 (0x0048 - 0x0000)
struct DIDataStoreBlueprintLibrary_GetRadialPingInfoByIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPingInfo                              ReturnValue;                                       // 0x0008(0x0040)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIDataStoreBlueprintLibrary_GetRadialPingInfoByIndex) == 0x000008, "Wrong alignment on DIDataStoreBlueprintLibrary_GetRadialPingInfoByIndex");
static_assert(sizeof(DIDataStoreBlueprintLibrary_GetRadialPingInfoByIndex) == 0x000048, "Wrong size on DIDataStoreBlueprintLibrary_GetRadialPingInfoByIndex");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetRadialPingInfoByIndex, Index_0) == 0x000000, "Member 'DIDataStoreBlueprintLibrary_GetRadialPingInfoByIndex::Index_0' has a wrong offset!");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetRadialPingInfoByIndex, ReturnValue) == 0x000008, "Member 'DIDataStoreBlueprintLibrary_GetRadialPingInfoByIndex::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetSecurityLevelColor
// 0x0008 (0x0008 - 0x0000)
struct DIDataStoreBlueprintLibrary_GetSecurityLevelColor final
{
public:
	ESecurityLevel                                SecurityLevel;                                     // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIDataStoreBlueprintLibrary_GetSecurityLevelColor) == 0x000004, "Wrong alignment on DIDataStoreBlueprintLibrary_GetSecurityLevelColor");
static_assert(sizeof(DIDataStoreBlueprintLibrary_GetSecurityLevelColor) == 0x000008, "Wrong size on DIDataStoreBlueprintLibrary_GetSecurityLevelColor");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetSecurityLevelColor, SecurityLevel) == 0x000000, "Member 'DIDataStoreBlueprintLibrary_GetSecurityLevelColor::SecurityLevel' has a wrong offset!");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetSecurityLevelColor, ReturnValue) == 0x000004, "Member 'DIDataStoreBlueprintLibrary_GetSecurityLevelColor::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetTeamData
// 0x0008 (0x0008 - 0x0000)
struct DIDataStoreBlueprintLibrary_GetTeamData final
{
public:
	class UTeamDataAsset*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIDataStoreBlueprintLibrary_GetTeamData) == 0x000008, "Wrong alignment on DIDataStoreBlueprintLibrary_GetTeamData");
static_assert(sizeof(DIDataStoreBlueprintLibrary_GetTeamData) == 0x000008, "Wrong size on DIDataStoreBlueprintLibrary_GetTeamData");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetTeamData, ReturnValue) == 0x000000, "Member 'DIDataStoreBlueprintLibrary_GetTeamData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetTitleDataById
// 0x0018 (0x0018 - 0x0000)
struct DIDataStoreBlueprintLibrary_GetTitleDataById final
{
public:
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTitleDataAsset*                        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIDataStoreBlueprintLibrary_GetTitleDataById) == 0x000008, "Wrong alignment on DIDataStoreBlueprintLibrary_GetTitleDataById");
static_assert(sizeof(DIDataStoreBlueprintLibrary_GetTitleDataById) == 0x000018, "Wrong size on DIDataStoreBlueprintLibrary_GetTitleDataById");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetTitleDataById, PrimaryAssetId) == 0x000000, "Member 'DIDataStoreBlueprintLibrary_GetTitleDataById::PrimaryAssetId' has a wrong offset!");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetTitleDataById, ReturnValue) == 0x000010, "Member 'DIDataStoreBlueprintLibrary_GetTitleDataById::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetWeaponDataById
// 0x0018 (0x0018 - 0x0000)
struct DIDataStoreBlueprintLibrary_GetWeaponDataById final
{
public:
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAgentWeaponData*                       ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIDataStoreBlueprintLibrary_GetWeaponDataById) == 0x000008, "Wrong alignment on DIDataStoreBlueprintLibrary_GetWeaponDataById");
static_assert(sizeof(DIDataStoreBlueprintLibrary_GetWeaponDataById) == 0x000018, "Wrong size on DIDataStoreBlueprintLibrary_GetWeaponDataById");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetWeaponDataById, PrimaryAssetId) == 0x000000, "Member 'DIDataStoreBlueprintLibrary_GetWeaponDataById::PrimaryAssetId' has a wrong offset!");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetWeaponDataById, ReturnValue) == 0x000010, "Member 'DIDataStoreBlueprintLibrary_GetWeaponDataById::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetXpEventData
// 0x0008 (0x0008 - 0x0000)
struct DIDataStoreBlueprintLibrary_GetXpEventData final
{
public:
	class UDIXpEventDataAsset*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIDataStoreBlueprintLibrary_GetXpEventData) == 0x000008, "Wrong alignment on DIDataStoreBlueprintLibrary_GetXpEventData");
static_assert(sizeof(DIDataStoreBlueprintLibrary_GetXpEventData) == 0x000008, "Wrong size on DIDataStoreBlueprintLibrary_GetXpEventData");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetXpEventData, ReturnValue) == 0x000000, "Member 'DIDataStoreBlueprintLibrary_GetXpEventData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIDataStoreBlueprintLibrary.GetXpProgressionData
// 0x0010 (0x0010 - 0x0000)
struct DIDataStoreBlueprintLibrary_GetXpProgressionData final
{
public:
	EXpProgressionType                            ProgressionType;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UXpProgressionData*                     ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIDataStoreBlueprintLibrary_GetXpProgressionData) == 0x000008, "Wrong alignment on DIDataStoreBlueprintLibrary_GetXpProgressionData");
static_assert(sizeof(DIDataStoreBlueprintLibrary_GetXpProgressionData) == 0x000010, "Wrong size on DIDataStoreBlueprintLibrary_GetXpProgressionData");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetXpProgressionData, ProgressionType) == 0x000000, "Member 'DIDataStoreBlueprintLibrary_GetXpProgressionData::ProgressionType' has a wrong offset!");
static_assert(offsetof(DIDataStoreBlueprintLibrary_GetXpProgressionData, ReturnValue) == 0x000008, "Member 'DIDataStoreBlueprintLibrary_GetXpProgressionData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.EMPSphere.HandleActorDamaged
// 0x0030 (0x0030 - 0x0000)
struct EMPSphere_HandleActorDamaged final
{
public:
	class UHealthComponent*                       OwningHealthComp;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthDelta;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDamageType*                      DamageType;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RawDamage;                                         // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(EMPSphere_HandleActorDamaged) == 0x000008, "Wrong alignment on EMPSphere_HandleActorDamaged");
static_assert(sizeof(EMPSphere_HandleActorDamaged) == 0x000030, "Wrong size on EMPSphere_HandleActorDamaged");
static_assert(offsetof(EMPSphere_HandleActorDamaged, OwningHealthComp) == 0x000000, "Member 'EMPSphere_HandleActorDamaged::OwningHealthComp' has a wrong offset!");
static_assert(offsetof(EMPSphere_HandleActorDamaged, Health) == 0x000008, "Member 'EMPSphere_HandleActorDamaged::Health' has a wrong offset!");
static_assert(offsetof(EMPSphere_HandleActorDamaged, HealthDelta) == 0x00000C, "Member 'EMPSphere_HandleActorDamaged::HealthDelta' has a wrong offset!");
static_assert(offsetof(EMPSphere_HandleActorDamaged, DamageType) == 0x000010, "Member 'EMPSphere_HandleActorDamaged::DamageType' has a wrong offset!");
static_assert(offsetof(EMPSphere_HandleActorDamaged, InstigatedBy) == 0x000018, "Member 'EMPSphere_HandleActorDamaged::InstigatedBy' has a wrong offset!");
static_assert(offsetof(EMPSphere_HandleActorDamaged, DamageCauser) == 0x000020, "Member 'EMPSphere_HandleActorDamaged::DamageCauser' has a wrong offset!");
static_assert(offsetof(EMPSphere_HandleActorDamaged, RawDamage) == 0x000028, "Member 'EMPSphere_HandleActorDamaged::RawDamage' has a wrong offset!");

// Function DeceiveInc.EMPSphere.NetMulticast_OnAttachToVictim
// 0x0008 (0x0008 - 0x0000)
struct EMPSphere_NetMulticast_OnAttachToVictim final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EMPSphere_NetMulticast_OnAttachToVictim) == 0x000008, "Wrong alignment on EMPSphere_NetMulticast_OnAttachToVictim");
static_assert(sizeof(EMPSphere_NetMulticast_OnAttachToVictim) == 0x000008, "Wrong size on EMPSphere_NetMulticast_OnAttachToVictim");
static_assert(offsetof(EMPSphere_NetMulticast_OnAttachToVictim, Victim) == 0x000000, "Member 'EMPSphere_NetMulticast_OnAttachToVictim::Victim' has a wrong offset!");

// Function DeceiveInc.EMPSphere.OnEMPSphereBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct EMPSphere_OnEMPSphereBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(EMPSphere_OnEMPSphereBeginOverlap) == 0x000008, "Wrong alignment on EMPSphere_OnEMPSphereBeginOverlap");
static_assert(sizeof(EMPSphere_OnEMPSphereBeginOverlap) == 0x0000A8, "Wrong size on EMPSphere_OnEMPSphereBeginOverlap");
static_assert(offsetof(EMPSphere_OnEMPSphereBeginOverlap, OverlappedComponent) == 0x000000, "Member 'EMPSphere_OnEMPSphereBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(EMPSphere_OnEMPSphereBeginOverlap, OtherActor) == 0x000008, "Member 'EMPSphere_OnEMPSphereBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(EMPSphere_OnEMPSphereBeginOverlap, OtherComp) == 0x000010, "Member 'EMPSphere_OnEMPSphereBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(EMPSphere_OnEMPSphereBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'EMPSphere_OnEMPSphereBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(EMPSphere_OnEMPSphereBeginOverlap, bFromSweep) == 0x00001C, "Member 'EMPSphere_OnEMPSphereBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(EMPSphere_OnEMPSphereBeginOverlap, SweepResult) == 0x000020, "Member 'EMPSphere_OnEMPSphereBeginOverlap::SweepResult' has a wrong offset!");

// Function DeceiveInc.EMPSphere.OnEMPSphereEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct EMPSphere_OnEMPSphereEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(EMPSphere_OnEMPSphereEndOverlap) == 0x000008, "Wrong alignment on EMPSphere_OnEMPSphereEndOverlap");
static_assert(sizeof(EMPSphere_OnEMPSphereEndOverlap) == 0x000020, "Wrong size on EMPSphere_OnEMPSphereEndOverlap");
static_assert(offsetof(EMPSphere_OnEMPSphereEndOverlap, OverlappedComponent) == 0x000000, "Member 'EMPSphere_OnEMPSphereEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(EMPSphere_OnEMPSphereEndOverlap, OtherActor) == 0x000008, "Member 'EMPSphere_OnEMPSphereEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(EMPSphere_OnEMPSphereEndOverlap, OtherComp) == 0x000010, "Member 'EMPSphere_OnEMPSphereEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(EMPSphere_OnEMPSphereEndOverlap, OtherBodyIndex) == 0x000018, "Member 'EMPSphere_OnEMPSphereEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function DeceiveInc.EMPSphere.SetVictim
// 0x0008 (0x0008 - 0x0000)
struct EMPSphere_SetVictim final
{
public:
	class AActor*                                 NewOwner;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EMPSphere_SetVictim) == 0x000008, "Wrong alignment on EMPSphere_SetVictim");
static_assert(sizeof(EMPSphere_SetVictim) == 0x000008, "Wrong size on EMPSphere_SetVictim");
static_assert(offsetof(EMPSphere_SetVictim, NewOwner) == 0x000000, "Member 'EMPSphere_SetVictim::NewOwner' has a wrong offset!");

// Function DeceiveInc.DIFactionsManager.BP_IsFreeForAll
// 0x0010 (0x0010 - 0x0000)
struct DIFactionsManager_BP_IsFreeForAll final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIFactionsManager_BP_IsFreeForAll) == 0x000008, "Wrong alignment on DIFactionsManager_BP_IsFreeForAll");
static_assert(sizeof(DIFactionsManager_BP_IsFreeForAll) == 0x000010, "Wrong size on DIFactionsManager_BP_IsFreeForAll");
static_assert(offsetof(DIFactionsManager_BP_IsFreeForAll, WorldContextObject) == 0x000000, "Member 'DIFactionsManager_BP_IsFreeForAll::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DIFactionsManager_BP_IsFreeForAll, ReturnValue) == 0x000008, "Member 'DIFactionsManager_BP_IsFreeForAll::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIFactionsManager.GetFactionId
// 0x0010 (0x0010 - 0x0000)
struct DIFactionsManager_GetFactionId final
{
public:
	const class AActor*                           ToCheck;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIFactionsManager_GetFactionId) == 0x000008, "Wrong alignment on DIFactionsManager_GetFactionId");
static_assert(sizeof(DIFactionsManager_GetFactionId) == 0x000010, "Wrong size on DIFactionsManager_GetFactionId");
static_assert(offsetof(DIFactionsManager_GetFactionId, ToCheck) == 0x000000, "Member 'DIFactionsManager_GetFactionId::ToCheck' has a wrong offset!");
static_assert(offsetof(DIFactionsManager_GetFactionId, ReturnValue) == 0x000008, "Member 'DIFactionsManager_GetFactionId::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIFactionsManager.GetFactionMembers
// 0x0018 (0x0018 - 0x0000)
struct DIFactionsManager_GetFactionMembers final
{
public:
	uint8                                         FactionID;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADIPlayerState*>                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIFactionsManager_GetFactionMembers) == 0x000008, "Wrong alignment on DIFactionsManager_GetFactionMembers");
static_assert(sizeof(DIFactionsManager_GetFactionMembers) == 0x000018, "Wrong size on DIFactionsManager_GetFactionMembers");
static_assert(offsetof(DIFactionsManager_GetFactionMembers, FactionID) == 0x000000, "Member 'DIFactionsManager_GetFactionMembers::FactionID' has a wrong offset!");
static_assert(offsetof(DIFactionsManager_GetFactionMembers, ReturnValue) == 0x000008, "Member 'DIFactionsManager_GetFactionMembers::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIFactionsManager.GetFactionMembersIndex
// 0x0010 (0x0010 - 0x0000)
struct DIFactionsManager_GetFactionMembersIndex final
{
public:
	class ADIPlayerState*                         Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIFactionsManager_GetFactionMembersIndex) == 0x000008, "Wrong alignment on DIFactionsManager_GetFactionMembersIndex");
static_assert(sizeof(DIFactionsManager_GetFactionMembersIndex) == 0x000010, "Wrong size on DIFactionsManager_GetFactionMembersIndex");
static_assert(offsetof(DIFactionsManager_GetFactionMembersIndex, Player) == 0x000000, "Member 'DIFactionsManager_GetFactionMembersIndex::Player' has a wrong offset!");
static_assert(offsetof(DIFactionsManager_GetFactionMembersIndex, ReturnValue) == 0x000008, "Member 'DIFactionsManager_GetFactionMembersIndex::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIFactionsManager.GetFactionSize
// 0x0001 (0x0001 - 0x0000)
struct DIFactionsManager_GetFactionSize final
{
public:
	uint8                                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIFactionsManager_GetFactionSize) == 0x000001, "Wrong alignment on DIFactionsManager_GetFactionSize");
static_assert(sizeof(DIFactionsManager_GetFactionSize) == 0x000001, "Wrong size on DIFactionsManager_GetFactionSize");
static_assert(offsetof(DIFactionsManager_GetFactionSize, ReturnValue) == 0x000000, "Member 'DIFactionsManager_GetFactionSize::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIFactionsManager.GetPlayerFactionMembers
// 0x0018 (0x0018 - 0x0000)
struct DIFactionsManager_GetPlayerFactionMembers final
{
public:
	class ADIPlayerState*                         Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADIPlayerState*>                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIFactionsManager_GetPlayerFactionMembers) == 0x000008, "Wrong alignment on DIFactionsManager_GetPlayerFactionMembers");
static_assert(sizeof(DIFactionsManager_GetPlayerFactionMembers) == 0x000018, "Wrong size on DIFactionsManager_GetPlayerFactionMembers");
static_assert(offsetof(DIFactionsManager_GetPlayerFactionMembers, Player) == 0x000000, "Member 'DIFactionsManager_GetPlayerFactionMembers::Player' has a wrong offset!");
static_assert(offsetof(DIFactionsManager_GetPlayerFactionMembers, ReturnValue) == 0x000008, "Member 'DIFactionsManager_GetPlayerFactionMembers::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIFactionsManager.HandleNameChange
// 0x0018 (0x0018 - 0x0000)
struct DIFactionsManager_HandleNameChange final
{
public:
	class AController*                            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerName;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIFactionsManager_HandleNameChange) == 0x000008, "Wrong alignment on DIFactionsManager_HandleNameChange");
static_assert(sizeof(DIFactionsManager_HandleNameChange) == 0x000018, "Wrong size on DIFactionsManager_HandleNameChange");
static_assert(offsetof(DIFactionsManager_HandleNameChange, PlayerController) == 0x000000, "Member 'DIFactionsManager_HandleNameChange::PlayerController' has a wrong offset!");
static_assert(offsetof(DIFactionsManager_HandleNameChange, PlayerName) == 0x000008, "Member 'DIFactionsManager_HandleNameChange::PlayerName' has a wrong offset!");

// Function DeceiveInc.DIFactionsManager.HasAliveTeammates
// 0x0010 (0x0010 - 0x0000)
struct DIFactionsManager_HasAliveTeammates final
{
public:
	class ADIPlayerState*                         Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIFactionsManager_HasAliveTeammates) == 0x000008, "Wrong alignment on DIFactionsManager_HasAliveTeammates");
static_assert(sizeof(DIFactionsManager_HasAliveTeammates) == 0x000010, "Wrong size on DIFactionsManager_HasAliveTeammates");
static_assert(offsetof(DIFactionsManager_HasAliveTeammates, Player) == 0x000000, "Member 'DIFactionsManager_HasAliveTeammates::Player' has a wrong offset!");
static_assert(offsetof(DIFactionsManager_HasAliveTeammates, ReturnValue) == 0x000008, "Member 'DIFactionsManager_HasAliveTeammates::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIUserWidget.HandleHideLocalWidget
// 0x0001 (0x0001 - 0x0000)
struct DIUserWidget_HandleHideLocalWidget final
{
public:
	bool                                          bHideHuds;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIUserWidget_HandleHideLocalWidget) == 0x000001, "Wrong alignment on DIUserWidget_HandleHideLocalWidget");
static_assert(sizeof(DIUserWidget_HandleHideLocalWidget) == 0x000001, "Wrong size on DIUserWidget_HandleHideLocalWidget");
static_assert(offsetof(DIUserWidget_HandleHideLocalWidget, bHideHuds) == 0x000000, "Member 'DIUserWidget_HandleHideLocalWidget::bHideHuds' has a wrong offset!");

// Function DeceiveInc.DIUserWidget.SetActorToFollow
// 0x0008 (0x0008 - 0x0000)
struct DIUserWidget_SetActorToFollow final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIUserWidget_SetActorToFollow) == 0x000008, "Wrong alignment on DIUserWidget_SetActorToFollow");
static_assert(sizeof(DIUserWidget_SetActorToFollow) == 0x000008, "Wrong size on DIUserWidget_SetActorToFollow");
static_assert(offsetof(DIUserWidget_SetActorToFollow, Actor) == 0x000000, "Member 'DIUserWidget_SetActorToFollow::Actor' has a wrong offset!");

// Function DeceiveInc.DIUserWidget.SetOffset
// 0x000C (0x000C - 0x0000)
struct DIUserWidget_SetOffset final
{
public:
	struct FVector                                NewOfsset;                                         // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIUserWidget_SetOffset) == 0x000004, "Wrong alignment on DIUserWidget_SetOffset");
static_assert(sizeof(DIUserWidget_SetOffset) == 0x00000C, "Wrong size on DIUserWidget_SetOffset");
static_assert(offsetof(DIUserWidget_SetOffset, NewOfsset) == 0x000000, "Member 'DIUserWidget_SetOffset::NewOfsset' has a wrong offset!");

// Function DeceiveInc.DIUserWidget.SetPosToFollow
// 0x000C (0x000C - 0x0000)
struct DIUserWidget_SetPosToFollow final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIUserWidget_SetPosToFollow) == 0x000004, "Wrong alignment on DIUserWidget_SetPosToFollow");
static_assert(sizeof(DIUserWidget_SetPosToFollow) == 0x00000C, "Wrong size on DIUserWidget_SetPosToFollow");
static_assert(offsetof(DIUserWidget_SetPosToFollow, Position) == 0x000000, "Member 'DIUserWidget_SetPosToFollow::Position' has a wrong offset!");

// Function DeceiveInc.DIUserWidget.GetCurrentWidgetFade
// 0x0004 (0x0004 - 0x0000)
struct DIUserWidget_GetCurrentWidgetFade final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIUserWidget_GetCurrentWidgetFade) == 0x000004, "Wrong alignment on DIUserWidget_GetCurrentWidgetFade");
static_assert(sizeof(DIUserWidget_GetCurrentWidgetFade) == 0x000004, "Wrong size on DIUserWidget_GetCurrentWidgetFade");
static_assert(offsetof(DIUserWidget_GetCurrentWidgetFade, ReturnValue) == 0x000000, "Member 'DIUserWidget_GetCurrentWidgetFade::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NavigationUserWidget.GetOwnerActor
// 0x0008 (0x0008 - 0x0000)
struct NavigationUserWidget_GetOwnerActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavigationUserWidget_GetOwnerActor) == 0x000008, "Wrong alignment on NavigationUserWidget_GetOwnerActor");
static_assert(sizeof(NavigationUserWidget_GetOwnerActor) == 0x000008, "Wrong size on NavigationUserWidget_GetOwnerActor");
static_assert(offsetof(NavigationUserWidget_GetOwnerActor, ReturnValue) == 0x000000, "Member 'NavigationUserWidget_GetOwnerActor::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NavigationUserWidget.OnNewDistance
// 0x0004 (0x0004 - 0x0000)
struct NavigationUserWidget_OnNewDistance final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavigationUserWidget_OnNewDistance) == 0x000004, "Wrong alignment on NavigationUserWidget_OnNewDistance");
static_assert(sizeof(NavigationUserWidget_OnNewDistance) == 0x000004, "Wrong size on NavigationUserWidget_OnNewDistance");
static_assert(offsetof(NavigationUserWidget_OnNewDistance, Distance) == 0x000000, "Member 'NavigationUserWidget_OnNewDistance::Distance' has a wrong offset!");

// Function DeceiveInc.NavigationUserWidget.SetOwnerActor
// 0x0008 (0x0008 - 0x0000)
struct NavigationUserWidget_SetOwnerActor final
{
public:
	class AActor*                                 NewOwner;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavigationUserWidget_SetOwnerActor) == 0x000008, "Wrong alignment on NavigationUserWidget_SetOwnerActor");
static_assert(sizeof(NavigationUserWidget_SetOwnerActor) == 0x000008, "Wrong size on NavigationUserWidget_SetOwnerActor");
static_assert(offsetof(NavigationUserWidget_SetOwnerActor, NewOwner) == 0x000000, "Member 'NavigationUserWidget_SetOwnerActor::NewOwner' has a wrong offset!");

// Function DeceiveInc.FacingUserWidget.OnNewOwner
// 0x0008 (0x0008 - 0x0000)
struct FacingUserWidget_OnNewOwner final
{
public:
	class AActor*                                 NewOwner;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FacingUserWidget_OnNewOwner) == 0x000008, "Wrong alignment on FacingUserWidget_OnNewOwner");
static_assert(sizeof(FacingUserWidget_OnNewOwner) == 0x000008, "Wrong size on FacingUserWidget_OnNewOwner");
static_assert(offsetof(FacingUserWidget_OnNewOwner, NewOwner) == 0x000000, "Member 'FacingUserWidget_OnNewOwner::NewOwner' has a wrong offset!");

// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.GetCameraComponent
// 0x0008 (0x0008 - 0x0000)
struct DIFreecamSettingsMenuUserWidget_GetCameraComponent final
{
public:
	class UCameraComponent*                       ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIFreecamSettingsMenuUserWidget_GetCameraComponent) == 0x000008, "Wrong alignment on DIFreecamSettingsMenuUserWidget_GetCameraComponent");
static_assert(sizeof(DIFreecamSettingsMenuUserWidget_GetCameraComponent) == 0x000008, "Wrong size on DIFreecamSettingsMenuUserWidget_GetCameraComponent");
static_assert(offsetof(DIFreecamSettingsMenuUserWidget_GetCameraComponent, ReturnValue) == 0x000000, "Member 'DIFreecamSettingsMenuUserWidget_GetCameraComponent::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.SetAcceleration
// 0x0004 (0x0004 - 0x0000)
struct DIFreecamSettingsMenuUserWidget_SetAcceleration final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIFreecamSettingsMenuUserWidget_SetAcceleration) == 0x000004, "Wrong alignment on DIFreecamSettingsMenuUserWidget_SetAcceleration");
static_assert(sizeof(DIFreecamSettingsMenuUserWidget_SetAcceleration) == 0x000004, "Wrong size on DIFreecamSettingsMenuUserWidget_SetAcceleration");
static_assert(offsetof(DIFreecamSettingsMenuUserWidget_SetAcceleration, NewValue) == 0x000000, "Member 'DIFreecamSettingsMenuUserWidget_SetAcceleration::NewValue' has a wrong offset!");

// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.SetCollisionsEnabled
// 0x0001 (0x0001 - 0x0000)
struct DIFreecamSettingsMenuUserWidget_SetCollisionsEnabled final
{
public:
	bool                                          NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIFreecamSettingsMenuUserWidget_SetCollisionsEnabled) == 0x000001, "Wrong alignment on DIFreecamSettingsMenuUserWidget_SetCollisionsEnabled");
static_assert(sizeof(DIFreecamSettingsMenuUserWidget_SetCollisionsEnabled) == 0x000001, "Wrong size on DIFreecamSettingsMenuUserWidget_SetCollisionsEnabled");
static_assert(offsetof(DIFreecamSettingsMenuUserWidget_SetCollisionsEnabled, NewValue) == 0x000000, "Member 'DIFreecamSettingsMenuUserWidget_SetCollisionsEnabled::NewValue' has a wrong offset!");

// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.SetDeceleration
// 0x0004 (0x0004 - 0x0000)
struct DIFreecamSettingsMenuUserWidget_SetDeceleration final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIFreecamSettingsMenuUserWidget_SetDeceleration) == 0x000004, "Wrong alignment on DIFreecamSettingsMenuUserWidget_SetDeceleration");
static_assert(sizeof(DIFreecamSettingsMenuUserWidget_SetDeceleration) == 0x000004, "Wrong size on DIFreecamSettingsMenuUserWidget_SetDeceleration");
static_assert(offsetof(DIFreecamSettingsMenuUserWidget_SetDeceleration, NewValue) == 0x000000, "Member 'DIFreecamSettingsMenuUserWidget_SetDeceleration::NewValue' has a wrong offset!");

// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.SetElevationLock
// 0x0001 (0x0001 - 0x0000)
struct DIFreecamSettingsMenuUserWidget_SetElevationLock final
{
public:
	bool                                          NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIFreecamSettingsMenuUserWidget_SetElevationLock) == 0x000001, "Wrong alignment on DIFreecamSettingsMenuUserWidget_SetElevationLock");
static_assert(sizeof(DIFreecamSettingsMenuUserWidget_SetElevationLock) == 0x000001, "Wrong size on DIFreecamSettingsMenuUserWidget_SetElevationLock");
static_assert(offsetof(DIFreecamSettingsMenuUserWidget_SetElevationLock, NewValue) == 0x000000, "Member 'DIFreecamSettingsMenuUserWidget_SetElevationLock::NewValue' has a wrong offset!");

// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.SetFOV
// 0x0004 (0x0004 - 0x0000)
struct DIFreecamSettingsMenuUserWidget_SetFOV final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIFreecamSettingsMenuUserWidget_SetFOV) == 0x000004, "Wrong alignment on DIFreecamSettingsMenuUserWidget_SetFOV");
static_assert(sizeof(DIFreecamSettingsMenuUserWidget_SetFOV) == 0x000004, "Wrong size on DIFreecamSettingsMenuUserWidget_SetFOV");
static_assert(offsetof(DIFreecamSettingsMenuUserWidget_SetFOV, NewValue) == 0x000000, "Member 'DIFreecamSettingsMenuUserWidget_SetFOV::NewValue' has a wrong offset!");

// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.SetMaxSpeed
// 0x0004 (0x0004 - 0x0000)
struct DIFreecamSettingsMenuUserWidget_SetMaxSpeed final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIFreecamSettingsMenuUserWidget_SetMaxSpeed) == 0x000004, "Wrong alignment on DIFreecamSettingsMenuUserWidget_SetMaxSpeed");
static_assert(sizeof(DIFreecamSettingsMenuUserWidget_SetMaxSpeed) == 0x000004, "Wrong size on DIFreecamSettingsMenuUserWidget_SetMaxSpeed");
static_assert(offsetof(DIFreecamSettingsMenuUserWidget_SetMaxSpeed, NewValue) == 0x000000, "Member 'DIFreecamSettingsMenuUserWidget_SetMaxSpeed::NewValue' has a wrong offset!");

// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.GetAcceleration
// 0x0004 (0x0004 - 0x0000)
struct DIFreecamSettingsMenuUserWidget_GetAcceleration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIFreecamSettingsMenuUserWidget_GetAcceleration) == 0x000004, "Wrong alignment on DIFreecamSettingsMenuUserWidget_GetAcceleration");
static_assert(sizeof(DIFreecamSettingsMenuUserWidget_GetAcceleration) == 0x000004, "Wrong size on DIFreecamSettingsMenuUserWidget_GetAcceleration");
static_assert(offsetof(DIFreecamSettingsMenuUserWidget_GetAcceleration, ReturnValue) == 0x000000, "Member 'DIFreecamSettingsMenuUserWidget_GetAcceleration::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.GetAccelerationLimit
// 0x0004 (0x0004 - 0x0000)
struct DIFreecamSettingsMenuUserWidget_GetAccelerationLimit final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIFreecamSettingsMenuUserWidget_GetAccelerationLimit) == 0x000004, "Wrong alignment on DIFreecamSettingsMenuUserWidget_GetAccelerationLimit");
static_assert(sizeof(DIFreecamSettingsMenuUserWidget_GetAccelerationLimit) == 0x000004, "Wrong size on DIFreecamSettingsMenuUserWidget_GetAccelerationLimit");
static_assert(offsetof(DIFreecamSettingsMenuUserWidget_GetAccelerationLimit, ReturnValue) == 0x000000, "Member 'DIFreecamSettingsMenuUserWidget_GetAccelerationLimit::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.GetDeceleration
// 0x0004 (0x0004 - 0x0000)
struct DIFreecamSettingsMenuUserWidget_GetDeceleration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIFreecamSettingsMenuUserWidget_GetDeceleration) == 0x000004, "Wrong alignment on DIFreecamSettingsMenuUserWidget_GetDeceleration");
static_assert(sizeof(DIFreecamSettingsMenuUserWidget_GetDeceleration) == 0x000004, "Wrong size on DIFreecamSettingsMenuUserWidget_GetDeceleration");
static_assert(offsetof(DIFreecamSettingsMenuUserWidget_GetDeceleration, ReturnValue) == 0x000000, "Member 'DIFreecamSettingsMenuUserWidget_GetDeceleration::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.GetDecelerationLimit
// 0x0004 (0x0004 - 0x0000)
struct DIFreecamSettingsMenuUserWidget_GetDecelerationLimit final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIFreecamSettingsMenuUserWidget_GetDecelerationLimit) == 0x000004, "Wrong alignment on DIFreecamSettingsMenuUserWidget_GetDecelerationLimit");
static_assert(sizeof(DIFreecamSettingsMenuUserWidget_GetDecelerationLimit) == 0x000004, "Wrong size on DIFreecamSettingsMenuUserWidget_GetDecelerationLimit");
static_assert(offsetof(DIFreecamSettingsMenuUserWidget_GetDecelerationLimit, ReturnValue) == 0x000000, "Member 'DIFreecamSettingsMenuUserWidget_GetDecelerationLimit::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.GetElevationLock
// 0x0001 (0x0001 - 0x0000)
struct DIFreecamSettingsMenuUserWidget_GetElevationLock final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIFreecamSettingsMenuUserWidget_GetElevationLock) == 0x000001, "Wrong alignment on DIFreecamSettingsMenuUserWidget_GetElevationLock");
static_assert(sizeof(DIFreecamSettingsMenuUserWidget_GetElevationLock) == 0x000001, "Wrong size on DIFreecamSettingsMenuUserWidget_GetElevationLock");
static_assert(offsetof(DIFreecamSettingsMenuUserWidget_GetElevationLock, ReturnValue) == 0x000000, "Member 'DIFreecamSettingsMenuUserWidget_GetElevationLock::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.GetFOV
// 0x0004 (0x0004 - 0x0000)
struct DIFreecamSettingsMenuUserWidget_GetFOV final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIFreecamSettingsMenuUserWidget_GetFOV) == 0x000004, "Wrong alignment on DIFreecamSettingsMenuUserWidget_GetFOV");
static_assert(sizeof(DIFreecamSettingsMenuUserWidget_GetFOV) == 0x000004, "Wrong size on DIFreecamSettingsMenuUserWidget_GetFOV");
static_assert(offsetof(DIFreecamSettingsMenuUserWidget_GetFOV, ReturnValue) == 0x000000, "Member 'DIFreecamSettingsMenuUserWidget_GetFOV::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.GetMaxSpeed
// 0x0004 (0x0004 - 0x0000)
struct DIFreecamSettingsMenuUserWidget_GetMaxSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIFreecamSettingsMenuUserWidget_GetMaxSpeed) == 0x000004, "Wrong alignment on DIFreecamSettingsMenuUserWidget_GetMaxSpeed");
static_assert(sizeof(DIFreecamSettingsMenuUserWidget_GetMaxSpeed) == 0x000004, "Wrong size on DIFreecamSettingsMenuUserWidget_GetMaxSpeed");
static_assert(offsetof(DIFreecamSettingsMenuUserWidget_GetMaxSpeed, ReturnValue) == 0x000000, "Member 'DIFreecamSettingsMenuUserWidget_GetMaxSpeed::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.GetMaxSpeedLimit
// 0x0004 (0x0004 - 0x0000)
struct DIFreecamSettingsMenuUserWidget_GetMaxSpeedLimit final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIFreecamSettingsMenuUserWidget_GetMaxSpeedLimit) == 0x000004, "Wrong alignment on DIFreecamSettingsMenuUserWidget_GetMaxSpeedLimit");
static_assert(sizeof(DIFreecamSettingsMenuUserWidget_GetMaxSpeedLimit) == 0x000004, "Wrong size on DIFreecamSettingsMenuUserWidget_GetMaxSpeedLimit");
static_assert(offsetof(DIFreecamSettingsMenuUserWidget_GetMaxSpeedLimit, ReturnValue) == 0x000000, "Member 'DIFreecamSettingsMenuUserWidget_GetMaxSpeedLimit::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIFreecamSettingsMenuUserWidget.IsCollisionEnabled
// 0x0001 (0x0001 - 0x0000)
struct DIFreecamSettingsMenuUserWidget_IsCollisionEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIFreecamSettingsMenuUserWidget_IsCollisionEnabled) == 0x000001, "Wrong alignment on DIFreecamSettingsMenuUserWidget_IsCollisionEnabled");
static_assert(sizeof(DIFreecamSettingsMenuUserWidget_IsCollisionEnabled) == 0x000001, "Wrong size on DIFreecamSettingsMenuUserWidget_IsCollisionEnabled");
static_assert(offsetof(DIFreecamSettingsMenuUserWidget_IsCollisionEnabled, ReturnValue) == 0x000000, "Member 'DIFreecamSettingsMenuUserWidget_IsCollisionEnabled::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.GetClientInformation
// 0x0008 (0x0008 - 0x0000)
struct DIGameInstanceBase_GetClientInformation final
{
public:
	class UClientInformation*                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_GetClientInformation) == 0x000008, "Wrong alignment on DIGameInstanceBase_GetClientInformation");
static_assert(sizeof(DIGameInstanceBase_GetClientInformation) == 0x000008, "Wrong size on DIGameInstanceBase_GetClientInformation");
static_assert(offsetof(DIGameInstanceBase_GetClientInformation, ReturnValue) == 0x000000, "Member 'DIGameInstanceBase_GetClientInformation::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.GetGameplayEventBus
// 0x0010 (0x0010 - 0x0000)
struct DIGameInstanceBase_GetGameplayEventBus final
{
public:
	const class AActor*                           Requester;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayEventBus*                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_GetGameplayEventBus) == 0x000008, "Wrong alignment on DIGameInstanceBase_GetGameplayEventBus");
static_assert(sizeof(DIGameInstanceBase_GetGameplayEventBus) == 0x000010, "Wrong size on DIGameInstanceBase_GetGameplayEventBus");
static_assert(offsetof(DIGameInstanceBase_GetGameplayEventBus, Requester) == 0x000000, "Member 'DIGameInstanceBase_GetGameplayEventBus::Requester' has a wrong offset!");
static_assert(offsetof(DIGameInstanceBase_GetGameplayEventBus, ReturnValue) == 0x000008, "Member 'DIGameInstanceBase_GetGameplayEventBus::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.GetLocalSpyEventBus
// 0x0010 (0x0010 - 0x0000)
struct DIGameInstanceBase_GetLocalSpyEventBus final
{
public:
	const class AActor*                           Requester;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULocalSpyEventBus*                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_GetLocalSpyEventBus) == 0x000008, "Wrong alignment on DIGameInstanceBase_GetLocalSpyEventBus");
static_assert(sizeof(DIGameInstanceBase_GetLocalSpyEventBus) == 0x000010, "Wrong size on DIGameInstanceBase_GetLocalSpyEventBus");
static_assert(offsetof(DIGameInstanceBase_GetLocalSpyEventBus, Requester) == 0x000000, "Member 'DIGameInstanceBase_GetLocalSpyEventBus::Requester' has a wrong offset!");
static_assert(offsetof(DIGameInstanceBase_GetLocalSpyEventBus, ReturnValue) == 0x000008, "Member 'DIGameInstanceBase_GetLocalSpyEventBus::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.IsCertTestingMode
// 0x0001 (0x0001 - 0x0000)
struct DIGameInstanceBase_IsCertTestingMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_IsCertTestingMode) == 0x000001, "Wrong alignment on DIGameInstanceBase_IsCertTestingMode");
static_assert(sizeof(DIGameInstanceBase_IsCertTestingMode) == 0x000001, "Wrong size on DIGameInstanceBase_IsCertTestingMode");
static_assert(offsetof(DIGameInstanceBase_IsCertTestingMode, ReturnValue) == 0x000000, "Member 'DIGameInstanceBase_IsCertTestingMode::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.IsDedicatedServerInstance
// 0x0001 (0x0001 - 0x0000)
struct DIGameInstanceBase_IsDedicatedServerInstance final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_IsDedicatedServerInstance) == 0x000001, "Wrong alignment on DIGameInstanceBase_IsDedicatedServerInstance");
static_assert(sizeof(DIGameInstanceBase_IsDedicatedServerInstance) == 0x000001, "Wrong size on DIGameInstanceBase_IsDedicatedServerInstance");
static_assert(offsetof(DIGameInstanceBase_IsDedicatedServerInstance, ReturnValue) == 0x000000, "Member 'DIGameInstanceBase_IsDedicatedServerInstance::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.IsPlaytestBuild
// 0x0001 (0x0001 - 0x0000)
struct DIGameInstanceBase_IsPlaytestBuild final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_IsPlaytestBuild) == 0x000001, "Wrong alignment on DIGameInstanceBase_IsPlaytestBuild");
static_assert(sizeof(DIGameInstanceBase_IsPlaytestBuild) == 0x000001, "Wrong size on DIGameInstanceBase_IsPlaytestBuild");
static_assert(offsetof(DIGameInstanceBase_IsPlaytestBuild, ReturnValue) == 0x000000, "Member 'DIGameInstanceBase_IsPlaytestBuild::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.IsTrialApp
// 0x0001 (0x0001 - 0x0000)
struct DIGameInstanceBase_IsTrialApp final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_IsTrialApp) == 0x000001, "Wrong alignment on DIGameInstanceBase_IsTrialApp");
static_assert(sizeof(DIGameInstanceBase_IsTrialApp) == 0x000001, "Wrong size on DIGameInstanceBase_IsTrialApp");
static_assert(offsetof(DIGameInstanceBase_IsTrialApp, ReturnValue) == 0x000000, "Member 'DIGameInstanceBase_IsTrialApp::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.DebugAddNativePlayer
// 0x0010 (0x0010 - 0x0000)
struct DIGameInstanceBase_DebugAddNativePlayer final
{
public:
	class FString                                 ABId;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_DebugAddNativePlayer) == 0x000008, "Wrong alignment on DIGameInstanceBase_DebugAddNativePlayer");
static_assert(sizeof(DIGameInstanceBase_DebugAddNativePlayer) == 0x000010, "Wrong size on DIGameInstanceBase_DebugAddNativePlayer");
static_assert(offsetof(DIGameInstanceBase_DebugAddNativePlayer, ABId) == 0x000000, "Member 'DIGameInstanceBase_DebugAddNativePlayer::ABId' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.GetEULAAgreementText
// 0x0030 (0x0030 - 0x0000)
struct DIGameInstanceBase_GetEULAAgreementText final
{
public:
	class FText                                   AgreementText;                                     // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_GetEULAAgreementText) == 0x000008, "Wrong alignment on DIGameInstanceBase_GetEULAAgreementText");
static_assert(sizeof(DIGameInstanceBase_GetEULAAgreementText) == 0x000030, "Wrong size on DIGameInstanceBase_GetEULAAgreementText");
static_assert(offsetof(DIGameInstanceBase_GetEULAAgreementText, AgreementText) == 0x000000, "Member 'DIGameInstanceBase_GetEULAAgreementText::AgreementText' has a wrong offset!");
static_assert(offsetof(DIGameInstanceBase_GetEULAAgreementText, ReturnValue) == 0x000018, "Member 'DIGameInstanceBase_GetEULAAgreementText::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.GetPlayerNickname
// 0x0010 (0x0010 - 0x0000)
struct DIGameInstanceBase_GetPlayerNickname final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_GetPlayerNickname) == 0x000008, "Wrong alignment on DIGameInstanceBase_GetPlayerNickname");
static_assert(sizeof(DIGameInstanceBase_GetPlayerNickname) == 0x000010, "Wrong size on DIGameInstanceBase_GetPlayerNickname");
static_assert(offsetof(DIGameInstanceBase_GetPlayerNickname, ReturnValue) == 0x000000, "Member 'DIGameInstanceBase_GetPlayerNickname::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.HandleDoFetchAgreementResponse
// 0x0058 (0x0058 - 0x0000)
struct DIGameInstanceBase_HandleDoFetchAgreementResponse final
{
public:
	class FString                                 AgreementName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAgreementResponse                     Response;                                          // 0x0010(0x0030)(Parm, NativeAccessSpecifierPublic)
	class FString                                 Error;                                             // 0x0040(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasAlreadySigned;                                 // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIGameInstanceBase_HandleDoFetchAgreementResponse) == 0x000008, "Wrong alignment on DIGameInstanceBase_HandleDoFetchAgreementResponse");
static_assert(sizeof(DIGameInstanceBase_HandleDoFetchAgreementResponse) == 0x000058, "Wrong size on DIGameInstanceBase_HandleDoFetchAgreementResponse");
static_assert(offsetof(DIGameInstanceBase_HandleDoFetchAgreementResponse, AgreementName) == 0x000000, "Member 'DIGameInstanceBase_HandleDoFetchAgreementResponse::AgreementName' has a wrong offset!");
static_assert(offsetof(DIGameInstanceBase_HandleDoFetchAgreementResponse, Response) == 0x000010, "Member 'DIGameInstanceBase_HandleDoFetchAgreementResponse::Response' has a wrong offset!");
static_assert(offsetof(DIGameInstanceBase_HandleDoFetchAgreementResponse, Error) == 0x000040, "Member 'DIGameInstanceBase_HandleDoFetchAgreementResponse::Error' has a wrong offset!");
static_assert(offsetof(DIGameInstanceBase_HandleDoFetchAgreementResponse, bWasAlreadySigned) == 0x000050, "Member 'DIGameInstanceBase_HandleDoFetchAgreementResponse::bWasAlreadySigned' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.HandleDoSignAgreementResponse
// 0x0058 (0x0058 - 0x0000)
struct DIGameInstanceBase_HandleDoSignAgreementResponse final
{
public:
	class FString                                 AgreementName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAgreementResponse                     Response;                                          // 0x0010(0x0030)(Parm, NativeAccessSpecifierPublic)
	class FString                                 Error;                                             // 0x0040(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeenSigned;                                    // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIGameInstanceBase_HandleDoSignAgreementResponse) == 0x000008, "Wrong alignment on DIGameInstanceBase_HandleDoSignAgreementResponse");
static_assert(sizeof(DIGameInstanceBase_HandleDoSignAgreementResponse) == 0x000058, "Wrong size on DIGameInstanceBase_HandleDoSignAgreementResponse");
static_assert(offsetof(DIGameInstanceBase_HandleDoSignAgreementResponse, AgreementName) == 0x000000, "Member 'DIGameInstanceBase_HandleDoSignAgreementResponse::AgreementName' has a wrong offset!");
static_assert(offsetof(DIGameInstanceBase_HandleDoSignAgreementResponse, Response) == 0x000010, "Member 'DIGameInstanceBase_HandleDoSignAgreementResponse::Response' has a wrong offset!");
static_assert(offsetof(DIGameInstanceBase_HandleDoSignAgreementResponse, Error) == 0x000040, "Member 'DIGameInstanceBase_HandleDoSignAgreementResponse::Error' has a wrong offset!");
static_assert(offsetof(DIGameInstanceBase_HandleDoSignAgreementResponse, bHasBeenSigned) == 0x000050, "Member 'DIGameInstanceBase_HandleDoSignAgreementResponse::bHasBeenSigned' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.HandleMenuEvent
// 0x0018 (0x0018 - 0x0000)
struct DIGameInstanceBase_HandleMenuEvent final
{
public:
	class FString                                 EventName;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AnswerValue;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIGameInstanceBase_HandleMenuEvent) == 0x000008, "Wrong alignment on DIGameInstanceBase_HandleMenuEvent");
static_assert(sizeof(DIGameInstanceBase_HandleMenuEvent) == 0x000018, "Wrong size on DIGameInstanceBase_HandleMenuEvent");
static_assert(offsetof(DIGameInstanceBase_HandleMenuEvent, EventName) == 0x000000, "Member 'DIGameInstanceBase_HandleMenuEvent::EventName' has a wrong offset!");
static_assert(offsetof(DIGameInstanceBase_HandleMenuEvent, AnswerValue) == 0x000010, "Member 'DIGameInstanceBase_HandleMenuEvent::AnswerValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.IsAppOwned
// 0x0001 (0x0001 - 0x0000)
struct DIGameInstanceBase_IsAppOwned final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_IsAppOwned) == 0x000001, "Wrong alignment on DIGameInstanceBase_IsAppOwned");
static_assert(sizeof(DIGameInstanceBase_IsAppOwned) == 0x000001, "Wrong size on DIGameInstanceBase_IsAppOwned");
static_assert(offsetof(DIGameInstanceBase_IsAppOwned, ReturnValue) == 0x000000, "Member 'DIGameInstanceBase_IsAppOwned::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.IsInLoginState
// 0x0002 (0x0002 - 0x0000)
struct DIGameInstanceBase_IsInLoginState final
{
public:
	EClientLoginStateFlags                        LoginState;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_IsInLoginState) == 0x000001, "Wrong alignment on DIGameInstanceBase_IsInLoginState");
static_assert(sizeof(DIGameInstanceBase_IsInLoginState) == 0x000002, "Wrong size on DIGameInstanceBase_IsInLoginState");
static_assert(offsetof(DIGameInstanceBase_IsInLoginState, LoginState) == 0x000000, "Member 'DIGameInstanceBase_IsInLoginState::LoginState' has a wrong offset!");
static_assert(offsetof(DIGameInstanceBase_IsInLoginState, ReturnValue) == 0x000001, "Member 'DIGameInstanceBase_IsInLoginState::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.IsInMainMenuMap
// 0x0001 (0x0001 - 0x0000)
struct DIGameInstanceBase_IsInMainMenuMap final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_IsInMainMenuMap) == 0x000001, "Wrong alignment on DIGameInstanceBase_IsInMainMenuMap");
static_assert(sizeof(DIGameInstanceBase_IsInMainMenuMap) == 0x000001, "Wrong size on DIGameInstanceBase_IsInMainMenuMap");
static_assert(offsetof(DIGameInstanceBase_IsInMainMenuMap, ReturnValue) == 0x000000, "Member 'DIGameInstanceBase_IsInMainMenuMap::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.IsInPlayableMap
// 0x0001 (0x0001 - 0x0000)
struct DIGameInstanceBase_IsInPlayableMap final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_IsInPlayableMap) == 0x000001, "Wrong alignment on DIGameInstanceBase_IsInPlayableMap");
static_assert(sizeof(DIGameInstanceBase_IsInPlayableMap) == 0x000001, "Wrong size on DIGameInstanceBase_IsInPlayableMap");
static_assert(offsetof(DIGameInstanceBase_IsInPlayableMap, ReturnValue) == 0x000000, "Member 'DIGameInstanceBase_IsInPlayableMap::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.IsLinuxCL
// 0x0001 (0x0001 - 0x0000)
struct DIGameInstanceBase_IsLinuxCL final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_IsLinuxCL) == 0x000001, "Wrong alignment on DIGameInstanceBase_IsLinuxCL");
static_assert(sizeof(DIGameInstanceBase_IsLinuxCL) == 0x000001, "Wrong size on DIGameInstanceBase_IsLinuxCL");
static_assert(offsetof(DIGameInstanceBase_IsLinuxCL, ReturnValue) == 0x000000, "Member 'DIGameInstanceBase_IsLinuxCL::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.OnDIWebServiceLoginCompleted
// 0x0020 (0x0020 - 0x0000)
struct DIGameInstanceBase_OnDIWebServiceLoginCompleted final
{
public:
	struct FLoginResponse                         LoginResponse;                                     // 0x0000(0x0020)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_OnDIWebServiceLoginCompleted) == 0x000008, "Wrong alignment on DIGameInstanceBase_OnDIWebServiceLoginCompleted");
static_assert(sizeof(DIGameInstanceBase_OnDIWebServiceLoginCompleted) == 0x000020, "Wrong size on DIGameInstanceBase_OnDIWebServiceLoginCompleted");
static_assert(offsetof(DIGameInstanceBase_OnDIWebServiceLoginCompleted, LoginResponse) == 0x000000, "Member 'DIGameInstanceBase_OnDIWebServiceLoginCompleted::LoginResponse' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.SetCurrentState
// 0x0008 (0x0008 - 0x0000)
struct DIGameInstanceBase_SetCurrentState final
{
public:
	class FName                                   NewState;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_SetCurrentState) == 0x000004, "Wrong alignment on DIGameInstanceBase_SetCurrentState");
static_assert(sizeof(DIGameInstanceBase_SetCurrentState) == 0x000008, "Wrong size on DIGameInstanceBase_SetCurrentState");
static_assert(offsetof(DIGameInstanceBase_SetCurrentState, NewState) == 0x000000, "Member 'DIGameInstanceBase_SetCurrentState::NewState' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.ShowPlatformSpecificPlayerDetails
// 0x0008 (0x0008 - 0x0000)
struct DIGameInstanceBase_ShowPlatformSpecificPlayerDetails final
{
public:
	class UDIOnlineFriendInfo*                    Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_ShowPlatformSpecificPlayerDetails) == 0x000008, "Wrong alignment on DIGameInstanceBase_ShowPlatformSpecificPlayerDetails");
static_assert(sizeof(DIGameInstanceBase_ShowPlatformSpecificPlayerDetails) == 0x000008, "Wrong size on DIGameInstanceBase_ShowPlatformSpecificPlayerDetails");
static_assert(offsetof(DIGameInstanceBase_ShowPlatformSpecificPlayerDetails, Player) == 0x000000, "Member 'DIGameInstanceBase_ShowPlatformSpecificPlayerDetails::Player' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.ShowPlatformSpecificPlayerDetailsForPlayer
// 0x0008 (0x0008 - 0x0000)
struct DIGameInstanceBase_ShowPlatformSpecificPlayerDetailsForPlayer final
{
public:
	class ADIPlayerState*                         Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_ShowPlatformSpecificPlayerDetailsForPlayer) == 0x000008, "Wrong alignment on DIGameInstanceBase_ShowPlatformSpecificPlayerDetailsForPlayer");
static_assert(sizeof(DIGameInstanceBase_ShowPlatformSpecificPlayerDetailsForPlayer) == 0x000008, "Wrong size on DIGameInstanceBase_ShowPlatformSpecificPlayerDetailsForPlayer");
static_assert(offsetof(DIGameInstanceBase_ShowPlatformSpecificPlayerDetailsForPlayer, Player) == 0x000000, "Member 'DIGameInstanceBase_ShowPlatformSpecificPlayerDetailsForPlayer::Player' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.TestTrophyEvents
// 0x0018 (0x0018 - 0x0000)
struct DIGameInstanceBase_TestTrophyEvents final
{
public:
	class FString                                 TrophyId;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Progress;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIGameInstanceBase_TestTrophyEvents) == 0x000008, "Wrong alignment on DIGameInstanceBase_TestTrophyEvents");
static_assert(sizeof(DIGameInstanceBase_TestTrophyEvents) == 0x000018, "Wrong size on DIGameInstanceBase_TestTrophyEvents");
static_assert(offsetof(DIGameInstanceBase_TestTrophyEvents, TrophyId) == 0x000000, "Member 'DIGameInstanceBase_TestTrophyEvents::TrophyId' has a wrong offset!");
static_assert(offsetof(DIGameInstanceBase_TestTrophyEvents, Progress) == 0x000010, "Member 'DIGameInstanceBase_TestTrophyEvents::Progress' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.TryRefreshClientSettings
// 0x0001 (0x0001 - 0x0000)
struct DIGameInstanceBase_TryRefreshClientSettings final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_TryRefreshClientSettings) == 0x000001, "Wrong alignment on DIGameInstanceBase_TryRefreshClientSettings");
static_assert(sizeof(DIGameInstanceBase_TryRefreshClientSettings) == 0x000001, "Wrong size on DIGameInstanceBase_TryRefreshClientSettings");
static_assert(offsetof(DIGameInstanceBase_TryRefreshClientSettings, ReturnValue) == 0x000000, "Member 'DIGameInstanceBase_TryRefreshClientSettings::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.GetAvailablePrivateLobbyRegions
// 0x0010 (0x0010 - 0x0000)
struct DIGameInstanceBase_GetAvailablePrivateLobbyRegions final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_GetAvailablePrivateLobbyRegions) == 0x000008, "Wrong alignment on DIGameInstanceBase_GetAvailablePrivateLobbyRegions");
static_assert(sizeof(DIGameInstanceBase_GetAvailablePrivateLobbyRegions) == 0x000010, "Wrong size on DIGameInstanceBase_GetAvailablePrivateLobbyRegions");
static_assert(offsetof(DIGameInstanceBase_GetAvailablePrivateLobbyRegions, ReturnValue) == 0x000000, "Member 'DIGameInstanceBase_GetAvailablePrivateLobbyRegions::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.GetCurrentFeatureLevel
// 0x0001 (0x0001 - 0x0000)
struct DIGameInstanceBase_GetCurrentFeatureLevel final
{
public:
	EAvaliableFeatureLevel                        ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_GetCurrentFeatureLevel) == 0x000001, "Wrong alignment on DIGameInstanceBase_GetCurrentFeatureLevel");
static_assert(sizeof(DIGameInstanceBase_GetCurrentFeatureLevel) == 0x000001, "Wrong size on DIGameInstanceBase_GetCurrentFeatureLevel");
static_assert(offsetof(DIGameInstanceBase_GetCurrentFeatureLevel, ReturnValue) == 0x000000, "Member 'DIGameInstanceBase_GetCurrentFeatureLevel::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.GetCurrentState
// 0x0008 (0x0008 - 0x0000)
struct DIGameInstanceBase_GetCurrentState final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_GetCurrentState) == 0x000004, "Wrong alignment on DIGameInstanceBase_GetCurrentState");
static_assert(sizeof(DIGameInstanceBase_GetCurrentState) == 0x000008, "Wrong size on DIGameInstanceBase_GetCurrentState");
static_assert(offsetof(DIGameInstanceBase_GetCurrentState, ReturnValue) == 0x000000, "Member 'DIGameInstanceBase_GetCurrentState::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.GetMaximumXPBoosterCount
// 0x0004 (0x0004 - 0x0000)
struct DIGameInstanceBase_GetMaximumXPBoosterCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_GetMaximumXPBoosterCount) == 0x000004, "Wrong alignment on DIGameInstanceBase_GetMaximumXPBoosterCount");
static_assert(sizeof(DIGameInstanceBase_GetMaximumXPBoosterCount) == 0x000004, "Wrong size on DIGameInstanceBase_GetMaximumXPBoosterCount");
static_assert(offsetof(DIGameInstanceBase_GetMaximumXPBoosterCount, ReturnValue) == 0x000000, "Member 'DIGameInstanceBase_GetMaximumXPBoosterCount::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.GetNetInfoClientSettings
// 0x0014 (0x0014 - 0x0000)
struct DIGameInstanceBase_GetNetInfoClientSettings final
{
public:
	struct FDINetInfoClientSettings               ReturnValue;                                       // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_GetNetInfoClientSettings) == 0x000004, "Wrong alignment on DIGameInstanceBase_GetNetInfoClientSettings");
static_assert(sizeof(DIGameInstanceBase_GetNetInfoClientSettings) == 0x000014, "Wrong size on DIGameInstanceBase_GetNetInfoClientSettings");
static_assert(offsetof(DIGameInstanceBase_GetNetInfoClientSettings, ReturnValue) == 0x000000, "Member 'DIGameInstanceBase_GetNetInfoClientSettings::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.GetVersionnedClientConfigSettings
// 0x0318 (0x0318 - 0x0000)
struct DIGameInstanceBase_GetVersionnedClientConfigSettings final
{
public:
	struct FDIVersionedClientConfigSettings       ReturnValue;                                       // 0x0000(0x0318)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_GetVersionnedClientConfigSettings) == 0x000008, "Wrong alignment on DIGameInstanceBase_GetVersionnedClientConfigSettings");
static_assert(sizeof(DIGameInstanceBase_GetVersionnedClientConfigSettings) == 0x000318, "Wrong size on DIGameInstanceBase_GetVersionnedClientConfigSettings");
static_assert(offsetof(DIGameInstanceBase_GetVersionnedClientConfigSettings, ReturnValue) == 0x000000, "Member 'DIGameInstanceBase_GetVersionnedClientConfigSettings::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.IsFeatureLevelAvailable
// 0x0002 (0x0002 - 0x0000)
struct DIGameInstanceBase_IsFeatureLevelAvailable final
{
public:
	EAvaliableFeatureLevel                        InFeatureLevel;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_IsFeatureLevelAvailable) == 0x000001, "Wrong alignment on DIGameInstanceBase_IsFeatureLevelAvailable");
static_assert(sizeof(DIGameInstanceBase_IsFeatureLevelAvailable) == 0x000002, "Wrong size on DIGameInstanceBase_IsFeatureLevelAvailable");
static_assert(offsetof(DIGameInstanceBase_IsFeatureLevelAvailable, InFeatureLevel) == 0x000000, "Member 'DIGameInstanceBase_IsFeatureLevelAvailable::InFeatureLevel' has a wrong offset!");
static_assert(offsetof(DIGameInstanceBase_IsFeatureLevelAvailable, ReturnValue) == 0x000001, "Member 'DIGameInstanceBase_IsFeatureLevelAvailable::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.IsGameModeAvailable
// 0x0002 (0x0002 - 0x0000)
struct DIGameInstanceBase_IsGameModeAvailable final
{
public:
	EModeAvaliability                             InMode;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_IsGameModeAvailable) == 0x000001, "Wrong alignment on DIGameInstanceBase_IsGameModeAvailable");
static_assert(sizeof(DIGameInstanceBase_IsGameModeAvailable) == 0x000002, "Wrong size on DIGameInstanceBase_IsGameModeAvailable");
static_assert(offsetof(DIGameInstanceBase_IsGameModeAvailable, InMode) == 0x000000, "Member 'DIGameInstanceBase_IsGameModeAvailable::InMode' has a wrong offset!");
static_assert(offsetof(DIGameInstanceBase_IsGameModeAvailable, ReturnValue) == 0x000001, "Member 'DIGameInstanceBase_IsGameModeAvailable::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameInstanceBase.WasLegalScreenShown
// 0x0001 (0x0001 - 0x0000)
struct DIGameInstanceBase_WasLegalScreenShown final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameInstanceBase_WasLegalScreenShown) == 0x000001, "Wrong alignment on DIGameInstanceBase_WasLegalScreenShown");
static_assert(sizeof(DIGameInstanceBase_WasLegalScreenShown) == 0x000001, "Wrong size on DIGameInstanceBase_WasLegalScreenShown");
static_assert(offsetof(DIGameInstanceBase_WasLegalScreenShown, ReturnValue) == 0x000000, "Member 'DIGameInstanceBase_WasLegalScreenShown::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DropAtComponent.OnDropAtTimerEnd
// 0x0018 (0x0018 - 0x0000)
struct DropAtComponent_OnDropAtTimerEnd final
{
public:
	struct FVector                                EndPos;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               EndRotation;                                       // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DropAtComponent_OnDropAtTimerEnd) == 0x000004, "Wrong alignment on DropAtComponent_OnDropAtTimerEnd");
static_assert(sizeof(DropAtComponent_OnDropAtTimerEnd) == 0x000018, "Wrong size on DropAtComponent_OnDropAtTimerEnd");
static_assert(offsetof(DropAtComponent_OnDropAtTimerEnd, EndPos) == 0x000000, "Member 'DropAtComponent_OnDropAtTimerEnd::EndPos' has a wrong offset!");
static_assert(offsetof(DropAtComponent_OnDropAtTimerEnd, EndRotation) == 0x00000C, "Member 'DropAtComponent_OnDropAtTimerEnd::EndRotation' has a wrong offset!");

// Function DeceiveInc.DIGameRulesSubsystem.SetActiveRuleset
// 0x0002 (0x0002 - 0x0000)
struct DIGameRulesSubsystem_SetActiveRuleset final
{
public:
	EDIGameRuleset                                InNewRuleset;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBroadcastChange;                                  // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameRulesSubsystem_SetActiveRuleset) == 0x000001, "Wrong alignment on DIGameRulesSubsystem_SetActiveRuleset");
static_assert(sizeof(DIGameRulesSubsystem_SetActiveRuleset) == 0x000002, "Wrong size on DIGameRulesSubsystem_SetActiveRuleset");
static_assert(offsetof(DIGameRulesSubsystem_SetActiveRuleset, InNewRuleset) == 0x000000, "Member 'DIGameRulesSubsystem_SetActiveRuleset::InNewRuleset' has a wrong offset!");
static_assert(offsetof(DIGameRulesSubsystem_SetActiveRuleset, bBroadcastChange) == 0x000001, "Member 'DIGameRulesSubsystem_SetActiveRuleset::bBroadcastChange' has a wrong offset!");

// Function DeceiveInc.DIGameRulesSubsystem.GetActiveRuleset
// 0x0001 (0x0001 - 0x0000)
struct DIGameRulesSubsystem_GetActiveRuleset final
{
public:
	EDIGameRuleset                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameRulesSubsystem_GetActiveRuleset) == 0x000001, "Wrong alignment on DIGameRulesSubsystem_GetActiveRuleset");
static_assert(sizeof(DIGameRulesSubsystem_GetActiveRuleset) == 0x000001, "Wrong size on DIGameRulesSubsystem_GetActiveRuleset");
static_assert(offsetof(DIGameRulesSubsystem_GetActiveRuleset, ReturnValue) == 0x000000, "Member 'DIGameRulesSubsystem_GetActiveRuleset::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameRulesSubsystem.GetCorrespondingDataAsset
// 0x0018 (0x0018 - 0x0000)
struct DIGameRulesSubsystem_GetCorrespondingDataAsset final
{
public:
	class UDataAsset*                             InDataAsset;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDIGameRuleset                                InRuleset;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataAsset*                             ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameRulesSubsystem_GetCorrespondingDataAsset) == 0x000008, "Wrong alignment on DIGameRulesSubsystem_GetCorrespondingDataAsset");
static_assert(sizeof(DIGameRulesSubsystem_GetCorrespondingDataAsset) == 0x000018, "Wrong size on DIGameRulesSubsystem_GetCorrespondingDataAsset");
static_assert(offsetof(DIGameRulesSubsystem_GetCorrespondingDataAsset, InDataAsset) == 0x000000, "Member 'DIGameRulesSubsystem_GetCorrespondingDataAsset::InDataAsset' has a wrong offset!");
static_assert(offsetof(DIGameRulesSubsystem_GetCorrespondingDataAsset, InRuleset) == 0x000008, "Member 'DIGameRulesSubsystem_GetCorrespondingDataAsset::InRuleset' has a wrong offset!");
static_assert(offsetof(DIGameRulesSubsystem_GetCorrespondingDataAsset, ReturnValue) == 0x000010, "Member 'DIGameRulesSubsystem_GetCorrespondingDataAsset::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameRulesSubsystem.GetCorrespondingDataTable
// 0x0018 (0x0018 - 0x0000)
struct DIGameRulesSubsystem_GetCorrespondingDataTable final
{
public:
	class UDataTable*                             InDataTable;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDIGameRuleset                                InRuleset;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameRulesSubsystem_GetCorrespondingDataTable) == 0x000008, "Wrong alignment on DIGameRulesSubsystem_GetCorrespondingDataTable");
static_assert(sizeof(DIGameRulesSubsystem_GetCorrespondingDataTable) == 0x000018, "Wrong size on DIGameRulesSubsystem_GetCorrespondingDataTable");
static_assert(offsetof(DIGameRulesSubsystem_GetCorrespondingDataTable, InDataTable) == 0x000000, "Member 'DIGameRulesSubsystem_GetCorrespondingDataTable::InDataTable' has a wrong offset!");
static_assert(offsetof(DIGameRulesSubsystem_GetCorrespondingDataTable, InRuleset) == 0x000008, "Member 'DIGameRulesSubsystem_GetCorrespondingDataTable::InRuleset' has a wrong offset!");
static_assert(offsetof(DIGameRulesSubsystem_GetCorrespondingDataTable, ReturnValue) == 0x000010, "Member 'DIGameRulesSubsystem_GetCorrespondingDataTable::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameRulesSubsystem.GetCorrespondingObject
// 0x0018 (0x0018 - 0x0000)
struct DIGameRulesSubsystem_GetCorrespondingObject final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDIGameRuleset                                InRuleset;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameRulesSubsystem_GetCorrespondingObject) == 0x000008, "Wrong alignment on DIGameRulesSubsystem_GetCorrespondingObject");
static_assert(sizeof(DIGameRulesSubsystem_GetCorrespondingObject) == 0x000018, "Wrong size on DIGameRulesSubsystem_GetCorrespondingObject");
static_assert(offsetof(DIGameRulesSubsystem_GetCorrespondingObject, InObject) == 0x000000, "Member 'DIGameRulesSubsystem_GetCorrespondingObject::InObject' has a wrong offset!");
static_assert(offsetof(DIGameRulesSubsystem_GetCorrespondingObject, InRuleset) == 0x000008, "Member 'DIGameRulesSubsystem_GetCorrespondingObject::InRuleset' has a wrong offset!");
static_assert(offsetof(DIGameRulesSubsystem_GetCorrespondingObject, ReturnValue) == 0x000010, "Member 'DIGameRulesSubsystem_GetCorrespondingObject::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameRulesSubsystem.IsAtLeastOneSpecialRuleInUse
// 0x0002 (0x0002 - 0x0000)
struct DIGameRulesSubsystem_IsAtLeastOneSpecialRuleInUse final
{
public:
	EDISpecialRules                               InSpecialRule;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameRulesSubsystem_IsAtLeastOneSpecialRuleInUse) == 0x000001, "Wrong alignment on DIGameRulesSubsystem_IsAtLeastOneSpecialRuleInUse");
static_assert(sizeof(DIGameRulesSubsystem_IsAtLeastOneSpecialRuleInUse) == 0x000002, "Wrong size on DIGameRulesSubsystem_IsAtLeastOneSpecialRuleInUse");
static_assert(offsetof(DIGameRulesSubsystem_IsAtLeastOneSpecialRuleInUse, InSpecialRule) == 0x000000, "Member 'DIGameRulesSubsystem_IsAtLeastOneSpecialRuleInUse::InSpecialRule' has a wrong offset!");
static_assert(offsetof(DIGameRulesSubsystem_IsAtLeastOneSpecialRuleInUse, ReturnValue) == 0x000001, "Member 'DIGameRulesSubsystem_IsAtLeastOneSpecialRuleInUse::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameRulesSubsystem.IsSpecialRuleInUse
// 0x0002 (0x0002 - 0x0000)
struct DIGameRulesSubsystem_IsSpecialRuleInUse final
{
public:
	EDISpecialRules                               InSpecialRule;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameRulesSubsystem_IsSpecialRuleInUse) == 0x000001, "Wrong alignment on DIGameRulesSubsystem_IsSpecialRuleInUse");
static_assert(sizeof(DIGameRulesSubsystem_IsSpecialRuleInUse) == 0x000002, "Wrong size on DIGameRulesSubsystem_IsSpecialRuleInUse");
static_assert(offsetof(DIGameRulesSubsystem_IsSpecialRuleInUse, InSpecialRule) == 0x000000, "Member 'DIGameRulesSubsystem_IsSpecialRuleInUse::InSpecialRule' has a wrong offset!");
static_assert(offsetof(DIGameRulesSubsystem_IsSpecialRuleInUse, ReturnValue) == 0x000001, "Member 'DIGameRulesSubsystem_IsSpecialRuleInUse::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIGameServerWebServiceSession.SendReport
// 0x0040 (0x0040 - 0x0000)
struct DIGameServerWebServiceSession_SendReport final
{
public:
	class FString                                 Reporter;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Reportee;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchId;                                           // 0x0030(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIGameServerWebServiceSession_SendReport) == 0x000008, "Wrong alignment on DIGameServerWebServiceSession_SendReport");
static_assert(sizeof(DIGameServerWebServiceSession_SendReport) == 0x000040, "Wrong size on DIGameServerWebServiceSession_SendReport");
static_assert(offsetof(DIGameServerWebServiceSession_SendReport, Reporter) == 0x000000, "Member 'DIGameServerWebServiceSession_SendReport::Reporter' has a wrong offset!");
static_assert(offsetof(DIGameServerWebServiceSession_SendReport, Reportee) == 0x000010, "Member 'DIGameServerWebServiceSession_SendReport::Reportee' has a wrong offset!");
static_assert(offsetof(DIGameServerWebServiceSession_SendReport, Message) == 0x000020, "Member 'DIGameServerWebServiceSession_SendReport::Message' has a wrong offset!");
static_assert(offsetof(DIGameServerWebServiceSession_SendReport, MatchId) == 0x000030, "Member 'DIGameServerWebServiceSession_SendReport::MatchId' has a wrong offset!");

// Function DeceiveInc.DiKeybindActionEntryWidget.ListenForKeyBinding
// 0x0004 (0x0004 - 0x0000)
struct DiKeybindActionEntryWidget_ListenForKeyBinding final
{
public:
	int32                                         KeySlot;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiKeybindActionEntryWidget_ListenForKeyBinding) == 0x000004, "Wrong alignment on DiKeybindActionEntryWidget_ListenForKeyBinding");
static_assert(sizeof(DiKeybindActionEntryWidget_ListenForKeyBinding) == 0x000004, "Wrong size on DiKeybindActionEntryWidget_ListenForKeyBinding");
static_assert(offsetof(DiKeybindActionEntryWidget_ListenForKeyBinding, KeySlot) == 0x000000, "Member 'DiKeybindActionEntryWidget_ListenForKeyBinding::KeySlot' has a wrong offset!");

// Function DeceiveInc.DiKeybindActionEntryWidget.SetFromBindableKeyEntry
// 0x0050 (0x0050 - 0x0000)
struct DiKeybindActionEntryWidget_SetFromBindableKeyEntry final
{
public:
	struct FBindableKeyEntry                      Src;                                               // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiKeybindActionEntryWidget_SetFromBindableKeyEntry) == 0x000008, "Wrong alignment on DiKeybindActionEntryWidget_SetFromBindableKeyEntry");
static_assert(sizeof(DiKeybindActionEntryWidget_SetFromBindableKeyEntry) == 0x000050, "Wrong size on DiKeybindActionEntryWidget_SetFromBindableKeyEntry");
static_assert(offsetof(DiKeybindActionEntryWidget_SetFromBindableKeyEntry, Src) == 0x000000, "Member 'DiKeybindActionEntryWidget_SetFromBindableKeyEntry::Src' has a wrong offset!");

// Function DeceiveInc.DiKeybindActionEntryWidget.SetInputDeviceType
// 0x0001 (0x0001 - 0x0000)
struct DiKeybindActionEntryWidget_SetInputDeviceType final
{
public:
	EInputDeviceType                              InInputDevice;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiKeybindActionEntryWidget_SetInputDeviceType) == 0x000001, "Wrong alignment on DiKeybindActionEntryWidget_SetInputDeviceType");
static_assert(sizeof(DiKeybindActionEntryWidget_SetInputDeviceType) == 0x000001, "Wrong size on DiKeybindActionEntryWidget_SetInputDeviceType");
static_assert(offsetof(DiKeybindActionEntryWidget_SetInputDeviceType, InInputDevice) == 0x000000, "Member 'DiKeybindActionEntryWidget_SetInputDeviceType::InInputDevice' has a wrong offset!");

// Function DeceiveInc.DiKeybindActionEntryWidget.GetActionName
// 0x0010 (0x0010 - 0x0000)
struct DiKeybindActionEntryWidget_GetActionName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiKeybindActionEntryWidget_GetActionName) == 0x000008, "Wrong alignment on DiKeybindActionEntryWidget_GetActionName");
static_assert(sizeof(DiKeybindActionEntryWidget_GetActionName) == 0x000010, "Wrong size on DiKeybindActionEntryWidget_GetActionName");
static_assert(offsetof(DiKeybindActionEntryWidget_GetActionName, ReturnValue) == 0x000000, "Member 'DiKeybindActionEntryWidget_GetActionName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiKeybindActionEntryWidget.GetCategory
// 0x0001 (0x0001 - 0x0000)
struct DiKeybindActionEntryWidget_GetCategory final
{
public:
	EKeybindContext                               ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiKeybindActionEntryWidget_GetCategory) == 0x000001, "Wrong alignment on DiKeybindActionEntryWidget_GetCategory");
static_assert(sizeof(DiKeybindActionEntryWidget_GetCategory) == 0x000001, "Wrong size on DiKeybindActionEntryWidget_GetCategory");
static_assert(offsetof(DiKeybindActionEntryWidget_GetCategory, ReturnValue) == 0x000000, "Member 'DiKeybindActionEntryWidget_GetCategory::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiKeybindActionEntryWidget.GetDisplayName
// 0x0018 (0x0018 - 0x0000)
struct DiKeybindActionEntryWidget_GetDisplayName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiKeybindActionEntryWidget_GetDisplayName) == 0x000008, "Wrong alignment on DiKeybindActionEntryWidget_GetDisplayName");
static_assert(sizeof(DiKeybindActionEntryWidget_GetDisplayName) == 0x000018, "Wrong size on DiKeybindActionEntryWidget_GetDisplayName");
static_assert(offsetof(DiKeybindActionEntryWidget_GetDisplayName, ReturnValue) == 0x000000, "Member 'DiKeybindActionEntryWidget_GetDisplayName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiKeybindActionEntryWidget.GetScale
// 0x0004 (0x0004 - 0x0000)
struct DiKeybindActionEntryWidget_GetScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiKeybindActionEntryWidget_GetScale) == 0x000004, "Wrong alignment on DiKeybindActionEntryWidget_GetScale");
static_assert(sizeof(DiKeybindActionEntryWidget_GetScale) == 0x000004, "Wrong size on DiKeybindActionEntryWidget_GetScale");
static_assert(offsetof(DiKeybindActionEntryWidget_GetScale, ReturnValue) == 0x000000, "Member 'DiKeybindActionEntryWidget_GetScale::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiKeybindActionEntryWidget.IsTapAction
// 0x0001 (0x0001 - 0x0000)
struct DiKeybindActionEntryWidget_IsTapAction final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiKeybindActionEntryWidget_IsTapAction) == 0x000001, "Wrong alignment on DiKeybindActionEntryWidget_IsTapAction");
static_assert(sizeof(DiKeybindActionEntryWidget_IsTapAction) == 0x000001, "Wrong size on DiKeybindActionEntryWidget_IsTapAction");
static_assert(offsetof(DiKeybindActionEntryWidget_IsTapAction, ReturnValue) == 0x000000, "Member 'DiKeybindActionEntryWidget_IsTapAction::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiKeybindActionWidget.ListenForKeyBinding
// 0x0004 (0x0004 - 0x0000)
struct DiKeybindActionWidget_ListenForKeyBinding final
{
public:
	int32                                         KeySlot;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiKeybindActionWidget_ListenForKeyBinding) == 0x000004, "Wrong alignment on DiKeybindActionWidget_ListenForKeyBinding");
static_assert(sizeof(DiKeybindActionWidget_ListenForKeyBinding) == 0x000004, "Wrong size on DiKeybindActionWidget_ListenForKeyBinding");
static_assert(offsetof(DiKeybindActionWidget_ListenForKeyBinding, KeySlot) == 0x000000, "Member 'DiKeybindActionWidget_ListenForKeyBinding::KeySlot' has a wrong offset!");

// Function DeceiveInc.DiKeybindActionWidget.SetFromBindableKeyEntry
// 0x0050 (0x0050 - 0x0000)
struct DiKeybindActionWidget_SetFromBindableKeyEntry final
{
public:
	struct FBindableKeyEntry                      Src;                                               // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiKeybindActionWidget_SetFromBindableKeyEntry) == 0x000008, "Wrong alignment on DiKeybindActionWidget_SetFromBindableKeyEntry");
static_assert(sizeof(DiKeybindActionWidget_SetFromBindableKeyEntry) == 0x000050, "Wrong size on DiKeybindActionWidget_SetFromBindableKeyEntry");
static_assert(offsetof(DiKeybindActionWidget_SetFromBindableKeyEntry, Src) == 0x000000, "Member 'DiKeybindActionWidget_SetFromBindableKeyEntry::Src' has a wrong offset!");

// Function DeceiveInc.DiKeybindActionWidget.SetFromDiKeybindActionWidget
// 0x0008 (0x0008 - 0x0000)
struct DiKeybindActionWidget_SetFromDiKeybindActionWidget final
{
public:
	const class UDiKeybindActionWidget*           Src;                                               // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiKeybindActionWidget_SetFromDiKeybindActionWidget) == 0x000008, "Wrong alignment on DiKeybindActionWidget_SetFromDiKeybindActionWidget");
static_assert(sizeof(DiKeybindActionWidget_SetFromDiKeybindActionWidget) == 0x000008, "Wrong size on DiKeybindActionWidget_SetFromDiKeybindActionWidget");
static_assert(offsetof(DiKeybindActionWidget_SetFromDiKeybindActionWidget, Src) == 0x000000, "Member 'DiKeybindActionWidget_SetFromDiKeybindActionWidget::Src' has a wrong offset!");

// Function DeceiveInc.DIKillcamPlaybackManager.OnKillcamPlaybackComplete
// 0x0008 (0x0008 - 0x0000)
struct DIKillcamPlaybackManager_OnKillcamPlaybackComplete final
{
public:
	class UWorld*                                 PlaybackWorld;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIKillcamPlaybackManager_OnKillcamPlaybackComplete) == 0x000008, "Wrong alignment on DIKillcamPlaybackManager_OnKillcamPlaybackComplete");
static_assert(sizeof(DIKillcamPlaybackManager_OnKillcamPlaybackComplete) == 0x000008, "Wrong size on DIKillcamPlaybackManager_OnKillcamPlaybackComplete");
static_assert(offsetof(DIKillcamPlaybackManager_OnKillcamPlaybackComplete, PlaybackWorld) == 0x000000, "Member 'DIKillcamPlaybackManager_OnKillcamPlaybackComplete::PlaybackWorld' has a wrong offset!");

// Function DeceiveInc.DILoadingScreenWidget.BP_SetMapFlavor
// 0x0018 (0x0018 - 0x0000)
struct DILoadingScreenWidget_BP_SetMapFlavor final
{
public:
	class FText                                   FlavorText;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DILoadingScreenWidget_BP_SetMapFlavor) == 0x000008, "Wrong alignment on DILoadingScreenWidget_BP_SetMapFlavor");
static_assert(sizeof(DILoadingScreenWidget_BP_SetMapFlavor) == 0x000018, "Wrong size on DILoadingScreenWidget_BP_SetMapFlavor");
static_assert(offsetof(DILoadingScreenWidget_BP_SetMapFlavor, FlavorText) == 0x000000, "Member 'DILoadingScreenWidget_BP_SetMapFlavor::FlavorText' has a wrong offset!");

// Function DeceiveInc.DILoadingScreenWidget.BP_SetMapName
// 0x0018 (0x0018 - 0x0000)
struct DILoadingScreenWidget_BP_SetMapName final
{
public:
	class FText                                   Name_0;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DILoadingScreenWidget_BP_SetMapName) == 0x000008, "Wrong alignment on DILoadingScreenWidget_BP_SetMapName");
static_assert(sizeof(DILoadingScreenWidget_BP_SetMapName) == 0x000018, "Wrong size on DILoadingScreenWidget_BP_SetMapName");
static_assert(offsetof(DILoadingScreenWidget_BP_SetMapName, Name_0) == 0x000000, "Member 'DILoadingScreenWidget_BP_SetMapName::Name_0' has a wrong offset!");

// Function DeceiveInc.DILoadingScreenWidget.BP_SetMapSubtext
// 0x0018 (0x0018 - 0x0000)
struct DILoadingScreenWidget_BP_SetMapSubtext final
{
public:
	class FText                                   Subtext;                                           // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DILoadingScreenWidget_BP_SetMapSubtext) == 0x000008, "Wrong alignment on DILoadingScreenWidget_BP_SetMapSubtext");
static_assert(sizeof(DILoadingScreenWidget_BP_SetMapSubtext) == 0x000018, "Wrong size on DILoadingScreenWidget_BP_SetMapSubtext");
static_assert(offsetof(DILoadingScreenWidget_BP_SetMapSubtext, Subtext) == 0x000000, "Member 'DILoadingScreenWidget_BP_SetMapSubtext::Subtext' has a wrong offset!");

// Function DeceiveInc.DILoadingScreenWidget.BP_SetMapTexture
// 0x0028 (0x0028 - 0x0000)
struct DILoadingScreenWidget_BP_SetMapTexture final
{
public:
	TSoftObjectPtr<class UTexture2D>              MapTexture;                                        // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DILoadingScreenWidget_BP_SetMapTexture) == 0x000008, "Wrong alignment on DILoadingScreenWidget_BP_SetMapTexture");
static_assert(sizeof(DILoadingScreenWidget_BP_SetMapTexture) == 0x000028, "Wrong size on DILoadingScreenWidget_BP_SetMapTexture");
static_assert(offsetof(DILoadingScreenWidget_BP_SetMapTexture, MapTexture) == 0x000000, "Member 'DILoadingScreenWidget_BP_SetMapTexture::MapTexture' has a wrong offset!");

// Function DeceiveInc.DILoadingScreenWidget.BP_SetMapTexture2
// 0x0008 (0x0008 - 0x0000)
struct DILoadingScreenWidget_BP_SetMapTexture2 final
{
public:
	const class UTexture2D*                       MapTexture;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DILoadingScreenWidget_BP_SetMapTexture2) == 0x000008, "Wrong alignment on DILoadingScreenWidget_BP_SetMapTexture2");
static_assert(sizeof(DILoadingScreenWidget_BP_SetMapTexture2) == 0x000008, "Wrong size on DILoadingScreenWidget_BP_SetMapTexture2");
static_assert(offsetof(DILoadingScreenWidget_BP_SetMapTexture2, MapTexture) == 0x000000, "Member 'DILoadingScreenWidget_BP_SetMapTexture2::MapTexture' has a wrong offset!");

// Function DeceiveInc.DILoadSubsystem.BP_HideLoadingScreen
// 0x0008 (0x0008 - 0x0000)
struct DILoadSubsystem_BP_HideLoadingScreen final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DILoadSubsystem_BP_HideLoadingScreen) == 0x000008, "Wrong alignment on DILoadSubsystem_BP_HideLoadingScreen");
static_assert(sizeof(DILoadSubsystem_BP_HideLoadingScreen) == 0x000008, "Wrong size on DILoadSubsystem_BP_HideLoadingScreen");
static_assert(offsetof(DILoadSubsystem_BP_HideLoadingScreen, WorldContextObject) == 0x000000, "Member 'DILoadSubsystem_BP_HideLoadingScreen::WorldContextObject' has a wrong offset!");

// Function DeceiveInc.DILoadSubsystem.BP_ShowLoadingScreen
// 0x0008 (0x0008 - 0x0000)
struct DILoadSubsystem_BP_ShowLoadingScreen final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DILoadSubsystem_BP_ShowLoadingScreen) == 0x000008, "Wrong alignment on DILoadSubsystem_BP_ShowLoadingScreen");
static_assert(sizeof(DILoadSubsystem_BP_ShowLoadingScreen) == 0x000008, "Wrong size on DILoadSubsystem_BP_ShowLoadingScreen");
static_assert(offsetof(DILoadSubsystem_BP_ShowLoadingScreen, WorldContextObject) == 0x000000, "Member 'DILoadSubsystem_BP_ShowLoadingScreen::WorldContextObject' has a wrong offset!");

// Function DeceiveInc.DILoadSubsystem.PrepareLoading
// 0x0008 (0x0008 - 0x0000)
struct DILoadSubsystem_PrepareLoading final
{
public:
	const class UMapData*                         MapData;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DILoadSubsystem_PrepareLoading) == 0x000008, "Wrong alignment on DILoadSubsystem_PrepareLoading");
static_assert(sizeof(DILoadSubsystem_PrepareLoading) == 0x000008, "Wrong size on DILoadSubsystem_PrepareLoading");
static_assert(offsetof(DILoadSubsystem_PrepareLoading, MapData) == 0x000000, "Member 'DILoadSubsystem_PrepareLoading::MapData' has a wrong offset!");

// Function DeceiveInc.DILocalPlayer.IsInKillcam
// 0x0001 (0x0001 - 0x0000)
struct DILocalPlayer_IsInKillcam final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DILocalPlayer_IsInKillcam) == 0x000001, "Wrong alignment on DILocalPlayer_IsInKillcam");
static_assert(sizeof(DILocalPlayer_IsInKillcam) == 0x000001, "Wrong size on DILocalPlayer_IsInKillcam");
static_assert(offsetof(DILocalPlayer_IsInKillcam, ReturnValue) == 0x000000, "Member 'DILocalPlayer_IsInKillcam::ReturnValue' has a wrong offset!");

// Function DeceiveInc.GooPod.BP_OnToggleGoo
// 0x0001 (0x0001 - 0x0000)
struct GooPod_BP_OnToggleGoo final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GooPod_BP_OnToggleGoo) == 0x000001, "Wrong alignment on GooPod_BP_OnToggleGoo");
static_assert(sizeof(GooPod_BP_OnToggleGoo) == 0x000001, "Wrong size on GooPod_BP_OnToggleGoo");
static_assert(offsetof(GooPod_BP_OnToggleGoo, bActive) == 0x000000, "Member 'GooPod_BP_OnToggleGoo::bActive' has a wrong offset!");

// Function DeceiveInc.GooPod.HandleCollisionBoxBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct GooPod_HandleCollisionBoxBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GooPod_HandleCollisionBoxBeginOverlap) == 0x000008, "Wrong alignment on GooPod_HandleCollisionBoxBeginOverlap");
static_assert(sizeof(GooPod_HandleCollisionBoxBeginOverlap) == 0x0000A8, "Wrong size on GooPod_HandleCollisionBoxBeginOverlap");
static_assert(offsetof(GooPod_HandleCollisionBoxBeginOverlap, OverlappedComponent) == 0x000000, "Member 'GooPod_HandleCollisionBoxBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GooPod_HandleCollisionBoxBeginOverlap, OtherActor) == 0x000008, "Member 'GooPod_HandleCollisionBoxBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(GooPod_HandleCollisionBoxBeginOverlap, OtherComp) == 0x000010, "Member 'GooPod_HandleCollisionBoxBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(GooPod_HandleCollisionBoxBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'GooPod_HandleCollisionBoxBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(GooPod_HandleCollisionBoxBeginOverlap, bFromSweep) == 0x00001C, "Member 'GooPod_HandleCollisionBoxBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(GooPod_HandleCollisionBoxBeginOverlap, SweepResult) == 0x000020, "Member 'GooPod_HandleCollisionBoxBeginOverlap::SweepResult' has a wrong offset!");

// Function DeceiveInc.GooPod.HandleCollisionBoxEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct GooPod_HandleCollisionBoxEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GooPod_HandleCollisionBoxEndOverlap) == 0x000008, "Wrong alignment on GooPod_HandleCollisionBoxEndOverlap");
static_assert(sizeof(GooPod_HandleCollisionBoxEndOverlap) == 0x000020, "Wrong size on GooPod_HandleCollisionBoxEndOverlap");
static_assert(offsetof(GooPod_HandleCollisionBoxEndOverlap, OverlappedComponent) == 0x000000, "Member 'GooPod_HandleCollisionBoxEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GooPod_HandleCollisionBoxEndOverlap, OtherActor) == 0x000008, "Member 'GooPod_HandleCollisionBoxEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(GooPod_HandleCollisionBoxEndOverlap, OtherComp) == 0x000010, "Member 'GooPod_HandleCollisionBoxEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(GooPod_HandleCollisionBoxEndOverlap, OtherBodyIndex) == 0x000018, "Member 'GooPod_HandleCollisionBoxEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function DeceiveInc.GooPod.IsGooActive
// 0x0001 (0x0001 - 0x0000)
struct GooPod_IsGooActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GooPod_IsGooActive) == 0x000001, "Wrong alignment on GooPod_IsGooActive");
static_assert(sizeof(GooPod_IsGooActive) == 0x000001, "Wrong size on GooPod_IsGooActive");
static_assert(offsetof(GooPod_IsGooActive, ReturnValue) == 0x000000, "Member 'GooPod_IsGooActive::ReturnValue' has a wrong offset!");

// Function DeceiveInc.GooPod.NetMulticast_ToggleGoo
// 0x0001 (0x0001 - 0x0000)
struct GooPod_NetMulticast_ToggleGoo final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GooPod_NetMulticast_ToggleGoo) == 0x000001, "Wrong alignment on GooPod_NetMulticast_ToggleGoo");
static_assert(sizeof(GooPod_NetMulticast_ToggleGoo) == 0x000001, "Wrong size on GooPod_NetMulticast_ToggleGoo");
static_assert(offsetof(GooPod_NetMulticast_ToggleGoo, bActive) == 0x000000, "Member 'GooPod_NetMulticast_ToggleGoo::bActive' has a wrong offset!");

// Function DeceiveInc.GooPod.OnPreDropConfirmation
// 0x0001 (0x0001 - 0x0000)
struct GooPod_OnPreDropConfirmation final
{
public:
	bool                                          CanDropOut;                                        // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GooPod_OnPreDropConfirmation) == 0x000001, "Wrong alignment on GooPod_OnPreDropConfirmation");
static_assert(sizeof(GooPod_OnPreDropConfirmation) == 0x000001, "Wrong size on GooPod_OnPreDropConfirmation");
static_assert(offsetof(GooPod_OnPreDropConfirmation, CanDropOut) == 0x000000, "Member 'GooPod_OnPreDropConfirmation::CanDropOut' has a wrong offset!");

// Function DeceiveInc.DIMainMenuUserWidget.DisplayMenuPageByEnum
// 0x0001 (0x0001 - 0x0000)
struct DIMainMenuUserWidget_DisplayMenuPageByEnum final
{
public:
	EMainMenuPages                                MenuPage;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMainMenuUserWidget_DisplayMenuPageByEnum) == 0x000001, "Wrong alignment on DIMainMenuUserWidget_DisplayMenuPageByEnum");
static_assert(sizeof(DIMainMenuUserWidget_DisplayMenuPageByEnum) == 0x000001, "Wrong size on DIMainMenuUserWidget_DisplayMenuPageByEnum");
static_assert(offsetof(DIMainMenuUserWidget_DisplayMenuPageByEnum, MenuPage) == 0x000000, "Member 'DIMainMenuUserWidget_DisplayMenuPageByEnum::MenuPage' has a wrong offset!");

// Function DeceiveInc.DIMainMenuUserWidget.GetIrisSubtitleWidget
// 0x0008 (0x0008 - 0x0000)
struct DIMainMenuUserWidget_GetIrisSubtitleWidget final
{
public:
	class UUserWidget*                            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMainMenuUserWidget_GetIrisSubtitleWidget) == 0x000008, "Wrong alignment on DIMainMenuUserWidget_GetIrisSubtitleWidget");
static_assert(sizeof(DIMainMenuUserWidget_GetIrisSubtitleWidget) == 0x000008, "Wrong size on DIMainMenuUserWidget_GetIrisSubtitleWidget");
static_assert(offsetof(DIMainMenuUserWidget_GetIrisSubtitleWidget, ReturnValue) == 0x000000, "Member 'DIMainMenuUserWidget_GetIrisSubtitleWidget::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMainMenuUserWidget.GetOpenedMenuPage
// 0x0001 (0x0001 - 0x0000)
struct DIMainMenuUserWidget_GetOpenedMenuPage final
{
public:
	EMainMenuPages                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMainMenuUserWidget_GetOpenedMenuPage) == 0x000001, "Wrong alignment on DIMainMenuUserWidget_GetOpenedMenuPage");
static_assert(sizeof(DIMainMenuUserWidget_GetOpenedMenuPage) == 0x000001, "Wrong size on DIMainMenuUserWidget_GetOpenedMenuPage");
static_assert(offsetof(DIMainMenuUserWidget_GetOpenedMenuPage, ReturnValue) == 0x000000, "Member 'DIMainMenuUserWidget_GetOpenedMenuPage::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMainMenuUserWidget.GetSubtitleWidget
// 0x0008 (0x0008 - 0x0000)
struct DIMainMenuUserWidget_GetSubtitleWidget final
{
public:
	class UUserWidget*                            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMainMenuUserWidget_GetSubtitleWidget) == 0x000008, "Wrong alignment on DIMainMenuUserWidget_GetSubtitleWidget");
static_assert(sizeof(DIMainMenuUserWidget_GetSubtitleWidget) == 0x000008, "Wrong size on DIMainMenuUserWidget_GetSubtitleWidget");
static_assert(offsetof(DIMainMenuUserWidget_GetSubtitleWidget, ReturnValue) == 0x000000, "Member 'DIMainMenuUserWidget_GetSubtitleWidget::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMatchesSubsystem.MatchUpdate
// 0x0001 (0x0001 - 0x0000)
struct DIMatchesSubsystem_MatchUpdate final
{
public:
	bool                                          bForceMatchEnded;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMatchesSubsystem_MatchUpdate) == 0x000001, "Wrong alignment on DIMatchesSubsystem_MatchUpdate");
static_assert(sizeof(DIMatchesSubsystem_MatchUpdate) == 0x000001, "Wrong size on DIMatchesSubsystem_MatchUpdate");
static_assert(offsetof(DIMatchesSubsystem_MatchUpdate, bForceMatchEnded) == 0x000000, "Member 'DIMatchesSubsystem_MatchUpdate::bForceMatchEnded' has a wrong offset!");

// Function DeceiveInc.DIMatchesSubsystem.OnGameStateSetEvent
// 0x0008 (0x0008 - 0x0000)
struct DIMatchesSubsystem_OnGameStateSetEvent final
{
public:
	class AGameStateBase*                         GameState;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMatchesSubsystem_OnGameStateSetEvent) == 0x000008, "Wrong alignment on DIMatchesSubsystem_OnGameStateSetEvent");
static_assert(sizeof(DIMatchesSubsystem_OnGameStateSetEvent) == 0x000008, "Wrong size on DIMatchesSubsystem_OnGameStateSetEvent");
static_assert(offsetof(DIMatchesSubsystem_OnGameStateSetEvent, GameState) == 0x000000, "Member 'DIMatchesSubsystem_OnGameStateSetEvent::GameState' has a wrong offset!");

// Function DeceiveInc.DIMatchesSubsystem.OnMatchStateChanged
// 0x0008 (0x0008 - 0x0000)
struct DIMatchesSubsystem_OnMatchStateChanged final
{
public:
	class FName                                   NewMatchState;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMatchesSubsystem_OnMatchStateChanged) == 0x000004, "Wrong alignment on DIMatchesSubsystem_OnMatchStateChanged");
static_assert(sizeof(DIMatchesSubsystem_OnMatchStateChanged) == 0x000008, "Wrong size on DIMatchesSubsystem_OnMatchStateChanged");
static_assert(offsetof(DIMatchesSubsystem_OnMatchStateChanged, NewMatchState) == 0x000000, "Member 'DIMatchesSubsystem_OnMatchStateChanged::NewMatchState' has a wrong offset!");

// Function DeceiveInc.DIMatchesSubsystem.OnPostLoadMap
// 0x0008 (0x0008 - 0x0000)
struct DIMatchesSubsystem_OnPostLoadMap final
{
public:
	class UWorld*                                 LoadedWorld;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMatchesSubsystem_OnPostLoadMap) == 0x000008, "Wrong alignment on DIMatchesSubsystem_OnPostLoadMap");
static_assert(sizeof(DIMatchesSubsystem_OnPostLoadMap) == 0x000008, "Wrong size on DIMatchesSubsystem_OnPostLoadMap");
static_assert(offsetof(DIMatchesSubsystem_OnPostLoadMap, LoadedWorld) == 0x000000, "Member 'DIMatchesSubsystem_OnPostLoadMap::LoadedWorld' has a wrong offset!");

// Function DeceiveInc.DIMatchesSubsystem.OnPreLoadMap
// 0x0010 (0x0010 - 0x0000)
struct DIMatchesSubsystem_OnPreLoadMap final
{
public:
	class FString                                 MapName;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMatchesSubsystem_OnPreLoadMap) == 0x000008, "Wrong alignment on DIMatchesSubsystem_OnPreLoadMap");
static_assert(sizeof(DIMatchesSubsystem_OnPreLoadMap) == 0x000010, "Wrong size on DIMatchesSubsystem_OnPreLoadMap");
static_assert(offsetof(DIMatchesSubsystem_OnPreLoadMap, MapName) == 0x000000, "Member 'DIMatchesSubsystem_OnPreLoadMap::MapName' has a wrong offset!");

// Function DeceiveInc.DIMatchesSubsystem.OnPS5MatchIdChanged
// 0x0010 (0x0010 - 0x0000)
struct DIMatchesSubsystem_OnPS5MatchIdChanged final
{
public:
	class FString                                 MatchId;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMatchesSubsystem_OnPS5MatchIdChanged) == 0x000008, "Wrong alignment on DIMatchesSubsystem_OnPS5MatchIdChanged");
static_assert(sizeof(DIMatchesSubsystem_OnPS5MatchIdChanged) == 0x000010, "Wrong size on DIMatchesSubsystem_OnPS5MatchIdChanged");
static_assert(offsetof(DIMatchesSubsystem_OnPS5MatchIdChanged, MatchId) == 0x000000, "Member 'DIMatchesSubsystem_OnPS5MatchIdChanged::MatchId' has a wrong offset!");

// Function DeceiveInc.DIMatchesSubsystem.OnPS5MatchResponsiblePlayerUpdated
// 0x0028 (0x0028 - 0x0000)
struct DIMatchesSubsystem_OnPS5MatchResponsiblePlayerUpdated final
{
public:
	struct FUniqueNetIdRepl                       Player;                                            // 0x0000(0x0028)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMatchesSubsystem_OnPS5MatchResponsiblePlayerUpdated) == 0x000008, "Wrong alignment on DIMatchesSubsystem_OnPS5MatchResponsiblePlayerUpdated");
static_assert(sizeof(DIMatchesSubsystem_OnPS5MatchResponsiblePlayerUpdated) == 0x000028, "Wrong size on DIMatchesSubsystem_OnPS5MatchResponsiblePlayerUpdated");
static_assert(offsetof(DIMatchesSubsystem_OnPS5MatchResponsiblePlayerUpdated, Player) == 0x000000, "Member 'DIMatchesSubsystem_OnPS5MatchResponsiblePlayerUpdated::Player' has a wrong offset!");

// Function DeceiveInc.DIMatchmakingRequestHandler.GetMatchmakingGameMode
// 0x0001 (0x0001 - 0x0000)
struct DIMatchmakingRequestHandler_GetMatchmakingGameMode final
{
public:
	EDIMenuGameModes                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMatchmakingRequestHandler_GetMatchmakingGameMode) == 0x000001, "Wrong alignment on DIMatchmakingRequestHandler_GetMatchmakingGameMode");
static_assert(sizeof(DIMatchmakingRequestHandler_GetMatchmakingGameMode) == 0x000001, "Wrong size on DIMatchmakingRequestHandler_GetMatchmakingGameMode");
static_assert(offsetof(DIMatchmakingRequestHandler_GetMatchmakingGameMode, ReturnValue) == 0x000000, "Member 'DIMatchmakingRequestHandler_GetMatchmakingGameMode::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.GetMenuName
// 0x000C (0x000C - 0x0000)
struct DIMenuSubsystem_GetMenuName final
{
public:
	EMenuType                                     Menu;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_GetMenuName) == 0x000004, "Wrong alignment on DIMenuSubsystem_GetMenuName");
static_assert(sizeof(DIMenuSubsystem_GetMenuName) == 0x00000C, "Wrong size on DIMenuSubsystem_GetMenuName");
static_assert(offsetof(DIMenuSubsystem_GetMenuName, Menu) == 0x000000, "Member 'DIMenuSubsystem_GetMenuName::Menu' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_GetMenuName, ReturnValue) == 0x000004, "Member 'DIMenuSubsystem_GetMenuName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.GetMenuTypeFromName
// 0x0018 (0x0018 - 0x0000)
struct DIMenuSubsystem_GetMenuTypeFromName final
{
public:
	class FString                                 MenuName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMenuType                                     ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIMenuSubsystem_GetMenuTypeFromName) == 0x000008, "Wrong alignment on DIMenuSubsystem_GetMenuTypeFromName");
static_assert(sizeof(DIMenuSubsystem_GetMenuTypeFromName) == 0x000018, "Wrong size on DIMenuSubsystem_GetMenuTypeFromName");
static_assert(offsetof(DIMenuSubsystem_GetMenuTypeFromName, MenuName) == 0x000000, "Member 'DIMenuSubsystem_GetMenuTypeFromName::MenuName' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_GetMenuTypeFromName, ReturnValue) == 0x000010, "Member 'DIMenuSubsystem_GetMenuTypeFromName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.AddNewMenuToScreen
// 0x0018 (0x0018 - 0x0000)
struct DIMenuSubsystem_AddNewMenuToScreen final
{
public:
	TSubclassOf<class UDIMenuUserWidget>          MenuClass;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MenuName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDIMenuUserWidget*                      ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_AddNewMenuToScreen) == 0x000008, "Wrong alignment on DIMenuSubsystem_AddNewMenuToScreen");
static_assert(sizeof(DIMenuSubsystem_AddNewMenuToScreen) == 0x000018, "Wrong size on DIMenuSubsystem_AddNewMenuToScreen");
static_assert(offsetof(DIMenuSubsystem_AddNewMenuToScreen, MenuClass) == 0x000000, "Member 'DIMenuSubsystem_AddNewMenuToScreen::MenuClass' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_AddNewMenuToScreen, MenuName) == 0x000008, "Member 'DIMenuSubsystem_AddNewMenuToScreen::MenuName' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_AddNewMenuToScreen, ReturnValue) == 0x000010, "Member 'DIMenuSubsystem_AddNewMenuToScreen::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.AppHasFocus
// 0x0001 (0x0001 - 0x0000)
struct DIMenuSubsystem_AppHasFocus final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_AppHasFocus) == 0x000001, "Wrong alignment on DIMenuSubsystem_AppHasFocus");
static_assert(sizeof(DIMenuSubsystem_AppHasFocus) == 0x000001, "Wrong size on DIMenuSubsystem_AppHasFocus");
static_assert(offsetof(DIMenuSubsystem_AppHasFocus, ReturnValue) == 0x000000, "Member 'DIMenuSubsystem_AppHasFocus::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.ClearDisplayedAgent
// 0x0004 (0x0004 - 0x0000)
struct DIMenuSubsystem_ClearDisplayedAgent final
{
public:
	int32                                         DisplayedIndex;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_ClearDisplayedAgent) == 0x000004, "Wrong alignment on DIMenuSubsystem_ClearDisplayedAgent");
static_assert(sizeof(DIMenuSubsystem_ClearDisplayedAgent) == 0x000004, "Wrong size on DIMenuSubsystem_ClearDisplayedAgent");
static_assert(offsetof(DIMenuSubsystem_ClearDisplayedAgent, DisplayedIndex) == 0x000000, "Member 'DIMenuSubsystem_ClearDisplayedAgent::DisplayedIndex' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.ClearDisplayedWrap
// 0x0004 (0x0004 - 0x0000)
struct DIMenuSubsystem_ClearDisplayedWrap final
{
public:
	int32                                         DisplayedIndex;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_ClearDisplayedWrap) == 0x000004, "Wrong alignment on DIMenuSubsystem_ClearDisplayedWrap");
static_assert(sizeof(DIMenuSubsystem_ClearDisplayedWrap) == 0x000004, "Wrong size on DIMenuSubsystem_ClearDisplayedWrap");
static_assert(offsetof(DIMenuSubsystem_ClearDisplayedWrap, DisplayedIndex) == 0x000000, "Member 'DIMenuSubsystem_ClearDisplayedWrap::DisplayedIndex' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.DisplayMenu
// 0x0001 (0x0001 - 0x0000)
struct DIMenuSubsystem_DisplayMenu final
{
public:
	EMenuType                                     MenuToDisplay;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_DisplayMenu) == 0x000001, "Wrong alignment on DIMenuSubsystem_DisplayMenu");
static_assert(sizeof(DIMenuSubsystem_DisplayMenu) == 0x000001, "Wrong size on DIMenuSubsystem_DisplayMenu");
static_assert(offsetof(DIMenuSubsystem_DisplayMenu, MenuToDisplay) == 0x000000, "Member 'DIMenuSubsystem_DisplayMenu::MenuToDisplay' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.DisplayPopup
// 0x0038 (0x0038 - 0x0000)
struct DIMenuSubsystem_DisplayPopup final
{
public:
	class FText                                   TextToDisplay;                                     // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FString                                 EventName;                                         // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPopupType                                    PopupType;                                         // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDIPopupUserWidget*                     ReturnValue;                                       // 0x0030(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_DisplayPopup) == 0x000008, "Wrong alignment on DIMenuSubsystem_DisplayPopup");
static_assert(sizeof(DIMenuSubsystem_DisplayPopup) == 0x000038, "Wrong size on DIMenuSubsystem_DisplayPopup");
static_assert(offsetof(DIMenuSubsystem_DisplayPopup, TextToDisplay) == 0x000000, "Member 'DIMenuSubsystem_DisplayPopup::TextToDisplay' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_DisplayPopup, EventName) == 0x000018, "Member 'DIMenuSubsystem_DisplayPopup::EventName' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_DisplayPopup, PopupType) == 0x000028, "Member 'DIMenuSubsystem_DisplayPopup::PopupType' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_DisplayPopup, ReturnValue) == 0x000030, "Member 'DIMenuSubsystem_DisplayPopup::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.DisplayPopupInternal
// 0x0050 (0x0050 - 0x0000)
struct DIMenuSubsystem_DisplayPopupInternal final
{
public:
	class FText                                   TitleToDisplay;                                    // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   TextToDisplay;                                     // 0x0018(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FString                                 EventName;                                         // 0x0030(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPopupType                                    PopupType;                                         // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDIPopupUserWidget*                     ReturnValue;                                       // 0x0048(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_DisplayPopupInternal) == 0x000008, "Wrong alignment on DIMenuSubsystem_DisplayPopupInternal");
static_assert(sizeof(DIMenuSubsystem_DisplayPopupInternal) == 0x000050, "Wrong size on DIMenuSubsystem_DisplayPopupInternal");
static_assert(offsetof(DIMenuSubsystem_DisplayPopupInternal, TitleToDisplay) == 0x000000, "Member 'DIMenuSubsystem_DisplayPopupInternal::TitleToDisplay' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_DisplayPopupInternal, TextToDisplay) == 0x000018, "Member 'DIMenuSubsystem_DisplayPopupInternal::TextToDisplay' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_DisplayPopupInternal, EventName) == 0x000030, "Member 'DIMenuSubsystem_DisplayPopupInternal::EventName' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_DisplayPopupInternal, PopupType) == 0x000040, "Member 'DIMenuSubsystem_DisplayPopupInternal::PopupType' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_DisplayPopupInternal, ReturnValue) == 0x000048, "Member 'DIMenuSubsystem_DisplayPopupInternal::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.DisplaySubMenu
// 0x0001 (0x0001 - 0x0000)
struct DIMenuSubsystem_DisplaySubMenu final
{
public:
	ESubMenuPages                                 MenuPage;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_DisplaySubMenu) == 0x000001, "Wrong alignment on DIMenuSubsystem_DisplaySubMenu");
static_assert(sizeof(DIMenuSubsystem_DisplaySubMenu) == 0x000001, "Wrong size on DIMenuSubsystem_DisplaySubMenu");
static_assert(offsetof(DIMenuSubsystem_DisplaySubMenu, MenuPage) == 0x000000, "Member 'DIMenuSubsystem_DisplaySubMenu::MenuPage' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.GetCurrentGameMode
// 0x0001 (0x0001 - 0x0000)
struct DIMenuSubsystem_GetCurrentGameMode final
{
public:
	EDIMenuGameModes                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_GetCurrentGameMode) == 0x000001, "Wrong alignment on DIMenuSubsystem_GetCurrentGameMode");
static_assert(sizeof(DIMenuSubsystem_GetCurrentGameMode) == 0x000001, "Wrong size on DIMenuSubsystem_GetCurrentGameMode");
static_assert(offsetof(DIMenuSubsystem_GetCurrentGameMode, ReturnValue) == 0x000000, "Member 'DIMenuSubsystem_GetCurrentGameMode::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.GetDisplayedAgent
// 0x0014 (0x0014 - 0x0000)
struct DIMenuSubsystem_GetDisplayedAgent final
{
public:
	int32                                         DisplayedIndex;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0004(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_GetDisplayedAgent) == 0x000004, "Wrong alignment on DIMenuSubsystem_GetDisplayedAgent");
static_assert(sizeof(DIMenuSubsystem_GetDisplayedAgent) == 0x000014, "Wrong size on DIMenuSubsystem_GetDisplayedAgent");
static_assert(offsetof(DIMenuSubsystem_GetDisplayedAgent, DisplayedIndex) == 0x000000, "Member 'DIMenuSubsystem_GetDisplayedAgent::DisplayedIndex' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_GetDisplayedAgent, ReturnValue) == 0x000004, "Member 'DIMenuSubsystem_GetDisplayedAgent::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.GetDisplayedAvatar
// 0x0014 (0x0014 - 0x0000)
struct DIMenuSubsystem_GetDisplayedAvatar final
{
public:
	int32                                         DisplayedIndex;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0004(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_GetDisplayedAvatar) == 0x000004, "Wrong alignment on DIMenuSubsystem_GetDisplayedAvatar");
static_assert(sizeof(DIMenuSubsystem_GetDisplayedAvatar) == 0x000014, "Wrong size on DIMenuSubsystem_GetDisplayedAvatar");
static_assert(offsetof(DIMenuSubsystem_GetDisplayedAvatar, DisplayedIndex) == 0x000000, "Member 'DIMenuSubsystem_GetDisplayedAvatar::DisplayedIndex' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_GetDisplayedAvatar, ReturnValue) == 0x000004, "Member 'DIMenuSubsystem_GetDisplayedAvatar::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.GetDisplayedTitle
// 0x0014 (0x0014 - 0x0000)
struct DIMenuSubsystem_GetDisplayedTitle final
{
public:
	int32                                         DisplayedIndex;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0004(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_GetDisplayedTitle) == 0x000004, "Wrong alignment on DIMenuSubsystem_GetDisplayedTitle");
static_assert(sizeof(DIMenuSubsystem_GetDisplayedTitle) == 0x000014, "Wrong size on DIMenuSubsystem_GetDisplayedTitle");
static_assert(offsetof(DIMenuSubsystem_GetDisplayedTitle, DisplayedIndex) == 0x000000, "Member 'DIMenuSubsystem_GetDisplayedTitle::DisplayedIndex' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_GetDisplayedTitle, ReturnValue) == 0x000004, "Member 'DIMenuSubsystem_GetDisplayedTitle::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.GetDisplayedWrap
// 0x0024 (0x0024 - 0x0000)
struct DIMenuSubsystem_GetDisplayedWrap final
{
public:
	struct FPrimaryAssetId                        WeaponId;                                          // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        WeaponWrapId;                                      // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayedIndex;                                    // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_GetDisplayedWrap) == 0x000004, "Wrong alignment on DIMenuSubsystem_GetDisplayedWrap");
static_assert(sizeof(DIMenuSubsystem_GetDisplayedWrap) == 0x000024, "Wrong size on DIMenuSubsystem_GetDisplayedWrap");
static_assert(offsetof(DIMenuSubsystem_GetDisplayedWrap, WeaponId) == 0x000000, "Member 'DIMenuSubsystem_GetDisplayedWrap::WeaponId' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_GetDisplayedWrap, WeaponWrapId) == 0x000010, "Member 'DIMenuSubsystem_GetDisplayedWrap::WeaponWrapId' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_GetDisplayedWrap, DisplayedIndex) == 0x000020, "Member 'DIMenuSubsystem_GetDisplayedWrap::DisplayedIndex' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.GetLocalPosingSpy
// 0x0008 (0x0008 - 0x0000)
struct DIMenuSubsystem_GetLocalPosingSpy final
{
public:
	class APosingSpy*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_GetLocalPosingSpy) == 0x000008, "Wrong alignment on DIMenuSubsystem_GetLocalPosingSpy");
static_assert(sizeof(DIMenuSubsystem_GetLocalPosingSpy) == 0x000008, "Wrong size on DIMenuSubsystem_GetLocalPosingSpy");
static_assert(offsetof(DIMenuSubsystem_GetLocalPosingSpy, ReturnValue) == 0x000000, "Member 'DIMenuSubsystem_GetLocalPosingSpy::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.GetOrderedGadgetList
// 0x0010 (0x0010 - 0x0000)
struct DIMenuSubsystem_GetOrderedGadgetList final
{
public:
	TArray<class UGadgetData*>                    ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_GetOrderedGadgetList) == 0x000008, "Wrong alignment on DIMenuSubsystem_GetOrderedGadgetList");
static_assert(sizeof(DIMenuSubsystem_GetOrderedGadgetList) == 0x000010, "Wrong size on DIMenuSubsystem_GetOrderedGadgetList");
static_assert(offsetof(DIMenuSubsystem_GetOrderedGadgetList, ReturnValue) == 0x000000, "Member 'DIMenuSubsystem_GetOrderedGadgetList::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.GetOwningMenu
// 0x0010 (0x0010 - 0x0000)
struct DIMenuSubsystem_GetOwningMenu final
{
public:
	class UUserWidget*                            UserWidget;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDIMenuUserWidget*                      ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_GetOwningMenu) == 0x000008, "Wrong alignment on DIMenuSubsystem_GetOwningMenu");
static_assert(sizeof(DIMenuSubsystem_GetOwningMenu) == 0x000010, "Wrong size on DIMenuSubsystem_GetOwningMenu");
static_assert(offsetof(DIMenuSubsystem_GetOwningMenu, UserWidget) == 0x000000, "Member 'DIMenuSubsystem_GetOwningMenu::UserWidget' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_GetOwningMenu, ReturnValue) == 0x000008, "Member 'DIMenuSubsystem_GetOwningMenu::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.GetWrapData
// 0x0018 (0x0018 - 0x0000)
struct DIMenuSubsystem_GetWrapData final
{
public:
	struct FPrimaryAssetId                        WrapId;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMenuWrapData*                          ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_GetWrapData) == 0x000008, "Wrong alignment on DIMenuSubsystem_GetWrapData");
static_assert(sizeof(DIMenuSubsystem_GetWrapData) == 0x000018, "Wrong size on DIMenuSubsystem_GetWrapData");
static_assert(offsetof(DIMenuSubsystem_GetWrapData, WrapId) == 0x000000, "Member 'DIMenuSubsystem_GetWrapData::WrapId' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_GetWrapData, ReturnValue) == 0x000010, "Member 'DIMenuSubsystem_GetWrapData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.GoToMenu
// 0x0010 (0x0010 - 0x0000)
struct DIMenuSubsystem_GoToMenu final
{
public:
	class FName                                   MenuName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDIMenuUserWidget*                      ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_GoToMenu) == 0x000008, "Wrong alignment on DIMenuSubsystem_GoToMenu");
static_assert(sizeof(DIMenuSubsystem_GoToMenu) == 0x000010, "Wrong size on DIMenuSubsystem_GoToMenu");
static_assert(offsetof(DIMenuSubsystem_GoToMenu, MenuName) == 0x000000, "Member 'DIMenuSubsystem_GoToMenu::MenuName' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_GoToMenu, ReturnValue) == 0x000008, "Member 'DIMenuSubsystem_GoToMenu::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.HandleMenuEvent
// 0x0018 (0x0018 - 0x0000)
struct DIMenuSubsystem_HandleMenuEvent final
{
public:
	class FString                                 EventName;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AnswerValue;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIMenuSubsystem_HandleMenuEvent) == 0x000008, "Wrong alignment on DIMenuSubsystem_HandleMenuEvent");
static_assert(sizeof(DIMenuSubsystem_HandleMenuEvent) == 0x000018, "Wrong size on DIMenuSubsystem_HandleMenuEvent");
static_assert(offsetof(DIMenuSubsystem_HandleMenuEvent, EventName) == 0x000000, "Member 'DIMenuSubsystem_HandleMenuEvent::EventName' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_HandleMenuEvent, AnswerValue) == 0x000010, "Member 'DIMenuSubsystem_HandleMenuEvent::AnswerValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.HandlePopupAnswered
// 0x0018 (0x0018 - 0x0000)
struct DIMenuSubsystem_HandlePopupAnswered final
{
public:
	class FString                                 EventName;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AnswerValue;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIMenuSubsystem_HandlePopupAnswered) == 0x000008, "Wrong alignment on DIMenuSubsystem_HandlePopupAnswered");
static_assert(sizeof(DIMenuSubsystem_HandlePopupAnswered) == 0x000018, "Wrong size on DIMenuSubsystem_HandlePopupAnswered");
static_assert(offsetof(DIMenuSubsystem_HandlePopupAnswered, EventName) == 0x000000, "Member 'DIMenuSubsystem_HandlePopupAnswered::EventName' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_HandlePopupAnswered, AnswerValue) == 0x000010, "Member 'DIMenuSubsystem_HandlePopupAnswered::AnswerValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.IsCursorShown
// 0x0001 (0x0001 - 0x0000)
struct DIMenuSubsystem_IsCursorShown final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_IsCursorShown) == 0x000001, "Wrong alignment on DIMenuSubsystem_IsCursorShown");
static_assert(sizeof(DIMenuSubsystem_IsCursorShown) == 0x000001, "Wrong size on DIMenuSubsystem_IsCursorShown");
static_assert(offsetof(DIMenuSubsystem_IsCursorShown, ReturnValue) == 0x000000, "Member 'DIMenuSubsystem_IsCursorShown::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.IsGameModeSelectable
// 0x0002 (0x0002 - 0x0000)
struct DIMenuSubsystem_IsGameModeSelectable final
{
public:
	EDIMenuGameModes                              GameMode;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_IsGameModeSelectable) == 0x000001, "Wrong alignment on DIMenuSubsystem_IsGameModeSelectable");
static_assert(sizeof(DIMenuSubsystem_IsGameModeSelectable) == 0x000002, "Wrong size on DIMenuSubsystem_IsGameModeSelectable");
static_assert(offsetof(DIMenuSubsystem_IsGameModeSelectable, GameMode) == 0x000000, "Member 'DIMenuSubsystem_IsGameModeSelectable::GameMode' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_IsGameModeSelectable, ReturnValue) == 0x000001, "Member 'DIMenuSubsystem_IsGameModeSelectable::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.IsMenuGameModeOffered
// 0x0002 (0x0002 - 0x0000)
struct DIMenuSubsystem_IsMenuGameModeOffered final
{
public:
	EDIMenuGameModes                              GameMode;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_IsMenuGameModeOffered) == 0x000001, "Wrong alignment on DIMenuSubsystem_IsMenuGameModeOffered");
static_assert(sizeof(DIMenuSubsystem_IsMenuGameModeOffered) == 0x000002, "Wrong size on DIMenuSubsystem_IsMenuGameModeOffered");
static_assert(offsetof(DIMenuSubsystem_IsMenuGameModeOffered, GameMode) == 0x000000, "Member 'DIMenuSubsystem_IsMenuGameModeOffered::GameMode' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_IsMenuGameModeOffered, ReturnValue) == 0x000001, "Member 'DIMenuSubsystem_IsMenuGameModeOffered::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.PlayDefaultMenuAnim
// 0x0004 (0x0004 - 0x0000)
struct DIMenuSubsystem_PlayDefaultMenuAnim final
{
public:
	int32                                         DisplayedIndex;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_PlayDefaultMenuAnim) == 0x000004, "Wrong alignment on DIMenuSubsystem_PlayDefaultMenuAnim");
static_assert(sizeof(DIMenuSubsystem_PlayDefaultMenuAnim) == 0x000004, "Wrong size on DIMenuSubsystem_PlayDefaultMenuAnim");
static_assert(offsetof(DIMenuSubsystem_PlayDefaultMenuAnim, DisplayedIndex) == 0x000000, "Member 'DIMenuSubsystem_PlayDefaultMenuAnim::DisplayedIndex' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.PopSpecialAnnouncements
// 0x0001 (0x0001 - 0x0000)
struct DIMenuSubsystem_PopSpecialAnnouncements final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_PopSpecialAnnouncements) == 0x000001, "Wrong alignment on DIMenuSubsystem_PopSpecialAnnouncements");
static_assert(sizeof(DIMenuSubsystem_PopSpecialAnnouncements) == 0x000001, "Wrong size on DIMenuSubsystem_PopSpecialAnnouncements");
static_assert(offsetof(DIMenuSubsystem_PopSpecialAnnouncements, ReturnValue) == 0x000000, "Member 'DIMenuSubsystem_PopSpecialAnnouncements::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.RemoveAllPopupOfEventName
// 0x0010 (0x0010 - 0x0000)
struct DIMenuSubsystem_RemoveAllPopupOfEventName final
{
public:
	class FString                                 EventName;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_RemoveAllPopupOfEventName) == 0x000008, "Wrong alignment on DIMenuSubsystem_RemoveAllPopupOfEventName");
static_assert(sizeof(DIMenuSubsystem_RemoveAllPopupOfEventName) == 0x000010, "Wrong size on DIMenuSubsystem_RemoveAllPopupOfEventName");
static_assert(offsetof(DIMenuSubsystem_RemoveAllPopupOfEventName, EventName) == 0x000000, "Member 'DIMenuSubsystem_RemoveAllPopupOfEventName::EventName' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.RemoveAllPopupOfType
// 0x0001 (0x0001 - 0x0000)
struct DIMenuSubsystem_RemoveAllPopupOfType final
{
public:
	EPopupType                                    PopupType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_RemoveAllPopupOfType) == 0x000001, "Wrong alignment on DIMenuSubsystem_RemoveAllPopupOfType");
static_assert(sizeof(DIMenuSubsystem_RemoveAllPopupOfType) == 0x000001, "Wrong size on DIMenuSubsystem_RemoveAllPopupOfType");
static_assert(offsetof(DIMenuSubsystem_RemoveAllPopupOfType, PopupType) == 0x000000, "Member 'DIMenuSubsystem_RemoveAllPopupOfType::PopupType' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.RemoveMenu
// 0x0001 (0x0001 - 0x0000)
struct DIMenuSubsystem_RemoveMenu final
{
public:
	EMenuType                                     MenuToRemove;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_RemoveMenu) == 0x000001, "Wrong alignment on DIMenuSubsystem_RemoveMenu");
static_assert(sizeof(DIMenuSubsystem_RemoveMenu) == 0x000001, "Wrong size on DIMenuSubsystem_RemoveMenu");
static_assert(offsetof(DIMenuSubsystem_RemoveMenu, MenuToRemove) == 0x000000, "Member 'DIMenuSubsystem_RemoveMenu::MenuToRemove' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.RemoveMenuFromScreen
// 0x000C (0x000C - 0x0000)
struct DIMenuSubsystem_RemoveMenuFromScreen final
{
public:
	class FName                                   MenuName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIMenuSubsystem_RemoveMenuFromScreen) == 0x000004, "Wrong alignment on DIMenuSubsystem_RemoveMenuFromScreen");
static_assert(sizeof(DIMenuSubsystem_RemoveMenuFromScreen) == 0x00000C, "Wrong size on DIMenuSubsystem_RemoveMenuFromScreen");
static_assert(offsetof(DIMenuSubsystem_RemoveMenuFromScreen, MenuName) == 0x000000, "Member 'DIMenuSubsystem_RemoveMenuFromScreen::MenuName' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_RemoveMenuFromScreen, ReturnValue) == 0x000008, "Member 'DIMenuSubsystem_RemoveMenuFromScreen::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.RemoveMenuInstanceFromScreen
// 0x0010 (0x0010 - 0x0000)
struct DIMenuSubsystem_RemoveMenuInstanceFromScreen final
{
public:
	class UDIMenuUserWidget*                      Menu;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIMenuSubsystem_RemoveMenuInstanceFromScreen) == 0x000008, "Wrong alignment on DIMenuSubsystem_RemoveMenuInstanceFromScreen");
static_assert(sizeof(DIMenuSubsystem_RemoveMenuInstanceFromScreen) == 0x000010, "Wrong size on DIMenuSubsystem_RemoveMenuInstanceFromScreen");
static_assert(offsetof(DIMenuSubsystem_RemoveMenuInstanceFromScreen, Menu) == 0x000000, "Member 'DIMenuSubsystem_RemoveMenuInstanceFromScreen::Menu' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_RemoveMenuInstanceFromScreen, ReturnValue) == 0x000008, "Member 'DIMenuSubsystem_RemoveMenuInstanceFromScreen::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.RemovePauseMenu
// 0x0001 (0x0001 - 0x0000)
struct DIMenuSubsystem_RemovePauseMenu final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_RemovePauseMenu) == 0x000001, "Wrong alignment on DIMenuSubsystem_RemovePauseMenu");
static_assert(sizeof(DIMenuSubsystem_RemovePauseMenu) == 0x000001, "Wrong size on DIMenuSubsystem_RemovePauseMenu");
static_assert(offsetof(DIMenuSubsystem_RemovePauseMenu, ReturnValue) == 0x000000, "Member 'DIMenuSubsystem_RemovePauseMenu::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.RemovePhaseMenu
// 0x0001 (0x0001 - 0x0000)
struct DIMenuSubsystem_RemovePhaseMenu final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_RemovePhaseMenu) == 0x000001, "Wrong alignment on DIMenuSubsystem_RemovePhaseMenu");
static_assert(sizeof(DIMenuSubsystem_RemovePhaseMenu) == 0x000001, "Wrong size on DIMenuSubsystem_RemovePhaseMenu");
static_assert(offsetof(DIMenuSubsystem_RemovePhaseMenu, ReturnValue) == 0x000000, "Member 'DIMenuSubsystem_RemovePhaseMenu::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.SetDisplayedAgent
// 0x0014 (0x0014 - 0x0000)
struct DIMenuSubsystem_SetDisplayedAgent final
{
public:
	struct FPrimaryAssetId                        AgentSkinId;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayedIndex;                                    // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_SetDisplayedAgent) == 0x000004, "Wrong alignment on DIMenuSubsystem_SetDisplayedAgent");
static_assert(sizeof(DIMenuSubsystem_SetDisplayedAgent) == 0x000014, "Wrong size on DIMenuSubsystem_SetDisplayedAgent");
static_assert(offsetof(DIMenuSubsystem_SetDisplayedAgent, AgentSkinId) == 0x000000, "Member 'DIMenuSubsystem_SetDisplayedAgent::AgentSkinId' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_SetDisplayedAgent, DisplayedIndex) == 0x000010, "Member 'DIMenuSubsystem_SetDisplayedAgent::DisplayedIndex' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.SetDisplayedAvatar
// 0x0014 (0x0014 - 0x0000)
struct DIMenuSubsystem_SetDisplayedAvatar final
{
public:
	struct FPrimaryAssetId                        AvatarId;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayedIndex;                                    // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_SetDisplayedAvatar) == 0x000004, "Wrong alignment on DIMenuSubsystem_SetDisplayedAvatar");
static_assert(sizeof(DIMenuSubsystem_SetDisplayedAvatar) == 0x000014, "Wrong size on DIMenuSubsystem_SetDisplayedAvatar");
static_assert(offsetof(DIMenuSubsystem_SetDisplayedAvatar, AvatarId) == 0x000000, "Member 'DIMenuSubsystem_SetDisplayedAvatar::AvatarId' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_SetDisplayedAvatar, DisplayedIndex) == 0x000010, "Member 'DIMenuSubsystem_SetDisplayedAvatar::DisplayedIndex' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.SetDisplayedIntroPose
// 0x0014 (0x0014 - 0x0000)
struct DIMenuSubsystem_SetDisplayedIntroPose final
{
public:
	struct FPrimaryAssetId                        IntroPoseId;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayedIndex;                                    // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_SetDisplayedIntroPose) == 0x000004, "Wrong alignment on DIMenuSubsystem_SetDisplayedIntroPose");
static_assert(sizeof(DIMenuSubsystem_SetDisplayedIntroPose) == 0x000014, "Wrong size on DIMenuSubsystem_SetDisplayedIntroPose");
static_assert(offsetof(DIMenuSubsystem_SetDisplayedIntroPose, IntroPoseId) == 0x000000, "Member 'DIMenuSubsystem_SetDisplayedIntroPose::IntroPoseId' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_SetDisplayedIntroPose, DisplayedIndex) == 0x000010, "Member 'DIMenuSubsystem_SetDisplayedIntroPose::DisplayedIndex' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.SetDisplayedIntroPoseToDefault
// 0x0004 (0x0004 - 0x0000)
struct DIMenuSubsystem_SetDisplayedIntroPoseToDefault final
{
public:
	int32                                         DisplayedIndex;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_SetDisplayedIntroPoseToDefault) == 0x000004, "Wrong alignment on DIMenuSubsystem_SetDisplayedIntroPoseToDefault");
static_assert(sizeof(DIMenuSubsystem_SetDisplayedIntroPoseToDefault) == 0x000004, "Wrong size on DIMenuSubsystem_SetDisplayedIntroPoseToDefault");
static_assert(offsetof(DIMenuSubsystem_SetDisplayedIntroPoseToDefault, DisplayedIndex) == 0x000000, "Member 'DIMenuSubsystem_SetDisplayedIntroPoseToDefault::DisplayedIndex' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.SetDisplayedTitle
// 0x0014 (0x0014 - 0x0000)
struct DIMenuSubsystem_SetDisplayedTitle final
{
public:
	struct FPrimaryAssetId                        TitleId;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayedIndex;                                    // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_SetDisplayedTitle) == 0x000004, "Wrong alignment on DIMenuSubsystem_SetDisplayedTitle");
static_assert(sizeof(DIMenuSubsystem_SetDisplayedTitle) == 0x000014, "Wrong size on DIMenuSubsystem_SetDisplayedTitle");
static_assert(offsetof(DIMenuSubsystem_SetDisplayedTitle, TitleId) == 0x000000, "Member 'DIMenuSubsystem_SetDisplayedTitle::TitleId' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_SetDisplayedTitle, DisplayedIndex) == 0x000010, "Member 'DIMenuSubsystem_SetDisplayedTitle::DisplayedIndex' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.SetDisplayedWrap
// 0x0024 (0x0024 - 0x0000)
struct DIMenuSubsystem_SetDisplayedWrap final
{
public:
	struct FPrimaryAssetId                        WeaponId;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        WrapId;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayedIndex;                                    // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_SetDisplayedWrap) == 0x000004, "Wrong alignment on DIMenuSubsystem_SetDisplayedWrap");
static_assert(sizeof(DIMenuSubsystem_SetDisplayedWrap) == 0x000024, "Wrong size on DIMenuSubsystem_SetDisplayedWrap");
static_assert(offsetof(DIMenuSubsystem_SetDisplayedWrap, WeaponId) == 0x000000, "Member 'DIMenuSubsystem_SetDisplayedWrap::WeaponId' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_SetDisplayedWrap, WrapId) == 0x000010, "Member 'DIMenuSubsystem_SetDisplayedWrap::WrapId' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_SetDisplayedWrap, DisplayedIndex) == 0x000020, "Member 'DIMenuSubsystem_SetDisplayedWrap::DisplayedIndex' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.SetMenuGameMode
// 0x0001 (0x0001 - 0x0000)
struct DIMenuSubsystem_SetMenuGameMode final
{
public:
	EDIMenuGameModes                              NewGameMode;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_SetMenuGameMode) == 0x000001, "Wrong alignment on DIMenuSubsystem_SetMenuGameMode");
static_assert(sizeof(DIMenuSubsystem_SetMenuGameMode) == 0x000001, "Wrong size on DIMenuSubsystem_SetMenuGameMode");
static_assert(offsetof(DIMenuSubsystem_SetMenuGameMode, NewGameMode) == 0x000000, "Member 'DIMenuSubsystem_SetMenuGameMode::NewGameMode' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.ShouldButtonPromptsBeDisplayed
// 0x0001 (0x0001 - 0x0000)
struct DIMenuSubsystem_ShouldButtonPromptsBeDisplayed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_ShouldButtonPromptsBeDisplayed) == 0x000001, "Wrong alignment on DIMenuSubsystem_ShouldButtonPromptsBeDisplayed");
static_assert(sizeof(DIMenuSubsystem_ShouldButtonPromptsBeDisplayed) == 0x000001, "Wrong size on DIMenuSubsystem_ShouldButtonPromptsBeDisplayed");
static_assert(offsetof(DIMenuSubsystem_ShouldButtonPromptsBeDisplayed, ReturnValue) == 0x000000, "Member 'DIMenuSubsystem_ShouldButtonPromptsBeDisplayed::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.ShowCursor
// 0x0008 (0x0008 - 0x0000)
struct DIMenuSubsystem_ShowCursor final
{
public:
	class UDIMenuUserWidget*                      UserWidget;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_ShowCursor) == 0x000008, "Wrong alignment on DIMenuSubsystem_ShowCursor");
static_assert(sizeof(DIMenuSubsystem_ShowCursor) == 0x000008, "Wrong size on DIMenuSubsystem_ShowCursor");
static_assert(offsetof(DIMenuSubsystem_ShowCursor, UserWidget) == 0x000000, "Member 'DIMenuSubsystem_ShowCursor::UserWidget' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.TogglePauseMenu
// 0x0001 (0x0001 - 0x0000)
struct DIMenuSubsystem_TogglePauseMenu final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_TogglePauseMenu) == 0x000001, "Wrong alignment on DIMenuSubsystem_TogglePauseMenu");
static_assert(sizeof(DIMenuSubsystem_TogglePauseMenu) == 0x000001, "Wrong size on DIMenuSubsystem_TogglePauseMenu");
static_assert(offsetof(DIMenuSubsystem_TogglePauseMenu, ReturnValue) == 0x000000, "Member 'DIMenuSubsystem_TogglePauseMenu::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.TogglePhaseMenu
// 0x0001 (0x0001 - 0x0000)
struct DIMenuSubsystem_TogglePhaseMenu final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_TogglePhaseMenu) == 0x000001, "Wrong alignment on DIMenuSubsystem_TogglePhaseMenu");
static_assert(sizeof(DIMenuSubsystem_TogglePhaseMenu) == 0x000001, "Wrong size on DIMenuSubsystem_TogglePhaseMenu");
static_assert(offsetof(DIMenuSubsystem_TogglePhaseMenu, ReturnValue) == 0x000000, "Member 'DIMenuSubsystem_TogglePhaseMenu::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.GetDataAssetDisplayDesc
// 0x0020 (0x0020 - 0x0000)
struct DIMenuSubsystem_GetDataAssetDisplayDesc final
{
public:
	class UDIPrimaryDataAsset*                    DataAsset;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_GetDataAssetDisplayDesc) == 0x000008, "Wrong alignment on DIMenuSubsystem_GetDataAssetDisplayDesc");
static_assert(sizeof(DIMenuSubsystem_GetDataAssetDisplayDesc) == 0x000020, "Wrong size on DIMenuSubsystem_GetDataAssetDisplayDesc");
static_assert(offsetof(DIMenuSubsystem_GetDataAssetDisplayDesc, DataAsset) == 0x000000, "Member 'DIMenuSubsystem_GetDataAssetDisplayDesc::DataAsset' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_GetDataAssetDisplayDesc, ReturnValue) == 0x000008, "Member 'DIMenuSubsystem_GetDataAssetDisplayDesc::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.GetDataAssetDisplayIcon
// 0x0010 (0x0010 - 0x0000)
struct DIMenuSubsystem_GetDataAssetDisplayIcon final
{
public:
	class UDIPrimaryDataAsset*                    DataAsset;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_GetDataAssetDisplayIcon) == 0x000008, "Wrong alignment on DIMenuSubsystem_GetDataAssetDisplayIcon");
static_assert(sizeof(DIMenuSubsystem_GetDataAssetDisplayIcon) == 0x000010, "Wrong size on DIMenuSubsystem_GetDataAssetDisplayIcon");
static_assert(offsetof(DIMenuSubsystem_GetDataAssetDisplayIcon, DataAsset) == 0x000000, "Member 'DIMenuSubsystem_GetDataAssetDisplayIcon::DataAsset' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_GetDataAssetDisplayIcon, ReturnValue) == 0x000008, "Member 'DIMenuSubsystem_GetDataAssetDisplayIcon::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.GetDataAssetDisplayName
// 0x0020 (0x0020 - 0x0000)
struct DIMenuSubsystem_GetDataAssetDisplayName final
{
public:
	class UDIPrimaryDataAsset*                    DataAsset;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_GetDataAssetDisplayName) == 0x000008, "Wrong alignment on DIMenuSubsystem_GetDataAssetDisplayName");
static_assert(sizeof(DIMenuSubsystem_GetDataAssetDisplayName) == 0x000020, "Wrong size on DIMenuSubsystem_GetDataAssetDisplayName");
static_assert(offsetof(DIMenuSubsystem_GetDataAssetDisplayName, DataAsset) == 0x000000, "Member 'DIMenuSubsystem_GetDataAssetDisplayName::DataAsset' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_GetDataAssetDisplayName, ReturnValue) == 0x000008, "Member 'DIMenuSubsystem_GetDataAssetDisplayName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.GetDataAssetRewardDesc
// 0x0020 (0x0020 - 0x0000)
struct DIMenuSubsystem_GetDataAssetRewardDesc final
{
public:
	class UDIPrimaryDataAsset*                    DataAsset;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_GetDataAssetRewardDesc) == 0x000008, "Wrong alignment on DIMenuSubsystem_GetDataAssetRewardDesc");
static_assert(sizeof(DIMenuSubsystem_GetDataAssetRewardDesc) == 0x000020, "Wrong size on DIMenuSubsystem_GetDataAssetRewardDesc");
static_assert(offsetof(DIMenuSubsystem_GetDataAssetRewardDesc, DataAsset) == 0x000000, "Member 'DIMenuSubsystem_GetDataAssetRewardDesc::DataAsset' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_GetDataAssetRewardDesc, ReturnValue) == 0x000008, "Member 'DIMenuSubsystem_GetDataAssetRewardDesc::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.GetDataAssetRewardIcon
// 0x0010 (0x0010 - 0x0000)
struct DIMenuSubsystem_GetDataAssetRewardIcon final
{
public:
	class UDIPrimaryDataAsset*                    DataAsset;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_GetDataAssetRewardIcon) == 0x000008, "Wrong alignment on DIMenuSubsystem_GetDataAssetRewardIcon");
static_assert(sizeof(DIMenuSubsystem_GetDataAssetRewardIcon) == 0x000010, "Wrong size on DIMenuSubsystem_GetDataAssetRewardIcon");
static_assert(offsetof(DIMenuSubsystem_GetDataAssetRewardIcon, DataAsset) == 0x000000, "Member 'DIMenuSubsystem_GetDataAssetRewardIcon::DataAsset' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_GetDataAssetRewardIcon, ReturnValue) == 0x000008, "Member 'DIMenuSubsystem_GetDataAssetRewardIcon::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.GetDataAssetRewardName
// 0x0020 (0x0020 - 0x0000)
struct DIMenuSubsystem_GetDataAssetRewardName final
{
public:
	class UDIPrimaryDataAsset*                    DataAsset;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_GetDataAssetRewardName) == 0x000008, "Wrong alignment on DIMenuSubsystem_GetDataAssetRewardName");
static_assert(sizeof(DIMenuSubsystem_GetDataAssetRewardName) == 0x000020, "Wrong size on DIMenuSubsystem_GetDataAssetRewardName");
static_assert(offsetof(DIMenuSubsystem_GetDataAssetRewardName, DataAsset) == 0x000000, "Member 'DIMenuSubsystem_GetDataAssetRewardName::DataAsset' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_GetDataAssetRewardName, ReturnValue) == 0x000008, "Member 'DIMenuSubsystem_GetDataAssetRewardName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.GetMenuFromName
// 0x0010 (0x0010 - 0x0000)
struct DIMenuSubsystem_GetMenuFromName final
{
public:
	class FName                                   InName;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDIMenuUserWidget*                      ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_GetMenuFromName) == 0x000008, "Wrong alignment on DIMenuSubsystem_GetMenuFromName");
static_assert(sizeof(DIMenuSubsystem_GetMenuFromName) == 0x000010, "Wrong size on DIMenuSubsystem_GetMenuFromName");
static_assert(offsetof(DIMenuSubsystem_GetMenuFromName, InName) == 0x000000, "Member 'DIMenuSubsystem_GetMenuFromName::InName' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_GetMenuFromName, ReturnValue) == 0x000008, "Member 'DIMenuSubsystem_GetMenuFromName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.GetMOTDWidgets
// 0x0010 (0x0010 - 0x0000)
struct DIMenuSubsystem_GetMOTDWidgets final
{
public:
	TArray<class UMessageUserWidget*>             ReturnValue;                                       // 0x0000(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_GetMOTDWidgets) == 0x000008, "Wrong alignment on DIMenuSubsystem_GetMOTDWidgets");
static_assert(sizeof(DIMenuSubsystem_GetMOTDWidgets) == 0x000010, "Wrong size on DIMenuSubsystem_GetMOTDWidgets");
static_assert(offsetof(DIMenuSubsystem_GetMOTDWidgets, ReturnValue) == 0x000000, "Member 'DIMenuSubsystem_GetMOTDWidgets::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.GetTopmostMenu
// 0x0008 (0x0008 - 0x0000)
struct DIMenuSubsystem_GetTopmostMenu final
{
public:
	class UDIMenuUserWidget*                      ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_GetTopmostMenu) == 0x000008, "Wrong alignment on DIMenuSubsystem_GetTopmostMenu");
static_assert(sizeof(DIMenuSubsystem_GetTopmostMenu) == 0x000008, "Wrong size on DIMenuSubsystem_GetTopmostMenu");
static_assert(offsetof(DIMenuSubsystem_GetTopmostMenu, ReturnValue) == 0x000000, "Member 'DIMenuSubsystem_GetTopmostMenu::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.GetTopmostMenuName
// 0x0008 (0x0008 - 0x0000)
struct DIMenuSubsystem_GetTopmostMenuName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_GetTopmostMenuName) == 0x000004, "Wrong alignment on DIMenuSubsystem_GetTopmostMenuName");
static_assert(sizeof(DIMenuSubsystem_GetTopmostMenuName) == 0x000008, "Wrong size on DIMenuSubsystem_GetTopmostMenuName");
static_assert(offsetof(DIMenuSubsystem_GetTopmostMenuName, ReturnValue) == 0x000000, "Member 'DIMenuSubsystem_GetTopmostMenuName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.HasActiveMenus
// 0x0001 (0x0001 - 0x0000)
struct DIMenuSubsystem_HasActiveMenus final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_HasActiveMenus) == 0x000001, "Wrong alignment on DIMenuSubsystem_HasActiveMenus");
static_assert(sizeof(DIMenuSubsystem_HasActiveMenus) == 0x000001, "Wrong size on DIMenuSubsystem_HasActiveMenus");
static_assert(offsetof(DIMenuSubsystem_HasActiveMenus, ReturnValue) == 0x000000, "Member 'DIMenuSubsystem_HasActiveMenus::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.HasActiveMenusOrPopup
// 0x0001 (0x0001 - 0x0000)
struct DIMenuSubsystem_HasActiveMenusOrPopup final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_HasActiveMenusOrPopup) == 0x000001, "Wrong alignment on DIMenuSubsystem_HasActiveMenusOrPopup");
static_assert(sizeof(DIMenuSubsystem_HasActiveMenusOrPopup) == 0x000001, "Wrong size on DIMenuSubsystem_HasActiveMenusOrPopup");
static_assert(offsetof(DIMenuSubsystem_HasActiveMenusOrPopup, ReturnValue) == 0x000000, "Member 'DIMenuSubsystem_HasActiveMenusOrPopup::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.IsGamepadUsableForMenus
// 0x0001 (0x0001 - 0x0000)
struct DIMenuSubsystem_IsGamepadUsableForMenus final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_IsGamepadUsableForMenus) == 0x000001, "Wrong alignment on DIMenuSubsystem_IsGamepadUsableForMenus");
static_assert(sizeof(DIMenuSubsystem_IsGamepadUsableForMenus) == 0x000001, "Wrong size on DIMenuSubsystem_IsGamepadUsableForMenus");
static_assert(offsetof(DIMenuSubsystem_IsGamepadUsableForMenus, ReturnValue) == 0x000000, "Member 'DIMenuSubsystem_IsGamepadUsableForMenus::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.IsInActiveMenu
// 0x000C (0x000C - 0x0000)
struct DIMenuSubsystem_IsInActiveMenu final
{
public:
	class FName                                   InName;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIMenuSubsystem_IsInActiveMenu) == 0x000004, "Wrong alignment on DIMenuSubsystem_IsInActiveMenu");
static_assert(sizeof(DIMenuSubsystem_IsInActiveMenu) == 0x00000C, "Wrong size on DIMenuSubsystem_IsInActiveMenu");
static_assert(offsetof(DIMenuSubsystem_IsInActiveMenu, InName) == 0x000000, "Member 'DIMenuSubsystem_IsInActiveMenu::InName' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_IsInActiveMenu, ReturnValue) == 0x000008, "Member 'DIMenuSubsystem_IsInActiveMenu::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.IsInActiveMenuInstance
// 0x0010 (0x0010 - 0x0000)
struct DIMenuSubsystem_IsInActiveMenuInstance final
{
public:
	class UDIMenuUserWidget*                      InMenu;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIMenuSubsystem_IsInActiveMenuInstance) == 0x000008, "Wrong alignment on DIMenuSubsystem_IsInActiveMenuInstance");
static_assert(sizeof(DIMenuSubsystem_IsInActiveMenuInstance) == 0x000010, "Wrong size on DIMenuSubsystem_IsInActiveMenuInstance");
static_assert(offsetof(DIMenuSubsystem_IsInActiveMenuInstance, InMenu) == 0x000000, "Member 'DIMenuSubsystem_IsInActiveMenuInstance::InMenu' has a wrong offset!");
static_assert(offsetof(DIMenuSubsystem_IsInActiveMenuInstance, ReturnValue) == 0x000008, "Member 'DIMenuSubsystem_IsInActiveMenuInstance::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIMenuSubsystem.IsMenuBackKeyHeld
// 0x0001 (0x0001 - 0x0000)
struct DIMenuSubsystem_IsMenuBackKeyHeld final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIMenuSubsystem_IsMenuBackKeyHeld) == 0x000001, "Wrong alignment on DIMenuSubsystem_IsMenuBackKeyHeld");
static_assert(sizeof(DIMenuSubsystem_IsMenuBackKeyHeld) == 0x000001, "Wrong size on DIMenuSubsystem_IsMenuBackKeyHeld");
static_assert(offsetof(DIMenuSubsystem_IsMenuBackKeyHeld, ReturnValue) == 0x000000, "Member 'DIMenuSubsystem_IsMenuBackKeyHeld::ReturnValue' has a wrong offset!");

// Function DeceiveInc.HansActiveAbilityMod1.BP_OnHansActiveProjectileHit
// 0x0020 (0x0020 - 0x0000)
struct HansActiveAbilityMod1_BP_OnHansActiveProjectileHit final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPoint;                                       // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactNormal;                                      // 0x0014(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HansActiveAbilityMod1_BP_OnHansActiveProjectileHit) == 0x000008, "Wrong alignment on HansActiveAbilityMod1_BP_OnHansActiveProjectileHit");
static_assert(sizeof(HansActiveAbilityMod1_BP_OnHansActiveProjectileHit) == 0x000020, "Wrong size on HansActiveAbilityMod1_BP_OnHansActiveProjectileHit");
static_assert(offsetof(HansActiveAbilityMod1_BP_OnHansActiveProjectileHit, Victim) == 0x000000, "Member 'HansActiveAbilityMod1_BP_OnHansActiveProjectileHit::Victim' has a wrong offset!");
static_assert(offsetof(HansActiveAbilityMod1_BP_OnHansActiveProjectileHit, ImpactPoint) == 0x000008, "Member 'HansActiveAbilityMod1_BP_OnHansActiveProjectileHit::ImpactPoint' has a wrong offset!");
static_assert(offsetof(HansActiveAbilityMod1_BP_OnHansActiveProjectileHit, ImpactNormal) == 0x000014, "Member 'HansActiveAbilityMod1_BP_OnHansActiveProjectileHit::ImpactNormal' has a wrong offset!");

// Function DeceiveInc.HansActiveAbilityMod1.BP_OnHansTargetInfected
// 0x0010 (0x0010 - 0x0000)
struct HansActiveAbilityMod1_BP_OnHansTargetInfected final
{
public:
	class AActor*                                 LastInfectedVictim;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 NewInfectedVictim;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HansActiveAbilityMod1_BP_OnHansTargetInfected) == 0x000008, "Wrong alignment on HansActiveAbilityMod1_BP_OnHansTargetInfected");
static_assert(sizeof(HansActiveAbilityMod1_BP_OnHansTargetInfected) == 0x000010, "Wrong size on HansActiveAbilityMod1_BP_OnHansTargetInfected");
static_assert(offsetof(HansActiveAbilityMod1_BP_OnHansTargetInfected, LastInfectedVictim) == 0x000000, "Member 'HansActiveAbilityMod1_BP_OnHansTargetInfected::LastInfectedVictim' has a wrong offset!");
static_assert(offsetof(HansActiveAbilityMod1_BP_OnHansTargetInfected, NewInfectedVictim) == 0x000008, "Member 'HansActiveAbilityMod1_BP_OnHansTargetInfected::NewInfectedVictim' has a wrong offset!");

// Function DeceiveInc.HansActiveAbilityMod1.MulticastFireShot
// 0x000C (0x000C - 0x0000)
struct HansActiveAbilityMod1_MulticastFireShot final
{
public:
	struct FVector_NetQuantize                    DestinationPos;                                    // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HansActiveAbilityMod1_MulticastFireShot) == 0x000004, "Wrong alignment on HansActiveAbilityMod1_MulticastFireShot");
static_assert(sizeof(HansActiveAbilityMod1_MulticastFireShot) == 0x00000C, "Wrong size on HansActiveAbilityMod1_MulticastFireShot");
static_assert(offsetof(HansActiveAbilityMod1_MulticastFireShot, DestinationPos) == 0x000000, "Member 'HansActiveAbilityMod1_MulticastFireShot::DestinationPos' has a wrong offset!");

// Function DeceiveInc.HansActiveAbilityMod1.MulticastNewInfectedVictim
// 0x0010 (0x0010 - 0x0000)
struct HansActiveAbilityMod1_MulticastNewInfectedVictim final
{
public:
	class AActor*                                 LastInfectedVictim;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 NewInfectedVictim;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HansActiveAbilityMod1_MulticastNewInfectedVictim) == 0x000008, "Wrong alignment on HansActiveAbilityMod1_MulticastNewInfectedVictim");
static_assert(sizeof(HansActiveAbilityMod1_MulticastNewInfectedVictim) == 0x000010, "Wrong size on HansActiveAbilityMod1_MulticastNewInfectedVictim");
static_assert(offsetof(HansActiveAbilityMod1_MulticastNewInfectedVictim, LastInfectedVictim) == 0x000000, "Member 'HansActiveAbilityMod1_MulticastNewInfectedVictim::LastInfectedVictim' has a wrong offset!");
static_assert(offsetof(HansActiveAbilityMod1_MulticastNewInfectedVictim, NewInfectedVictim) == 0x000008, "Member 'HansActiveAbilityMod1_MulticastNewInfectedVictim::NewInfectedVictim' has a wrong offset!");

// Function DeceiveInc.HansActiveAbilityMod1.MulticastProjectileHit
// 0x0020 (0x0020 - 0x0000)
struct HansActiveAbilityMod1_MulticastProjectileHit final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    ImpactPos;                                         // 0x0008(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              ImpactNormal;                                      // 0x0014(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HansActiveAbilityMod1_MulticastProjectileHit) == 0x000008, "Wrong alignment on HansActiveAbilityMod1_MulticastProjectileHit");
static_assert(sizeof(HansActiveAbilityMod1_MulticastProjectileHit) == 0x000020, "Wrong size on HansActiveAbilityMod1_MulticastProjectileHit");
static_assert(offsetof(HansActiveAbilityMod1_MulticastProjectileHit, Victim) == 0x000000, "Member 'HansActiveAbilityMod1_MulticastProjectileHit::Victim' has a wrong offset!");
static_assert(offsetof(HansActiveAbilityMod1_MulticastProjectileHit, ImpactPos) == 0x000008, "Member 'HansActiveAbilityMod1_MulticastProjectileHit::ImpactPos' has a wrong offset!");
static_assert(offsetof(HansActiveAbilityMod1_MulticastProjectileHit, ImpactNormal) == 0x000014, "Member 'HansActiveAbilityMod1_MulticastProjectileHit::ImpactNormal' has a wrong offset!");

// Function DeceiveInc.HansActiveAbilityMod1.GetMuzzlePosition
// 0x000C (0x000C - 0x0000)
struct HansActiveAbilityMod1_GetMuzzlePosition final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HansActiveAbilityMod1_GetMuzzlePosition) == 0x000004, "Wrong alignment on HansActiveAbilityMod1_GetMuzzlePosition");
static_assert(sizeof(HansActiveAbilityMod1_GetMuzzlePosition) == 0x00000C, "Wrong size on HansActiveAbilityMod1_GetMuzzlePosition");
static_assert(offsetof(HansActiveAbilityMod1_GetMuzzlePosition, ReturnValue) == 0x000000, "Member 'HansActiveAbilityMod1_GetMuzzlePosition::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.GetMaxPartySizeForGameMode
// 0x0008 (0x0008 - 0x0000)
struct DIPartySubsystem_GetMaxPartySizeForGameMode final
{
public:
	EDIGameMode                                   NewMode;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_GetMaxPartySizeForGameMode) == 0x000004, "Wrong alignment on DIPartySubsystem_GetMaxPartySizeForGameMode");
static_assert(sizeof(DIPartySubsystem_GetMaxPartySizeForGameMode) == 0x000008, "Wrong size on DIPartySubsystem_GetMaxPartySizeForGameMode");
static_assert(offsetof(DIPartySubsystem_GetMaxPartySizeForGameMode, NewMode) == 0x000000, "Member 'DIPartySubsystem_GetMaxPartySizeForGameMode::NewMode' has a wrong offset!");
static_assert(offsetof(DIPartySubsystem_GetMaxPartySizeForGameMode, ReturnValue) == 0x000004, "Member 'DIPartySubsystem_GetMaxPartySizeForGameMode::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.GetMinPartySizeForGameMode
// 0x0008 (0x0008 - 0x0000)
struct DIPartySubsystem_GetMinPartySizeForGameMode final
{
public:
	EDIGameMode                                   NewMode;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_GetMinPartySizeForGameMode) == 0x000004, "Wrong alignment on DIPartySubsystem_GetMinPartySizeForGameMode");
static_assert(sizeof(DIPartySubsystem_GetMinPartySizeForGameMode) == 0x000008, "Wrong size on DIPartySubsystem_GetMinPartySizeForGameMode");
static_assert(offsetof(DIPartySubsystem_GetMinPartySizeForGameMode, NewMode) == 0x000000, "Member 'DIPartySubsystem_GetMinPartySizeForGameMode::NewMode' has a wrong offset!");
static_assert(offsetof(DIPartySubsystem_GetMinPartySizeForGameMode, ReturnValue) == 0x000004, "Member 'DIPartySubsystem_GetMinPartySizeForGameMode::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.AcceptPartyInviteFrom
// 0x0010 (0x0010 - 0x0000)
struct DIPartySubsystem_AcceptPartyInviteFrom final
{
public:
	class FString                                 InviteSourceName;                                  // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_AcceptPartyInviteFrom) == 0x000008, "Wrong alignment on DIPartySubsystem_AcceptPartyInviteFrom");
static_assert(sizeof(DIPartySubsystem_AcceptPartyInviteFrom) == 0x000010, "Wrong size on DIPartySubsystem_AcceptPartyInviteFrom");
static_assert(offsetof(DIPartySubsystem_AcceptPartyInviteFrom, InviteSourceName) == 0x000000, "Member 'DIPartySubsystem_AcceptPartyInviteFrom::InviteSourceName' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.CanInviteToParty
// 0x0001 (0x0001 - 0x0000)
struct DIPartySubsystem_CanInviteToParty final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_CanInviteToParty) == 0x000001, "Wrong alignment on DIPartySubsystem_CanInviteToParty");
static_assert(sizeof(DIPartySubsystem_CanInviteToParty) == 0x000001, "Wrong size on DIPartySubsystem_CanInviteToParty");
static_assert(offsetof(DIPartySubsystem_CanInviteToParty, ReturnValue) == 0x000000, "Member 'DIPartySubsystem_CanInviteToParty::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.CanStartMatchmaking
// 0x0001 (0x0001 - 0x0000)
struct DIPartySubsystem_CanStartMatchmaking final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_CanStartMatchmaking) == 0x000001, "Wrong alignment on DIPartySubsystem_CanStartMatchmaking");
static_assert(sizeof(DIPartySubsystem_CanStartMatchmaking) == 0x000001, "Wrong size on DIPartySubsystem_CanStartMatchmaking");
static_assert(offsetof(DIPartySubsystem_CanStartMatchmaking, ReturnValue) == 0x000000, "Member 'DIPartySubsystem_CanStartMatchmaking::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.GetInviteeName
// 0x0010 (0x0010 - 0x0000)
struct DIPartySubsystem_GetInviteeName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_GetInviteeName) == 0x000008, "Wrong alignment on DIPartySubsystem_GetInviteeName");
static_assert(sizeof(DIPartySubsystem_GetInviteeName) == 0x000010, "Wrong size on DIPartySubsystem_GetInviteeName");
static_assert(offsetof(DIPartySubsystem_GetInviteeName, ReturnValue) == 0x000000, "Member 'DIPartySubsystem_GetInviteeName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.GetNbrPendingInvites
// 0x0004 (0x0004 - 0x0000)
struct DIPartySubsystem_GetNbrPendingInvites final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_GetNbrPendingInvites) == 0x000004, "Wrong alignment on DIPartySubsystem_GetNbrPendingInvites");
static_assert(sizeof(DIPartySubsystem_GetNbrPendingInvites) == 0x000004, "Wrong size on DIPartySubsystem_GetNbrPendingInvites");
static_assert(offsetof(DIPartySubsystem_GetNbrPendingInvites, ReturnValue) == 0x000000, "Member 'DIPartySubsystem_GetNbrPendingInvites::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.GetPartyMemberByDisplayIndex
// 0x0010 (0x0010 - 0x0000)
struct DIPartySubsystem_GetPartyMemberByDisplayIndex final
{
public:
	int32                                         DisplayIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDIOnlinePartyMemberInfo*               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_GetPartyMemberByDisplayIndex) == 0x000008, "Wrong alignment on DIPartySubsystem_GetPartyMemberByDisplayIndex");
static_assert(sizeof(DIPartySubsystem_GetPartyMemberByDisplayIndex) == 0x000010, "Wrong size on DIPartySubsystem_GetPartyMemberByDisplayIndex");
static_assert(offsetof(DIPartySubsystem_GetPartyMemberByDisplayIndex, DisplayIndex) == 0x000000, "Member 'DIPartySubsystem_GetPartyMemberByDisplayIndex::DisplayIndex' has a wrong offset!");
static_assert(offsetof(DIPartySubsystem_GetPartyMemberByDisplayIndex, ReturnValue) == 0x000008, "Member 'DIPartySubsystem_GetPartyMemberByDisplayIndex::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.InviteFriend
// 0x0008 (0x0008 - 0x0000)
struct DIPartySubsystem_InviteFriend final
{
public:
	const class UDIOnlineFriendInfo*              FriendInfo;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_InviteFriend) == 0x000008, "Wrong alignment on DIPartySubsystem_InviteFriend");
static_assert(sizeof(DIPartySubsystem_InviteFriend) == 0x000008, "Wrong size on DIPartySubsystem_InviteFriend");
static_assert(offsetof(DIPartySubsystem_InviteFriend, FriendInfo) == 0x000000, "Member 'DIPartySubsystem_InviteFriend::FriendInfo' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.InvitePlayer
// 0x0010 (0x0010 - 0x0000)
struct DIPartySubsystem_InvitePlayer final
{
public:
	class FString                                 PlayerUId;                                         // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_InvitePlayer) == 0x000008, "Wrong alignment on DIPartySubsystem_InvitePlayer");
static_assert(sizeof(DIPartySubsystem_InvitePlayer) == 0x000010, "Wrong size on DIPartySubsystem_InvitePlayer");
static_assert(offsetof(DIPartySubsystem_InvitePlayer, PlayerUId) == 0x000000, "Member 'DIPartySubsystem_InvitePlayer::PlayerUId' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.IsAllowedCrossplay
// 0x0001 (0x0001 - 0x0000)
struct DIPartySubsystem_IsAllowedCrossplay final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_IsAllowedCrossplay) == 0x000001, "Wrong alignment on DIPartySubsystem_IsAllowedCrossplay");
static_assert(sizeof(DIPartySubsystem_IsAllowedCrossplay) == 0x000001, "Wrong size on DIPartySubsystem_IsAllowedCrossplay");
static_assert(offsetof(DIPartySubsystem_IsAllowedCrossplay, ReturnValue) == 0x000000, "Member 'DIPartySubsystem_IsAllowedCrossplay::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.IsGameCompatibleWithCurrentParty
// 0x0002 (0x0002 - 0x0000)
struct DIPartySubsystem_IsGameCompatibleWithCurrentParty final
{
public:
	EDIGameMode                                   GameMode;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_IsGameCompatibleWithCurrentParty) == 0x000001, "Wrong alignment on DIPartySubsystem_IsGameCompatibleWithCurrentParty");
static_assert(sizeof(DIPartySubsystem_IsGameCompatibleWithCurrentParty) == 0x000002, "Wrong size on DIPartySubsystem_IsGameCompatibleWithCurrentParty");
static_assert(offsetof(DIPartySubsystem_IsGameCompatibleWithCurrentParty, GameMode) == 0x000000, "Member 'DIPartySubsystem_IsGameCompatibleWithCurrentParty::GameMode' has a wrong offset!");
static_assert(offsetof(DIPartySubsystem_IsGameCompatibleWithCurrentParty, ReturnValue) == 0x000001, "Member 'DIPartySubsystem_IsGameCompatibleWithCurrentParty::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.IsGameModeSelectable
// 0x0002 (0x0002 - 0x0000)
struct DIPartySubsystem_IsGameModeSelectable final
{
public:
	EDIGameMode                                   GameMode;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_IsGameModeSelectable) == 0x000001, "Wrong alignment on DIPartySubsystem_IsGameModeSelectable");
static_assert(sizeof(DIPartySubsystem_IsGameModeSelectable) == 0x000002, "Wrong size on DIPartySubsystem_IsGameModeSelectable");
static_assert(offsetof(DIPartySubsystem_IsGameModeSelectable, GameMode) == 0x000000, "Member 'DIPartySubsystem_IsGameModeSelectable::GameMode' has a wrong offset!");
static_assert(offsetof(DIPartySubsystem_IsGameModeSelectable, ReturnValue) == 0x000001, "Member 'DIPartySubsystem_IsGameModeSelectable::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.IsInSoloPartyOrNotInParty
// 0x0001 (0x0001 - 0x0000)
struct DIPartySubsystem_IsInSoloPartyOrNotInParty final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_IsInSoloPartyOrNotInParty) == 0x000001, "Wrong alignment on DIPartySubsystem_IsInSoloPartyOrNotInParty");
static_assert(sizeof(DIPartySubsystem_IsInSoloPartyOrNotInParty) == 0x000001, "Wrong size on DIPartySubsystem_IsInSoloPartyOrNotInParty");
static_assert(offsetof(DIPartySubsystem_IsInSoloPartyOrNotInParty, ReturnValue) == 0x000000, "Member 'DIPartySubsystem_IsInSoloPartyOrNotInParty::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.IsPartyMemberLeader
// 0x0010 (0x0010 - 0x0000)
struct DIPartySubsystem_IsPartyMemberLeader final
{
public:
	class UDIOnlinePartyMemberInfo*               PartyMember;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIPartySubsystem_IsPartyMemberLeader) == 0x000008, "Wrong alignment on DIPartySubsystem_IsPartyMemberLeader");
static_assert(sizeof(DIPartySubsystem_IsPartyMemberLeader) == 0x000010, "Wrong size on DIPartySubsystem_IsPartyMemberLeader");
static_assert(offsetof(DIPartySubsystem_IsPartyMemberLeader, PartyMember) == 0x000000, "Member 'DIPartySubsystem_IsPartyMemberLeader::PartyMember' has a wrong offset!");
static_assert(offsetof(DIPartySubsystem_IsPartyMemberLeader, ReturnValue) == 0x000008, "Member 'DIPartySubsystem_IsPartyMemberLeader::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.KickMember
// 0x0008 (0x0008 - 0x0000)
struct DIPartySubsystem_KickMember final
{
public:
	class UDIOnlinePartyMemberInfo*               PartyMember;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_KickMember) == 0x000008, "Wrong alignment on DIPartySubsystem_KickMember");
static_assert(sizeof(DIPartySubsystem_KickMember) == 0x000008, "Wrong size on DIPartySubsystem_KickMember");
static_assert(offsetof(DIPartySubsystem_KickMember, PartyMember) == 0x000000, "Member 'DIPartySubsystem_KickMember::PartyMember' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.LeaveParty
// 0x0001 (0x0001 - 0x0000)
struct DIPartySubsystem_LeaveParty final
{
public:
	bool                                          bSynchronized;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_LeaveParty) == 0x000001, "Wrong alignment on DIPartySubsystem_LeaveParty");
static_assert(sizeof(DIPartySubsystem_LeaveParty) == 0x000001, "Wrong size on DIPartySubsystem_LeaveParty");
static_assert(offsetof(DIPartySubsystem_LeaveParty, bSynchronized) == 0x000000, "Member 'DIPartySubsystem_LeaveParty::bSynchronized' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.RejectPartyInviteFrom
// 0x0010 (0x0010 - 0x0000)
struct DIPartySubsystem_RejectPartyInviteFrom final
{
public:
	class FString                                 InviteSourceName;                                  // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_RejectPartyInviteFrom) == 0x000008, "Wrong alignment on DIPartySubsystem_RejectPartyInviteFrom");
static_assert(sizeof(DIPartySubsystem_RejectPartyInviteFrom) == 0x000010, "Wrong size on DIPartySubsystem_RejectPartyInviteFrom");
static_assert(offsetof(DIPartySubsystem_RejectPartyInviteFrom, InviteSourceName) == 0x000000, "Member 'DIPartySubsystem_RejectPartyInviteFrom::InviteSourceName' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.TrySetCurrentGameMode
// 0x0002 (0x0002 - 0x0000)
struct DIPartySubsystem_TrySetCurrentGameMode final
{
public:
	EDIGameMode                                   NewMode;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDIGameMode                                   ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_TrySetCurrentGameMode) == 0x000001, "Wrong alignment on DIPartySubsystem_TrySetCurrentGameMode");
static_assert(sizeof(DIPartySubsystem_TrySetCurrentGameMode) == 0x000002, "Wrong size on DIPartySubsystem_TrySetCurrentGameMode");
static_assert(offsetof(DIPartySubsystem_TrySetCurrentGameMode, NewMode) == 0x000000, "Member 'DIPartySubsystem_TrySetCurrentGameMode::NewMode' has a wrong offset!");
static_assert(offsetof(DIPartySubsystem_TrySetCurrentGameMode, ReturnValue) == 0x000001, "Member 'DIPartySubsystem_TrySetCurrentGameMode::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.TryStartMatchmaking
// 0x0001 (0x0001 - 0x0000)
struct DIPartySubsystem_TryStartMatchmaking final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_TryStartMatchmaking) == 0x000001, "Wrong alignment on DIPartySubsystem_TryStartMatchmaking");
static_assert(sizeof(DIPartySubsystem_TryStartMatchmaking) == 0x000001, "Wrong size on DIPartySubsystem_TryStartMatchmaking");
static_assert(offsetof(DIPartySubsystem_TryStartMatchmaking, ReturnValue) == 0x000000, "Member 'DIPartySubsystem_TryStartMatchmaking::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.GetCurrentGameMode
// 0x0001 (0x0001 - 0x0000)
struct DIPartySubsystem_GetCurrentGameMode final
{
public:
	EDIGameMode                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_GetCurrentGameMode) == 0x000001, "Wrong alignment on DIPartySubsystem_GetCurrentGameMode");
static_assert(sizeof(DIPartySubsystem_GetCurrentGameMode) == 0x000001, "Wrong size on DIPartySubsystem_GetCurrentGameMode");
static_assert(offsetof(DIPartySubsystem_GetCurrentGameMode, ReturnValue) == 0x000000, "Member 'DIPartySubsystem_GetCurrentGameMode::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.GetInvitationForDIOnlineFriend
// 0x0010 (0x0010 - 0x0000)
struct DIPartySubsystem_GetInvitationForDIOnlineFriend final
{
public:
	const class UDIOnlineFriendInfo*              FriendInfo;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDIOnlinePartyInvite*                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_GetInvitationForDIOnlineFriend) == 0x000008, "Wrong alignment on DIPartySubsystem_GetInvitationForDIOnlineFriend");
static_assert(sizeof(DIPartySubsystem_GetInvitationForDIOnlineFriend) == 0x000010, "Wrong size on DIPartySubsystem_GetInvitationForDIOnlineFriend");
static_assert(offsetof(DIPartySubsystem_GetInvitationForDIOnlineFriend, FriendInfo) == 0x000000, "Member 'DIPartySubsystem_GetInvitationForDIOnlineFriend::FriendInfo' has a wrong offset!");
static_assert(offsetof(DIPartySubsystem_GetInvitationForDIOnlineFriend, ReturnValue) == 0x000008, "Member 'DIPartySubsystem_GetInvitationForDIOnlineFriend::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.GetLocalPartyMember
// 0x0008 (0x0008 - 0x0000)
struct DIPartySubsystem_GetLocalPartyMember final
{
public:
	class UDIOnlinePartyMemberInfo*               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_GetLocalPartyMember) == 0x000008, "Wrong alignment on DIPartySubsystem_GetLocalPartyMember");
static_assert(sizeof(DIPartySubsystem_GetLocalPartyMember) == 0x000008, "Wrong size on DIPartySubsystem_GetLocalPartyMember");
static_assert(offsetof(DIPartySubsystem_GetLocalPartyMember, ReturnValue) == 0x000000, "Member 'DIPartySubsystem_GetLocalPartyMember::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.GetMatchmakingAvailabilityForCurrentMode
// 0x0001 (0x0001 - 0x0000)
struct DIPartySubsystem_GetMatchmakingAvailabilityForCurrentMode final
{
public:
	EMatchmakingAvailability                      ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_GetMatchmakingAvailabilityForCurrentMode) == 0x000001, "Wrong alignment on DIPartySubsystem_GetMatchmakingAvailabilityForCurrentMode");
static_assert(sizeof(DIPartySubsystem_GetMatchmakingAvailabilityForCurrentMode) == 0x000001, "Wrong size on DIPartySubsystem_GetMatchmakingAvailabilityForCurrentMode");
static_assert(offsetof(DIPartySubsystem_GetMatchmakingAvailabilityForCurrentMode, ReturnValue) == 0x000000, "Member 'DIPartySubsystem_GetMatchmakingAvailabilityForCurrentMode::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.GetMatchmakingAvailabilityForMode
// 0x0002 (0x0002 - 0x0000)
struct DIPartySubsystem_GetMatchmakingAvailabilityForMode final
{
public:
	EDIGameMode                                   GameMode;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchmakingAvailability                      ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_GetMatchmakingAvailabilityForMode) == 0x000001, "Wrong alignment on DIPartySubsystem_GetMatchmakingAvailabilityForMode");
static_assert(sizeof(DIPartySubsystem_GetMatchmakingAvailabilityForMode) == 0x000002, "Wrong size on DIPartySubsystem_GetMatchmakingAvailabilityForMode");
static_assert(offsetof(DIPartySubsystem_GetMatchmakingAvailabilityForMode, GameMode) == 0x000000, "Member 'DIPartySubsystem_GetMatchmakingAvailabilityForMode::GameMode' has a wrong offset!");
static_assert(offsetof(DIPartySubsystem_GetMatchmakingAvailabilityForMode, ReturnValue) == 0x000001, "Member 'DIPartySubsystem_GetMatchmakingAvailabilityForMode::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.GetNumberOfPlayersInPartyIncludingSelf
// 0x0004 (0x0004 - 0x0000)
struct DIPartySubsystem_GetNumberOfPlayersInPartyIncludingSelf final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_GetNumberOfPlayersInPartyIncludingSelf) == 0x000004, "Wrong alignment on DIPartySubsystem_GetNumberOfPlayersInPartyIncludingSelf");
static_assert(sizeof(DIPartySubsystem_GetNumberOfPlayersInPartyIncludingSelf) == 0x000004, "Wrong size on DIPartySubsystem_GetNumberOfPlayersInPartyIncludingSelf");
static_assert(offsetof(DIPartySubsystem_GetNumberOfPlayersInPartyIncludingSelf, ReturnValue) == 0x000000, "Member 'DIPartySubsystem_GetNumberOfPlayersInPartyIncludingSelf::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.IsAllPartyMembersReady
// 0x0001 (0x0001 - 0x0000)
struct DIPartySubsystem_IsAllPartyMembersReady final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_IsAllPartyMembersReady) == 0x000001, "Wrong alignment on DIPartySubsystem_IsAllPartyMembersReady");
static_assert(sizeof(DIPartySubsystem_IsAllPartyMembersReady) == 0x000001, "Wrong size on DIPartySubsystem_IsAllPartyMembersReady");
static_assert(offsetof(DIPartySubsystem_IsAllPartyMembersReady, ReturnValue) == 0x000000, "Member 'DIPartySubsystem_IsAllPartyMembersReady::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.IsBeginnerProtectionEnabledForCurrentGameMode
// 0x0001 (0x0001 - 0x0000)
struct DIPartySubsystem_IsBeginnerProtectionEnabledForCurrentGameMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_IsBeginnerProtectionEnabledForCurrentGameMode) == 0x000001, "Wrong alignment on DIPartySubsystem_IsBeginnerProtectionEnabledForCurrentGameMode");
static_assert(sizeof(DIPartySubsystem_IsBeginnerProtectionEnabledForCurrentGameMode) == 0x000001, "Wrong size on DIPartySubsystem_IsBeginnerProtectionEnabledForCurrentGameMode");
static_assert(offsetof(DIPartySubsystem_IsBeginnerProtectionEnabledForCurrentGameMode, ReturnValue) == 0x000000, "Member 'DIPartySubsystem_IsBeginnerProtectionEnabledForCurrentGameMode::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.IsGameModeOffered
// 0x0002 (0x0002 - 0x0000)
struct DIPartySubsystem_IsGameModeOffered final
{
public:
	EDIGameMode                                   GameMode;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_IsGameModeOffered) == 0x000001, "Wrong alignment on DIPartySubsystem_IsGameModeOffered");
static_assert(sizeof(DIPartySubsystem_IsGameModeOffered) == 0x000002, "Wrong size on DIPartySubsystem_IsGameModeOffered");
static_assert(offsetof(DIPartySubsystem_IsGameModeOffered, GameMode) == 0x000000, "Member 'DIPartySubsystem_IsGameModeOffered::GameMode' has a wrong offset!");
static_assert(offsetof(DIPartySubsystem_IsGameModeOffered, ReturnValue) == 0x000001, "Member 'DIPartySubsystem_IsGameModeOffered::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.IsInParty
// 0x0001 (0x0001 - 0x0000)
struct DIPartySubsystem_IsInParty final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_IsInParty) == 0x000001, "Wrong alignment on DIPartySubsystem_IsInParty");
static_assert(sizeof(DIPartySubsystem_IsInParty) == 0x000001, "Wrong size on DIPartySubsystem_IsInParty");
static_assert(offsetof(DIPartySubsystem_IsInParty, ReturnValue) == 0x000000, "Member 'DIPartySubsystem_IsInParty::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.IsLocalPartyMember
// 0x0010 (0x0010 - 0x0000)
struct DIPartySubsystem_IsLocalPartyMember final
{
public:
	class UDIOnlinePartyMemberInfo*               Member;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIPartySubsystem_IsLocalPartyMember) == 0x000008, "Wrong alignment on DIPartySubsystem_IsLocalPartyMember");
static_assert(sizeof(DIPartySubsystem_IsLocalPartyMember) == 0x000010, "Wrong size on DIPartySubsystem_IsLocalPartyMember");
static_assert(offsetof(DIPartySubsystem_IsLocalPartyMember, Member) == 0x000000, "Member 'DIPartySubsystem_IsLocalPartyMember::Member' has a wrong offset!");
static_assert(offsetof(DIPartySubsystem_IsLocalPartyMember, ReturnValue) == 0x000008, "Member 'DIPartySubsystem_IsLocalPartyMember::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPartySubsystem.IsPartyLeader
// 0x0001 (0x0001 - 0x0000)
struct DIPartySubsystem_IsPartyLeader final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPartySubsystem_IsPartyLeader) == 0x000001, "Wrong alignment on DIPartySubsystem_IsPartyLeader");
static_assert(sizeof(DIPartySubsystem_IsPartyLeader) == 0x000001, "Wrong size on DIPartySubsystem_IsPartyLeader");
static_assert(offsetof(DIPartySubsystem_IsPartyLeader, ReturnValue) == 0x000000, "Member 'DIPartySubsystem_IsPartyLeader::ReturnValue' has a wrong offset!");

// Function DeceiveInc.HackTrapScannerTool.NetMulticast_OnNewAnnouncement
// 0x0008 (0x0008 - 0x0000)
struct HackTrapScannerTool_NetMulticast_OnNewAnnouncement final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HackTrapScannerTool_NetMulticast_OnNewAnnouncement) == 0x000008, "Wrong alignment on HackTrapScannerTool_NetMulticast_OnNewAnnouncement");
static_assert(sizeof(HackTrapScannerTool_NetMulticast_OnNewAnnouncement) == 0x000008, "Wrong size on HackTrapScannerTool_NetMulticast_OnNewAnnouncement");
static_assert(offsetof(HackTrapScannerTool_NetMulticast_OnNewAnnouncement, Victim) == 0x000000, "Member 'HackTrapScannerTool_NetMulticast_OnNewAnnouncement::Victim' has a wrong offset!");

// Function DeceiveInc.HackTrapScannerTool.NetMulticast_OnTrapTrigger
// 0x0010 (0x0010 - 0x0000)
struct HackTrapScannerTool_NetMulticast_OnTrapTrigger final
{
public:
	class UHackTrapScannableComponent*            Trap;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HackTrapScannerTool_NetMulticast_OnTrapTrigger) == 0x000008, "Wrong alignment on HackTrapScannerTool_NetMulticast_OnTrapTrigger");
static_assert(sizeof(HackTrapScannerTool_NetMulticast_OnTrapTrigger) == 0x000010, "Wrong size on HackTrapScannerTool_NetMulticast_OnTrapTrigger");
static_assert(offsetof(HackTrapScannerTool_NetMulticast_OnTrapTrigger, Trap) == 0x000000, "Member 'HackTrapScannerTool_NetMulticast_OnTrapTrigger::Trap' has a wrong offset!");
static_assert(offsetof(HackTrapScannerTool_NetMulticast_OnTrapTrigger, Victim) == 0x000008, "Member 'HackTrapScannerTool_NetMulticast_OnTrapTrigger::Victim' has a wrong offset!");

// Function DeceiveInc.HackTrapScannerTool.OnAnnouncementTimerEnd
// 0x0008 (0x0008 - 0x0000)
struct HackTrapScannerTool_OnAnnouncementTimerEnd final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HackTrapScannerTool_OnAnnouncementTimerEnd) == 0x000008, "Wrong alignment on HackTrapScannerTool_OnAnnouncementTimerEnd");
static_assert(sizeof(HackTrapScannerTool_OnAnnouncementTimerEnd) == 0x000008, "Wrong size on HackTrapScannerTool_OnAnnouncementTimerEnd");
static_assert(offsetof(HackTrapScannerTool_OnAnnouncementTimerEnd, Victim) == 0x000000, "Member 'HackTrapScannerTool_OnAnnouncementTimerEnd::Victim' has a wrong offset!");

// Function DeceiveInc.HackTrapScannerTool.OnCooldownChange
// 0x0001 (0x0001 - 0x0000)
struct HackTrapScannerTool_OnCooldownChange final
{
public:
	bool                                          bOnCooldown;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HackTrapScannerTool_OnCooldownChange) == 0x000001, "Wrong alignment on HackTrapScannerTool_OnCooldownChange");
static_assert(sizeof(HackTrapScannerTool_OnCooldownChange) == 0x000001, "Wrong size on HackTrapScannerTool_OnCooldownChange");
static_assert(offsetof(HackTrapScannerTool_OnCooldownChange, bOnCooldown) == 0x000000, "Member 'HackTrapScannerTool_OnCooldownChange::bOnCooldown' has a wrong offset!");

// Function DeceiveInc.DIPingWidget.BP_SetupPingData
// 0x0058 (0x0058 - 0x0000)
struct DIPingWidget_BP_SetupPingData final
{
public:
	struct FPingData                              PingData;                                          // 0x0000(0x0058)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPingWidget_BP_SetupPingData) == 0x000008, "Wrong alignment on DIPingWidget_BP_SetupPingData");
static_assert(sizeof(DIPingWidget_BP_SetupPingData) == 0x000058, "Wrong size on DIPingWidget_BP_SetupPingData");
static_assert(offsetof(DIPingWidget_BP_SetupPingData, PingData) == 0x000000, "Member 'DIPingWidget_BP_SetupPingData::PingData' has a wrong offset!");

// Function DeceiveInc.DIPingWidget.BP_SetupTeamIndex
// 0x0004 (0x0004 - 0x0000)
struct DIPingWidget_BP_SetupTeamIndex final
{
public:
	int32                                         TeamIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPingWidget_BP_SetupTeamIndex) == 0x000004, "Wrong alignment on DIPingWidget_BP_SetupTeamIndex");
static_assert(sizeof(DIPingWidget_BP_SetupTeamIndex) == 0x000004, "Wrong size on DIPingWidget_BP_SetupTeamIndex");
static_assert(offsetof(DIPingWidget_BP_SetupTeamIndex, TeamIndex) == 0x000000, "Member 'DIPingWidget_BP_SetupTeamIndex::TeamIndex' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.IsDX12Enabled
// 0x0001 (0x0001 - 0x0000)
struct DiPlayerSettingsSubsystem_IsDX12Enabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_IsDX12Enabled) == 0x000001, "Wrong alignment on DiPlayerSettingsSubsystem_IsDX12Enabled");
static_assert(sizeof(DiPlayerSettingsSubsystem_IsDX12Enabled) == 0x000001, "Wrong size on DiPlayerSettingsSubsystem_IsDX12Enabled");
static_assert(offsetof(DiPlayerSettingsSubsystem_IsDX12Enabled, ReturnValue) == 0x000000, "Member 'DiPlayerSettingsSubsystem_IsDX12Enabled::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.AddKeyForEnhancedAction
// 0x0030 (0x0030 - 0x0000)
struct DiPlayerSettingsSubsystem_AddKeyForEnhancedAction final
{
public:
	const class UInputAction*                     InputAction;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Binding;                                           // 0x0008(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKeybindContext                               Context;                                           // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AxisScale;                                         // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputDeviceType                              DeviceType;                                        // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0029(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DiPlayerSettingsSubsystem_AddKeyForEnhancedAction) == 0x000008, "Wrong alignment on DiPlayerSettingsSubsystem_AddKeyForEnhancedAction");
static_assert(sizeof(DiPlayerSettingsSubsystem_AddKeyForEnhancedAction) == 0x000030, "Wrong size on DiPlayerSettingsSubsystem_AddKeyForEnhancedAction");
static_assert(offsetof(DiPlayerSettingsSubsystem_AddKeyForEnhancedAction, InputAction) == 0x000000, "Member 'DiPlayerSettingsSubsystem_AddKeyForEnhancedAction::InputAction' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_AddKeyForEnhancedAction, Binding) == 0x000008, "Member 'DiPlayerSettingsSubsystem_AddKeyForEnhancedAction::Binding' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_AddKeyForEnhancedAction, Context) == 0x000020, "Member 'DiPlayerSettingsSubsystem_AddKeyForEnhancedAction::Context' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_AddKeyForEnhancedAction, AxisScale) == 0x000024, "Member 'DiPlayerSettingsSubsystem_AddKeyForEnhancedAction::AxisScale' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_AddKeyForEnhancedAction, DeviceType) == 0x000028, "Member 'DiPlayerSettingsSubsystem_AddKeyForEnhancedAction::DeviceType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_AddKeyForEnhancedAction, ReturnValue) == 0x000029, "Member 'DiPlayerSettingsSubsystem_AddKeyForEnhancedAction::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.ApplyDefaultInputMappings
// 0x0001 (0x0001 - 0x0000)
struct DiPlayerSettingsSubsystem_ApplyDefaultInputMappings final
{
public:
	EInputDeviceType                              DeviceType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_ApplyDefaultInputMappings) == 0x000001, "Wrong alignment on DiPlayerSettingsSubsystem_ApplyDefaultInputMappings");
static_assert(sizeof(DiPlayerSettingsSubsystem_ApplyDefaultInputMappings) == 0x000001, "Wrong size on DiPlayerSettingsSubsystem_ApplyDefaultInputMappings");
static_assert(offsetof(DiPlayerSettingsSubsystem_ApplyDefaultInputMappings, DeviceType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_ApplyDefaultInputMappings::DeviceType' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.CallSettingAction
// 0x0001 (0x0001 - 0x0000)
struct DiPlayerSettingsSubsystem_CallSettingAction final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_CallSettingAction) == 0x000001, "Wrong alignment on DiPlayerSettingsSubsystem_CallSettingAction");
static_assert(sizeof(DiPlayerSettingsSubsystem_CallSettingAction) == 0x000001, "Wrong size on DiPlayerSettingsSubsystem_CallSettingAction");
static_assert(offsetof(DiPlayerSettingsSubsystem_CallSettingAction, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_CallSettingAction::SettingType' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetActionsForCategory
// 0x0018 (0x0018 - 0x0000)
struct DiPlayerSettingsSubsystem_GetActionsForCategory final
{
public:
	EKeybindContext                               Category;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBindableKeyEntry>              ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetActionsForCategory) == 0x000008, "Wrong alignment on DiPlayerSettingsSubsystem_GetActionsForCategory");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetActionsForCategory) == 0x000018, "Wrong size on DiPlayerSettingsSubsystem_GetActionsForCategory");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetActionsForCategory, Category) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetActionsForCategory::Category' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetActionsForCategory, ReturnValue) == 0x000008, "Member 'DiPlayerSettingsSubsystem_GetActionsForCategory::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetAxesForCategory
// 0x0018 (0x0018 - 0x0000)
struct DiPlayerSettingsSubsystem_GetAxesForCategory final
{
public:
	EKeybindContext                               Category;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBindableKeyEntry>              ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetAxesForCategory) == 0x000008, "Wrong alignment on DiPlayerSettingsSubsystem_GetAxesForCategory");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetAxesForCategory) == 0x000018, "Wrong size on DiPlayerSettingsSubsystem_GetAxesForCategory");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetAxesForCategory, Category) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetAxesForCategory::Category' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetAxesForCategory, ReturnValue) == 0x000008, "Member 'DiPlayerSettingsSubsystem_GetAxesForCategory::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetBindableActions
// 0x0010 (0x0010 - 0x0000)
struct DiPlayerSettingsSubsystem_GetBindableActions final
{
public:
	TArray<struct FBindableKeyEntry>              ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetBindableActions) == 0x000008, "Wrong alignment on DiPlayerSettingsSubsystem_GetBindableActions");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetBindableActions) == 0x000010, "Wrong size on DiPlayerSettingsSubsystem_GetBindableActions");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetBindableActions, ReturnValue) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetBindableActions::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetBindingCategories
// 0x0010 (0x0010 - 0x0000)
struct DiPlayerSettingsSubsystem_GetBindingCategories final
{
public:
	TArray<EKeybindContext>                       ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetBindingCategories) == 0x000008, "Wrong alignment on DiPlayerSettingsSubsystem_GetBindingCategories");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetBindingCategories) == 0x000010, "Wrong size on DiPlayerSettingsSubsystem_GetBindingCategories");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetBindingCategories, ReturnValue) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetBindingCategories::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetDefaultKeysForEnhancedAction
// 0x0028 (0x0028 - 0x0000)
struct DiPlayerSettingsSubsystem_GetDefaultKeysForEnhancedAction final
{
public:
	const class UInputAction*                     InputAction;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKey>                           OutBindings;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	EKeybindContext                               Context;                                           // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AxisScale;                                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputDeviceType                              DeviceType;                                        // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetDefaultKeysForEnhancedAction) == 0x000008, "Wrong alignment on DiPlayerSettingsSubsystem_GetDefaultKeysForEnhancedAction");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetDefaultKeysForEnhancedAction) == 0x000028, "Wrong size on DiPlayerSettingsSubsystem_GetDefaultKeysForEnhancedAction");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetDefaultKeysForEnhancedAction, InputAction) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetDefaultKeysForEnhancedAction::InputAction' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetDefaultKeysForEnhancedAction, OutBindings) == 0x000008, "Member 'DiPlayerSettingsSubsystem_GetDefaultKeysForEnhancedAction::OutBindings' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetDefaultKeysForEnhancedAction, Context) == 0x000018, "Member 'DiPlayerSettingsSubsystem_GetDefaultKeysForEnhancedAction::Context' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetDefaultKeysForEnhancedAction, AxisScale) == 0x00001C, "Member 'DiPlayerSettingsSubsystem_GetDefaultKeysForEnhancedAction::AxisScale' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetDefaultKeysForEnhancedAction, DeviceType) == 0x000020, "Member 'DiPlayerSettingsSubsystem_GetDefaultKeysForEnhancedAction::DeviceType' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetFirstMappingContext
// 0x0010 (0x0010 - 0x0000)
struct DiPlayerSettingsSubsystem_GetFirstMappingContext final
{
public:
	EKeybindContext                               Context;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputDeviceType                              DeviceType;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputMappingContext*                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetFirstMappingContext) == 0x000008, "Wrong alignment on DiPlayerSettingsSubsystem_GetFirstMappingContext");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetFirstMappingContext) == 0x000010, "Wrong size on DiPlayerSettingsSubsystem_GetFirstMappingContext");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetFirstMappingContext, Context) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetFirstMappingContext::Context' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetFirstMappingContext, DeviceType) == 0x000001, "Member 'DiPlayerSettingsSubsystem_GetFirstMappingContext::DeviceType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetFirstMappingContext, ReturnValue) == 0x000008, "Member 'DiPlayerSettingsSubsystem_GetFirstMappingContext::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetKeysForEnhancedAction
// 0x0028 (0x0028 - 0x0000)
struct DiPlayerSettingsSubsystem_GetKeysForEnhancedAction final
{
public:
	const class UInputAction*                     InputAction;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKey>                           OutBindings;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	EKeybindContext                               Context;                                           // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AxisScale;                                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputDeviceType                              DeviceType;                                        // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetKeysForEnhancedAction) == 0x000008, "Wrong alignment on DiPlayerSettingsSubsystem_GetKeysForEnhancedAction");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetKeysForEnhancedAction) == 0x000028, "Wrong size on DiPlayerSettingsSubsystem_GetKeysForEnhancedAction");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetKeysForEnhancedAction, InputAction) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetKeysForEnhancedAction::InputAction' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetKeysForEnhancedAction, OutBindings) == 0x000008, "Member 'DiPlayerSettingsSubsystem_GetKeysForEnhancedAction::OutBindings' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetKeysForEnhancedAction, Context) == 0x000018, "Member 'DiPlayerSettingsSubsystem_GetKeysForEnhancedAction::Context' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetKeysForEnhancedAction, AxisScale) == 0x00001C, "Member 'DiPlayerSettingsSubsystem_GetKeysForEnhancedAction::AxisScale' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetKeysForEnhancedAction, DeviceType) == 0x000020, "Member 'DiPlayerSettingsSubsystem_GetKeysForEnhancedAction::DeviceType' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetMappingContexts
// 0x0018 (0x0018 - 0x0000)
struct DiPlayerSettingsSubsystem_GetMappingContexts final
{
public:
	EKeybindContext                               Context;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputDeviceType                              DeviceType;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInputMappingContext*>           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetMappingContexts) == 0x000008, "Wrong alignment on DiPlayerSettingsSubsystem_GetMappingContexts");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetMappingContexts) == 0x000018, "Wrong size on DiPlayerSettingsSubsystem_GetMappingContexts");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetMappingContexts, Context) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetMappingContexts::Context' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetMappingContexts, DeviceType) == 0x000001, "Member 'DiPlayerSettingsSubsystem_GetMappingContexts::DeviceType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetMappingContexts, ReturnValue) == 0x000008, "Member 'DiPlayerSettingsSubsystem_GetMappingContexts::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.RemoveKeyFromEnhancedAction
// 0x0030 (0x0030 - 0x0000)
struct DiPlayerSettingsSubsystem_RemoveKeyFromEnhancedAction final
{
public:
	const class UInputAction*                     InputAction;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Binding;                                           // 0x0008(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKeybindContext                               Context;                                           // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AxisScale;                                         // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputDeviceType                              DeviceType;                                        // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0029(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DiPlayerSettingsSubsystem_RemoveKeyFromEnhancedAction) == 0x000008, "Wrong alignment on DiPlayerSettingsSubsystem_RemoveKeyFromEnhancedAction");
static_assert(sizeof(DiPlayerSettingsSubsystem_RemoveKeyFromEnhancedAction) == 0x000030, "Wrong size on DiPlayerSettingsSubsystem_RemoveKeyFromEnhancedAction");
static_assert(offsetof(DiPlayerSettingsSubsystem_RemoveKeyFromEnhancedAction, InputAction) == 0x000000, "Member 'DiPlayerSettingsSubsystem_RemoveKeyFromEnhancedAction::InputAction' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_RemoveKeyFromEnhancedAction, Binding) == 0x000008, "Member 'DiPlayerSettingsSubsystem_RemoveKeyFromEnhancedAction::Binding' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_RemoveKeyFromEnhancedAction, Context) == 0x000020, "Member 'DiPlayerSettingsSubsystem_RemoveKeyFromEnhancedAction::Context' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_RemoveKeyFromEnhancedAction, AxisScale) == 0x000024, "Member 'DiPlayerSettingsSubsystem_RemoveKeyFromEnhancedAction::AxisScale' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_RemoveKeyFromEnhancedAction, DeviceType) == 0x000028, "Member 'DiPlayerSettingsSubsystem_RemoveKeyFromEnhancedAction::DeviceType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_RemoveKeyFromEnhancedAction, ReturnValue) == 0x000029, "Member 'DiPlayerSettingsSubsystem_RemoveKeyFromEnhancedAction::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.ResetToDefaultKeysForEnhancedAction
// 0x0010 (0x0010 - 0x0000)
struct DiPlayerSettingsSubsystem_ResetToDefaultKeysForEnhancedAction final
{
public:
	const class UInputAction*                     InputAction;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKeybindContext                               Context;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputDeviceType                              DeviceType;                                        // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DiPlayerSettingsSubsystem_ResetToDefaultKeysForEnhancedAction) == 0x000008, "Wrong alignment on DiPlayerSettingsSubsystem_ResetToDefaultKeysForEnhancedAction");
static_assert(sizeof(DiPlayerSettingsSubsystem_ResetToDefaultKeysForEnhancedAction) == 0x000010, "Wrong size on DiPlayerSettingsSubsystem_ResetToDefaultKeysForEnhancedAction");
static_assert(offsetof(DiPlayerSettingsSubsystem_ResetToDefaultKeysForEnhancedAction, InputAction) == 0x000000, "Member 'DiPlayerSettingsSubsystem_ResetToDefaultKeysForEnhancedAction::InputAction' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_ResetToDefaultKeysForEnhancedAction, Context) == 0x000008, "Member 'DiPlayerSettingsSubsystem_ResetToDefaultKeysForEnhancedAction::Context' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_ResetToDefaultKeysForEnhancedAction, DeviceType) == 0x000009, "Member 'DiPlayerSettingsSubsystem_ResetToDefaultKeysForEnhancedAction::DeviceType' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.SetContextuallyDisabledSetting
// 0x0002 (0x0002 - 0x0000)
struct DiPlayerSettingsSubsystem_SetContextuallyDisabledSetting final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisabled;                                         // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_SetContextuallyDisabledSetting) == 0x000001, "Wrong alignment on DiPlayerSettingsSubsystem_SetContextuallyDisabledSetting");
static_assert(sizeof(DiPlayerSettingsSubsystem_SetContextuallyDisabledSetting) == 0x000002, "Wrong size on DiPlayerSettingsSubsystem_SetContextuallyDisabledSetting");
static_assert(offsetof(DiPlayerSettingsSubsystem_SetContextuallyDisabledSetting, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_SetContextuallyDisabledSetting::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_SetContextuallyDisabledSetting, bDisabled) == 0x000001, "Member 'DiPlayerSettingsSubsystem_SetContextuallyDisabledSetting::bDisabled' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.SetSettingCurrentValue_Boolean
// 0x0003 (0x0003 - 0x0000)
struct DiPlayerSettingsSubsystem_SetSettingCurrentValue_Boolean final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewValue;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_SetSettingCurrentValue_Boolean) == 0x000001, "Wrong alignment on DiPlayerSettingsSubsystem_SetSettingCurrentValue_Boolean");
static_assert(sizeof(DiPlayerSettingsSubsystem_SetSettingCurrentValue_Boolean) == 0x000003, "Wrong size on DiPlayerSettingsSubsystem_SetSettingCurrentValue_Boolean");
static_assert(offsetof(DiPlayerSettingsSubsystem_SetSettingCurrentValue_Boolean, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_SetSettingCurrentValue_Boolean::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_SetSettingCurrentValue_Boolean, NewValue) == 0x000001, "Member 'DiPlayerSettingsSubsystem_SetSettingCurrentValue_Boolean::NewValue' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_SetSettingCurrentValue_Boolean, ReturnValue) == 0x000002, "Member 'DiPlayerSettingsSubsystem_SetSettingCurrentValue_Boolean::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.SetSettingCurrentValue_Float
// 0x000C (0x000C - 0x0000)
struct DiPlayerSettingsSubsystem_SetSettingCurrentValue_Float final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NewValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DiPlayerSettingsSubsystem_SetSettingCurrentValue_Float) == 0x000004, "Wrong alignment on DiPlayerSettingsSubsystem_SetSettingCurrentValue_Float");
static_assert(sizeof(DiPlayerSettingsSubsystem_SetSettingCurrentValue_Float) == 0x00000C, "Wrong size on DiPlayerSettingsSubsystem_SetSettingCurrentValue_Float");
static_assert(offsetof(DiPlayerSettingsSubsystem_SetSettingCurrentValue_Float, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_SetSettingCurrentValue_Float::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_SetSettingCurrentValue_Float, NewValue) == 0x000004, "Member 'DiPlayerSettingsSubsystem_SetSettingCurrentValue_Float::NewValue' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_SetSettingCurrentValue_Float, ReturnValue) == 0x000008, "Member 'DiPlayerSettingsSubsystem_SetSettingCurrentValue_Float::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.SetSettingCurrentValue_Integer
// 0x000C (0x000C - 0x0000)
struct DiPlayerSettingsSubsystem_SetSettingCurrentValue_Integer final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NewValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DiPlayerSettingsSubsystem_SetSettingCurrentValue_Integer) == 0x000004, "Wrong alignment on DiPlayerSettingsSubsystem_SetSettingCurrentValue_Integer");
static_assert(sizeof(DiPlayerSettingsSubsystem_SetSettingCurrentValue_Integer) == 0x00000C, "Wrong size on DiPlayerSettingsSubsystem_SetSettingCurrentValue_Integer");
static_assert(offsetof(DiPlayerSettingsSubsystem_SetSettingCurrentValue_Integer, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_SetSettingCurrentValue_Integer::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_SetSettingCurrentValue_Integer, NewValue) == 0x000004, "Member 'DiPlayerSettingsSubsystem_SetSettingCurrentValue_Integer::NewValue' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_SetSettingCurrentValue_Integer, ReturnValue) == 0x000008, "Member 'DiPlayerSettingsSubsystem_SetSettingCurrentValue_Integer::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.SetSettingCurrentValue_String
// 0x0020 (0x0020 - 0x0000)
struct DiPlayerSettingsSubsystem_SetSettingCurrentValue_String final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NewValue;                                          // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DiPlayerSettingsSubsystem_SetSettingCurrentValue_String) == 0x000008, "Wrong alignment on DiPlayerSettingsSubsystem_SetSettingCurrentValue_String");
static_assert(sizeof(DiPlayerSettingsSubsystem_SetSettingCurrentValue_String) == 0x000020, "Wrong size on DiPlayerSettingsSubsystem_SetSettingCurrentValue_String");
static_assert(offsetof(DiPlayerSettingsSubsystem_SetSettingCurrentValue_String, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_SetSettingCurrentValue_String::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_SetSettingCurrentValue_String, NewValue) == 0x000008, "Member 'DiPlayerSettingsSubsystem_SetSettingCurrentValue_String::NewValue' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_SetSettingCurrentValue_String, ReturnValue) == 0x000018, "Member 'DiPlayerSettingsSubsystem_SetSettingCurrentValue_String::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingCurrentValue_Boolean
// 0x0002 (0x0002 - 0x0000)
struct DiPlayerSettingsSubsystem_GetSettingCurrentValue_Boolean final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetSettingCurrentValue_Boolean) == 0x000001, "Wrong alignment on DiPlayerSettingsSubsystem_GetSettingCurrentValue_Boolean");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetSettingCurrentValue_Boolean) == 0x000002, "Wrong size on DiPlayerSettingsSubsystem_GetSettingCurrentValue_Boolean");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingCurrentValue_Boolean, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetSettingCurrentValue_Boolean::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingCurrentValue_Boolean, ReturnValue) == 0x000001, "Member 'DiPlayerSettingsSubsystem_GetSettingCurrentValue_Boolean::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingCurrentValue_Float
// 0x0008 (0x0008 - 0x0000)
struct DiPlayerSettingsSubsystem_GetSettingCurrentValue_Float final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetSettingCurrentValue_Float) == 0x000004, "Wrong alignment on DiPlayerSettingsSubsystem_GetSettingCurrentValue_Float");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetSettingCurrentValue_Float) == 0x000008, "Wrong size on DiPlayerSettingsSubsystem_GetSettingCurrentValue_Float");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingCurrentValue_Float, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetSettingCurrentValue_Float::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingCurrentValue_Float, ReturnValue) == 0x000004, "Member 'DiPlayerSettingsSubsystem_GetSettingCurrentValue_Float::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingCurrentValue_Integer
// 0x0008 (0x0008 - 0x0000)
struct DiPlayerSettingsSubsystem_GetSettingCurrentValue_Integer final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetSettingCurrentValue_Integer) == 0x000004, "Wrong alignment on DiPlayerSettingsSubsystem_GetSettingCurrentValue_Integer");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetSettingCurrentValue_Integer) == 0x000008, "Wrong size on DiPlayerSettingsSubsystem_GetSettingCurrentValue_Integer");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingCurrentValue_Integer, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetSettingCurrentValue_Integer::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingCurrentValue_Integer, ReturnValue) == 0x000004, "Member 'DiPlayerSettingsSubsystem_GetSettingCurrentValue_Integer::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingCurrentValue_String
// 0x0018 (0x0018 - 0x0000)
struct DiPlayerSettingsSubsystem_GetSettingCurrentValue_String final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetSettingCurrentValue_String) == 0x000008, "Wrong alignment on DiPlayerSettingsSubsystem_GetSettingCurrentValue_String");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetSettingCurrentValue_String) == 0x000018, "Wrong size on DiPlayerSettingsSubsystem_GetSettingCurrentValue_String");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingCurrentValue_String, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetSettingCurrentValue_String::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingCurrentValue_String, ReturnValue) == 0x000008, "Member 'DiPlayerSettingsSubsystem_GetSettingCurrentValue_String::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingDisabledReasonTooltip
// 0x0020 (0x0020 - 0x0000)
struct DiPlayerSettingsSubsystem_GetSettingDisabledReasonTooltip final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetSettingDisabledReasonTooltip) == 0x000008, "Wrong alignment on DiPlayerSettingsSubsystem_GetSettingDisabledReasonTooltip");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetSettingDisabledReasonTooltip) == 0x000020, "Wrong size on DiPlayerSettingsSubsystem_GetSettingDisabledReasonTooltip");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingDisabledReasonTooltip, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetSettingDisabledReasonTooltip::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingDisabledReasonTooltip, ReturnValue) == 0x000008, "Member 'DiPlayerSettingsSubsystem_GetSettingDisabledReasonTooltip::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingLongDescription
// 0x0020 (0x0020 - 0x0000)
struct DiPlayerSettingsSubsystem_GetSettingLongDescription final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetSettingLongDescription) == 0x000008, "Wrong alignment on DiPlayerSettingsSubsystem_GetSettingLongDescription");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetSettingLongDescription) == 0x000020, "Wrong size on DiPlayerSettingsSubsystem_GetSettingLongDescription");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingLongDescription, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetSettingLongDescription::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingLongDescription, ReturnValue) == 0x000008, "Member 'DiPlayerSettingsSubsystem_GetSettingLongDescription::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingMaxLength_String
// 0x0008 (0x0008 - 0x0000)
struct DiPlayerSettingsSubsystem_GetSettingMaxLength_String final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetSettingMaxLength_String) == 0x000004, "Wrong alignment on DiPlayerSettingsSubsystem_GetSettingMaxLength_String");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetSettingMaxLength_String) == 0x000008, "Wrong size on DiPlayerSettingsSubsystem_GetSettingMaxLength_String");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingMaxLength_String, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetSettingMaxLength_String::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingMaxLength_String, ReturnValue) == 0x000004, "Member 'DiPlayerSettingsSubsystem_GetSettingMaxLength_String::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingMaxValue_Float
// 0x0008 (0x0008 - 0x0000)
struct DiPlayerSettingsSubsystem_GetSettingMaxValue_Float final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetSettingMaxValue_Float) == 0x000004, "Wrong alignment on DiPlayerSettingsSubsystem_GetSettingMaxValue_Float");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetSettingMaxValue_Float) == 0x000008, "Wrong size on DiPlayerSettingsSubsystem_GetSettingMaxValue_Float");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingMaxValue_Float, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetSettingMaxValue_Float::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingMaxValue_Float, ReturnValue) == 0x000004, "Member 'DiPlayerSettingsSubsystem_GetSettingMaxValue_Float::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingMaxValue_Integer
// 0x0008 (0x0008 - 0x0000)
struct DiPlayerSettingsSubsystem_GetSettingMaxValue_Integer final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetSettingMaxValue_Integer) == 0x000004, "Wrong alignment on DiPlayerSettingsSubsystem_GetSettingMaxValue_Integer");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetSettingMaxValue_Integer) == 0x000008, "Wrong size on DiPlayerSettingsSubsystem_GetSettingMaxValue_Integer");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingMaxValue_Integer, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetSettingMaxValue_Integer::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingMaxValue_Integer, ReturnValue) == 0x000004, "Member 'DiPlayerSettingsSubsystem_GetSettingMaxValue_Integer::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingMinLength_String
// 0x0008 (0x0008 - 0x0000)
struct DiPlayerSettingsSubsystem_GetSettingMinLength_String final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetSettingMinLength_String) == 0x000004, "Wrong alignment on DiPlayerSettingsSubsystem_GetSettingMinLength_String");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetSettingMinLength_String) == 0x000008, "Wrong size on DiPlayerSettingsSubsystem_GetSettingMinLength_String");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingMinLength_String, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetSettingMinLength_String::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingMinLength_String, ReturnValue) == 0x000004, "Member 'DiPlayerSettingsSubsystem_GetSettingMinLength_String::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingMinValue_Float
// 0x0008 (0x0008 - 0x0000)
struct DiPlayerSettingsSubsystem_GetSettingMinValue_Float final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetSettingMinValue_Float) == 0x000004, "Wrong alignment on DiPlayerSettingsSubsystem_GetSettingMinValue_Float");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetSettingMinValue_Float) == 0x000008, "Wrong size on DiPlayerSettingsSubsystem_GetSettingMinValue_Float");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingMinValue_Float, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetSettingMinValue_Float::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingMinValue_Float, ReturnValue) == 0x000004, "Member 'DiPlayerSettingsSubsystem_GetSettingMinValue_Float::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingMinValue_Integer
// 0x0008 (0x0008 - 0x0000)
struct DiPlayerSettingsSubsystem_GetSettingMinValue_Integer final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetSettingMinValue_Integer) == 0x000004, "Wrong alignment on DiPlayerSettingsSubsystem_GetSettingMinValue_Integer");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetSettingMinValue_Integer) == 0x000008, "Wrong size on DiPlayerSettingsSubsystem_GetSettingMinValue_Integer");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingMinValue_Integer, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetSettingMinValue_Integer::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingMinValue_Integer, ReturnValue) == 0x000004, "Member 'DiPlayerSettingsSubsystem_GetSettingMinValue_Integer::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingPossibleValues_String
// 0x0018 (0x0018 - 0x0000)
struct DiPlayerSettingsSubsystem_GetSettingPossibleValues_String final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetSettingPossibleValues_String) == 0x000008, "Wrong alignment on DiPlayerSettingsSubsystem_GetSettingPossibleValues_String");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetSettingPossibleValues_String) == 0x000018, "Wrong size on DiPlayerSettingsSubsystem_GetSettingPossibleValues_String");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingPossibleValues_String, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetSettingPossibleValues_String::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingPossibleValues_String, ReturnValue) == 0x000008, "Member 'DiPlayerSettingsSubsystem_GetSettingPossibleValues_String::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingPossibleValues_Text
// 0x0018 (0x0018 - 0x0000)
struct DiPlayerSettingsSubsystem_GetSettingPossibleValues_Text final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetSettingPossibleValues_Text) == 0x000008, "Wrong alignment on DiPlayerSettingsSubsystem_GetSettingPossibleValues_Text");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetSettingPossibleValues_Text) == 0x000018, "Wrong size on DiPlayerSettingsSubsystem_GetSettingPossibleValues_Text");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingPossibleValues_Text, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetSettingPossibleValues_Text::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingPossibleValues_Text, ReturnValue) == 0x000008, "Member 'DiPlayerSettingsSubsystem_GetSettingPossibleValues_Text::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingShortDescription
// 0x0020 (0x0020 - 0x0000)
struct DiPlayerSettingsSubsystem_GetSettingShortDescription final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetSettingShortDescription) == 0x000008, "Wrong alignment on DiPlayerSettingsSubsystem_GetSettingShortDescription");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetSettingShortDescription) == 0x000020, "Wrong size on DiPlayerSettingsSubsystem_GetSettingShortDescription");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingShortDescription, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetSettingShortDescription::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingShortDescription, ReturnValue) == 0x000008, "Member 'DiPlayerSettingsSubsystem_GetSettingShortDescription::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.GetSettingTooltipDecription
// 0x0020 (0x0020 - 0x0000)
struct DiPlayerSettingsSubsystem_GetSettingTooltipDecription final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_GetSettingTooltipDecription) == 0x000008, "Wrong alignment on DiPlayerSettingsSubsystem_GetSettingTooltipDecription");
static_assert(sizeof(DiPlayerSettingsSubsystem_GetSettingTooltipDecription) == 0x000020, "Wrong size on DiPlayerSettingsSubsystem_GetSettingTooltipDecription");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingTooltipDecription, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_GetSettingTooltipDecription::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_GetSettingTooltipDecription, ReturnValue) == 0x000008, "Member 'DiPlayerSettingsSubsystem_GetSettingTooltipDecription::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.IsContextuallyDisabledSetting
// 0x0002 (0x0002 - 0x0000)
struct DiPlayerSettingsSubsystem_IsContextuallyDisabledSetting final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_IsContextuallyDisabledSetting) == 0x000001, "Wrong alignment on DiPlayerSettingsSubsystem_IsContextuallyDisabledSetting");
static_assert(sizeof(DiPlayerSettingsSubsystem_IsContextuallyDisabledSetting) == 0x000002, "Wrong size on DiPlayerSettingsSubsystem_IsContextuallyDisabledSetting");
static_assert(offsetof(DiPlayerSettingsSubsystem_IsContextuallyDisabledSetting, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_IsContextuallyDisabledSetting::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_IsContextuallyDisabledSetting, ReturnValue) == 0x000001, "Member 'DiPlayerSettingsSubsystem_IsContextuallyDisabledSetting::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.IsGameplayTipsEnabled
// 0x0001 (0x0001 - 0x0000)
struct DiPlayerSettingsSubsystem_IsGameplayTipsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_IsGameplayTipsEnabled) == 0x000001, "Wrong alignment on DiPlayerSettingsSubsystem_IsGameplayTipsEnabled");
static_assert(sizeof(DiPlayerSettingsSubsystem_IsGameplayTipsEnabled) == 0x000001, "Wrong size on DiPlayerSettingsSubsystem_IsGameplayTipsEnabled");
static_assert(offsetof(DiPlayerSettingsSubsystem_IsGameplayTipsEnabled, ReturnValue) == 0x000000, "Member 'DiPlayerSettingsSubsystem_IsGameplayTipsEnabled::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.IsSeparatorSetting
// 0x0002 (0x0002 - 0x0000)
struct DiPlayerSettingsSubsystem_IsSeparatorSetting final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_IsSeparatorSetting) == 0x000001, "Wrong alignment on DiPlayerSettingsSubsystem_IsSeparatorSetting");
static_assert(sizeof(DiPlayerSettingsSubsystem_IsSeparatorSetting) == 0x000002, "Wrong size on DiPlayerSettingsSubsystem_IsSeparatorSetting");
static_assert(offsetof(DiPlayerSettingsSubsystem_IsSeparatorSetting, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_IsSeparatorSetting::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_IsSeparatorSetting, ReturnValue) == 0x000001, "Member 'DiPlayerSettingsSubsystem_IsSeparatorSetting::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.IsSettingAllowedOnThisPlatform
// 0x0002 (0x0002 - 0x0000)
struct DiPlayerSettingsSubsystem_IsSettingAllowedOnThisPlatform final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_IsSettingAllowedOnThisPlatform) == 0x000001, "Wrong alignment on DiPlayerSettingsSubsystem_IsSettingAllowedOnThisPlatform");
static_assert(sizeof(DiPlayerSettingsSubsystem_IsSettingAllowedOnThisPlatform) == 0x000002, "Wrong size on DiPlayerSettingsSubsystem_IsSettingAllowedOnThisPlatform");
static_assert(offsetof(DiPlayerSettingsSubsystem_IsSettingAllowedOnThisPlatform, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_IsSettingAllowedOnThisPlatform::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_IsSettingAllowedOnThisPlatform, ReturnValue) == 0x000001, "Member 'DiPlayerSettingsSubsystem_IsSettingAllowedOnThisPlatform::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.IsSettingEnabled
// 0x0002 (0x0002 - 0x0000)
struct DiPlayerSettingsSubsystem_IsSettingEnabled final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_IsSettingEnabled) == 0x000001, "Wrong alignment on DiPlayerSettingsSubsystem_IsSettingEnabled");
static_assert(sizeof(DiPlayerSettingsSubsystem_IsSettingEnabled) == 0x000002, "Wrong size on DiPlayerSettingsSubsystem_IsSettingEnabled");
static_assert(offsetof(DiPlayerSettingsSubsystem_IsSettingEnabled, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_IsSettingEnabled::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_IsSettingEnabled, ReturnValue) == 0x000001, "Member 'DiPlayerSettingsSubsystem_IsSettingEnabled::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiPlayerSettingsSubsystem.IsSettingTooltipAvailable
// 0x0002 (0x0002 - 0x0000)
struct DiPlayerSettingsSubsystem_IsSettingTooltipAvailable final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiPlayerSettingsSubsystem_IsSettingTooltipAvailable) == 0x000001, "Wrong alignment on DiPlayerSettingsSubsystem_IsSettingTooltipAvailable");
static_assert(sizeof(DiPlayerSettingsSubsystem_IsSettingTooltipAvailable) == 0x000002, "Wrong size on DiPlayerSettingsSubsystem_IsSettingTooltipAvailable");
static_assert(offsetof(DiPlayerSettingsSubsystem_IsSettingTooltipAvailable, SettingType) == 0x000000, "Member 'DiPlayerSettingsSubsystem_IsSettingTooltipAvailable::SettingType' has a wrong offset!");
static_assert(offsetof(DiPlayerSettingsSubsystem_IsSettingTooltipAvailable, ReturnValue) == 0x000001, "Member 'DiPlayerSettingsSubsystem_IsSettingTooltipAvailable::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerStart.BP_OnSpySpawnedOnStartPoint
// 0x0008 (0x0008 - 0x0000)
struct DIPlayerStart_BP_OnSpySpawnedOnStartPoint final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerStart_BP_OnSpySpawnedOnStartPoint) == 0x000008, "Wrong alignment on DIPlayerStart_BP_OnSpySpawnedOnStartPoint");
static_assert(sizeof(DIPlayerStart_BP_OnSpySpawnedOnStartPoint) == 0x000008, "Wrong size on DIPlayerStart_BP_OnSpySpawnedOnStartPoint");
static_assert(offsetof(DIPlayerStart_BP_OnSpySpawnedOnStartPoint, Spy) == 0x000000, "Member 'DIPlayerStart_BP_OnSpySpawnedOnStartPoint::Spy' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.Client_ReceivedXPEvent
// 0x0008 (0x0008 - 0x0000)
struct DIPlayerState_Client_ReceivedXPEvent final
{
public:
	EDIXPEvent                                    XPEventType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AddedXP;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_Client_ReceivedXPEvent) == 0x000004, "Wrong alignment on DIPlayerState_Client_ReceivedXPEvent");
static_assert(sizeof(DIPlayerState_Client_ReceivedXPEvent) == 0x000008, "Wrong size on DIPlayerState_Client_ReceivedXPEvent");
static_assert(offsetof(DIPlayerState_Client_ReceivedXPEvent, XPEventType) == 0x000000, "Member 'DIPlayerState_Client_ReceivedXPEvent::XPEventType' has a wrong offset!");
static_assert(offsetof(DIPlayerState_Client_ReceivedXPEvent, AddedXP) == 0x000004, "Member 'DIPlayerState_Client_ReceivedXPEvent::AddedXP' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.Client_UpdateAchievement
// 0x0018 (0x0018 - 0x0000)
struct DIPlayerState_Client_UpdateAchievement final
{
public:
	class FString                                 AchievementName;                                   // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Progress;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Increment;                                         // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIPlayerState_Client_UpdateAchievement) == 0x000008, "Wrong alignment on DIPlayerState_Client_UpdateAchievement");
static_assert(sizeof(DIPlayerState_Client_UpdateAchievement) == 0x000018, "Wrong size on DIPlayerState_Client_UpdateAchievement");
static_assert(offsetof(DIPlayerState_Client_UpdateAchievement, AchievementName) == 0x000000, "Member 'DIPlayerState_Client_UpdateAchievement::AchievementName' has a wrong offset!");
static_assert(offsetof(DIPlayerState_Client_UpdateAchievement, Progress) == 0x000010, "Member 'DIPlayerState_Client_UpdateAchievement::Progress' has a wrong offset!");
static_assert(offsetof(DIPlayerState_Client_UpdateAchievement, Increment) == 0x000014, "Member 'DIPlayerState_Client_UpdateAchievement::Increment' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetAliveTeammates
// 0x0010 (0x0010 - 0x0000)
struct DIPlayerState_GetAliveTeammates final
{
public:
	TArray<class ADIPlayerState*>                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetAliveTeammates) == 0x000008, "Wrong alignment on DIPlayerState_GetAliveTeammates");
static_assert(sizeof(DIPlayerState_GetAliveTeammates) == 0x000010, "Wrong size on DIPlayerState_GetAliveTeammates");
static_assert(offsetof(DIPlayerState_GetAliveTeammates, ReturnValue) == 0x000000, "Member 'DIPlayerState_GetAliveTeammates::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetAllXpDataEventInfo
// 0x0010 (0x0010 - 0x0000)
struct DIPlayerState_GetAllXpDataEventInfo final
{
public:
	TArray<struct FPlayerXpTypeEventInfo>         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetAllXpDataEventInfo) == 0x000008, "Wrong alignment on DIPlayerState_GetAllXpDataEventInfo");
static_assert(sizeof(DIPlayerState_GetAllXpDataEventInfo) == 0x000010, "Wrong size on DIPlayerState_GetAllXpDataEventInfo");
static_assert(offsetof(DIPlayerState_GetAllXpDataEventInfo, ReturnValue) == 0x000000, "Member 'DIPlayerState_GetAllXpDataEventInfo::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetMatchGainedCurrency
// 0x0004 (0x0004 - 0x0000)
struct DIPlayerState_GetMatchGainedCurrency final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetMatchGainedCurrency) == 0x000004, "Wrong alignment on DIPlayerState_GetMatchGainedCurrency");
static_assert(sizeof(DIPlayerState_GetMatchGainedCurrency) == 0x000004, "Wrong size on DIPlayerState_GetMatchGainedCurrency");
static_assert(offsetof(DIPlayerState_GetMatchGainedCurrency, ReturnValue) == 0x000000, "Member 'DIPlayerState_GetMatchGainedCurrency::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.IsTeamAlive
// 0x0001 (0x0001 - 0x0000)
struct DIPlayerState_IsTeamAlive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_IsTeamAlive) == 0x000001, "Wrong alignment on DIPlayerState_IsTeamAlive");
static_assert(sizeof(DIPlayerState_IsTeamAlive) == 0x000001, "Wrong size on DIPlayerState_IsTeamAlive");
static_assert(offsetof(DIPlayerState_IsTeamAlive, ReturnValue) == 0x000000, "Member 'DIPlayerState_IsTeamAlive::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.OnRep_AccessoriesSelection
// 0x0098 (0x0098 - 0x0000)
struct DIPlayerState_OnRep_AccessoriesSelection final
{
public:
	struct FDISerializedAccessories               OldVal;                                            // 0x0000(0x0098)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_OnRep_AccessoriesSelection) == 0x000008, "Wrong alignment on DIPlayerState_OnRep_AccessoriesSelection");
static_assert(sizeof(DIPlayerState_OnRep_AccessoriesSelection) == 0x000098, "Wrong size on DIPlayerState_OnRep_AccessoriesSelection");
static_assert(offsetof(DIPlayerState_OnRep_AccessoriesSelection, OldVal) == 0x000000, "Member 'DIPlayerState_OnRep_AccessoriesSelection::OldVal' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.OnRep_AgentSelection
// 0x00B4 (0x00B4 - 0x0000)
struct DIPlayerState_OnRep_AgentSelection final
{
public:
	struct FPlayerAgentSelectionInfo              OldVal;                                            // 0x0000(0x00B4)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_OnRep_AgentSelection) == 0x000004, "Wrong alignment on DIPlayerState_OnRep_AgentSelection");
static_assert(sizeof(DIPlayerState_OnRep_AgentSelection) == 0x0000B4, "Wrong size on DIPlayerState_OnRep_AgentSelection");
static_assert(offsetof(DIPlayerState_OnRep_AgentSelection, OldVal) == 0x000000, "Member 'DIPlayerState_OnRep_AgentSelection::OldVal' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.OnRep_EquippedDeck
// 0x0010 (0x0010 - 0x0000)
struct DIPlayerState_OnRep_EquippedDeck final
{
public:
	struct FDISerializedDeckEntry                 OldVal;                                            // 0x0000(0x0010)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_OnRep_EquippedDeck) == 0x000008, "Wrong alignment on DIPlayerState_OnRep_EquippedDeck");
static_assert(sizeof(DIPlayerState_OnRep_EquippedDeck) == 0x000010, "Wrong size on DIPlayerState_OnRep_EquippedDeck");
static_assert(offsetof(DIPlayerState_OnRep_EquippedDeck, OldVal) == 0x000000, "Member 'DIPlayerState_OnRep_EquippedDeck::OldVal' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.OnRep_FactionEliminated
// 0x0001 (0x0001 - 0x0000)
struct DIPlayerState_OnRep_FactionEliminated final
{
public:
	bool                                          OldVal;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_OnRep_FactionEliminated) == 0x000001, "Wrong alignment on DIPlayerState_OnRep_FactionEliminated");
static_assert(sizeof(DIPlayerState_OnRep_FactionEliminated) == 0x000001, "Wrong size on DIPlayerState_OnRep_FactionEliminated");
static_assert(offsetof(DIPlayerState_OnRep_FactionEliminated, OldVal) == 0x000000, "Member 'DIPlayerState_OnRep_FactionEliminated::OldVal' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.OnRep_FactionID
// 0x0001 (0x0001 - 0x0000)
struct DIPlayerState_OnRep_FactionID final
{
public:
	uint8                                         OldVal;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_OnRep_FactionID) == 0x000001, "Wrong alignment on DIPlayerState_OnRep_FactionID");
static_assert(sizeof(DIPlayerState_OnRep_FactionID) == 0x000001, "Wrong size on DIPlayerState_OnRep_FactionID");
static_assert(offsetof(DIPlayerState_OnRep_FactionID, OldVal) == 0x000000, "Member 'DIPlayerState_OnRep_FactionID::OldVal' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.OnRep_XpData
// 0x0040 (0x0040 - 0x0000)
struct DIPlayerState_OnRep_XpData final
{
public:
	struct FXpHolder                              OldXpData;                                         // 0x0000(0x0040)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_OnRep_XpData) == 0x000008, "Wrong alignment on DIPlayerState_OnRep_XpData");
static_assert(sizeof(DIPlayerState_OnRep_XpData) == 0x000040, "Wrong size on DIPlayerState_OnRep_XpData");
static_assert(offsetof(DIPlayerState_OnRep_XpData, OldXpData) == 0x000000, "Member 'DIPlayerState_OnRep_XpData::OldXpData' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.Server_SetHidePlayerName
// 0x0001 (0x0001 - 0x0000)
struct DIPlayerState_Server_SetHidePlayerName final
{
public:
	EAnonymizePlayerNameType                      InHidePlayerName;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_Server_SetHidePlayerName) == 0x000001, "Wrong alignment on DIPlayerState_Server_SetHidePlayerName");
static_assert(sizeof(DIPlayerState_Server_SetHidePlayerName) == 0x000001, "Wrong size on DIPlayerState_Server_SetHidePlayerName");
static_assert(offsetof(DIPlayerState_Server_SetHidePlayerName, InHidePlayerName) == 0x000000, "Member 'DIPlayerState_Server_SetHidePlayerName::InHidePlayerName' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.Server_SetIsSpySelected
// 0x0001 (0x0001 - 0x0000)
struct DIPlayerState_Server_SetIsSpySelected final
{
public:
	bool                                          bIsSpySelectedIn;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_Server_SetIsSpySelected) == 0x000001, "Wrong alignment on DIPlayerState_Server_SetIsSpySelected");
static_assert(sizeof(DIPlayerState_Server_SetIsSpySelected) == 0x000001, "Wrong size on DIPlayerState_Server_SetIsSpySelected");
static_assert(offsetof(DIPlayerState_Server_SetIsSpySelected, bIsSpySelectedIn) == 0x000000, "Member 'DIPlayerState_Server_SetIsSpySelected::bIsSpySelectedIn' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetActiveID
// 0x0010 (0x0010 - 0x0000)
struct DIPlayerState_GetActiveID final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetActiveID) == 0x000004, "Wrong alignment on DIPlayerState_GetActiveID");
static_assert(sizeof(DIPlayerState_GetActiveID) == 0x000010, "Wrong size on DIPlayerState_GetActiveID");
static_assert(offsetof(DIPlayerState_GetActiveID, ReturnValue) == 0x000000, "Member 'DIPlayerState_GetActiveID::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetAgentExpertiseSkillId
// 0x0010 (0x0010 - 0x0000)
struct DIPlayerState_GetAgentExpertiseSkillId final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetAgentExpertiseSkillId) == 0x000004, "Wrong alignment on DIPlayerState_GetAgentExpertiseSkillId");
static_assert(sizeof(DIPlayerState_GetAgentExpertiseSkillId) == 0x000010, "Wrong size on DIPlayerState_GetAgentExpertiseSkillId");
static_assert(offsetof(DIPlayerState_GetAgentExpertiseSkillId, ReturnValue) == 0x000000, "Member 'DIPlayerState_GetAgentExpertiseSkillId::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetAgentGadget1Id
// 0x0010 (0x0010 - 0x0000)
struct DIPlayerState_GetAgentGadget1Id final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetAgentGadget1Id) == 0x000004, "Wrong alignment on DIPlayerState_GetAgentGadget1Id");
static_assert(sizeof(DIPlayerState_GetAgentGadget1Id) == 0x000010, "Wrong size on DIPlayerState_GetAgentGadget1Id");
static_assert(offsetof(DIPlayerState_GetAgentGadget1Id, ReturnValue) == 0x000000, "Member 'DIPlayerState_GetAgentGadget1Id::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetAgentGadget2Id
// 0x0010 (0x0010 - 0x0000)
struct DIPlayerState_GetAgentGadget2Id final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetAgentGadget2Id) == 0x000004, "Wrong alignment on DIPlayerState_GetAgentGadget2Id");
static_assert(sizeof(DIPlayerState_GetAgentGadget2Id) == 0x000010, "Wrong size on DIPlayerState_GetAgentGadget2Id");
static_assert(offsetof(DIPlayerState_GetAgentGadget2Id, ReturnValue) == 0x000000, "Member 'DIPlayerState_GetAgentGadget2Id::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetAgentId
// 0x0010 (0x0010 - 0x0000)
struct DIPlayerState_GetAgentId final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetAgentId) == 0x000004, "Wrong alignment on DIPlayerState_GetAgentId");
static_assert(sizeof(DIPlayerState_GetAgentId) == 0x000010, "Wrong size on DIPlayerState_GetAgentId");
static_assert(offsetof(DIPlayerState_GetAgentId, ReturnValue) == 0x000000, "Member 'DIPlayerState_GetAgentId::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetAgentPassiveSkillId
// 0x0010 (0x0010 - 0x0000)
struct DIPlayerState_GetAgentPassiveSkillId final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetAgentPassiveSkillId) == 0x000004, "Wrong alignment on DIPlayerState_GetAgentPassiveSkillId");
static_assert(sizeof(DIPlayerState_GetAgentPassiveSkillId) == 0x000010, "Wrong size on DIPlayerState_GetAgentPassiveSkillId");
static_assert(offsetof(DIPlayerState_GetAgentPassiveSkillId, ReturnValue) == 0x000000, "Member 'DIPlayerState_GetAgentPassiveSkillId::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetAgentSkinId
// 0x0010 (0x0010 - 0x0000)
struct DIPlayerState_GetAgentSkinId final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetAgentSkinId) == 0x000004, "Wrong alignment on DIPlayerState_GetAgentSkinId");
static_assert(sizeof(DIPlayerState_GetAgentSkinId) == 0x000010, "Wrong size on DIPlayerState_GetAgentSkinId");
static_assert(offsetof(DIPlayerState_GetAgentSkinId, ReturnValue) == 0x000000, "Member 'DIPlayerState_GetAgentSkinId::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetAgentWeaponId
// 0x0010 (0x0010 - 0x0000)
struct DIPlayerState_GetAgentWeaponId final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetAgentWeaponId) == 0x000004, "Wrong alignment on DIPlayerState_GetAgentWeaponId");
static_assert(sizeof(DIPlayerState_GetAgentWeaponId) == 0x000010, "Wrong size on DIPlayerState_GetAgentWeaponId");
static_assert(offsetof(DIPlayerState_GetAgentWeaponId, ReturnValue) == 0x000000, "Member 'DIPlayerState_GetAgentWeaponId::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetAvatarId
// 0x0010 (0x0010 - 0x0000)
struct DIPlayerState_GetAvatarId final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetAvatarId) == 0x000004, "Wrong alignment on DIPlayerState_GetAvatarId");
static_assert(sizeof(DIPlayerState_GetAvatarId) == 0x000010, "Wrong size on DIPlayerState_GetAvatarId");
static_assert(offsetof(DIPlayerState_GetAvatarId, ReturnValue) == 0x000000, "Member 'DIPlayerState_GetAvatarId::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetDataAssetDisplayName
// 0x0020 (0x0020 - 0x0000)
struct DIPlayerState_GetDataAssetDisplayName final
{
public:
	class UDIPrimaryDataAsset*                    DataAsset;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetDataAssetDisplayName) == 0x000008, "Wrong alignment on DIPlayerState_GetDataAssetDisplayName");
static_assert(sizeof(DIPlayerState_GetDataAssetDisplayName) == 0x000020, "Wrong size on DIPlayerState_GetDataAssetDisplayName");
static_assert(offsetof(DIPlayerState_GetDataAssetDisplayName, DataAsset) == 0x000000, "Member 'DIPlayerState_GetDataAssetDisplayName::DataAsset' has a wrong offset!");
static_assert(offsetof(DIPlayerState_GetDataAssetDisplayName, ReturnValue) == 0x000008, "Member 'DIPlayerState_GetDataAssetDisplayName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetDataAssetRewardIcon
// 0x0010 (0x0010 - 0x0000)
struct DIPlayerState_GetDataAssetRewardIcon final
{
public:
	class UDIPrimaryDataAsset*                    DataAsset;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetDataAssetRewardIcon) == 0x000008, "Wrong alignment on DIPlayerState_GetDataAssetRewardIcon");
static_assert(sizeof(DIPlayerState_GetDataAssetRewardIcon) == 0x000010, "Wrong size on DIPlayerState_GetDataAssetRewardIcon");
static_assert(offsetof(DIPlayerState_GetDataAssetRewardIcon, DataAsset) == 0x000000, "Member 'DIPlayerState_GetDataAssetRewardIcon::DataAsset' has a wrong offset!");
static_assert(offsetof(DIPlayerState_GetDataAssetRewardIcon, ReturnValue) == 0x000008, "Member 'DIPlayerState_GetDataAssetRewardIcon::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetEquippedPowerupDeck
// 0x0010 (0x0010 - 0x0000)
struct DIPlayerState_GetEquippedPowerupDeck final
{
public:
	struct FDISerializedDeckEntry                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetEquippedPowerupDeck) == 0x000008, "Wrong alignment on DIPlayerState_GetEquippedPowerupDeck");
static_assert(sizeof(DIPlayerState_GetEquippedPowerupDeck) == 0x000010, "Wrong size on DIPlayerState_GetEquippedPowerupDeck");
static_assert(offsetof(DIPlayerState_GetEquippedPowerupDeck, ReturnValue) == 0x000000, "Member 'DIPlayerState_GetEquippedPowerupDeck::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetIntroPoseId
// 0x0010 (0x0010 - 0x0000)
struct DIPlayerState_GetIntroPoseId final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetIntroPoseId) == 0x000004, "Wrong alignment on DIPlayerState_GetIntroPoseId");
static_assert(sizeof(DIPlayerState_GetIntroPoseId) == 0x000010, "Wrong size on DIPlayerState_GetIntroPoseId");
static_assert(offsetof(DIPlayerState_GetIntroPoseId, ReturnValue) == 0x000000, "Member 'DIPlayerState_GetIntroPoseId::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetMatchGainedXP
// 0x0004 (0x0004 - 0x0000)
struct DIPlayerState_GetMatchGainedXP final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetMatchGainedXP) == 0x000004, "Wrong alignment on DIPlayerState_GetMatchGainedXP");
static_assert(sizeof(DIPlayerState_GetMatchGainedXP) == 0x000004, "Wrong size on DIPlayerState_GetMatchGainedXP");
static_assert(offsetof(DIPlayerState_GetMatchGainedXP, ReturnValue) == 0x000000, "Member 'DIPlayerState_GetMatchGainedXP::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetMatchGainedXPForSpecificXpType
// 0x0018 (0x0018 - 0x0000)
struct DIPlayerState_GetMatchGainedXPForSpecificXpType final
{
public:
	class FString                                 XpType;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIPlayerState_GetMatchGainedXPForSpecificXpType) == 0x000008, "Wrong alignment on DIPlayerState_GetMatchGainedXPForSpecificXpType");
static_assert(sizeof(DIPlayerState_GetMatchGainedXPForSpecificXpType) == 0x000018, "Wrong size on DIPlayerState_GetMatchGainedXPForSpecificXpType");
static_assert(offsetof(DIPlayerState_GetMatchGainedXPForSpecificXpType, XpType) == 0x000000, "Member 'DIPlayerState_GetMatchGainedXPForSpecificXpType::XpType' has a wrong offset!");
static_assert(offsetof(DIPlayerState_GetMatchGainedXPForSpecificXpType, ReturnValue) == 0x000010, "Member 'DIPlayerState_GetMatchGainedXPForSpecificXpType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetMatchStartCatalogueToken
// 0x0004 (0x0004 - 0x0000)
struct DIPlayerState_GetMatchStartCatalogueToken final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetMatchStartCatalogueToken) == 0x000004, "Wrong alignment on DIPlayerState_GetMatchStartCatalogueToken");
static_assert(sizeof(DIPlayerState_GetMatchStartCatalogueToken) == 0x000004, "Wrong size on DIPlayerState_GetMatchStartCatalogueToken");
static_assert(offsetof(DIPlayerState_GetMatchStartCatalogueToken, ReturnValue) == 0x000000, "Member 'DIPlayerState_GetMatchStartCatalogueToken::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetPassiveID
// 0x0010 (0x0010 - 0x0000)
struct DIPlayerState_GetPassiveID final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetPassiveID) == 0x000004, "Wrong alignment on DIPlayerState_GetPassiveID");
static_assert(sizeof(DIPlayerState_GetPassiveID) == 0x000010, "Wrong size on DIPlayerState_GetPassiveID");
static_assert(offsetof(DIPlayerState_GetPassiveID, ReturnValue) == 0x000000, "Member 'DIPlayerState_GetPassiveID::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetPlatformType
// 0x0001 (0x0001 - 0x0000)
struct DIPlayerState_GetPlatformType final
{
public:
	EPlatformType                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetPlatformType) == 0x000001, "Wrong alignment on DIPlayerState_GetPlatformType");
static_assert(sizeof(DIPlayerState_GetPlatformType) == 0x000001, "Wrong size on DIPlayerState_GetPlatformType");
static_assert(offsetof(DIPlayerState_GetPlatformType, ReturnValue) == 0x000000, "Member 'DIPlayerState_GetPlatformType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetPlayerDisplayName
// 0x0010 (0x0010 - 0x0000)
struct DIPlayerState_GetPlayerDisplayName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetPlayerDisplayName) == 0x000008, "Wrong alignment on DIPlayerState_GetPlayerDisplayName");
static_assert(sizeof(DIPlayerState_GetPlayerDisplayName) == 0x000010, "Wrong size on DIPlayerState_GetPlayerDisplayName");
static_assert(offsetof(DIPlayerState_GetPlayerDisplayName, ReturnValue) == 0x000000, "Member 'DIPlayerState_GetPlayerDisplayName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetPlayerProgression
// 0x0020 (0x0020 - 0x0000)
struct DIPlayerState_GetPlayerProgression final
{
public:
	struct FPlayerProgression                     ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetPlayerProgression) == 0x000008, "Wrong alignment on DIPlayerState_GetPlayerProgression");
static_assert(sizeof(DIPlayerState_GetPlayerProgression) == 0x000020, "Wrong size on DIPlayerState_GetPlayerProgression");
static_assert(offsetof(DIPlayerState_GetPlayerProgression, ReturnValue) == 0x000000, "Member 'DIPlayerState_GetPlayerProgression::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetTitleId
// 0x0010 (0x0010 - 0x0000)
struct DIPlayerState_GetTitleId final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetTitleId) == 0x000004, "Wrong alignment on DIPlayerState_GetTitleId");
static_assert(sizeof(DIPlayerState_GetTitleId) == 0x000010, "Wrong size on DIPlayerState_GetTitleId");
static_assert(offsetof(DIPlayerState_GetTitleId, ReturnValue) == 0x000000, "Member 'DIPlayerState_GetTitleId::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.GetWeaponWrapID
// 0x0010 (0x0010 - 0x0000)
struct DIPlayerState_GetWeaponWrapID final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_GetWeaponWrapID) == 0x000004, "Wrong alignment on DIPlayerState_GetWeaponWrapID");
static_assert(sizeof(DIPlayerState_GetWeaponWrapID) == 0x000010, "Wrong size on DIPlayerState_GetWeaponWrapID");
static_assert(offsetof(DIPlayerState_GetWeaponWrapID, ReturnValue) == 0x000000, "Member 'DIPlayerState_GetWeaponWrapID::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.IsSameFactionAsLocalPlayer
// 0x0001 (0x0001 - 0x0000)
struct DIPlayerState_IsSameFactionAsLocalPlayer final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_IsSameFactionAsLocalPlayer) == 0x000001, "Wrong alignment on DIPlayerState_IsSameFactionAsLocalPlayer");
static_assert(sizeof(DIPlayerState_IsSameFactionAsLocalPlayer) == 0x000001, "Wrong size on DIPlayerState_IsSameFactionAsLocalPlayer");
static_assert(offsetof(DIPlayerState_IsSameFactionAsLocalPlayer, ReturnValue) == 0x000000, "Member 'DIPlayerState_IsSameFactionAsLocalPlayer::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPlayerState.ShouldShowRealNameToLocalPlayer
// 0x0001 (0x0001 - 0x0000)
struct DIPlayerState_ShouldShowRealNameToLocalPlayer final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPlayerState_ShouldShowRealNameToLocalPlayer) == 0x000001, "Wrong alignment on DIPlayerState_ShouldShowRealNameToLocalPlayer");
static_assert(sizeof(DIPlayerState_ShouldShowRealNameToLocalPlayer) == 0x000001, "Wrong size on DIPlayerState_ShouldShowRealNameToLocalPlayer");
static_assert(offsetof(DIPlayerState_ShouldShowRealNameToLocalPlayer, ReturnValue) == 0x000000, "Member 'DIPlayerState_ShouldShowRealNameToLocalPlayer::ReturnValue' has a wrong offset!");

// Function DeceiveInc.HealTeamComponent.HandleInteractionComplete
// 0x0010 (0x0010 - 0x0000)
struct HealTeamComponent_HandleInteractionComplete final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealTeamComponent_HandleInteractionComplete) == 0x000008, "Wrong alignment on HealTeamComponent_HandleInteractionComplete");
static_assert(sizeof(HealTeamComponent_HandleInteractionComplete) == 0x000010, "Wrong size on HealTeamComponent_HandleInteractionComplete");
static_assert(offsetof(HealTeamComponent_HandleInteractionComplete, Interacter) == 0x000000, "Member 'HealTeamComponent_HandleInteractionComplete::Interacter' has a wrong offset!");
static_assert(offsetof(HealTeamComponent_HandleInteractionComplete, Interactable) == 0x000008, "Member 'HealTeamComponent_HandleInteractionComplete::Interactable' has a wrong offset!");

// Function DeceiveInc.DIPopupUserWidget.OnNewTextToDisplay
// 0x0018 (0x0018 - 0x0000)
struct DIPopupUserWidget_OnNewTextToDisplay final
{
public:
	class FText                                   TextToDisplay;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPopupUserWidget_OnNewTextToDisplay) == 0x000008, "Wrong alignment on DIPopupUserWidget_OnNewTextToDisplay");
static_assert(sizeof(DIPopupUserWidget_OnNewTextToDisplay) == 0x000018, "Wrong size on DIPopupUserWidget_OnNewTextToDisplay");
static_assert(offsetof(DIPopupUserWidget_OnNewTextToDisplay, TextToDisplay) == 0x000000, "Member 'DIPopupUserWidget_OnNewTextToDisplay::TextToDisplay' has a wrong offset!");

// Function DeceiveInc.DIPopupUserWidget.OnNewTitleToDisplay
// 0x0018 (0x0018 - 0x0000)
struct DIPopupUserWidget_OnNewTitleToDisplay final
{
public:
	class FText                                   TitleToDisplay;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPopupUserWidget_OnNewTitleToDisplay) == 0x000008, "Wrong alignment on DIPopupUserWidget_OnNewTitleToDisplay");
static_assert(sizeof(DIPopupUserWidget_OnNewTitleToDisplay) == 0x000018, "Wrong size on DIPopupUserWidget_OnNewTitleToDisplay");
static_assert(offsetof(DIPopupUserWidget_OnNewTitleToDisplay, TitleToDisplay) == 0x000000, "Member 'DIPopupUserWidget_OnNewTitleToDisplay::TitleToDisplay' has a wrong offset!");

// Function DeceiveInc.DIPopupUserWidget.OnPopupAnswered
// 0x0001 (0x0001 - 0x0000)
struct DIPopupUserWidget_OnPopupAnswered final
{
public:
	bool                                          bAnswerValue;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPopupUserWidget_OnPopupAnswered) == 0x000001, "Wrong alignment on DIPopupUserWidget_OnPopupAnswered");
static_assert(sizeof(DIPopupUserWidget_OnPopupAnswered) == 0x000001, "Wrong size on DIPopupUserWidget_OnPopupAnswered");
static_assert(offsetof(DIPopupUserWidget_OnPopupAnswered, bAnswerValue) == 0x000000, "Member 'DIPopupUserWidget_OnPopupAnswered::bAnswerValue' has a wrong offset!");

// Function DeceiveInc.DIPopupAnnouncementUserWidget.OnNewImageToDisplay
// 0x0008 (0x0008 - 0x0000)
struct DIPopupAnnouncementUserWidget_OnNewImageToDisplay final
{
public:
	const class UTexture*                         NewImage;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPopupAnnouncementUserWidget_OnNewImageToDisplay) == 0x000008, "Wrong alignment on DIPopupAnnouncementUserWidget_OnNewImageToDisplay");
static_assert(sizeof(DIPopupAnnouncementUserWidget_OnNewImageToDisplay) == 0x000008, "Wrong size on DIPopupAnnouncementUserWidget_OnNewImageToDisplay");
static_assert(offsetof(DIPopupAnnouncementUserWidget_OnNewImageToDisplay, NewImage) == 0x000000, "Member 'DIPopupAnnouncementUserWidget_OnNewImageToDisplay::NewImage' has a wrong offset!");

// Function DeceiveInc.DIPopupAnnouncementUserWidget.SetImageToDisplay
// 0x0028 (0x0028 - 0x0000)
struct DIPopupAnnouncementUserWidget_SetImageToDisplay final
{
public:
	TSoftObjectPtr<class UTexture>                NewImage;                                          // 0x0000(0x0028)(ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPopupAnnouncementUserWidget_SetImageToDisplay) == 0x000008, "Wrong alignment on DIPopupAnnouncementUserWidget_SetImageToDisplay");
static_assert(sizeof(DIPopupAnnouncementUserWidget_SetImageToDisplay) == 0x000028, "Wrong size on DIPopupAnnouncementUserWidget_SetImageToDisplay");
static_assert(offsetof(DIPopupAnnouncementUserWidget_SetImageToDisplay, NewImage) == 0x000000, "Member 'DIPopupAnnouncementUserWidget_SetImageToDisplay::NewImage' has a wrong offset!");

// Function DeceiveInc.DIPopupAnnouncementUserWidget.SetShouldStayOnScreenWhenAnswered
// 0x0001 (0x0001 - 0x0000)
struct DIPopupAnnouncementUserWidget_SetShouldStayOnScreenWhenAnswered final
{
public:
	bool                                          InShouldStayOnScreenWhenAnswered;                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPopupAnnouncementUserWidget_SetShouldStayOnScreenWhenAnswered) == 0x000001, "Wrong alignment on DIPopupAnnouncementUserWidget_SetShouldStayOnScreenWhenAnswered");
static_assert(sizeof(DIPopupAnnouncementUserWidget_SetShouldStayOnScreenWhenAnswered) == 0x000001, "Wrong size on DIPopupAnnouncementUserWidget_SetShouldStayOnScreenWhenAnswered");
static_assert(offsetof(DIPopupAnnouncementUserWidget_SetShouldStayOnScreenWhenAnswered, InShouldStayOnScreenWhenAnswered) == 0x000000, "Member 'DIPopupAnnouncementUserWidget_SetShouldStayOnScreenWhenAnswered::InShouldStayOnScreenWhenAnswered' has a wrong offset!");

// Function DeceiveInc.DIPopupAnnouncementUserWidget.SetSpecialAnnouncmentSettings
// 0x0130 (0x0130 - 0x0000)
struct DIPopupAnnouncementUserWidget_SetSpecialAnnouncmentSettings final
{
public:
	struct FDISpecialAnnouncmentSettings          InMessageSettings;                                 // 0x0000(0x0130)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPopupAnnouncementUserWidget_SetSpecialAnnouncmentSettings) == 0x000008, "Wrong alignment on DIPopupAnnouncementUserWidget_SetSpecialAnnouncmentSettings");
static_assert(sizeof(DIPopupAnnouncementUserWidget_SetSpecialAnnouncmentSettings) == 0x000130, "Wrong size on DIPopupAnnouncementUserWidget_SetSpecialAnnouncmentSettings");
static_assert(offsetof(DIPopupAnnouncementUserWidget_SetSpecialAnnouncmentSettings, InMessageSettings) == 0x000000, "Member 'DIPopupAnnouncementUserWidget_SetSpecialAnnouncmentSettings::InMessageSettings' has a wrong offset!");

// Function DeceiveInc.DIPopupAnnouncementUserWidget.GetImageAsset
// 0x0028 (0x0028 - 0x0000)
struct DIPopupAnnouncementUserWidget_GetImageAsset final
{
public:
	TSoftObjectPtr<class UTexture>                ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPopupAnnouncementUserWidget_GetImageAsset) == 0x000008, "Wrong alignment on DIPopupAnnouncementUserWidget_GetImageAsset");
static_assert(sizeof(DIPopupAnnouncementUserWidget_GetImageAsset) == 0x000028, "Wrong size on DIPopupAnnouncementUserWidget_GetImageAsset");
static_assert(offsetof(DIPopupAnnouncementUserWidget_GetImageAsset, ReturnValue) == 0x000000, "Member 'DIPopupAnnouncementUserWidget_GetImageAsset::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPopupAnnouncementUserWidget.GetText
// 0x0018 (0x0018 - 0x0000)
struct DIPopupAnnouncementUserWidget_GetText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPopupAnnouncementUserWidget_GetText) == 0x000008, "Wrong alignment on DIPopupAnnouncementUserWidget_GetText");
static_assert(sizeof(DIPopupAnnouncementUserWidget_GetText) == 0x000018, "Wrong size on DIPopupAnnouncementUserWidget_GetText");
static_assert(offsetof(DIPopupAnnouncementUserWidget_GetText, ReturnValue) == 0x000000, "Member 'DIPopupAnnouncementUserWidget_GetText::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPopupAnnouncementUserWidget.GetTitle
// 0x0018 (0x0018 - 0x0000)
struct DIPopupAnnouncementUserWidget_GetTitle final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPopupAnnouncementUserWidget_GetTitle) == 0x000008, "Wrong alignment on DIPopupAnnouncementUserWidget_GetTitle");
static_assert(sizeof(DIPopupAnnouncementUserWidget_GetTitle) == 0x000018, "Wrong size on DIPopupAnnouncementUserWidget_GetTitle");
static_assert(offsetof(DIPopupAnnouncementUserWidget_GetTitle, ReturnValue) == 0x000000, "Member 'DIPopupAnnouncementUserWidget_GetTitle::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPopupAnnouncementUserWidget.IsShouldStayOnScreenWhenAnswered
// 0x0001 (0x0001 - 0x0000)
struct DIPopupAnnouncementUserWidget_IsShouldStayOnScreenWhenAnswered final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPopupAnnouncementUserWidget_IsShouldStayOnScreenWhenAnswered) == 0x000001, "Wrong alignment on DIPopupAnnouncementUserWidget_IsShouldStayOnScreenWhenAnswered");
static_assert(sizeof(DIPopupAnnouncementUserWidget_IsShouldStayOnScreenWhenAnswered) == 0x000001, "Wrong size on DIPopupAnnouncementUserWidget_IsShouldStayOnScreenWhenAnswered");
static_assert(offsetof(DIPopupAnnouncementUserWidget_IsShouldStayOnScreenWhenAnswered, ReturnValue) == 0x000000, "Member 'DIPopupAnnouncementUserWidget_IsShouldStayOnScreenWhenAnswered::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPrivateLobbyMenuUserWidget.GetSelectedPlayers
// 0x0010 (0x0010 - 0x0000)
struct DIPrivateLobbyMenuUserWidget_GetSelectedPlayers final
{
public:
	TArray<class UDIOnlinePartyMemberInfo*>       ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIPrivateLobbyMenuUserWidget_GetSelectedPlayers) == 0x000008, "Wrong alignment on DIPrivateLobbyMenuUserWidget_GetSelectedPlayers");
static_assert(sizeof(DIPrivateLobbyMenuUserWidget_GetSelectedPlayers) == 0x000010, "Wrong size on DIPrivateLobbyMenuUserWidget_GetSelectedPlayers");
static_assert(offsetof(DIPrivateLobbyMenuUserWidget_GetSelectedPlayers, ReturnValue) == 0x000000, "Member 'DIPrivateLobbyMenuUserWidget_GetSelectedPlayers::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPrivateLobbyMenuUserWidget.IsSelectedPlayer
// 0x0010 (0x0010 - 0x0000)
struct DIPrivateLobbyMenuUserWidget_IsSelectedPlayer final
{
public:
	class UDIOnlinePartyMemberInfo*               Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIPrivateLobbyMenuUserWidget_IsSelectedPlayer) == 0x000008, "Wrong alignment on DIPrivateLobbyMenuUserWidget_IsSelectedPlayer");
static_assert(sizeof(DIPrivateLobbyMenuUserWidget_IsSelectedPlayer) == 0x000010, "Wrong size on DIPrivateLobbyMenuUserWidget_IsSelectedPlayer");
static_assert(offsetof(DIPrivateLobbyMenuUserWidget_IsSelectedPlayer, Player) == 0x000000, "Member 'DIPrivateLobbyMenuUserWidget_IsSelectedPlayer::Player' has a wrong offset!");
static_assert(offsetof(DIPrivateLobbyMenuUserWidget_IsSelectedPlayer, ReturnValue) == 0x000008, "Member 'DIPrivateLobbyMenuUserWidget_IsSelectedPlayer::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIPrivateLobbyMenuUserWidget.SetSelectedPlayer
// 0x0010 (0x0010 - 0x0000)
struct DIPrivateLobbyMenuUserWidget_SetSelectedPlayer final
{
public:
	class UDIOnlinePartyMemberInfo*               Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Selected;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIPrivateLobbyMenuUserWidget_SetSelectedPlayer) == 0x000008, "Wrong alignment on DIPrivateLobbyMenuUserWidget_SetSelectedPlayer");
static_assert(sizeof(DIPrivateLobbyMenuUserWidget_SetSelectedPlayer) == 0x000010, "Wrong size on DIPrivateLobbyMenuUserWidget_SetSelectedPlayer");
static_assert(offsetof(DIPrivateLobbyMenuUserWidget_SetSelectedPlayer, Player) == 0x000000, "Member 'DIPrivateLobbyMenuUserWidget_SetSelectedPlayer::Player' has a wrong offset!");
static_assert(offsetof(DIPrivateLobbyMenuUserWidget_SetSelectedPlayer, Selected) == 0x000008, "Member 'DIPrivateLobbyMenuUserWidget_SetSelectedPlayer::Selected' has a wrong offset!");

// Function DeceiveInc.KeycardPrinterActor.BP_OnScrambleStateChanged
// 0x0001 (0x0001 - 0x0000)
struct KeycardPrinterActor_BP_OnScrambleStateChanged final
{
public:
	bool                                          bScrambled;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KeycardPrinterActor_BP_OnScrambleStateChanged) == 0x000001, "Wrong alignment on KeycardPrinterActor_BP_OnScrambleStateChanged");
static_assert(sizeof(KeycardPrinterActor_BP_OnScrambleStateChanged) == 0x000001, "Wrong size on KeycardPrinterActor_BP_OnScrambleStateChanged");
static_assert(offsetof(KeycardPrinterActor_BP_OnScrambleStateChanged, bScrambled) == 0x000000, "Member 'KeycardPrinterActor_BP_OnScrambleStateChanged::bScrambled' has a wrong offset!");

// Function DeceiveInc.KeycardPrinterActor.GetPrintedKeycard
// 0x0008 (0x0008 - 0x0000)
struct KeycardPrinterActor_GetPrintedKeycard final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KeycardPrinterActor_GetPrintedKeycard) == 0x000008, "Wrong alignment on KeycardPrinterActor_GetPrintedKeycard");
static_assert(sizeof(KeycardPrinterActor_GetPrintedKeycard) == 0x000008, "Wrong size on KeycardPrinterActor_GetPrintedKeycard");
static_assert(offsetof(KeycardPrinterActor_GetPrintedKeycard, ReturnValue) == 0x000000, "Member 'KeycardPrinterActor_GetPrintedKeycard::ReturnValue' has a wrong offset!");

// Function DeceiveInc.KeycardPrinterActor.HandleScramblerIsAffectedChanged
// 0x0010 (0x0010 - 0x0000)
struct KeycardPrinterActor_HandleScramblerIsAffectedChanged final
{
public:
	bool                                          bIsAffected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AffectedActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KeycardPrinterActor_HandleScramblerIsAffectedChanged) == 0x000008, "Wrong alignment on KeycardPrinterActor_HandleScramblerIsAffectedChanged");
static_assert(sizeof(KeycardPrinterActor_HandleScramblerIsAffectedChanged) == 0x000010, "Wrong size on KeycardPrinterActor_HandleScramblerIsAffectedChanged");
static_assert(offsetof(KeycardPrinterActor_HandleScramblerIsAffectedChanged, bIsAffected) == 0x000000, "Member 'KeycardPrinterActor_HandleScramblerIsAffectedChanged::bIsAffected' has a wrong offset!");
static_assert(offsetof(KeycardPrinterActor_HandleScramblerIsAffectedChanged, AffectedActor) == 0x000008, "Member 'KeycardPrinterActor_HandleScramblerIsAffectedChanged::AffectedActor' has a wrong offset!");

// Function DeceiveInc.KeycardPrinterActor.SetPrintedKeycard
// 0x0008 (0x0008 - 0x0000)
struct KeycardPrinterActor_SetPrintedKeycard final
{
public:
	class AActor*                                 PrintedKeycardIn;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KeycardPrinterActor_SetPrintedKeycard) == 0x000008, "Wrong alignment on KeycardPrinterActor_SetPrintedKeycard");
static_assert(sizeof(KeycardPrinterActor_SetPrintedKeycard) == 0x000008, "Wrong size on KeycardPrinterActor_SetPrintedKeycard");
static_assert(offsetof(KeycardPrinterActor_SetPrintedKeycard, PrintedKeycardIn) == 0x000000, "Member 'KeycardPrinterActor_SetPrintedKeycard::PrintedKeycardIn' has a wrong offset!");

// Function DeceiveInc.DIResultScreenMenuUserWidget.GetSubtitleWidget
// 0x0008 (0x0008 - 0x0000)
struct DIResultScreenMenuUserWidget_GetSubtitleWidget final
{
public:
	class UUserWidget*                            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIResultScreenMenuUserWidget_GetSubtitleWidget) == 0x000008, "Wrong alignment on DIResultScreenMenuUserWidget_GetSubtitleWidget");
static_assert(sizeof(DIResultScreenMenuUserWidget_GetSubtitleWidget) == 0x000008, "Wrong size on DIResultScreenMenuUserWidget_GetSubtitleWidget");
static_assert(offsetof(DIResultScreenMenuUserWidget_GetSubtitleWidget, ReturnValue) == 0x000000, "Member 'DIResultScreenMenuUserWidget_GetSubtitleWidget::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ObjectiveProximitySubsystem.HandleExtractionArrivedEvent
// 0x0008 (0x0008 - 0x0000)
struct ObjectiveProximitySubsystem_HandleExtractionArrivedEvent final
{
public:
	class UExtractionArrivedPhaseInfo*            PhaseInfo;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ObjectiveProximitySubsystem_HandleExtractionArrivedEvent) == 0x000008, "Wrong alignment on ObjectiveProximitySubsystem_HandleExtractionArrivedEvent");
static_assert(sizeof(ObjectiveProximitySubsystem_HandleExtractionArrivedEvent) == 0x000008, "Wrong size on ObjectiveProximitySubsystem_HandleExtractionArrivedEvent");
static_assert(offsetof(ObjectiveProximitySubsystem_HandleExtractionArrivedEvent, PhaseInfo) == 0x000000, "Member 'ObjectiveProximitySubsystem_HandleExtractionArrivedEvent::PhaseInfo' has a wrong offset!");

// Function DeceiveInc.ObjectiveProximitySubsystem.HandleExtractionArrivingEvent
// 0x0008 (0x0008 - 0x0000)
struct ObjectiveProximitySubsystem_HandleExtractionArrivingEvent final
{
public:
	class UExtractionArrivingPhaseInfo*           PhaseInfo;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ObjectiveProximitySubsystem_HandleExtractionArrivingEvent) == 0x000008, "Wrong alignment on ObjectiveProximitySubsystem_HandleExtractionArrivingEvent");
static_assert(sizeof(ObjectiveProximitySubsystem_HandleExtractionArrivingEvent) == 0x000008, "Wrong size on ObjectiveProximitySubsystem_HandleExtractionArrivingEvent");
static_assert(offsetof(ObjectiveProximitySubsystem_HandleExtractionArrivingEvent, PhaseInfo) == 0x000000, "Member 'ObjectiveProximitySubsystem_HandleExtractionArrivingEvent::PhaseInfo' has a wrong offset!");

// Function DeceiveInc.DISessionProgression.GetAgentLevelByXpType
// 0x0028 (0x0028 - 0x0000)
struct DISessionProgression_GetAgentLevelByXpType final
{
public:
	struct FPrimaryAssetId                        XpType;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerXpTypeDefinition                ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionProgression_GetAgentLevelByXpType) == 0x000008, "Wrong alignment on DISessionProgression_GetAgentLevelByXpType");
static_assert(sizeof(DISessionProgression_GetAgentLevelByXpType) == 0x000028, "Wrong size on DISessionProgression_GetAgentLevelByXpType");
static_assert(offsetof(DISessionProgression_GetAgentLevelByXpType, XpType) == 0x000000, "Member 'DISessionProgression_GetAgentLevelByXpType::XpType' has a wrong offset!");
static_assert(offsetof(DISessionProgression_GetAgentLevelByXpType, ReturnValue) == 0x000010, "Member 'DISessionProgression_GetAgentLevelByXpType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionProgression.GetAgentMasteryByXpType
// 0x0028 (0x0028 - 0x0000)
struct DISessionProgression_GetAgentMasteryByXpType final
{
public:
	struct FPrimaryAssetId                        XpType;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerXpTypeDefinition                ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionProgression_GetAgentMasteryByXpType) == 0x000008, "Wrong alignment on DISessionProgression_GetAgentMasteryByXpType");
static_assert(sizeof(DISessionProgression_GetAgentMasteryByXpType) == 0x000028, "Wrong size on DISessionProgression_GetAgentMasteryByXpType");
static_assert(offsetof(DISessionProgression_GetAgentMasteryByXpType, XpType) == 0x000000, "Member 'DISessionProgression_GetAgentMasteryByXpType::XpType' has a wrong offset!");
static_assert(offsetof(DISessionProgression_GetAgentMasteryByXpType, ReturnValue) == 0x000010, "Member 'DISessionProgression_GetAgentMasteryByXpType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionProgression.GetXpInfoByXpType
// 0x0028 (0x0028 - 0x0000)
struct DISessionProgression_GetXpInfoByXpType final
{
public:
	struct FPrimaryAssetId                        XpType;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerXpTypeDefinition                ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionProgression_GetXpInfoByXpType) == 0x000008, "Wrong alignment on DISessionProgression_GetXpInfoByXpType");
static_assert(sizeof(DISessionProgression_GetXpInfoByXpType) == 0x000028, "Wrong size on DISessionProgression_GetXpInfoByXpType");
static_assert(offsetof(DISessionProgression_GetXpInfoByXpType, XpType) == 0x000000, "Member 'DISessionProgression_GetXpInfoByXpType::XpType' has a wrong offset!");
static_assert(offsetof(DISessionProgression_GetXpInfoByXpType, ReturnValue) == 0x000010, "Member 'DISessionProgression_GetXpInfoByXpType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionProgression.GetAgentLevelByString
// 0x0028 (0x0028 - 0x0000)
struct DISessionProgression_GetAgentLevelByString final
{
public:
	class FString                                 XpType;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerXpTypeDefinition                ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionProgression_GetAgentLevelByString) == 0x000008, "Wrong alignment on DISessionProgression_GetAgentLevelByString");
static_assert(sizeof(DISessionProgression_GetAgentLevelByString) == 0x000028, "Wrong size on DISessionProgression_GetAgentLevelByString");
static_assert(offsetof(DISessionProgression_GetAgentLevelByString, XpType) == 0x000000, "Member 'DISessionProgression_GetAgentLevelByString::XpType' has a wrong offset!");
static_assert(offsetof(DISessionProgression_GetAgentLevelByString, ReturnValue) == 0x000010, "Member 'DISessionProgression_GetAgentLevelByString::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionProgression.GetAgentMasteryByString
// 0x0028 (0x0028 - 0x0000)
struct DISessionProgression_GetAgentMasteryByString final
{
public:
	class FString                                 XpType;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerXpTypeDefinition                ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionProgression_GetAgentMasteryByString) == 0x000008, "Wrong alignment on DISessionProgression_GetAgentMasteryByString");
static_assert(sizeof(DISessionProgression_GetAgentMasteryByString) == 0x000028, "Wrong size on DISessionProgression_GetAgentMasteryByString");
static_assert(offsetof(DISessionProgression_GetAgentMasteryByString, XpType) == 0x000000, "Member 'DISessionProgression_GetAgentMasteryByString::XpType' has a wrong offset!");
static_assert(offsetof(DISessionProgression_GetAgentMasteryByString, ReturnValue) == 0x000010, "Member 'DISessionProgression_GetAgentMasteryByString::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionProgression.GetXpInfoByString
// 0x0028 (0x0028 - 0x0000)
struct DISessionProgression_GetXpInfoByString final
{
public:
	class FString                                 XpType;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerXpTypeDefinition                ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionProgression_GetXpInfoByString) == 0x000008, "Wrong alignment on DISessionProgression_GetXpInfoByString");
static_assert(sizeof(DISessionProgression_GetXpInfoByString) == 0x000028, "Wrong size on DISessionProgression_GetXpInfoByString");
static_assert(offsetof(DISessionProgression_GetXpInfoByString, XpType) == 0x000000, "Member 'DISessionProgression_GetXpInfoByString::XpType' has a wrong offset!");
static_assert(offsetof(DISessionProgression_GetXpInfoByString, ReturnValue) == 0x000010, "Member 'DISessionProgression_GetXpInfoByString::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SessionAccessoriesSelectionInfo.GetSelectedCallingCards
// 0x0010 (0x0010 - 0x0000)
struct SessionAccessoriesSelectionInfo_GetSelectedCallingCards final
{
public:
	TArray<class UCallingCardDataAsset*>          ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SessionAccessoriesSelectionInfo_GetSelectedCallingCards) == 0x000008, "Wrong alignment on SessionAccessoriesSelectionInfo_GetSelectedCallingCards");
static_assert(sizeof(SessionAccessoriesSelectionInfo_GetSelectedCallingCards) == 0x000010, "Wrong size on SessionAccessoriesSelectionInfo_GetSelectedCallingCards");
static_assert(offsetof(SessionAccessoriesSelectionInfo_GetSelectedCallingCards, ReturnValue) == 0x000000, "Member 'SessionAccessoriesSelectionInfo_GetSelectedCallingCards::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.DEBUG_GetAllAgentSkinDatasByAgentSkinData
// 0x0020 (0x0020 - 0x0000)
struct DISessionSelections_DEBUG_GetAllAgentSkinDatasByAgentSkinData final
{
public:
	const class UAgentSkinData*                   AgentSkinData;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentIndex;                                      // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAgentSkinData*>                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_DEBUG_GetAllAgentSkinDatasByAgentSkinData) == 0x000008, "Wrong alignment on DISessionSelections_DEBUG_GetAllAgentSkinDatasByAgentSkinData");
static_assert(sizeof(DISessionSelections_DEBUG_GetAllAgentSkinDatasByAgentSkinData) == 0x000020, "Wrong size on DISessionSelections_DEBUG_GetAllAgentSkinDatasByAgentSkinData");
static_assert(offsetof(DISessionSelections_DEBUG_GetAllAgentSkinDatasByAgentSkinData, AgentSkinData) == 0x000000, "Member 'DISessionSelections_DEBUG_GetAllAgentSkinDatasByAgentSkinData::AgentSkinData' has a wrong offset!");
static_assert(offsetof(DISessionSelections_DEBUG_GetAllAgentSkinDatasByAgentSkinData, CurrentIndex) == 0x000008, "Member 'DISessionSelections_DEBUG_GetAllAgentSkinDatasByAgentSkinData::CurrentIndex' has a wrong offset!");
static_assert(offsetof(DISessionSelections_DEBUG_GetAllAgentSkinDatasByAgentSkinData, ReturnValue) == 0x000010, "Member 'DISessionSelections_DEBUG_GetAllAgentSkinDatasByAgentSkinData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.GetAgentIntroPoseDatasByAgentData
// 0x0018 (0x0018 - 0x0000)
struct DISessionSelections_GetAgentIntroPoseDatasByAgentData final
{
public:
	const class UAgentData*                       AgentData;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAgentIntroPoseDataAsset*>       ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_GetAgentIntroPoseDatasByAgentData) == 0x000008, "Wrong alignment on DISessionSelections_GetAgentIntroPoseDatasByAgentData");
static_assert(sizeof(DISessionSelections_GetAgentIntroPoseDatasByAgentData) == 0x000018, "Wrong size on DISessionSelections_GetAgentIntroPoseDatasByAgentData");
static_assert(offsetof(DISessionSelections_GetAgentIntroPoseDatasByAgentData, AgentData) == 0x000000, "Member 'DISessionSelections_GetAgentIntroPoseDatasByAgentData::AgentData' has a wrong offset!");
static_assert(offsetof(DISessionSelections_GetAgentIntroPoseDatasByAgentData, ReturnValue) == 0x000008, "Member 'DISessionSelections_GetAgentIntroPoseDatasByAgentData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.GetAgentSkinDatasByAgentData
// 0x0018 (0x0018 - 0x0000)
struct DISessionSelections_GetAgentSkinDatasByAgentData final
{
public:
	const class UAgentData*                       AgentData;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAgentSkinData*>                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_GetAgentSkinDatasByAgentData) == 0x000008, "Wrong alignment on DISessionSelections_GetAgentSkinDatasByAgentData");
static_assert(sizeof(DISessionSelections_GetAgentSkinDatasByAgentData) == 0x000018, "Wrong size on DISessionSelections_GetAgentSkinDatasByAgentData");
static_assert(offsetof(DISessionSelections_GetAgentSkinDatasByAgentData, AgentData) == 0x000000, "Member 'DISessionSelections_GetAgentSkinDatasByAgentData::AgentData' has a wrong offset!");
static_assert(offsetof(DISessionSelections_GetAgentSkinDatasByAgentData, ReturnValue) == 0x000008, "Member 'DISessionSelections_GetAgentSkinDatasByAgentData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.GetAvatarSelection
// 0x0010 (0x0010 - 0x0000)
struct DISessionSelections_GetAvatarSelection final
{
public:
	TArray<class UAvatarDataAsset*>               ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_GetAvatarSelection) == 0x000008, "Wrong alignment on DISessionSelections_GetAvatarSelection");
static_assert(sizeof(DISessionSelections_GetAvatarSelection) == 0x000010, "Wrong size on DISessionSelections_GetAvatarSelection");
static_assert(offsetof(DISessionSelections_GetAvatarSelection, ReturnValue) == 0x000000, "Member 'DISessionSelections_GetAvatarSelection::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.GetCallingCardSelection
// 0x0010 (0x0010 - 0x0000)
struct DISessionSelections_GetCallingCardSelection final
{
public:
	TArray<class UCallingCardDataAsset*>          ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_GetCallingCardSelection) == 0x000008, "Wrong alignment on DISessionSelections_GetCallingCardSelection");
static_assert(sizeof(DISessionSelections_GetCallingCardSelection) == 0x000010, "Wrong size on DISessionSelections_GetCallingCardSelection");
static_assert(offsetof(DISessionSelections_GetCallingCardSelection, ReturnValue) == 0x000000, "Member 'DISessionSelections_GetCallingCardSelection::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.GetDeckName
// 0x0018 (0x0018 - 0x0000)
struct DISessionSelections_GetDeckName final
{
public:
	int32                                         DeckIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DeckName;                                          // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_GetDeckName) == 0x000008, "Wrong alignment on DISessionSelections_GetDeckName");
static_assert(sizeof(DISessionSelections_GetDeckName) == 0x000018, "Wrong size on DISessionSelections_GetDeckName");
static_assert(offsetof(DISessionSelections_GetDeckName, DeckIndex) == 0x000000, "Member 'DISessionSelections_GetDeckName::DeckIndex' has a wrong offset!");
static_assert(offsetof(DISessionSelections_GetDeckName, DeckName) == 0x000008, "Member 'DISessionSelections_GetDeckName::DeckName' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.GetEquippedDeckName
// 0x0010 (0x0010 - 0x0000)
struct DISessionSelections_GetEquippedDeckName final
{
public:
	class FString                                 DeckName;                                          // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_GetEquippedDeckName) == 0x000008, "Wrong alignment on DISessionSelections_GetEquippedDeckName");
static_assert(sizeof(DISessionSelections_GetEquippedDeckName) == 0x000010, "Wrong size on DISessionSelections_GetEquippedDeckName");
static_assert(offsetof(DISessionSelections_GetEquippedDeckName, DeckName) == 0x000000, "Member 'DISessionSelections_GetEquippedDeckName::DeckName' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.GetSavedPowerupDecksInfos
// 0x0028 (0x0028 - 0x0000)
struct DISessionSelections_GetSavedPowerupDecksInfos final
{
public:
	struct FDISerializedDecks                     PlayerDecks;                                       // 0x0000(0x0028)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_GetSavedPowerupDecksInfos) == 0x000008, "Wrong alignment on DISessionSelections_GetSavedPowerupDecksInfos");
static_assert(sizeof(DISessionSelections_GetSavedPowerupDecksInfos) == 0x000028, "Wrong size on DISessionSelections_GetSavedPowerupDecksInfos");
static_assert(offsetof(DISessionSelections_GetSavedPowerupDecksInfos, PlayerDecks) == 0x000000, "Member 'DISessionSelections_GetSavedPowerupDecksInfos::PlayerDecks' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.GetTitleSelection
// 0x0010 (0x0010 - 0x0000)
struct DISessionSelections_GetTitleSelection final
{
public:
	TArray<class UTitleDataAsset*>                ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_GetTitleSelection) == 0x000008, "Wrong alignment on DISessionSelections_GetTitleSelection");
static_assert(sizeof(DISessionSelections_GetTitleSelection) == 0x000010, "Wrong size on DISessionSelections_GetTitleSelection");
static_assert(offsetof(DISessionSelections_GetTitleSelection, ReturnValue) == 0x000000, "Member 'DISessionSelections_GetTitleSelection::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.GetToolMenuWrapSelection
// 0x0020 (0x0020 - 0x0000)
struct DISessionSelections_GetToolMenuWrapSelection final
{
public:
	struct FPrimaryAssetId                        ToolAssetId;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMenuWrapData*>                  ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_GetToolMenuWrapSelection) == 0x000008, "Wrong alignment on DISessionSelections_GetToolMenuWrapSelection");
static_assert(sizeof(DISessionSelections_GetToolMenuWrapSelection) == 0x000020, "Wrong size on DISessionSelections_GetToolMenuWrapSelection");
static_assert(offsetof(DISessionSelections_GetToolMenuWrapSelection, ToolAssetId) == 0x000000, "Member 'DISessionSelections_GetToolMenuWrapSelection::ToolAssetId' has a wrong offset!");
static_assert(offsetof(DISessionSelections_GetToolMenuWrapSelection, ReturnValue) == 0x000010, "Member 'DISessionSelections_GetToolMenuWrapSelection::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.GetToolSelectedWrap
// 0x0018 (0x0018 - 0x0000)
struct DISessionSelections_GetToolSelectedWrap final
{
public:
	struct FPrimaryAssetId                        ToolAssetId;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMenuWrapData*                          ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_GetToolSelectedWrap) == 0x000008, "Wrong alignment on DISessionSelections_GetToolSelectedWrap");
static_assert(sizeof(DISessionSelections_GetToolSelectedWrap) == 0x000018, "Wrong size on DISessionSelections_GetToolSelectedWrap");
static_assert(offsetof(DISessionSelections_GetToolSelectedWrap, ToolAssetId) == 0x000000, "Member 'DISessionSelections_GetToolSelectedWrap::ToolAssetId' has a wrong offset!");
static_assert(offsetof(DISessionSelections_GetToolSelectedWrap, ReturnValue) == 0x000010, "Member 'DISessionSelections_GetToolSelectedWrap::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.IsAgentSelectable
// 0x0014 (0x0014 - 0x0000)
struct DISessionSelections_IsAgentSelectable final
{
public:
	struct FPrimaryAssetId                        AgentId;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DISessionSelections_IsAgentSelectable) == 0x000004, "Wrong alignment on DISessionSelections_IsAgentSelectable");
static_assert(sizeof(DISessionSelections_IsAgentSelectable) == 0x000014, "Wrong size on DISessionSelections_IsAgentSelectable");
static_assert(offsetof(DISessionSelections_IsAgentSelectable, AgentId) == 0x000000, "Member 'DISessionSelections_IsAgentSelectable::AgentId' has a wrong offset!");
static_assert(offsetof(DISessionSelections_IsAgentSelectable, ReturnValue) == 0x000010, "Member 'DISessionSelections_IsAgentSelectable::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.IsAgentSkinSelectable
// 0x0014 (0x0014 - 0x0000)
struct DISessionSelections_IsAgentSkinSelectable final
{
public:
	struct FPrimaryAssetId                        AgentSkinId;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DISessionSelections_IsAgentSkinSelectable) == 0x000004, "Wrong alignment on DISessionSelections_IsAgentSkinSelectable");
static_assert(sizeof(DISessionSelections_IsAgentSkinSelectable) == 0x000014, "Wrong size on DISessionSelections_IsAgentSkinSelectable");
static_assert(offsetof(DISessionSelections_IsAgentSkinSelectable, AgentSkinId) == 0x000000, "Member 'DISessionSelections_IsAgentSkinSelectable::AgentSkinId' has a wrong offset!");
static_assert(offsetof(DISessionSelections_IsAgentSkinSelectable, ReturnValue) == 0x000010, "Member 'DISessionSelections_IsAgentSkinSelectable::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.SetAgentIntroPoseIdByAgentId
// 0x0020 (0x0020 - 0x0000)
struct DISessionSelections_SetAgentIntroPoseIdByAgentId final
{
public:
	struct FPrimaryAssetId                        AgentId;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        IntroPoseId;                                       // 0x0010(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_SetAgentIntroPoseIdByAgentId) == 0x000004, "Wrong alignment on DISessionSelections_SetAgentIntroPoseIdByAgentId");
static_assert(sizeof(DISessionSelections_SetAgentIntroPoseIdByAgentId) == 0x000020, "Wrong size on DISessionSelections_SetAgentIntroPoseIdByAgentId");
static_assert(offsetof(DISessionSelections_SetAgentIntroPoseIdByAgentId, AgentId) == 0x000000, "Member 'DISessionSelections_SetAgentIntroPoseIdByAgentId::AgentId' has a wrong offset!");
static_assert(offsetof(DISessionSelections_SetAgentIntroPoseIdByAgentId, IntroPoseId) == 0x000010, "Member 'DISessionSelections_SetAgentIntroPoseIdByAgentId::IntroPoseId' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.SetAgentSkinIdByAgentId
// 0x0020 (0x0020 - 0x0000)
struct DISessionSelections_SetAgentSkinIdByAgentId final
{
public:
	struct FPrimaryAssetId                        AgentId;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SkinId;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_SetAgentSkinIdByAgentId) == 0x000004, "Wrong alignment on DISessionSelections_SetAgentSkinIdByAgentId");
static_assert(sizeof(DISessionSelections_SetAgentSkinIdByAgentId) == 0x000020, "Wrong size on DISessionSelections_SetAgentSkinIdByAgentId");
static_assert(offsetof(DISessionSelections_SetAgentSkinIdByAgentId, AgentId) == 0x000000, "Member 'DISessionSelections_SetAgentSkinIdByAgentId::AgentId' has a wrong offset!");
static_assert(offsetof(DISessionSelections_SetAgentSkinIdByAgentId, SkinId) == 0x000010, "Member 'DISessionSelections_SetAgentSkinIdByAgentId::SkinId' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.SetCallingCard
// 0x0014 (0x0014 - 0x0000)
struct DISessionSelections_SetCallingCard final
{
public:
	struct FPrimaryAssetId                        CallingCardId;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECallingCardPosition                          CalingCardPosition;                                // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DISessionSelections_SetCallingCard) == 0x000004, "Wrong alignment on DISessionSelections_SetCallingCard");
static_assert(sizeof(DISessionSelections_SetCallingCard) == 0x000014, "Wrong size on DISessionSelections_SetCallingCard");
static_assert(offsetof(DISessionSelections_SetCallingCard, CallingCardId) == 0x000000, "Member 'DISessionSelections_SetCallingCard::CallingCardId' has a wrong offset!");
static_assert(offsetof(DISessionSelections_SetCallingCard, CalingCardPosition) == 0x000010, "Member 'DISessionSelections_SetCallingCard::CalingCardPosition' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.SetDeckName
// 0x0018 (0x0018 - 0x0000)
struct DISessionSelections_SetDeckName final
{
public:
	int32                                         DeckIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NewDeckName;                                       // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_SetDeckName) == 0x000008, "Wrong alignment on DISessionSelections_SetDeckName");
static_assert(sizeof(DISessionSelections_SetDeckName) == 0x000018, "Wrong size on DISessionSelections_SetDeckName");
static_assert(offsetof(DISessionSelections_SetDeckName, DeckIndex) == 0x000000, "Member 'DISessionSelections_SetDeckName::DeckIndex' has a wrong offset!");
static_assert(offsetof(DISessionSelections_SetDeckName, NewDeckName) == 0x000008, "Member 'DISessionSelections_SetDeckName::NewDeckName' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.SetDeckPowerupToSlot
// 0x0008 (0x0008 - 0x0000)
struct DISessionSelections_SetDeckPowerupToSlot final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PowerupUpIndex;                                    // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_SetDeckPowerupToSlot) == 0x000004, "Wrong alignment on DISessionSelections_SetDeckPowerupToSlot");
static_assert(sizeof(DISessionSelections_SetDeckPowerupToSlot) == 0x000008, "Wrong size on DISessionSelections_SetDeckPowerupToSlot");
static_assert(offsetof(DISessionSelections_SetDeckPowerupToSlot, SlotIndex) == 0x000000, "Member 'DISessionSelections_SetDeckPowerupToSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(DISessionSelections_SetDeckPowerupToSlot, PowerupUpIndex) == 0x000004, "Member 'DISessionSelections_SetDeckPowerupToSlot::PowerupUpIndex' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.SetPowerupDeckToEquip
// 0x0004 (0x0004 - 0x0000)
struct DISessionSelections_SetPowerupDeckToEquip final
{
public:
	int32                                         NewDeckIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_SetPowerupDeckToEquip) == 0x000004, "Wrong alignment on DISessionSelections_SetPowerupDeckToEquip");
static_assert(sizeof(DISessionSelections_SetPowerupDeckToEquip) == 0x000004, "Wrong size on DISessionSelections_SetPowerupDeckToEquip");
static_assert(offsetof(DISessionSelections_SetPowerupDeckToEquip, NewDeckIndex) == 0x000000, "Member 'DISessionSelections_SetPowerupDeckToEquip::NewDeckIndex' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.SetSelectedAgent
// 0x0014 (0x0014 - 0x0000)
struct DISessionSelections_SetSelectedAgent final
{
public:
	struct FPrimaryAssetId                        AgentId;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSaveToStorage;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DISessionSelections_SetSelectedAgent) == 0x000004, "Wrong alignment on DISessionSelections_SetSelectedAgent");
static_assert(sizeof(DISessionSelections_SetSelectedAgent) == 0x000014, "Wrong size on DISessionSelections_SetSelectedAgent");
static_assert(offsetof(DISessionSelections_SetSelectedAgent, AgentId) == 0x000000, "Member 'DISessionSelections_SetSelectedAgent::AgentId' has a wrong offset!");
static_assert(offsetof(DISessionSelections_SetSelectedAgent, bSaveToStorage) == 0x000010, "Member 'DISessionSelections_SetSelectedAgent::bSaveToStorage' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.SetSelectedAgentSkin
// 0x0008 (0x0008 - 0x0000)
struct DISessionSelections_SetSelectedAgentSkin final
{
public:
	class UAgentSkinData*                         AgentSkinData;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_SetSelectedAgentSkin) == 0x000008, "Wrong alignment on DISessionSelections_SetSelectedAgentSkin");
static_assert(sizeof(DISessionSelections_SetSelectedAgentSkin) == 0x000008, "Wrong size on DISessionSelections_SetSelectedAgentSkin");
static_assert(offsetof(DISessionSelections_SetSelectedAgentSkin, AgentSkinData) == 0x000000, "Member 'DISessionSelections_SetSelectedAgentSkin::AgentSkinData' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.SetSelectedAvatar
// 0x0010 (0x0010 - 0x0000)
struct DISessionSelections_SetSelectedAvatar final
{
public:
	struct FPrimaryAssetId                        AvatarId;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_SetSelectedAvatar) == 0x000004, "Wrong alignment on DISessionSelections_SetSelectedAvatar");
static_assert(sizeof(DISessionSelections_SetSelectedAvatar) == 0x000010, "Wrong size on DISessionSelections_SetSelectedAvatar");
static_assert(offsetof(DISessionSelections_SetSelectedAvatar, AvatarId) == 0x000000, "Member 'DISessionSelections_SetSelectedAvatar::AvatarId' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.SetSelectedExpertiseSkillOnSelectedAgent
// 0x0010 (0x0010 - 0x0000)
struct DISessionSelections_SetSelectedExpertiseSkillOnSelectedAgent final
{
public:
	struct FPrimaryAssetId                        ExpertiseSkillId;                                  // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_SetSelectedExpertiseSkillOnSelectedAgent) == 0x000004, "Wrong alignment on DISessionSelections_SetSelectedExpertiseSkillOnSelectedAgent");
static_assert(sizeof(DISessionSelections_SetSelectedExpertiseSkillOnSelectedAgent) == 0x000010, "Wrong size on DISessionSelections_SetSelectedExpertiseSkillOnSelectedAgent");
static_assert(offsetof(DISessionSelections_SetSelectedExpertiseSkillOnSelectedAgent, ExpertiseSkillId) == 0x000000, "Member 'DISessionSelections_SetSelectedExpertiseSkillOnSelectedAgent::ExpertiseSkillId' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.SetSelectedGadgetOnSelectedAgent
// 0x0014 (0x0014 - 0x0000)
struct DISessionSelections_SetSelectedGadgetOnSelectedAgent final
{
public:
	struct FPrimaryAssetId                        GadgetId;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GadgetIndex;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_SetSelectedGadgetOnSelectedAgent) == 0x000004, "Wrong alignment on DISessionSelections_SetSelectedGadgetOnSelectedAgent");
static_assert(sizeof(DISessionSelections_SetSelectedGadgetOnSelectedAgent) == 0x000014, "Wrong size on DISessionSelections_SetSelectedGadgetOnSelectedAgent");
static_assert(offsetof(DISessionSelections_SetSelectedGadgetOnSelectedAgent, GadgetId) == 0x000000, "Member 'DISessionSelections_SetSelectedGadgetOnSelectedAgent::GadgetId' has a wrong offset!");
static_assert(offsetof(DISessionSelections_SetSelectedGadgetOnSelectedAgent, GadgetIndex) == 0x000010, "Member 'DISessionSelections_SetSelectedGadgetOnSelectedAgent::GadgetIndex' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.SetSelectedPassiveSkillOnSelectedAgent
// 0x0010 (0x0010 - 0x0000)
struct DISessionSelections_SetSelectedPassiveSkillOnSelectedAgent final
{
public:
	struct FPrimaryAssetId                        PassiveSkillId;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_SetSelectedPassiveSkillOnSelectedAgent) == 0x000004, "Wrong alignment on DISessionSelections_SetSelectedPassiveSkillOnSelectedAgent");
static_assert(sizeof(DISessionSelections_SetSelectedPassiveSkillOnSelectedAgent) == 0x000010, "Wrong size on DISessionSelections_SetSelectedPassiveSkillOnSelectedAgent");
static_assert(offsetof(DISessionSelections_SetSelectedPassiveSkillOnSelectedAgent, PassiveSkillId) == 0x000000, "Member 'DISessionSelections_SetSelectedPassiveSkillOnSelectedAgent::PassiveSkillId' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.SetSelectedTitle
// 0x0010 (0x0010 - 0x0000)
struct DISessionSelections_SetSelectedTitle final
{
public:
	struct FPrimaryAssetId                        TitleId;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_SetSelectedTitle) == 0x000004, "Wrong alignment on DISessionSelections_SetSelectedTitle");
static_assert(sizeof(DISessionSelections_SetSelectedTitle) == 0x000010, "Wrong size on DISessionSelections_SetSelectedTitle");
static_assert(offsetof(DISessionSelections_SetSelectedTitle, TitleId) == 0x000000, "Member 'DISessionSelections_SetSelectedTitle::TitleId' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.SetSelectedWeaponOnSelectedAgent
// 0x0010 (0x0010 - 0x0000)
struct DISessionSelections_SetSelectedWeaponOnSelectedAgent final
{
public:
	struct FPrimaryAssetId                        WeaponId;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_SetSelectedWeaponOnSelectedAgent) == 0x000004, "Wrong alignment on DISessionSelections_SetSelectedWeaponOnSelectedAgent");
static_assert(sizeof(DISessionSelections_SetSelectedWeaponOnSelectedAgent) == 0x000010, "Wrong size on DISessionSelections_SetSelectedWeaponOnSelectedAgent");
static_assert(offsetof(DISessionSelections_SetSelectedWeaponOnSelectedAgent, WeaponId) == 0x000000, "Member 'DISessionSelections_SetSelectedWeaponOnSelectedAgent::WeaponId' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.SetSelectedWrapOnTool
// 0x0018 (0x0018 - 0x0000)
struct DISessionSelections_SetSelectedWrapOnTool final
{
public:
	class UMenuWrapData*                          WrapId;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ToolAssetId;                                       // 0x0008(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_SetSelectedWrapOnTool) == 0x000008, "Wrong alignment on DISessionSelections_SetSelectedWrapOnTool");
static_assert(sizeof(DISessionSelections_SetSelectedWrapOnTool) == 0x000018, "Wrong size on DISessionSelections_SetSelectedWrapOnTool");
static_assert(offsetof(DISessionSelections_SetSelectedWrapOnTool, WrapId) == 0x000000, "Member 'DISessionSelections_SetSelectedWrapOnTool::WrapId' has a wrong offset!");
static_assert(offsetof(DISessionSelections_SetSelectedWrapOnTool, ToolAssetId) == 0x000008, "Member 'DISessionSelections_SetSelectedWrapOnTool::ToolAssetId' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.GetAccessoriesInfos
// 0x0008 (0x0008 - 0x0000)
struct DISessionSelections_GetAccessoriesInfos final
{
public:
	class USessionAccessoriesSelectionInfo*       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_GetAccessoriesInfos) == 0x000008, "Wrong alignment on DISessionSelections_GetAccessoriesInfos");
static_assert(sizeof(DISessionSelections_GetAccessoriesInfos) == 0x000008, "Wrong size on DISessionSelections_GetAccessoriesInfos");
static_assert(offsetof(DISessionSelections_GetAccessoriesInfos, ReturnValue) == 0x000000, "Member 'DISessionSelections_GetAccessoriesInfos::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.GetAgentSelectionInfosByAgentId
// 0x0018 (0x0018 - 0x0000)
struct DISessionSelections_GetAgentSelectionInfosByAgentId final
{
public:
	struct FPrimaryAssetId                        AgentId;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USessionAgentSelectionInfo*             ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_GetAgentSelectionInfosByAgentId) == 0x000008, "Wrong alignment on DISessionSelections_GetAgentSelectionInfosByAgentId");
static_assert(sizeof(DISessionSelections_GetAgentSelectionInfosByAgentId) == 0x000018, "Wrong size on DISessionSelections_GetAgentSelectionInfosByAgentId");
static_assert(offsetof(DISessionSelections_GetAgentSelectionInfosByAgentId, AgentId) == 0x000000, "Member 'DISessionSelections_GetAgentSelectionInfosByAgentId::AgentId' has a wrong offset!");
static_assert(offsetof(DISessionSelections_GetAgentSelectionInfosByAgentId, ReturnValue) == 0x000010, "Member 'DISessionSelections_GetAgentSelectionInfosByAgentId::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.GetEquippedDeck
// 0x0010 (0x0010 - 0x0000)
struct DISessionSelections_GetEquippedDeck final
{
public:
	struct FDISerializedDeckEntry                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_GetEquippedDeck) == 0x000008, "Wrong alignment on DISessionSelections_GetEquippedDeck");
static_assert(sizeof(DISessionSelections_GetEquippedDeck) == 0x000010, "Wrong size on DISessionSelections_GetEquippedDeck");
static_assert(offsetof(DISessionSelections_GetEquippedDeck, ReturnValue) == 0x000000, "Member 'DISessionSelections_GetEquippedDeck::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.GetEquippedDeckIndex
// 0x0004 (0x0004 - 0x0000)
struct DISessionSelections_GetEquippedDeckIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_GetEquippedDeckIndex) == 0x000004, "Wrong alignment on DISessionSelections_GetEquippedDeckIndex");
static_assert(sizeof(DISessionSelections_GetEquippedDeckIndex) == 0x000004, "Wrong size on DISessionSelections_GetEquippedDeckIndex");
static_assert(offsetof(DISessionSelections_GetEquippedDeckIndex, ReturnValue) == 0x000000, "Member 'DISessionSelections_GetEquippedDeckIndex::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionSelections.GetSelectedAgentSelectionInfos
// 0x0008 (0x0008 - 0x0000)
struct DISessionSelections_GetSelectedAgentSelectionInfos final
{
public:
	class USessionAgentSelectionInfo*             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionSelections_GetSelectedAgentSelectionInfos) == 0x000008, "Wrong alignment on DISessionSelections_GetSelectedAgentSelectionInfos");
static_assert(sizeof(DISessionSelections_GetSelectedAgentSelectionInfos) == 0x000008, "Wrong size on DISessionSelections_GetSelectedAgentSelectionInfos");
static_assert(offsetof(DISessionSelections_GetSelectedAgentSelectionInfos, ReturnValue) == 0x000000, "Member 'DISessionSelections_GetSelectedAgentSelectionInfos::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VictimEffect.BP_InitializeDamageModifier
// 0x0008 (0x0008 - 0x0000)
struct VictimEffect_BP_InitializeDamageModifier final
{
public:
	class UDamageModifier*                        DamageModifier;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_BP_InitializeDamageModifier) == 0x000008, "Wrong alignment on VictimEffect_BP_InitializeDamageModifier");
static_assert(sizeof(VictimEffect_BP_InitializeDamageModifier) == 0x000008, "Wrong size on VictimEffect_BP_InitializeDamageModifier");
static_assert(offsetof(VictimEffect_BP_InitializeDamageModifier, DamageModifier) == 0x000000, "Member 'VictimEffect_BP_InitializeDamageModifier::DamageModifier' has a wrong offset!");

// Function DeceiveInc.VictimEffect.BP_InitializeTickEffect
// 0x0008 (0x0008 - 0x0000)
struct VictimEffect_BP_InitializeTickEffect final
{
public:
	class UVictimEffectTickBehavior*              TickEffect;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_BP_InitializeTickEffect) == 0x000008, "Wrong alignment on VictimEffect_BP_InitializeTickEffect");
static_assert(sizeof(VictimEffect_BP_InitializeTickEffect) == 0x000008, "Wrong size on VictimEffect_BP_InitializeTickEffect");
static_assert(offsetof(VictimEffect_BP_InitializeTickEffect, TickEffect) == 0x000000, "Member 'VictimEffect_BP_InitializeTickEffect::TickEffect' has a wrong offset!");

// Function DeceiveInc.VictimEffect.BP_OnEffectEnd
// 0x0010 (0x0010 - 0x0000)
struct VictimEffect_BP_OnEffectEnd final
{
public:
	class AVictimEffect*                          Effect;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_BP_OnEffectEnd) == 0x000008, "Wrong alignment on VictimEffect_BP_OnEffectEnd");
static_assert(sizeof(VictimEffect_BP_OnEffectEnd) == 0x000010, "Wrong size on VictimEffect_BP_OnEffectEnd");
static_assert(offsetof(VictimEffect_BP_OnEffectEnd, Effect) == 0x000000, "Member 'VictimEffect_BP_OnEffectEnd::Effect' has a wrong offset!");
static_assert(offsetof(VictimEffect_BP_OnEffectEnd, Victim) == 0x000008, "Member 'VictimEffect_BP_OnEffectEnd::Victim' has a wrong offset!");

// Function DeceiveInc.VictimEffect.BP_OnEffectFadeOutEnd
// 0x0008 (0x0008 - 0x0000)
struct VictimEffect_BP_OnEffectFadeOutEnd final
{
public:
	class AVictimEffect*                          Effect;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_BP_OnEffectFadeOutEnd) == 0x000008, "Wrong alignment on VictimEffect_BP_OnEffectFadeOutEnd");
static_assert(sizeof(VictimEffect_BP_OnEffectFadeOutEnd) == 0x000008, "Wrong size on VictimEffect_BP_OnEffectFadeOutEnd");
static_assert(offsetof(VictimEffect_BP_OnEffectFadeOutEnd, Effect) == 0x000000, "Member 'VictimEffect_BP_OnEffectFadeOutEnd::Effect' has a wrong offset!");

// Function DeceiveInc.VictimEffect.BP_OnEffectFadeOutStart
// 0x0008 (0x0008 - 0x0000)
struct VictimEffect_BP_OnEffectFadeOutStart final
{
public:
	class AVictimEffect*                          Effect;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_BP_OnEffectFadeOutStart) == 0x000008, "Wrong alignment on VictimEffect_BP_OnEffectFadeOutStart");
static_assert(sizeof(VictimEffect_BP_OnEffectFadeOutStart) == 0x000008, "Wrong size on VictimEffect_BP_OnEffectFadeOutStart");
static_assert(offsetof(VictimEffect_BP_OnEffectFadeOutStart, Effect) == 0x000000, "Member 'VictimEffect_BP_OnEffectFadeOutStart::Effect' has a wrong offset!");

// Function DeceiveInc.VictimEffect.BP_OnEffectStart
// 0x0010 (0x0010 - 0x0000)
struct VictimEffect_BP_OnEffectStart final
{
public:
	class AVictimEffect*                          Effect;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_BP_OnEffectStart) == 0x000008, "Wrong alignment on VictimEffect_BP_OnEffectStart");
static_assert(sizeof(VictimEffect_BP_OnEffectStart) == 0x000010, "Wrong size on VictimEffect_BP_OnEffectStart");
static_assert(offsetof(VictimEffect_BP_OnEffectStart, Effect) == 0x000000, "Member 'VictimEffect_BP_OnEffectStart::Effect' has a wrong offset!");
static_assert(offsetof(VictimEffect_BP_OnEffectStart, Victim) == 0x000008, "Member 'VictimEffect_BP_OnEffectStart::Victim' has a wrong offset!");

// Function DeceiveInc.VictimEffect.BP_OnEffectTick
// 0x0010 (0x0010 - 0x0000)
struct VictimEffect_BP_OnEffectTick final
{
public:
	class AVictimEffect*                          Effect;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_BP_OnEffectTick) == 0x000008, "Wrong alignment on VictimEffect_BP_OnEffectTick");
static_assert(sizeof(VictimEffect_BP_OnEffectTick) == 0x000010, "Wrong size on VictimEffect_BP_OnEffectTick");
static_assert(offsetof(VictimEffect_BP_OnEffectTick, Effect) == 0x000000, "Member 'VictimEffect_BP_OnEffectTick::Effect' has a wrong offset!");
static_assert(offsetof(VictimEffect_BP_OnEffectTick, Victim) == 0x000008, "Member 'VictimEffect_BP_OnEffectTick::Victim' has a wrong offset!");

// Function DeceiveInc.VictimEffect.BP_OnEffectTriggered
// 0x0010 (0x0010 - 0x0000)
struct VictimEffect_BP_OnEffectTriggered final
{
public:
	class AVictimEffect*                          Effect;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_BP_OnEffectTriggered) == 0x000008, "Wrong alignment on VictimEffect_BP_OnEffectTriggered");
static_assert(sizeof(VictimEffect_BP_OnEffectTriggered) == 0x000010, "Wrong size on VictimEffect_BP_OnEffectTriggered");
static_assert(offsetof(VictimEffect_BP_OnEffectTriggered, Effect) == 0x000000, "Member 'VictimEffect_BP_OnEffectTriggered::Effect' has a wrong offset!");
static_assert(offsetof(VictimEffect_BP_OnEffectTriggered, Victim) == 0x000008, "Member 'VictimEffect_BP_OnEffectTriggered::Victim' has a wrong offset!");

// Function DeceiveInc.VictimEffect.BP_OnNewEffectInstigator
// 0x0008 (0x0008 - 0x0000)
struct VictimEffect_BP_OnNewEffectInstigator final
{
public:
	class AActor*                                 NewEffectInstigator;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_BP_OnNewEffectInstigator) == 0x000008, "Wrong alignment on VictimEffect_BP_OnNewEffectInstigator");
static_assert(sizeof(VictimEffect_BP_OnNewEffectInstigator) == 0x000008, "Wrong size on VictimEffect_BP_OnNewEffectInstigator");
static_assert(offsetof(VictimEffect_BP_OnNewEffectInstigator, NewEffectInstigator) == 0x000000, "Member 'VictimEffect_BP_OnNewEffectInstigator::NewEffectInstigator' has a wrong offset!");

// Function DeceiveInc.VictimEffect.BP_OnVictimChanged
// 0x0008 (0x0008 - 0x0000)
struct VictimEffect_BP_OnVictimChanged final
{
public:
	class AActor*                                 NewVictim;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_BP_OnVictimChanged) == 0x000008, "Wrong alignment on VictimEffect_BP_OnVictimChanged");
static_assert(sizeof(VictimEffect_BP_OnVictimChanged) == 0x000008, "Wrong size on VictimEffect_BP_OnVictimChanged");
static_assert(offsetof(VictimEffect_BP_OnVictimChanged, NewVictim) == 0x000000, "Member 'VictimEffect_BP_OnVictimChanged::NewVictim' has a wrong offset!");

// Function DeceiveInc.VictimEffect.BP_OnWidgetReady
// 0x0008 (0x0008 - 0x0000)
struct VictimEffect_BP_OnWidgetReady final
{
public:
	class UVictimEffectUserWidget*                NewWidget;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_BP_OnWidgetReady) == 0x000008, "Wrong alignment on VictimEffect_BP_OnWidgetReady");
static_assert(sizeof(VictimEffect_BP_OnWidgetReady) == 0x000008, "Wrong size on VictimEffect_BP_OnWidgetReady");
static_assert(offsetof(VictimEffect_BP_OnWidgetReady, NewWidget) == 0x000000, "Member 'VictimEffect_BP_OnWidgetReady::NewWidget' has a wrong offset!");

// Function DeceiveInc.VictimEffect.CanBeCleansed
// 0x0001 (0x0001 - 0x0000)
struct VictimEffect_CanBeCleansed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_CanBeCleansed) == 0x000001, "Wrong alignment on VictimEffect_CanBeCleansed");
static_assert(sizeof(VictimEffect_CanBeCleansed) == 0x000001, "Wrong size on VictimEffect_CanBeCleansed");
static_assert(offsetof(VictimEffect_CanBeCleansed, ReturnValue) == 0x000000, "Member 'VictimEffect_CanBeCleansed::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VictimEffect.GetEffectInstigator
// 0x0008 (0x0008 - 0x0000)
struct VictimEffect_GetEffectInstigator final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_GetEffectInstigator) == 0x000008, "Wrong alignment on VictimEffect_GetEffectInstigator");
static_assert(sizeof(VictimEffect_GetEffectInstigator) == 0x000008, "Wrong size on VictimEffect_GetEffectInstigator");
static_assert(offsetof(VictimEffect_GetEffectInstigator, ReturnValue) == 0x000000, "Member 'VictimEffect_GetEffectInstigator::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VictimEffect.GetEffectTickLeftPercentage
// 0x0004 (0x0004 - 0x0000)
struct VictimEffect_GetEffectTickLeftPercentage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_GetEffectTickLeftPercentage) == 0x000004, "Wrong alignment on VictimEffect_GetEffectTickLeftPercentage");
static_assert(sizeof(VictimEffect_GetEffectTickLeftPercentage) == 0x000004, "Wrong size on VictimEffect_GetEffectTickLeftPercentage");
static_assert(offsetof(VictimEffect_GetEffectTickLeftPercentage, ReturnValue) == 0x000000, "Member 'VictimEffect_GetEffectTickLeftPercentage::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VictimEffect.GetEffectTimeLeftPercentage
// 0x0004 (0x0004 - 0x0000)
struct VictimEffect_GetEffectTimeLeftPercentage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_GetEffectTimeLeftPercentage) == 0x000004, "Wrong alignment on VictimEffect_GetEffectTimeLeftPercentage");
static_assert(sizeof(VictimEffect_GetEffectTimeLeftPercentage) == 0x000004, "Wrong size on VictimEffect_GetEffectTimeLeftPercentage");
static_assert(offsetof(VictimEffect_GetEffectTimeLeftPercentage, ReturnValue) == 0x000000, "Member 'VictimEffect_GetEffectTimeLeftPercentage::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VictimEffect.GetLifetime
// 0x0004 (0x0004 - 0x0000)
struct VictimEffect_GetLifetime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_GetLifetime) == 0x000004, "Wrong alignment on VictimEffect_GetLifetime");
static_assert(sizeof(VictimEffect_GetLifetime) == 0x000004, "Wrong size on VictimEffect_GetLifetime");
static_assert(offsetof(VictimEffect_GetLifetime, ReturnValue) == 0x000000, "Member 'VictimEffect_GetLifetime::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VictimEffect.GetVariantData
// 0x0018 (0x0018 - 0x0000)
struct VictimEffect_GetVariantData final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VictimEffect_GetVariantData) == 0x000008, "Wrong alignment on VictimEffect_GetVariantData");
static_assert(sizeof(VictimEffect_GetVariantData) == 0x000018, "Wrong size on VictimEffect_GetVariantData");
static_assert(offsetof(VictimEffect_GetVariantData, ID) == 0x000000, "Member 'VictimEffect_GetVariantData::ID' has a wrong offset!");
static_assert(offsetof(VictimEffect_GetVariantData, ReturnValue) == 0x000010, "Member 'VictimEffect_GetVariantData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VictimEffect.HandleVictimCoverChange
// 0x0001 (0x0001 - 0x0000)
struct VictimEffect_HandleVictimCoverChange final
{
public:
	bool                                          CoverState;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_HandleVictimCoverChange) == 0x000001, "Wrong alignment on VictimEffect_HandleVictimCoverChange");
static_assert(sizeof(VictimEffect_HandleVictimCoverChange) == 0x000001, "Wrong size on VictimEffect_HandleVictimCoverChange");
static_assert(offsetof(VictimEffect_HandleVictimCoverChange, CoverState) == 0x000000, "Member 'VictimEffect_HandleVictimCoverChange::CoverState' has a wrong offset!");

// Function DeceiveInc.VictimEffect.HandleVictimCoverSwitch
// 0x0008 (0x0008 - 0x0000)
struct VictimEffect_HandleVictimCoverSwitch final
{
public:
	class ANPCCharacter*                          NewCover;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_HandleVictimCoverSwitch) == 0x000008, "Wrong alignment on VictimEffect_HandleVictimCoverSwitch");
static_assert(sizeof(VictimEffect_HandleVictimCoverSwitch) == 0x000008, "Wrong size on VictimEffect_HandleVictimCoverSwitch");
static_assert(offsetof(VictimEffect_HandleVictimCoverSwitch, NewCover) == 0x000000, "Member 'VictimEffect_HandleVictimCoverSwitch::NewCover' has a wrong offset!");

// Function DeceiveInc.VictimEffect.IsPositiveEffect
// 0x0001 (0x0001 - 0x0000)
struct VictimEffect_IsPositiveEffect final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_IsPositiveEffect) == 0x000001, "Wrong alignment on VictimEffect_IsPositiveEffect");
static_assert(sizeof(VictimEffect_IsPositiveEffect) == 0x000001, "Wrong size on VictimEffect_IsPositiveEffect");
static_assert(offsetof(VictimEffect_IsPositiveEffect, ReturnValue) == 0x000000, "Member 'VictimEffect_IsPositiveEffect::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VictimEffect.OnRep_EffectInfo
// 0x0020 (0x0020 - 0x0000)
struct VictimEffect_OnRep_EffectInfo final
{
public:
	struct FEffectInfo                            OldEffectInfo;                                     // 0x0000(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_OnRep_EffectInfo) == 0x000008, "Wrong alignment on VictimEffect_OnRep_EffectInfo");
static_assert(sizeof(VictimEffect_OnRep_EffectInfo) == 0x000020, "Wrong size on VictimEffect_OnRep_EffectInfo");
static_assert(offsetof(VictimEffect_OnRep_EffectInfo, OldEffectInfo) == 0x000000, "Member 'VictimEffect_OnRep_EffectInfo::OldEffectInfo' has a wrong offset!");

// Function DeceiveInc.VictimEffect.PauseTickEffect
// 0x0001 (0x0001 - 0x0000)
struct VictimEffect_PauseTickEffect final
{
public:
	bool                                          bPause;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_PauseTickEffect) == 0x000001, "Wrong alignment on VictimEffect_PauseTickEffect");
static_assert(sizeof(VictimEffect_PauseTickEffect) == 0x000001, "Wrong size on VictimEffect_PauseTickEffect");
static_assert(offsetof(VictimEffect_PauseTickEffect, bPause) == 0x000000, "Member 'VictimEffect_PauseTickEffect::bPause' has a wrong offset!");

// Function DeceiveInc.VictimEffect.SetEffectDuration
// 0x0004 (0x0004 - 0x0000)
struct VictimEffect_SetEffectDuration final
{
public:
	float                                         NewEffectDuration;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_SetEffectDuration) == 0x000004, "Wrong alignment on VictimEffect_SetEffectDuration");
static_assert(sizeof(VictimEffect_SetEffectDuration) == 0x000004, "Wrong size on VictimEffect_SetEffectDuration");
static_assert(offsetof(VictimEffect_SetEffectDuration, NewEffectDuration) == 0x000000, "Member 'VictimEffect_SetEffectDuration::NewEffectDuration' has a wrong offset!");

// Function DeceiveInc.VictimEffect.SetEffectPositioningType
// 0x0001 (0x0001 - 0x0000)
struct VictimEffect_SetEffectPositioningType final
{
public:
	EVictimEffectPositioningType                  PositioningType;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_SetEffectPositioningType) == 0x000001, "Wrong alignment on VictimEffect_SetEffectPositioningType");
static_assert(sizeof(VictimEffect_SetEffectPositioningType) == 0x000001, "Wrong size on VictimEffect_SetEffectPositioningType");
static_assert(offsetof(VictimEffect_SetEffectPositioningType, PositioningType) == 0x000000, "Member 'VictimEffect_SetEffectPositioningType::PositioningType' has a wrong offset!");

// Function DeceiveInc.VictimEffect.SetEffectPositioningTypeWithSocket
// 0x000C (0x000C - 0x0000)
struct VictimEffect_SetEffectPositioningTypeWithSocket final
{
public:
	EVictimEffectPositioningType                  PositioningType;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_SetEffectPositioningTypeWithSocket) == 0x000004, "Wrong alignment on VictimEffect_SetEffectPositioningTypeWithSocket");
static_assert(sizeof(VictimEffect_SetEffectPositioningTypeWithSocket) == 0x00000C, "Wrong size on VictimEffect_SetEffectPositioningTypeWithSocket");
static_assert(offsetof(VictimEffect_SetEffectPositioningTypeWithSocket, PositioningType) == 0x000000, "Member 'VictimEffect_SetEffectPositioningTypeWithSocket::PositioningType' has a wrong offset!");
static_assert(offsetof(VictimEffect_SetEffectPositioningTypeWithSocket, SocketName) == 0x000004, "Member 'VictimEffect_SetEffectPositioningTypeWithSocket::SocketName' has a wrong offset!");

// Function DeceiveInc.VictimEffect.SetInstigator
// 0x0008 (0x0008 - 0x0000)
struct VictimEffect_SetInstigator final
{
public:
	class AActor*                                 CausingActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_SetInstigator) == 0x000008, "Wrong alignment on VictimEffect_SetInstigator");
static_assert(sizeof(VictimEffect_SetInstigator) == 0x000008, "Wrong size on VictimEffect_SetInstigator");
static_assert(offsetof(VictimEffect_SetInstigator, CausingActor) == 0x000000, "Member 'VictimEffect_SetInstigator::CausingActor' has a wrong offset!");

// Function DeceiveInc.VictimEffect.SetTickEffectEnabled
// 0x0001 (0x0001 - 0x0000)
struct VictimEffect_SetTickEffectEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_SetTickEffectEnabled) == 0x000001, "Wrong alignment on VictimEffect_SetTickEffectEnabled");
static_assert(sizeof(VictimEffect_SetTickEffectEnabled) == 0x000001, "Wrong size on VictimEffect_SetTickEffectEnabled");
static_assert(offsetof(VictimEffect_SetTickEffectEnabled, bEnabled) == 0x000000, "Member 'VictimEffect_SetTickEffectEnabled::bEnabled' has a wrong offset!");

// Function DeceiveInc.VictimEffect.SetupEffect
// 0x0018 (0x0018 - 0x0000)
struct VictimEffect_SetupEffect final
{
public:
	class AActor*                                 NewVictim;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 NewInstigator;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartEffect;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NewDuration;                                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_SetupEffect) == 0x000008, "Wrong alignment on VictimEffect_SetupEffect");
static_assert(sizeof(VictimEffect_SetupEffect) == 0x000018, "Wrong size on VictimEffect_SetupEffect");
static_assert(offsetof(VictimEffect_SetupEffect, NewVictim) == 0x000000, "Member 'VictimEffect_SetupEffect::NewVictim' has a wrong offset!");
static_assert(offsetof(VictimEffect_SetupEffect, NewInstigator) == 0x000008, "Member 'VictimEffect_SetupEffect::NewInstigator' has a wrong offset!");
static_assert(offsetof(VictimEffect_SetupEffect, bStartEffect) == 0x000010, "Member 'VictimEffect_SetupEffect::bStartEffect' has a wrong offset!");
static_assert(offsetof(VictimEffect_SetupEffect, NewDuration) == 0x000014, "Member 'VictimEffect_SetupEffect::NewDuration' has a wrong offset!");

// Function DeceiveInc.VictimEffect.SetVariantData
// 0x0018 (0x0018 - 0x0000)
struct VictimEffect_SetVariantData final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VictimEffect_SetVariantData) == 0x000008, "Wrong alignment on VictimEffect_SetVariantData");
static_assert(sizeof(VictimEffect_SetVariantData) == 0x000018, "Wrong size on VictimEffect_SetVariantData");
static_assert(offsetof(VictimEffect_SetVariantData, ID) == 0x000000, "Member 'VictimEffect_SetVariantData::ID' has a wrong offset!");
static_assert(offsetof(VictimEffect_SetVariantData, Value) == 0x000010, "Member 'VictimEffect_SetVariantData::Value' has a wrong offset!");

// Function DeceiveInc.VictimEffect.SetVictim
// 0x0008 (0x0008 - 0x0000)
struct VictimEffect_SetVictim final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_SetVictim) == 0x000008, "Wrong alignment on VictimEffect_SetVictim");
static_assert(sizeof(VictimEffect_SetVictim) == 0x000008, "Wrong size on VictimEffect_SetVictim");
static_assert(offsetof(VictimEffect_SetVictim, Victim) == 0x000000, "Member 'VictimEffect_SetVictim::Victim' has a wrong offset!");

// Function DeceiveInc.VictimEffect.GetEffectTimeLeft
// 0x0004 (0x0004 - 0x0000)
struct VictimEffect_GetEffectTimeLeft final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_GetEffectTimeLeft) == 0x000004, "Wrong alignment on VictimEffect_GetEffectTimeLeft");
static_assert(sizeof(VictimEffect_GetEffectTimeLeft) == 0x000004, "Wrong size on VictimEffect_GetEffectTimeLeft");
static_assert(offsetof(VictimEffect_GetEffectTimeLeft, ReturnValue) == 0x000000, "Member 'VictimEffect_GetEffectTimeLeft::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VictimEffect.IsActive
// 0x0001 (0x0001 - 0x0000)
struct VictimEffect_IsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_IsActive) == 0x000001, "Wrong alignment on VictimEffect_IsActive");
static_assert(sizeof(VictimEffect_IsActive) == 0x000001, "Wrong size on VictimEffect_IsActive");
static_assert(offsetof(VictimEffect_IsActive, ReturnValue) == 0x000000, "Member 'VictimEffect_IsActive::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VictimEffect.IsSameFactionFromInstigator
// 0x0001 (0x0001 - 0x0000)
struct VictimEffect_IsSameFactionFromInstigator final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_IsSameFactionFromInstigator) == 0x000001, "Wrong alignment on VictimEffect_IsSameFactionFromInstigator");
static_assert(sizeof(VictimEffect_IsSameFactionFromInstigator) == 0x000001, "Wrong size on VictimEffect_IsSameFactionFromInstigator");
static_assert(offsetof(VictimEffect_IsSameFactionFromInstigator, ReturnValue) == 0x000000, "Member 'VictimEffect_IsSameFactionFromInstigator::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VictimEffect.IsSameFactionFromInstigatorPawn
// 0x0010 (0x0010 - 0x0000)
struct VictimEffect_IsSameFactionFromInstigatorPawn final
{
public:
	class APawn*                                  PawnToCheck;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VictimEffect_IsSameFactionFromInstigatorPawn) == 0x000008, "Wrong alignment on VictimEffect_IsSameFactionFromInstigatorPawn");
static_assert(sizeof(VictimEffect_IsSameFactionFromInstigatorPawn) == 0x000010, "Wrong size on VictimEffect_IsSameFactionFromInstigatorPawn");
static_assert(offsetof(VictimEffect_IsSameFactionFromInstigatorPawn, PawnToCheck) == 0x000000, "Member 'VictimEffect_IsSameFactionFromInstigatorPawn::PawnToCheck' has a wrong offset!");
static_assert(offsetof(VictimEffect_IsSameFactionFromInstigatorPawn, ReturnValue) == 0x000008, "Member 'VictimEffect_IsSameFactionFromInstigatorPawn::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VictimEffect.ShouldShowFollowEffectHud
// 0x0001 (0x0001 - 0x0000)
struct VictimEffect_ShouldShowFollowEffectHud final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffect_ShouldShowFollowEffectHud) == 0x000001, "Wrong alignment on VictimEffect_ShouldShowFollowEffectHud");
static_assert(sizeof(VictimEffect_ShouldShowFollowEffectHud) == 0x000001, "Wrong size on VictimEffect_ShouldShowFollowEffectHud");
static_assert(offsetof(VictimEffect_ShouldShowFollowEffectHud, ReturnValue) == 0x000000, "Member 'VictimEffect_ShouldShowFollowEffectHud::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ObjectiveCarrierVictimEffect.GetPingRatio
// 0x0004 (0x0004 - 0x0000)
struct ObjectiveCarrierVictimEffect_GetPingRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ObjectiveCarrierVictimEffect_GetPingRatio) == 0x000004, "Wrong alignment on ObjectiveCarrierVictimEffect_GetPingRatio");
static_assert(sizeof(ObjectiveCarrierVictimEffect_GetPingRatio) == 0x000004, "Wrong size on ObjectiveCarrierVictimEffect_GetPingRatio");
static_assert(offsetof(ObjectiveCarrierVictimEffect_GetPingRatio, ReturnValue) == 0x000000, "Member 'ObjectiveCarrierVictimEffect_GetPingRatio::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ObjectiveCarrierVictimEffect.IsInCooldown
// 0x0001 (0x0001 - 0x0000)
struct ObjectiveCarrierVictimEffect_IsInCooldown final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ObjectiveCarrierVictimEffect_IsInCooldown) == 0x000001, "Wrong alignment on ObjectiveCarrierVictimEffect_IsInCooldown");
static_assert(sizeof(ObjectiveCarrierVictimEffect_IsInCooldown) == 0x000001, "Wrong size on ObjectiveCarrierVictimEffect_IsInCooldown");
static_assert(offsetof(ObjectiveCarrierVictimEffect_IsInCooldown, ReturnValue) == 0x000000, "Member 'ObjectiveCarrierVictimEffect_IsInCooldown::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionStats.ClassPlayTime
// 0x0010 (0x0010 - 0x0000)
struct DISessionStats_ClassPlayTime final
{
public:
	TArray<struct FClassPlayTimeDefinition>       ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionStats_ClassPlayTime) == 0x000008, "Wrong alignment on DISessionStats_ClassPlayTime");
static_assert(sizeof(DISessionStats_ClassPlayTime) == 0x000010, "Wrong size on DISessionStats_ClassPlayTime");
static_assert(offsetof(DISessionStats_ClassPlayTime, ReturnValue) == 0x000000, "Member 'DISessionStats_ClassPlayTime::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionStats.DeathsSolo
// 0x0004 (0x0004 - 0x0000)
struct DISessionStats_DeathsSolo final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionStats_DeathsSolo) == 0x000004, "Wrong alignment on DISessionStats_DeathsSolo");
static_assert(sizeof(DISessionStats_DeathsSolo) == 0x000004, "Wrong size on DISessionStats_DeathsSolo");
static_assert(offsetof(DISessionStats_DeathsSolo, ReturnValue) == 0x000000, "Member 'DISessionStats_DeathsSolo::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionStats.DeathsTeam
// 0x0004 (0x0004 - 0x0000)
struct DISessionStats_DeathsTeam final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionStats_DeathsTeam) == 0x000004, "Wrong alignment on DISessionStats_DeathsTeam");
static_assert(sizeof(DISessionStats_DeathsTeam) == 0x000004, "Wrong size on DISessionStats_DeathsTeam");
static_assert(offsetof(DISessionStats_DeathsTeam, ReturnValue) == 0x000000, "Member 'DISessionStats_DeathsTeam::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionStats.KillsSolo
// 0x0004 (0x0004 - 0x0000)
struct DISessionStats_KillsSolo final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionStats_KillsSolo) == 0x000004, "Wrong alignment on DISessionStats_KillsSolo");
static_assert(sizeof(DISessionStats_KillsSolo) == 0x000004, "Wrong size on DISessionStats_KillsSolo");
static_assert(offsetof(DISessionStats_KillsSolo, ReturnValue) == 0x000000, "Member 'DISessionStats_KillsSolo::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionStats.KillsTeam
// 0x0004 (0x0004 - 0x0000)
struct DISessionStats_KillsTeam final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionStats_KillsTeam) == 0x000004, "Wrong alignment on DISessionStats_KillsTeam");
static_assert(sizeof(DISessionStats_KillsTeam) == 0x000004, "Wrong size on DISessionStats_KillsTeam");
static_assert(offsetof(DISessionStats_KillsTeam, ReturnValue) == 0x000000, "Member 'DISessionStats_KillsTeam::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionStats.MatchesPlayedDuo
// 0x0004 (0x0004 - 0x0000)
struct DISessionStats_MatchesPlayedDuo final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionStats_MatchesPlayedDuo) == 0x000004, "Wrong alignment on DISessionStats_MatchesPlayedDuo");
static_assert(sizeof(DISessionStats_MatchesPlayedDuo) == 0x000004, "Wrong size on DISessionStats_MatchesPlayedDuo");
static_assert(offsetof(DISessionStats_MatchesPlayedDuo, ReturnValue) == 0x000000, "Member 'DISessionStats_MatchesPlayedDuo::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionStats.MatchesPlayedSolo
// 0x0004 (0x0004 - 0x0000)
struct DISessionStats_MatchesPlayedSolo final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionStats_MatchesPlayedSolo) == 0x000004, "Wrong alignment on DISessionStats_MatchesPlayedSolo");
static_assert(sizeof(DISessionStats_MatchesPlayedSolo) == 0x000004, "Wrong size on DISessionStats_MatchesPlayedSolo");
static_assert(offsetof(DISessionStats_MatchesPlayedSolo, ReturnValue) == 0x000000, "Member 'DISessionStats_MatchesPlayedSolo::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionStats.MatchesPlayedTeam
// 0x0004 (0x0004 - 0x0000)
struct DISessionStats_MatchesPlayedTeam final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionStats_MatchesPlayedTeam) == 0x000004, "Wrong alignment on DISessionStats_MatchesPlayedTeam");
static_assert(sizeof(DISessionStats_MatchesPlayedTeam) == 0x000004, "Wrong size on DISessionStats_MatchesPlayedTeam");
static_assert(offsetof(DISessionStats_MatchesPlayedTeam, ReturnValue) == 0x000000, "Member 'DISessionStats_MatchesPlayedTeam::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionStats.MatchesWonDuo
// 0x0004 (0x0004 - 0x0000)
struct DISessionStats_MatchesWonDuo final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionStats_MatchesWonDuo) == 0x000004, "Wrong alignment on DISessionStats_MatchesWonDuo");
static_assert(sizeof(DISessionStats_MatchesWonDuo) == 0x000004, "Wrong size on DISessionStats_MatchesWonDuo");
static_assert(offsetof(DISessionStats_MatchesWonDuo, ReturnValue) == 0x000000, "Member 'DISessionStats_MatchesWonDuo::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionStats.MatchesWonSolo
// 0x0004 (0x0004 - 0x0000)
struct DISessionStats_MatchesWonSolo final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionStats_MatchesWonSolo) == 0x000004, "Wrong alignment on DISessionStats_MatchesWonSolo");
static_assert(sizeof(DISessionStats_MatchesWonSolo) == 0x000004, "Wrong size on DISessionStats_MatchesWonSolo");
static_assert(offsetof(DISessionStats_MatchesWonSolo, ReturnValue) == 0x000000, "Member 'DISessionStats_MatchesWonSolo::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionStats.MatchesWonTeam
// 0x0004 (0x0004 - 0x0000)
struct DISessionStats_MatchesWonTeam final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionStats_MatchesWonTeam) == 0x000004, "Wrong alignment on DISessionStats_MatchesWonTeam");
static_assert(sizeof(DISessionStats_MatchesWonTeam) == 0x000004, "Wrong size on DISessionStats_MatchesWonTeam");
static_assert(offsetof(DISessionStats_MatchesWonTeam, ReturnValue) == 0x000000, "Member 'DISessionStats_MatchesWonTeam::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionStats.TopPlayedAgents
// 0x0010 (0x0010 - 0x0000)
struct DISessionStats_TopPlayedAgents final
{
public:
	TArray<struct FAgentPlayTimeDefinition>       ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionStats_TopPlayedAgents) == 0x000008, "Wrong alignment on DISessionStats_TopPlayedAgents");
static_assert(sizeof(DISessionStats_TopPlayedAgents) == 0x000010, "Wrong size on DISessionStats_TopPlayedAgents");
static_assert(offsetof(DISessionStats_TopPlayedAgents, ReturnValue) == 0x000000, "Member 'DISessionStats_TopPlayedAgents::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionStats.TotalGames
// 0x0004 (0x0004 - 0x0000)
struct DISessionStats_TotalGames final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionStats_TotalGames) == 0x000004, "Wrong alignment on DISessionStats_TotalGames");
static_assert(sizeof(DISessionStats_TotalGames) == 0x000004, "Wrong size on DISessionStats_TotalGames");
static_assert(offsetof(DISessionStats_TotalGames, ReturnValue) == 0x000000, "Member 'DISessionStats_TotalGames::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionStats.TotalPlayTime
// 0x0004 (0x0004 - 0x0000)
struct DISessionStats_TotalPlayTime final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionStats_TotalPlayTime) == 0x000004, "Wrong alignment on DISessionStats_TotalPlayTime");
static_assert(sizeof(DISessionStats_TotalPlayTime) == 0x000004, "Wrong size on DISessionStats_TotalPlayTime");
static_assert(offsetof(DISessionStats_TotalPlayTime, ReturnValue) == 0x000000, "Member 'DISessionStats_TotalPlayTime::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISessionStats.VictoryPercentage
// 0x0004 (0x0004 - 0x0000)
struct DISessionStats_VictoryPercentage final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISessionStats_VictoryPercentage) == 0x000004, "Wrong alignment on DISessionStats_VictoryPercentage");
static_assert(sizeof(DISessionStats_VictoryPercentage) == 0x000004, "Wrong size on DISessionStats_VictoryPercentage");
static_assert(offsetof(DISessionStats_VictoryPercentage, ReturnValue) == 0x000000, "Member 'DISessionStats_VictoryPercentage::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DisguiseShieldComponent.HandleCoverChange
// 0x0001 (0x0001 - 0x0000)
struct DisguiseShieldComponent_HandleCoverChange final
{
public:
	bool                                          Undercover;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DisguiseShieldComponent_HandleCoverChange) == 0x000001, "Wrong alignment on DisguiseShieldComponent_HandleCoverChange");
static_assert(sizeof(DisguiseShieldComponent_HandleCoverChange) == 0x000001, "Wrong size on DisguiseShieldComponent_HandleCoverChange");
static_assert(offsetof(DisguiseShieldComponent_HandleCoverChange, Undercover) == 0x000000, "Member 'DisguiseShieldComponent_HandleCoverChange::Undercover' has a wrong offset!");

// Function DeceiveInc.DisguiseShieldComponent.HandleNewDisguise
// 0x0008 (0x0008 - 0x0000)
struct DisguiseShieldComponent_HandleNewDisguise final
{
public:
	class ANPCCharacter*                          Disguise;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DisguiseShieldComponent_HandleNewDisguise) == 0x000008, "Wrong alignment on DisguiseShieldComponent_HandleNewDisguise");
static_assert(sizeof(DisguiseShieldComponent_HandleNewDisguise) == 0x000008, "Wrong size on DisguiseShieldComponent_HandleNewDisguise");
static_assert(offsetof(DisguiseShieldComponent_HandleNewDisguise, Disguise) == 0x000000, "Member 'DisguiseShieldComponent_HandleNewDisguise::Disguise' has a wrong offset!");

// Function DeceiveInc.DisguiseShieldComponent.HandleRemoveDisguise
// 0x0008 (0x0008 - 0x0000)
struct DisguiseShieldComponent_HandleRemoveDisguise final
{
public:
	class ANPCCharacter*                          Disguise;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DisguiseShieldComponent_HandleRemoveDisguise) == 0x000008, "Wrong alignment on DisguiseShieldComponent_HandleRemoveDisguise");
static_assert(sizeof(DisguiseShieldComponent_HandleRemoveDisguise) == 0x000008, "Wrong size on DisguiseShieldComponent_HandleRemoveDisguise");
static_assert(offsetof(DisguiseShieldComponent_HandleRemoveDisguise, Disguise) == 0x000000, "Member 'DisguiseShieldComponent_HandleRemoveDisguise::Disguise' has a wrong offset!");

// Function DeceiveInc.DIOnlineFriendInfo.GetSubsystemName
// 0x0010 (0x0010 - 0x0000)
struct DIOnlineFriendInfo_GetSubsystemName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIOnlineFriendInfo_GetSubsystemName) == 0x000008, "Wrong alignment on DIOnlineFriendInfo_GetSubsystemName");
static_assert(sizeof(DIOnlineFriendInfo_GetSubsystemName) == 0x000010, "Wrong size on DIOnlineFriendInfo_GetSubsystemName");
static_assert(offsetof(DIOnlineFriendInfo_GetSubsystemName, ReturnValue) == 0x000000, "Member 'DIOnlineFriendInfo_GetSubsystemName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIOnlineFriendInfo.GetUserIdString
// 0x0010 (0x0010 - 0x0000)
struct DIOnlineFriendInfo_GetUserIdString final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIOnlineFriendInfo_GetUserIdString) == 0x000008, "Wrong alignment on DIOnlineFriendInfo_GetUserIdString");
static_assert(sizeof(DIOnlineFriendInfo_GetUserIdString) == 0x000010, "Wrong size on DIOnlineFriendInfo_GetUserIdString");
static_assert(offsetof(DIOnlineFriendInfo_GetUserIdString, ReturnValue) == 0x000000, "Member 'DIOnlineFriendInfo_GetUserIdString::ReturnValue' has a wrong offset!");

// Function DeceiveInc.LarcinPassiveMod1Ability.HandleLoadoutSpawnCompleteEvent
// 0x0008 (0x0008 - 0x0000)
struct LarcinPassiveMod1Ability_HandleLoadoutSpawnCompleteEvent final
{
public:
	class UToolLoadoutComponent*                  LoadoutComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LarcinPassiveMod1Ability_HandleLoadoutSpawnCompleteEvent) == 0x000008, "Wrong alignment on LarcinPassiveMod1Ability_HandleLoadoutSpawnCompleteEvent");
static_assert(sizeof(LarcinPassiveMod1Ability_HandleLoadoutSpawnCompleteEvent) == 0x000008, "Wrong size on LarcinPassiveMod1Ability_HandleLoadoutSpawnCompleteEvent");
static_assert(offsetof(LarcinPassiveMod1Ability_HandleLoadoutSpawnCompleteEvent, LoadoutComponent) == 0x000000, "Member 'LarcinPassiveMod1Ability_HandleLoadoutSpawnCompleteEvent::LoadoutComponent' has a wrong offset!");

// Function DeceiveInc.LarcinPassiveMod1Ability.HandleMeleeAttackImpactEvent
// 0x0068 (0x0068 - 0x0000)
struct LarcinPassiveMod1Ability_HandleMeleeAttackImpactEvent final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPoint;                                       // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChargeLevel;                                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultingHealthPercentage;                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitType                                      HitType;                                           // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMeleeHitConfirmedData                 HitConfirmedData;                                  // 0x0028(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LarcinPassiveMod1Ability_HandleMeleeAttackImpactEvent) == 0x000008, "Wrong alignment on LarcinPassiveMod1Ability_HandleMeleeAttackImpactEvent");
static_assert(sizeof(LarcinPassiveMod1Ability_HandleMeleeAttackImpactEvent) == 0x000068, "Wrong size on LarcinPassiveMod1Ability_HandleMeleeAttackImpactEvent");
static_assert(offsetof(LarcinPassiveMod1Ability_HandleMeleeAttackImpactEvent, Victim) == 0x000000, "Member 'LarcinPassiveMod1Ability_HandleMeleeAttackImpactEvent::Victim' has a wrong offset!");
static_assert(offsetof(LarcinPassiveMod1Ability_HandleMeleeAttackImpactEvent, ImpactPoint) == 0x000008, "Member 'LarcinPassiveMod1Ability_HandleMeleeAttackImpactEvent::ImpactPoint' has a wrong offset!");
static_assert(offsetof(LarcinPassiveMod1Ability_HandleMeleeAttackImpactEvent, ChargeLevel) == 0x000014, "Member 'LarcinPassiveMod1Ability_HandleMeleeAttackImpactEvent::ChargeLevel' has a wrong offset!");
static_assert(offsetof(LarcinPassiveMod1Ability_HandleMeleeAttackImpactEvent, Damage) == 0x000018, "Member 'LarcinPassiveMod1Ability_HandleMeleeAttackImpactEvent::Damage' has a wrong offset!");
static_assert(offsetof(LarcinPassiveMod1Ability_HandleMeleeAttackImpactEvent, ResultingHealthPercentage) == 0x00001C, "Member 'LarcinPassiveMod1Ability_HandleMeleeAttackImpactEvent::ResultingHealthPercentage' has a wrong offset!");
static_assert(offsetof(LarcinPassiveMod1Ability_HandleMeleeAttackImpactEvent, HitType) == 0x000020, "Member 'LarcinPassiveMod1Ability_HandleMeleeAttackImpactEvent::HitType' has a wrong offset!");
static_assert(offsetof(LarcinPassiveMod1Ability_HandleMeleeAttackImpactEvent, HitConfirmedData) == 0x000028, "Member 'LarcinPassiveMod1Ability_HandleMeleeAttackImpactEvent::HitConfirmedData' has a wrong offset!");

// Function DeceiveInc.DISocialSubsystem.AcceptFriendRequest
// 0x0008 (0x0008 - 0x0000)
struct DISocialSubsystem_AcceptFriendRequest final
{
public:
	class UDIOnlineFriendInfo*                    FriendInfo;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISocialSubsystem_AcceptFriendRequest) == 0x000008, "Wrong alignment on DISocialSubsystem_AcceptFriendRequest");
static_assert(sizeof(DISocialSubsystem_AcceptFriendRequest) == 0x000008, "Wrong size on DISocialSubsystem_AcceptFriendRequest");
static_assert(offsetof(DISocialSubsystem_AcceptFriendRequest, FriendInfo) == 0x000000, "Member 'DISocialSubsystem_AcceptFriendRequest::FriendInfo' has a wrong offset!");

// Function DeceiveInc.DISocialSubsystem.ApplyReportFlag
// 0x0010 (0x0010 - 0x0000)
struct DISocialSubsystem_ApplyReportFlag final
{
public:
	bool                                          ShouldAdd;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ApplyBitmask;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentBitmask;                                    // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISocialSubsystem_ApplyReportFlag) == 0x000004, "Wrong alignment on DISocialSubsystem_ApplyReportFlag");
static_assert(sizeof(DISocialSubsystem_ApplyReportFlag) == 0x000010, "Wrong size on DISocialSubsystem_ApplyReportFlag");
static_assert(offsetof(DISocialSubsystem_ApplyReportFlag, ShouldAdd) == 0x000000, "Member 'DISocialSubsystem_ApplyReportFlag::ShouldAdd' has a wrong offset!");
static_assert(offsetof(DISocialSubsystem_ApplyReportFlag, ApplyBitmask) == 0x000004, "Member 'DISocialSubsystem_ApplyReportFlag::ApplyBitmask' has a wrong offset!");
static_assert(offsetof(DISocialSubsystem_ApplyReportFlag, CurrentBitmask) == 0x000008, "Member 'DISocialSubsystem_ApplyReportFlag::CurrentBitmask' has a wrong offset!");
static_assert(offsetof(DISocialSubsystem_ApplyReportFlag, ReturnValue) == 0x00000C, "Member 'DISocialSubsystem_ApplyReportFlag::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISocialSubsystem.BlockPlayer
// 0x0008 (0x0008 - 0x0000)
struct DISocialSubsystem_BlockPlayer final
{
public:
	class UDIOnlineFriendInfo*                    FriendInfo;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISocialSubsystem_BlockPlayer) == 0x000008, "Wrong alignment on DISocialSubsystem_BlockPlayer");
static_assert(sizeof(DISocialSubsystem_BlockPlayer) == 0x000008, "Wrong size on DISocialSubsystem_BlockPlayer");
static_assert(offsetof(DISocialSubsystem_BlockPlayer, FriendInfo) == 0x000000, "Member 'DISocialSubsystem_BlockPlayer::FriendInfo' has a wrong offset!");

// Function DeceiveInc.DISocialSubsystem.CancelFriendRequest
// 0x0008 (0x0008 - 0x0000)
struct DISocialSubsystem_CancelFriendRequest final
{
public:
	class UDIOnlineFriendInfo*                    FriendInfo;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISocialSubsystem_CancelFriendRequest) == 0x000008, "Wrong alignment on DISocialSubsystem_CancelFriendRequest");
static_assert(sizeof(DISocialSubsystem_CancelFriendRequest) == 0x000008, "Wrong size on DISocialSubsystem_CancelFriendRequest");
static_assert(offsetof(DISocialSubsystem_CancelFriendRequest, FriendInfo) == 0x000000, "Member 'DISocialSubsystem_CancelFriendRequest::FriendInfo' has a wrong offset!");

// Function DeceiveInc.DISocialSubsystem.OnDIWebServiceLoginCompleted
// 0x0020 (0x0020 - 0x0000)
struct DISocialSubsystem_OnDIWebServiceLoginCompleted final
{
public:
	struct FLoginResponse                         LoginResponse;                                     // 0x0000(0x0020)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISocialSubsystem_OnDIWebServiceLoginCompleted) == 0x000008, "Wrong alignment on DISocialSubsystem_OnDIWebServiceLoginCompleted");
static_assert(sizeof(DISocialSubsystem_OnDIWebServiceLoginCompleted) == 0x000020, "Wrong size on DISocialSubsystem_OnDIWebServiceLoginCompleted");
static_assert(offsetof(DISocialSubsystem_OnDIWebServiceLoginCompleted, LoginResponse) == 0x000000, "Member 'DISocialSubsystem_OnDIWebServiceLoginCompleted::LoginResponse' has a wrong offset!");

// Function DeceiveInc.DISocialSubsystem.OnMapChange
// 0x0008 (0x0008 - 0x0000)
struct DISocialSubsystem_OnMapChange final
{
public:
	class UWorld*                                 LoadedWorld;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISocialSubsystem_OnMapChange) == 0x000008, "Wrong alignment on DISocialSubsystem_OnMapChange");
static_assert(sizeof(DISocialSubsystem_OnMapChange) == 0x000008, "Wrong size on DISocialSubsystem_OnMapChange");
static_assert(offsetof(DISocialSubsystem_OnMapChange, LoadedWorld) == 0x000000, "Member 'DISocialSubsystem_OnMapChange::LoadedWorld' has a wrong offset!");

// Function DeceiveInc.DISocialSubsystem.OnReadFriendsListComplete
// 0x0028 (0x0028 - 0x0000)
struct DISocialSubsystem_OnReadFriendsListComplete final
{
public:
	int32                                         LocalUserNum;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasSuccessful;                                    // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ListName;                                          // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ErrorStr;                                          // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISocialSubsystem_OnReadFriendsListComplete) == 0x000008, "Wrong alignment on DISocialSubsystem_OnReadFriendsListComplete");
static_assert(sizeof(DISocialSubsystem_OnReadFriendsListComplete) == 0x000028, "Wrong size on DISocialSubsystem_OnReadFriendsListComplete");
static_assert(offsetof(DISocialSubsystem_OnReadFriendsListComplete, LocalUserNum) == 0x000000, "Member 'DISocialSubsystem_OnReadFriendsListComplete::LocalUserNum' has a wrong offset!");
static_assert(offsetof(DISocialSubsystem_OnReadFriendsListComplete, bWasSuccessful) == 0x000004, "Member 'DISocialSubsystem_OnReadFriendsListComplete::bWasSuccessful' has a wrong offset!");
static_assert(offsetof(DISocialSubsystem_OnReadFriendsListComplete, ListName) == 0x000008, "Member 'DISocialSubsystem_OnReadFriendsListComplete::ListName' has a wrong offset!");
static_assert(offsetof(DISocialSubsystem_OnReadFriendsListComplete, ErrorStr) == 0x000018, "Member 'DISocialSubsystem_OnReadFriendsListComplete::ErrorStr' has a wrong offset!");

// Function DeceiveInc.DISocialSubsystem.RejectFriendRequest
// 0x0008 (0x0008 - 0x0000)
struct DISocialSubsystem_RejectFriendRequest final
{
public:
	class UDIOnlineFriendInfo*                    FriendInfo;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISocialSubsystem_RejectFriendRequest) == 0x000008, "Wrong alignment on DISocialSubsystem_RejectFriendRequest");
static_assert(sizeof(DISocialSubsystem_RejectFriendRequest) == 0x000008, "Wrong size on DISocialSubsystem_RejectFriendRequest");
static_assert(offsetof(DISocialSubsystem_RejectFriendRequest, FriendInfo) == 0x000000, "Member 'DISocialSubsystem_RejectFriendRequest::FriendInfo' has a wrong offset!");

// Function DeceiveInc.DISocialSubsystem.RemoveFriend
// 0x0008 (0x0008 - 0x0000)
struct DISocialSubsystem_RemoveFriend final
{
public:
	class UDIOnlineFriendInfo*                    FriendInfo;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISocialSubsystem_RemoveFriend) == 0x000008, "Wrong alignment on DISocialSubsystem_RemoveFriend");
static_assert(sizeof(DISocialSubsystem_RemoveFriend) == 0x000008, "Wrong size on DISocialSubsystem_RemoveFriend");
static_assert(offsetof(DISocialSubsystem_RemoveFriend, FriendInfo) == 0x000000, "Member 'DISocialSubsystem_RemoveFriend::FriendInfo' has a wrong offset!");

// Function DeceiveInc.DISocialSubsystem.SearchFriendByDisplayName
// 0x0010 (0x0010 - 0x0000)
struct DISocialSubsystem_SearchFriendByDisplayName final
{
public:
	class FString                                 SearchDisplayName;                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISocialSubsystem_SearchFriendByDisplayName) == 0x000008, "Wrong alignment on DISocialSubsystem_SearchFriendByDisplayName");
static_assert(sizeof(DISocialSubsystem_SearchFriendByDisplayName) == 0x000010, "Wrong size on DISocialSubsystem_SearchFriendByDisplayName");
static_assert(offsetof(DISocialSubsystem_SearchFriendByDisplayName, SearchDisplayName) == 0x000000, "Member 'DISocialSubsystem_SearchFriendByDisplayName::SearchDisplayName' has a wrong offset!");

// Function DeceiveInc.DISocialSubsystem.SendFriendRequest
// 0x0008 (0x0008 - 0x0000)
struct DISocialSubsystem_SendFriendRequest final
{
public:
	class UDIOnlineFriendInfo*                    FriendInfo;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISocialSubsystem_SendFriendRequest) == 0x000008, "Wrong alignment on DISocialSubsystem_SendFriendRequest");
static_assert(sizeof(DISocialSubsystem_SendFriendRequest) == 0x000008, "Wrong size on DISocialSubsystem_SendFriendRequest");
static_assert(offsetof(DISocialSubsystem_SendFriendRequest, FriendInfo) == 0x000000, "Member 'DISocialSubsystem_SendFriendRequest::FriendInfo' has a wrong offset!");

// Function DeceiveInc.DISocialSubsystem.SendPlayerReport
// 0x0030 (0x0030 - 0x0000)
struct DISocialSubsystem_SendPlayerReport final
{
public:
	class UDIOnlineFriendInfo*                    FriendInfo;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CategoryId;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SessionID;                                         // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISocialSubsystem_SendPlayerReport) == 0x000008, "Wrong alignment on DISocialSubsystem_SendPlayerReport");
static_assert(sizeof(DISocialSubsystem_SendPlayerReport) == 0x000030, "Wrong size on DISocialSubsystem_SendPlayerReport");
static_assert(offsetof(DISocialSubsystem_SendPlayerReport, FriendInfo) == 0x000000, "Member 'DISocialSubsystem_SendPlayerReport::FriendInfo' has a wrong offset!");
static_assert(offsetof(DISocialSubsystem_SendPlayerReport, CategoryId) == 0x000008, "Member 'DISocialSubsystem_SendPlayerReport::CategoryId' has a wrong offset!");
static_assert(offsetof(DISocialSubsystem_SendPlayerReport, SessionID) == 0x000010, "Member 'DISocialSubsystem_SendPlayerReport::SessionID' has a wrong offset!");
static_assert(offsetof(DISocialSubsystem_SendPlayerReport, Message) == 0x000020, "Member 'DISocialSubsystem_SendPlayerReport::Message' has a wrong offset!");

// Function DeceiveInc.DISocialSubsystem.SendPlayerReportPlayerState
// 0x0030 (0x0030 - 0x0000)
struct DISocialSubsystem_SendPlayerReportPlayerState final
{
public:
	class ADIPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CategoryId;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SessionID;                                         // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISocialSubsystem_SendPlayerReportPlayerState) == 0x000008, "Wrong alignment on DISocialSubsystem_SendPlayerReportPlayerState");
static_assert(sizeof(DISocialSubsystem_SendPlayerReportPlayerState) == 0x000030, "Wrong size on DISocialSubsystem_SendPlayerReportPlayerState");
static_assert(offsetof(DISocialSubsystem_SendPlayerReportPlayerState, PlayerState) == 0x000000, "Member 'DISocialSubsystem_SendPlayerReportPlayerState::PlayerState' has a wrong offset!");
static_assert(offsetof(DISocialSubsystem_SendPlayerReportPlayerState, CategoryId) == 0x000008, "Member 'DISocialSubsystem_SendPlayerReportPlayerState::CategoryId' has a wrong offset!");
static_assert(offsetof(DISocialSubsystem_SendPlayerReportPlayerState, SessionID) == 0x000010, "Member 'DISocialSubsystem_SendPlayerReportPlayerState::SessionID' has a wrong offset!");
static_assert(offsetof(DISocialSubsystem_SendPlayerReportPlayerState, Message) == 0x000020, "Member 'DISocialSubsystem_SendPlayerReportPlayerState::Message' has a wrong offset!");

// Function DeceiveInc.DISocialSubsystem.TriggerFriendsListOpenChanged
// 0x0001 (0x0001 - 0x0000)
struct DISocialSubsystem_TriggerFriendsListOpenChanged final
{
public:
	bool                                          bOpen;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISocialSubsystem_TriggerFriendsListOpenChanged) == 0x000001, "Wrong alignment on DISocialSubsystem_TriggerFriendsListOpenChanged");
static_assert(sizeof(DISocialSubsystem_TriggerFriendsListOpenChanged) == 0x000001, "Wrong size on DISocialSubsystem_TriggerFriendsListOpenChanged");
static_assert(offsetof(DISocialSubsystem_TriggerFriendsListOpenChanged, bOpen) == 0x000000, "Member 'DISocialSubsystem_TriggerFriendsListOpenChanged::bOpen' has a wrong offset!");

// Function DeceiveInc.DISocialSubsystem.UnblockPlayer
// 0x0008 (0x0008 - 0x0000)
struct DISocialSubsystem_UnblockPlayer final
{
public:
	class UDIOnlineFriendInfo*                    FriendInfo;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISocialSubsystem_UnblockPlayer) == 0x000008, "Wrong alignment on DISocialSubsystem_UnblockPlayer");
static_assert(sizeof(DISocialSubsystem_UnblockPlayer) == 0x000008, "Wrong size on DISocialSubsystem_UnblockPlayer");
static_assert(offsetof(DISocialSubsystem_UnblockPlayer, FriendInfo) == 0x000000, "Member 'DISocialSubsystem_UnblockPlayer::FriendInfo' has a wrong offset!");

// Function DeceiveInc.DISocialSubsystem.GetBlockedPlayersList
// 0x0010 (0x0010 - 0x0000)
struct DISocialSubsystem_GetBlockedPlayersList final
{
public:
	TArray<class UDIOnlineFriendInfo*>            ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISocialSubsystem_GetBlockedPlayersList) == 0x000008, "Wrong alignment on DISocialSubsystem_GetBlockedPlayersList");
static_assert(sizeof(DISocialSubsystem_GetBlockedPlayersList) == 0x000010, "Wrong size on DISocialSubsystem_GetBlockedPlayersList");
static_assert(offsetof(DISocialSubsystem_GetBlockedPlayersList, ReturnValue) == 0x000000, "Member 'DISocialSubsystem_GetBlockedPlayersList::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISocialSubsystem.GetFriendInbounds
// 0x0010 (0x0010 - 0x0000)
struct DISocialSubsystem_GetFriendInbounds final
{
public:
	TArray<class UDIOnlineFriendInfo*>            ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISocialSubsystem_GetFriendInbounds) == 0x000008, "Wrong alignment on DISocialSubsystem_GetFriendInbounds");
static_assert(sizeof(DISocialSubsystem_GetFriendInbounds) == 0x000010, "Wrong size on DISocialSubsystem_GetFriendInbounds");
static_assert(offsetof(DISocialSubsystem_GetFriendInbounds, ReturnValue) == 0x000000, "Member 'DISocialSubsystem_GetFriendInbounds::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISocialSubsystem.GetFriendOutbounds
// 0x0010 (0x0010 - 0x0000)
struct DISocialSubsystem_GetFriendOutbounds final
{
public:
	TArray<class UDIOnlineFriendInfo*>            ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISocialSubsystem_GetFriendOutbounds) == 0x000008, "Wrong alignment on DISocialSubsystem_GetFriendOutbounds");
static_assert(sizeof(DISocialSubsystem_GetFriendOutbounds) == 0x000010, "Wrong size on DISocialSubsystem_GetFriendOutbounds");
static_assert(offsetof(DISocialSubsystem_GetFriendOutbounds, ReturnValue) == 0x000000, "Member 'DISocialSubsystem_GetFriendOutbounds::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DISocialSubsystem.GetSortedFriendList
// 0x0010 (0x0010 - 0x0000)
struct DISocialSubsystem_GetSortedFriendList final
{
public:
	TArray<class UDIOnlineFriendInfo*>            ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DISocialSubsystem_GetSortedFriendList) == 0x000008, "Wrong alignment on DISocialSubsystem_GetSortedFriendList");
static_assert(sizeof(DISocialSubsystem_GetSortedFriendList) == 0x000010, "Wrong size on DISocialSubsystem_GetSortedFriendList");
static_assert(offsetof(DISocialSubsystem_GetSortedFriendList, ReturnValue) == 0x000000, "Member 'DISocialSubsystem_GetSortedFriendList::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VictimEffectTickBehavior.ApplyEffectToVictim
// 0x0010 (0x0010 - 0x0000)
struct VictimEffectTickBehavior_ApplyEffectToVictim final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffectTickBehavior_ApplyEffectToVictim) == 0x000008, "Wrong alignment on VictimEffectTickBehavior_ApplyEffectToVictim");
static_assert(sizeof(VictimEffectTickBehavior_ApplyEffectToVictim) == 0x000010, "Wrong size on VictimEffectTickBehavior_ApplyEffectToVictim");
static_assert(offsetof(VictimEffectTickBehavior_ApplyEffectToVictim, Victim) == 0x000000, "Member 'VictimEffectTickBehavior_ApplyEffectToVictim::Victim' has a wrong offset!");
static_assert(offsetof(VictimEffectTickBehavior_ApplyEffectToVictim, Instigator) == 0x000008, "Member 'VictimEffectTickBehavior_ApplyEffectToVictim::Instigator' has a wrong offset!");

// Function DeceiveInc.VictimEffectTickBehavior.BP_OnEffectTick
// 0x0010 (0x0010 - 0x0000)
struct VictimEffectTickBehavior_BP_OnEffectTick final
{
public:
	class UVictimEffectTickBehavior*              EffectTick;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffectTickBehavior_BP_OnEffectTick) == 0x000008, "Wrong alignment on VictimEffectTickBehavior_BP_OnEffectTick");
static_assert(sizeof(VictimEffectTickBehavior_BP_OnEffectTick) == 0x000010, "Wrong size on VictimEffectTickBehavior_BP_OnEffectTick");
static_assert(offsetof(VictimEffectTickBehavior_BP_OnEffectTick, EffectTick) == 0x000000, "Member 'VictimEffectTickBehavior_BP_OnEffectTick::EffectTick' has a wrong offset!");
static_assert(offsetof(VictimEffectTickBehavior_BP_OnEffectTick, Victim) == 0x000008, "Member 'VictimEffectTickBehavior_BP_OnEffectTick::Victim' has a wrong offset!");

// Function DeceiveInc.VictimEffectTickBehavior.IsPositiveEffect
// 0x0001 (0x0001 - 0x0000)
struct VictimEffectTickBehavior_IsPositiveEffect final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffectTickBehavior_IsPositiveEffect) == 0x000001, "Wrong alignment on VictimEffectTickBehavior_IsPositiveEffect");
static_assert(sizeof(VictimEffectTickBehavior_IsPositiveEffect) == 0x000001, "Wrong size on VictimEffectTickBehavior_IsPositiveEffect");
static_assert(offsetof(VictimEffectTickBehavior_IsPositiveEffect, ReturnValue) == 0x000000, "Member 'VictimEffectTickBehavior_IsPositiveEffect::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VictimEffectTickBehavior.SetParentVictimEffect
// 0x0008 (0x0008 - 0x0000)
struct VictimEffectTickBehavior_SetParentVictimEffect final
{
public:
	class AVictimEffect*                          InParentVictimEffect;                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffectTickBehavior_SetParentVictimEffect) == 0x000008, "Wrong alignment on VictimEffectTickBehavior_SetParentVictimEffect");
static_assert(sizeof(VictimEffectTickBehavior_SetParentVictimEffect) == 0x000008, "Wrong size on VictimEffectTickBehavior_SetParentVictimEffect");
static_assert(offsetof(VictimEffectTickBehavior_SetParentVictimEffect, InParentVictimEffect) == 0x000000, "Member 'VictimEffectTickBehavior_SetParentVictimEffect::InParentVictimEffect' has a wrong offset!");

// Function DeceiveInc.VictimEffectTickBehavior.GetEffectType
// 0x0001 (0x0001 - 0x0000)
struct VictimEffectTickBehavior_GetEffectType final
{
public:
	EVictimEffectType                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffectTickBehavior_GetEffectType) == 0x000001, "Wrong alignment on VictimEffectTickBehavior_GetEffectType");
static_assert(sizeof(VictimEffectTickBehavior_GetEffectType) == 0x000001, "Wrong size on VictimEffectTickBehavior_GetEffectType");
static_assert(offsetof(VictimEffectTickBehavior_GetEffectType, ReturnValue) == 0x000000, "Member 'VictimEffectTickBehavior_GetEffectType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VictimEffectTickBehavior.GetParentVictimEffect
// 0x0008 (0x0008 - 0x0000)
struct VictimEffectTickBehavior_GetParentVictimEffect final
{
public:
	class AVictimEffect*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffectTickBehavior_GetParentVictimEffect) == 0x000008, "Wrong alignment on VictimEffectTickBehavior_GetParentVictimEffect");
static_assert(sizeof(VictimEffectTickBehavior_GetParentVictimEffect) == 0x000008, "Wrong size on VictimEffectTickBehavior_GetParentVictimEffect");
static_assert(offsetof(VictimEffectTickBehavior_GetParentVictimEffect, ReturnValue) == 0x000000, "Member 'VictimEffectTickBehavior_GetParentVictimEffect::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiSpyAnimInstance1P.TryGetSpyOwner
// 0x0008 (0x0008 - 0x0000)
struct DiSpyAnimInstance1P_TryGetSpyOwner final
{
public:
	class ASpy*                                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiSpyAnimInstance1P_TryGetSpyOwner) == 0x000008, "Wrong alignment on DiSpyAnimInstance1P_TryGetSpyOwner");
static_assert(sizeof(DiSpyAnimInstance1P_TryGetSpyOwner) == 0x000008, "Wrong size on DiSpyAnimInstance1P_TryGetSpyOwner");
static_assert(offsetof(DiSpyAnimInstance1P_TryGetSpyOwner, ReturnValue) == 0x000000, "Member 'DiSpyAnimInstance1P_TryGetSpyOwner::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiSpyAnimInstance3P.SwapTo3PMovementSet
// 0x0008 (0x0008 - 0x0000)
struct DiSpyAnimInstance3P_SwapTo3PMovementSet final
{
public:
	class FName                                   MovementSetName;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiSpyAnimInstance3P_SwapTo3PMovementSet) == 0x000004, "Wrong alignment on DiSpyAnimInstance3P_SwapTo3PMovementSet");
static_assert(sizeof(DiSpyAnimInstance3P_SwapTo3PMovementSet) == 0x000008, "Wrong size on DiSpyAnimInstance3P_SwapTo3PMovementSet");
static_assert(offsetof(DiSpyAnimInstance3P_SwapTo3PMovementSet, MovementSetName) == 0x000000, "Member 'DiSpyAnimInstance3P_SwapTo3PMovementSet::MovementSetName' has a wrong offset!");

// Function DeceiveInc.DiSpyAnimInstance3P.TryGetSpyOwner
// 0x0008 (0x0008 - 0x0000)
struct DiSpyAnimInstance3P_TryGetSpyOwner final
{
public:
	class ASpy*                                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiSpyAnimInstance3P_TryGetSpyOwner) == 0x000008, "Wrong alignment on DiSpyAnimInstance3P_TryGetSpyOwner");
static_assert(sizeof(DiSpyAnimInstance3P_TryGetSpyOwner) == 0x000008, "Wrong size on DiSpyAnimInstance3P_TryGetSpyOwner");
static_assert(offsetof(DiSpyAnimInstance3P_TryGetSpyOwner, ReturnValue) == 0x000000, "Member 'DiSpyAnimInstance3P_TryGetSpyOwner::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreMenuPageUserWidget.GetItemForSlot
// 0x0010 (0x0010 - 0x0000)
struct DIStoreMenuPageUserWidget_GetItemForSlot final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReducedPrice;                                      // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDIItem*                                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIStoreMenuPageUserWidget_GetItemForSlot) == 0x000008, "Wrong alignment on DIStoreMenuPageUserWidget_GetItemForSlot");
static_assert(sizeof(DIStoreMenuPageUserWidget_GetItemForSlot) == 0x000010, "Wrong size on DIStoreMenuPageUserWidget_GetItemForSlot");
static_assert(offsetof(DIStoreMenuPageUserWidget_GetItemForSlot, SlotIndex) == 0x000000, "Member 'DIStoreMenuPageUserWidget_GetItemForSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(DIStoreMenuPageUserWidget_GetItemForSlot, ReducedPrice) == 0x000004, "Member 'DIStoreMenuPageUserWidget_GetItemForSlot::ReducedPrice' has a wrong offset!");
static_assert(offsetof(DIStoreMenuPageUserWidget_GetItemForSlot, ReturnValue) == 0x000008, "Member 'DIStoreMenuPageUserWidget_GetItemForSlot::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIItem.GetDisplayRarity
// 0x0004 (0x0004 - 0x0000)
struct DIItem_GetDisplayRarity final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIItem_GetDisplayRarity) == 0x000004, "Wrong alignment on DIItem_GetDisplayRarity");
static_assert(sizeof(DIItem_GetDisplayRarity) == 0x000004, "Wrong size on DIItem_GetDisplayRarity");
static_assert(offsetof(DIItem_GetDisplayRarity, ReturnValue) == 0x000000, "Member 'DIItem_GetDisplayRarity::ReturnValue' has a wrong offset!");

// Function DeceiveInc.XpProgressionData.ClampMatchLevel
// 0x000C (0x000C - 0x0000)
struct XpProgressionData_ClampMatchLevel final
{
public:
	int32                                         CurrentLevel;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewLevel;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XpProgressionData_ClampMatchLevel) == 0x000004, "Wrong alignment on XpProgressionData_ClampMatchLevel");
static_assert(sizeof(XpProgressionData_ClampMatchLevel) == 0x00000C, "Wrong size on XpProgressionData_ClampMatchLevel");
static_assert(offsetof(XpProgressionData_ClampMatchLevel, CurrentLevel) == 0x000000, "Member 'XpProgressionData_ClampMatchLevel::CurrentLevel' has a wrong offset!");
static_assert(offsetof(XpProgressionData_ClampMatchLevel, NewLevel) == 0x000004, "Member 'XpProgressionData_ClampMatchLevel::NewLevel' has a wrong offset!");
static_assert(offsetof(XpProgressionData_ClampMatchLevel, ReturnValue) == 0x000008, "Member 'XpProgressionData_ClampMatchLevel::ReturnValue' has a wrong offset!");

// Function DeceiveInc.XpProgressionData.GetEchelonForLevel
// 0x0040 (0x0040 - 0x0000)
struct XpProgressionData_GetEchelonForLevel final
{
public:
	int32                                         CurrentLevel;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEchelonProgression                    ReturnValue;                                       // 0x0008(0x0038)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(XpProgressionData_GetEchelonForLevel) == 0x000008, "Wrong alignment on XpProgressionData_GetEchelonForLevel");
static_assert(sizeof(XpProgressionData_GetEchelonForLevel) == 0x000040, "Wrong size on XpProgressionData_GetEchelonForLevel");
static_assert(offsetof(XpProgressionData_GetEchelonForLevel, CurrentLevel) == 0x000000, "Member 'XpProgressionData_GetEchelonForLevel::CurrentLevel' has a wrong offset!");
static_assert(offsetof(XpProgressionData_GetEchelonForLevel, ReturnValue) == 0x000008, "Member 'XpProgressionData_GetEchelonForLevel::ReturnValue' has a wrong offset!");

// Function DeceiveInc.XpProgressionData.GetEchelonMinLevel
// 0x0004 (0x0004 - 0x0000)
struct XpProgressionData_GetEchelonMinLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XpProgressionData_GetEchelonMinLevel) == 0x000004, "Wrong alignment on XpProgressionData_GetEchelonMinLevel");
static_assert(sizeof(XpProgressionData_GetEchelonMinLevel) == 0x000004, "Wrong size on XpProgressionData_GetEchelonMinLevel");
static_assert(offsetof(XpProgressionData_GetEchelonMinLevel, ReturnValue) == 0x000000, "Member 'XpProgressionData_GetEchelonMinLevel::ReturnValue' has a wrong offset!");

// Function DeceiveInc.XpProgressionData.GetLastUnlockEchelon
// 0x0040 (0x0040 - 0x0000)
struct XpProgressionData_GetLastUnlockEchelon final
{
public:
	int32                                         CurrentLevel;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEchelonProgression                    ReturnValue;                                       // 0x0008(0x0038)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(XpProgressionData_GetLastUnlockEchelon) == 0x000008, "Wrong alignment on XpProgressionData_GetLastUnlockEchelon");
static_assert(sizeof(XpProgressionData_GetLastUnlockEchelon) == 0x000040, "Wrong size on XpProgressionData_GetLastUnlockEchelon");
static_assert(offsetof(XpProgressionData_GetLastUnlockEchelon, CurrentLevel) == 0x000000, "Member 'XpProgressionData_GetLastUnlockEchelon::CurrentLevel' has a wrong offset!");
static_assert(offsetof(XpProgressionData_GetLastUnlockEchelon, ReturnValue) == 0x000008, "Member 'XpProgressionData_GetLastUnlockEchelon::ReturnValue' has a wrong offset!");

// Function DeceiveInc.XpProgressionData.GetLevelForXpValue
// 0x000C (0x000C - 0x0000)
struct XpProgressionData_GetLevelForXpValue final
{
public:
	int32                                         CurrentLevel;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XPTotal;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XpProgressionData_GetLevelForXpValue) == 0x000004, "Wrong alignment on XpProgressionData_GetLevelForXpValue");
static_assert(sizeof(XpProgressionData_GetLevelForXpValue) == 0x00000C, "Wrong size on XpProgressionData_GetLevelForXpValue");
static_assert(offsetof(XpProgressionData_GetLevelForXpValue, CurrentLevel) == 0x000000, "Member 'XpProgressionData_GetLevelForXpValue::CurrentLevel' has a wrong offset!");
static_assert(offsetof(XpProgressionData_GetLevelForXpValue, XPTotal) == 0x000004, "Member 'XpProgressionData_GetLevelForXpValue::XPTotal' has a wrong offset!");
static_assert(offsetof(XpProgressionData_GetLevelForXpValue, ReturnValue) == 0x000008, "Member 'XpProgressionData_GetLevelForXpValue::ReturnValue' has a wrong offset!");

// Function DeceiveInc.XpProgressionData.GetMaxLevel
// 0x0004 (0x0004 - 0x0000)
struct XpProgressionData_GetMaxLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XpProgressionData_GetMaxLevel) == 0x000004, "Wrong alignment on XpProgressionData_GetMaxLevel");
static_assert(sizeof(XpProgressionData_GetMaxLevel) == 0x000004, "Wrong size on XpProgressionData_GetMaxLevel");
static_assert(offsetof(XpProgressionData_GetMaxLevel, ReturnValue) == 0x000000, "Member 'XpProgressionData_GetMaxLevel::ReturnValue' has a wrong offset!");

// Function DeceiveInc.XpProgressionData.GetMaxLevelForMatch
// 0x0008 (0x0008 - 0x0000)
struct XpProgressionData_GetMaxLevelForMatch final
{
public:
	int32                                         CurrentLevel;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XpProgressionData_GetMaxLevelForMatch) == 0x000004, "Wrong alignment on XpProgressionData_GetMaxLevelForMatch");
static_assert(sizeof(XpProgressionData_GetMaxLevelForMatch) == 0x000008, "Wrong size on XpProgressionData_GetMaxLevelForMatch");
static_assert(offsetof(XpProgressionData_GetMaxLevelForMatch, CurrentLevel) == 0x000000, "Member 'XpProgressionData_GetMaxLevelForMatch::CurrentLevel' has a wrong offset!");
static_assert(offsetof(XpProgressionData_GetMaxLevelForMatch, ReturnValue) == 0x000004, "Member 'XpProgressionData_GetMaxLevelForMatch::ReturnValue' has a wrong offset!");

// Function DeceiveInc.XpProgressionData.GetProgressionPercent
// 0x000C (0x000C - 0x0000)
struct XpProgressionData_GetProgressionPercent final
{
public:
	int32                                         CurrentLevel;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XPTotal;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XpProgressionData_GetProgressionPercent) == 0x000004, "Wrong alignment on XpProgressionData_GetProgressionPercent");
static_assert(sizeof(XpProgressionData_GetProgressionPercent) == 0x00000C, "Wrong size on XpProgressionData_GetProgressionPercent");
static_assert(offsetof(XpProgressionData_GetProgressionPercent, CurrentLevel) == 0x000000, "Member 'XpProgressionData_GetProgressionPercent::CurrentLevel' has a wrong offset!");
static_assert(offsetof(XpProgressionData_GetProgressionPercent, XPTotal) == 0x000004, "Member 'XpProgressionData_GetProgressionPercent::XPTotal' has a wrong offset!");
static_assert(offsetof(XpProgressionData_GetProgressionPercent, ReturnValue) == 0x000008, "Member 'XpProgressionData_GetProgressionPercent::ReturnValue' has a wrong offset!");

// Function DeceiveInc.XpProgressionData.GetRequiredXPForLevel
// 0x0008 (0x0008 - 0x0000)
struct XpProgressionData_GetRequiredXPForLevel final
{
public:
	int32                                         LevelIn;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XpProgressionData_GetRequiredXPForLevel) == 0x000004, "Wrong alignment on XpProgressionData_GetRequiredXPForLevel");
static_assert(sizeof(XpProgressionData_GetRequiredXPForLevel) == 0x000008, "Wrong size on XpProgressionData_GetRequiredXPForLevel");
static_assert(offsetof(XpProgressionData_GetRequiredXPForLevel, LevelIn) == 0x000000, "Member 'XpProgressionData_GetRequiredXPForLevel::LevelIn' has a wrong offset!");
static_assert(offsetof(XpProgressionData_GetRequiredXPForLevel, ReturnValue) == 0x000004, "Member 'XpProgressionData_GetRequiredXPForLevel::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VaultDoorOverrideCondition.GetCurrentStatus
// 0x0001 (0x0001 - 0x0000)
struct VaultDoorOverrideCondition_GetCurrentStatus final
{
public:
	EVaultOverrideStatus                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VaultDoorOverrideCondition_GetCurrentStatus) == 0x000001, "Wrong alignment on VaultDoorOverrideCondition_GetCurrentStatus");
static_assert(sizeof(VaultDoorOverrideCondition_GetCurrentStatus) == 0x000001, "Wrong size on VaultDoorOverrideCondition_GetCurrentStatus");
static_assert(offsetof(VaultDoorOverrideCondition_GetCurrentStatus, ReturnValue) == 0x000000, "Member 'VaultDoorOverrideCondition_GetCurrentStatus::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VaultDoorOverrideCondition.HandleInteractionComplete
// 0x0010 (0x0010 - 0x0000)
struct VaultDoorOverrideCondition_HandleInteractionComplete final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VaultDoorOverrideCondition_HandleInteractionComplete) == 0x000008, "Wrong alignment on VaultDoorOverrideCondition_HandleInteractionComplete");
static_assert(sizeof(VaultDoorOverrideCondition_HandleInteractionComplete) == 0x000010, "Wrong size on VaultDoorOverrideCondition_HandleInteractionComplete");
static_assert(offsetof(VaultDoorOverrideCondition_HandleInteractionComplete, Interacter) == 0x000000, "Member 'VaultDoorOverrideCondition_HandleInteractionComplete::Interacter' has a wrong offset!");
static_assert(offsetof(VaultDoorOverrideCondition_HandleInteractionComplete, Interactable) == 0x000008, "Member 'VaultDoorOverrideCondition_HandleInteractionComplete::Interactable' has a wrong offset!");

// Function DeceiveInc.VaultDoorOverrideCondition.ReduceCost
// 0x0010 (0x0010 - 0x0000)
struct VaultDoorOverrideCondition_ReduceCost final
{
public:
	int32                                         Reduction;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VaultDoorOverrideCondition_ReduceCost) == 0x000008, "Wrong alignment on VaultDoorOverrideCondition_ReduceCost");
static_assert(sizeof(VaultDoorOverrideCondition_ReduceCost) == 0x000010, "Wrong size on VaultDoorOverrideCondition_ReduceCost");
static_assert(offsetof(VaultDoorOverrideCondition_ReduceCost, Reduction) == 0x000000, "Member 'VaultDoorOverrideCondition_ReduceCost::Reduction' has a wrong offset!");
static_assert(offsetof(VaultDoorOverrideCondition_ReduceCost, Spy) == 0x000008, "Member 'VaultDoorOverrideCondition_ReduceCost::Spy' has a wrong offset!");

// Function DeceiveInc.VaultDoorOverrideCondition.GetRemainingIntelRequired
// 0x0004 (0x0004 - 0x0000)
struct VaultDoorOverrideCondition_GetRemainingIntelRequired final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VaultDoorOverrideCondition_GetRemainingIntelRequired) == 0x000004, "Wrong alignment on VaultDoorOverrideCondition_GetRemainingIntelRequired");
static_assert(sizeof(VaultDoorOverrideCondition_GetRemainingIntelRequired) == 0x000004, "Wrong size on VaultDoorOverrideCondition_GetRemainingIntelRequired");
static_assert(offsetof(VaultDoorOverrideCondition_GetRemainingIntelRequired, ReturnValue) == 0x000000, "Member 'VaultDoorOverrideCondition_GetRemainingIntelRequired::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Matchmaker.DoStartMatchmakingRequest
// 0x0001 (0x0001 - 0x0000)
struct Matchmaker_DoStartMatchmakingRequest final
{
public:
	EDIGameMode                                   GameMode;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Matchmaker_DoStartMatchmakingRequest) == 0x000001, "Wrong alignment on Matchmaker_DoStartMatchmakingRequest");
static_assert(sizeof(Matchmaker_DoStartMatchmakingRequest) == 0x000001, "Wrong size on Matchmaker_DoStartMatchmakingRequest");
static_assert(offsetof(Matchmaker_DoStartMatchmakingRequest, GameMode) == 0x000000, "Member 'Matchmaker_DoStartMatchmakingRequest::GameMode' has a wrong offset!");

// Function DeceiveInc.Matchmaker.DoStartMatchmakingRequestForPrivateLobby
// 0x00D0 (0x00D0 - 0x0000)
struct Matchmaker_DoStartMatchmakingRequestForPrivateLobby final
{
public:
	EDIGameMode                                   GameMode;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDIPrivateLobbyInfo                    DIPrivateLobbyInfo;                                // 0x0008(0x00C8)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Matchmaker_DoStartMatchmakingRequestForPrivateLobby) == 0x000008, "Wrong alignment on Matchmaker_DoStartMatchmakingRequestForPrivateLobby");
static_assert(sizeof(Matchmaker_DoStartMatchmakingRequestForPrivateLobby) == 0x0000D0, "Wrong size on Matchmaker_DoStartMatchmakingRequestForPrivateLobby");
static_assert(offsetof(Matchmaker_DoStartMatchmakingRequestForPrivateLobby, GameMode) == 0x000000, "Member 'Matchmaker_DoStartMatchmakingRequestForPrivateLobby::GameMode' has a wrong offset!");
static_assert(offsetof(Matchmaker_DoStartMatchmakingRequestForPrivateLobby, DIPrivateLobbyInfo) == 0x000008, "Member 'Matchmaker_DoStartMatchmakingRequestForPrivateLobby::DIPrivateLobbyInfo' has a wrong offset!");

// Function DeceiveInc.Matchmaker.IsDelayedMatchmaking
// 0x0001 (0x0001 - 0x0000)
struct Matchmaker_IsDelayedMatchmaking final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Matchmaker_IsDelayedMatchmaking) == 0x000001, "Wrong alignment on Matchmaker_IsDelayedMatchmaking");
static_assert(sizeof(Matchmaker_IsDelayedMatchmaking) == 0x000001, "Wrong size on Matchmaker_IsDelayedMatchmaking");
static_assert(offsetof(Matchmaker_IsDelayedMatchmaking, ReturnValue) == 0x000000, "Member 'Matchmaker_IsDelayedMatchmaking::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Matchmaker.IsMatchmaking
// 0x0001 (0x0001 - 0x0000)
struct Matchmaker_IsMatchmaking final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Matchmaker_IsMatchmaking) == 0x000001, "Wrong alignment on Matchmaker_IsMatchmaking");
static_assert(sizeof(Matchmaker_IsMatchmaking) == 0x000001, "Wrong size on Matchmaker_IsMatchmaking");
static_assert(offsetof(Matchmaker_IsMatchmaking, ReturnValue) == 0x000000, "Member 'Matchmaker_IsMatchmaking::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ScannableComponent.AreConditionsMet
// 0x0010 (0x0010 - 0x0000)
struct ScannableComponent_AreConditionsMet final
{
public:
	class AActor*                                 Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ScannableComponent_AreConditionsMet) == 0x000008, "Wrong alignment on ScannableComponent_AreConditionsMet");
static_assert(sizeof(ScannableComponent_AreConditionsMet) == 0x000010, "Wrong size on ScannableComponent_AreConditionsMet");
static_assert(offsetof(ScannableComponent_AreConditionsMet, Interacter) == 0x000000, "Member 'ScannableComponent_AreConditionsMet::Interacter' has a wrong offset!");
static_assert(offsetof(ScannableComponent_AreConditionsMet, ReturnValue) == 0x000008, "Member 'ScannableComponent_AreConditionsMet::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ScannableComponent.AreRayCastConditionMet
// 0x0010 (0x0010 - 0x0000)
struct ScannableComponent_AreRayCastConditionMet final
{
public:
	class AActor*                                 Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ScannableComponent_AreRayCastConditionMet) == 0x000008, "Wrong alignment on ScannableComponent_AreRayCastConditionMet");
static_assert(sizeof(ScannableComponent_AreRayCastConditionMet) == 0x000010, "Wrong size on ScannableComponent_AreRayCastConditionMet");
static_assert(offsetof(ScannableComponent_AreRayCastConditionMet, Interacter) == 0x000000, "Member 'ScannableComponent_AreRayCastConditionMet::Interacter' has a wrong offset!");
static_assert(offsetof(ScannableComponent_AreRayCastConditionMet, ReturnValue) == 0x000008, "Member 'ScannableComponent_AreRayCastConditionMet::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ScannableComponent.OnComponentBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct ScannableComponent_OnComponentBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScannableComponent_OnComponentBeginOverlap) == 0x000008, "Wrong alignment on ScannableComponent_OnComponentBeginOverlap");
static_assert(sizeof(ScannableComponent_OnComponentBeginOverlap) == 0x0000A8, "Wrong size on ScannableComponent_OnComponentBeginOverlap");
static_assert(offsetof(ScannableComponent_OnComponentBeginOverlap, OverlappedComponent) == 0x000000, "Member 'ScannableComponent_OnComponentBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(ScannableComponent_OnComponentBeginOverlap, OtherActor) == 0x000008, "Member 'ScannableComponent_OnComponentBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(ScannableComponent_OnComponentBeginOverlap, OtherComp) == 0x000010, "Member 'ScannableComponent_OnComponentBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(ScannableComponent_OnComponentBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'ScannableComponent_OnComponentBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(ScannableComponent_OnComponentBeginOverlap, bFromSweep) == 0x00001C, "Member 'ScannableComponent_OnComponentBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(ScannableComponent_OnComponentBeginOverlap, SweepResult) == 0x000020, "Member 'ScannableComponent_OnComponentBeginOverlap::SweepResult' has a wrong offset!");

// Function DeceiveInc.ScannableComponent.OnComponentEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct ScannableComponent_OnComponentEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ScannableComponent_OnComponentEndOverlap) == 0x000008, "Wrong alignment on ScannableComponent_OnComponentEndOverlap");
static_assert(sizeof(ScannableComponent_OnComponentEndOverlap) == 0x000020, "Wrong size on ScannableComponent_OnComponentEndOverlap");
static_assert(offsetof(ScannableComponent_OnComponentEndOverlap, OverlappedComponent) == 0x000000, "Member 'ScannableComponent_OnComponentEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(ScannableComponent_OnComponentEndOverlap, OtherActor) == 0x000008, "Member 'ScannableComponent_OnComponentEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(ScannableComponent_OnComponentEndOverlap, OtherComp) == 0x000010, "Member 'ScannableComponent_OnComponentEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(ScannableComponent_OnComponentEndOverlap, OtherBodyIndex) == 0x000018, "Member 'ScannableComponent_OnComponentEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function DeceiveInc.ScannableComponent.SetDetectionCollision
// 0x0008 (0x0008 - 0x0000)
struct ScannableComponent_SetDetectionCollision final
{
public:
	class UShapeComponent*                        CollisionShape;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScannableComponent_SetDetectionCollision) == 0x000008, "Wrong alignment on ScannableComponent_SetDetectionCollision");
static_assert(sizeof(ScannableComponent_SetDetectionCollision) == 0x000008, "Wrong size on ScannableComponent_SetDetectionCollision");
static_assert(offsetof(ScannableComponent_SetDetectionCollision, CollisionShape) == 0x000000, "Member 'ScannableComponent_SetDetectionCollision::CollisionShape' has a wrong offset!");

// Function DeceiveInc.ScannableComponent.SetIsScannable
// 0x0001 (0x0001 - 0x0000)
struct ScannableComponent_SetIsScannable final
{
public:
	bool                                          bScannable;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScannableComponent_SetIsScannable) == 0x000001, "Wrong alignment on ScannableComponent_SetIsScannable");
static_assert(sizeof(ScannableComponent_SetIsScannable) == 0x000001, "Wrong size on ScannableComponent_SetIsScannable");
static_assert(offsetof(ScannableComponent_SetIsScannable, bScannable) == 0x000000, "Member 'ScannableComponent_SetIsScannable::bScannable' has a wrong offset!");

// Function DeceiveInc.ScannableComponent.SetScanIcon
// 0x0008 (0x0008 - 0x0000)
struct ScannableComponent_SetScanIcon final
{
public:
	class UInteractionIconComponent*              ScanIcon;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScannableComponent_SetScanIcon) == 0x000008, "Wrong alignment on ScannableComponent_SetScanIcon");
static_assert(sizeof(ScannableComponent_SetScanIcon) == 0x000008, "Wrong size on ScannableComponent_SetScanIcon");
static_assert(offsetof(ScannableComponent_SetScanIcon, ScanIcon) == 0x000000, "Member 'ScannableComponent_SetScanIcon::ScanIcon' has a wrong offset!");

// Function DeceiveInc.ScannableComponent.GetInteractionLocation
// 0x000C (0x000C - 0x0000)
struct ScannableComponent_GetInteractionLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScannableComponent_GetInteractionLocation) == 0x000004, "Wrong alignment on ScannableComponent_GetInteractionLocation");
static_assert(sizeof(ScannableComponent_GetInteractionLocation) == 0x00000C, "Wrong size on ScannableComponent_GetInteractionLocation");
static_assert(offsetof(ScannableComponent_GetInteractionLocation, ReturnValue) == 0x000000, "Member 'ScannableComponent_GetInteractionLocation::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ScannableComponent.GetScanIcon
// 0x0008 (0x0008 - 0x0000)
struct ScannableComponent_GetScanIcon final
{
public:
	class UInteractionIconComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScannableComponent_GetScanIcon) == 0x000008, "Wrong alignment on ScannableComponent_GetScanIcon");
static_assert(sizeof(ScannableComponent_GetScanIcon) == 0x000008, "Wrong size on ScannableComponent_GetScanIcon");
static_assert(offsetof(ScannableComponent_GetScanIcon, ReturnValue) == 0x000000, "Member 'ScannableComponent_GetScanIcon::ReturnValue' has a wrong offset!");

// Function DeceiveInc.GameplayResourcesComponent.AddMaxAmountPowerup
// 0x000C (0x000C - 0x0000)
struct GameplayResourcesComponent_AddMaxAmountPowerup final
{
public:
	EGameplayResourcesType                        Ressource;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxAmountIncrease;                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResourceToGive;                                    // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayResourcesComponent_AddMaxAmountPowerup) == 0x000004, "Wrong alignment on GameplayResourcesComponent_AddMaxAmountPowerup");
static_assert(sizeof(GameplayResourcesComponent_AddMaxAmountPowerup) == 0x00000C, "Wrong size on GameplayResourcesComponent_AddMaxAmountPowerup");
static_assert(offsetof(GameplayResourcesComponent_AddMaxAmountPowerup, Ressource) == 0x000000, "Member 'GameplayResourcesComponent_AddMaxAmountPowerup::Ressource' has a wrong offset!");
static_assert(offsetof(GameplayResourcesComponent_AddMaxAmountPowerup, MaxAmountIncrease) == 0x000004, "Member 'GameplayResourcesComponent_AddMaxAmountPowerup::MaxAmountIncrease' has a wrong offset!");
static_assert(offsetof(GameplayResourcesComponent_AddMaxAmountPowerup, ResourceToGive) == 0x000008, "Member 'GameplayResourcesComponent_AddMaxAmountPowerup::ResourceToGive' has a wrong offset!");

// Function DeceiveInc.GameplayResourcesComponent.AddResource
// 0x000C (0x000C - 0x0000)
struct GameplayResourcesComponent_AddResource final
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGiveXpForResource;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayResourcesComponent_AddResource) == 0x000004, "Wrong alignment on GameplayResourcesComponent_AddResource");
static_assert(sizeof(GameplayResourcesComponent_AddResource) == 0x00000C, "Wrong size on GameplayResourcesComponent_AddResource");
static_assert(offsetof(GameplayResourcesComponent_AddResource, ResourceType) == 0x000000, "Member 'GameplayResourcesComponent_AddResource::ResourceType' has a wrong offset!");
static_assert(offsetof(GameplayResourcesComponent_AddResource, Amount) == 0x000004, "Member 'GameplayResourcesComponent_AddResource::Amount' has a wrong offset!");
static_assert(offsetof(GameplayResourcesComponent_AddResource, bGiveXpForResource) == 0x000008, "Member 'GameplayResourcesComponent_AddResource::bGiveXpForResource' has a wrong offset!");

// Function DeceiveInc.GameplayResourcesComponent.GetMaxAmount
// 0x0008 (0x0008 - 0x0000)
struct GameplayResourcesComponent_GetMaxAmount final
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayResourcesComponent_GetMaxAmount) == 0x000004, "Wrong alignment on GameplayResourcesComponent_GetMaxAmount");
static_assert(sizeof(GameplayResourcesComponent_GetMaxAmount) == 0x000008, "Wrong size on GameplayResourcesComponent_GetMaxAmount");
static_assert(offsetof(GameplayResourcesComponent_GetMaxAmount, ResourceType) == 0x000000, "Member 'GameplayResourcesComponent_GetMaxAmount::ResourceType' has a wrong offset!");
static_assert(offsetof(GameplayResourcesComponent_GetMaxAmount, ReturnValue) == 0x000004, "Member 'GameplayResourcesComponent_GetMaxAmount::ReturnValue' has a wrong offset!");

// Function DeceiveInc.GameplayResourcesComponent.GetResourceAmount
// 0x0008 (0x0008 - 0x0000)
struct GameplayResourcesComponent_GetResourceAmount final
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayResourcesComponent_GetResourceAmount) == 0x000004, "Wrong alignment on GameplayResourcesComponent_GetResourceAmount");
static_assert(sizeof(GameplayResourcesComponent_GetResourceAmount) == 0x000008, "Wrong size on GameplayResourcesComponent_GetResourceAmount");
static_assert(offsetof(GameplayResourcesComponent_GetResourceAmount, ResourceType) == 0x000000, "Member 'GameplayResourcesComponent_GetResourceAmount::ResourceType' has a wrong offset!");
static_assert(offsetof(GameplayResourcesComponent_GetResourceAmount, ReturnValue) == 0x000004, "Member 'GameplayResourcesComponent_GetResourceAmount::ReturnValue' has a wrong offset!");

// Function DeceiveInc.GameplayResourcesComponent.GetResourceDisplayName
// 0x0020 (0x0020 - 0x0000)
struct GameplayResourcesComponent_GetResourceDisplayName final
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayResourcesComponent_GetResourceDisplayName) == 0x000008, "Wrong alignment on GameplayResourcesComponent_GetResourceDisplayName");
static_assert(sizeof(GameplayResourcesComponent_GetResourceDisplayName) == 0x000020, "Wrong size on GameplayResourcesComponent_GetResourceDisplayName");
static_assert(offsetof(GameplayResourcesComponent_GetResourceDisplayName, ResourceType) == 0x000000, "Member 'GameplayResourcesComponent_GetResourceDisplayName::ResourceType' has a wrong offset!");
static_assert(offsetof(GameplayResourcesComponent_GetResourceDisplayName, ReturnValue) == 0x000008, "Member 'GameplayResourcesComponent_GetResourceDisplayName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.GameplayResourcesComponent.HasEnoughResource
// 0x000C (0x000C - 0x0000)
struct GameplayResourcesComponent_HasEnoughResource final
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayResourcesComponent_HasEnoughResource) == 0x000004, "Wrong alignment on GameplayResourcesComponent_HasEnoughResource");
static_assert(sizeof(GameplayResourcesComponent_HasEnoughResource) == 0x00000C, "Wrong size on GameplayResourcesComponent_HasEnoughResource");
static_assert(offsetof(GameplayResourcesComponent_HasEnoughResource, ResourceType) == 0x000000, "Member 'GameplayResourcesComponent_HasEnoughResource::ResourceType' has a wrong offset!");
static_assert(offsetof(GameplayResourcesComponent_HasEnoughResource, Amount) == 0x000004, "Member 'GameplayResourcesComponent_HasEnoughResource::Amount' has a wrong offset!");
static_assert(offsetof(GameplayResourcesComponent_HasEnoughResource, ReturnValue) == 0x000008, "Member 'GameplayResourcesComponent_HasEnoughResource::ReturnValue' has a wrong offset!");

// Function DeceiveInc.GameplayResourcesComponent.OnRep_NewPlayerResourceData
// 0x0010 (0x0010 - 0x0000)
struct GameplayResourcesComponent_OnRep_NewPlayerResourceData final
{
public:
	TArray<struct FPlayerResourceData>            OldData;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayResourcesComponent_OnRep_NewPlayerResourceData) == 0x000008, "Wrong alignment on GameplayResourcesComponent_OnRep_NewPlayerResourceData");
static_assert(sizeof(GameplayResourcesComponent_OnRep_NewPlayerResourceData) == 0x000010, "Wrong size on GameplayResourcesComponent_OnRep_NewPlayerResourceData");
static_assert(offsetof(GameplayResourcesComponent_OnRep_NewPlayerResourceData, OldData) == 0x000000, "Member 'GameplayResourcesComponent_OnRep_NewPlayerResourceData::OldData' has a wrong offset!");

// Function DeceiveInc.GameplayResourcesComponent.RemoveMaxAmountPowerup
// 0x000C (0x000C - 0x0000)
struct GameplayResourcesComponent_RemoveMaxAmountPowerup final
{
public:
	EGameplayResourcesType                        Ressource;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxAmountIncrease;                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResourceToGive;                                    // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayResourcesComponent_RemoveMaxAmountPowerup) == 0x000004, "Wrong alignment on GameplayResourcesComponent_RemoveMaxAmountPowerup");
static_assert(sizeof(GameplayResourcesComponent_RemoveMaxAmountPowerup) == 0x00000C, "Wrong size on GameplayResourcesComponent_RemoveMaxAmountPowerup");
static_assert(offsetof(GameplayResourcesComponent_RemoveMaxAmountPowerup, Ressource) == 0x000000, "Member 'GameplayResourcesComponent_RemoveMaxAmountPowerup::Ressource' has a wrong offset!");
static_assert(offsetof(GameplayResourcesComponent_RemoveMaxAmountPowerup, MaxAmountIncrease) == 0x000004, "Member 'GameplayResourcesComponent_RemoveMaxAmountPowerup::MaxAmountIncrease' has a wrong offset!");
static_assert(offsetof(GameplayResourcesComponent_RemoveMaxAmountPowerup, ResourceToGive) == 0x000008, "Member 'GameplayResourcesComponent_RemoveMaxAmountPowerup::ResourceToGive' has a wrong offset!");

// Function DeceiveInc.GameplayResourcesComponent.RemoveResource
// 0x0008 (0x0008 - 0x0000)
struct GameplayResourcesComponent_RemoveResource final
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayResourcesComponent_RemoveResource) == 0x000004, "Wrong alignment on GameplayResourcesComponent_RemoveResource");
static_assert(sizeof(GameplayResourcesComponent_RemoveResource) == 0x000008, "Wrong size on GameplayResourcesComponent_RemoveResource");
static_assert(offsetof(GameplayResourcesComponent_RemoveResource, ResourceType) == 0x000000, "Member 'GameplayResourcesComponent_RemoveResource::ResourceType' has a wrong offset!");
static_assert(offsetof(GameplayResourcesComponent_RemoveResource, Amount) == 0x000004, "Member 'GameplayResourcesComponent_RemoveResource::Amount' has a wrong offset!");

// Function DeceiveInc.GameplayResourcesComponent.SetMaxAmount
// 0x0008 (0x0008 - 0x0000)
struct GameplayResourcesComponent_SetMaxAmount final
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxAmount;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayResourcesComponent_SetMaxAmount) == 0x000004, "Wrong alignment on GameplayResourcesComponent_SetMaxAmount");
static_assert(sizeof(GameplayResourcesComponent_SetMaxAmount) == 0x000008, "Wrong size on GameplayResourcesComponent_SetMaxAmount");
static_assert(offsetof(GameplayResourcesComponent_SetMaxAmount, ResourceType) == 0x000000, "Member 'GameplayResourcesComponent_SetMaxAmount::ResourceType' has a wrong offset!");
static_assert(offsetof(GameplayResourcesComponent_SetMaxAmount, MaxAmount) == 0x000004, "Member 'GameplayResourcesComponent_SetMaxAmount::MaxAmount' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.IsNPCMainAnimationAirborne
// 0x0002 (0x0002 - 0x0000)
struct NPCCharacter_IsNPCMainAnimationAirborne final
{
public:
	ENPCMainAnimation                             CheckMainAnimation;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_IsNPCMainAnimationAirborne) == 0x000001, "Wrong alignment on NPCCharacter_IsNPCMainAnimationAirborne");
static_assert(sizeof(NPCCharacter_IsNPCMainAnimationAirborne) == 0x000002, "Wrong size on NPCCharacter_IsNPCMainAnimationAirborne");
static_assert(offsetof(NPCCharacter_IsNPCMainAnimationAirborne, CheckMainAnimation) == 0x000000, "Member 'NPCCharacter_IsNPCMainAnimationAirborne::CheckMainAnimation' has a wrong offset!");
static_assert(offsetof(NPCCharacter_IsNPCMainAnimationAirborne, ReturnValue) == 0x000001, "Member 'NPCCharacter_IsNPCMainAnimationAirborne::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.BP_OnNPCJustRevivedAnotherNPC
// 0x0010 (0x0010 - 0x0000)
struct NPCCharacter_BP_OnNPCJustRevivedAnotherNPC final
{
public:
	class ANPCCharacter*                          DeadNPC;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Prop;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_BP_OnNPCJustRevivedAnotherNPC) == 0x000008, "Wrong alignment on NPCCharacter_BP_OnNPCJustRevivedAnotherNPC");
static_assert(sizeof(NPCCharacter_BP_OnNPCJustRevivedAnotherNPC) == 0x000010, "Wrong size on NPCCharacter_BP_OnNPCJustRevivedAnotherNPC");
static_assert(offsetof(NPCCharacter_BP_OnNPCJustRevivedAnotherNPC, DeadNPC) == 0x000000, "Member 'NPCCharacter_BP_OnNPCJustRevivedAnotherNPC::DeadNPC' has a wrong offset!");
static_assert(offsetof(NPCCharacter_BP_OnNPCJustRevivedAnotherNPC, Prop) == 0x000008, "Member 'NPCCharacter_BP_OnNPCJustRevivedAnotherNPC::Prop' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.BP_OnNPCRevivingAnotherNPC
// 0x0008 (0x0008 - 0x0000)
struct NPCCharacter_BP_OnNPCRevivingAnotherNPC final
{
public:
	class ANPCCharacter*                          DeadNPC;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_BP_OnNPCRevivingAnotherNPC) == 0x000008, "Wrong alignment on NPCCharacter_BP_OnNPCRevivingAnotherNPC");
static_assert(sizeof(NPCCharacter_BP_OnNPCRevivingAnotherNPC) == 0x000008, "Wrong size on NPCCharacter_BP_OnNPCRevivingAnotherNPC");
static_assert(offsetof(NPCCharacter_BP_OnNPCRevivingAnotherNPC, DeadNPC) == 0x000000, "Member 'NPCCharacter_BP_OnNPCRevivingAnotherNPC::DeadNPC' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.BP_OnPlayReplicatedVO
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_BP_OnPlayReplicatedVO final
{
public:
	ENPCReplicatedVO                              VOType;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_BP_OnPlayReplicatedVO) == 0x000001, "Wrong alignment on NPCCharacter_BP_OnPlayReplicatedVO");
static_assert(sizeof(NPCCharacter_BP_OnPlayReplicatedVO) == 0x000001, "Wrong size on NPCCharacter_BP_OnPlayReplicatedVO");
static_assert(offsetof(NPCCharacter_BP_OnPlayReplicatedVO, VOType) == 0x000000, "Member 'NPCCharacter_BP_OnPlayReplicatedVO::VOType' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.BP_OnScaredChange
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_BP_OnScaredChange final
{
public:
	bool                                          bScaredIn;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_BP_OnScaredChange) == 0x000001, "Wrong alignment on NPCCharacter_BP_OnScaredChange");
static_assert(sizeof(NPCCharacter_BP_OnScaredChange) == 0x000001, "Wrong size on NPCCharacter_BP_OnScaredChange");
static_assert(offsetof(NPCCharacter_BP_OnScaredChange, bScaredIn) == 0x000000, "Member 'NPCCharacter_BP_OnScaredChange::bScaredIn' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.BP_OnScareTriggered
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_BP_OnScareTriggered final
{
public:
	ENPCScaredReason                              ScaredReason;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_BP_OnScareTriggered) == 0x000001, "Wrong alignment on NPCCharacter_BP_OnScareTriggered");
static_assert(sizeof(NPCCharacter_BP_OnScareTriggered) == 0x000001, "Wrong size on NPCCharacter_BP_OnScareTriggered");
static_assert(offsetof(NPCCharacter_BP_OnScareTriggered, ScaredReason) == 0x000000, "Member 'NPCCharacter_BP_OnScareTriggered::ScaredReason' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.BP_SignificanceUpdate
// 0x0008 (0x0008 - 0x0000)
struct NPCCharacter_BP_SignificanceUpdate final
{
public:
	float                                         OldValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_BP_SignificanceUpdate) == 0x000004, "Wrong alignment on NPCCharacter_BP_SignificanceUpdate");
static_assert(sizeof(NPCCharacter_BP_SignificanceUpdate) == 0x000008, "Wrong size on NPCCharacter_BP_SignificanceUpdate");
static_assert(offsetof(NPCCharacter_BP_SignificanceUpdate, OldValue) == 0x000000, "Member 'NPCCharacter_BP_SignificanceUpdate::OldValue' has a wrong offset!");
static_assert(offsetof(NPCCharacter_BP_SignificanceUpdate, NewValue) == 0x000004, "Member 'NPCCharacter_BP_SignificanceUpdate::NewValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.ExternalBounce
// 0x0018 (0x0018 - 0x0000)
struct NPCCharacter_ExternalBounce final
{
public:
	struct FVector                                Impulse;                                           // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 BouncedBy;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_ExternalBounce) == 0x000008, "Wrong alignment on NPCCharacter_ExternalBounce");
static_assert(sizeof(NPCCharacter_ExternalBounce) == 0x000018, "Wrong size on NPCCharacter_ExternalBounce");
static_assert(offsetof(NPCCharacter_ExternalBounce, Impulse) == 0x000000, "Member 'NPCCharacter_ExternalBounce::Impulse' has a wrong offset!");
static_assert(offsetof(NPCCharacter_ExternalBounce, BouncedBy) == 0x000010, "Member 'NPCCharacter_ExternalBounce::BouncedBy' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.HandleInteractionComplete
// 0x0010 (0x0010 - 0x0000)
struct NPCCharacter_HandleInteractionComplete final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_HandleInteractionComplete) == 0x000008, "Wrong alignment on NPCCharacter_HandleInteractionComplete");
static_assert(sizeof(NPCCharacter_HandleInteractionComplete) == 0x000010, "Wrong size on NPCCharacter_HandleInteractionComplete");
static_assert(offsetof(NPCCharacter_HandleInteractionComplete, Interacter) == 0x000000, "Member 'NPCCharacter_HandleInteractionComplete::Interacter' has a wrong offset!");
static_assert(offsetof(NPCCharacter_HandleInteractionComplete, Interactable) == 0x000008, "Member 'NPCCharacter_HandleInteractionComplete::Interactable' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.HandleTakePointDamage
// 0x0058 (0x0058 - 0x0000)
struct NPCCharacter_HandleTakePointDamage final
{
public:
	class AActor*                                 DamagedActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            InstigatedBy;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    FHitComponent;                                     // 0x0028(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ShotFromDirection;                                 // 0x0038(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UDamageType*                      DamageType;                                        // 0x0048(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0050(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_HandleTakePointDamage) == 0x000008, "Wrong alignment on NPCCharacter_HandleTakePointDamage");
static_assert(sizeof(NPCCharacter_HandleTakePointDamage) == 0x000058, "Wrong size on NPCCharacter_HandleTakePointDamage");
static_assert(offsetof(NPCCharacter_HandleTakePointDamage, DamagedActor) == 0x000000, "Member 'NPCCharacter_HandleTakePointDamage::DamagedActor' has a wrong offset!");
static_assert(offsetof(NPCCharacter_HandleTakePointDamage, Damage) == 0x000008, "Member 'NPCCharacter_HandleTakePointDamage::Damage' has a wrong offset!");
static_assert(offsetof(NPCCharacter_HandleTakePointDamage, InstigatedBy) == 0x000010, "Member 'NPCCharacter_HandleTakePointDamage::InstigatedBy' has a wrong offset!");
static_assert(offsetof(NPCCharacter_HandleTakePointDamage, HitLocation) == 0x000018, "Member 'NPCCharacter_HandleTakePointDamage::HitLocation' has a wrong offset!");
static_assert(offsetof(NPCCharacter_HandleTakePointDamage, FHitComponent) == 0x000028, "Member 'NPCCharacter_HandleTakePointDamage::FHitComponent' has a wrong offset!");
static_assert(offsetof(NPCCharacter_HandleTakePointDamage, BoneName) == 0x000030, "Member 'NPCCharacter_HandleTakePointDamage::BoneName' has a wrong offset!");
static_assert(offsetof(NPCCharacter_HandleTakePointDamage, ShotFromDirection) == 0x000038, "Member 'NPCCharacter_HandleTakePointDamage::ShotFromDirection' has a wrong offset!");
static_assert(offsetof(NPCCharacter_HandleTakePointDamage, DamageType) == 0x000048, "Member 'NPCCharacter_HandleTakePointDamage::DamageType' has a wrong offset!");
static_assert(offsetof(NPCCharacter_HandleTakePointDamage, DamageCauser) == 0x000050, "Member 'NPCCharacter_HandleTakePointDamage::DamageCauser' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.IsRightFootForward
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_IsRightFootForward final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_IsRightFootForward) == 0x000001, "Wrong alignment on NPCCharacter_IsRightFootForward");
static_assert(sizeof(NPCCharacter_IsRightFootForward) == 0x000001, "Wrong size on NPCCharacter_IsRightFootForward");
static_assert(offsetof(NPCCharacter_IsRightFootForward, ReturnValue) == 0x000000, "Member 'NPCCharacter_IsRightFootForward::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.MulticastExternalBounce
// 0x0018 (0x0018 - 0x0000)
struct NPCCharacter_MulticastExternalBounce final
{
public:
	struct FVector_NetQuantize                    Impulse;                                           // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 BouncedBy;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_MulticastExternalBounce) == 0x000008, "Wrong alignment on NPCCharacter_MulticastExternalBounce");
static_assert(sizeof(NPCCharacter_MulticastExternalBounce) == 0x000018, "Wrong size on NPCCharacter_MulticastExternalBounce");
static_assert(offsetof(NPCCharacter_MulticastExternalBounce, Impulse) == 0x000000, "Member 'NPCCharacter_MulticastExternalBounce::Impulse' has a wrong offset!");
static_assert(offsetof(NPCCharacter_MulticastExternalBounce, BouncedBy) == 0x000010, "Member 'NPCCharacter_MulticastExternalBounce::BouncedBy' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.NetMulticast_TriggerScared
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_NetMulticast_TriggerScared final
{
public:
	ENPCScaredReason                              ScaredReason;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_NetMulticast_TriggerScared) == 0x000001, "Wrong alignment on NPCCharacter_NetMulticast_TriggerScared");
static_assert(sizeof(NPCCharacter_NetMulticast_TriggerScared) == 0x000001, "Wrong size on NPCCharacter_NetMulticast_TriggerScared");
static_assert(offsetof(NPCCharacter_NetMulticast_TriggerScared, ScaredReason) == 0x000000, "Member 'NPCCharacter_NetMulticast_TriggerScared::ScaredReason' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.OnConversationNewTalkingNPC
// 0x0010 (0x0010 - 0x0000)
struct NPCCharacter_OnConversationNewTalkingNPC final
{
public:
	class UNPCConversationComponent*              ConversationInteractionComp;                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANPCCharacter*                          TalkingNPC;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_OnConversationNewTalkingNPC) == 0x000008, "Wrong alignment on NPCCharacter_OnConversationNewTalkingNPC");
static_assert(sizeof(NPCCharacter_OnConversationNewTalkingNPC) == 0x000010, "Wrong size on NPCCharacter_OnConversationNewTalkingNPC");
static_assert(offsetof(NPCCharacter_OnConversationNewTalkingNPC, ConversationInteractionComp) == 0x000000, "Member 'NPCCharacter_OnConversationNewTalkingNPC::ConversationInteractionComp' has a wrong offset!");
static_assert(offsetof(NPCCharacter_OnConversationNewTalkingNPC, TalkingNPC) == 0x000008, "Member 'NPCCharacter_OnConversationNewTalkingNPC::TalkingNPC' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.OnDeath
// 0x0008 (0x0008 - 0x0000)
struct NPCCharacter_OnDeath final
{
public:
	class AActor*                                 DeadActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_OnDeath) == 0x000008, "Wrong alignment on NPCCharacter_OnDeath");
static_assert(sizeof(NPCCharacter_OnDeath) == 0x000008, "Wrong size on NPCCharacter_OnDeath");
static_assert(offsetof(NPCCharacter_OnDeath, DeadActor) == 0x000000, "Member 'NPCCharacter_OnDeath::DeadActor' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.OnHealthChanged
// 0x0030 (0x0030 - 0x0000)
struct NPCCharacter_OnHealthChanged final
{
public:
	class UHealthComponent*                       OwningHealthComp;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthDelta;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDamageType*                      DamageType;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RawDamage;                                         // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NPCCharacter_OnHealthChanged) == 0x000008, "Wrong alignment on NPCCharacter_OnHealthChanged");
static_assert(sizeof(NPCCharacter_OnHealthChanged) == 0x000030, "Wrong size on NPCCharacter_OnHealthChanged");
static_assert(offsetof(NPCCharacter_OnHealthChanged, OwningHealthComp) == 0x000000, "Member 'NPCCharacter_OnHealthChanged::OwningHealthComp' has a wrong offset!");
static_assert(offsetof(NPCCharacter_OnHealthChanged, Health) == 0x000008, "Member 'NPCCharacter_OnHealthChanged::Health' has a wrong offset!");
static_assert(offsetof(NPCCharacter_OnHealthChanged, HealthDelta) == 0x00000C, "Member 'NPCCharacter_OnHealthChanged::HealthDelta' has a wrong offset!");
static_assert(offsetof(NPCCharacter_OnHealthChanged, DamageType) == 0x000010, "Member 'NPCCharacter_OnHealthChanged::DamageType' has a wrong offset!");
static_assert(offsetof(NPCCharacter_OnHealthChanged, InstigatedBy) == 0x000018, "Member 'NPCCharacter_OnHealthChanged::InstigatedBy' has a wrong offset!");
static_assert(offsetof(NPCCharacter_OnHealthChanged, DamageCauser) == 0x000020, "Member 'NPCCharacter_OnHealthChanged::DamageCauser' has a wrong offset!");
static_assert(offsetof(NPCCharacter_OnHealthChanged, RawDamage) == 0x000028, "Member 'NPCCharacter_OnHealthChanged::RawDamage' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.OnRep_LookAtData
// 0x000C (0x000C - 0x0000)
struct NPCCharacter_OnRep_LookAtData final
{
public:
	struct FNPCLookAtReplicationData              PrevLookAtData;                                    // 0x0000(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_OnRep_LookAtData) == 0x000004, "Wrong alignment on NPCCharacter_OnRep_LookAtData");
static_assert(sizeof(NPCCharacter_OnRep_LookAtData) == 0x00000C, "Wrong size on NPCCharacter_OnRep_LookAtData");
static_assert(offsetof(NPCCharacter_OnRep_LookAtData, PrevLookAtData) == 0x000000, "Member 'NPCCharacter_OnRep_LookAtData::PrevLookAtData' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.OnRep_MainAnimation
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_OnRep_MainAnimation final
{
public:
	ENPCMainAnimation                             PrevMainAnimation;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_OnRep_MainAnimation) == 0x000001, "Wrong alignment on NPCCharacter_OnRep_MainAnimation");
static_assert(sizeof(NPCCharacter_OnRep_MainAnimation) == 0x000001, "Wrong size on NPCCharacter_OnRep_MainAnimation");
static_assert(offsetof(NPCCharacter_OnRep_MainAnimation, PrevMainAnimation) == 0x000000, "Member 'NPCCharacter_OnRep_MainAnimation::PrevMainAnimation' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.OnRep_MovementData
// 0x0010 (0x0010 - 0x0000)
struct NPCCharacter_OnRep_MovementData final
{
public:
	struct FNPCMovementReplicationData            PrevMovementData;                                  // 0x0000(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_OnRep_MovementData) == 0x000004, "Wrong alignment on NPCCharacter_OnRep_MovementData");
static_assert(sizeof(NPCCharacter_OnRep_MovementData) == 0x000010, "Wrong size on NPCCharacter_OnRep_MovementData");
static_assert(offsetof(NPCCharacter_OnRep_MovementData, PrevMovementData) == 0x000000, "Member 'NPCCharacter_OnRep_MovementData::PrevMovementData' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.OnRep_ReplicatedInteraction
// 0x0008 (0x0008 - 0x0000)
struct NPCCharacter_OnRep_ReplicatedInteraction final
{
public:
	class AActor*                                 PrevReplicatedInteraction;                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_OnRep_ReplicatedInteraction) == 0x000008, "Wrong alignment on NPCCharacter_OnRep_ReplicatedInteraction");
static_assert(sizeof(NPCCharacter_OnRep_ReplicatedInteraction) == 0x000008, "Wrong size on NPCCharacter_OnRep_ReplicatedInteraction");
static_assert(offsetof(NPCCharacter_OnRep_ReplicatedInteraction, PrevReplicatedInteraction) == 0x000000, "Member 'NPCCharacter_OnRep_ReplicatedInteraction::PrevReplicatedInteraction' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.OnRep_Running
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_OnRep_Running final
{
public:
	bool                                          PrevRunning;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_OnRep_Running) == 0x000001, "Wrong alignment on NPCCharacter_OnRep_Running");
static_assert(sizeof(NPCCharacter_OnRep_Running) == 0x000001, "Wrong size on NPCCharacter_OnRep_Running");
static_assert(offsetof(NPCCharacter_OnRep_Running, PrevRunning) == 0x000000, "Member 'NPCCharacter_OnRep_Running::PrevRunning' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.OnRep_Scared
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_OnRep_Scared final
{
public:
	bool                                          PrevScared;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_OnRep_Scared) == 0x000001, "Wrong alignment on NPCCharacter_OnRep_Scared");
static_assert(sizeof(NPCCharacter_OnRep_Scared) == 0x000001, "Wrong size on NPCCharacter_OnRep_Scared");
static_assert(offsetof(NPCCharacter_OnRep_Scared, PrevScared) == 0x000000, "Member 'NPCCharacter_OnRep_Scared::PrevScared' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.OnRep_ScoldState
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_OnRep_ScoldState final
{
public:
	EScoldState                                   PrevScoldState;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_OnRep_ScoldState) == 0x000001, "Wrong alignment on NPCCharacter_OnRep_ScoldState");
static_assert(sizeof(NPCCharacter_OnRep_ScoldState) == 0x000001, "Wrong size on NPCCharacter_OnRep_ScoldState");
static_assert(offsetof(NPCCharacter_OnRep_ScoldState, PrevScoldState) == 0x000000, "Member 'NPCCharacter_OnRep_ScoldState::PrevScoldState' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.OnRevive
// 0x0008 (0x0008 - 0x0000)
struct NPCCharacter_OnRevive final
{
public:
	class AActor*                                 DeadActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_OnRevive) == 0x000008, "Wrong alignment on NPCCharacter_OnRevive");
static_assert(sizeof(NPCCharacter_OnRevive) == 0x000008, "Wrong size on NPCCharacter_OnRevive");
static_assert(offsetof(NPCCharacter_OnRevive, DeadActor) == 0x000000, "Member 'NPCCharacter_OnRevive::DeadActor' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.PlayReplicatedVO
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_PlayReplicatedVO final
{
public:
	ENPCReplicatedVO                              VOType;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_PlayReplicatedVO) == 0x000001, "Wrong alignment on NPCCharacter_PlayReplicatedVO");
static_assert(sizeof(NPCCharacter_PlayReplicatedVO) == 0x000001, "Wrong size on NPCCharacter_PlayReplicatedVO");
static_assert(offsetof(NPCCharacter_PlayReplicatedVO, VOType) == 0x000000, "Member 'NPCCharacter_PlayReplicatedVO::VOType' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.SetUpperBodyBoneGroup
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_SetUpperBodyBoneGroup final
{
public:
	ENPCUpperBodyBoneGroup                        NewBoneGroup;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_SetUpperBodyBoneGroup) == 0x000001, "Wrong alignment on NPCCharacter_SetUpperBodyBoneGroup");
static_assert(sizeof(NPCCharacter_SetUpperBodyBoneGroup) == 0x000001, "Wrong size on NPCCharacter_SetUpperBodyBoneGroup");
static_assert(offsetof(NPCCharacter_SetUpperBodyBoneGroup, NewBoneGroup) == 0x000000, "Member 'NPCCharacter_SetUpperBodyBoneGroup::NewBoneGroup' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.SpawnProp
// 0x0018 (0x0018 - 0x0000)
struct NPCCharacter_SpawnProp final
{
public:
	TSubclassOf<class AActor>                     ActorClassToSpawn;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneAttachName;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_SpawnProp) == 0x000008, "Wrong alignment on NPCCharacter_SpawnProp");
static_assert(sizeof(NPCCharacter_SpawnProp) == 0x000018, "Wrong size on NPCCharacter_SpawnProp");
static_assert(offsetof(NPCCharacter_SpawnProp, ActorClassToSpawn) == 0x000000, "Member 'NPCCharacter_SpawnProp::ActorClassToSpawn' has a wrong offset!");
static_assert(offsetof(NPCCharacter_SpawnProp, BoneAttachName) == 0x000008, "Member 'NPCCharacter_SpawnProp::BoneAttachName' has a wrong offset!");
static_assert(offsetof(NPCCharacter_SpawnProp, ReturnValue) == 0x000010, "Member 'NPCCharacter_SpawnProp::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.CanEverBeAggroed
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_CanEverBeAggroed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_CanEverBeAggroed) == 0x000001, "Wrong alignment on NPCCharacter_CanEverBeAggroed");
static_assert(sizeof(NPCCharacter_CanEverBeAggroed) == 0x000001, "Wrong size on NPCCharacter_CanEverBeAggroed");
static_assert(offsetof(NPCCharacter_CanEverBeAggroed, ReturnValue) == 0x000000, "Member 'NPCCharacter_CanEverBeAggroed::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.GetControllingSpy
// 0x0008 (0x0008 - 0x0000)
struct NPCCharacter_GetControllingSpy final
{
public:
	class ASpy*                                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_GetControllingSpy) == 0x000008, "Wrong alignment on NPCCharacter_GetControllingSpy");
static_assert(sizeof(NPCCharacter_GetControllingSpy) == 0x000008, "Wrong size on NPCCharacter_GetControllingSpy");
static_assert(offsetof(NPCCharacter_GetControllingSpy, ReturnValue) == 0x000000, "Member 'NPCCharacter_GetControllingSpy::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.GetCurrentProp
// 0x0008 (0x0008 - 0x0000)
struct NPCCharacter_GetCurrentProp final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_GetCurrentProp) == 0x000008, "Wrong alignment on NPCCharacter_GetCurrentProp");
static_assert(sizeof(NPCCharacter_GetCurrentProp) == 0x000008, "Wrong size on NPCCharacter_GetCurrentProp");
static_assert(offsetof(NPCCharacter_GetCurrentProp, ReturnValue) == 0x000000, "Member 'NPCCharacter_GetCurrentProp::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.GetEffectOfClass
// 0x0010 (0x0010 - 0x0000)
struct NPCCharacter_GetEffectOfClass final
{
public:
	class UClass*                                 EffectClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVictimEffect*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_GetEffectOfClass) == 0x000008, "Wrong alignment on NPCCharacter_GetEffectOfClass");
static_assert(sizeof(NPCCharacter_GetEffectOfClass) == 0x000010, "Wrong size on NPCCharacter_GetEffectOfClass");
static_assert(offsetof(NPCCharacter_GetEffectOfClass, EffectClass) == 0x000000, "Member 'NPCCharacter_GetEffectOfClass::EffectClass' has a wrong offset!");
static_assert(offsetof(NPCCharacter_GetEffectOfClass, ReturnValue) == 0x000008, "Member 'NPCCharacter_GetEffectOfClass::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.GetGuardComponent
// 0x0008 (0x0008 - 0x0000)
struct NPCCharacter_GetGuardComponent final
{
public:
	class UNPCGuardComponent*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_GetGuardComponent) == 0x000008, "Wrong alignment on NPCCharacter_GetGuardComponent");
static_assert(sizeof(NPCCharacter_GetGuardComponent) == 0x000008, "Wrong size on NPCCharacter_GetGuardComponent");
static_assert(offsetof(NPCCharacter_GetGuardComponent, ReturnValue) == 0x000000, "Member 'NPCCharacter_GetGuardComponent::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.GetInteractableType
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_GetInteractableType final
{
public:
	EInteractableType                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_GetInteractableType) == 0x000001, "Wrong alignment on NPCCharacter_GetInteractableType");
static_assert(sizeof(NPCCharacter_GetInteractableType) == 0x000001, "Wrong size on NPCCharacter_GetInteractableType");
static_assert(offsetof(NPCCharacter_GetInteractableType, ReturnValue) == 0x000000, "Member 'NPCCharacter_GetInteractableType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.GetKillerData
// 0x0010 (0x0010 - 0x0000)
struct NPCCharacter_GetKillerData final
{
public:
	struct FLastInteractionData                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_GetKillerData) == 0x000008, "Wrong alignment on NPCCharacter_GetKillerData");
static_assert(sizeof(NPCCharacter_GetKillerData) == 0x000010, "Wrong size on NPCCharacter_GetKillerData");
static_assert(offsetof(NPCCharacter_GetKillerData, ReturnValue) == 0x000000, "Member 'NPCCharacter_GetKillerData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.GetNPCPool
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_GetNPCPool final
{
public:
	ENPCPool                                      ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_GetNPCPool) == 0x000001, "Wrong alignment on NPCCharacter_GetNPCPool");
static_assert(sizeof(NPCCharacter_GetNPCPool) == 0x000001, "Wrong size on NPCCharacter_GetNPCPool");
static_assert(offsetof(NPCCharacter_GetNPCPool, ReturnValue) == 0x000000, "Member 'NPCCharacter_GetNPCPool::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.GetSecurityLevel
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_GetSecurityLevel final
{
public:
	ESecurityLevel                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_GetSecurityLevel) == 0x000001, "Wrong alignment on NPCCharacter_GetSecurityLevel");
static_assert(sizeof(NPCCharacter_GetSecurityLevel) == 0x000001, "Wrong size on NPCCharacter_GetSecurityLevel");
static_assert(offsetof(NPCCharacter_GetSecurityLevel, ReturnValue) == 0x000000, "Member 'NPCCharacter_GetSecurityLevel::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.GetUpperBodyBoneGroup
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_GetUpperBodyBoneGroup final
{
public:
	ENPCUpperBodyBoneGroup                        ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_GetUpperBodyBoneGroup) == 0x000001, "Wrong alignment on NPCCharacter_GetUpperBodyBoneGroup");
static_assert(sizeof(NPCCharacter_GetUpperBodyBoneGroup) == 0x000001, "Wrong size on NPCCharacter_GetUpperBodyBoneGroup");
static_assert(offsetof(NPCCharacter_GetUpperBodyBoneGroup, ReturnValue) == 0x000000, "Member 'NPCCharacter_GetUpperBodyBoneGroup::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.GetWalkDirection
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_GetWalkDirection final
{
public:
	ENPCWalkDirection                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_GetWalkDirection) == 0x000001, "Wrong alignment on NPCCharacter_GetWalkDirection");
static_assert(sizeof(NPCCharacter_GetWalkDirection) == 0x000001, "Wrong size on NPCCharacter_GetWalkDirection");
static_assert(offsetof(NPCCharacter_GetWalkDirection, ReturnValue) == 0x000000, "Member 'NPCCharacter_GetWalkDirection::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.IsActorFlaggedAsIgnoreHeat
// 0x0010 (0x0010 - 0x0000)
struct NPCCharacter_IsActorFlaggedAsIgnoreHeat final
{
public:
	class AActor*                                 FlaggedActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NPCCharacter_IsActorFlaggedAsIgnoreHeat) == 0x000008, "Wrong alignment on NPCCharacter_IsActorFlaggedAsIgnoreHeat");
static_assert(sizeof(NPCCharacter_IsActorFlaggedAsIgnoreHeat) == 0x000010, "Wrong size on NPCCharacter_IsActorFlaggedAsIgnoreHeat");
static_assert(offsetof(NPCCharacter_IsActorFlaggedAsIgnoreHeat, FlaggedActor) == 0x000000, "Member 'NPCCharacter_IsActorFlaggedAsIgnoreHeat::FlaggedActor' has a wrong offset!");
static_assert(offsetof(NPCCharacter_IsActorFlaggedAsIgnoreHeat, ReturnValue) == 0x000008, "Member 'NPCCharacter_IsActorFlaggedAsIgnoreHeat::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.IsAggroed
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_IsAggroed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_IsAggroed) == 0x000001, "Wrong alignment on NPCCharacter_IsAggroed");
static_assert(sizeof(NPCCharacter_IsAggroed) == 0x000001, "Wrong size on NPCCharacter_IsAggroed");
static_assert(offsetof(NPCCharacter_IsAggroed, ReturnValue) == 0x000000, "Member 'NPCCharacter_IsAggroed::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.IsControlledBySpy
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_IsControlledBySpy final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_IsControlledBySpy) == 0x000001, "Wrong alignment on NPCCharacter_IsControlledBySpy");
static_assert(sizeof(NPCCharacter_IsControlledBySpy) == 0x000001, "Wrong size on NPCCharacter_IsControlledBySpy");
static_assert(offsetof(NPCCharacter_IsControlledBySpy, ReturnValue) == 0x000000, "Member 'NPCCharacter_IsControlledBySpy::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.IsDead
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_IsDead final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_IsDead) == 0x000001, "Wrong alignment on NPCCharacter_IsDead");
static_assert(sizeof(NPCCharacter_IsDead) == 0x000001, "Wrong size on NPCCharacter_IsDead");
static_assert(offsetof(NPCCharacter_IsDead, ReturnValue) == 0x000000, "Member 'NPCCharacter_IsDead::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.IsFlaggedAsXiuDecoy
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_IsFlaggedAsXiuDecoy final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_IsFlaggedAsXiuDecoy) == 0x000001, "Wrong alignment on NPCCharacter_IsFlaggedAsXiuDecoy");
static_assert(sizeof(NPCCharacter_IsFlaggedAsXiuDecoy) == 0x000001, "Wrong size on NPCCharacter_IsFlaggedAsXiuDecoy");
static_assert(offsetof(NPCCharacter_IsFlaggedAsXiuDecoy, ReturnValue) == 0x000000, "Member 'NPCCharacter_IsFlaggedAsXiuDecoy::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.IsFollowingVIP
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_IsFollowingVIP final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_IsFollowingVIP) == 0x000001, "Wrong alignment on NPCCharacter_IsFollowingVIP");
static_assert(sizeof(NPCCharacter_IsFollowingVIP) == 0x000001, "Wrong size on NPCCharacter_IsFollowingVIP");
static_assert(offsetof(NPCCharacter_IsFollowingVIP, ReturnValue) == 0x000000, "Member 'NPCCharacter_IsFollowingVIP::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.IsRunDisabled
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_IsRunDisabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_IsRunDisabled) == 0x000001, "Wrong alignment on NPCCharacter_IsRunDisabled");
static_assert(sizeof(NPCCharacter_IsRunDisabled) == 0x000001, "Wrong size on NPCCharacter_IsRunDisabled");
static_assert(offsetof(NPCCharacter_IsRunDisabled, ReturnValue) == 0x000000, "Member 'NPCCharacter_IsRunDisabled::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.IsRunning
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_IsRunning final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_IsRunning) == 0x000001, "Wrong alignment on NPCCharacter_IsRunning");
static_assert(sizeof(NPCCharacter_IsRunning) == 0x000001, "Wrong size on NPCCharacter_IsRunning");
static_assert(offsetof(NPCCharacter_IsRunning, ReturnValue) == 0x000000, "Member 'NPCCharacter_IsRunning::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.IsScared
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_IsScared final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_IsScared) == 0x000001, "Wrong alignment on NPCCharacter_IsScared");
static_assert(sizeof(NPCCharacter_IsScared) == 0x000001, "Wrong size on NPCCharacter_IsScared");
static_assert(offsetof(NPCCharacter_IsScared, ReturnValue) == 0x000000, "Member 'NPCCharacter_IsScared::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCCharacter.IsScolding
// 0x0001 (0x0001 - 0x0000)
struct NPCCharacter_IsScolding final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCCharacter_IsScolding) == 0x000001, "Wrong alignment on NPCCharacter_IsScolding");
static_assert(sizeof(NPCCharacter_IsScolding) == 0x000001, "Wrong size on NPCCharacter_IsScolding");
static_assert(offsetof(NPCCharacter_IsScolding, ReturnValue) == 0x000000, "Member 'NPCCharacter_IsScolding::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.CatalogueIsItemPremiumLocked
// 0x0018 (0x0018 - 0x0000)
struct DIStoreSubsystem_CatalogueIsItemPremiumLocked final
{
public:
	const class UStoreCatalogEntryData*           Catalogue;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDIItem*                          ItemToChheck;                                      // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIStoreSubsystem_CatalogueIsItemPremiumLocked) == 0x000008, "Wrong alignment on DIStoreSubsystem_CatalogueIsItemPremiumLocked");
static_assert(sizeof(DIStoreSubsystem_CatalogueIsItemPremiumLocked) == 0x000018, "Wrong size on DIStoreSubsystem_CatalogueIsItemPremiumLocked");
static_assert(offsetof(DIStoreSubsystem_CatalogueIsItemPremiumLocked, Catalogue) == 0x000000, "Member 'DIStoreSubsystem_CatalogueIsItemPremiumLocked::Catalogue' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_CatalogueIsItemPremiumLocked, ItemToChheck) == 0x000008, "Member 'DIStoreSubsystem_CatalogueIsItemPremiumLocked::ItemToChheck' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_CatalogueIsItemPremiumLocked, ReturnValue) == 0x000010, "Member 'DIStoreSubsystem_CatalogueIsItemPremiumLocked::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.GetAllItemsOfType
// 0x0020 (0x0020 - 0x0000)
struct DIStoreSubsystem_GetAllItemsOfType final
{
public:
	EDIITemTypeQuery                              ItemType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinRarity;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRarity;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShopOnly;                                         // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverse;                                          // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDIItem*>                        ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIStoreSubsystem_GetAllItemsOfType) == 0x000008, "Wrong alignment on DIStoreSubsystem_GetAllItemsOfType");
static_assert(sizeof(DIStoreSubsystem_GetAllItemsOfType) == 0x000020, "Wrong size on DIStoreSubsystem_GetAllItemsOfType");
static_assert(offsetof(DIStoreSubsystem_GetAllItemsOfType, ItemType) == 0x000000, "Member 'DIStoreSubsystem_GetAllItemsOfType::ItemType' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_GetAllItemsOfType, MinRarity) == 0x000004, "Member 'DIStoreSubsystem_GetAllItemsOfType::MinRarity' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_GetAllItemsOfType, MaxRarity) == 0x000008, "Member 'DIStoreSubsystem_GetAllItemsOfType::MaxRarity' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_GetAllItemsOfType, bShopOnly) == 0x00000C, "Member 'DIStoreSubsystem_GetAllItemsOfType::bShopOnly' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_GetAllItemsOfType, bReverse) == 0x00000D, "Member 'DIStoreSubsystem_GetAllItemsOfType::bReverse' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_GetAllItemsOfType, ReturnValue) == 0x000010, "Member 'DIStoreSubsystem_GetAllItemsOfType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.GetCurrencyFromCurrencyId
// 0x0018 (0x0018 - 0x0000)
struct DIStoreSubsystem_GetCurrencyFromCurrencyId final
{
public:
	class FString                                 CurrencyId;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDICurrencyItem*                        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIStoreSubsystem_GetCurrencyFromCurrencyId) == 0x000008, "Wrong alignment on DIStoreSubsystem_GetCurrencyFromCurrencyId");
static_assert(sizeof(DIStoreSubsystem_GetCurrencyFromCurrencyId) == 0x000018, "Wrong size on DIStoreSubsystem_GetCurrencyFromCurrencyId");
static_assert(offsetof(DIStoreSubsystem_GetCurrencyFromCurrencyId, CurrencyId) == 0x000000, "Member 'DIStoreSubsystem_GetCurrencyFromCurrencyId::CurrencyId' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_GetCurrencyFromCurrencyId, ReturnValue) == 0x000010, "Member 'DIStoreSubsystem_GetCurrencyFromCurrencyId::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.GetIsRotationEnabled
// 0x0001 (0x0001 - 0x0000)
struct DIStoreSubsystem_GetIsRotationEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIStoreSubsystem_GetIsRotationEnabled) == 0x000001, "Wrong alignment on DIStoreSubsystem_GetIsRotationEnabled");
static_assert(sizeof(DIStoreSubsystem_GetIsRotationEnabled) == 0x000001, "Wrong size on DIStoreSubsystem_GetIsRotationEnabled");
static_assert(offsetof(DIStoreSubsystem_GetIsRotationEnabled, ReturnValue) == 0x000000, "Member 'DIStoreSubsystem_GetIsRotationEnabled::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.GetItemFromAssetId
// 0x0018 (0x0018 - 0x0000)
struct DIStoreSubsystem_GetItemFromAssetId final
{
public:
	struct FPrimaryAssetId                        AssetId;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDIItem*                                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIStoreSubsystem_GetItemFromAssetId) == 0x000008, "Wrong alignment on DIStoreSubsystem_GetItemFromAssetId");
static_assert(sizeof(DIStoreSubsystem_GetItemFromAssetId) == 0x000018, "Wrong size on DIStoreSubsystem_GetItemFromAssetId");
static_assert(offsetof(DIStoreSubsystem_GetItemFromAssetId, AssetId) == 0x000000, "Member 'DIStoreSubsystem_GetItemFromAssetId::AssetId' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_GetItemFromAssetId, ReturnValue) == 0x000010, "Member 'DIStoreSubsystem_GetItemFromAssetId::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.GetItemFromItemId
// 0x0018 (0x0018 - 0x0000)
struct DIStoreSubsystem_GetItemFromItemId final
{
public:
	class FString                                 ItemId;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDIItem*                                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIStoreSubsystem_GetItemFromItemId) == 0x000008, "Wrong alignment on DIStoreSubsystem_GetItemFromItemId");
static_assert(sizeof(DIStoreSubsystem_GetItemFromItemId) == 0x000018, "Wrong size on DIStoreSubsystem_GetItemFromItemId");
static_assert(offsetof(DIStoreSubsystem_GetItemFromItemId, ItemId) == 0x000000, "Member 'DIStoreSubsystem_GetItemFromItemId::ItemId' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_GetItemFromItemId, ReturnValue) == 0x000010, "Member 'DIStoreSubsystem_GetItemFromItemId::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.GetTimeUntilRotation
// 0x0018 (0x0018 - 0x0000)
struct DIStoreSubsystem_GetTimeUntilRotation final
{
public:
	class FString                                 TimeLeft;                                          // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIStoreSubsystem_GetTimeUntilRotation) == 0x000008, "Wrong alignment on DIStoreSubsystem_GetTimeUntilRotation");
static_assert(sizeof(DIStoreSubsystem_GetTimeUntilRotation) == 0x000018, "Wrong size on DIStoreSubsystem_GetTimeUntilRotation");
static_assert(offsetof(DIStoreSubsystem_GetTimeUntilRotation, TimeLeft) == 0x000000, "Member 'DIStoreSubsystem_GetTimeUntilRotation::TimeLeft' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_GetTimeUntilRotation, Ratio) == 0x000010, "Member 'DIStoreSubsystem_GetTimeUntilRotation::Ratio' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.GetXPBoosterActiveTime
// 0x0004 (0x0004 - 0x0000)
struct DIStoreSubsystem_GetXPBoosterActiveTime final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIStoreSubsystem_GetXPBoosterActiveTime) == 0x000004, "Wrong alignment on DIStoreSubsystem_GetXPBoosterActiveTime");
static_assert(sizeof(DIStoreSubsystem_GetXPBoosterActiveTime) == 0x000004, "Wrong size on DIStoreSubsystem_GetXPBoosterActiveTime");
static_assert(offsetof(DIStoreSubsystem_GetXPBoosterActiveTime, ReturnValue) == 0x000000, "Member 'DIStoreSubsystem_GetXPBoosterActiveTime::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.GetXPBoosterID
// 0x0010 (0x0010 - 0x0000)
struct DIStoreSubsystem_GetXPBoosterID final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIStoreSubsystem_GetXPBoosterID) == 0x000008, "Wrong alignment on DIStoreSubsystem_GetXPBoosterID");
static_assert(sizeof(DIStoreSubsystem_GetXPBoosterID) == 0x000010, "Wrong size on DIStoreSubsystem_GetXPBoosterID");
static_assert(offsetof(DIStoreSubsystem_GetXPBoosterID, ReturnValue) == 0x000000, "Member 'DIStoreSubsystem_GetXPBoosterID::ReturnValue' has a wrong offset!");

// DelegateFunction DeceiveInc.DIStoreSubsystem.OnWalletUpdated__DelegateSignature
// 0x00A0 (0x00A0 - 0x0000)
struct DIStoreSubsystem_OnWalletUpdated__DelegateSignature final
{
public:
	struct FAccelByteModelsWalletInfo             WalletInfo;                                        // 0x0000(0x00A0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIStoreSubsystem_OnWalletUpdated__DelegateSignature) == 0x000008, "Wrong alignment on DIStoreSubsystem_OnWalletUpdated__DelegateSignature");
static_assert(sizeof(DIStoreSubsystem_OnWalletUpdated__DelegateSignature) == 0x0000A0, "Wrong size on DIStoreSubsystem_OnWalletUpdated__DelegateSignature");
static_assert(offsetof(DIStoreSubsystem_OnWalletUpdated__DelegateSignature, WalletInfo) == 0x000000, "Member 'DIStoreSubsystem_OnWalletUpdated__DelegateSignature::WalletInfo' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.CanPurchaseItemWithCurrency
// 0x0018 (0x0018 - 0x0000)
struct DIStoreSubsystem_CanPurchaseItemWithCurrency final
{
public:
	const class UDIItem*                          ItemToCheck;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDICurrencyItem*                  CurrencyType;                                      // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrencyAmount;                                    // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIStoreSubsystem_CanPurchaseItemWithCurrency) == 0x000008, "Wrong alignment on DIStoreSubsystem_CanPurchaseItemWithCurrency");
static_assert(sizeof(DIStoreSubsystem_CanPurchaseItemWithCurrency) == 0x000018, "Wrong size on DIStoreSubsystem_CanPurchaseItemWithCurrency");
static_assert(offsetof(DIStoreSubsystem_CanPurchaseItemWithCurrency, ItemToCheck) == 0x000000, "Member 'DIStoreSubsystem_CanPurchaseItemWithCurrency::ItemToCheck' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_CanPurchaseItemWithCurrency, CurrencyType) == 0x000008, "Member 'DIStoreSubsystem_CanPurchaseItemWithCurrency::CurrencyType' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_CanPurchaseItemWithCurrency, CurrencyAmount) == 0x000010, "Member 'DIStoreSubsystem_CanPurchaseItemWithCurrency::CurrencyAmount' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_CanPurchaseItemWithCurrency, ReturnValue) == 0x000014, "Member 'DIStoreSubsystem_CanPurchaseItemWithCurrency::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.CatalogueCanPurchaseItem
// 0x0010 (0x0010 - 0x0000)
struct DIStoreSubsystem_CatalogueCanPurchaseItem final
{
public:
	const class UDIItem*                          ItemToCheck;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIStoreSubsystem_CatalogueCanPurchaseItem) == 0x000008, "Wrong alignment on DIStoreSubsystem_CatalogueCanPurchaseItem");
static_assert(sizeof(DIStoreSubsystem_CatalogueCanPurchaseItem) == 0x000010, "Wrong size on DIStoreSubsystem_CatalogueCanPurchaseItem");
static_assert(offsetof(DIStoreSubsystem_CatalogueCanPurchaseItem, ItemToCheck) == 0x000000, "Member 'DIStoreSubsystem_CatalogueCanPurchaseItem::ItemToCheck' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_CatalogueCanPurchaseItem, ReturnValue) == 0x000008, "Member 'DIStoreSubsystem_CatalogueCanPurchaseItem::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.CatalogueCheckPageCompleted
// 0x0068 (0x0068 - 0x0000)
struct DIStoreSubsystem_CatalogueCheckPageCompleted final
{
public:
	struct FStoreCatalogEntryPageData             PageToCheck;                                       // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         NbItemsUnlocked;                                   // 0x0060(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0064(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIStoreSubsystem_CatalogueCheckPageCompleted) == 0x000008, "Wrong alignment on DIStoreSubsystem_CatalogueCheckPageCompleted");
static_assert(sizeof(DIStoreSubsystem_CatalogueCheckPageCompleted) == 0x000068, "Wrong size on DIStoreSubsystem_CatalogueCheckPageCompleted");
static_assert(offsetof(DIStoreSubsystem_CatalogueCheckPageCompleted, PageToCheck) == 0x000000, "Member 'DIStoreSubsystem_CatalogueCheckPageCompleted::PageToCheck' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_CatalogueCheckPageCompleted, NbItemsUnlocked) == 0x000060, "Member 'DIStoreSubsystem_CatalogueCheckPageCompleted::NbItemsUnlocked' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_CatalogueCheckPageCompleted, ReturnValue) == 0x000064, "Member 'DIStoreSubsystem_CatalogueCheckPageCompleted::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.CatalogueGetCurrentPage
// 0x0010 (0x0010 - 0x0000)
struct DIStoreSubsystem_CatalogueGetCurrentPage final
{
public:
	const class UStoreCatalogEntryData*           Catalogue;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIStoreSubsystem_CatalogueGetCurrentPage) == 0x000008, "Wrong alignment on DIStoreSubsystem_CatalogueGetCurrentPage");
static_assert(sizeof(DIStoreSubsystem_CatalogueGetCurrentPage) == 0x000010, "Wrong size on DIStoreSubsystem_CatalogueGetCurrentPage");
static_assert(offsetof(DIStoreSubsystem_CatalogueGetCurrentPage, Catalogue) == 0x000000, "Member 'DIStoreSubsystem_CatalogueGetCurrentPage::Catalogue' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_CatalogueGetCurrentPage, ReturnValue) == 0x000008, "Member 'DIStoreSubsystem_CatalogueGetCurrentPage::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.CatalogueIsCurrentSeason
// 0x0010 (0x0010 - 0x0000)
struct DIStoreSubsystem_CatalogueIsCurrentSeason final
{
public:
	const class UStoreCatalogEntryData*           Catalogue;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIStoreSubsystem_CatalogueIsCurrentSeason) == 0x000008, "Wrong alignment on DIStoreSubsystem_CatalogueIsCurrentSeason");
static_assert(sizeof(DIStoreSubsystem_CatalogueIsCurrentSeason) == 0x000010, "Wrong size on DIStoreSubsystem_CatalogueIsCurrentSeason");
static_assert(offsetof(DIStoreSubsystem_CatalogueIsCurrentSeason, Catalogue) == 0x000000, "Member 'DIStoreSubsystem_CatalogueIsCurrentSeason::Catalogue' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_CatalogueIsCurrentSeason, ReturnValue) == 0x000008, "Member 'DIStoreSubsystem_CatalogueIsCurrentSeason::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.GetBundleContainingItem
// 0x0010 (0x0010 - 0x0000)
struct DIStoreSubsystem_GetBundleContainingItem final
{
public:
	const class UDIItem*                          ToFind;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDIItem*                                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIStoreSubsystem_GetBundleContainingItem) == 0x000008, "Wrong alignment on DIStoreSubsystem_GetBundleContainingItem");
static_assert(sizeof(DIStoreSubsystem_GetBundleContainingItem) == 0x000010, "Wrong size on DIStoreSubsystem_GetBundleContainingItem");
static_assert(offsetof(DIStoreSubsystem_GetBundleContainingItem, ToFind) == 0x000000, "Member 'DIStoreSubsystem_GetBundleContainingItem::ToFind' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_GetBundleContainingItem, ReturnValue) == 0x000008, "Member 'DIStoreSubsystem_GetBundleContainingItem::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.GetCatalogForAgent
// 0x0010 (0x0010 - 0x0000)
struct DIStoreSubsystem_GetCatalogForAgent final
{
public:
	const class UDIItem*                          ItemToCheck;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStoreCatalogEntryData*                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIStoreSubsystem_GetCatalogForAgent) == 0x000008, "Wrong alignment on DIStoreSubsystem_GetCatalogForAgent");
static_assert(sizeof(DIStoreSubsystem_GetCatalogForAgent) == 0x000010, "Wrong size on DIStoreSubsystem_GetCatalogForAgent");
static_assert(offsetof(DIStoreSubsystem_GetCatalogForAgent, ItemToCheck) == 0x000000, "Member 'DIStoreSubsystem_GetCatalogForAgent::ItemToCheck' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_GetCatalogForAgent, ReturnValue) == 0x000008, "Member 'DIStoreSubsystem_GetCatalogForAgent::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.GetCatalogForItem
// 0x0010 (0x0010 - 0x0000)
struct DIStoreSubsystem_GetCatalogForItem final
{
public:
	const class UDIItem*                          ItemToCheck;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStoreCatalogEntryData*                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIStoreSubsystem_GetCatalogForItem) == 0x000008, "Wrong alignment on DIStoreSubsystem_GetCatalogForItem");
static_assert(sizeof(DIStoreSubsystem_GetCatalogForItem) == 0x000010, "Wrong size on DIStoreSubsystem_GetCatalogForItem");
static_assert(offsetof(DIStoreSubsystem_GetCatalogForItem, ItemToCheck) == 0x000000, "Member 'DIStoreSubsystem_GetCatalogForItem::ItemToCheck' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_GetCatalogForItem, ReturnValue) == 0x000008, "Member 'DIStoreSubsystem_GetCatalogForItem::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.GetCatalogueCurrencyItem
// 0x0008 (0x0008 - 0x0000)
struct DIStoreSubsystem_GetCatalogueCurrencyItem final
{
public:
	class UDICurrencyItem*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIStoreSubsystem_GetCatalogueCurrencyItem) == 0x000008, "Wrong alignment on DIStoreSubsystem_GetCatalogueCurrencyItem");
static_assert(sizeof(DIStoreSubsystem_GetCatalogueCurrencyItem) == 0x000008, "Wrong size on DIStoreSubsystem_GetCatalogueCurrencyItem");
static_assert(offsetof(DIStoreSubsystem_GetCatalogueCurrencyItem, ReturnValue) == 0x000000, "Member 'DIStoreSubsystem_GetCatalogueCurrencyItem::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.GetCollectionIconForItem
// 0x0010 (0x0010 - 0x0000)
struct DIStoreSubsystem_GetCollectionIconForItem final
{
public:
	const class UDIItem*                          ItemToCheck;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIStoreSubsystem_GetCollectionIconForItem) == 0x000008, "Wrong alignment on DIStoreSubsystem_GetCollectionIconForItem");
static_assert(sizeof(DIStoreSubsystem_GetCollectionIconForItem) == 0x000010, "Wrong size on DIStoreSubsystem_GetCollectionIconForItem");
static_assert(offsetof(DIStoreSubsystem_GetCollectionIconForItem, ItemToCheck) == 0x000000, "Member 'DIStoreSubsystem_GetCollectionIconForItem::ItemToCheck' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_GetCollectionIconForItem, ReturnValue) == 0x000008, "Member 'DIStoreSubsystem_GetCollectionIconForItem::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.GetHardCurrencyItem
// 0x0008 (0x0008 - 0x0000)
struct DIStoreSubsystem_GetHardCurrencyItem final
{
public:
	class UDICurrencyItem*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIStoreSubsystem_GetHardCurrencyItem) == 0x000008, "Wrong alignment on DIStoreSubsystem_GetHardCurrencyItem");
static_assert(sizeof(DIStoreSubsystem_GetHardCurrencyItem) == 0x000008, "Wrong size on DIStoreSubsystem_GetHardCurrencyItem");
static_assert(offsetof(DIStoreSubsystem_GetHardCurrencyItem, ReturnValue) == 0x000000, "Member 'DIStoreSubsystem_GetHardCurrencyItem::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.GetItemCostForCurrency
// 0x0018 (0x0018 - 0x0000)
struct DIStoreSubsystem_GetItemCostForCurrency final
{
public:
	const class UDIItem*                          ItemToCheck;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDICurrencyItem*                  Currency;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIStoreSubsystem_GetItemCostForCurrency) == 0x000008, "Wrong alignment on DIStoreSubsystem_GetItemCostForCurrency");
static_assert(sizeof(DIStoreSubsystem_GetItemCostForCurrency) == 0x000018, "Wrong size on DIStoreSubsystem_GetItemCostForCurrency");
static_assert(offsetof(DIStoreSubsystem_GetItemCostForCurrency, ItemToCheck) == 0x000000, "Member 'DIStoreSubsystem_GetItemCostForCurrency::ItemToCheck' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_GetItemCostForCurrency, Currency) == 0x000008, "Member 'DIStoreSubsystem_GetItemCostForCurrency::Currency' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_GetItemCostForCurrency, ReturnValue) == 0x000010, "Member 'DIStoreSubsystem_GetItemCostForCurrency::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.GetItemFromItemIdNum
// 0x0010 (0x0010 - 0x0000)
struct DIStoreSubsystem_GetItemFromItemIdNum final
{
public:
	int32                                         ItemId;                                            // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDIItem*                                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIStoreSubsystem_GetItemFromItemIdNum) == 0x000008, "Wrong alignment on DIStoreSubsystem_GetItemFromItemIdNum");
static_assert(sizeof(DIStoreSubsystem_GetItemFromItemIdNum) == 0x000010, "Wrong size on DIStoreSubsystem_GetItemFromItemIdNum");
static_assert(offsetof(DIStoreSubsystem_GetItemFromItemIdNum, ItemId) == 0x000000, "Member 'DIStoreSubsystem_GetItemFromItemIdNum::ItemId' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_GetItemFromItemIdNum, ReturnValue) == 0x000008, "Member 'DIStoreSubsystem_GetItemFromItemIdNum::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.GetRebatePercentForItem
// 0x0010 (0x0010 - 0x0000)
struct DIStoreSubsystem_GetRebatePercentForItem final
{
public:
	const class UDIItem*                          ItemToCheck;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIStoreSubsystem_GetRebatePercentForItem) == 0x000008, "Wrong alignment on DIStoreSubsystem_GetRebatePercentForItem");
static_assert(sizeof(DIStoreSubsystem_GetRebatePercentForItem) == 0x000010, "Wrong size on DIStoreSubsystem_GetRebatePercentForItem");
static_assert(offsetof(DIStoreSubsystem_GetRebatePercentForItem, ItemToCheck) == 0x000000, "Member 'DIStoreSubsystem_GetRebatePercentForItem::ItemToCheck' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_GetRebatePercentForItem, ReturnValue) == 0x000008, "Member 'DIStoreSubsystem_GetRebatePercentForItem::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.GetSoftCurrencyItem
// 0x0008 (0x0008 - 0x0000)
struct DIStoreSubsystem_GetSoftCurrencyItem final
{
public:
	class UDICurrencyItem*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DIStoreSubsystem_GetSoftCurrencyItem) == 0x000008, "Wrong alignment on DIStoreSubsystem_GetSoftCurrencyItem");
static_assert(sizeof(DIStoreSubsystem_GetSoftCurrencyItem) == 0x000008, "Wrong size on DIStoreSubsystem_GetSoftCurrencyItem");
static_assert(offsetof(DIStoreSubsystem_GetSoftCurrencyItem, ReturnValue) == 0x000000, "Member 'DIStoreSubsystem_GetSoftCurrencyItem::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DIStoreSubsystem.IsItemPurchasable
// 0x0010 (0x0010 - 0x0000)
struct DIStoreSubsystem_IsItemPurchasable final
{
public:
	const class UDIItem*                          ItemToCheck;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DIStoreSubsystem_IsItemPurchasable) == 0x000008, "Wrong alignment on DIStoreSubsystem_IsItemPurchasable");
static_assert(sizeof(DIStoreSubsystem_IsItemPurchasable) == 0x000010, "Wrong size on DIStoreSubsystem_IsItemPurchasable");
static_assert(offsetof(DIStoreSubsystem_IsItemPurchasable, ItemToCheck) == 0x000000, "Member 'DIStoreSubsystem_IsItemPurchasable::ItemToCheck' has a wrong offset!");
static_assert(offsetof(DIStoreSubsystem_IsItemPurchasable, ReturnValue) == 0x000008, "Member 'DIStoreSubsystem_IsItemPurchasable::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiUserSettingWidget.HandleSettingChange
// 0x0001 (0x0001 - 0x0000)
struct DiUserSettingWidget_HandleSettingChange final
{
public:
	EPlayerSettingsType                           SettingChanged;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiUserSettingWidget_HandleSettingChange) == 0x000001, "Wrong alignment on DiUserSettingWidget_HandleSettingChange");
static_assert(sizeof(DiUserSettingWidget_HandleSettingChange) == 0x000001, "Wrong size on DiUserSettingWidget_HandleSettingChange");
static_assert(offsetof(DiUserSettingWidget_HandleSettingChange, SettingChanged) == 0x000000, "Member 'DiUserSettingWidget_HandleSettingChange::SettingChanged' has a wrong offset!");

// Function DeceiveInc.DiUserSettingWidget.SetupForSetting
// 0x0001 (0x0001 - 0x0000)
struct DiUserSettingWidget_SetupForSetting final
{
public:
	EPlayerSettingsType                           InSettingType;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiUserSettingWidget_SetupForSetting) == 0x000001, "Wrong alignment on DiUserSettingWidget_SetupForSetting");
static_assert(sizeof(DiUserSettingWidget_SetupForSetting) == 0x000001, "Wrong size on DiUserSettingWidget_SetupForSetting");
static_assert(offsetof(DiUserSettingWidget_SetupForSetting, InSettingType) == 0x000000, "Member 'DiUserSettingWidget_SetupForSetting::InSettingType' has a wrong offset!");

// Function DeceiveInc.DiUserSettingWidget.GetDefaultVisibilityState
// 0x0001 (0x0001 - 0x0000)
struct DiUserSettingWidget_GetDefaultVisibilityState final
{
public:
	EPlayerSettingsDefaultState                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiUserSettingWidget_GetDefaultVisibilityState) == 0x000001, "Wrong alignment on DiUserSettingWidget_GetDefaultVisibilityState");
static_assert(sizeof(DiUserSettingWidget_GetDefaultVisibilityState) == 0x000001, "Wrong size on DiUserSettingWidget_GetDefaultVisibilityState");
static_assert(offsetof(DiUserSettingWidget_GetDefaultVisibilityState, ReturnValue) == 0x000000, "Member 'DiUserSettingWidget_GetDefaultVisibilityState::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiUserSettingWidget.GetSettingShortDescription
// 0x0018 (0x0018 - 0x0000)
struct DiUserSettingWidget_GetSettingShortDescription final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiUserSettingWidget_GetSettingShortDescription) == 0x000008, "Wrong alignment on DiUserSettingWidget_GetSettingShortDescription");
static_assert(sizeof(DiUserSettingWidget_GetSettingShortDescription) == 0x000018, "Wrong size on DiUserSettingWidget_GetSettingShortDescription");
static_assert(offsetof(DiUserSettingWidget_GetSettingShortDescription, ReturnValue) == 0x000000, "Member 'DiUserSettingWidget_GetSettingShortDescription::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiUserSettingWidget.GetSettingTooltipDecription
// 0x0018 (0x0018 - 0x0000)
struct DiUserSettingWidget_GetSettingTooltipDecription final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiUserSettingWidget_GetSettingTooltipDecription) == 0x000008, "Wrong alignment on DiUserSettingWidget_GetSettingTooltipDecription");
static_assert(sizeof(DiUserSettingWidget_GetSettingTooltipDecription) == 0x000018, "Wrong size on DiUserSettingWidget_GetSettingTooltipDecription");
static_assert(offsetof(DiUserSettingWidget_GetSettingTooltipDecription, ReturnValue) == 0x000000, "Member 'DiUserSettingWidget_GetSettingTooltipDecription::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiUserSettingWidget.IsAdvancedSetting
// 0x0001 (0x0001 - 0x0000)
struct DiUserSettingWidget_IsAdvancedSetting final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiUserSettingWidget_IsAdvancedSetting) == 0x000001, "Wrong alignment on DiUserSettingWidget_IsAdvancedSetting");
static_assert(sizeof(DiUserSettingWidget_IsAdvancedSetting) == 0x000001, "Wrong size on DiUserSettingWidget_IsAdvancedSetting");
static_assert(offsetof(DiUserSettingWidget_IsAdvancedSetting, ReturnValue) == 0x000000, "Member 'DiUserSettingWidget_IsAdvancedSetting::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiUserSettingWidget.IsAllowedPerAgentSetting
// 0x0001 (0x0001 - 0x0000)
struct DiUserSettingWidget_IsAllowedPerAgentSetting final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiUserSettingWidget_IsAllowedPerAgentSetting) == 0x000001, "Wrong alignment on DiUserSettingWidget_IsAllowedPerAgentSetting");
static_assert(sizeof(DiUserSettingWidget_IsAllowedPerAgentSetting) == 0x000001, "Wrong size on DiUserSettingWidget_IsAllowedPerAgentSetting");
static_assert(offsetof(DiUserSettingWidget_IsAllowedPerAgentSetting, ReturnValue) == 0x000000, "Member 'DiUserSettingWidget_IsAllowedPerAgentSetting::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiUserSettingWidget.IsAllowedSubSetting
// 0x0001 (0x0001 - 0x0000)
struct DiUserSettingWidget_IsAllowedSubSetting final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiUserSettingWidget_IsAllowedSubSetting) == 0x000001, "Wrong alignment on DiUserSettingWidget_IsAllowedSubSetting");
static_assert(sizeof(DiUserSettingWidget_IsAllowedSubSetting) == 0x000001, "Wrong size on DiUserSettingWidget_IsAllowedSubSetting");
static_assert(offsetof(DiUserSettingWidget_IsAllowedSubSetting, ReturnValue) == 0x000000, "Member 'DiUserSettingWidget_IsAllowedSubSetting::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiUserSettingWidget.IsEnabled
// 0x0001 (0x0001 - 0x0000)
struct DiUserSettingWidget_IsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiUserSettingWidget_IsEnabled) == 0x000001, "Wrong alignment on DiUserSettingWidget_IsEnabled");
static_assert(sizeof(DiUserSettingWidget_IsEnabled) == 0x000001, "Wrong size on DiUserSettingWidget_IsEnabled");
static_assert(offsetof(DiUserSettingWidget_IsEnabled, ReturnValue) == 0x000000, "Member 'DiUserSettingWidget_IsEnabled::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiUserSettingWidget.IsTooltipAvailable
// 0x0001 (0x0001 - 0x0000)
struct DiUserSettingWidget_IsTooltipAvailable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiUserSettingWidget_IsTooltipAvailable) == 0x000001, "Wrong alignment on DiUserSettingWidget_IsTooltipAvailable");
static_assert(sizeof(DiUserSettingWidget_IsTooltipAvailable) == 0x000001, "Wrong size on DiUserSettingWidget_IsTooltipAvailable");
static_assert(offsetof(DiUserSettingWidget_IsTooltipAvailable, ReturnValue) == 0x000000, "Member 'DiUserSettingWidget_IsTooltipAvailable::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCBug.HandleCoverSwitch
// 0x0008 (0x0008 - 0x0000)
struct NPCBug_HandleCoverSwitch final
{
public:
	class ANPCCharacter*                          Disguise;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBug_HandleCoverSwitch) == 0x000008, "Wrong alignment on NPCBug_HandleCoverSwitch");
static_assert(sizeof(NPCBug_HandleCoverSwitch) == 0x000008, "Wrong size on NPCBug_HandleCoverSwitch");
static_assert(offsetof(NPCBug_HandleCoverSwitch, Disguise) == 0x000000, "Member 'NPCBug_HandleCoverSwitch::Disguise' has a wrong offset!");

// Function DeceiveInc.NPCBug.HandleDeadActor
// 0x0008 (0x0008 - 0x0000)
struct NPCBug_HandleDeadActor final
{
public:
	class AActor*                                 DeadActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBug_HandleDeadActor) == 0x000008, "Wrong alignment on NPCBug_HandleDeadActor");
static_assert(sizeof(NPCBug_HandleDeadActor) == 0x000008, "Wrong size on NPCBug_HandleDeadActor");
static_assert(offsetof(NPCBug_HandleDeadActor, DeadActor) == 0x000000, "Member 'NPCBug_HandleDeadActor::DeadActor' has a wrong offset!");

// Function DeceiveInc.NPCBug.HandleNPCFellOffMap
// 0x0008 (0x0008 - 0x0000)
struct NPCBug_HandleNPCFellOffMap final
{
public:
	class ANPCCharacter*                          NPCCharacter;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBug_HandleNPCFellOffMap) == 0x000008, "Wrong alignment on NPCBug_HandleNPCFellOffMap");
static_assert(sizeof(NPCBug_HandleNPCFellOffMap) == 0x000008, "Wrong size on NPCBug_HandleNPCFellOffMap");
static_assert(offsetof(NPCBug_HandleNPCFellOffMap, NPCCharacter) == 0x000000, "Member 'NPCBug_HandleNPCFellOffMap::NPCCharacter' has a wrong offset!");

// Function DeceiveInc.NPCBug.HandleSpyLookAction
// 0x0018 (0x0018 - 0x0000)
struct NPCBug_HandleSpyLookAction final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawValue;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchValue;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSpyCameraMovementLock;                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NPCBug_HandleSpyLookAction) == 0x000008, "Wrong alignment on NPCBug_HandleSpyLookAction");
static_assert(sizeof(NPCBug_HandleSpyLookAction) == 0x000018, "Wrong size on NPCBug_HandleSpyLookAction");
static_assert(offsetof(NPCBug_HandleSpyLookAction, Spy) == 0x000000, "Member 'NPCBug_HandleSpyLookAction::Spy' has a wrong offset!");
static_assert(offsetof(NPCBug_HandleSpyLookAction, YawValue) == 0x000008, "Member 'NPCBug_HandleSpyLookAction::YawValue' has a wrong offset!");
static_assert(offsetof(NPCBug_HandleSpyLookAction, PitchValue) == 0x00000C, "Member 'NPCBug_HandleSpyLookAction::PitchValue' has a wrong offset!");
static_assert(offsetof(NPCBug_HandleSpyLookAction, bIsSpyCameraMovementLock) == 0x000010, "Member 'NPCBug_HandleSpyLookAction::bIsSpyCameraMovementLock' has a wrong offset!");

// Function DeceiveInc.NPCBug.HandleSpyTransformInMimic
// 0x0010 (0x0010 - 0x0000)
struct NPCBug_HandleSpyTransformInMimic final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseMimicScannableActor*               Mimic;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBug_HandleSpyTransformInMimic) == 0x000008, "Wrong alignment on NPCBug_HandleSpyTransformInMimic");
static_assert(sizeof(NPCBug_HandleSpyTransformInMimic) == 0x000010, "Wrong size on NPCBug_HandleSpyTransformInMimic");
static_assert(offsetof(NPCBug_HandleSpyTransformInMimic, Spy) == 0x000000, "Member 'NPCBug_HandleSpyTransformInMimic::Spy' has a wrong offset!");
static_assert(offsetof(NPCBug_HandleSpyTransformInMimic, Mimic) == 0x000008, "Member 'NPCBug_HandleSpyTransformInMimic::Mimic' has a wrong offset!");

// Function DeceiveInc.NPCBug.HandleSpyUndercoverChanged
// 0x0010 (0x0010 - 0x0000)
struct NPCBug_HandleSpyUndercoverChanged final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Undercover;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NPCBug_HandleSpyUndercoverChanged) == 0x000008, "Wrong alignment on NPCBug_HandleSpyUndercoverChanged");
static_assert(sizeof(NPCBug_HandleSpyUndercoverChanged) == 0x000010, "Wrong size on NPCBug_HandleSpyUndercoverChanged");
static_assert(offsetof(NPCBug_HandleSpyUndercoverChanged, Spy) == 0x000000, "Member 'NPCBug_HandleSpyUndercoverChanged::Spy' has a wrong offset!");
static_assert(offsetof(NPCBug_HandleSpyUndercoverChanged, Undercover) == 0x000008, "Member 'NPCBug_HandleSpyUndercoverChanged::Undercover' has a wrong offset!");

// Function DeceiveInc.NPCBug.NetMulticast_SetIsCameraActive
// 0x0001 (0x0001 - 0x0000)
struct NPCBug_NetMulticast_SetIsCameraActive final
{
public:
	bool                                          bInIsCameraActive;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBug_NetMulticast_SetIsCameraActive) == 0x000001, "Wrong alignment on NPCBug_NetMulticast_SetIsCameraActive");
static_assert(sizeof(NPCBug_NetMulticast_SetIsCameraActive) == 0x000001, "Wrong size on NPCBug_NetMulticast_SetIsCameraActive");
static_assert(offsetof(NPCBug_NetMulticast_SetIsCameraActive, bInIsCameraActive) == 0x000000, "Member 'NPCBug_NetMulticast_SetIsCameraActive::bInIsCameraActive' has a wrong offset!");

// Function DeceiveInc.NPCBug.NetMulticast_SetNewRotation
// 0x000C (0x000C - 0x0000)
struct NPCBug_NetMulticast_SetNewRotation final
{
public:
	struct FRotator                               NewRotation;                                       // 0x0000(0x000C)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBug_NetMulticast_SetNewRotation) == 0x000004, "Wrong alignment on NPCBug_NetMulticast_SetNewRotation");
static_assert(sizeof(NPCBug_NetMulticast_SetNewRotation) == 0x00000C, "Wrong size on NPCBug_NetMulticast_SetNewRotation");
static_assert(offsetof(NPCBug_NetMulticast_SetNewRotation, NewRotation) == 0x000000, "Member 'NPCBug_NetMulticast_SetNewRotation::NewRotation' has a wrong offset!");

// Function DeceiveInc.NPCBug.OnRep_SpyVictim
// 0x0008 (0x0008 - 0x0000)
struct NPCBug_OnRep_SpyVictim final
{
public:
	class ASpy*                                   OldSpy;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBug_OnRep_SpyVictim) == 0x000008, "Wrong alignment on NPCBug_OnRep_SpyVictim");
static_assert(sizeof(NPCBug_OnRep_SpyVictim) == 0x000008, "Wrong size on NPCBug_OnRep_SpyVictim");
static_assert(offsetof(NPCBug_OnRep_SpyVictim, OldSpy) == 0x000000, "Member 'NPCBug_OnRep_SpyVictim::OldSpy' has a wrong offset!");

// Function DeceiveInc.NPCBug.Server_SetIsCameraActive
// 0x0001 (0x0001 - 0x0000)
struct NPCBug_Server_SetIsCameraActive final
{
public:
	bool                                          bInIsCameraActive;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBug_Server_SetIsCameraActive) == 0x000001, "Wrong alignment on NPCBug_Server_SetIsCameraActive");
static_assert(sizeof(NPCBug_Server_SetIsCameraActive) == 0x000001, "Wrong size on NPCBug_Server_SetIsCameraActive");
static_assert(offsetof(NPCBug_Server_SetIsCameraActive, bInIsCameraActive) == 0x000000, "Member 'NPCBug_Server_SetIsCameraActive::bInIsCameraActive' has a wrong offset!");

// Function DeceiveInc.NPCBug.Server_SetNewRotation
// 0x000C (0x000C - 0x0000)
struct NPCBug_Server_SetNewRotation final
{
public:
	struct FRotator                               NewRotation;                                       // 0x0000(0x000C)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBug_Server_SetNewRotation) == 0x000004, "Wrong alignment on NPCBug_Server_SetNewRotation");
static_assert(sizeof(NPCBug_Server_SetNewRotation) == 0x00000C, "Wrong size on NPCBug_Server_SetNewRotation");
static_assert(offsetof(NPCBug_Server_SetNewRotation, NewRotation) == 0x000000, "Member 'NPCBug_Server_SetNewRotation::NewRotation' has a wrong offset!");

// Function DeceiveInc.DiUserBooleanSettingWidget.ApplyNewSettingValue
// 0x0001 (0x0001 - 0x0000)
struct DiUserBooleanSettingWidget_ApplyNewSettingValue final
{
public:
	bool                                          bNewSettingValue;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiUserBooleanSettingWidget_ApplyNewSettingValue) == 0x000001, "Wrong alignment on DiUserBooleanSettingWidget_ApplyNewSettingValue");
static_assert(sizeof(DiUserBooleanSettingWidget_ApplyNewSettingValue) == 0x000001, "Wrong size on DiUserBooleanSettingWidget_ApplyNewSettingValue");
static_assert(offsetof(DiUserBooleanSettingWidget_ApplyNewSettingValue, bNewSettingValue) == 0x000000, "Member 'DiUserBooleanSettingWidget_ApplyNewSettingValue::bNewSettingValue' has a wrong offset!");

// Function DeceiveInc.DiUserBooleanSettingWidget.GetSettingValue
// 0x0001 (0x0001 - 0x0000)
struct DiUserBooleanSettingWidget_GetSettingValue final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiUserBooleanSettingWidget_GetSettingValue) == 0x000001, "Wrong alignment on DiUserBooleanSettingWidget_GetSettingValue");
static_assert(sizeof(DiUserBooleanSettingWidget_GetSettingValue) == 0x000001, "Wrong size on DiUserBooleanSettingWidget_GetSettingValue");
static_assert(offsetof(DiUserBooleanSettingWidget_GetSettingValue, ReturnValue) == 0x000000, "Member 'DiUserBooleanSettingWidget_GetSettingValue::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiUserIntegerSettingWidget.ApplyNewSettingValue
// 0x0004 (0x0004 - 0x0000)
struct DiUserIntegerSettingWidget_ApplyNewSettingValue final
{
public:
	int32                                         NewSettingValue;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiUserIntegerSettingWidget_ApplyNewSettingValue) == 0x000004, "Wrong alignment on DiUserIntegerSettingWidget_ApplyNewSettingValue");
static_assert(sizeof(DiUserIntegerSettingWidget_ApplyNewSettingValue) == 0x000004, "Wrong size on DiUserIntegerSettingWidget_ApplyNewSettingValue");
static_assert(offsetof(DiUserIntegerSettingWidget_ApplyNewSettingValue, NewSettingValue) == 0x000000, "Member 'DiUserIntegerSettingWidget_ApplyNewSettingValue::NewSettingValue' has a wrong offset!");

// Function DeceiveInc.DiUserIntegerSettingWidget.GetSettingValue
// 0x0004 (0x0004 - 0x0000)
struct DiUserIntegerSettingWidget_GetSettingValue final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiUserIntegerSettingWidget_GetSettingValue) == 0x000004, "Wrong alignment on DiUserIntegerSettingWidget_GetSettingValue");
static_assert(sizeof(DiUserIntegerSettingWidget_GetSettingValue) == 0x000004, "Wrong size on DiUserIntegerSettingWidget_GetSettingValue");
static_assert(offsetof(DiUserIntegerSettingWidget_GetSettingValue, ReturnValue) == 0x000000, "Member 'DiUserIntegerSettingWidget_GetSettingValue::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiUserFloatSettingWidget.ApplyNewSettingValue
// 0x0004 (0x0004 - 0x0000)
struct DiUserFloatSettingWidget_ApplyNewSettingValue final
{
public:
	float                                         NewSettingValue;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiUserFloatSettingWidget_ApplyNewSettingValue) == 0x000004, "Wrong alignment on DiUserFloatSettingWidget_ApplyNewSettingValue");
static_assert(sizeof(DiUserFloatSettingWidget_ApplyNewSettingValue) == 0x000004, "Wrong size on DiUserFloatSettingWidget_ApplyNewSettingValue");
static_assert(offsetof(DiUserFloatSettingWidget_ApplyNewSettingValue, NewSettingValue) == 0x000000, "Member 'DiUserFloatSettingWidget_ApplyNewSettingValue::NewSettingValue' has a wrong offset!");

// Function DeceiveInc.DiUserFloatSettingWidget.GetSettingValue
// 0x0004 (0x0004 - 0x0000)
struct DiUserFloatSettingWidget_GetSettingValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiUserFloatSettingWidget_GetSettingValue) == 0x000004, "Wrong alignment on DiUserFloatSettingWidget_GetSettingValue");
static_assert(sizeof(DiUserFloatSettingWidget_GetSettingValue) == 0x000004, "Wrong size on DiUserFloatSettingWidget_GetSettingValue");
static_assert(offsetof(DiUserFloatSettingWidget_GetSettingValue, ReturnValue) == 0x000000, "Member 'DiUserFloatSettingWidget_GetSettingValue::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DiUserStringSettingWidget.ApplyNewSettingValue
// 0x0010 (0x0010 - 0x0000)
struct DiUserStringSettingWidget_ApplyNewSettingValue final
{
public:
	class FString                                 NewSettingValue;                                   // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiUserStringSettingWidget_ApplyNewSettingValue) == 0x000008, "Wrong alignment on DiUserStringSettingWidget_ApplyNewSettingValue");
static_assert(sizeof(DiUserStringSettingWidget_ApplyNewSettingValue) == 0x000010, "Wrong size on DiUserStringSettingWidget_ApplyNewSettingValue");
static_assert(offsetof(DiUserStringSettingWidget_ApplyNewSettingValue, NewSettingValue) == 0x000000, "Member 'DiUserStringSettingWidget_ApplyNewSettingValue::NewSettingValue' has a wrong offset!");

// Function DeceiveInc.DiUserStringSettingWidget.GetSettingValue
// 0x0010 (0x0010 - 0x0000)
struct DiUserStringSettingWidget_GetSettingValue final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DiUserStringSettingWidget_GetSettingValue) == 0x000008, "Wrong alignment on DiUserStringSettingWidget_GetSettingValue");
static_assert(sizeof(DiUserStringSettingWidget_GetSettingValue) == 0x000010, "Wrong size on DiUserStringSettingWidget_GetSettingValue");
static_assert(offsetof(DiUserStringSettingWidget_GetSettingValue, ReturnValue) == 0x000000, "Member 'DiUserStringSettingWidget_GetSettingValue::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCInteractionComponent.GetInteractingNPC
// 0x0008 (0x0008 - 0x0000)
struct NPCInteractionComponent_GetInteractingNPC final
{
public:
	class ANPCCharacter*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCInteractionComponent_GetInteractingNPC) == 0x000008, "Wrong alignment on NPCInteractionComponent_GetInteractingNPC");
static_assert(sizeof(NPCInteractionComponent_GetInteractingNPC) == 0x000008, "Wrong size on NPCInteractionComponent_GetInteractingNPC");
static_assert(offsetof(NPCInteractionComponent_GetInteractingNPC, ReturnValue) == 0x000000, "Member 'NPCInteractionComponent_GetInteractingNPC::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCInteractionComponent.GetWatchingPlayerDisguiseAnimationLoop
// 0x0008 (0x0008 - 0x0000)
struct NPCInteractionComponent_GetWatchingPlayerDisguiseAnimationLoop final
{
public:
	class UAnimSequence*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCInteractionComponent_GetWatchingPlayerDisguiseAnimationLoop) == 0x000008, "Wrong alignment on NPCInteractionComponent_GetWatchingPlayerDisguiseAnimationLoop");
static_assert(sizeof(NPCInteractionComponent_GetWatchingPlayerDisguiseAnimationLoop) == 0x000008, "Wrong size on NPCInteractionComponent_GetWatchingPlayerDisguiseAnimationLoop");
static_assert(offsetof(NPCInteractionComponent_GetWatchingPlayerDisguiseAnimationLoop, ReturnValue) == 0x000000, "Member 'NPCInteractionComponent_GetWatchingPlayerDisguiseAnimationLoop::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCInteractionComponent.OnMimicVisibilityChange
// 0x0001 (0x0001 - 0x0000)
struct NPCInteractionComponent_OnMimicVisibilityChange final
{
public:
	bool                                          bVisibleIn;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCInteractionComponent_OnMimicVisibilityChange) == 0x000001, "Wrong alignment on NPCInteractionComponent_OnMimicVisibilityChange");
static_assert(sizeof(NPCInteractionComponent_OnMimicVisibilityChange) == 0x000001, "Wrong size on NPCInteractionComponent_OnMimicVisibilityChange");
static_assert(offsetof(NPCInteractionComponent_OnMimicVisibilityChange, bVisibleIn) == 0x000000, "Member 'NPCInteractionComponent_OnMimicVisibilityChange::bVisibleIn' has a wrong offset!");

// Function DeceiveInc.NPCInteractionComponent.OnPlayerInteractComplete
// 0x0010 (0x0010 - 0x0000)
struct NPCInteractionComponent_OnPlayerInteractComplete final
{
public:
	class UInteracterComponent*                   InteracterIn;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 InteractableIn;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCInteractionComponent_OnPlayerInteractComplete) == 0x000008, "Wrong alignment on NPCInteractionComponent_OnPlayerInteractComplete");
static_assert(sizeof(NPCInteractionComponent_OnPlayerInteractComplete) == 0x000010, "Wrong size on NPCInteractionComponent_OnPlayerInteractComplete");
static_assert(offsetof(NPCInteractionComponent_OnPlayerInteractComplete, InteracterIn) == 0x000000, "Member 'NPCInteractionComponent_OnPlayerInteractComplete::InteracterIn' has a wrong offset!");
static_assert(offsetof(NPCInteractionComponent_OnPlayerInteractComplete, InteractableIn) == 0x000008, "Member 'NPCInteractionComponent_OnPlayerInteractComplete::InteractableIn' has a wrong offset!");

// Function DeceiveInc.NPCInteractionComponent.OnPostInitRooms
// 0x0008 (0x0008 - 0x0000)
struct NPCInteractionComponent_OnPostInitRooms final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCInteractionComponent_OnPostInitRooms) == 0x000008, "Wrong alignment on NPCInteractionComponent_OnPostInitRooms");
static_assert(sizeof(NPCInteractionComponent_OnPostInitRooms) == 0x000008, "Wrong size on NPCInteractionComponent_OnPostInitRooms");
static_assert(offsetof(NPCInteractionComponent_OnPostInitRooms, World) == 0x000000, "Member 'NPCInteractionComponent_OnPostInitRooms::World' has a wrong offset!");

// Function DeceiveInc.NPCConversationComponent.OnRep_TalkingNPC
// 0x0008 (0x0008 - 0x0000)
struct NPCConversationComponent_OnRep_TalkingNPC final
{
public:
	class ANPCCharacter*                          PrevNPC;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCConversationComponent_OnRep_TalkingNPC) == 0x000008, "Wrong alignment on NPCConversationComponent_OnRep_TalkingNPC");
static_assert(sizeof(NPCConversationComponent_OnRep_TalkingNPC) == 0x000008, "Wrong size on NPCConversationComponent_OnRep_TalkingNPC");
static_assert(offsetof(NPCConversationComponent_OnRep_TalkingNPC, PrevNPC) == 0x000000, "Member 'NPCConversationComponent_OnRep_TalkingNPC::PrevNPC' has a wrong offset!");

// Function DeceiveInc.ObjectSpawnComponent.UpdateConnectedRoomsReference
// 0x0008 (0x0008 - 0x0000)
struct ObjectSpawnComponent_UpdateConnectedRoomsReference final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ObjectSpawnComponent_UpdateConnectedRoomsReference) == 0x000008, "Wrong alignment on ObjectSpawnComponent_UpdateConnectedRoomsReference");
static_assert(sizeof(ObjectSpawnComponent_UpdateConnectedRoomsReference) == 0x000008, "Wrong size on ObjectSpawnComponent_UpdateConnectedRoomsReference");
static_assert(offsetof(ObjectSpawnComponent_UpdateConnectedRoomsReference, World) == 0x000000, "Member 'ObjectSpawnComponent_UpdateConnectedRoomsReference::World' has a wrong offset!");

// Function DeceiveInc.ObjectSpawnComponent.GetSpawnedObject
// 0x0008 (0x0008 - 0x0000)
struct ObjectSpawnComponent_GetSpawnedObject final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ObjectSpawnComponent_GetSpawnedObject) == 0x000008, "Wrong alignment on ObjectSpawnComponent_GetSpawnedObject");
static_assert(sizeof(ObjectSpawnComponent_GetSpawnedObject) == 0x000008, "Wrong size on ObjectSpawnComponent_GetSpawnedObject");
static_assert(offsetof(ObjectSpawnComponent_GetSpawnedObject, ReturnValue) == 0x000000, "Member 'ObjectSpawnComponent_GetSpawnedObject::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DoubleContainerActor.HandleSecondaryInteractionComplete
// 0x0010 (0x0010 - 0x0000)
struct DoubleContainerActor_HandleSecondaryInteractionComplete final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DoubleContainerActor_HandleSecondaryInteractionComplete) == 0x000008, "Wrong alignment on DoubleContainerActor_HandleSecondaryInteractionComplete");
static_assert(sizeof(DoubleContainerActor_HandleSecondaryInteractionComplete) == 0x000010, "Wrong size on DoubleContainerActor_HandleSecondaryInteractionComplete");
static_assert(offsetof(DoubleContainerActor_HandleSecondaryInteractionComplete, Interacter) == 0x000000, "Member 'DoubleContainerActor_HandleSecondaryInteractionComplete::Interacter' has a wrong offset!");
static_assert(offsetof(DoubleContainerActor_HandleSecondaryInteractionComplete, Interactable) == 0x000008, "Member 'DoubleContainerActor_HandleSecondaryInteractionComplete::Interactable' has a wrong offset!");

// Function DeceiveInc.DoubleContainerActor.OnRep_SecondaryContainerState
// 0x0001 (0x0001 - 0x0000)
struct DoubleContainerActor_OnRep_SecondaryContainerState final
{
public:
	EContainerState                               PreviousState;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DoubleContainerActor_OnRep_SecondaryContainerState) == 0x000001, "Wrong alignment on DoubleContainerActor_OnRep_SecondaryContainerState");
static_assert(sizeof(DoubleContainerActor_OnRep_SecondaryContainerState) == 0x000001, "Wrong size on DoubleContainerActor_OnRep_SecondaryContainerState");
static_assert(offsetof(DoubleContainerActor_OnRep_SecondaryContainerState, PreviousState) == 0x000000, "Member 'DoubleContainerActor_OnRep_SecondaryContainerState::PreviousState' has a wrong offset!");

// Function DeceiveInc.NPCMovementComponent.NotifyAnimationStateJumpInChange
// 0x0001 (0x0001 - 0x0000)
struct NPCMovementComponent_NotifyAnimationStateJumpInChange final
{
public:
	bool                                          bJumpInStart;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCMovementComponent_NotifyAnimationStateJumpInChange) == 0x000001, "Wrong alignment on NPCMovementComponent_NotifyAnimationStateJumpInChange");
static_assert(sizeof(NPCMovementComponent_NotifyAnimationStateJumpInChange) == 0x000001, "Wrong size on NPCMovementComponent_NotifyAnimationStateJumpInChange");
static_assert(offsetof(NPCMovementComponent_NotifyAnimationStateJumpInChange, bJumpInStart) == 0x000000, "Member 'NPCMovementComponent_NotifyAnimationStateJumpInChange::bJumpInStart' has a wrong offset!");

// Function DeceiveInc.NPCMovementComponent.OnCollisionBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct NPCMovementComponent_OnCollisionBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCMovementComponent_OnCollisionBeginOverlap) == 0x000008, "Wrong alignment on NPCMovementComponent_OnCollisionBeginOverlap");
static_assert(sizeof(NPCMovementComponent_OnCollisionBeginOverlap) == 0x0000A8, "Wrong size on NPCMovementComponent_OnCollisionBeginOverlap");
static_assert(offsetof(NPCMovementComponent_OnCollisionBeginOverlap, OverlappedComponent) == 0x000000, "Member 'NPCMovementComponent_OnCollisionBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(NPCMovementComponent_OnCollisionBeginOverlap, OtherActor) == 0x000008, "Member 'NPCMovementComponent_OnCollisionBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(NPCMovementComponent_OnCollisionBeginOverlap, OtherComp) == 0x000010, "Member 'NPCMovementComponent_OnCollisionBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(NPCMovementComponent_OnCollisionBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'NPCMovementComponent_OnCollisionBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(NPCMovementComponent_OnCollisionBeginOverlap, bFromSweep) == 0x00001C, "Member 'NPCMovementComponent_OnCollisionBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(NPCMovementComponent_OnCollisionBeginOverlap, SweepResult) == 0x000020, "Member 'NPCMovementComponent_OnCollisionBeginOverlap::SweepResult' has a wrong offset!");

// Function DeceiveInc.NPCMovementComponent.OnCollisionEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct NPCMovementComponent_OnCollisionEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NPCMovementComponent_OnCollisionEndOverlap) == 0x000008, "Wrong alignment on NPCMovementComponent_OnCollisionEndOverlap");
static_assert(sizeof(NPCMovementComponent_OnCollisionEndOverlap) == 0x000020, "Wrong size on NPCMovementComponent_OnCollisionEndOverlap");
static_assert(offsetof(NPCMovementComponent_OnCollisionEndOverlap, OverlappedComponent) == 0x000000, "Member 'NPCMovementComponent_OnCollisionEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(NPCMovementComponent_OnCollisionEndOverlap, OtherActor) == 0x000008, "Member 'NPCMovementComponent_OnCollisionEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(NPCMovementComponent_OnCollisionEndOverlap, OtherComp) == 0x000010, "Member 'NPCMovementComponent_OnCollisionEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(NPCMovementComponent_OnCollisionEndOverlap, OtherBodyIndex) == 0x000018, "Member 'NPCMovementComponent_OnCollisionEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function DeceiveInc.NPCMovementComponent.SetJumpInAnimationSequence
// 0x0008 (0x0008 - 0x0000)
struct NPCMovementComponent_SetJumpInAnimationSequence final
{
public:
	class UAnimSequence*                          JumpInAnim;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCMovementComponent_SetJumpInAnimationSequence) == 0x000008, "Wrong alignment on NPCMovementComponent_SetJumpInAnimationSequence");
static_assert(sizeof(NPCMovementComponent_SetJumpInAnimationSequence) == 0x000008, "Wrong size on NPCMovementComponent_SetJumpInAnimationSequence");
static_assert(offsetof(NPCMovementComponent_SetJumpInAnimationSequence, JumpInAnim) == 0x000000, "Member 'NPCMovementComponent_SetJumpInAnimationSequence::JumpInAnim' has a wrong offset!");

// Function DeceiveInc.Drone.GetFactionId
// 0x0001 (0x0001 - 0x0000)
struct Drone_GetFactionId final
{
public:
	uint8                                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Drone_GetFactionId) == 0x000001, "Wrong alignment on Drone_GetFactionId");
static_assert(sizeof(Drone_GetFactionId) == 0x000001, "Wrong size on Drone_GetFactionId");
static_assert(offsetof(Drone_GetFactionId, ReturnValue) == 0x000000, "Member 'Drone_GetFactionId::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Drone.HandleBooleanPlayerSettingChange
// 0x0002 (0x0002 - 0x0000)
struct Drone_HandleBooleanPlayerSettingChange final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewValue;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Drone_HandleBooleanPlayerSettingChange) == 0x000001, "Wrong alignment on Drone_HandleBooleanPlayerSettingChange");
static_assert(sizeof(Drone_HandleBooleanPlayerSettingChange) == 0x000002, "Wrong size on Drone_HandleBooleanPlayerSettingChange");
static_assert(offsetof(Drone_HandleBooleanPlayerSettingChange, SettingType) == 0x000000, "Member 'Drone_HandleBooleanPlayerSettingChange::SettingType' has a wrong offset!");
static_assert(offsetof(Drone_HandleBooleanPlayerSettingChange, NewValue) == 0x000001, "Member 'Drone_HandleBooleanPlayerSettingChange::NewValue' has a wrong offset!");

// Function DeceiveInc.Drone.HandleDeath
// 0x0008 (0x0008 - 0x0000)
struct Drone_HandleDeath final
{
public:
	class AActor*                                 DeadActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Drone_HandleDeath) == 0x000008, "Wrong alignment on Drone_HandleDeath");
static_assert(sizeof(Drone_HandleDeath) == 0x000008, "Wrong size on Drone_HandleDeath");
static_assert(offsetof(Drone_HandleDeath, DeadActor) == 0x000000, "Member 'Drone_HandleDeath::DeadActor' has a wrong offset!");

// Function DeceiveInc.Drone.HandleEMPIsAffectedChanged
// 0x0010 (0x0010 - 0x0000)
struct Drone_HandleEMPIsAffectedChanged final
{
public:
	bool                                          bIsAffected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AffectedActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Drone_HandleEMPIsAffectedChanged) == 0x000008, "Wrong alignment on Drone_HandleEMPIsAffectedChanged");
static_assert(sizeof(Drone_HandleEMPIsAffectedChanged) == 0x000010, "Wrong size on Drone_HandleEMPIsAffectedChanged");
static_assert(offsetof(Drone_HandleEMPIsAffectedChanged, bIsAffected) == 0x000000, "Member 'Drone_HandleEMPIsAffectedChanged::bIsAffected' has a wrong offset!");
static_assert(offsetof(Drone_HandleEMPIsAffectedChanged, AffectedActor) == 0x000008, "Member 'Drone_HandleEMPIsAffectedChanged::AffectedActor' has a wrong offset!");

// Function DeceiveInc.Drone.HandleFloatPlayerSettingChange
// 0x0008 (0x0008 - 0x0000)
struct Drone_HandleFloatPlayerSettingChange final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NewValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Drone_HandleFloatPlayerSettingChange) == 0x000004, "Wrong alignment on Drone_HandleFloatPlayerSettingChange");
static_assert(sizeof(Drone_HandleFloatPlayerSettingChange) == 0x000008, "Wrong size on Drone_HandleFloatPlayerSettingChange");
static_assert(offsetof(Drone_HandleFloatPlayerSettingChange, SettingType) == 0x000000, "Member 'Drone_HandleFloatPlayerSettingChange::SettingType' has a wrong offset!");
static_assert(offsetof(Drone_HandleFloatPlayerSettingChange, NewValue) == 0x000004, "Member 'Drone_HandleFloatPlayerSettingChange::NewValue' has a wrong offset!");

// Function DeceiveInc.Drone.HandleInteractionCompleted
// 0x0010 (0x0010 - 0x0000)
struct Drone_HandleInteractionCompleted final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Drone_HandleInteractionCompleted) == 0x000008, "Wrong alignment on Drone_HandleInteractionCompleted");
static_assert(sizeof(Drone_HandleInteractionCompleted) == 0x000010, "Wrong size on Drone_HandleInteractionCompleted");
static_assert(offsetof(Drone_HandleInteractionCompleted, Interacter) == 0x000000, "Member 'Drone_HandleInteractionCompleted::Interacter' has a wrong offset!");
static_assert(offsetof(Drone_HandleInteractionCompleted, Interactable) == 0x000008, "Member 'Drone_HandleInteractionCompleted::Interactable' has a wrong offset!");

// Function DeceiveInc.Drone.HandleIntPlayerSettingChange
// 0x0008 (0x0008 - 0x0000)
struct Drone_HandleIntPlayerSettingChange final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NewValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Drone_HandleIntPlayerSettingChange) == 0x000004, "Wrong alignment on Drone_HandleIntPlayerSettingChange");
static_assert(sizeof(Drone_HandleIntPlayerSettingChange) == 0x000008, "Wrong size on Drone_HandleIntPlayerSettingChange");
static_assert(offsetof(Drone_HandleIntPlayerSettingChange, SettingType) == 0x000000, "Member 'Drone_HandleIntPlayerSettingChange::SettingType' has a wrong offset!");
static_assert(offsetof(Drone_HandleIntPlayerSettingChange, NewValue) == 0x000004, "Member 'Drone_HandleIntPlayerSettingChange::NewValue' has a wrong offset!");

// Function DeceiveInc.Drone.HandleScramblerIsAffectedChanged
// 0x0010 (0x0010 - 0x0000)
struct Drone_HandleScramblerIsAffectedChanged final
{
public:
	bool                                          bIsAffected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AffectedActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Drone_HandleScramblerIsAffectedChanged) == 0x000008, "Wrong alignment on Drone_HandleScramblerIsAffectedChanged");
static_assert(sizeof(Drone_HandleScramblerIsAffectedChanged) == 0x000010, "Wrong size on Drone_HandleScramblerIsAffectedChanged");
static_assert(offsetof(Drone_HandleScramblerIsAffectedChanged, bIsAffected) == 0x000000, "Member 'Drone_HandleScramblerIsAffectedChanged::bIsAffected' has a wrong offset!");
static_assert(offsetof(Drone_HandleScramblerIsAffectedChanged, AffectedActor) == 0x000008, "Member 'Drone_HandleScramblerIsAffectedChanged::AffectedActor' has a wrong offset!");

// Function DeceiveInc.Drone.LocalReleaseControl
// 0x0008 (0x0008 - 0x0000)
struct Drone_LocalReleaseControl final
{
public:
	class ASpy*                                   OriginalSpy;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Drone_LocalReleaseControl) == 0x000008, "Wrong alignment on Drone_LocalReleaseControl");
static_assert(sizeof(Drone_LocalReleaseControl) == 0x000008, "Wrong size on Drone_LocalReleaseControl");
static_assert(offsetof(Drone_LocalReleaseControl, OriginalSpy) == 0x000000, "Member 'Drone_LocalReleaseControl::OriginalSpy' has a wrong offset!");

// Function DeceiveInc.Drone.LocalTakeControl
// 0x0008 (0x0008 - 0x0000)
struct Drone_LocalTakeControl final
{
public:
	class ASpy*                                   OriginalSpy;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Drone_LocalTakeControl) == 0x000008, "Wrong alignment on Drone_LocalTakeControl");
static_assert(sizeof(Drone_LocalTakeControl) == 0x000008, "Wrong size on Drone_LocalTakeControl");
static_assert(offsetof(Drone_LocalTakeControl, OriginalSpy) == 0x000000, "Member 'Drone_LocalTakeControl::OriginalSpy' has a wrong offset!");

// Function DeceiveInc.Drone.MulticastReleaseControl
// 0x0008 (0x0008 - 0x0000)
struct Drone_MulticastReleaseControl final
{
public:
	class AController*                            Possesor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Drone_MulticastReleaseControl) == 0x000008, "Wrong alignment on Drone_MulticastReleaseControl");
static_assert(sizeof(Drone_MulticastReleaseControl) == 0x000008, "Wrong size on Drone_MulticastReleaseControl");
static_assert(offsetof(Drone_MulticastReleaseControl, Possesor) == 0x000000, "Member 'Drone_MulticastReleaseControl::Possesor' has a wrong offset!");

// Function DeceiveInc.Drone.MulticastTakeControl
// 0x0008 (0x0008 - 0x0000)
struct Drone_MulticastTakeControl final
{
public:
	class AController*                            Possesor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Drone_MulticastTakeControl) == 0x000008, "Wrong alignment on Drone_MulticastTakeControl");
static_assert(sizeof(Drone_MulticastTakeControl) == 0x000008, "Wrong size on Drone_MulticastTakeControl");
static_assert(offsetof(Drone_MulticastTakeControl, Possesor) == 0x000000, "Member 'Drone_MulticastTakeControl::Possesor' has a wrong offset!");

// Function DeceiveInc.Drone.OnRep_OriginalBody
// 0x0008 (0x0008 - 0x0000)
struct Drone_OnRep_OriginalBody final
{
public:
	class ASpy*                                   OldValue;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Drone_OnRep_OriginalBody) == 0x000008, "Wrong alignment on Drone_OnRep_OriginalBody");
static_assert(sizeof(Drone_OnRep_OriginalBody) == 0x000008, "Wrong size on Drone_OnRep_OriginalBody");
static_assert(offsetof(Drone_OnRep_OriginalBody, OldValue) == 0x000000, "Member 'Drone_OnRep_OriginalBody::OldValue' has a wrong offset!");

// Function DeceiveInc.Drone.OnRep_Spawner
// 0x0008 (0x0008 - 0x0000)
struct Drone_OnRep_Spawner final
{
public:
	class ADroneSpawnerWeapon*                    OldValue;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Drone_OnRep_Spawner) == 0x000008, "Wrong alignment on Drone_OnRep_Spawner");
static_assert(sizeof(Drone_OnRep_Spawner) == 0x000008, "Wrong size on Drone_OnRep_Spawner");
static_assert(offsetof(Drone_OnRep_Spawner, OldValue) == 0x000000, "Member 'Drone_OnRep_Spawner::OldValue' has a wrong offset!");

// Function DeceiveInc.Drone.OnRep_Weapon
// 0x0008 (0x0008 - 0x0000)
struct Drone_OnRep_Weapon final
{
public:
	class ADroneSpawnerWeapon*                    OldValue;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Drone_OnRep_Weapon) == 0x000008, "Wrong alignment on Drone_OnRep_Weapon");
static_assert(sizeof(Drone_OnRep_Weapon) == 0x000008, "Wrong size on Drone_OnRep_Weapon");
static_assert(offsetof(Drone_OnRep_Weapon, OldValue) == 0x000000, "Member 'Drone_OnRep_Weapon::OldValue' has a wrong offset!");

// Function DeceiveInc.Drone.Server_SpawnPing
// 0x0020 (0x0020 - 0x0000)
struct Drone_Server_SpawnPing final
{
public:
	struct FVector_NetQuantize                    Position;                                          // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUrgent;                                           // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RadialPingIndex;                                   // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Drone_Server_SpawnPing) == 0x000008, "Wrong alignment on Drone_Server_SpawnPing");
static_assert(sizeof(Drone_Server_SpawnPing) == 0x000020, "Wrong size on Drone_Server_SpawnPing");
static_assert(offsetof(Drone_Server_SpawnPing, Position) == 0x000000, "Member 'Drone_Server_SpawnPing::Position' has a wrong offset!");
static_assert(offsetof(Drone_Server_SpawnPing, TargetActor) == 0x000010, "Member 'Drone_Server_SpawnPing::TargetActor' has a wrong offset!");
static_assert(offsetof(Drone_Server_SpawnPing, bUrgent) == 0x000018, "Member 'Drone_Server_SpawnPing::bUrgent' has a wrong offset!");
static_assert(offsetof(Drone_Server_SpawnPing, RadialPingIndex) == 0x00001C, "Member 'Drone_Server_SpawnPing::RadialPingIndex' has a wrong offset!");

// Function DeceiveInc.Drone.ServerUpdateSpeed
// 0x0001 (0x0001 - 0x0000)
struct Drone_ServerUpdateSpeed final
{
public:
	bool                                          bIsSpeeding;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Drone_ServerUpdateSpeed) == 0x000001, "Wrong alignment on Drone_ServerUpdateSpeed");
static_assert(sizeof(Drone_ServerUpdateSpeed) == 0x000001, "Wrong size on Drone_ServerUpdateSpeed");
static_assert(offsetof(Drone_ServerUpdateSpeed, bIsSpeeding) == 0x000000, "Member 'Drone_ServerUpdateSpeed::bIsSpeeding' has a wrong offset!");

// Function DeceiveInc.DroneSpawnerWeapon.GetDartCooldownRatio
// 0x0004 (0x0004 - 0x0000)
struct DroneSpawnerWeapon_GetDartCooldownRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DroneSpawnerWeapon_GetDartCooldownRatio) == 0x000004, "Wrong alignment on DroneSpawnerWeapon_GetDartCooldownRatio");
static_assert(sizeof(DroneSpawnerWeapon_GetDartCooldownRatio) == 0x000004, "Wrong size on DroneSpawnerWeapon_GetDartCooldownRatio");
static_assert(offsetof(DroneSpawnerWeapon_GetDartCooldownRatio, ReturnValue) == 0x000000, "Member 'DroneSpawnerWeapon_GetDartCooldownRatio::ReturnValue' has a wrong offset!");

// Function DeceiveInc.DroneSpawnerWeapon.HandleDartCooldownChange
// 0x0001 (0x0001 - 0x0000)
struct DroneSpawnerWeapon_HandleDartCooldownChange final
{
public:
	bool                                          bOnCooldown;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DroneSpawnerWeapon_HandleDartCooldownChange) == 0x000001, "Wrong alignment on DroneSpawnerWeapon_HandleDartCooldownChange");
static_assert(sizeof(DroneSpawnerWeapon_HandleDartCooldownChange) == 0x000001, "Wrong size on DroneSpawnerWeapon_HandleDartCooldownChange");
static_assert(offsetof(DroneSpawnerWeapon_HandleDartCooldownChange, bOnCooldown) == 0x000000, "Member 'DroneSpawnerWeapon_HandleDartCooldownChange::bOnCooldown' has a wrong offset!");

// Function DeceiveInc.DroneSpawnerWeapon.HandleDroneCooldownChange
// 0x0001 (0x0001 - 0x0000)
struct DroneSpawnerWeapon_HandleDroneCooldownChange final
{
public:
	bool                                          bOnCooldown;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DroneSpawnerWeapon_HandleDroneCooldownChange) == 0x000001, "Wrong alignment on DroneSpawnerWeapon_HandleDroneCooldownChange");
static_assert(sizeof(DroneSpawnerWeapon_HandleDroneCooldownChange) == 0x000001, "Wrong size on DroneSpawnerWeapon_HandleDroneCooldownChange");
static_assert(offsetof(DroneSpawnerWeapon_HandleDroneCooldownChange, bOnCooldown) == 0x000000, "Member 'DroneSpawnerWeapon_HandleDroneCooldownChange::bOnCooldown' has a wrong offset!");

// Function DeceiveInc.DroneSpawnerWeapon.HandleResourceChanged
// 0x0028 (0x0028 - 0x0000)
struct DroneSpawnerWeapon_HandleResourceChanged final
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ResourceDisplayName;                               // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DroneSpawnerWeapon_HandleResourceChanged) == 0x000008, "Wrong alignment on DroneSpawnerWeapon_HandleResourceChanged");
static_assert(sizeof(DroneSpawnerWeapon_HandleResourceChanged) == 0x000028, "Wrong size on DroneSpawnerWeapon_HandleResourceChanged");
static_assert(offsetof(DroneSpawnerWeapon_HandleResourceChanged, ResourceType) == 0x000000, "Member 'DroneSpawnerWeapon_HandleResourceChanged::ResourceType' has a wrong offset!");
static_assert(offsetof(DroneSpawnerWeapon_HandleResourceChanged, ResourceDisplayName) == 0x000008, "Member 'DroneSpawnerWeapon_HandleResourceChanged::ResourceDisplayName' has a wrong offset!");
static_assert(offsetof(DroneSpawnerWeapon_HandleResourceChanged, Amount) == 0x000020, "Member 'DroneSpawnerWeapon_HandleResourceChanged::Amount' has a wrong offset!");

// Function DeceiveInc.DroneSpawnerWeapon.ServerDestroyDrone
// 0x0001 (0x0001 - 0x0000)
struct DroneSpawnerWeapon_ServerDestroyDrone final
{
public:
	bool                                          bDestroyed;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DroneSpawnerWeapon_ServerDestroyDrone) == 0x000001, "Wrong alignment on DroneSpawnerWeapon_ServerDestroyDrone");
static_assert(sizeof(DroneSpawnerWeapon_ServerDestroyDrone) == 0x000001, "Wrong size on DroneSpawnerWeapon_ServerDestroyDrone");
static_assert(offsetof(DroneSpawnerWeapon_ServerDestroyDrone, bDestroyed) == 0x000000, "Member 'DroneSpawnerWeapon_ServerDestroyDrone::bDestroyed' has a wrong offset!");

// Function DeceiveInc.ExtractionInteractableActor.BP_PlayerExtractedServer
// 0x0008 (0x0008 - 0x0000)
struct ExtractionInteractableActor_BP_PlayerExtractedServer final
{
public:
	class AActor*                                 Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExtractionInteractableActor_BP_PlayerExtractedServer) == 0x000008, "Wrong alignment on ExtractionInteractableActor_BP_PlayerExtractedServer");
static_assert(sizeof(ExtractionInteractableActor_BP_PlayerExtractedServer) == 0x000008, "Wrong size on ExtractionInteractableActor_BP_PlayerExtractedServer");
static_assert(offsetof(ExtractionInteractableActor_BP_PlayerExtractedServer, Player) == 0x000000, "Member 'ExtractionInteractableActor_BP_PlayerExtractedServer::Player' has a wrong offset!");

// Function DeceiveInc.ExtractionInteractableActor.GetExtractionRatio
// 0x0004 (0x0004 - 0x0000)
struct ExtractionInteractableActor_GetExtractionRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExtractionInteractableActor_GetExtractionRatio) == 0x000004, "Wrong alignment on ExtractionInteractableActor_GetExtractionRatio");
static_assert(sizeof(ExtractionInteractableActor_GetExtractionRatio) == 0x000004, "Wrong size on ExtractionInteractableActor_GetExtractionRatio");
static_assert(offsetof(ExtractionInteractableActor_GetExtractionRatio, ReturnValue) == 0x000000, "Member 'ExtractionInteractableActor_GetExtractionRatio::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ExtractionInteractableActor.HandleComponentOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct ExtractionInteractableActor_HandleComponentOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ExtractionInteractableActor_HandleComponentOverlapEnd) == 0x000008, "Wrong alignment on ExtractionInteractableActor_HandleComponentOverlapEnd");
static_assert(sizeof(ExtractionInteractableActor_HandleComponentOverlapEnd) == 0x000020, "Wrong size on ExtractionInteractableActor_HandleComponentOverlapEnd");
static_assert(offsetof(ExtractionInteractableActor_HandleComponentOverlapEnd, OverlappedComponent) == 0x000000, "Member 'ExtractionInteractableActor_HandleComponentOverlapEnd::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(ExtractionInteractableActor_HandleComponentOverlapEnd, OtherActor) == 0x000008, "Member 'ExtractionInteractableActor_HandleComponentOverlapEnd::OtherActor' has a wrong offset!");
static_assert(offsetof(ExtractionInteractableActor_HandleComponentOverlapEnd, OtherComp) == 0x000010, "Member 'ExtractionInteractableActor_HandleComponentOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(ExtractionInteractableActor_HandleComponentOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'ExtractionInteractableActor_HandleComponentOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function DeceiveInc.ExtractionInteractableActor.HandleComponentOverlapStart
// 0x00A8 (0x00A8 - 0x0000)
struct ExtractionInteractableActor_HandleComponentOverlapStart final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExtractionInteractableActor_HandleComponentOverlapStart) == 0x000008, "Wrong alignment on ExtractionInteractableActor_HandleComponentOverlapStart");
static_assert(sizeof(ExtractionInteractableActor_HandleComponentOverlapStart) == 0x0000A8, "Wrong size on ExtractionInteractableActor_HandleComponentOverlapStart");
static_assert(offsetof(ExtractionInteractableActor_HandleComponentOverlapStart, OverlappedComponent) == 0x000000, "Member 'ExtractionInteractableActor_HandleComponentOverlapStart::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(ExtractionInteractableActor_HandleComponentOverlapStart, OtherActor) == 0x000008, "Member 'ExtractionInteractableActor_HandleComponentOverlapStart::OtherActor' has a wrong offset!");
static_assert(offsetof(ExtractionInteractableActor_HandleComponentOverlapStart, OtherComp) == 0x000010, "Member 'ExtractionInteractableActor_HandleComponentOverlapStart::OtherComp' has a wrong offset!");
static_assert(offsetof(ExtractionInteractableActor_HandleComponentOverlapStart, OtherBodyIndex) == 0x000018, "Member 'ExtractionInteractableActor_HandleComponentOverlapStart::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(ExtractionInteractableActor_HandleComponentOverlapStart, bFromSweep) == 0x00001C, "Member 'ExtractionInteractableActor_HandleComponentOverlapStart::bFromSweep' has a wrong offset!");
static_assert(offsetof(ExtractionInteractableActor_HandleComponentOverlapStart, SweepResult) == 0x000020, "Member 'ExtractionInteractableActor_HandleComponentOverlapStart::SweepResult' has a wrong offset!");

// Function DeceiveInc.ExtractionInteractableActor.HandleExfilArrivedEvent
// 0x0008 (0x0008 - 0x0000)
struct ExtractionInteractableActor_HandleExfilArrivedEvent final
{
public:
	class UExtractionArrivedPhaseInfo*            PhaseInfo;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExtractionInteractableActor_HandleExfilArrivedEvent) == 0x000008, "Wrong alignment on ExtractionInteractableActor_HandleExfilArrivedEvent");
static_assert(sizeof(ExtractionInteractableActor_HandleExfilArrivedEvent) == 0x000008, "Wrong size on ExtractionInteractableActor_HandleExfilArrivedEvent");
static_assert(offsetof(ExtractionInteractableActor_HandleExfilArrivedEvent, PhaseInfo) == 0x000000, "Member 'ExtractionInteractableActor_HandleExfilArrivedEvent::PhaseInfo' has a wrong offset!");

// Function DeceiveInc.ExtractionInteractableActor.HandleExfilArrivingEvent
// 0x0008 (0x0008 - 0x0000)
struct ExtractionInteractableActor_HandleExfilArrivingEvent final
{
public:
	class UExtractionArrivingPhaseInfo*           PhaseInfo;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExtractionInteractableActor_HandleExfilArrivingEvent) == 0x000008, "Wrong alignment on ExtractionInteractableActor_HandleExfilArrivingEvent");
static_assert(sizeof(ExtractionInteractableActor_HandleExfilArrivingEvent) == 0x000008, "Wrong size on ExtractionInteractableActor_HandleExfilArrivingEvent");
static_assert(offsetof(ExtractionInteractableActor_HandleExfilArrivingEvent, PhaseInfo) == 0x000000, "Member 'ExtractionInteractableActor_HandleExfilArrivingEvent::PhaseInfo' has a wrong offset!");

// Function DeceiveInc.ExtractionInteractableActor.HandleGamePhaseTick
// 0x0004 (0x0004 - 0x0000)
struct ExtractionInteractableActor_HandleGamePhaseTick final
{
public:
	int32                                         RemainingTime;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExtractionInteractableActor_HandleGamePhaseTick) == 0x000004, "Wrong alignment on ExtractionInteractableActor_HandleGamePhaseTick");
static_assert(sizeof(ExtractionInteractableActor_HandleGamePhaseTick) == 0x000004, "Wrong size on ExtractionInteractableActor_HandleGamePhaseTick");
static_assert(offsetof(ExtractionInteractableActor_HandleGamePhaseTick, RemainingTime) == 0x000000, "Member 'ExtractionInteractableActor_HandleGamePhaseTick::RemainingTime' has a wrong offset!");

// Function DeceiveInc.ExtractionInteractableActor.HandleObjectiveDropped
// 0x0008 (0x0008 - 0x0000)
struct ExtractionInteractableActor_HandleObjectiveDropped final
{
public:
	class ASpy*                                   Carrier;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExtractionInteractableActor_HandleObjectiveDropped) == 0x000008, "Wrong alignment on ExtractionInteractableActor_HandleObjectiveDropped");
static_assert(sizeof(ExtractionInteractableActor_HandleObjectiveDropped) == 0x000008, "Wrong size on ExtractionInteractableActor_HandleObjectiveDropped");
static_assert(offsetof(ExtractionInteractableActor_HandleObjectiveDropped, Carrier) == 0x000000, "Member 'ExtractionInteractableActor_HandleObjectiveDropped::Carrier' has a wrong offset!");

// Function DeceiveInc.ExtractionInteractableActor.HandleObjectivePickedUp
// 0x0008 (0x0008 - 0x0000)
struct ExtractionInteractableActor_HandleObjectivePickedUp final
{
public:
	class ASpy*                                   Carrier;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExtractionInteractableActor_HandleObjectivePickedUp) == 0x000008, "Wrong alignment on ExtractionInteractableActor_HandleObjectivePickedUp");
static_assert(sizeof(ExtractionInteractableActor_HandleObjectivePickedUp) == 0x000008, "Wrong size on ExtractionInteractableActor_HandleObjectivePickedUp");
static_assert(offsetof(ExtractionInteractableActor_HandleObjectivePickedUp, Carrier) == 0x000000, "Member 'ExtractionInteractableActor_HandleObjectivePickedUp::Carrier' has a wrong offset!");

// Function DeceiveInc.ExtractionInteractableActor.OnExfilInitialize
// 0x0001 (0x0001 - 0x0000)
struct ExtractionInteractableActor_OnExfilInitialize final
{
public:
	bool                                          bArriveNow;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExtractionInteractableActor_OnExfilInitialize) == 0x000001, "Wrong alignment on ExtractionInteractableActor_OnExfilInitialize");
static_assert(sizeof(ExtractionInteractableActor_OnExfilInitialize) == 0x000001, "Wrong size on ExtractionInteractableActor_OnExfilInitialize");
static_assert(offsetof(ExtractionInteractableActor_OnExfilInitialize, bArriveNow) == 0x000000, "Member 'ExtractionInteractableActor_OnExfilInitialize::bArriveNow' has a wrong offset!");

// Function DeceiveInc.ExtractionInteractableActor.OnRep_ExtractionActorReplicatedState
// 0x0001 (0x0001 - 0x0000)
struct ExtractionInteractableActor_OnRep_ExtractionActorReplicatedState final
{
public:
	EExtractionActorReplicatedState               PrevState;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExtractionInteractableActor_OnRep_ExtractionActorReplicatedState) == 0x000001, "Wrong alignment on ExtractionInteractableActor_OnRep_ExtractionActorReplicatedState");
static_assert(sizeof(ExtractionInteractableActor_OnRep_ExtractionActorReplicatedState) == 0x000001, "Wrong size on ExtractionInteractableActor_OnRep_ExtractionActorReplicatedState");
static_assert(offsetof(ExtractionInteractableActor_OnRep_ExtractionActorReplicatedState, PrevState) == 0x000000, "Member 'ExtractionInteractableActor_OnRep_ExtractionActorReplicatedState::PrevState' has a wrong offset!");

// Function DeceiveInc.GameplayBotBrain.OnFightTargetLost
// 0x0010 (0x0010 - 0x0000)
struct GameplayBotBrain_OnFightTargetLost final
{
public:
	class UBotPlanFight*                          BotPlanFight;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   LostTarget;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayBotBrain_OnFightTargetLost) == 0x000008, "Wrong alignment on GameplayBotBrain_OnFightTargetLost");
static_assert(sizeof(GameplayBotBrain_OnFightTargetLost) == 0x000010, "Wrong size on GameplayBotBrain_OnFightTargetLost");
static_assert(offsetof(GameplayBotBrain_OnFightTargetLost, BotPlanFight) == 0x000000, "Member 'GameplayBotBrain_OnFightTargetLost::BotPlanFight' has a wrong offset!");
static_assert(offsetof(GameplayBotBrain_OnFightTargetLost, LostTarget) == 0x000008, "Member 'GameplayBotBrain_OnFightTargetLost::LostTarget' has a wrong offset!");

// Function DeceiveInc.GameplayBotBrain.OnGamePhaseChanged
// 0x0001 (0x0001 - 0x0000)
struct GameplayBotBrain_OnGamePhaseChanged final
{
public:
	ESpyGamePhase                                 NewGamePhase;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayBotBrain_OnGamePhaseChanged) == 0x000001, "Wrong alignment on GameplayBotBrain_OnGamePhaseChanged");
static_assert(sizeof(GameplayBotBrain_OnGamePhaseChanged) == 0x000001, "Wrong size on GameplayBotBrain_OnGamePhaseChanged");
static_assert(offsetof(GameplayBotBrain_OnGamePhaseChanged, NewGamePhase) == 0x000000, "Member 'GameplayBotBrain_OnGamePhaseChanged::NewGamePhase' has a wrong offset!");

// Function DeceiveInc.GameplayBotBrain.OnHealthChanged
// 0x0030 (0x0030 - 0x0000)
struct GameplayBotBrain_OnHealthChanged final
{
public:
	class UHealthComponent*                       OwningHealthComp;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthDelta;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDamageType*                      DamageType;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RawDamage;                                         // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayBotBrain_OnHealthChanged) == 0x000008, "Wrong alignment on GameplayBotBrain_OnHealthChanged");
static_assert(sizeof(GameplayBotBrain_OnHealthChanged) == 0x000030, "Wrong size on GameplayBotBrain_OnHealthChanged");
static_assert(offsetof(GameplayBotBrain_OnHealthChanged, OwningHealthComp) == 0x000000, "Member 'GameplayBotBrain_OnHealthChanged::OwningHealthComp' has a wrong offset!");
static_assert(offsetof(GameplayBotBrain_OnHealthChanged, Health) == 0x000008, "Member 'GameplayBotBrain_OnHealthChanged::Health' has a wrong offset!");
static_assert(offsetof(GameplayBotBrain_OnHealthChanged, HealthDelta) == 0x00000C, "Member 'GameplayBotBrain_OnHealthChanged::HealthDelta' has a wrong offset!");
static_assert(offsetof(GameplayBotBrain_OnHealthChanged, DamageType) == 0x000010, "Member 'GameplayBotBrain_OnHealthChanged::DamageType' has a wrong offset!");
static_assert(offsetof(GameplayBotBrain_OnHealthChanged, InstigatedBy) == 0x000018, "Member 'GameplayBotBrain_OnHealthChanged::InstigatedBy' has a wrong offset!");
static_assert(offsetof(GameplayBotBrain_OnHealthChanged, DamageCauser) == 0x000020, "Member 'GameplayBotBrain_OnHealthChanged::DamageCauser' has a wrong offset!");
static_assert(offsetof(GameplayBotBrain_OnHealthChanged, RawDamage) == 0x000028, "Member 'GameplayBotBrain_OnHealthChanged::RawDamage' has a wrong offset!");

// Function DeceiveInc.GameplayBotBrain.OnResourceChange
// 0x0028 (0x0028 - 0x0000)
struct GameplayBotBrain_OnResourceChange final
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ResourceDisplayName;                               // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayBotBrain_OnResourceChange) == 0x000008, "Wrong alignment on GameplayBotBrain_OnResourceChange");
static_assert(sizeof(GameplayBotBrain_OnResourceChange) == 0x000028, "Wrong size on GameplayBotBrain_OnResourceChange");
static_assert(offsetof(GameplayBotBrain_OnResourceChange, ResourceType) == 0x000000, "Member 'GameplayBotBrain_OnResourceChange::ResourceType' has a wrong offset!");
static_assert(offsetof(GameplayBotBrain_OnResourceChange, ResourceDisplayName) == 0x000008, "Member 'GameplayBotBrain_OnResourceChange::ResourceDisplayName' has a wrong offset!");
static_assert(offsetof(GameplayBotBrain_OnResourceChange, Amount) == 0x000020, "Member 'GameplayBotBrain_OnResourceChange::Amount' has a wrong offset!");

// Function DeceiveInc.GameplayBotBrain.OnSpyExtractingChange
// 0x0018 (0x0018 - 0x0000)
struct GameplayBotBrain_OnSpyExtractingChange final
{
public:
	class AExtractionInteractableActor*           ExtractPointIn;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   ExtractingSpyIn;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExtractingIn;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayBotBrain_OnSpyExtractingChange) == 0x000008, "Wrong alignment on GameplayBotBrain_OnSpyExtractingChange");
static_assert(sizeof(GameplayBotBrain_OnSpyExtractingChange) == 0x000018, "Wrong size on GameplayBotBrain_OnSpyExtractingChange");
static_assert(offsetof(GameplayBotBrain_OnSpyExtractingChange, ExtractPointIn) == 0x000000, "Member 'GameplayBotBrain_OnSpyExtractingChange::ExtractPointIn' has a wrong offset!");
static_assert(offsetof(GameplayBotBrain_OnSpyExtractingChange, ExtractingSpyIn) == 0x000008, "Member 'GameplayBotBrain_OnSpyExtractingChange::ExtractingSpyIn' has a wrong offset!");
static_assert(offsetof(GameplayBotBrain_OnSpyExtractingChange, bExtractingIn) == 0x000010, "Member 'GameplayBotBrain_OnSpyExtractingChange::bExtractingIn' has a wrong offset!");

// Function DeceiveInc.GameplayBotBrain.OnUndercoverChange
// 0x0001 (0x0001 - 0x0000)
struct GameplayBotBrain_OnUndercoverChange final
{
public:
	bool                                          bUndercover;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayBotBrain_OnUndercoverChange) == 0x000001, "Wrong alignment on GameplayBotBrain_OnUndercoverChange");
static_assert(sizeof(GameplayBotBrain_OnUndercoverChange) == 0x000001, "Wrong size on GameplayBotBrain_OnUndercoverChange");
static_assert(offsetof(GameplayBotBrain_OnUndercoverChange, bUndercover) == 0x000000, "Member 'GameplayBotBrain_OnUndercoverChange::bUndercover' has a wrong offset!");

// Function DeceiveInc.GameplayBotBrain.OnVaultTerminalUnlockedCountChange
// 0x0004 (0x0004 - 0x0000)
struct GameplayBotBrain_OnVaultTerminalUnlockedCountChange final
{
public:
	int32                                         VaultTerminalUnlockedCount;                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayBotBrain_OnVaultTerminalUnlockedCountChange) == 0x000004, "Wrong alignment on GameplayBotBrain_OnVaultTerminalUnlockedCountChange");
static_assert(sizeof(GameplayBotBrain_OnVaultTerminalUnlockedCountChange) == 0x000004, "Wrong size on GameplayBotBrain_OnVaultTerminalUnlockedCountChange");
static_assert(offsetof(GameplayBotBrain_OnVaultTerminalUnlockedCountChange, VaultTerminalUnlockedCount) == 0x000000, "Member 'GameplayBotBrain_OnVaultTerminalUnlockedCountChange::VaultTerminalUnlockedCount' has a wrong offset!");

// Function DeceiveInc.GameplayEventBus.FireOnNPCKilledEvent
// 0x0010 (0x0010 - 0x0000)
struct GameplayEventBus_FireOnNPCKilledEvent final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANPCCharacter*                          NPC;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayEventBus_FireOnNPCKilledEvent) == 0x000008, "Wrong alignment on GameplayEventBus_FireOnNPCKilledEvent");
static_assert(sizeof(GameplayEventBus_FireOnNPCKilledEvent) == 0x000010, "Wrong size on GameplayEventBus_FireOnNPCKilledEvent");
static_assert(offsetof(GameplayEventBus_FireOnNPCKilledEvent, Spy) == 0x000000, "Member 'GameplayEventBus_FireOnNPCKilledEvent::Spy' has a wrong offset!");
static_assert(offsetof(GameplayEventBus_FireOnNPCKilledEvent, NPC) == 0x000008, "Member 'GameplayEventBus_FireOnNPCKilledEvent::NPC' has a wrong offset!");

// Function DeceiveInc.GameplayEventBus.FireOnSpyHeatChanged
// 0x0010 (0x0010 - 0x0000)
struct GameplayEventBus_FireOnSpyHeatChanged final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewHeatValue;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeatDelta;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayEventBus_FireOnSpyHeatChanged) == 0x000008, "Wrong alignment on GameplayEventBus_FireOnSpyHeatChanged");
static_assert(sizeof(GameplayEventBus_FireOnSpyHeatChanged) == 0x000010, "Wrong size on GameplayEventBus_FireOnSpyHeatChanged");
static_assert(offsetof(GameplayEventBus_FireOnSpyHeatChanged, Spy) == 0x000000, "Member 'GameplayEventBus_FireOnSpyHeatChanged::Spy' has a wrong offset!");
static_assert(offsetof(GameplayEventBus_FireOnSpyHeatChanged, NewHeatValue) == 0x000008, "Member 'GameplayEventBus_FireOnSpyHeatChanged::NewHeatValue' has a wrong offset!");
static_assert(offsetof(GameplayEventBus_FireOnSpyHeatChanged, HeatDelta) == 0x00000C, "Member 'GameplayEventBus_FireOnSpyHeatChanged::HeatDelta' has a wrong offset!");

// DelegateFunction DeceiveInc.GameplayEventBus.GameplayEventDelegate_CoverChanged__DelegateSignature
// 0x0010 (0x0010 - 0x0000)
struct GameplayEventBus_GameplayEventDelegate_CoverChanged__DelegateSignature final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANPCCharacter*                          NewCover;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayEventBus_GameplayEventDelegate_CoverChanged__DelegateSignature) == 0x000008, "Wrong alignment on GameplayEventBus_GameplayEventDelegate_CoverChanged__DelegateSignature");
static_assert(sizeof(GameplayEventBus_GameplayEventDelegate_CoverChanged__DelegateSignature) == 0x000010, "Wrong size on GameplayEventBus_GameplayEventDelegate_CoverChanged__DelegateSignature");
static_assert(offsetof(GameplayEventBus_GameplayEventDelegate_CoverChanged__DelegateSignature, Spy) == 0x000000, "Member 'GameplayEventBus_GameplayEventDelegate_CoverChanged__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(GameplayEventBus_GameplayEventDelegate_CoverChanged__DelegateSignature, NewCover) == 0x000008, "Member 'GameplayEventBus_GameplayEventDelegate_CoverChanged__DelegateSignature::NewCover' has a wrong offset!");

// DelegateFunction DeceiveInc.GameplayEventBus.GameplayEventDelegate_GamePhaseChange__DelegateSignature
// 0x0010 (0x0010 - 0x0000)
struct GameplayEventBus_GameplayEventDelegate_GamePhaseChange__DelegateSignature final
{
public:
	ESpyGamePhase                                 NewPhase;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class ADeceiveIncMatchGameState*        GameState;                                         // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayEventBus_GameplayEventDelegate_GamePhaseChange__DelegateSignature) == 0x000008, "Wrong alignment on GameplayEventBus_GameplayEventDelegate_GamePhaseChange__DelegateSignature");
static_assert(sizeof(GameplayEventBus_GameplayEventDelegate_GamePhaseChange__DelegateSignature) == 0x000010, "Wrong size on GameplayEventBus_GameplayEventDelegate_GamePhaseChange__DelegateSignature");
static_assert(offsetof(GameplayEventBus_GameplayEventDelegate_GamePhaseChange__DelegateSignature, NewPhase) == 0x000000, "Member 'GameplayEventBus_GameplayEventDelegate_GamePhaseChange__DelegateSignature::NewPhase' has a wrong offset!");
static_assert(offsetof(GameplayEventBus_GameplayEventDelegate_GamePhaseChange__DelegateSignature, GameState) == 0x000008, "Member 'GameplayEventBus_GameplayEventDelegate_GamePhaseChange__DelegateSignature::GameState' has a wrong offset!");

// DelegateFunction DeceiveInc.GameplayEventBus.GameplayEventDelegate_HealthSpecific__DelegateSignature
// 0x0030 (0x0030 - 0x0000)
struct GameplayEventBus_GameplayEventDelegate_HealthSpecific__DelegateSignature final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHealthComponent*                       OwningHealthComp;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthDelta;                                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDamageType*                      DamageType;                                        // 0x0018(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayEventBus_GameplayEventDelegate_HealthSpecific__DelegateSignature) == 0x000008, "Wrong alignment on GameplayEventBus_GameplayEventDelegate_HealthSpecific__DelegateSignature");
static_assert(sizeof(GameplayEventBus_GameplayEventDelegate_HealthSpecific__DelegateSignature) == 0x000030, "Wrong size on GameplayEventBus_GameplayEventDelegate_HealthSpecific__DelegateSignature");
static_assert(offsetof(GameplayEventBus_GameplayEventDelegate_HealthSpecific__DelegateSignature, Spy) == 0x000000, "Member 'GameplayEventBus_GameplayEventDelegate_HealthSpecific__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(GameplayEventBus_GameplayEventDelegate_HealthSpecific__DelegateSignature, OwningHealthComp) == 0x000008, "Member 'GameplayEventBus_GameplayEventDelegate_HealthSpecific__DelegateSignature::OwningHealthComp' has a wrong offset!");
static_assert(offsetof(GameplayEventBus_GameplayEventDelegate_HealthSpecific__DelegateSignature, Health) == 0x000010, "Member 'GameplayEventBus_GameplayEventDelegate_HealthSpecific__DelegateSignature::Health' has a wrong offset!");
static_assert(offsetof(GameplayEventBus_GameplayEventDelegate_HealthSpecific__DelegateSignature, HealthDelta) == 0x000014, "Member 'GameplayEventBus_GameplayEventDelegate_HealthSpecific__DelegateSignature::HealthDelta' has a wrong offset!");
static_assert(offsetof(GameplayEventBus_GameplayEventDelegate_HealthSpecific__DelegateSignature, DamageType) == 0x000018, "Member 'GameplayEventBus_GameplayEventDelegate_HealthSpecific__DelegateSignature::DamageType' has a wrong offset!");
static_assert(offsetof(GameplayEventBus_GameplayEventDelegate_HealthSpecific__DelegateSignature, InstigatedBy) == 0x000020, "Member 'GameplayEventBus_GameplayEventDelegate_HealthSpecific__DelegateSignature::InstigatedBy' has a wrong offset!");
static_assert(offsetof(GameplayEventBus_GameplayEventDelegate_HealthSpecific__DelegateSignature, DamageCauser) == 0x000028, "Member 'GameplayEventBus_GameplayEventDelegate_HealthSpecific__DelegateSignature::DamageCauser' has a wrong offset!");

// DelegateFunction DeceiveInc.GameplayEventBus.GameplayEventDelegate_NewPlayerState__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct GameplayEventBus_GameplayEventDelegate_NewPlayerState__DelegateSignature final
{
public:
	class ADIPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayEventBus_GameplayEventDelegate_NewPlayerState__DelegateSignature) == 0x000008, "Wrong alignment on GameplayEventBus_GameplayEventDelegate_NewPlayerState__DelegateSignature");
static_assert(sizeof(GameplayEventBus_GameplayEventDelegate_NewPlayerState__DelegateSignature) == 0x000008, "Wrong size on GameplayEventBus_GameplayEventDelegate_NewPlayerState__DelegateSignature");
static_assert(offsetof(GameplayEventBus_GameplayEventDelegate_NewPlayerState__DelegateSignature, PlayerState) == 0x000000, "Member 'GameplayEventBus_GameplayEventDelegate_NewPlayerState__DelegateSignature::PlayerState' has a wrong offset!");

// DelegateFunction DeceiveInc.GameplayEventBus.GameplayEventDelegate_SpyHeatChange__DelegateSignature
// 0x0010 (0x0010 - 0x0000)
struct GameplayEventBus_GameplayEventDelegate_SpyHeatChange__DelegateSignature final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewHeatValue;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeatDelta;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayEventBus_GameplayEventDelegate_SpyHeatChange__DelegateSignature) == 0x000008, "Wrong alignment on GameplayEventBus_GameplayEventDelegate_SpyHeatChange__DelegateSignature");
static_assert(sizeof(GameplayEventBus_GameplayEventDelegate_SpyHeatChange__DelegateSignature) == 0x000010, "Wrong size on GameplayEventBus_GameplayEventDelegate_SpyHeatChange__DelegateSignature");
static_assert(offsetof(GameplayEventBus_GameplayEventDelegate_SpyHeatChange__DelegateSignature, Spy) == 0x000000, "Member 'GameplayEventBus_GameplayEventDelegate_SpyHeatChange__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(GameplayEventBus_GameplayEventDelegate_SpyHeatChange__DelegateSignature, NewHeatValue) == 0x000008, "Member 'GameplayEventBus_GameplayEventDelegate_SpyHeatChange__DelegateSignature::NewHeatValue' has a wrong offset!");
static_assert(offsetof(GameplayEventBus_GameplayEventDelegate_SpyHeatChange__DelegateSignature, HeatDelta) == 0x00000C, "Member 'GameplayEventBus_GameplayEventDelegate_SpyHeatChange__DelegateSignature::HeatDelta' has a wrong offset!");

// DelegateFunction DeceiveInc.GameplayEventBus.GameplayEventDelegate_SpySecuritySpecific__DelegateSignature
// 0x0010 (0x0010 - 0x0000)
struct GameplayEventBus_GameplayEventDelegate_SpySecuritySpecific__DelegateSignature final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpySecurityState                             PreviousState;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpySecurityState                             NewState;                                          // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayEventBus_GameplayEventDelegate_SpySecuritySpecific__DelegateSignature) == 0x000008, "Wrong alignment on GameplayEventBus_GameplayEventDelegate_SpySecuritySpecific__DelegateSignature");
static_assert(sizeof(GameplayEventBus_GameplayEventDelegate_SpySecuritySpecific__DelegateSignature) == 0x000010, "Wrong size on GameplayEventBus_GameplayEventDelegate_SpySecuritySpecific__DelegateSignature");
static_assert(offsetof(GameplayEventBus_GameplayEventDelegate_SpySecuritySpecific__DelegateSignature, Spy) == 0x000000, "Member 'GameplayEventBus_GameplayEventDelegate_SpySecuritySpecific__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(GameplayEventBus_GameplayEventDelegate_SpySecuritySpecific__DelegateSignature, PreviousState) == 0x000008, "Member 'GameplayEventBus_GameplayEventDelegate_SpySecuritySpecific__DelegateSignature::PreviousState' has a wrong offset!");
static_assert(offsetof(GameplayEventBus_GameplayEventDelegate_SpySecuritySpecific__DelegateSignature, NewState) == 0x000009, "Member 'GameplayEventBus_GameplayEventDelegate_SpySecuritySpecific__DelegateSignature::NewState' has a wrong offset!");

// DelegateFunction DeceiveInc.GameplayEventBus.GameplayEventDelegate_SpySpecific__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct GameplayEventBus_GameplayEventDelegate_SpySpecific__DelegateSignature final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayEventBus_GameplayEventDelegate_SpySpecific__DelegateSignature) == 0x000008, "Wrong alignment on GameplayEventBus_GameplayEventDelegate_SpySpecific__DelegateSignature");
static_assert(sizeof(GameplayEventBus_GameplayEventDelegate_SpySpecific__DelegateSignature) == 0x000008, "Wrong size on GameplayEventBus_GameplayEventDelegate_SpySpecific__DelegateSignature");
static_assert(offsetof(GameplayEventBus_GameplayEventDelegate_SpySpecific__DelegateSignature, Spy) == 0x000000, "Member 'GameplayEventBus_GameplayEventDelegate_SpySpecific__DelegateSignature::Spy' has a wrong offset!");

// DelegateFunction DeceiveInc.GameplayEventBus.GameplayEventDelegate_SpyVictimEffect__DelegateSignature
// 0x0010 (0x0010 - 0x0000)
struct GameplayEventBus_GameplayEventDelegate_SpyVictimEffect__DelegateSignature final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVictimEffect*                          VictimEffect;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayEventBus_GameplayEventDelegate_SpyVictimEffect__DelegateSignature) == 0x000008, "Wrong alignment on GameplayEventBus_GameplayEventDelegate_SpyVictimEffect__DelegateSignature");
static_assert(sizeof(GameplayEventBus_GameplayEventDelegate_SpyVictimEffect__DelegateSignature) == 0x000010, "Wrong size on GameplayEventBus_GameplayEventDelegate_SpyVictimEffect__DelegateSignature");
static_assert(offsetof(GameplayEventBus_GameplayEventDelegate_SpyVictimEffect__DelegateSignature, Spy) == 0x000000, "Member 'GameplayEventBus_GameplayEventDelegate_SpyVictimEffect__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(GameplayEventBus_GameplayEventDelegate_SpyVictimEffect__DelegateSignature, VictimEffect) == 0x000008, "Member 'GameplayEventBus_GameplayEventDelegate_SpyVictimEffect__DelegateSignature::VictimEffect' has a wrong offset!");

// Function DeceiveInc.GlobalEBusSubsystem.SignalBlueprintEbusStringEvent
// 0x0010 (0x0010 - 0x0000)
struct GlobalEBusSubsystem_SignalBlueprintEbusStringEvent final
{
public:
	class FString                                 StringEvent;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GlobalEBusSubsystem_SignalBlueprintEbusStringEvent) == 0x000008, "Wrong alignment on GlobalEBusSubsystem_SignalBlueprintEbusStringEvent");
static_assert(sizeof(GlobalEBusSubsystem_SignalBlueprintEbusStringEvent) == 0x000010, "Wrong size on GlobalEBusSubsystem_SignalBlueprintEbusStringEvent");
static_assert(offsetof(GlobalEBusSubsystem_SignalBlueprintEbusStringEvent, StringEvent) == 0x000000, "Member 'GlobalEBusSubsystem_SignalBlueprintEbusStringEvent::StringEvent' has a wrong offset!");

// Function DeceiveInc.GlobalEBusSubsystem.SignalLoadingScreenEvent
// 0x0010 (0x0010 - 0x0000)
struct GlobalEBusSubsystem_SignalLoadingScreenEvent final
{
public:
	class FString                                 LoadingEvent;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GlobalEBusSubsystem_SignalLoadingScreenEvent) == 0x000008, "Wrong alignment on GlobalEBusSubsystem_SignalLoadingScreenEvent");
static_assert(sizeof(GlobalEBusSubsystem_SignalLoadingScreenEvent) == 0x000010, "Wrong size on GlobalEBusSubsystem_SignalLoadingScreenEvent");
static_assert(offsetof(GlobalEBusSubsystem_SignalLoadingScreenEvent, LoadingEvent) == 0x000000, "Member 'GlobalEBusSubsystem_SignalLoadingScreenEvent::LoadingEvent' has a wrong offset!");

// Function DeceiveInc.GooPodTool.Server_ToggleGoo
// 0x0001 (0x0001 - 0x0000)
struct GooPodTool_Server_ToggleGoo final
{
public:
	bool                                          bIsActiveIn;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GooPodTool_Server_ToggleGoo) == 0x000001, "Wrong alignment on GooPodTool_Server_ToggleGoo");
static_assert(sizeof(GooPodTool_Server_ToggleGoo) == 0x000001, "Wrong size on GooPodTool_Server_ToggleGoo");
static_assert(offsetof(GooPodTool_Server_ToggleGoo, bIsActiveIn) == 0x000000, "Member 'GooPodTool_Server_ToggleGoo::bIsActiveIn' has a wrong offset!");

// Function DeceiveInc.HackTrapScannableComponent.BP_OnIsTrappedChanged
// 0x0001 (0x0001 - 0x0000)
struct HackTrapScannableComponent_BP_OnIsTrappedChanged final
{
public:
	bool                                          bIsTrapped;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HackTrapScannableComponent_BP_OnIsTrappedChanged) == 0x000001, "Wrong alignment on HackTrapScannableComponent_BP_OnIsTrappedChanged");
static_assert(sizeof(HackTrapScannableComponent_BP_OnIsTrappedChanged) == 0x000001, "Wrong size on HackTrapScannableComponent_BP_OnIsTrappedChanged");
static_assert(offsetof(HackTrapScannableComponent_BP_OnIsTrappedChanged, bIsTrapped) == 0x000000, "Member 'HackTrapScannableComponent_BP_OnIsTrappedChanged::bIsTrapped' has a wrong offset!");

// Function DeceiveInc.HackTrapScannableComponent.HandleInteractionComplete
// 0x0010 (0x0010 - 0x0000)
struct HackTrapScannableComponent_HandleInteractionComplete final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HackTrapScannableComponent_HandleInteractionComplete) == 0x000008, "Wrong alignment on HackTrapScannableComponent_HandleInteractionComplete");
static_assert(sizeof(HackTrapScannableComponent_HandleInteractionComplete) == 0x000010, "Wrong size on HackTrapScannableComponent_HandleInteractionComplete");
static_assert(offsetof(HackTrapScannableComponent_HandleInteractionComplete, Interacter) == 0x000000, "Member 'HackTrapScannableComponent_HandleInteractionComplete::Interacter' has a wrong offset!");
static_assert(offsetof(HackTrapScannableComponent_HandleInteractionComplete, Interactable) == 0x000008, "Member 'HackTrapScannableComponent_HandleInteractionComplete::Interactable' has a wrong offset!");

// Function DeceiveInc.HackTrapScannableComponent.HandleResourceSpent
// 0x0010 (0x0010 - 0x0000)
struct HackTrapScannableComponent_HandleResourceSpent final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayResourcesType                        ResourceType;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HackTrapScannableComponent_HandleResourceSpent) == 0x000008, "Wrong alignment on HackTrapScannableComponent_HandleResourceSpent");
static_assert(sizeof(HackTrapScannableComponent_HandleResourceSpent) == 0x000010, "Wrong size on HackTrapScannableComponent_HandleResourceSpent");
static_assert(offsetof(HackTrapScannableComponent_HandleResourceSpent, Interacter) == 0x000000, "Member 'HackTrapScannableComponent_HandleResourceSpent::Interacter' has a wrong offset!");
static_assert(offsetof(HackTrapScannableComponent_HandleResourceSpent, ResourceType) == 0x000008, "Member 'HackTrapScannableComponent_HandleResourceSpent::ResourceType' has a wrong offset!");
static_assert(offsetof(HackTrapScannableComponent_HandleResourceSpent, Amount) == 0x00000C, "Member 'HackTrapScannableComponent_HandleResourceSpent::Amount' has a wrong offset!");

// Function DeceiveInc.HackTrapScannableComponent.HandleSpyToolLoadComplete
// 0x0008 (0x0008 - 0x0000)
struct HackTrapScannableComponent_HandleSpyToolLoadComplete final
{
public:
	class UToolLoadoutComponent*                  ToolLoadout;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HackTrapScannableComponent_HandleSpyToolLoadComplete) == 0x000008, "Wrong alignment on HackTrapScannableComponent_HandleSpyToolLoadComplete");
static_assert(sizeof(HackTrapScannableComponent_HandleSpyToolLoadComplete) == 0x000008, "Wrong size on HackTrapScannableComponent_HandleSpyToolLoadComplete");
static_assert(offsetof(HackTrapScannableComponent_HandleSpyToolLoadComplete, ToolLoadout) == 0x000000, "Member 'HackTrapScannableComponent_HandleSpyToolLoadComplete::ToolLoadout' has a wrong offset!");

// Function DeceiveInc.HackTrapScannableComponent.IsTrappedByEnnemyFaction
// 0x0001 (0x0001 - 0x0000)
struct HackTrapScannableComponent_IsTrappedByEnnemyFaction final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HackTrapScannableComponent_IsTrappedByEnnemyFaction) == 0x000001, "Wrong alignment on HackTrapScannableComponent_IsTrappedByEnnemyFaction");
static_assert(sizeof(HackTrapScannableComponent_IsTrappedByEnnemyFaction) == 0x000001, "Wrong size on HackTrapScannableComponent_IsTrappedByEnnemyFaction");
static_assert(offsetof(HackTrapScannableComponent_IsTrappedByEnnemyFaction, ReturnValue) == 0x000000, "Member 'HackTrapScannableComponent_IsTrappedByEnnemyFaction::ReturnValue' has a wrong offset!");

// Function DeceiveInc.HackTrapScannableComponent.NetMulticast_IsDeviceTrappedChanged
// 0x0018 (0x0018 - 0x0000)
struct HackTrapScannableComponent_NetMulticast_IsDeviceTrappedChanged final
{
public:
	bool                                          bIsTrapped;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AHackTrapScannerTool*                   HackTrapScanner;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Interacter;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HackTrapScannableComponent_NetMulticast_IsDeviceTrappedChanged) == 0x000008, "Wrong alignment on HackTrapScannableComponent_NetMulticast_IsDeviceTrappedChanged");
static_assert(sizeof(HackTrapScannableComponent_NetMulticast_IsDeviceTrappedChanged) == 0x000018, "Wrong size on HackTrapScannableComponent_NetMulticast_IsDeviceTrappedChanged");
static_assert(offsetof(HackTrapScannableComponent_NetMulticast_IsDeviceTrappedChanged, bIsTrapped) == 0x000000, "Member 'HackTrapScannableComponent_NetMulticast_IsDeviceTrappedChanged::bIsTrapped' has a wrong offset!");
static_assert(offsetof(HackTrapScannableComponent_NetMulticast_IsDeviceTrappedChanged, HackTrapScanner) == 0x000008, "Member 'HackTrapScannableComponent_NetMulticast_IsDeviceTrappedChanged::HackTrapScanner' has a wrong offset!");
static_assert(offsetof(HackTrapScannableComponent_NetMulticast_IsDeviceTrappedChanged, Interacter) == 0x000010, "Member 'HackTrapScannableComponent_NetMulticast_IsDeviceTrappedChanged::Interacter' has a wrong offset!");

// Function DeceiveInc.HackTrapScannableComponent.OnRep_FactionScramblingDevice
// 0x0010 (0x0010 - 0x0000)
struct HackTrapScannableComponent_OnRep_FactionScramblingDevice final
{
public:
	TArray<int32>                                 OldFactionScramblingDevice;                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HackTrapScannableComponent_OnRep_FactionScramblingDevice) == 0x000008, "Wrong alignment on HackTrapScannableComponent_OnRep_FactionScramblingDevice");
static_assert(sizeof(HackTrapScannableComponent_OnRep_FactionScramblingDevice) == 0x000010, "Wrong size on HackTrapScannableComponent_OnRep_FactionScramblingDevice");
static_assert(offsetof(HackTrapScannableComponent_OnRep_FactionScramblingDevice, OldFactionScramblingDevice) == 0x000000, "Member 'HackTrapScannableComponent_OnRep_FactionScramblingDevice::OldFactionScramblingDevice' has a wrong offset!");

// Function DeceiveInc.HackTrapScannableComponent.OnRep_FactionTrappingDevice
// 0x0010 (0x0010 - 0x0000)
struct HackTrapScannableComponent_OnRep_FactionTrappingDevice final
{
public:
	TArray<int32>                                 OldFactionTrappingDevice;                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HackTrapScannableComponent_OnRep_FactionTrappingDevice) == 0x000008, "Wrong alignment on HackTrapScannableComponent_OnRep_FactionTrappingDevice");
static_assert(sizeof(HackTrapScannableComponent_OnRep_FactionTrappingDevice) == 0x000010, "Wrong size on HackTrapScannableComponent_OnRep_FactionTrappingDevice");
static_assert(offsetof(HackTrapScannableComponent_OnRep_FactionTrappingDevice, OldFactionTrappingDevice) == 0x000000, "Member 'HackTrapScannableComponent_OnRep_FactionTrappingDevice::OldFactionTrappingDevice' has a wrong offset!");

// Function DeceiveInc.HansActiveAbility.BP_OnHansActiveProjectileHit
// 0x0020 (0x0020 - 0x0000)
struct HansActiveAbility_BP_OnHansActiveProjectileHit final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPoint;                                       // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactNormal;                                      // 0x0014(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HansActiveAbility_BP_OnHansActiveProjectileHit) == 0x000008, "Wrong alignment on HansActiveAbility_BP_OnHansActiveProjectileHit");
static_assert(sizeof(HansActiveAbility_BP_OnHansActiveProjectileHit) == 0x000020, "Wrong size on HansActiveAbility_BP_OnHansActiveProjectileHit");
static_assert(offsetof(HansActiveAbility_BP_OnHansActiveProjectileHit, Victim) == 0x000000, "Member 'HansActiveAbility_BP_OnHansActiveProjectileHit::Victim' has a wrong offset!");
static_assert(offsetof(HansActiveAbility_BP_OnHansActiveProjectileHit, ImpactPoint) == 0x000008, "Member 'HansActiveAbility_BP_OnHansActiveProjectileHit::ImpactPoint' has a wrong offset!");
static_assert(offsetof(HansActiveAbility_BP_OnHansActiveProjectileHit, ImpactNormal) == 0x000014, "Member 'HansActiveAbility_BP_OnHansActiveProjectileHit::ImpactNormal' has a wrong offset!");

// Function DeceiveInc.HansActiveAbility.MulticastFireShot
// 0x0018 (0x0018 - 0x0000)
struct HansActiveAbility_MulticastFireShot final
{
public:
	struct FVector_NetQuantize                    OriginPos;                                         // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    DestinationPos;                                    // 0x000C(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HansActiveAbility_MulticastFireShot) == 0x000004, "Wrong alignment on HansActiveAbility_MulticastFireShot");
static_assert(sizeof(HansActiveAbility_MulticastFireShot) == 0x000018, "Wrong size on HansActiveAbility_MulticastFireShot");
static_assert(offsetof(HansActiveAbility_MulticastFireShot, OriginPos) == 0x000000, "Member 'HansActiveAbility_MulticastFireShot::OriginPos' has a wrong offset!");
static_assert(offsetof(HansActiveAbility_MulticastFireShot, DestinationPos) == 0x00000C, "Member 'HansActiveAbility_MulticastFireShot::DestinationPos' has a wrong offset!");

// Function DeceiveInc.HansActiveAbility.MulticastProjectileHit
// 0x0020 (0x0020 - 0x0000)
struct HansActiveAbility_MulticastProjectileHit final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    ImpactPos;                                         // 0x0008(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              ImpactNormal;                                      // 0x0014(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HansActiveAbility_MulticastProjectileHit) == 0x000008, "Wrong alignment on HansActiveAbility_MulticastProjectileHit");
static_assert(sizeof(HansActiveAbility_MulticastProjectileHit) == 0x000020, "Wrong size on HansActiveAbility_MulticastProjectileHit");
static_assert(offsetof(HansActiveAbility_MulticastProjectileHit, Victim) == 0x000000, "Member 'HansActiveAbility_MulticastProjectileHit::Victim' has a wrong offset!");
static_assert(offsetof(HansActiveAbility_MulticastProjectileHit, ImpactPos) == 0x000008, "Member 'HansActiveAbility_MulticastProjectileHit::ImpactPos' has a wrong offset!");
static_assert(offsetof(HansActiveAbility_MulticastProjectileHit, ImpactNormal) == 0x000014, "Member 'HansActiveAbility_MulticastProjectileHit::ImpactNormal' has a wrong offset!");

// Function DeceiveInc.HansActiveAbility.GetMuzzlePosition
// 0x000C (0x000C - 0x0000)
struct HansActiveAbility_GetMuzzlePosition final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HansActiveAbility_GetMuzzlePosition) == 0x000004, "Wrong alignment on HansActiveAbility_GetMuzzlePosition");
static_assert(sizeof(HansActiveAbility_GetMuzzlePosition) == 0x00000C, "Wrong size on HansActiveAbility_GetMuzzlePosition");
static_assert(offsetof(HansActiveAbility_GetMuzzlePosition, ReturnValue) == 0x000000, "Member 'HansActiveAbility_GetMuzzlePosition::ReturnValue' has a wrong offset!");

// Function DeceiveInc.HealthComponent.IsFriendly
// 0x0018 (0x0018 - 0x0000)
struct HealthComponent_IsFriendly final
{
public:
	const class AActor*                           ActorA;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           ActorB;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HealthComponent_IsFriendly) == 0x000008, "Wrong alignment on HealthComponent_IsFriendly");
static_assert(sizeof(HealthComponent_IsFriendly) == 0x000018, "Wrong size on HealthComponent_IsFriendly");
static_assert(offsetof(HealthComponent_IsFriendly, ActorA) == 0x000000, "Member 'HealthComponent_IsFriendly::ActorA' has a wrong offset!");
static_assert(offsetof(HealthComponent_IsFriendly, ActorB) == 0x000008, "Member 'HealthComponent_IsFriendly::ActorB' has a wrong offset!");
static_assert(offsetof(HealthComponent_IsFriendly, ReturnValue) == 0x000010, "Member 'HealthComponent_IsFriendly::ReturnValue' has a wrong offset!");

// Function DeceiveInc.HealthComponent.IsFriendlyOrNeutral
// 0x0018 (0x0018 - 0x0000)
struct HealthComponent_IsFriendlyOrNeutral final
{
public:
	const class AActor*                           ActorA;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           ActorB;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HealthComponent_IsFriendlyOrNeutral) == 0x000008, "Wrong alignment on HealthComponent_IsFriendlyOrNeutral");
static_assert(sizeof(HealthComponent_IsFriendlyOrNeutral) == 0x000018, "Wrong size on HealthComponent_IsFriendlyOrNeutral");
static_assert(offsetof(HealthComponent_IsFriendlyOrNeutral, ActorA) == 0x000000, "Member 'HealthComponent_IsFriendlyOrNeutral::ActorA' has a wrong offset!");
static_assert(offsetof(HealthComponent_IsFriendlyOrNeutral, ActorB) == 0x000008, "Member 'HealthComponent_IsFriendlyOrNeutral::ActorB' has a wrong offset!");
static_assert(offsetof(HealthComponent_IsFriendlyOrNeutral, ReturnValue) == 0x000010, "Member 'HealthComponent_IsFriendlyOrNeutral::ReturnValue' has a wrong offset!");

// Function DeceiveInc.HealthComponent.AddDamageModifier
// 0x0010 (0x0010 - 0x0000)
struct HealthComponent_AddDamageModifier final
{
public:
	class AActor*                                 Instigator;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageModifier*                        Modifier;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealthComponent_AddDamageModifier) == 0x000008, "Wrong alignment on HealthComponent_AddDamageModifier");
static_assert(sizeof(HealthComponent_AddDamageModifier) == 0x000010, "Wrong size on HealthComponent_AddDamageModifier");
static_assert(offsetof(HealthComponent_AddDamageModifier, Instigator) == 0x000000, "Member 'HealthComponent_AddDamageModifier::Instigator' has a wrong offset!");
static_assert(offsetof(HealthComponent_AddDamageModifier, Modifier) == 0x000008, "Member 'HealthComponent_AddDamageModifier::Modifier' has a wrong offset!");

// Function DeceiveInc.HealthComponent.HandleTakeAnyDamage
// 0x0028 (0x0028 - 0x0000)
struct HealthComponent_HandleTakeAnyDamage final
{
public:
	class AActor*                                 DamagedActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UDamageType*                      DamageType;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealthComponent_HandleTakeAnyDamage) == 0x000008, "Wrong alignment on HealthComponent_HandleTakeAnyDamage");
static_assert(sizeof(HealthComponent_HandleTakeAnyDamage) == 0x000028, "Wrong size on HealthComponent_HandleTakeAnyDamage");
static_assert(offsetof(HealthComponent_HandleTakeAnyDamage, DamagedActor) == 0x000000, "Member 'HealthComponent_HandleTakeAnyDamage::DamagedActor' has a wrong offset!");
static_assert(offsetof(HealthComponent_HandleTakeAnyDamage, Damage) == 0x000008, "Member 'HealthComponent_HandleTakeAnyDamage::Damage' has a wrong offset!");
static_assert(offsetof(HealthComponent_HandleTakeAnyDamage, DamageType) == 0x000010, "Member 'HealthComponent_HandleTakeAnyDamage::DamageType' has a wrong offset!");
static_assert(offsetof(HealthComponent_HandleTakeAnyDamage, InstigatedBy) == 0x000018, "Member 'HealthComponent_HandleTakeAnyDamage::InstigatedBy' has a wrong offset!");
static_assert(offsetof(HealthComponent_HandleTakeAnyDamage, DamageCauser) == 0x000020, "Member 'HealthComponent_HandleTakeAnyDamage::DamageCauser' has a wrong offset!");

// Function DeceiveInc.HealthComponent.Heal
// 0x0004 (0x0004 - 0x0000)
struct HealthComponent_Heal final
{
public:
	float                                         HealAmount;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealthComponent_Heal) == 0x000004, "Wrong alignment on HealthComponent_Heal");
static_assert(sizeof(HealthComponent_Heal) == 0x000004, "Wrong size on HealthComponent_Heal");
static_assert(offsetof(HealthComponent_Heal, HealAmount) == 0x000000, "Member 'HealthComponent_Heal::HealAmount' has a wrong offset!");

// Function DeceiveInc.HealthComponent.OnRep_Dead
// 0x0001 (0x0001 - 0x0000)
struct HealthComponent_OnRep_Dead final
{
public:
	bool                                          OldDead;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealthComponent_OnRep_Dead) == 0x000001, "Wrong alignment on HealthComponent_OnRep_Dead");
static_assert(sizeof(HealthComponent_OnRep_Dead) == 0x000001, "Wrong size on HealthComponent_OnRep_Dead");
static_assert(offsetof(HealthComponent_OnRep_Dead, OldDead) == 0x000000, "Member 'HealthComponent_OnRep_Dead::OldDead' has a wrong offset!");

// Function DeceiveInc.HealthComponent.OnRep_HealthInfo
// 0x0020 (0x0020 - 0x0000)
struct HealthComponent_OnRep_HealthInfo final
{
public:
	struct FHealthInfo                            OldHealthInfo;                                     // 0x0000(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealthComponent_OnRep_HealthInfo) == 0x000008, "Wrong alignment on HealthComponent_OnRep_HealthInfo");
static_assert(sizeof(HealthComponent_OnRep_HealthInfo) == 0x000020, "Wrong size on HealthComponent_OnRep_HealthInfo");
static_assert(offsetof(HealthComponent_OnRep_HealthInfo, OldHealthInfo) == 0x000000, "Member 'HealthComponent_OnRep_HealthInfo::OldHealthInfo' has a wrong offset!");

// Function DeceiveInc.HealthComponent.OnRep_MaxHealth
// 0x0004 (0x0004 - 0x0000)
struct HealthComponent_OnRep_MaxHealth final
{
public:
	float                                         OldMaxHealth;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealthComponent_OnRep_MaxHealth) == 0x000004, "Wrong alignment on HealthComponent_OnRep_MaxHealth");
static_assert(sizeof(HealthComponent_OnRep_MaxHealth) == 0x000004, "Wrong size on HealthComponent_OnRep_MaxHealth");
static_assert(offsetof(HealthComponent_OnRep_MaxHealth, OldMaxHealth) == 0x000000, "Member 'HealthComponent_OnRep_MaxHealth::OldMaxHealth' has a wrong offset!");

// Function DeceiveInc.HealthComponent.RemoveDamageModifier
// 0x0008 (0x0008 - 0x0000)
struct HealthComponent_RemoveDamageModifier final
{
public:
	class UDamageModifier*                        Modifier;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealthComponent_RemoveDamageModifier) == 0x000008, "Wrong alignment on HealthComponent_RemoveDamageModifier");
static_assert(sizeof(HealthComponent_RemoveDamageModifier) == 0x000008, "Wrong size on HealthComponent_RemoveDamageModifier");
static_assert(offsetof(HealthComponent_RemoveDamageModifier, Modifier) == 0x000000, "Member 'HealthComponent_RemoveDamageModifier::Modifier' has a wrong offset!");

// Function DeceiveInc.HealthComponent.SetHealth
// 0x0004 (0x0004 - 0x0000)
struct HealthComponent_SetHealth final
{
public:
	float                                         NewHealth;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealthComponent_SetHealth) == 0x000004, "Wrong alignment on HealthComponent_SetHealth");
static_assert(sizeof(HealthComponent_SetHealth) == 0x000004, "Wrong size on HealthComponent_SetHealth");
static_assert(offsetof(HealthComponent_SetHealth, NewHealth) == 0x000000, "Member 'HealthComponent_SetHealth::NewHealth' has a wrong offset!");

// Function DeceiveInc.HealthComponent.SetMaxHealth
// 0x0004 (0x0004 - 0x0000)
struct HealthComponent_SetMaxHealth final
{
public:
	float                                         NewMaxHealth;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealthComponent_SetMaxHealth) == 0x000004, "Wrong alignment on HealthComponent_SetMaxHealth");
static_assert(sizeof(HealthComponent_SetMaxHealth) == 0x000004, "Wrong size on HealthComponent_SetMaxHealth");
static_assert(offsetof(HealthComponent_SetMaxHealth, NewMaxHealth) == 0x000000, "Member 'HealthComponent_SetMaxHealth::NewMaxHealth' has a wrong offset!");

// Function DeceiveInc.HealthComponent.SetOfflineDemiGod
// 0x0001 (0x0001 - 0x0000)
struct HealthComponent_SetOfflineDemiGod final
{
public:
	bool                                          bDemiGod;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealthComponent_SetOfflineDemiGod) == 0x000001, "Wrong alignment on HealthComponent_SetOfflineDemiGod");
static_assert(sizeof(HealthComponent_SetOfflineDemiGod) == 0x000001, "Wrong size on HealthComponent_SetOfflineDemiGod");
static_assert(offsetof(HealthComponent_SetOfflineDemiGod, bDemiGod) == 0x000000, "Member 'HealthComponent_SetOfflineDemiGod::bDemiGod' has a wrong offset!");

// Function DeceiveInc.HealthComponent.GetHealth
// 0x0004 (0x0004 - 0x0000)
struct HealthComponent_GetHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealthComponent_GetHealth) == 0x000004, "Wrong alignment on HealthComponent_GetHealth");
static_assert(sizeof(HealthComponent_GetHealth) == 0x000004, "Wrong size on HealthComponent_GetHealth");
static_assert(offsetof(HealthComponent_GetHealth, ReturnValue) == 0x000000, "Member 'HealthComponent_GetHealth::ReturnValue' has a wrong offset!");

// Function DeceiveInc.HealthComponent.GetHealthRatio
// 0x0004 (0x0004 - 0x0000)
struct HealthComponent_GetHealthRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealthComponent_GetHealthRatio) == 0x000004, "Wrong alignment on HealthComponent_GetHealthRatio");
static_assert(sizeof(HealthComponent_GetHealthRatio) == 0x000004, "Wrong size on HealthComponent_GetHealthRatio");
static_assert(offsetof(HealthComponent_GetHealthRatio, ReturnValue) == 0x000000, "Member 'HealthComponent_GetHealthRatio::ReturnValue' has a wrong offset!");

// Function DeceiveInc.HealthComponent.GetHealthRatioOnDefault
// 0x0004 (0x0004 - 0x0000)
struct HealthComponent_GetHealthRatioOnDefault final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealthComponent_GetHealthRatioOnDefault) == 0x000004, "Wrong alignment on HealthComponent_GetHealthRatioOnDefault");
static_assert(sizeof(HealthComponent_GetHealthRatioOnDefault) == 0x000004, "Wrong size on HealthComponent_GetHealthRatioOnDefault");
static_assert(offsetof(HealthComponent_GetHealthRatioOnDefault, ReturnValue) == 0x000000, "Member 'HealthComponent_GetHealthRatioOnDefault::ReturnValue' has a wrong offset!");

// Function DeceiveInc.HealthComponent.GetMaxHealth
// 0x0004 (0x0004 - 0x0000)
struct HealthComponent_GetMaxHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealthComponent_GetMaxHealth) == 0x000004, "Wrong alignment on HealthComponent_GetMaxHealth");
static_assert(sizeof(HealthComponent_GetMaxHealth) == 0x000004, "Wrong size on HealthComponent_GetMaxHealth");
static_assert(offsetof(HealthComponent_GetMaxHealth, ReturnValue) == 0x000000, "Member 'HealthComponent_GetMaxHealth::ReturnValue' has a wrong offset!");

// Function DeceiveInc.HealthComponent.IsDead
// 0x0001 (0x0001 - 0x0000)
struct HealthComponent_IsDead final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealthComponent_IsDead) == 0x000001, "Wrong alignment on HealthComponent_IsDead");
static_assert(sizeof(HealthComponent_IsDead) == 0x000001, "Wrong size on HealthComponent_IsDead");
static_assert(offsetof(HealthComponent_IsDead, ReturnValue) == 0x000000, "Member 'HealthComponent_IsDead::ReturnValue' has a wrong offset!");

// Function DeceiveInc.HeightCheckComponent.ActivateHeightCheck
// 0x0001 (0x0001 - 0x0000)
struct HeightCheckComponent_ActivateHeightCheck final
{
public:
	bool                                          bActivate;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeightCheckComponent_ActivateHeightCheck) == 0x000001, "Wrong alignment on HeightCheckComponent_ActivateHeightCheck");
static_assert(sizeof(HeightCheckComponent_ActivateHeightCheck) == 0x000001, "Wrong size on HeightCheckComponent_ActivateHeightCheck");
static_assert(offsetof(HeightCheckComponent_ActivateHeightCheck, bActivate) == 0x000000, "Member 'HeightCheckComponent_ActivateHeightCheck::bActivate' has a wrong offset!");

// Function DeceiveInc.HeightCheckComponent.SetCustomCheckLocation
// 0x000C (0x000C - 0x0000)
struct HeightCheckComponent_SetCustomCheckLocation final
{
public:
	struct FVector                                CheckLocation;                                     // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeightCheckComponent_SetCustomCheckLocation) == 0x000004, "Wrong alignment on HeightCheckComponent_SetCustomCheckLocation");
static_assert(sizeof(HeightCheckComponent_SetCustomCheckLocation) == 0x00000C, "Wrong size on HeightCheckComponent_SetCustomCheckLocation");
static_assert(offsetof(HeightCheckComponent_SetCustomCheckLocation, CheckLocation) == 0x000000, "Member 'HeightCheckComponent_SetCustomCheckLocation::CheckLocation' has a wrong offset!");

// Function DeceiveInc.ImpulseWeaponComponent.OnSimulateLocalFireShot
// 0x0028 (0x0028 - 0x0000)
struct ImpulseWeaponComponent_OnSimulateLocalFireShot final
{
public:
	class AProjectileWeapon*                      Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginPos;                                         // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DestinationPos;                                    // 0x0014(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoDamage;                                         // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMissingShot;                                      // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ImpulseWeaponComponent_OnSimulateLocalFireShot) == 0x000008, "Wrong alignment on ImpulseWeaponComponent_OnSimulateLocalFireShot");
static_assert(sizeof(ImpulseWeaponComponent_OnSimulateLocalFireShot) == 0x000028, "Wrong size on ImpulseWeaponComponent_OnSimulateLocalFireShot");
static_assert(offsetof(ImpulseWeaponComponent_OnSimulateLocalFireShot, Weapon) == 0x000000, "Member 'ImpulseWeaponComponent_OnSimulateLocalFireShot::Weapon' has a wrong offset!");
static_assert(offsetof(ImpulseWeaponComponent_OnSimulateLocalFireShot, OriginPos) == 0x000008, "Member 'ImpulseWeaponComponent_OnSimulateLocalFireShot::OriginPos' has a wrong offset!");
static_assert(offsetof(ImpulseWeaponComponent_OnSimulateLocalFireShot, DestinationPos) == 0x000014, "Member 'ImpulseWeaponComponent_OnSimulateLocalFireShot::DestinationPos' has a wrong offset!");
static_assert(offsetof(ImpulseWeaponComponent_OnSimulateLocalFireShot, bDoDamage) == 0x000020, "Member 'ImpulseWeaponComponent_OnSimulateLocalFireShot::bDoDamage' has a wrong offset!");
static_assert(offsetof(ImpulseWeaponComponent_OnSimulateLocalFireShot, bMissingShot) == 0x000021, "Member 'ImpulseWeaponComponent_OnSimulateLocalFireShot::bMissingShot' has a wrong offset!");

// Function DeceiveInc.InteractableComponent.GetContinuousInteraction
// 0x0001 (0x0001 - 0x0000)
struct InteractableComponent_GetContinuousInteraction final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableComponent_GetContinuousInteraction) == 0x000001, "Wrong alignment on InteractableComponent_GetContinuousInteraction");
static_assert(sizeof(InteractableComponent_GetContinuousInteraction) == 0x000001, "Wrong size on InteractableComponent_GetContinuousInteraction");
static_assert(offsetof(InteractableComponent_GetContinuousInteraction, ReturnValue) == 0x000000, "Member 'InteractableComponent_GetContinuousInteraction::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteractableComponent.HandleActorSpawned
// 0x0008 (0x0008 - 0x0000)
struct InteractableComponent_HandleActorSpawned final
{
public:
	class AActor*                                 SpawnedActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableComponent_HandleActorSpawned) == 0x000008, "Wrong alignment on InteractableComponent_HandleActorSpawned");
static_assert(sizeof(InteractableComponent_HandleActorSpawned) == 0x000008, "Wrong size on InteractableComponent_HandleActorSpawned");
static_assert(offsetof(InteractableComponent_HandleActorSpawned, SpawnedActor) == 0x000000, "Member 'InteractableComponent_HandleActorSpawned::SpawnedActor' has a wrong offset!");

// Function DeceiveInc.InteractableComponent.HandleSpyDead
// 0x0008 (0x0008 - 0x0000)
struct InteractableComponent_HandleSpyDead final
{
public:
	class ASpy*                                   DeadSpy;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableComponent_HandleSpyDead) == 0x000008, "Wrong alignment on InteractableComponent_HandleSpyDead");
static_assert(sizeof(InteractableComponent_HandleSpyDead) == 0x000008, "Wrong size on InteractableComponent_HandleSpyDead");
static_assert(offsetof(InteractableComponent_HandleSpyDead, DeadSpy) == 0x000000, "Member 'InteractableComponent_HandleSpyDead::DeadSpy' has a wrong offset!");

// Function DeceiveInc.InteractableComponent.IsBeingInteractedWith
// 0x0001 (0x0001 - 0x0000)
struct InteractableComponent_IsBeingInteractedWith final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableComponent_IsBeingInteractedWith) == 0x000001, "Wrong alignment on InteractableComponent_IsBeingInteractedWith");
static_assert(sizeof(InteractableComponent_IsBeingInteractedWith) == 0x000001, "Wrong size on InteractableComponent_IsBeingInteractedWith");
static_assert(offsetof(InteractableComponent_IsBeingInteractedWith, ReturnValue) == 0x000000, "Member 'InteractableComponent_IsBeingInteractedWith::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteractableComponent.IsResourceSpend
// 0x0010 (0x0010 - 0x0000)
struct InteractableComponent_IsResourceSpend final
{
public:
	const class UInteracterComponent*             Interacter;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InteractableComponent_IsResourceSpend) == 0x000008, "Wrong alignment on InteractableComponent_IsResourceSpend");
static_assert(sizeof(InteractableComponent_IsResourceSpend) == 0x000010, "Wrong size on InteractableComponent_IsResourceSpend");
static_assert(offsetof(InteractableComponent_IsResourceSpend, Interacter) == 0x000000, "Member 'InteractableComponent_IsResourceSpend::Interacter' has a wrong offset!");
static_assert(offsetof(InteractableComponent_IsResourceSpend, ReturnValue) == 0x000008, "Member 'InteractableComponent_IsResourceSpend::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteractableComponent.OnComponentBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct InteractableComponent_OnComponentBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableComponent_OnComponentBeginOverlap) == 0x000008, "Wrong alignment on InteractableComponent_OnComponentBeginOverlap");
static_assert(sizeof(InteractableComponent_OnComponentBeginOverlap) == 0x0000A8, "Wrong size on InteractableComponent_OnComponentBeginOverlap");
static_assert(offsetof(InteractableComponent_OnComponentBeginOverlap, OverlappedComponent) == 0x000000, "Member 'InteractableComponent_OnComponentBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(InteractableComponent_OnComponentBeginOverlap, OtherActor) == 0x000008, "Member 'InteractableComponent_OnComponentBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(InteractableComponent_OnComponentBeginOverlap, OtherComp) == 0x000010, "Member 'InteractableComponent_OnComponentBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(InteractableComponent_OnComponentBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'InteractableComponent_OnComponentBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(InteractableComponent_OnComponentBeginOverlap, bFromSweep) == 0x00001C, "Member 'InteractableComponent_OnComponentBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(InteractableComponent_OnComponentBeginOverlap, SweepResult) == 0x000020, "Member 'InteractableComponent_OnComponentBeginOverlap::SweepResult' has a wrong offset!");

// Function DeceiveInc.InteractableComponent.OnComponentEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct InteractableComponent_OnComponentEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InteractableComponent_OnComponentEndOverlap) == 0x000008, "Wrong alignment on InteractableComponent_OnComponentEndOverlap");
static_assert(sizeof(InteractableComponent_OnComponentEndOverlap) == 0x000020, "Wrong size on InteractableComponent_OnComponentEndOverlap");
static_assert(offsetof(InteractableComponent_OnComponentEndOverlap, OverlappedComponent) == 0x000000, "Member 'InteractableComponent_OnComponentEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(InteractableComponent_OnComponentEndOverlap, OtherActor) == 0x000008, "Member 'InteractableComponent_OnComponentEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(InteractableComponent_OnComponentEndOverlap, OtherComp) == 0x000010, "Member 'InteractableComponent_OnComponentEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(InteractableComponent_OnComponentEndOverlap, OtherBodyIndex) == 0x000018, "Member 'InteractableComponent_OnComponentEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function DeceiveInc.InteractableComponent.OnGamePhaseChanged
// 0x0001 (0x0001 - 0x0000)
struct InteractableComponent_OnGamePhaseChanged final
{
public:
	ESpyGamePhase                                 NewGamePhase;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableComponent_OnGamePhaseChanged) == 0x000001, "Wrong alignment on InteractableComponent_OnGamePhaseChanged");
static_assert(sizeof(InteractableComponent_OnGamePhaseChanged) == 0x000001, "Wrong size on InteractableComponent_OnGamePhaseChanged");
static_assert(offsetof(InteractableComponent_OnGamePhaseChanged, NewGamePhase) == 0x000000, "Member 'InteractableComponent_OnGamePhaseChanged::NewGamePhase' has a wrong offset!");

// Function DeceiveInc.InteractableComponent.SetEnable
// 0x0001 (0x0001 - 0x0000)
struct InteractableComponent_SetEnable final
{
public:
	bool                                          Enable;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableComponent_SetEnable) == 0x000001, "Wrong alignment on InteractableComponent_SetEnable");
static_assert(sizeof(InteractableComponent_SetEnable) == 0x000001, "Wrong size on InteractableComponent_SetEnable");
static_assert(offsetof(InteractableComponent_SetEnable, Enable) == 0x000000, "Member 'InteractableComponent_SetEnable::Enable' has a wrong offset!");

// Function DeceiveInc.InteractableComponent.CanReduceInteractDuration
// 0x0010 (0x0010 - 0x0000)
struct InteractableComponent_CanReduceInteractDuration final
{
public:
	const class UInteracterComponent*             Interacter;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InteractableComponent_CanReduceInteractDuration) == 0x000008, "Wrong alignment on InteractableComponent_CanReduceInteractDuration");
static_assert(sizeof(InteractableComponent_CanReduceInteractDuration) == 0x000010, "Wrong size on InteractableComponent_CanReduceInteractDuration");
static_assert(offsetof(InteractableComponent_CanReduceInteractDuration, Interacter) == 0x000000, "Member 'InteractableComponent_CanReduceInteractDuration::Interacter' has a wrong offset!");
static_assert(offsetof(InteractableComponent_CanReduceInteractDuration, ReturnValue) == 0x000008, "Member 'InteractableComponent_CanReduceInteractDuration::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteractableComponent.GetCurrentInteractionData
// 0x0010 (0x0010 - 0x0000)
struct InteractableComponent_GetCurrentInteractionData final
{
public:
	struct FLastInteractionData                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableComponent_GetCurrentInteractionData) == 0x000008, "Wrong alignment on InteractableComponent_GetCurrentInteractionData");
static_assert(sizeof(InteractableComponent_GetCurrentInteractionData) == 0x000010, "Wrong size on InteractableComponent_GetCurrentInteractionData");
static_assert(offsetof(InteractableComponent_GetCurrentInteractionData, ReturnValue) == 0x000000, "Member 'InteractableComponent_GetCurrentInteractionData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteractableComponent.GetInteract1PAnimation
// 0x0010 (0x0010 - 0x0000)
struct InteractableComponent_GetInteract1PAnimation final
{
public:
	class AActor*                                 Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteract1PAnimation                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InteractableComponent_GetInteract1PAnimation) == 0x000008, "Wrong alignment on InteractableComponent_GetInteract1PAnimation");
static_assert(sizeof(InteractableComponent_GetInteract1PAnimation) == 0x000010, "Wrong size on InteractableComponent_GetInteract1PAnimation");
static_assert(offsetof(InteractableComponent_GetInteract1PAnimation, Interacter) == 0x000000, "Member 'InteractableComponent_GetInteract1PAnimation::Interacter' has a wrong offset!");
static_assert(offsetof(InteractableComponent_GetInteract1PAnimation, ReturnValue) == 0x000008, "Member 'InteractableComponent_GetInteract1PAnimation::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteractableComponent.GetInteractableState
// 0x0001 (0x0001 - 0x0000)
struct InteractableComponent_GetInteractableState final
{
public:
	EInteractableState                            ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableComponent_GetInteractableState) == 0x000001, "Wrong alignment on InteractableComponent_GetInteractableState");
static_assert(sizeof(InteractableComponent_GetInteractableState) == 0x000001, "Wrong size on InteractableComponent_GetInteractableState");
static_assert(offsetof(InteractableComponent_GetInteractableState, ReturnValue) == 0x000000, "Member 'InteractableComponent_GetInteractableState::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteractableComponent.GetInteractionDistance
// 0x0004 (0x0004 - 0x0000)
struct InteractableComponent_GetInteractionDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableComponent_GetInteractionDistance) == 0x000004, "Wrong alignment on InteractableComponent_GetInteractionDistance");
static_assert(sizeof(InteractableComponent_GetInteractionDistance) == 0x000004, "Wrong size on InteractableComponent_GetInteractionDistance");
static_assert(offsetof(InteractableComponent_GetInteractionDistance, ReturnValue) == 0x000000, "Member 'InteractableComponent_GetInteractionDistance::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteractableComponent.GetInteractionDuration
// 0x0010 (0x0010 - 0x0000)
struct InteractableComponent_GetInteractionDuration final
{
public:
	const class UInteracterComponent*             Interacter;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InteractableComponent_GetInteractionDuration) == 0x000008, "Wrong alignment on InteractableComponent_GetInteractionDuration");
static_assert(sizeof(InteractableComponent_GetInteractionDuration) == 0x000010, "Wrong size on InteractableComponent_GetInteractionDuration");
static_assert(offsetof(InteractableComponent_GetInteractionDuration, Interacter) == 0x000000, "Member 'InteractableComponent_GetInteractionDuration::Interacter' has a wrong offset!");
static_assert(offsetof(InteractableComponent_GetInteractionDuration, ReturnValue) == 0x000008, "Member 'InteractableComponent_GetInteractionDuration::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteractableComponent.GetInteractionIcon
// 0x0008 (0x0008 - 0x0000)
struct InteractableComponent_GetInteractionIcon final
{
public:
	class UInteractionIconComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableComponent_GetInteractionIcon) == 0x000008, "Wrong alignment on InteractableComponent_GetInteractionIcon");
static_assert(sizeof(InteractableComponent_GetInteractionIcon) == 0x000008, "Wrong size on InteractableComponent_GetInteractionIcon");
static_assert(offsetof(InteractableComponent_GetInteractionIcon, ReturnValue) == 0x000000, "Member 'InteractableComponent_GetInteractionIcon::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteractableComponent.IsDisableOnDestroyed
// 0x0001 (0x0001 - 0x0000)
struct InteractableComponent_IsDisableOnDestroyed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableComponent_IsDisableOnDestroyed) == 0x000001, "Wrong alignment on InteractableComponent_IsDisableOnDestroyed");
static_assert(sizeof(InteractableComponent_IsDisableOnDestroyed) == 0x000001, "Wrong size on InteractableComponent_IsDisableOnDestroyed");
static_assert(offsetof(InteractableComponent_IsDisableOnDestroyed, ReturnValue) == 0x000000, "Member 'InteractableComponent_IsDisableOnDestroyed::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteractableComponent.IsInteractCancelOnDamage
// 0x0001 (0x0001 - 0x0000)
struct InteractableComponent_IsInteractCancelOnDamage final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableComponent_IsInteractCancelOnDamage) == 0x000001, "Wrong alignment on InteractableComponent_IsInteractCancelOnDamage");
static_assert(sizeof(InteractableComponent_IsInteractCancelOnDamage) == 0x000001, "Wrong size on InteractableComponent_IsInteractCancelOnDamage");
static_assert(offsetof(InteractableComponent_IsInteractCancelOnDamage, ReturnValue) == 0x000000, "Member 'InteractableComponent_IsInteractCancelOnDamage::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InteractionIconWidget.OnNewInteractionIconComponent
// 0x0010 (0x0010 - 0x0000)
struct InteractionIconWidget_OnNewInteractionIconComponent final
{
public:
	class UInteractionIconComponent*              OldComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractionIconComponent*              NewComponent;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractionIconWidget_OnNewInteractionIconComponent) == 0x000008, "Wrong alignment on InteractionIconWidget_OnNewInteractionIconComponent");
static_assert(sizeof(InteractionIconWidget_OnNewInteractionIconComponent) == 0x000010, "Wrong size on InteractionIconWidget_OnNewInteractionIconComponent");
static_assert(offsetof(InteractionIconWidget_OnNewInteractionIconComponent, OldComponent) == 0x000000, "Member 'InteractionIconWidget_OnNewInteractionIconComponent::OldComponent' has a wrong offset!");
static_assert(offsetof(InteractionIconWidget_OnNewInteractionIconComponent, NewComponent) == 0x000008, "Member 'InteractionIconWidget_OnNewInteractionIconComponent::NewComponent' has a wrong offset!");

// Function DeceiveInc.InteractionIconWidget.SetIsRepeatableInteraction
// 0x0001 (0x0001 - 0x0000)
struct InteractionIconWidget_SetIsRepeatableInteraction final
{
public:
	bool                                          bState;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractionIconWidget_SetIsRepeatableInteraction) == 0x000001, "Wrong alignment on InteractionIconWidget_SetIsRepeatableInteraction");
static_assert(sizeof(InteractionIconWidget_SetIsRepeatableInteraction) == 0x000001, "Wrong size on InteractionIconWidget_SetIsRepeatableInteraction");
static_assert(offsetof(InteractionIconWidget_SetIsRepeatableInteraction, bState) == 0x000000, "Member 'InteractionIconWidget_SetIsRepeatableInteraction::bState' has a wrong offset!");

// Function DeceiveInc.IntroFlow.BP_OnShowPosingSpySequenceStart
// 0x0018 (0x0018 - 0x0000)
struct IntroFlow_BP_OnShowPosingSpySequenceStart final
{
public:
	struct FVector                                SpyPosition;                                       // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APosingSpy*                             PosingSpy;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(IntroFlow_BP_OnShowPosingSpySequenceStart) == 0x000008, "Wrong alignment on IntroFlow_BP_OnShowPosingSpySequenceStart");
static_assert(sizeof(IntroFlow_BP_OnShowPosingSpySequenceStart) == 0x000018, "Wrong size on IntroFlow_BP_OnShowPosingSpySequenceStart");
static_assert(offsetof(IntroFlow_BP_OnShowPosingSpySequenceStart, SpyPosition) == 0x000000, "Member 'IntroFlow_BP_OnShowPosingSpySequenceStart::SpyPosition' has a wrong offset!");
static_assert(offsetof(IntroFlow_BP_OnShowPosingSpySequenceStart, PosingSpy) == 0x000010, "Member 'IntroFlow_BP_OnShowPosingSpySequenceStart::PosingSpy' has a wrong offset!");

// Function DeceiveInc.IntroFlow.IsKillcamPlaying
// 0x0001 (0x0001 - 0x0000)
struct IntroFlow_IsKillcamPlaying final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(IntroFlow_IsKillcamPlaying) == 0x000001, "Wrong alignment on IntroFlow_IsKillcamPlaying");
static_assert(sizeof(IntroFlow_IsKillcamPlaying) == 0x000001, "Wrong size on IntroFlow_IsKillcamPlaying");
static_assert(offsetof(IntroFlow_IsKillcamPlaying, ReturnValue) == 0x000000, "Member 'IntroFlow_IsKillcamPlaying::ReturnValue' has a wrong offset!");

// Function DeceiveInc.IntroFlow.SpawnPosingSpyLightRig
// 0x0028 (0x0028 - 0x0000)
struct IntroFlow_SpawnPosingSpyLightRig final
{
public:
	TSubclassOf<class AActor>                     LightRigClass;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalOffset;                                       // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LocalRotation;                                     // 0x0014(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(IntroFlow_SpawnPosingSpyLightRig) == 0x000008, "Wrong alignment on IntroFlow_SpawnPosingSpyLightRig");
static_assert(sizeof(IntroFlow_SpawnPosingSpyLightRig) == 0x000028, "Wrong size on IntroFlow_SpawnPosingSpyLightRig");
static_assert(offsetof(IntroFlow_SpawnPosingSpyLightRig, LightRigClass) == 0x000000, "Member 'IntroFlow_SpawnPosingSpyLightRig::LightRigClass' has a wrong offset!");
static_assert(offsetof(IntroFlow_SpawnPosingSpyLightRig, LocalOffset) == 0x000008, "Member 'IntroFlow_SpawnPosingSpyLightRig::LocalOffset' has a wrong offset!");
static_assert(offsetof(IntroFlow_SpawnPosingSpyLightRig, LocalRotation) == 0x000014, "Member 'IntroFlow_SpawnPosingSpyLightRig::LocalRotation' has a wrong offset!");
static_assert(offsetof(IntroFlow_SpawnPosingSpyLightRig, ReturnValue) == 0x000020, "Member 'IntroFlow_SpawnPosingSpyLightRig::ReturnValue' has a wrong offset!");

// Function DeceiveInc.IntroFlow.StartShowPosingSpySequence
// 0x0020 (0x0020 - 0x0000)
struct IntroFlow_StartShowPosingSpySequence final
{
public:
	TSubclassOf<class AActor>                     PosingSpyContainer;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0008(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(IntroFlow_StartShowPosingSpySequence) == 0x000008, "Wrong alignment on IntroFlow_StartShowPosingSpySequence");
static_assert(sizeof(IntroFlow_StartShowPosingSpySequence) == 0x000020, "Wrong size on IntroFlow_StartShowPosingSpySequence");
static_assert(offsetof(IntroFlow_StartShowPosingSpySequence, PosingSpyContainer) == 0x000000, "Member 'IntroFlow_StartShowPosingSpySequence::PosingSpyContainer' has a wrong offset!");
static_assert(offsetof(IntroFlow_StartShowPosingSpySequence, LatentInfo) == 0x000008, "Member 'IntroFlow_StartShowPosingSpySequence::LatentInfo' has a wrong offset!");

// Function DeceiveInc.IntroFlow.IsShowPosingSpySequenceInProgress
// 0x0001 (0x0001 - 0x0000)
struct IntroFlow_IsShowPosingSpySequenceInProgress final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(IntroFlow_IsShowPosingSpySequenceInProgress) == 0x000001, "Wrong alignment on IntroFlow_IsShowPosingSpySequenceInProgress");
static_assert(sizeof(IntroFlow_IsShowPosingSpySequenceInProgress) == 0x000001, "Wrong size on IntroFlow_IsShowPosingSpySequenceInProgress");
static_assert(offsetof(IntroFlow_IsShowPosingSpySequenceInProgress, ReturnValue) == 0x000000, "Member 'IntroFlow_IsShowPosingSpySequenceInProgress::ReturnValue' has a wrong offset!");

// Function DeceiveInc.IntroFlow.IsShowPosingSpySuccessful
// 0x0001 (0x0001 - 0x0000)
struct IntroFlow_IsShowPosingSpySuccessful final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(IntroFlow_IsShowPosingSpySuccessful) == 0x000001, "Wrong alignment on IntroFlow_IsShowPosingSpySuccessful");
static_assert(sizeof(IntroFlow_IsShowPosingSpySuccessful) == 0x000001, "Wrong size on IntroFlow_IsShowPosingSpySuccessful");
static_assert(offsetof(IntroFlow_IsShowPosingSpySuccessful, ReturnValue) == 0x000000, "Member 'IntroFlow_IsShowPosingSpySuccessful::ReturnValue' has a wrong offset!");

// Function DeceiveInc.InvestigationZoneActor.HandleComponentBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct InvestigationZoneActor_HandleComponentBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(InvestigationZoneActor_HandleComponentBeginOverlap) == 0x000008, "Wrong alignment on InvestigationZoneActor_HandleComponentBeginOverlap");
static_assert(sizeof(InvestigationZoneActor_HandleComponentBeginOverlap) == 0x0000A8, "Wrong size on InvestigationZoneActor_HandleComponentBeginOverlap");
static_assert(offsetof(InvestigationZoneActor_HandleComponentBeginOverlap, OverlappedComponent) == 0x000000, "Member 'InvestigationZoneActor_HandleComponentBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(InvestigationZoneActor_HandleComponentBeginOverlap, OtherActor) == 0x000008, "Member 'InvestigationZoneActor_HandleComponentBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(InvestigationZoneActor_HandleComponentBeginOverlap, OtherComp) == 0x000010, "Member 'InvestigationZoneActor_HandleComponentBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(InvestigationZoneActor_HandleComponentBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'InvestigationZoneActor_HandleComponentBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(InvestigationZoneActor_HandleComponentBeginOverlap, bFromSweep) == 0x00001C, "Member 'InvestigationZoneActor_HandleComponentBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(InvestigationZoneActor_HandleComponentBeginOverlap, SweepResult) == 0x000020, "Member 'InvestigationZoneActor_HandleComponentBeginOverlap::SweepResult' has a wrong offset!");

// Function DeceiveInc.InvestigationZoneActor.HandleComponentEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct InvestigationZoneActor_HandleComponentEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InvestigationZoneActor_HandleComponentEndOverlap) == 0x000008, "Wrong alignment on InvestigationZoneActor_HandleComponentEndOverlap");
static_assert(sizeof(InvestigationZoneActor_HandleComponentEndOverlap) == 0x000020, "Wrong size on InvestigationZoneActor_HandleComponentEndOverlap");
static_assert(offsetof(InvestigationZoneActor_HandleComponentEndOverlap, OverlappedComponent) == 0x000000, "Member 'InvestigationZoneActor_HandleComponentEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(InvestigationZoneActor_HandleComponentEndOverlap, OtherActor) == 0x000008, "Member 'InvestigationZoneActor_HandleComponentEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(InvestigationZoneActor_HandleComponentEndOverlap, OtherComp) == 0x000010, "Member 'InvestigationZoneActor_HandleComponentEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(InvestigationZoneActor_HandleComponentEndOverlap, OtherBodyIndex) == 0x000018, "Member 'InvestigationZoneActor_HandleComponentEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function DeceiveInc.InvestigationZoneActor.HandleInteractTrapTriggered
// 0x0010 (0x0010 - 0x0000)
struct InvestigationZoneActor_HandleInteractTrapTriggered final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InvestigationZoneActor_HandleInteractTrapTriggered) == 0x000008, "Wrong alignment on InvestigationZoneActor_HandleInteractTrapTriggered");
static_assert(sizeof(InvestigationZoneActor_HandleInteractTrapTriggered) == 0x000010, "Wrong size on InvestigationZoneActor_HandleInteractTrapTriggered");
static_assert(offsetof(InvestigationZoneActor_HandleInteractTrapTriggered, Interacter) == 0x000000, "Member 'InvestigationZoneActor_HandleInteractTrapTriggered::Interacter' has a wrong offset!");
static_assert(offsetof(InvestigationZoneActor_HandleInteractTrapTriggered, Interactable) == 0x000008, "Member 'InvestigationZoneActor_HandleInteractTrapTriggered::Interactable' has a wrong offset!");

// Function DeceiveInc.InvestigationZoneActor.HandleTrapTriggered
// 0x0010 (0x0010 - 0x0000)
struct InvestigationZoneActor_HandleTrapTriggered final
{
public:
	class UHackTrapScannableComponent*            Trap;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InvestigationZoneActor_HandleTrapTriggered) == 0x000008, "Wrong alignment on InvestigationZoneActor_HandleTrapTriggered");
static_assert(sizeof(InvestigationZoneActor_HandleTrapTriggered) == 0x000010, "Wrong size on InvestigationZoneActor_HandleTrapTriggered");
static_assert(offsetof(InvestigationZoneActor_HandleTrapTriggered, Trap) == 0x000000, "Member 'InvestigationZoneActor_HandleTrapTriggered::Trap' has a wrong offset!");
static_assert(offsetof(InvestigationZoneActor_HandleTrapTriggered, Victim) == 0x000008, "Member 'InvestigationZoneActor_HandleTrapTriggered::Victim' has a wrong offset!");

// Function DeceiveInc.LarcinPassiveAbility.BP_OnLocalLarcinStoleResource
// 0x0010 (0x0010 - 0x0000)
struct LarcinPassiveAbility_BP_OnLocalLarcinStoleResource final
{
public:
	class AActor*                                 VictimActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayResourcesType                        InResourceType;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LarcinPassiveAbility_BP_OnLocalLarcinStoleResource) == 0x000008, "Wrong alignment on LarcinPassiveAbility_BP_OnLocalLarcinStoleResource");
static_assert(sizeof(LarcinPassiveAbility_BP_OnLocalLarcinStoleResource) == 0x000010, "Wrong size on LarcinPassiveAbility_BP_OnLocalLarcinStoleResource");
static_assert(offsetof(LarcinPassiveAbility_BP_OnLocalLarcinStoleResource, VictimActor) == 0x000000, "Member 'LarcinPassiveAbility_BP_OnLocalLarcinStoleResource::VictimActor' has a wrong offset!");
static_assert(offsetof(LarcinPassiveAbility_BP_OnLocalLarcinStoleResource, InResourceType) == 0x000008, "Member 'LarcinPassiveAbility_BP_OnLocalLarcinStoleResource::InResourceType' has a wrong offset!");

// Function DeceiveInc.LarcinPassiveAbility.BP_OnLocalVictimOfLarcinSteal
// 0x0010 (0x0010 - 0x0000)
struct LarcinPassiveAbility_BP_OnLocalVictimOfLarcinSteal final
{
public:
	class AActor*                                 StealingLarcinActor;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayResourcesType                        InResourceType;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LarcinPassiveAbility_BP_OnLocalVictimOfLarcinSteal) == 0x000008, "Wrong alignment on LarcinPassiveAbility_BP_OnLocalVictimOfLarcinSteal");
static_assert(sizeof(LarcinPassiveAbility_BP_OnLocalVictimOfLarcinSteal) == 0x000010, "Wrong size on LarcinPassiveAbility_BP_OnLocalVictimOfLarcinSteal");
static_assert(offsetof(LarcinPassiveAbility_BP_OnLocalVictimOfLarcinSteal, StealingLarcinActor) == 0x000000, "Member 'LarcinPassiveAbility_BP_OnLocalVictimOfLarcinSteal::StealingLarcinActor' has a wrong offset!");
static_assert(offsetof(LarcinPassiveAbility_BP_OnLocalVictimOfLarcinSteal, InResourceType) == 0x000008, "Member 'LarcinPassiveAbility_BP_OnLocalVictimOfLarcinSteal::InResourceType' has a wrong offset!");

// Function DeceiveInc.LarcinPassiveAbility.HandleCoverChange
// 0x0001 (0x0001 - 0x0000)
struct LarcinPassiveAbility_HandleCoverChange final
{
public:
	bool                                          Undercover;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LarcinPassiveAbility_HandleCoverChange) == 0x000001, "Wrong alignment on LarcinPassiveAbility_HandleCoverChange");
static_assert(sizeof(LarcinPassiveAbility_HandleCoverChange) == 0x000001, "Wrong size on LarcinPassiveAbility_HandleCoverChange");
static_assert(offsetof(LarcinPassiveAbility_HandleCoverChange, Undercover) == 0x000000, "Member 'LarcinPassiveAbility_HandleCoverChange::Undercover' has a wrong offset!");

// Function DeceiveInc.LarcinPassiveAbility.HandleLoadoutSpawnCompleteEvent
// 0x0008 (0x0008 - 0x0000)
struct LarcinPassiveAbility_HandleLoadoutSpawnCompleteEvent final
{
public:
	class UToolLoadoutComponent*                  LoadoutComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LarcinPassiveAbility_HandleLoadoutSpawnCompleteEvent) == 0x000008, "Wrong alignment on LarcinPassiveAbility_HandleLoadoutSpawnCompleteEvent");
static_assert(sizeof(LarcinPassiveAbility_HandleLoadoutSpawnCompleteEvent) == 0x000008, "Wrong size on LarcinPassiveAbility_HandleLoadoutSpawnCompleteEvent");
static_assert(offsetof(LarcinPassiveAbility_HandleLoadoutSpawnCompleteEvent, LoadoutComponent) == 0x000000, "Member 'LarcinPassiveAbility_HandleLoadoutSpawnCompleteEvent::LoadoutComponent' has a wrong offset!");

// Function DeceiveInc.LarcinPassiveAbility.HandleMeleeAttackImpactEvent
// 0x0068 (0x0068 - 0x0000)
struct LarcinPassiveAbility_HandleMeleeAttackImpactEvent final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPoint;                                       // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChargeLevel;                                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultingHealthPercentage;                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitType                                      HitType;                                           // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMeleeHitConfirmedData                 HitConfirmedData;                                  // 0x0028(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LarcinPassiveAbility_HandleMeleeAttackImpactEvent) == 0x000008, "Wrong alignment on LarcinPassiveAbility_HandleMeleeAttackImpactEvent");
static_assert(sizeof(LarcinPassiveAbility_HandleMeleeAttackImpactEvent) == 0x000068, "Wrong size on LarcinPassiveAbility_HandleMeleeAttackImpactEvent");
static_assert(offsetof(LarcinPassiveAbility_HandleMeleeAttackImpactEvent, Victim) == 0x000000, "Member 'LarcinPassiveAbility_HandleMeleeAttackImpactEvent::Victim' has a wrong offset!");
static_assert(offsetof(LarcinPassiveAbility_HandleMeleeAttackImpactEvent, ImpactPoint) == 0x000008, "Member 'LarcinPassiveAbility_HandleMeleeAttackImpactEvent::ImpactPoint' has a wrong offset!");
static_assert(offsetof(LarcinPassiveAbility_HandleMeleeAttackImpactEvent, ChargeLevel) == 0x000014, "Member 'LarcinPassiveAbility_HandleMeleeAttackImpactEvent::ChargeLevel' has a wrong offset!");
static_assert(offsetof(LarcinPassiveAbility_HandleMeleeAttackImpactEvent, Damage) == 0x000018, "Member 'LarcinPassiveAbility_HandleMeleeAttackImpactEvent::Damage' has a wrong offset!");
static_assert(offsetof(LarcinPassiveAbility_HandleMeleeAttackImpactEvent, ResultingHealthPercentage) == 0x00001C, "Member 'LarcinPassiveAbility_HandleMeleeAttackImpactEvent::ResultingHealthPercentage' has a wrong offset!");
static_assert(offsetof(LarcinPassiveAbility_HandleMeleeAttackImpactEvent, HitType) == 0x000020, "Member 'LarcinPassiveAbility_HandleMeleeAttackImpactEvent::HitType' has a wrong offset!");
static_assert(offsetof(LarcinPassiveAbility_HandleMeleeAttackImpactEvent, HitConfirmedData) == 0x000028, "Member 'LarcinPassiveAbility_HandleMeleeAttackImpactEvent::HitConfirmedData' has a wrong offset!");

// Function DeceiveInc.LarcinPassiveAbility.NotifyHitNPCMulticast
// 0x0008 (0x0008 - 0x0000)
struct LarcinPassiveAbility_NotifyHitNPCMulticast final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LarcinPassiveAbility_NotifyHitNPCMulticast) == 0x000008, "Wrong alignment on LarcinPassiveAbility_NotifyHitNPCMulticast");
static_assert(sizeof(LarcinPassiveAbility_NotifyHitNPCMulticast) == 0x000008, "Wrong size on LarcinPassiveAbility_NotifyHitNPCMulticast");
static_assert(offsetof(LarcinPassiveAbility_NotifyHitNPCMulticast, Victim) == 0x000000, "Member 'LarcinPassiveAbility_NotifyHitNPCMulticast::Victim' has a wrong offset!");

// Function DeceiveInc.LarcinPassiveAbility.NotifySuccessfulStealNetMulticast
// 0x0018 (0x0018 - 0x0000)
struct LarcinPassiveAbility_NotifySuccessfulStealNetMulticast final
{
public:
	class AActor*                                 Theft;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayResourcesType                        InResourceType;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LarcinPassiveAbility_NotifySuccessfulStealNetMulticast) == 0x000008, "Wrong alignment on LarcinPassiveAbility_NotifySuccessfulStealNetMulticast");
static_assert(sizeof(LarcinPassiveAbility_NotifySuccessfulStealNetMulticast) == 0x000018, "Wrong size on LarcinPassiveAbility_NotifySuccessfulStealNetMulticast");
static_assert(offsetof(LarcinPassiveAbility_NotifySuccessfulStealNetMulticast, Theft) == 0x000000, "Member 'LarcinPassiveAbility_NotifySuccessfulStealNetMulticast::Theft' has a wrong offset!");
static_assert(offsetof(LarcinPassiveAbility_NotifySuccessfulStealNetMulticast, Victim) == 0x000008, "Member 'LarcinPassiveAbility_NotifySuccessfulStealNetMulticast::Victim' has a wrong offset!");
static_assert(offsetof(LarcinPassiveAbility_NotifySuccessfulStealNetMulticast, InResourceType) == 0x000010, "Member 'LarcinPassiveAbility_NotifySuccessfulStealNetMulticast::InResourceType' has a wrong offset!");

// Function DeceiveInc.LarcinPassiveMod1_2Ability.BP_OnLocalLarcinStoleResource
// 0x0010 (0x0010 - 0x0000)
struct LarcinPassiveMod1_2Ability_BP_OnLocalLarcinStoleResource final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayResourcesType                        InResourceType;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LarcinPassiveMod1_2Ability_BP_OnLocalLarcinStoleResource) == 0x000008, "Wrong alignment on LarcinPassiveMod1_2Ability_BP_OnLocalLarcinStoleResource");
static_assert(sizeof(LarcinPassiveMod1_2Ability_BP_OnLocalLarcinStoleResource) == 0x000010, "Wrong size on LarcinPassiveMod1_2Ability_BP_OnLocalLarcinStoleResource");
static_assert(offsetof(LarcinPassiveMod1_2Ability_BP_OnLocalLarcinStoleResource, Victim) == 0x000000, "Member 'LarcinPassiveMod1_2Ability_BP_OnLocalLarcinStoleResource::Victim' has a wrong offset!");
static_assert(offsetof(LarcinPassiveMod1_2Ability_BP_OnLocalLarcinStoleResource, InResourceType) == 0x000008, "Member 'LarcinPassiveMod1_2Ability_BP_OnLocalLarcinStoleResource::InResourceType' has a wrong offset!");

// Function DeceiveInc.LarcinPassiveMod1_2Ability.BP_OnLocalVictimOfLarcinSteal
// 0x0010 (0x0010 - 0x0000)
struct LarcinPassiveMod1_2Ability_BP_OnLocalVictimOfLarcinSteal final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayResourcesType                        InResourceType;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LarcinPassiveMod1_2Ability_BP_OnLocalVictimOfLarcinSteal) == 0x000008, "Wrong alignment on LarcinPassiveMod1_2Ability_BP_OnLocalVictimOfLarcinSteal");
static_assert(sizeof(LarcinPassiveMod1_2Ability_BP_OnLocalVictimOfLarcinSteal) == 0x000010, "Wrong size on LarcinPassiveMod1_2Ability_BP_OnLocalVictimOfLarcinSteal");
static_assert(offsetof(LarcinPassiveMod1_2Ability_BP_OnLocalVictimOfLarcinSteal, Victim) == 0x000000, "Member 'LarcinPassiveMod1_2Ability_BP_OnLocalVictimOfLarcinSteal::Victim' has a wrong offset!");
static_assert(offsetof(LarcinPassiveMod1_2Ability_BP_OnLocalVictimOfLarcinSteal, InResourceType) == 0x000008, "Member 'LarcinPassiveMod1_2Ability_BP_OnLocalVictimOfLarcinSteal::InResourceType' has a wrong offset!");

// Function DeceiveInc.LarcinPassiveMod1_2Ability.HandleCoverBlownEvent
// 0x0008 (0x0008 - 0x0000)
struct LarcinPassiveMod1_2Ability_HandleCoverBlownEvent final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LarcinPassiveMod1_2Ability_HandleCoverBlownEvent) == 0x000008, "Wrong alignment on LarcinPassiveMod1_2Ability_HandleCoverBlownEvent");
static_assert(sizeof(LarcinPassiveMod1_2Ability_HandleCoverBlownEvent) == 0x000008, "Wrong size on LarcinPassiveMod1_2Ability_HandleCoverBlownEvent");
static_assert(offsetof(LarcinPassiveMod1_2Ability_HandleCoverBlownEvent, Spy) == 0x000000, "Member 'LarcinPassiveMod1_2Ability_HandleCoverBlownEvent::Spy' has a wrong offset!");

// Function DeceiveInc.LarcinPassiveMod1_2Ability.NotifySuccessfulStealNetMulticast
// 0x0018 (0x0018 - 0x0000)
struct LarcinPassiveMod1_2Ability_NotifySuccessfulStealNetMulticast final
{
public:
	class AActor*                                 Larcin;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayResourcesType                        InResourceType;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LarcinPassiveMod1_2Ability_NotifySuccessfulStealNetMulticast) == 0x000008, "Wrong alignment on LarcinPassiveMod1_2Ability_NotifySuccessfulStealNetMulticast");
static_assert(sizeof(LarcinPassiveMod1_2Ability_NotifySuccessfulStealNetMulticast) == 0x000018, "Wrong size on LarcinPassiveMod1_2Ability_NotifySuccessfulStealNetMulticast");
static_assert(offsetof(LarcinPassiveMod1_2Ability_NotifySuccessfulStealNetMulticast, Larcin) == 0x000000, "Member 'LarcinPassiveMod1_2Ability_NotifySuccessfulStealNetMulticast::Larcin' has a wrong offset!");
static_assert(offsetof(LarcinPassiveMod1_2Ability_NotifySuccessfulStealNetMulticast, Victim) == 0x000008, "Member 'LarcinPassiveMod1_2Ability_NotifySuccessfulStealNetMulticast::Victim' has a wrong offset!");
static_assert(offsetof(LarcinPassiveMod1_2Ability_NotifySuccessfulStealNetMulticast, InResourceType) == 0x000010, "Member 'LarcinPassiveMod1_2Ability_NotifySuccessfulStealNetMulticast::InResourceType' has a wrong offset!");

// Function DeceiveInc.LevelArea.GetAreaName
// 0x0018 (0x0018 - 0x0000)
struct LevelArea_GetAreaName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LevelArea_GetAreaName) == 0x000008, "Wrong alignment on LevelArea_GetAreaName");
static_assert(sizeof(LevelArea_GetAreaName) == 0x000018, "Wrong size on LevelArea_GetAreaName");
static_assert(offsetof(LevelArea_GetAreaName, ReturnValue) == 0x000000, "Member 'LevelArea_GetAreaName::ReturnValue' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_AutoSpectatingChange__DelegateSignature
// 0x0010 (0x0010 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_AutoSpectatingChange__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoSpectating;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_AutoSpectatingChange__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_AutoSpectatingChange__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_AutoSpectatingChange__DelegateSignature) == 0x000010, "Wrong size on LocalSpyEventBus_SpyEventDelegate_AutoSpectatingChange__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_AutoSpectatingChange__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_AutoSpectatingChange__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_AutoSpectatingChange__DelegateSignature, bAutoSpectating) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_AutoSpectatingChange__DelegateSignature::bAutoSpectating' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_CancelInteract__DelegateSignature
// 0x0010 (0x0010 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_CancelInteract__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractCancelType                           InteractCancelType;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_CancelInteract__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_CancelInteract__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_CancelInteract__DelegateSignature) == 0x000010, "Wrong size on LocalSpyEventBus_SpyEventDelegate_CancelInteract__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_CancelInteract__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_CancelInteract__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_CancelInteract__DelegateSignature, InteractCancelType) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_CancelInteract__DelegateSignature::InteractCancelType' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_CharmedChange__DelegateSignature
// 0x0010 (0x0010 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_CharmedChange__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCharmed;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_CharmedChange__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_CharmedChange__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_CharmedChange__DelegateSignature) == 0x000010, "Wrong size on LocalSpyEventBus_SpyEventDelegate_CharmedChange__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_CharmedChange__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_CharmedChange__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_CharmedChange__DelegateSignature, bIsCharmed) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_CharmedChange__DelegateSignature::bIsCharmed' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_ConfirmKill__DelegateSignature
// 0x0030 (0x0030 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_ConfirmKill__DelegateSignature final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamagedActor;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UDamageType*                      DamageType;                                        // 0x0018(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_ConfirmKill__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_ConfirmKill__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_ConfirmKill__DelegateSignature) == 0x000030, "Wrong size on LocalSpyEventBus_SpyEventDelegate_ConfirmKill__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_ConfirmKill__DelegateSignature, Spy) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_ConfirmKill__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_ConfirmKill__DelegateSignature, DamagedActor) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_ConfirmKill__DelegateSignature::DamagedActor' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_ConfirmKill__DelegateSignature, Damage) == 0x000010, "Member 'LocalSpyEventBus_SpyEventDelegate_ConfirmKill__DelegateSignature::Damage' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_ConfirmKill__DelegateSignature, DamageType) == 0x000018, "Member 'LocalSpyEventBus_SpyEventDelegate_ConfirmKill__DelegateSignature::DamageType' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_ConfirmKill__DelegateSignature, InstigatedBy) == 0x000020, "Member 'LocalSpyEventBus_SpyEventDelegate_ConfirmKill__DelegateSignature::InstigatedBy' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_ConfirmKill__DelegateSignature, DamageCauser) == 0x000028, "Member 'LocalSpyEventBus_SpyEventDelegate_ConfirmKill__DelegateSignature::DamageCauser' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_CoverChanged__DelegateSignature
// 0x0020 (0x0020 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_CoverChanged__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANPCCharacter*                          NewDisguise;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFirstDisguise;                                  // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_CoverChanged__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_CoverChanged__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_CoverChanged__DelegateSignature) == 0x000020, "Wrong size on LocalSpyEventBus_SpyEventDelegate_CoverChanged__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_CoverChanged__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_CoverChanged__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_CoverChanged__DelegateSignature, Spy) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_CoverChanged__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_CoverChanged__DelegateSignature, NewDisguise) == 0x000010, "Member 'LocalSpyEventBus_SpyEventDelegate_CoverChanged__DelegateSignature::NewDisguise' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_CoverChanged__DelegateSignature, bIsFirstDisguise) == 0x000018, "Member 'LocalSpyEventBus_SpyEventDelegate_CoverChanged__DelegateSignature::bIsFirstDisguise' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_DirectionalDamageReceived__DelegateSignature
// 0x0028 (0x0028 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_DirectionalDamageReceived__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ShotFromDirection;                                 // 0x0014(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitType                                      HitType;                                           // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_DirectionalDamageReceived__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_DirectionalDamageReceived__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_DirectionalDamageReceived__DelegateSignature) == 0x000028, "Wrong size on LocalSpyEventBus_SpyEventDelegate_DirectionalDamageReceived__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_DirectionalDamageReceived__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_DirectionalDamageReceived__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_DirectionalDamageReceived__DelegateSignature, Spy) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_DirectionalDamageReceived__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_DirectionalDamageReceived__DelegateSignature, Damage) == 0x000010, "Member 'LocalSpyEventBus_SpyEventDelegate_DirectionalDamageReceived__DelegateSignature::Damage' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_DirectionalDamageReceived__DelegateSignature, ShotFromDirection) == 0x000014, "Member 'LocalSpyEventBus_SpyEventDelegate_DirectionalDamageReceived__DelegateSignature::ShotFromDirection' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_DirectionalDamageReceived__DelegateSignature, HitType) == 0x000020, "Member 'LocalSpyEventBus_SpyEventDelegate_DirectionalDamageReceived__DelegateSignature::HitType' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_FallLand__DelegateSignature
// 0x0010 (0x0010 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_FallLand__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FallStep;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FallDamageAmount;                                  // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_FallLand__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_FallLand__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_FallLand__DelegateSignature) == 0x000010, "Wrong size on LocalSpyEventBus_SpyEventDelegate_FallLand__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_FallLand__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_FallLand__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_FallLand__DelegateSignature, FallStep) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_FallLand__DelegateSignature::FallStep' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_FallLand__DelegateSignature, FallDamageAmount) == 0x00000C, "Member 'LocalSpyEventBus_SpyEventDelegate_FallLand__DelegateSignature::FallDamageAmount' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_Generic__DelegateSignature
// 0x0010 (0x0010 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_Generic__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_Generic__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_Generic__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_Generic__DelegateSignature) == 0x000010, "Wrong size on LocalSpyEventBus_SpyEventDelegate_Generic__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_Generic__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_Generic__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_Generic__DelegateSignature, Spy) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_Generic__DelegateSignature::Spy' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_HeadingChange__DelegateSignature
// 0x0018 (0x0018 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_HeadingChange__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewHeading;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_HeadingChange__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_HeadingChange__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_HeadingChange__DelegateSignature) == 0x000018, "Wrong size on LocalSpyEventBus_SpyEventDelegate_HeadingChange__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_HeadingChange__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_HeadingChange__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_HeadingChange__DelegateSignature, Spy) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_HeadingChange__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_HeadingChange__DelegateSignature, NewHeading) == 0x000010, "Member 'LocalSpyEventBus_SpyEventDelegate_HeadingChange__DelegateSignature::NewHeading' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_IntroFlow__DelegateSignature
// 0x0018 (0x0018 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_IntroFlow__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AIntroFlow*                             IntroFlowActor;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_IntroFlow__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_IntroFlow__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_IntroFlow__DelegateSignature) == 0x000018, "Wrong size on LocalSpyEventBus_SpyEventDelegate_IntroFlow__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_IntroFlow__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_IntroFlow__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_IntroFlow__DelegateSignature, Spy) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_IntroFlow__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_IntroFlow__DelegateSignature, IntroFlowActor) == 0x000010, "Member 'LocalSpyEventBus_SpyEventDelegate_IntroFlow__DelegateSignature::IntroFlowActor' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_InVaultChanged__DelegateSignature
// 0x0018 (0x0018 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_InVaultChanged__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInVault;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_InVaultChanged__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_InVaultChanged__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_InVaultChanged__DelegateSignature) == 0x000018, "Wrong size on LocalSpyEventBus_SpyEventDelegate_InVaultChanged__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_InVaultChanged__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_InVaultChanged__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_InVaultChanged__DelegateSignature, Spy) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_InVaultChanged__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_InVaultChanged__DelegateSignature, bInVault) == 0x000010, "Member 'LocalSpyEventBus_SpyEventDelegate_InVaultChanged__DelegateSignature::bInVault' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_KillcamPlaybackChange__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_KillcamPlaybackChange__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_KillcamPlaybackChange__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_KillcamPlaybackChange__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_KillcamPlaybackChange__DelegateSignature) == 0x000008, "Wrong size on LocalSpyEventBus_SpyEventDelegate_KillcamPlaybackChange__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_KillcamPlaybackChange__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_KillcamPlaybackChange__DelegateSignature::PlayerController' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_LoadoutSpawnComplete__DelegateSignature
// 0x0010 (0x0010 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_LoadoutSpawnComplete__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UToolLoadoutComponent*                  ToolLoadout;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_LoadoutSpawnComplete__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_LoadoutSpawnComplete__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_LoadoutSpawnComplete__DelegateSignature) == 0x000010, "Wrong size on LocalSpyEventBus_SpyEventDelegate_LoadoutSpawnComplete__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_LoadoutSpawnComplete__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_LoadoutSpawnComplete__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_LoadoutSpawnComplete__DelegateSignature, ToolLoadout) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_LoadoutSpawnComplete__DelegateSignature::ToolLoadout' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_MeleeImpact__DelegateSignature
// 0x0038 (0x0038 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_MeleeImpact__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPoint;                                       // 0x0018(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChargeLevel;                                       // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultingHealthPercentage;                         // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitType                                      HitType;                                           // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_MeleeImpact__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_MeleeImpact__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_MeleeImpact__DelegateSignature) == 0x000038, "Wrong size on LocalSpyEventBus_SpyEventDelegate_MeleeImpact__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_MeleeImpact__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_MeleeImpact__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_MeleeImpact__DelegateSignature, Spy) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_MeleeImpact__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_MeleeImpact__DelegateSignature, Victim) == 0x000010, "Member 'LocalSpyEventBus_SpyEventDelegate_MeleeImpact__DelegateSignature::Victim' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_MeleeImpact__DelegateSignature, ImpactPoint) == 0x000018, "Member 'LocalSpyEventBus_SpyEventDelegate_MeleeImpact__DelegateSignature::ImpactPoint' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_MeleeImpact__DelegateSignature, ChargeLevel) == 0x000024, "Member 'LocalSpyEventBus_SpyEventDelegate_MeleeImpact__DelegateSignature::ChargeLevel' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_MeleeImpact__DelegateSignature, Damage) == 0x000028, "Member 'LocalSpyEventBus_SpyEventDelegate_MeleeImpact__DelegateSignature::Damage' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_MeleeImpact__DelegateSignature, ResultingHealthPercentage) == 0x00002C, "Member 'LocalSpyEventBus_SpyEventDelegate_MeleeImpact__DelegateSignature::ResultingHealthPercentage' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_MeleeImpact__DelegateSignature, HitType) == 0x000030, "Member 'LocalSpyEventBus_SpyEventDelegate_MeleeImpact__DelegateSignature::HitType' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_MovementEvent__DelegateSignature
// 0x0018 (0x0018 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_MovementEvent__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementEventType                            MovementEventType;                                 // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_MovementEvent__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_MovementEvent__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_MovementEvent__DelegateSignature) == 0x000018, "Wrong size on LocalSpyEventBus_SpyEventDelegate_MovementEvent__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_MovementEvent__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_MovementEvent__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_MovementEvent__DelegateSignature, Spy) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_MovementEvent__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_MovementEvent__DelegateSignature, MovementEventType) == 0x000010, "Member 'LocalSpyEventBus_SpyEventDelegate_MovementEvent__DelegateSignature::MovementEventType' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_PlayerNameChanged__DelegateSignature
// 0x0018 (0x0018 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_PlayerNameChanged__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerName;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_PlayerNameChanged__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_PlayerNameChanged__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_PlayerNameChanged__DelegateSignature) == 0x000018, "Wrong size on LocalSpyEventBus_SpyEventDelegate_PlayerNameChanged__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_PlayerNameChanged__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_PlayerNameChanged__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_PlayerNameChanged__DelegateSignature, PlayerName) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_PlayerNameChanged__DelegateSignature::PlayerName' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_PoudrierVisibilityChange__DelegateSignature
// 0x0010 (0x0010 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_PoudrierVisibilityChange__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisible;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_PoudrierVisibilityChange__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_PoudrierVisibilityChange__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_PoudrierVisibilityChange__DelegateSignature) == 0x000010, "Wrong size on LocalSpyEventBus_SpyEventDelegate_PoudrierVisibilityChange__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_PoudrierVisibilityChange__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_PoudrierVisibilityChange__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_PoudrierVisibilityChange__DelegateSignature, bVisible) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_PoudrierVisibilityChange__DelegateSignature::bVisible' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_ReceivedXPEvent__DelegateSignature
// 0x0010 (0x0010 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_ReceivedXPEvent__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDIXPEvent                                    XPEventType;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AddedXP;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_ReceivedXPEvent__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_ReceivedXPEvent__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_ReceivedXPEvent__DelegateSignature) == 0x000010, "Wrong size on LocalSpyEventBus_SpyEventDelegate_ReceivedXPEvent__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_ReceivedXPEvent__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_ReceivedXPEvent__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_ReceivedXPEvent__DelegateSignature, XPEventType) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_ReceivedXPEvent__DelegateSignature::XPEventType' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_ReceivedXPEvent__DelegateSignature, AddedXP) == 0x00000C, "Member 'LocalSpyEventBus_SpyEventDelegate_ReceivedXPEvent__DelegateSignature::AddedXP' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_ResourceAmountChanged__DelegateSignature
// 0x0020 (0x0020 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_ResourceAmountChanged__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayResourcesType                        AffectedResource;                                  // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NewResourceCount;                                  // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmountDelta;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_ResourceAmountChanged__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_ResourceAmountChanged__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_ResourceAmountChanged__DelegateSignature) == 0x000020, "Wrong size on LocalSpyEventBus_SpyEventDelegate_ResourceAmountChanged__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_ResourceAmountChanged__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_ResourceAmountChanged__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_ResourceAmountChanged__DelegateSignature, Spy) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_ResourceAmountChanged__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_ResourceAmountChanged__DelegateSignature, AffectedResource) == 0x000010, "Member 'LocalSpyEventBus_SpyEventDelegate_ResourceAmountChanged__DelegateSignature::AffectedResource' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_ResourceAmountChanged__DelegateSignature, NewResourceCount) == 0x000014, "Member 'LocalSpyEventBus_SpyEventDelegate_ResourceAmountChanged__DelegateSignature::NewResourceCount' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_ResourceAmountChanged__DelegateSignature, AmountDelta) == 0x000018, "Member 'LocalSpyEventBus_SpyEventDelegate_ResourceAmountChanged__DelegateSignature::AmountDelta' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_ResourceNewAmount__DelegateSignature
// 0x0018 (0x0018 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_ResourceNewAmount__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayResourcesType                        AffectedResource;                                  // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NewResourceCount;                                  // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_ResourceNewAmount__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_ResourceNewAmount__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_ResourceNewAmount__DelegateSignature) == 0x000018, "Wrong size on LocalSpyEventBus_SpyEventDelegate_ResourceNewAmount__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_ResourceNewAmount__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_ResourceNewAmount__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_ResourceNewAmount__DelegateSignature, Spy) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_ResourceNewAmount__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_ResourceNewAmount__DelegateSignature, AffectedResource) == 0x000010, "Member 'LocalSpyEventBus_SpyEventDelegate_ResourceNewAmount__DelegateSignature::AffectedResource' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_ResourceNewAmount__DelegateSignature, NewResourceCount) == 0x000014, "Member 'LocalSpyEventBus_SpyEventDelegate_ResourceNewAmount__DelegateSignature::NewResourceCount' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_RoomChanged__DelegateSignature
// 0x0018 (0x0018 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_RoomChanged__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARoomVolume*                            InRoom;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_RoomChanged__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_RoomChanged__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_RoomChanged__DelegateSignature) == 0x000018, "Wrong size on LocalSpyEventBus_SpyEventDelegate_RoomChanged__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_RoomChanged__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_RoomChanged__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_RoomChanged__DelegateSignature, Spy) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_RoomChanged__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_RoomChanged__DelegateSignature, InRoom) == 0x000010, "Member 'LocalSpyEventBus_SpyEventDelegate_RoomChanged__DelegateSignature::InRoom' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_SpectatingPlayerChange__DelegateSignature
// 0x0018 (0x0018 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_SpectatingPlayerChange__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SpectatingActor;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADIPlayerState*                         SpectatingPlayerState;                             // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_SpectatingPlayerChange__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_SpectatingPlayerChange__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_SpectatingPlayerChange__DelegateSignature) == 0x000018, "Wrong size on LocalSpyEventBus_SpyEventDelegate_SpectatingPlayerChange__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_SpectatingPlayerChange__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_SpectatingPlayerChange__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_SpectatingPlayerChange__DelegateSignature, SpectatingActor) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_SpectatingPlayerChange__DelegateSignature::SpectatingActor' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_SpectatingPlayerChange__DelegateSignature, SpectatingPlayerState) == 0x000010, "Member 'LocalSpyEventBus_SpyEventDelegate_SpectatingPlayerChange__DelegateSignature::SpectatingPlayerState' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_WeaponAllowedChange__DelegateSignature
// 0x0020 (0x0020 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_WeaponAllowedChange__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AProjectileWeapon*                      Weapon;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAllowed;                                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_WeaponAllowedChange__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_WeaponAllowedChange__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_WeaponAllowedChange__DelegateSignature) == 0x000020, "Wrong size on LocalSpyEventBus_SpyEventDelegate_WeaponAllowedChange__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_WeaponAllowedChange__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_WeaponAllowedChange__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_WeaponAllowedChange__DelegateSignature, Spy) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_WeaponAllowedChange__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_WeaponAllowedChange__DelegateSignature, Weapon) == 0x000010, "Member 'LocalSpyEventBus_SpyEventDelegate_WeaponAllowedChange__DelegateSignature::Weapon' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_WeaponAllowedChange__DelegateSignature, bIsAllowed) == 0x000018, "Member 'LocalSpyEventBus_SpyEventDelegate_WeaponAllowedChange__DelegateSignature::bIsAllowed' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_WeaponAmmoStateChange__DelegateSignature
// 0x0020 (0x0020 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_WeaponAmmoStateChange__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AProjectileWeapon*                      Weapon;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponAmmoState                              AmmoState;                                         // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_WeaponAmmoStateChange__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_WeaponAmmoStateChange__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_WeaponAmmoStateChange__DelegateSignature) == 0x000020, "Wrong size on LocalSpyEventBus_SpyEventDelegate_WeaponAmmoStateChange__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_WeaponAmmoStateChange__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_WeaponAmmoStateChange__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_WeaponAmmoStateChange__DelegateSignature, Spy) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_WeaponAmmoStateChange__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_WeaponAmmoStateChange__DelegateSignature, Weapon) == 0x000010, "Member 'LocalSpyEventBus_SpyEventDelegate_WeaponAmmoStateChange__DelegateSignature::Weapon' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_WeaponAmmoStateChange__DelegateSignature, AmmoState) == 0x000018, "Member 'LocalSpyEventBus_SpyEventDelegate_WeaponAmmoStateChange__DelegateSignature::AmmoState' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_WeaponChargeChange__DelegateSignature
// 0x0018 (0x0018 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_WeaponChargeChange__DelegateSignature final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AProjectileWeapon*                      Weapon;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCharging;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxChargingTime;                                   // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_WeaponChargeChange__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_WeaponChargeChange__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_WeaponChargeChange__DelegateSignature) == 0x000018, "Wrong size on LocalSpyEventBus_SpyEventDelegate_WeaponChargeChange__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_WeaponChargeChange__DelegateSignature, Spy) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_WeaponChargeChange__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_WeaponChargeChange__DelegateSignature, Weapon) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_WeaponChargeChange__DelegateSignature::Weapon' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_WeaponChargeChange__DelegateSignature, bIsCharging) == 0x000010, "Member 'LocalSpyEventBus_SpyEventDelegate_WeaponChargeChange__DelegateSignature::bIsCharging' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_WeaponChargeChange__DelegateSignature, MaxChargingTime) == 0x000014, "Member 'LocalSpyEventBus_SpyEventDelegate_WeaponChargeChange__DelegateSignature::MaxChargingTime' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_WeaponHitConfirmedEvent__DelegateSignature
// 0x0050 (0x0050 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_WeaponHitConfirmedEvent__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitConfirmData                        HitConfirmedData;                                  // 0x0010(0x0040)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_WeaponHitConfirmedEvent__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_WeaponHitConfirmedEvent__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_WeaponHitConfirmedEvent__DelegateSignature) == 0x000050, "Wrong size on LocalSpyEventBus_SpyEventDelegate_WeaponHitConfirmedEvent__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_WeaponHitConfirmedEvent__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_WeaponHitConfirmedEvent__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_WeaponHitConfirmedEvent__DelegateSignature, Spy) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_WeaponHitConfirmedEvent__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_WeaponHitConfirmedEvent__DelegateSignature, HitConfirmedData) == 0x000010, "Member 'LocalSpyEventBus_SpyEventDelegate_WeaponHitConfirmedEvent__DelegateSignature::HitConfirmedData' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_WeaponProjectileImpact__DelegateSignature
// 0x0060 (0x0060 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_WeaponProjectileImpact__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWeaponImpactData                      WeaponImpactData;                                  // 0x0010(0x0050)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_WeaponProjectileImpact__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_WeaponProjectileImpact__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_WeaponProjectileImpact__DelegateSignature) == 0x000060, "Wrong size on LocalSpyEventBus_SpyEventDelegate_WeaponProjectileImpact__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_WeaponProjectileImpact__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_WeaponProjectileImpact__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_WeaponProjectileImpact__DelegateSignature, Spy) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_WeaponProjectileImpact__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_WeaponProjectileImpact__DelegateSignature, WeaponImpactData) == 0x000010, "Member 'LocalSpyEventBus_SpyEventDelegate_WeaponProjectileImpact__DelegateSignature::WeaponImpactData' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDelegate_WeaponShoot__DelegateSignature
// 0x0028 (0x0028 - 0x0000)
struct LocalSpyEventBus_SpyEventDelegate_WeaponShoot__DelegateSignature final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AProjectileWeapon*                      Weapon;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginPos;                                         // 0x0010(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DestinationPos;                                    // 0x001C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LocalSpyEventBus_SpyEventDelegate_WeaponShoot__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDelegate_WeaponShoot__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDelegate_WeaponShoot__DelegateSignature) == 0x000028, "Wrong size on LocalSpyEventBus_SpyEventDelegate_WeaponShoot__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_WeaponShoot__DelegateSignature, Spy) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDelegate_WeaponShoot__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_WeaponShoot__DelegateSignature, Weapon) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDelegate_WeaponShoot__DelegateSignature::Weapon' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_WeaponShoot__DelegateSignature, OriginPos) == 0x000010, "Member 'LocalSpyEventBus_SpyEventDelegate_WeaponShoot__DelegateSignature::OriginPos' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDelegate_WeaponShoot__DelegateSignature, DestinationPos) == 0x00001C, "Member 'LocalSpyEventBus_SpyEventDelegate_WeaponShoot__DelegateSignature::DestinationPos' has a wrong offset!");

// DelegateFunction DeceiveInc.LocalSpyEventBus.SpyEventDeletgate_HealthChanged__DelegateSignature
// 0x0048 (0x0048 - 0x0000)
struct LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHealthComponent*                       SpyHealthComp;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthDelta;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDamageType*                      DamageType;                                        // 0x0020(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DamageDirection;                                   // 0x0038(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature) == 0x000008, "Wrong alignment on LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature");
static_assert(sizeof(LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature) == 0x000048, "Wrong size on LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature");
static_assert(offsetof(LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature, PlayerController) == 0x000000, "Member 'LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature, Spy) == 0x000008, "Member 'LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature, SpyHealthComp) == 0x000010, "Member 'LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature::SpyHealthComp' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature, Health) == 0x000018, "Member 'LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature::Health' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature, HealthDelta) == 0x00001C, "Member 'LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature::HealthDelta' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature, DamageType) == 0x000020, "Member 'LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature::DamageType' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature, InstigatedBy) == 0x000028, "Member 'LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature::InstigatedBy' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature, DamageCauser) == 0x000030, "Member 'LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature::DamageCauser' has a wrong offset!");
static_assert(offsetof(LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature, DamageDirection) == 0x000038, "Member 'LocalSpyEventBus_SpyEventDeletgate_HealthChanged__DelegateSignature::DamageDirection' has a wrong offset!");

// Function DeceiveInc.LootItemShowcase.BP_OnClaimedItemResponseSet
// 0x0020 (0x0020 - 0x0000)
struct LootItemShowcase_BP_OnClaimedItemResponseSet final
{
public:
	struct FClaimedItemResponse                   NewClaimedItemResponse;                            // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	class UDIItem*                                ItemIn;                                            // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootItemShowcase_BP_OnClaimedItemResponseSet) == 0x000008, "Wrong alignment on LootItemShowcase_BP_OnClaimedItemResponseSet");
static_assert(sizeof(LootItemShowcase_BP_OnClaimedItemResponseSet) == 0x000020, "Wrong size on LootItemShowcase_BP_OnClaimedItemResponseSet");
static_assert(offsetof(LootItemShowcase_BP_OnClaimedItemResponseSet, NewClaimedItemResponse) == 0x000000, "Member 'LootItemShowcase_BP_OnClaimedItemResponseSet::NewClaimedItemResponse' has a wrong offset!");
static_assert(offsetof(LootItemShowcase_BP_OnClaimedItemResponseSet, ItemIn) == 0x000018, "Member 'LootItemShowcase_BP_OnClaimedItemResponseSet::ItemIn' has a wrong offset!");

// Function DeceiveInc.LootItemShowcase.EnableItemRotation
// 0x0001 (0x0001 - 0x0000)
struct LootItemShowcase_EnableItemRotation final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootItemShowcase_EnableItemRotation) == 0x000001, "Wrong alignment on LootItemShowcase_EnableItemRotation");
static_assert(sizeof(LootItemShowcase_EnableItemRotation) == 0x000001, "Wrong size on LootItemShowcase_EnableItemRotation");
static_assert(offsetof(LootItemShowcase_EnableItemRotation, bEnable) == 0x000000, "Member 'LootItemShowcase_EnableItemRotation::bEnable' has a wrong offset!");

// Function DeceiveInc.LootItemShowcase.GetAvatarTexture2D
// 0x0008 (0x0008 - 0x0000)
struct LootItemShowcase_GetAvatarTexture2D final
{
public:
	class UTexture2D*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootItemShowcase_GetAvatarTexture2D) == 0x000008, "Wrong alignment on LootItemShowcase_GetAvatarTexture2D");
static_assert(sizeof(LootItemShowcase_GetAvatarTexture2D) == 0x000008, "Wrong size on LootItemShowcase_GetAvatarTexture2D");
static_assert(offsetof(LootItemShowcase_GetAvatarTexture2D, ReturnValue) == 0x000000, "Member 'LootItemShowcase_GetAvatarTexture2D::ReturnValue' has a wrong offset!");

// Function DeceiveInc.LootItemShowcase.GetClaimedItemResponse
// 0x0018 (0x0018 - 0x0000)
struct LootItemShowcase_GetClaimedItemResponse final
{
public:
	struct FClaimedItemResponse                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootItemShowcase_GetClaimedItemResponse) == 0x000008, "Wrong alignment on LootItemShowcase_GetClaimedItemResponse");
static_assert(sizeof(LootItemShowcase_GetClaimedItemResponse) == 0x000018, "Wrong size on LootItemShowcase_GetClaimedItemResponse");
static_assert(offsetof(LootItemShowcase_GetClaimedItemResponse, ReturnValue) == 0x000000, "Member 'LootItemShowcase_GetClaimedItemResponse::ReturnValue' has a wrong offset!");

// Function DeceiveInc.LootItemShowcase.GetFocusCamera
// 0x0008 (0x0008 - 0x0000)
struct LootItemShowcase_GetFocusCamera final
{
public:
	class UCameraComponent*                       ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootItemShowcase_GetFocusCamera) == 0x000008, "Wrong alignment on LootItemShowcase_GetFocusCamera");
static_assert(sizeof(LootItemShowcase_GetFocusCamera) == 0x000008, "Wrong size on LootItemShowcase_GetFocusCamera");
static_assert(offsetof(LootItemShowcase_GetFocusCamera, ReturnValue) == 0x000000, "Member 'LootItemShowcase_GetFocusCamera::ReturnValue' has a wrong offset!");

// Function DeceiveInc.LootItemShowcase.GetHoverWidgetRefPos
// 0x000C (0x000C - 0x0000)
struct LootItemShowcase_GetHoverWidgetRefPos final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootItemShowcase_GetHoverWidgetRefPos) == 0x000004, "Wrong alignment on LootItemShowcase_GetHoverWidgetRefPos");
static_assert(sizeof(LootItemShowcase_GetHoverWidgetRefPos) == 0x00000C, "Wrong size on LootItemShowcase_GetHoverWidgetRefPos");
static_assert(offsetof(LootItemShowcase_GetHoverWidgetRefPos, ReturnValue) == 0x000000, "Member 'LootItemShowcase_GetHoverWidgetRefPos::ReturnValue' has a wrong offset!");

// Function DeceiveInc.LootItemShowcase.GetItem
// 0x0008 (0x0008 - 0x0000)
struct LootItemShowcase_GetItem final
{
public:
	class UDIItem*                                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootItemShowcase_GetItem) == 0x000008, "Wrong alignment on LootItemShowcase_GetItem");
static_assert(sizeof(LootItemShowcase_GetItem) == 0x000008, "Wrong size on LootItemShowcase_GetItem");
static_assert(offsetof(LootItemShowcase_GetItem, ReturnValue) == 0x000000, "Member 'LootItemShowcase_GetItem::ReturnValue' has a wrong offset!");

// Function DeceiveInc.LootItemShowcase.GetItemDisplayName
// 0x0018 (0x0018 - 0x0000)
struct LootItemShowcase_GetItemDisplayName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootItemShowcase_GetItemDisplayName) == 0x000008, "Wrong alignment on LootItemShowcase_GetItemDisplayName");
static_assert(sizeof(LootItemShowcase_GetItemDisplayName) == 0x000018, "Wrong size on LootItemShowcase_GetItemDisplayName");
static_assert(offsetof(LootItemShowcase_GetItemDisplayName, ReturnValue) == 0x000000, "Member 'LootItemShowcase_GetItemDisplayName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.LootItemShowcase.GetItemRarity
// 0x0004 (0x0004 - 0x0000)
struct LootItemShowcase_GetItemRarity final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootItemShowcase_GetItemRarity) == 0x000004, "Wrong alignment on LootItemShowcase_GetItemRarity");
static_assert(sizeof(LootItemShowcase_GetItemRarity) == 0x000004, "Wrong size on LootItemShowcase_GetItemRarity");
static_assert(offsetof(LootItemShowcase_GetItemRarity, ReturnValue) == 0x000000, "Member 'LootItemShowcase_GetItemRarity::ReturnValue' has a wrong offset!");

// Function DeceiveInc.LootItemShowcase.GetItemRarityDisplayName
// 0x0018 (0x0018 - 0x0000)
struct LootItemShowcase_GetItemRarityDisplayName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootItemShowcase_GetItemRarityDisplayName) == 0x000008, "Wrong alignment on LootItemShowcase_GetItemRarityDisplayName");
static_assert(sizeof(LootItemShowcase_GetItemRarityDisplayName) == 0x000018, "Wrong size on LootItemShowcase_GetItemRarityDisplayName");
static_assert(offsetof(LootItemShowcase_GetItemRarityDisplayName, ReturnValue) == 0x000000, "Member 'LootItemShowcase_GetItemRarityDisplayName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.LootItemShowcase.GetItemTypeDisplayName
// 0x0018 (0x0018 - 0x0000)
struct LootItemShowcase_GetItemTypeDisplayName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootItemShowcase_GetItemTypeDisplayName) == 0x000008, "Wrong alignment on LootItemShowcase_GetItemTypeDisplayName");
static_assert(sizeof(LootItemShowcase_GetItemTypeDisplayName) == 0x000018, "Wrong size on LootItemShowcase_GetItemTypeDisplayName");
static_assert(offsetof(LootItemShowcase_GetItemTypeDisplayName, ReturnValue) == 0x000000, "Member 'LootItemShowcase_GetItemTypeDisplayName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.LootItemShowcase.GetItemVisualRepresentation
// 0x0008 (0x0008 - 0x0000)
struct LootItemShowcase_GetItemVisualRepresentation final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootItemShowcase_GetItemVisualRepresentation) == 0x000008, "Wrong alignment on LootItemShowcase_GetItemVisualRepresentation");
static_assert(sizeof(LootItemShowcase_GetItemVisualRepresentation) == 0x000008, "Wrong size on LootItemShowcase_GetItemVisualRepresentation");
static_assert(offsetof(LootItemShowcase_GetItemVisualRepresentation, ReturnValue) == 0x000000, "Member 'LootItemShowcase_GetItemVisualRepresentation::ReturnValue' has a wrong offset!");

// Function DeceiveInc.MaxUseConditionComponent.OnInteractionComplete
// 0x0010 (0x0010 - 0x0000)
struct MaxUseConditionComponent_OnInteractionComplete final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MaxUseConditionComponent_OnInteractionComplete) == 0x000008, "Wrong alignment on MaxUseConditionComponent_OnInteractionComplete");
static_assert(sizeof(MaxUseConditionComponent_OnInteractionComplete) == 0x000010, "Wrong size on MaxUseConditionComponent_OnInteractionComplete");
static_assert(offsetof(MaxUseConditionComponent_OnInteractionComplete, Interacter) == 0x000000, "Member 'MaxUseConditionComponent_OnInteractionComplete::Interacter' has a wrong offset!");
static_assert(offsetof(MaxUseConditionComponent_OnInteractionComplete, Interactable) == 0x000008, "Member 'MaxUseConditionComponent_OnInteractionComplete::Interactable' has a wrong offset!");

// Function DeceiveInc.MaxUseConditionComponent.ResetForPlayer
// 0x0010 (0x0010 - 0x0000)
struct MaxUseConditionComponent_ResetForPlayer final
{
public:
	class AActor*                                 PlayerActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MaxUseConditionComponent_ResetForPlayer) == 0x000008, "Wrong alignment on MaxUseConditionComponent_ResetForPlayer");
static_assert(sizeof(MaxUseConditionComponent_ResetForPlayer) == 0x000010, "Wrong size on MaxUseConditionComponent_ResetForPlayer");
static_assert(offsetof(MaxUseConditionComponent_ResetForPlayer, PlayerActor) == 0x000000, "Member 'MaxUseConditionComponent_ResetForPlayer::PlayerActor' has a wrong offset!");
static_assert(offsetof(MaxUseConditionComponent_ResetForPlayer, ReturnValue) == 0x000008, "Member 'MaxUseConditionComponent_ResetForPlayer::ReturnValue' has a wrong offset!");

// Function DeceiveInc.MenuData.GetMenuWidgetClass
// 0x0010 (0x0010 - 0x0000)
struct MenuData_GetMenuWidgetClass final
{
public:
	EMenuType                                     MenuType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MenuData_GetMenuWidgetClass) == 0x000008, "Wrong alignment on MenuData_GetMenuWidgetClass");
static_assert(sizeof(MenuData_GetMenuWidgetClass) == 0x000010, "Wrong size on MenuData_GetMenuWidgetClass");
static_assert(offsetof(MenuData_GetMenuWidgetClass, MenuType) == 0x000000, "Member 'MenuData_GetMenuWidgetClass::MenuType' has a wrong offset!");
static_assert(offsetof(MenuData_GetMenuWidgetClass, ReturnValue) == 0x000008, "Member 'MenuData_GetMenuWidgetClass::ReturnValue' has a wrong offset!");

// Function DeceiveInc.MessageUserWidget.CreateMessageWidget
// 0x0130 (0x0130 - 0x0000)
struct MessageUserWidget_CreateMessageWidget final
{
public:
	struct FDIMessageSettings                     InMessageSettings;                                 // 0x0000(0x0128)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UMessageUserWidget*                     ReturnValue;                                       // 0x0128(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MessageUserWidget_CreateMessageWidget) == 0x000008, "Wrong alignment on MessageUserWidget_CreateMessageWidget");
static_assert(sizeof(MessageUserWidget_CreateMessageWidget) == 0x000130, "Wrong size on MessageUserWidget_CreateMessageWidget");
static_assert(offsetof(MessageUserWidget_CreateMessageWidget, InMessageSettings) == 0x000000, "Member 'MessageUserWidget_CreateMessageWidget::InMessageSettings' has a wrong offset!");
static_assert(offsetof(MessageUserWidget_CreateMessageWidget, ReturnValue) == 0x000128, "Member 'MessageUserWidget_CreateMessageWidget::ReturnValue' has a wrong offset!");

// Function DeceiveInc.MessageUserWidget.ImageAsset
// 0x0028 (0x0028 - 0x0000)
struct MessageUserWidget_ImageAsset final
{
public:
	TSoftObjectPtr<class UTexture>                ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MessageUserWidget_ImageAsset) == 0x000008, "Wrong alignment on MessageUserWidget_ImageAsset");
static_assert(sizeof(MessageUserWidget_ImageAsset) == 0x000028, "Wrong size on MessageUserWidget_ImageAsset");
static_assert(offsetof(MessageUserWidget_ImageAsset, ReturnValue) == 0x000000, "Member 'MessageUserWidget_ImageAsset::ReturnValue' has a wrong offset!");

// Function DeceiveInc.MessageUserWidget.SetMessageSettings
// 0x0128 (0x0128 - 0x0000)
struct MessageUserWidget_SetMessageSettings final
{
public:
	struct FDIMessageSettings                     InMessageSettings;                                 // 0x0000(0x0128)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MessageUserWidget_SetMessageSettings) == 0x000008, "Wrong alignment on MessageUserWidget_SetMessageSettings");
static_assert(sizeof(MessageUserWidget_SetMessageSettings) == 0x000128, "Wrong size on MessageUserWidget_SetMessageSettings");
static_assert(offsetof(MessageUserWidget_SetMessageSettings, InMessageSettings) == 0x000000, "Member 'MessageUserWidget_SetMessageSettings::InMessageSettings' has a wrong offset!");

// Function DeceiveInc.MessageUserWidget.GetExtraData
// 0x0010 (0x0010 - 0x0000)
struct MessageUserWidget_GetExtraData final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MessageUserWidget_GetExtraData) == 0x000008, "Wrong alignment on MessageUserWidget_GetExtraData");
static_assert(sizeof(MessageUserWidget_GetExtraData) == 0x000010, "Wrong size on MessageUserWidget_GetExtraData");
static_assert(offsetof(MessageUserWidget_GetExtraData, ReturnValue) == 0x000000, "Member 'MessageUserWidget_GetExtraData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.MessageUserWidget.GetText
// 0x0018 (0x0018 - 0x0000)
struct MessageUserWidget_GetText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MessageUserWidget_GetText) == 0x000008, "Wrong alignment on MessageUserWidget_GetText");
static_assert(sizeof(MessageUserWidget_GetText) == 0x000018, "Wrong size on MessageUserWidget_GetText");
static_assert(offsetof(MessageUserWidget_GetText, ReturnValue) == 0x000000, "Member 'MessageUserWidget_GetText::ReturnValue' has a wrong offset!");

// Function DeceiveInc.MessageUserWidget.GetTitle
// 0x0018 (0x0018 - 0x0000)
struct MessageUserWidget_GetTitle final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MessageUserWidget_GetTitle) == 0x000008, "Wrong alignment on MessageUserWidget_GetTitle");
static_assert(sizeof(MessageUserWidget_GetTitle) == 0x000018, "Wrong size on MessageUserWidget_GetTitle");
static_assert(offsetof(MessageUserWidget_GetTitle, ReturnValue) == 0x000000, "Member 'MessageUserWidget_GetTitle::ReturnValue' has a wrong offset!");

// Function DeceiveInc.MimicScannableComponent.OnSpyToolLoadComplete
// 0x0008 (0x0008 - 0x0000)
struct MimicScannableComponent_OnSpyToolLoadComplete final
{
public:
	class UToolLoadoutComponent*                  ToolLoadout;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MimicScannableComponent_OnSpyToolLoadComplete) == 0x000008, "Wrong alignment on MimicScannableComponent_OnSpyToolLoadComplete");
static_assert(sizeof(MimicScannableComponent_OnSpyToolLoadComplete) == 0x000008, "Wrong size on MimicScannableComponent_OnSpyToolLoadComplete");
static_assert(offsetof(MimicScannableComponent_OnSpyToolLoadComplete, ToolLoadout) == 0x000000, "Member 'MimicScannableComponent_OnSpyToolLoadComplete::ToolLoadout' has a wrong offset!");

// Function DeceiveInc.MimicScannerTool.HandleCoverAffectingSourceChange
// 0x0002 (0x0002 - 0x0000)
struct MimicScannerTool_HandleCoverAffectingSourceChange final
{
public:
	ECoverAffectingSourceType                     NewCoverAffectingType;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdded;                                            // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MimicScannerTool_HandleCoverAffectingSourceChange) == 0x000001, "Wrong alignment on MimicScannerTool_HandleCoverAffectingSourceChange");
static_assert(sizeof(MimicScannerTool_HandleCoverAffectingSourceChange) == 0x000002, "Wrong size on MimicScannerTool_HandleCoverAffectingSourceChange");
static_assert(offsetof(MimicScannerTool_HandleCoverAffectingSourceChange, NewCoverAffectingType) == 0x000000, "Member 'MimicScannerTool_HandleCoverAffectingSourceChange::NewCoverAffectingType' has a wrong offset!");
static_assert(offsetof(MimicScannerTool_HandleCoverAffectingSourceChange, bAdded) == 0x000001, "Member 'MimicScannerTool_HandleCoverAffectingSourceChange::bAdded' has a wrong offset!");

// Function DeceiveInc.MimicScannerTool.NetMulticast_ToggleMimicRotation
// 0x0001 (0x0001 - 0x0000)
struct MimicScannerTool_NetMulticast_ToggleMimicRotation final
{
public:
	bool                                          bRotate;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MimicScannerTool_NetMulticast_ToggleMimicRotation) == 0x000001, "Wrong alignment on MimicScannerTool_NetMulticast_ToggleMimicRotation");
static_assert(sizeof(MimicScannerTool_NetMulticast_ToggleMimicRotation) == 0x000001, "Wrong size on MimicScannerTool_NetMulticast_ToggleMimicRotation");
static_assert(offsetof(MimicScannerTool_NetMulticast_ToggleMimicRotation, bRotate) == 0x000000, "Member 'MimicScannerTool_NetMulticast_ToggleMimicRotation::bRotate' has a wrong offset!");

// Function DeceiveInc.MimicScannerTool.Server_ToggleMimicRotation
// 0x0001 (0x0001 - 0x0000)
struct MimicScannerTool_Server_ToggleMimicRotation final
{
public:
	bool                                          bRotate;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MimicScannerTool_Server_ToggleMimicRotation) == 0x000001, "Wrong alignment on MimicScannerTool_Server_ToggleMimicRotation");
static_assert(sizeof(MimicScannerTool_Server_ToggleMimicRotation) == 0x000001, "Wrong size on MimicScannerTool_Server_ToggleMimicRotation");
static_assert(offsetof(MimicScannerTool_Server_ToggleMimicRotation, bRotate) == 0x000000, "Member 'MimicScannerTool_Server_ToggleMimicRotation::bRotate' has a wrong offset!");

// Function DeceiveInc.MimicScannerTool.IsInMimic
// 0x0001 (0x0001 - 0x0000)
struct MimicScannerTool_IsInMimic final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MimicScannerTool_IsInMimic) == 0x000001, "Wrong alignment on MimicScannerTool_IsInMimic");
static_assert(sizeof(MimicScannerTool_IsInMimic) == 0x000001, "Wrong size on MimicScannerTool_IsInMimic");
static_assert(offsetof(MimicScannerTool_IsInMimic, ReturnValue) == 0x000000, "Member 'MimicScannerTool_IsInMimic::ReturnValue' has a wrong offset!");

// Function DeceiveInc.MirrorBotBrain.OnLocalMeleeEvent
// 0x0010 (0x0010 - 0x0000)
struct MirrorBotBrain_OnLocalMeleeEvent final
{
public:
	ESpyToolEvent                                 EventType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSpyTool*                           SpyTool;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MirrorBotBrain_OnLocalMeleeEvent) == 0x000008, "Wrong alignment on MirrorBotBrain_OnLocalMeleeEvent");
static_assert(sizeof(MirrorBotBrain_OnLocalMeleeEvent) == 0x000010, "Wrong size on MirrorBotBrain_OnLocalMeleeEvent");
static_assert(offsetof(MirrorBotBrain_OnLocalMeleeEvent, EventType) == 0x000000, "Member 'MirrorBotBrain_OnLocalMeleeEvent::EventType' has a wrong offset!");
static_assert(offsetof(MirrorBotBrain_OnLocalMeleeEvent, SpyTool) == 0x000008, "Member 'MirrorBotBrain_OnLocalMeleeEvent::SpyTool' has a wrong offset!");

// Function DeceiveInc.MirrorBotBrain.OnLocalPlayerCoverBlown
// 0x0010 (0x0010 - 0x0000)
struct MirrorBotBrain_OnLocalPlayerCoverBlown final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MirrorBotBrain_OnLocalPlayerCoverBlown) == 0x000008, "Wrong alignment on MirrorBotBrain_OnLocalPlayerCoverBlown");
static_assert(sizeof(MirrorBotBrain_OnLocalPlayerCoverBlown) == 0x000010, "Wrong size on MirrorBotBrain_OnLocalPlayerCoverBlown");
static_assert(offsetof(MirrorBotBrain_OnLocalPlayerCoverBlown, PlayerController) == 0x000000, "Member 'MirrorBotBrain_OnLocalPlayerCoverBlown::PlayerController' has a wrong offset!");
static_assert(offsetof(MirrorBotBrain_OnLocalPlayerCoverBlown, Spy) == 0x000008, "Member 'MirrorBotBrain_OnLocalPlayerCoverBlown::Spy' has a wrong offset!");

// Function DeceiveInc.MirrorBotBrain.OnLocalPlayerCoverRegainedEvent
// 0x0010 (0x0010 - 0x0000)
struct MirrorBotBrain_OnLocalPlayerCoverRegainedEvent final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MirrorBotBrain_OnLocalPlayerCoverRegainedEvent) == 0x000008, "Wrong alignment on MirrorBotBrain_OnLocalPlayerCoverRegainedEvent");
static_assert(sizeof(MirrorBotBrain_OnLocalPlayerCoverRegainedEvent) == 0x000010, "Wrong size on MirrorBotBrain_OnLocalPlayerCoverRegainedEvent");
static_assert(offsetof(MirrorBotBrain_OnLocalPlayerCoverRegainedEvent, PlayerController) == 0x000000, "Member 'MirrorBotBrain_OnLocalPlayerCoverRegainedEvent::PlayerController' has a wrong offset!");
static_assert(offsetof(MirrorBotBrain_OnLocalPlayerCoverRegainedEvent, Spy) == 0x000008, "Member 'MirrorBotBrain_OnLocalPlayerCoverRegainedEvent::Spy' has a wrong offset!");

// Function DeceiveInc.MirrorBotBrain.OnLocalWeaponEvent
// 0x0010 (0x0010 - 0x0000)
struct MirrorBotBrain_OnLocalWeaponEvent final
{
public:
	ESpyToolEvent                                 EventType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSpyTool*                           SpyTool;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MirrorBotBrain_OnLocalWeaponEvent) == 0x000008, "Wrong alignment on MirrorBotBrain_OnLocalWeaponEvent");
static_assert(sizeof(MirrorBotBrain_OnLocalWeaponEvent) == 0x000010, "Wrong size on MirrorBotBrain_OnLocalWeaponEvent");
static_assert(offsetof(MirrorBotBrain_OnLocalWeaponEvent, EventType) == 0x000000, "Member 'MirrorBotBrain_OnLocalWeaponEvent::EventType' has a wrong offset!");
static_assert(offsetof(MirrorBotBrain_OnLocalWeaponEvent, SpyTool) == 0x000008, "Member 'MirrorBotBrain_OnLocalWeaponEvent::SpyTool' has a wrong offset!");

// Function DeceiveInc.MirrorBotBrain.OnSwitchTool
// 0x0010 (0x0010 - 0x0000)
struct MirrorBotBrain_OnSwitchTool final
{
public:
	class ABaseSpyTool*                           SpyTool;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELoadoutSlot                                  Slot;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MirrorBotBrain_OnSwitchTool) == 0x000008, "Wrong alignment on MirrorBotBrain_OnSwitchTool");
static_assert(sizeof(MirrorBotBrain_OnSwitchTool) == 0x000010, "Wrong size on MirrorBotBrain_OnSwitchTool");
static_assert(offsetof(MirrorBotBrain_OnSwitchTool, SpyTool) == 0x000000, "Member 'MirrorBotBrain_OnSwitchTool::SpyTool' has a wrong offset!");
static_assert(offsetof(MirrorBotBrain_OnSwitchTool, Slot) == 0x000008, "Member 'MirrorBotBrain_OnSwitchTool::Slot' has a wrong offset!");

// Function DeceiveInc.NavModeItemComponent.EnableNavModeItem
// 0x0001 (0x0001 - 0x0000)
struct NavModeItemComponent_EnableNavModeItem final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavModeItemComponent_EnableNavModeItem) == 0x000001, "Wrong alignment on NavModeItemComponent_EnableNavModeItem");
static_assert(sizeof(NavModeItemComponent_EnableNavModeItem) == 0x000001, "Wrong size on NavModeItemComponent_EnableNavModeItem");
static_assert(offsetof(NavModeItemComponent_EnableNavModeItem, bEnable) == 0x000000, "Member 'NavModeItemComponent_EnableNavModeItem::bEnable' has a wrong offset!");

// Function DeceiveInc.NavModeItemComponent.HandleGamePhaseChanged
// 0x0001 (0x0001 - 0x0000)
struct NavModeItemComponent_HandleGamePhaseChanged final
{
public:
	ESpyGamePhase                                 NewGamePhase;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavModeItemComponent_HandleGamePhaseChanged) == 0x000001, "Wrong alignment on NavModeItemComponent_HandleGamePhaseChanged");
static_assert(sizeof(NavModeItemComponent_HandleGamePhaseChanged) == 0x000001, "Wrong size on NavModeItemComponent_HandleGamePhaseChanged");
static_assert(offsetof(NavModeItemComponent_HandleGamePhaseChanged, NewGamePhase) == 0x000000, "Member 'NavModeItemComponent_HandleGamePhaseChanged::NewGamePhase' has a wrong offset!");

// Function DeceiveInc.NavModeItemComponent.HandleOnLocalLoadoutSpawnComplete
// 0x0010 (0x0010 - 0x0000)
struct NavModeItemComponent_HandleOnLocalLoadoutSpawnComplete final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UToolLoadoutComponent*                  ToolLoadout;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavModeItemComponent_HandleOnLocalLoadoutSpawnComplete) == 0x000008, "Wrong alignment on NavModeItemComponent_HandleOnLocalLoadoutSpawnComplete");
static_assert(sizeof(NavModeItemComponent_HandleOnLocalLoadoutSpawnComplete) == 0x000010, "Wrong size on NavModeItemComponent_HandleOnLocalLoadoutSpawnComplete");
static_assert(offsetof(NavModeItemComponent_HandleOnLocalLoadoutSpawnComplete, PlayerController) == 0x000000, "Member 'NavModeItemComponent_HandleOnLocalLoadoutSpawnComplete::PlayerController' has a wrong offset!");
static_assert(offsetof(NavModeItemComponent_HandleOnLocalLoadoutSpawnComplete, ToolLoadout) == 0x000008, "Member 'NavModeItemComponent_HandleOnLocalLoadoutSpawnComplete::ToolLoadout' has a wrong offset!");

// Function DeceiveInc.NavModeItemComponent.SetNavModeItemIcon
// 0x0028 (0x0028 - 0x0000)
struct NavModeItemComponent_SetNavModeItemIcon final
{
public:
	TSoftClassPtr<class UClass>                   NewIcon;                                           // 0x0000(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavModeItemComponent_SetNavModeItemIcon) == 0x000008, "Wrong alignment on NavModeItemComponent_SetNavModeItemIcon");
static_assert(sizeof(NavModeItemComponent_SetNavModeItemIcon) == 0x000028, "Wrong size on NavModeItemComponent_SetNavModeItemIcon");
static_assert(offsetof(NavModeItemComponent_SetNavModeItemIcon, NewIcon) == 0x000000, "Member 'NavModeItemComponent_SetNavModeItemIcon::NewIcon' has a wrong offset!");

// Function DeceiveInc.NavModeItemComponent.SetNavModeItemSelected
// 0x0008 (0x0008 - 0x0000)
struct NavModeItemComponent_SetNavModeItemSelected final
{
public:
	bool                                          bHighlight;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavModeItemComponent_SetNavModeItemSelected) == 0x000004, "Wrong alignment on NavModeItemComponent_SetNavModeItemSelected");
static_assert(sizeof(NavModeItemComponent_SetNavModeItemSelected) == 0x000008, "Wrong size on NavModeItemComponent_SetNavModeItemSelected");
static_assert(offsetof(NavModeItemComponent_SetNavModeItemSelected, bHighlight) == 0x000000, "Member 'NavModeItemComponent_SetNavModeItemSelected::bHighlight' has a wrong offset!");
static_assert(offsetof(NavModeItemComponent_SetNavModeItemSelected, Duration) == 0x000004, "Member 'NavModeItemComponent_SetNavModeItemSelected::Duration' has a wrong offset!");

// Function DeceiveInc.NavModeItemComponent.SetNavModeItemShowed
// 0x0001 (0x0001 - 0x0000)
struct NavModeItemComponent_SetNavModeItemShowed final
{
public:
	bool                                          bShowed;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavModeItemComponent_SetNavModeItemShowed) == 0x000001, "Wrong alignment on NavModeItemComponent_SetNavModeItemShowed");
static_assert(sizeof(NavModeItemComponent_SetNavModeItemShowed) == 0x000001, "Wrong size on NavModeItemComponent_SetNavModeItemShowed");
static_assert(offsetof(NavModeItemComponent_SetNavModeItemShowed, bShowed) == 0x000000, "Member 'NavModeItemComponent_SetNavModeItemShowed::bShowed' has a wrong offset!");

// Function DeceiveInc.NavModeItemComponent.GetMinSquaredDistanceToUnselect
// 0x0004 (0x0004 - 0x0000)
struct NavModeItemComponent_GetMinSquaredDistanceToUnselect final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavModeItemComponent_GetMinSquaredDistanceToUnselect) == 0x000004, "Wrong alignment on NavModeItemComponent_GetMinSquaredDistanceToUnselect");
static_assert(sizeof(NavModeItemComponent_GetMinSquaredDistanceToUnselect) == 0x000004, "Wrong size on NavModeItemComponent_GetMinSquaredDistanceToUnselect");
static_assert(offsetof(NavModeItemComponent_GetMinSquaredDistanceToUnselect, ReturnValue) == 0x000000, "Member 'NavModeItemComponent_GetMinSquaredDistanceToUnselect::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NavModeItemComponent.GetNavModeItemType
// 0x0001 (0x0001 - 0x0000)
struct NavModeItemComponent_GetNavModeItemType final
{
public:
	ENavModeItemType                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavModeItemComponent_GetNavModeItemType) == 0x000001, "Wrong alignment on NavModeItemComponent_GetNavModeItemType");
static_assert(sizeof(NavModeItemComponent_GetNavModeItemType) == 0x000001, "Wrong size on NavModeItemComponent_GetNavModeItemType");
static_assert(offsetof(NavModeItemComponent_GetNavModeItemType, ReturnValue) == 0x000000, "Member 'NavModeItemComponent_GetNavModeItemType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NavModeItemComponent.GetRaycastPenetrationThreshold
// 0x0004 (0x0004 - 0x0000)
struct NavModeItemComponent_GetRaycastPenetrationThreshold final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavModeItemComponent_GetRaycastPenetrationThreshold) == 0x000004, "Wrong alignment on NavModeItemComponent_GetRaycastPenetrationThreshold");
static_assert(sizeof(NavModeItemComponent_GetRaycastPenetrationThreshold) == 0x000004, "Wrong size on NavModeItemComponent_GetRaycastPenetrationThreshold");
static_assert(offsetof(NavModeItemComponent_GetRaycastPenetrationThreshold, ReturnValue) == 0x000000, "Member 'NavModeItemComponent_GetRaycastPenetrationThreshold::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NavModeItemComponent.IsEnable
// 0x0001 (0x0001 - 0x0000)
struct NavModeItemComponent_IsEnable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavModeItemComponent_IsEnable) == 0x000001, "Wrong alignment on NavModeItemComponent_IsEnable");
static_assert(sizeof(NavModeItemComponent_IsEnable) == 0x000001, "Wrong size on NavModeItemComponent_IsEnable");
static_assert(offsetof(NavModeItemComponent_IsEnable, ReturnValue) == 0x000000, "Member 'NavModeItemComponent_IsEnable::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NavModeItemComponent.IsNavModeItemSelected
// 0x0001 (0x0001 - 0x0000)
struct NavModeItemComponent_IsNavModeItemSelected final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavModeItemComponent_IsNavModeItemSelected) == 0x000001, "Wrong alignment on NavModeItemComponent_IsNavModeItemSelected");
static_assert(sizeof(NavModeItemComponent_IsNavModeItemSelected) == 0x000001, "Wrong size on NavModeItemComponent_IsNavModeItemSelected");
static_assert(offsetof(NavModeItemComponent_IsNavModeItemSelected, ReturnValue) == 0x000000, "Member 'NavModeItemComponent_IsNavModeItemSelected::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NavModeItemComponent.IsNavModeItemShowed
// 0x0001 (0x0001 - 0x0000)
struct NavModeItemComponent_IsNavModeItemShowed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavModeItemComponent_IsNavModeItemShowed) == 0x000001, "Wrong alignment on NavModeItemComponent_IsNavModeItemShowed");
static_assert(sizeof(NavModeItemComponent_IsNavModeItemShowed) == 0x000001, "Wrong size on NavModeItemComponent_IsNavModeItemShowed");
static_assert(offsetof(NavModeItemComponent_IsNavModeItemShowed, ReturnValue) == 0x000000, "Member 'NavModeItemComponent_IsNavModeItemShowed::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NavModeItemComponent.IsShowedInCurrentPhase
// 0x0001 (0x0001 - 0x0000)
struct NavModeItemComponent_IsShowedInCurrentPhase final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavModeItemComponent_IsShowedInCurrentPhase) == 0x000001, "Wrong alignment on NavModeItemComponent_IsShowedInCurrentPhase");
static_assert(sizeof(NavModeItemComponent_IsShowedInCurrentPhase) == 0x000001, "Wrong size on NavModeItemComponent_IsShowedInCurrentPhase");
static_assert(offsetof(NavModeItemComponent_IsShowedInCurrentPhase, ReturnValue) == 0x000000, "Member 'NavModeItemComponent_IsShowedInCurrentPhase::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NavModeTool.HandleLocalSpyDeathEvent
// 0x0010 (0x0010 - 0x0000)
struct NavModeTool_HandleLocalSpyDeathEvent final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavModeTool_HandleLocalSpyDeathEvent) == 0x000008, "Wrong alignment on NavModeTool_HandleLocalSpyDeathEvent");
static_assert(sizeof(NavModeTool_HandleLocalSpyDeathEvent) == 0x000010, "Wrong size on NavModeTool_HandleLocalSpyDeathEvent");
static_assert(offsetof(NavModeTool_HandleLocalSpyDeathEvent, PlayerController) == 0x000000, "Member 'NavModeTool_HandleLocalSpyDeathEvent::PlayerController' has a wrong offset!");
static_assert(offsetof(NavModeTool_HandleLocalSpyDeathEvent, Spy) == 0x000008, "Member 'NavModeTool_HandleLocalSpyDeathEvent::Spy' has a wrong offset!");

// Function DeceiveInc.NavModeTool.HandleResourceChanged
// 0x0028 (0x0028 - 0x0000)
struct NavModeTool_HandleResourceChanged final
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ResourceDisplayName;                               // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NavModeTool_HandleResourceChanged) == 0x000008, "Wrong alignment on NavModeTool_HandleResourceChanged");
static_assert(sizeof(NavModeTool_HandleResourceChanged) == 0x000028, "Wrong size on NavModeTool_HandleResourceChanged");
static_assert(offsetof(NavModeTool_HandleResourceChanged, ResourceType) == 0x000000, "Member 'NavModeTool_HandleResourceChanged::ResourceType' has a wrong offset!");
static_assert(offsetof(NavModeTool_HandleResourceChanged, ResourceDisplayName) == 0x000008, "Member 'NavModeTool_HandleResourceChanged::ResourceDisplayName' has a wrong offset!");
static_assert(offsetof(NavModeTool_HandleResourceChanged, Amount) == 0x000020, "Member 'NavModeTool_HandleResourceChanged::Amount' has a wrong offset!");

// Function DeceiveInc.NavModeTool.Server_OnNavModeItemSelected
// 0x0008 (0x0008 - 0x0000)
struct NavModeTool_Server_OnNavModeItemSelected final
{
public:
	class UNavModeItemComponent*                  NavModeItem;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavModeTool_Server_OnNavModeItemSelected) == 0x000008, "Wrong alignment on NavModeTool_Server_OnNavModeItemSelected");
static_assert(sizeof(NavModeTool_Server_OnNavModeItemSelected) == 0x000008, "Wrong size on NavModeTool_Server_OnNavModeItemSelected");
static_assert(offsetof(NavModeTool_Server_OnNavModeItemSelected, NavModeItem) == 0x000000, "Member 'NavModeTool_Server_OnNavModeItemSelected::NavModeItem' has a wrong offset!");

// Function DeceiveInc.NavModeTool.Server_OnNavModeStateChanged
// 0x0001 (0x0001 - 0x0000)
struct NavModeTool_Server_OnNavModeStateChanged final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavModeTool_Server_OnNavModeStateChanged) == 0x000001, "Wrong alignment on NavModeTool_Server_OnNavModeStateChanged");
static_assert(sizeof(NavModeTool_Server_OnNavModeStateChanged) == 0x000001, "Wrong size on NavModeTool_Server_OnNavModeStateChanged");
static_assert(offsetof(NavModeTool_Server_OnNavModeStateChanged, bEnable) == 0x000000, "Member 'NavModeTool_Server_OnNavModeStateChanged::bEnable' has a wrong offset!");

// Function DeceiveInc.NavModeTool.GetSelectedNavModeItem
// 0x0008 (0x0008 - 0x0000)
struct NavModeTool_GetSelectedNavModeItem final
{
public:
	class UNavModeItemComponent*                  ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavModeTool_GetSelectedNavModeItem) == 0x000008, "Wrong alignment on NavModeTool_GetSelectedNavModeItem");
static_assert(sizeof(NavModeTool_GetSelectedNavModeItem) == 0x000008, "Wrong size on NavModeTool_GetSelectedNavModeItem");
static_assert(offsetof(NavModeTool_GetSelectedNavModeItem, ReturnValue) == 0x000000, "Member 'NavModeTool_GetSelectedNavModeItem::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NetworkInfoWidget.BP_OnDisplayModeChange
// 0x0001 (0x0001 - 0x0000)
struct NetworkInfoWidget_BP_OnDisplayModeChange final
{
public:
	ENetInfoDisplayMode                           NewDisplayMode;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NetworkInfoWidget_BP_OnDisplayModeChange) == 0x000001, "Wrong alignment on NetworkInfoWidget_BP_OnDisplayModeChange");
static_assert(sizeof(NetworkInfoWidget_BP_OnDisplayModeChange) == 0x000001, "Wrong size on NetworkInfoWidget_BP_OnDisplayModeChange");
static_assert(offsetof(NetworkInfoWidget_BP_OnDisplayModeChange, NewDisplayMode) == 0x000000, "Member 'NetworkInfoWidget_BP_OnDisplayModeChange::NewDisplayMode' has a wrong offset!");

// Function DeceiveInc.NetworkInfoWidget.HandleIntegerPlayerSettingChange
// 0x0008 (0x0008 - 0x0000)
struct NetworkInfoWidget_HandleIntegerPlayerSettingChange final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NewValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NetworkInfoWidget_HandleIntegerPlayerSettingChange) == 0x000004, "Wrong alignment on NetworkInfoWidget_HandleIntegerPlayerSettingChange");
static_assert(sizeof(NetworkInfoWidget_HandleIntegerPlayerSettingChange) == 0x000008, "Wrong size on NetworkInfoWidget_HandleIntegerPlayerSettingChange");
static_assert(offsetof(NetworkInfoWidget_HandleIntegerPlayerSettingChange, SettingType) == 0x000000, "Member 'NetworkInfoWidget_HandleIntegerPlayerSettingChange::SettingType' has a wrong offset!");
static_assert(offsetof(NetworkInfoWidget_HandleIntegerPlayerSettingChange, NewValue) == 0x000004, "Member 'NetworkInfoWidget_HandleIntegerPlayerSettingChange::NewValue' has a wrong offset!");

// Function DeceiveInc.NetworkInfoWidget.CanBeDisplayed
// 0x0001 (0x0001 - 0x0000)
struct NetworkInfoWidget_CanBeDisplayed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NetworkInfoWidget_CanBeDisplayed) == 0x000001, "Wrong alignment on NetworkInfoWidget_CanBeDisplayed");
static_assert(sizeof(NetworkInfoWidget_CanBeDisplayed) == 0x000001, "Wrong size on NetworkInfoWidget_CanBeDisplayed");
static_assert(offsetof(NetworkInfoWidget_CanBeDisplayed, ReturnValue) == 0x000000, "Member 'NetworkInfoWidget_CanBeDisplayed::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NetworkInfoWidget.CanDisplayRegion
// 0x0001 (0x0001 - 0x0000)
struct NetworkInfoWidget_CanDisplayRegion final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NetworkInfoWidget_CanDisplayRegion) == 0x000001, "Wrong alignment on NetworkInfoWidget_CanDisplayRegion");
static_assert(sizeof(NetworkInfoWidget_CanDisplayRegion) == 0x000001, "Wrong size on NetworkInfoWidget_CanDisplayRegion");
static_assert(offsetof(NetworkInfoWidget_CanDisplayRegion, ReturnValue) == 0x000000, "Member 'NetworkInfoWidget_CanDisplayRegion::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NetworkInfoWidget.CanDisplayServerFrameTime
// 0x0001 (0x0001 - 0x0000)
struct NetworkInfoWidget_CanDisplayServerFrameTime final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NetworkInfoWidget_CanDisplayServerFrameTime) == 0x000001, "Wrong alignment on NetworkInfoWidget_CanDisplayServerFrameTime");
static_assert(sizeof(NetworkInfoWidget_CanDisplayServerFrameTime) == 0x000001, "Wrong size on NetworkInfoWidget_CanDisplayServerFrameTime");
static_assert(offsetof(NetworkInfoWidget_CanDisplayServerFrameTime, ReturnValue) == 0x000000, "Member 'NetworkInfoWidget_CanDisplayServerFrameTime::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NetworkInfoWidget.CanDisplayServerVersion
// 0x0001 (0x0001 - 0x0000)
struct NetworkInfoWidget_CanDisplayServerVersion final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NetworkInfoWidget_CanDisplayServerVersion) == 0x000001, "Wrong alignment on NetworkInfoWidget_CanDisplayServerVersion");
static_assert(sizeof(NetworkInfoWidget_CanDisplayServerVersion) == 0x000001, "Wrong size on NetworkInfoWidget_CanDisplayServerVersion");
static_assert(offsetof(NetworkInfoWidget_CanDisplayServerVersion, ReturnValue) == 0x000000, "Member 'NetworkInfoWidget_CanDisplayServerVersion::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NetworkInfoWidget.CanDisplaySessionID
// 0x0001 (0x0001 - 0x0000)
struct NetworkInfoWidget_CanDisplaySessionID final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NetworkInfoWidget_CanDisplaySessionID) == 0x000001, "Wrong alignment on NetworkInfoWidget_CanDisplaySessionID");
static_assert(sizeof(NetworkInfoWidget_CanDisplaySessionID) == 0x000001, "Wrong size on NetworkInfoWidget_CanDisplaySessionID");
static_assert(offsetof(NetworkInfoWidget_CanDisplaySessionID, ReturnValue) == 0x000000, "Member 'NetworkInfoWidget_CanDisplaySessionID::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NetworkInfoWidget.GetDisplayMode
// 0x0001 (0x0001 - 0x0000)
struct NetworkInfoWidget_GetDisplayMode final
{
public:
	ENetInfoDisplayMode                           ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NetworkInfoWidget_GetDisplayMode) == 0x000001, "Wrong alignment on NetworkInfoWidget_GetDisplayMode");
static_assert(sizeof(NetworkInfoWidget_GetDisplayMode) == 0x000001, "Wrong size on NetworkInfoWidget_GetDisplayMode");
static_assert(offsetof(NetworkInfoWidget_GetDisplayMode, ReturnValue) == 0x000000, "Member 'NetworkInfoWidget_GetDisplayMode::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NetworkInfoWidget.GetNetworkInfo
// 0x0050 (0x0050 - 0x0000)
struct NetworkInfoWidget_GetNetworkInfo final
{
public:
	struct FDINetworkInfoData                     ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(NetworkInfoWidget_GetNetworkInfo) == 0x000008, "Wrong alignment on NetworkInfoWidget_GetNetworkInfo");
static_assert(sizeof(NetworkInfoWidget_GetNetworkInfo) == 0x000050, "Wrong size on NetworkInfoWidget_GetNetworkInfo");
static_assert(offsetof(NetworkInfoWidget_GetNetworkInfo, ReturnValue) == 0x000000, "Member 'NetworkInfoWidget_GetNetworkInfo::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NetworkInfoWidget.IsConnexionLagging
// 0x0001 (0x0001 - 0x0000)
struct NetworkInfoWidget_IsConnexionLagging final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NetworkInfoWidget_IsConnexionLagging) == 0x000001, "Wrong alignment on NetworkInfoWidget_IsConnexionLagging");
static_assert(sizeof(NetworkInfoWidget_IsConnexionLagging) == 0x000001, "Wrong size on NetworkInfoWidget_IsConnexionLagging");
static_assert(offsetof(NetworkInfoWidget_IsConnexionLagging, ReturnValue) == 0x000000, "Member 'NetworkInfoWidget_IsConnexionLagging::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NetworkInfoWidget.IsDisconnected
// 0x0001 (0x0001 - 0x0000)
struct NetworkInfoWidget_IsDisconnected final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NetworkInfoWidget_IsDisconnected) == 0x000001, "Wrong alignment on NetworkInfoWidget_IsDisconnected");
static_assert(sizeof(NetworkInfoWidget_IsDisconnected) == 0x000001, "Wrong size on NetworkInfoWidget_IsDisconnected");
static_assert(offsetof(NetworkInfoWidget_IsDisconnected, ReturnValue) == 0x000000, "Member 'NetworkInfoWidget_IsDisconnected::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NetworkInfoWidget.IsPacketLoss
// 0x0001 (0x0001 - 0x0000)
struct NetworkInfoWidget_IsPacketLoss final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NetworkInfoWidget_IsPacketLoss) == 0x000001, "Wrong alignment on NetworkInfoWidget_IsPacketLoss");
static_assert(sizeof(NetworkInfoWidget_IsPacketLoss) == 0x000001, "Wrong size on NetworkInfoWidget_IsPacketLoss");
static_assert(offsetof(NetworkInfoWidget_IsPacketLoss, ReturnValue) == 0x000000, "Member 'NetworkInfoWidget_IsPacketLoss::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NetworkInfoWidget.IsServerLagging
// 0x0001 (0x0001 - 0x0000)
struct NetworkInfoWidget_IsServerLagging final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NetworkInfoWidget_IsServerLagging) == 0x000001, "Wrong alignment on NetworkInfoWidget_IsServerLagging");
static_assert(sizeof(NetworkInfoWidget_IsServerLagging) == 0x000001, "Wrong size on NetworkInfoWidget_IsServerLagging");
static_assert(offsetof(NetworkInfoWidget_IsServerLagging, ReturnValue) == 0x000000, "Member 'NetworkInfoWidget_IsServerLagging::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCAIActor.OnGamePhaseChanged
// 0x0001 (0x0001 - 0x0000)
struct NPCAIActor_OnGamePhaseChanged final
{
public:
	ESpyGamePhase                                 NewGamePhase;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCAIActor_OnGamePhaseChanged) == 0x000001, "Wrong alignment on NPCAIActor_OnGamePhaseChanged");
static_assert(sizeof(NPCAIActor_OnGamePhaseChanged) == 0x000001, "Wrong size on NPCAIActor_OnGamePhaseChanged");
static_assert(offsetof(NPCAIActor_OnGamePhaseChanged, NewGamePhase) == 0x000000, "Member 'NPCAIActor_OnGamePhaseChanged::NewGamePhase' has a wrong offset!");

// Function DeceiveInc.NPCAIActor.OnRunningChange
// 0x0001 (0x0001 - 0x0000)
struct NPCAIActor_OnRunningChange final
{
public:
	bool                                          bRunningIn;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCAIActor_OnRunningChange) == 0x000001, "Wrong alignment on NPCAIActor_OnRunningChange");
static_assert(sizeof(NPCAIActor_OnRunningChange) == 0x000001, "Wrong size on NPCAIActor_OnRunningChange");
static_assert(offsetof(NPCAIActor_OnRunningChange, bRunningIn) == 0x000000, "Member 'NPCAIActor_OnRunningChange::bRunningIn' has a wrong offset!");

// Function DeceiveInc.NPCAIActor.OnScaredChange
// 0x0001 (0x0001 - 0x0000)
struct NPCAIActor_OnScaredChange final
{
public:
	bool                                          bScaredIn;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCAIActor_OnScaredChange) == 0x000001, "Wrong alignment on NPCAIActor_OnScaredChange");
static_assert(sizeof(NPCAIActor_OnScaredChange) == 0x000001, "Wrong size on NPCAIActor_OnScaredChange");
static_assert(offsetof(NPCAIActor_OnScaredChange, bScaredIn) == 0x000000, "Member 'NPCAIActor_OnScaredChange::bScaredIn' has a wrong offset!");

// Function DeceiveInc.NPCAIActor.OnScoldingChange
// 0x0002 (0x0002 - 0x0000)
struct NPCAIActor_OnScoldingChange final
{
public:
	EScoldState                                   PrevScoldState;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScoldState                                   ScoldState;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCAIActor_OnScoldingChange) == 0x000001, "Wrong alignment on NPCAIActor_OnScoldingChange");
static_assert(sizeof(NPCAIActor_OnScoldingChange) == 0x000002, "Wrong size on NPCAIActor_OnScoldingChange");
static_assert(offsetof(NPCAIActor_OnScoldingChange, PrevScoldState) == 0x000000, "Member 'NPCAIActor_OnScoldingChange::PrevScoldState' has a wrong offset!");
static_assert(offsetof(NPCAIActor_OnScoldingChange, ScoldState) == 0x000001, "Member 'NPCAIActor_OnScoldingChange::ScoldState' has a wrong offset!");

// Function DeceiveInc.NPCAIActor.OnStandingOnBounceMatDeflated
// 0x0008 (0x0008 - 0x0000)
struct NPCAIActor_OnStandingOnBounceMatDeflated final
{
public:
	class ABouncingMat*                           DeflatingBounceMat;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCAIActor_OnStandingOnBounceMatDeflated) == 0x000008, "Wrong alignment on NPCAIActor_OnStandingOnBounceMatDeflated");
static_assert(sizeof(NPCAIActor_OnStandingOnBounceMatDeflated) == 0x000008, "Wrong size on NPCAIActor_OnStandingOnBounceMatDeflated");
static_assert(offsetof(NPCAIActor_OnStandingOnBounceMatDeflated, DeflatingBounceMat) == 0x000000, "Member 'NPCAIActor_OnStandingOnBounceMatDeflated::DeflatingBounceMat' has a wrong offset!");

// Function DeceiveInc.NPCAIActor.GetNPCMoveStatus
// 0x0001 (0x0001 - 0x0000)
struct NPCAIActor_GetNPCMoveStatus final
{
public:
	ENPCMovementStatus                            ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCAIActor_GetNPCMoveStatus) == 0x000001, "Wrong alignment on NPCAIActor_GetNPCMoveStatus");
static_assert(sizeof(NPCAIActor_GetNPCMoveStatus) == 0x000001, "Wrong size on NPCAIActor_GetNPCMoveStatus");
static_assert(offsetof(NPCAIActor_GetNPCMoveStatus, ReturnValue) == 0x000000, "Member 'NPCAIActor_GetNPCMoveStatus::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCBehaviorFollow.OnFollowingNPCEnteredRoom
// 0x0010 (0x0010 - 0x0000)
struct NPCBehaviorFollow_OnFollowingNPCEnteredRoom final
{
public:
	class ANPCCharacter*                          FollowingNPC;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARoomVolume*                            EnteredRoom;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBehaviorFollow_OnFollowingNPCEnteredRoom) == 0x000008, "Wrong alignment on NPCBehaviorFollow_OnFollowingNPCEnteredRoom");
static_assert(sizeof(NPCBehaviorFollow_OnFollowingNPCEnteredRoom) == 0x000010, "Wrong size on NPCBehaviorFollow_OnFollowingNPCEnteredRoom");
static_assert(offsetof(NPCBehaviorFollow_OnFollowingNPCEnteredRoom, FollowingNPC) == 0x000000, "Member 'NPCBehaviorFollow_OnFollowingNPCEnteredRoom::FollowingNPC' has a wrong offset!");
static_assert(offsetof(NPCBehaviorFollow_OnFollowingNPCEnteredRoom, EnteredRoom) == 0x000008, "Member 'NPCBehaviorFollow_OnFollowingNPCEnteredRoom::EnteredRoom' has a wrong offset!");

// Function DeceiveInc.NPCBugSpawnerWeapon.HandleCoverSwitch
// 0x0008 (0x0008 - 0x0000)
struct NPCBugSpawnerWeapon_HandleCoverSwitch final
{
public:
	class ANPCCharacter*                          Disguise;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBugSpawnerWeapon_HandleCoverSwitch) == 0x000008, "Wrong alignment on NPCBugSpawnerWeapon_HandleCoverSwitch");
static_assert(sizeof(NPCBugSpawnerWeapon_HandleCoverSwitch) == 0x000008, "Wrong size on NPCBugSpawnerWeapon_HandleCoverSwitch");
static_assert(offsetof(NPCBugSpawnerWeapon_HandleCoverSwitch, Disguise) == 0x000000, "Member 'NPCBugSpawnerWeapon_HandleCoverSwitch::Disguise' has a wrong offset!");

// Function DeceiveInc.NPCBugSpawnerWeapon.HandleOwnerTookDamage
// 0x0048 (0x0048 - 0x0000)
struct NPCBugSpawnerWeapon_HandleOwnerTookDamage final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHealthComponent*                       SpyHealthComp;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthDelta;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDamageType*                      DamageType;                                        // 0x0020(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DamageDirection;                                   // 0x0038(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NPCBugSpawnerWeapon_HandleOwnerTookDamage) == 0x000008, "Wrong alignment on NPCBugSpawnerWeapon_HandleOwnerTookDamage");
static_assert(sizeof(NPCBugSpawnerWeapon_HandleOwnerTookDamage) == 0x000048, "Wrong size on NPCBugSpawnerWeapon_HandleOwnerTookDamage");
static_assert(offsetof(NPCBugSpawnerWeapon_HandleOwnerTookDamage, PlayerController) == 0x000000, "Member 'NPCBugSpawnerWeapon_HandleOwnerTookDamage::PlayerController' has a wrong offset!");
static_assert(offsetof(NPCBugSpawnerWeapon_HandleOwnerTookDamage, Spy) == 0x000008, "Member 'NPCBugSpawnerWeapon_HandleOwnerTookDamage::Spy' has a wrong offset!");
static_assert(offsetof(NPCBugSpawnerWeapon_HandleOwnerTookDamage, SpyHealthComp) == 0x000010, "Member 'NPCBugSpawnerWeapon_HandleOwnerTookDamage::SpyHealthComp' has a wrong offset!");
static_assert(offsetof(NPCBugSpawnerWeapon_HandleOwnerTookDamage, Health) == 0x000018, "Member 'NPCBugSpawnerWeapon_HandleOwnerTookDamage::Health' has a wrong offset!");
static_assert(offsetof(NPCBugSpawnerWeapon_HandleOwnerTookDamage, HealthDelta) == 0x00001C, "Member 'NPCBugSpawnerWeapon_HandleOwnerTookDamage::HealthDelta' has a wrong offset!");
static_assert(offsetof(NPCBugSpawnerWeapon_HandleOwnerTookDamage, DamageType) == 0x000020, "Member 'NPCBugSpawnerWeapon_HandleOwnerTookDamage::DamageType' has a wrong offset!");
static_assert(offsetof(NPCBugSpawnerWeapon_HandleOwnerTookDamage, InstigatedBy) == 0x000028, "Member 'NPCBugSpawnerWeapon_HandleOwnerTookDamage::InstigatedBy' has a wrong offset!");
static_assert(offsetof(NPCBugSpawnerWeapon_HandleOwnerTookDamage, DamageCauser) == 0x000030, "Member 'NPCBugSpawnerWeapon_HandleOwnerTookDamage::DamageCauser' has a wrong offset!");
static_assert(offsetof(NPCBugSpawnerWeapon_HandleOwnerTookDamage, DamageDirection) == 0x000038, "Member 'NPCBugSpawnerWeapon_HandleOwnerTookDamage::DamageDirection' has a wrong offset!");

// Function DeceiveInc.NPCBugSpawnerWeapon.HandleProjectileImpact
// 0x0050 (0x0050 - 0x0000)
struct NPCBugSpawnerWeapon_HandleProjectileImpact final
{
public:
	struct FWeaponImpactData                      WeaponInpactData;                                  // 0x0000(0x0050)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBugSpawnerWeapon_HandleProjectileImpact) == 0x000008, "Wrong alignment on NPCBugSpawnerWeapon_HandleProjectileImpact");
static_assert(sizeof(NPCBugSpawnerWeapon_HandleProjectileImpact) == 0x000050, "Wrong size on NPCBugSpawnerWeapon_HandleProjectileImpact");
static_assert(offsetof(NPCBugSpawnerWeapon_HandleProjectileImpact, WeaponInpactData) == 0x000000, "Member 'NPCBugSpawnerWeapon_HandleProjectileImpact::WeaponInpactData' has a wrong offset!");

// Function DeceiveInc.NPCBugSpawnerWeapon.HandleSimulateLocalFireShot
// 0x0028 (0x0028 - 0x0000)
struct NPCBugSpawnerWeapon_HandleSimulateLocalFireShot final
{
public:
	class AProjectileWeapon*                      Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginPos;                                         // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DestinationPos;                                    // 0x0014(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoDamage;                                         // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMissingShot;                                      // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NPCBugSpawnerWeapon_HandleSimulateLocalFireShot) == 0x000008, "Wrong alignment on NPCBugSpawnerWeapon_HandleSimulateLocalFireShot");
static_assert(sizeof(NPCBugSpawnerWeapon_HandleSimulateLocalFireShot) == 0x000028, "Wrong size on NPCBugSpawnerWeapon_HandleSimulateLocalFireShot");
static_assert(offsetof(NPCBugSpawnerWeapon_HandleSimulateLocalFireShot, Weapon) == 0x000000, "Member 'NPCBugSpawnerWeapon_HandleSimulateLocalFireShot::Weapon' has a wrong offset!");
static_assert(offsetof(NPCBugSpawnerWeapon_HandleSimulateLocalFireShot, OriginPos) == 0x000008, "Member 'NPCBugSpawnerWeapon_HandleSimulateLocalFireShot::OriginPos' has a wrong offset!");
static_assert(offsetof(NPCBugSpawnerWeapon_HandleSimulateLocalFireShot, DestinationPos) == 0x000014, "Member 'NPCBugSpawnerWeapon_HandleSimulateLocalFireShot::DestinationPos' has a wrong offset!");
static_assert(offsetof(NPCBugSpawnerWeapon_HandleSimulateLocalFireShot, bDoDamage) == 0x000020, "Member 'NPCBugSpawnerWeapon_HandleSimulateLocalFireShot::bDoDamage' has a wrong offset!");
static_assert(offsetof(NPCBugSpawnerWeapon_HandleSimulateLocalFireShot, bMissingShot) == 0x000021, "Member 'NPCBugSpawnerWeapon_HandleSimulateLocalFireShot::bMissingShot' has a wrong offset!");

// Function DeceiveInc.NPCBugSpawnerWeapon.HandleSpyMovementEvent
// 0x0018 (0x0018 - 0x0000)
struct NPCBugSpawnerWeapon_HandleSpyMovementEvent final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementEventType                            MovementEventType;                                 // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NPCBugSpawnerWeapon_HandleSpyMovementEvent) == 0x000008, "Wrong alignment on NPCBugSpawnerWeapon_HandleSpyMovementEvent");
static_assert(sizeof(NPCBugSpawnerWeapon_HandleSpyMovementEvent) == 0x000018, "Wrong size on NPCBugSpawnerWeapon_HandleSpyMovementEvent");
static_assert(offsetof(NPCBugSpawnerWeapon_HandleSpyMovementEvent, PlayerController) == 0x000000, "Member 'NPCBugSpawnerWeapon_HandleSpyMovementEvent::PlayerController' has a wrong offset!");
static_assert(offsetof(NPCBugSpawnerWeapon_HandleSpyMovementEvent, Spy) == 0x000008, "Member 'NPCBugSpawnerWeapon_HandleSpyMovementEvent::Spy' has a wrong offset!");
static_assert(offsetof(NPCBugSpawnerWeapon_HandleSpyMovementEvent, MovementEventType) == 0x000010, "Member 'NPCBugSpawnerWeapon_HandleSpyMovementEvent::MovementEventType' has a wrong offset!");

// Function DeceiveInc.NPCBugSpawnerWeapon.HandleSpyToolEvent
// 0x0010 (0x0010 - 0x0000)
struct NPCBugSpawnerWeapon_HandleSpyToolEvent final
{
public:
	ESpyToolEvent                                 EventType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSpyTool*                           SpyTool;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBugSpawnerWeapon_HandleSpyToolEvent) == 0x000008, "Wrong alignment on NPCBugSpawnerWeapon_HandleSpyToolEvent");
static_assert(sizeof(NPCBugSpawnerWeapon_HandleSpyToolEvent) == 0x000010, "Wrong size on NPCBugSpawnerWeapon_HandleSpyToolEvent");
static_assert(offsetof(NPCBugSpawnerWeapon_HandleSpyToolEvent, EventType) == 0x000000, "Member 'NPCBugSpawnerWeapon_HandleSpyToolEvent::EventType' has a wrong offset!");
static_assert(offsetof(NPCBugSpawnerWeapon_HandleSpyToolEvent, SpyTool) == 0x000008, "Member 'NPCBugSpawnerWeapon_HandleSpyToolEvent::SpyTool' has a wrong offset!");

// Function DeceiveInc.NPCBugSpawnerWeapon.Server_HandleProjectileImpactOnClient
// 0x0060 (0x0060 - 0x0000)
struct NPCBugSpawnerWeapon_Server_HandleProjectileImpactOnClient final
{
public:
	struct FWeaponImpactData                      WeaponImpactData;                                  // 0x0000(0x0050)(ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    RelativePosition;                                  // 0x0050(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NPCBugSpawnerWeapon_Server_HandleProjectileImpactOnClient) == 0x000008, "Wrong alignment on NPCBugSpawnerWeapon_Server_HandleProjectileImpactOnClient");
static_assert(sizeof(NPCBugSpawnerWeapon_Server_HandleProjectileImpactOnClient) == 0x000060, "Wrong size on NPCBugSpawnerWeapon_Server_HandleProjectileImpactOnClient");
static_assert(offsetof(NPCBugSpawnerWeapon_Server_HandleProjectileImpactOnClient, WeaponImpactData) == 0x000000, "Member 'NPCBugSpawnerWeapon_Server_HandleProjectileImpactOnClient::WeaponImpactData' has a wrong offset!");
static_assert(offsetof(NPCBugSpawnerWeapon_Server_HandleProjectileImpactOnClient, RelativePosition) == 0x000050, "Member 'NPCBugSpawnerWeapon_Server_HandleProjectileImpactOnClient::RelativePosition' has a wrong offset!");

// Function DeceiveInc.NPCGuardComponent.FOnLoSChange
// 0x0010 (0x0010 - 0x0000)
struct NPCGuardComponent_FOnLoSChange final
{
public:
	class AActor*                                 AffectedActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSeen;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NPCGuardComponent_FOnLoSChange) == 0x000008, "Wrong alignment on NPCGuardComponent_FOnLoSChange");
static_assert(sizeof(NPCGuardComponent_FOnLoSChange) == 0x000010, "Wrong size on NPCGuardComponent_FOnLoSChange");
static_assert(offsetof(NPCGuardComponent_FOnLoSChange, AffectedActor) == 0x000000, "Member 'NPCGuardComponent_FOnLoSChange::AffectedActor' has a wrong offset!");
static_assert(offsetof(NPCGuardComponent_FOnLoSChange, bIsSeen) == 0x000008, "Member 'NPCGuardComponent_FOnLoSChange::bIsSeen' has a wrong offset!");

// Function DeceiveInc.NPCGuardComponent.NetMulticast_OnKillSpy
// 0x0008 (0x0008 - 0x0000)
struct NPCGuardComponent_NetMulticast_OnKillSpy final
{
public:
	class ASpy*                                   KilledSpy;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCGuardComponent_NetMulticast_OnKillSpy) == 0x000008, "Wrong alignment on NPCGuardComponent_NetMulticast_OnKillSpy");
static_assert(sizeof(NPCGuardComponent_NetMulticast_OnKillSpy) == 0x000008, "Wrong size on NPCGuardComponent_NetMulticast_OnKillSpy");
static_assert(offsetof(NPCGuardComponent_NetMulticast_OnKillSpy, KilledSpy) == 0x000000, "Member 'NPCGuardComponent_NetMulticast_OnKillSpy::KilledSpy' has a wrong offset!");

// Function DeceiveInc.NPCGuardComponent.OnKillSpyNotify
// 0x0008 (0x0008 - 0x0000)
struct NPCGuardComponent_OnKillSpyNotify final
{
public:
	class ASpy*                                   KilledSpy;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCGuardComponent_OnKillSpyNotify) == 0x000008, "Wrong alignment on NPCGuardComponent_OnKillSpyNotify");
static_assert(sizeof(NPCGuardComponent_OnKillSpyNotify) == 0x000008, "Wrong size on NPCGuardComponent_OnKillSpyNotify");
static_assert(offsetof(NPCGuardComponent_OnKillSpyNotify, KilledSpy) == 0x000000, "Member 'NPCGuardComponent_OnKillSpyNotify::KilledSpy' has a wrong offset!");

// Function DeceiveInc.NPCGuardComponent.OnRep_AggroTargetActor
// 0x0008 (0x0008 - 0x0000)
struct NPCGuardComponent_OnRep_AggroTargetActor final
{
public:
	class AActor*                                 PrevAggroTarget;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCGuardComponent_OnRep_AggroTargetActor) == 0x000008, "Wrong alignment on NPCGuardComponent_OnRep_AggroTargetActor");
static_assert(sizeof(NPCGuardComponent_OnRep_AggroTargetActor) == 0x000008, "Wrong size on NPCGuardComponent_OnRep_AggroTargetActor");
static_assert(offsetof(NPCGuardComponent_OnRep_AggroTargetActor, PrevAggroTarget) == 0x000000, "Member 'NPCGuardComponent_OnRep_AggroTargetActor::PrevAggroTarget' has a wrong offset!");

// Function DeceiveInc.NPCGuardComponent.OnRep_InvestigationType
// 0x0001 (0x0001 - 0x0000)
struct NPCGuardComponent_OnRep_InvestigationType final
{
public:
	EInvestigationType                            PrevType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCGuardComponent_OnRep_InvestigationType) == 0x000001, "Wrong alignment on NPCGuardComponent_OnRep_InvestigationType");
static_assert(sizeof(NPCGuardComponent_OnRep_InvestigationType) == 0x000001, "Wrong size on NPCGuardComponent_OnRep_InvestigationType");
static_assert(offsetof(NPCGuardComponent_OnRep_InvestigationType, PrevType) == 0x000000, "Member 'NPCGuardComponent_OnRep_InvestigationType::PrevType' has a wrong offset!");

// Function DeceiveInc.NPCGuardComponent.OnRep_RotationAnimationType
// 0x0001 (0x0001 - 0x0000)
struct NPCGuardComponent_OnRep_RotationAnimationType final
{
public:
	ERotationAnimationType                        PrevType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCGuardComponent_OnRep_RotationAnimationType) == 0x000001, "Wrong alignment on NPCGuardComponent_OnRep_RotationAnimationType");
static_assert(sizeof(NPCGuardComponent_OnRep_RotationAnimationType) == 0x000001, "Wrong size on NPCGuardComponent_OnRep_RotationAnimationType");
static_assert(offsetof(NPCGuardComponent_OnRep_RotationAnimationType, PrevType) == 0x000000, "Member 'NPCGuardComponent_OnRep_RotationAnimationType::PrevType' has a wrong offset!");

// Function DeceiveInc.NPCGuardComponent.OnRep_WeaponChanged
// 0x0008 (0x0008 - 0x0000)
struct NPCGuardComponent_OnRep_WeaponChanged final
{
public:
	class AHitscanWeapon*                         OldWeapon;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCGuardComponent_OnRep_WeaponChanged) == 0x000008, "Wrong alignment on NPCGuardComponent_OnRep_WeaponChanged");
static_assert(sizeof(NPCGuardComponent_OnRep_WeaponChanged) == 0x000008, "Wrong size on NPCGuardComponent_OnRep_WeaponChanged");
static_assert(offsetof(NPCGuardComponent_OnRep_WeaponChanged, OldWeapon) == 0x000000, "Member 'NPCGuardComponent_OnRep_WeaponChanged::OldWeapon' has a wrong offset!");

// Function DeceiveInc.NPCGuardComponent.OnVisibilityChanged
// 0x0001 (0x0001 - 0x0000)
struct NPCGuardComponent_OnVisibilityChanged final
{
public:
	bool                                          bIsVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCGuardComponent_OnVisibilityChanged) == 0x000001, "Wrong alignment on NPCGuardComponent_OnVisibilityChanged");
static_assert(sizeof(NPCGuardComponent_OnVisibilityChanged) == 0x000001, "Wrong size on NPCGuardComponent_OnVisibilityChanged");
static_assert(offsetof(NPCGuardComponent_OnVisibilityChanged, bIsVisible) == 0x000000, "Member 'NPCGuardComponent_OnVisibilityChanged::bIsVisible' has a wrong offset!");

// Function DeceiveInc.NPCGuardComponent.ShowWeaponFromAnimation
// 0x0001 (0x0001 - 0x0000)
struct NPCGuardComponent_ShowWeaponFromAnimation final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCGuardComponent_ShowWeaponFromAnimation) == 0x000001, "Wrong alignment on NPCGuardComponent_ShowWeaponFromAnimation");
static_assert(sizeof(NPCGuardComponent_ShowWeaponFromAnimation) == 0x000001, "Wrong size on NPCGuardComponent_ShowWeaponFromAnimation");
static_assert(offsetof(NPCGuardComponent_ShowWeaponFromAnimation, bShow) == 0x000000, "Member 'NPCGuardComponent_ShowWeaponFromAnimation::bShow' has a wrong offset!");

// Function DeceiveInc.NPCGuardComponent.GetInvestigationType
// 0x0001 (0x0001 - 0x0000)
struct NPCGuardComponent_GetInvestigationType final
{
public:
	EInvestigationType                            ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCGuardComponent_GetInvestigationType) == 0x000001, "Wrong alignment on NPCGuardComponent_GetInvestigationType");
static_assert(sizeof(NPCGuardComponent_GetInvestigationType) == 0x000001, "Wrong size on NPCGuardComponent_GetInvestigationType");
static_assert(offsetof(NPCGuardComponent_GetInvestigationType, ReturnValue) == 0x000000, "Member 'NPCGuardComponent_GetInvestigationType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.NPCGuardComponent.IsAggroed
// 0x0001 (0x0001 - 0x0000)
struct NPCGuardComponent_IsAggroed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCGuardComponent_IsAggroed) == 0x000001, "Wrong alignment on NPCGuardComponent_IsAggroed");
static_assert(sizeof(NPCGuardComponent_IsAggroed) == 0x000001, "Wrong size on NPCGuardComponent_IsAggroed");
static_assert(offsetof(NPCGuardComponent_IsAggroed, ReturnValue) == 0x000000, "Member 'NPCGuardComponent_IsAggroed::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ObjectSpawn.UpdateConnectedRoomsReference
// 0x0008 (0x0008 - 0x0000)
struct ObjectSpawn_UpdateConnectedRoomsReference final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ObjectSpawn_UpdateConnectedRoomsReference) == 0x000008, "Wrong alignment on ObjectSpawn_UpdateConnectedRoomsReference");
static_assert(sizeof(ObjectSpawn_UpdateConnectedRoomsReference) == 0x000008, "Wrong size on ObjectSpawn_UpdateConnectedRoomsReference");
static_assert(offsetof(ObjectSpawn_UpdateConnectedRoomsReference, World) == 0x000000, "Member 'ObjectSpawn_UpdateConnectedRoomsReference::World' has a wrong offset!");

// Function DeceiveInc.ObjectSpawn.GetSpawnedObject
// 0x0008 (0x0008 - 0x0000)
struct ObjectSpawn_GetSpawnedObject final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ObjectSpawn_GetSpawnedObject) == 0x000008, "Wrong alignment on ObjectSpawn_GetSpawnedObject");
static_assert(sizeof(ObjectSpawn_GetSpawnedObject) == 0x000008, "Wrong size on ObjectSpawn_GetSpawnedObject");
static_assert(offsetof(ObjectSpawn_GetSpawnedObject, ReturnValue) == 0x000000, "Member 'ObjectSpawn_GetSpawnedObject::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ObjectSpawningManager.Get
// 0x0010 (0x0010 - 0x0000)
struct ObjectSpawningManager_Get final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AObjectSpawningManager*                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ObjectSpawningManager_Get) == 0x000008, "Wrong alignment on ObjectSpawningManager_Get");
static_assert(sizeof(ObjectSpawningManager_Get) == 0x000010, "Wrong size on ObjectSpawningManager_Get");
static_assert(offsetof(ObjectSpawningManager_Get, World) == 0x000000, "Member 'ObjectSpawningManager_Get::World' has a wrong offset!");
static_assert(offsetof(ObjectSpawningManager_Get, ReturnValue) == 0x000008, "Member 'ObjectSpawningManager_Get::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ObjectSpawningManager.GetObjectSpawnPresetsData
// 0x0008 (0x0008 - 0x0000)
struct ObjectSpawningManager_GetObjectSpawnPresetsData final
{
public:
	class UDIObjectSpawnPresetsDataAsset*         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ObjectSpawningManager_GetObjectSpawnPresetsData) == 0x000008, "Wrong alignment on ObjectSpawningManager_GetObjectSpawnPresetsData");
static_assert(sizeof(ObjectSpawningManager_GetObjectSpawnPresetsData) == 0x000008, "Wrong size on ObjectSpawningManager_GetObjectSpawnPresetsData");
static_assert(offsetof(ObjectSpawningManager_GetObjectSpawnPresetsData, ReturnValue) == 0x000000, "Member 'ObjectSpawningManager_GetObjectSpawnPresetsData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ObjectSpawningManager.GetObjectsToSpawnCountData
// 0x0008 (0x0008 - 0x0000)
struct ObjectSpawningManager_GetObjectsToSpawnCountData final
{
public:
	class UDIObjectsToSpawnCountDataAsset*        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ObjectSpawningManager_GetObjectsToSpawnCountData) == 0x000008, "Wrong alignment on ObjectSpawningManager_GetObjectsToSpawnCountData");
static_assert(sizeof(ObjectSpawningManager_GetObjectsToSpawnCountData) == 0x000008, "Wrong size on ObjectSpawningManager_GetObjectsToSpawnCountData");
static_assert(offsetof(ObjectSpawningManager_GetObjectsToSpawnCountData, ReturnValue) == 0x000000, "Member 'ObjectSpawningManager_GetObjectsToSpawnCountData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ObjectSpawningManager.GetObjectsToSpawnData
// 0x0008 (0x0008 - 0x0000)
struct ObjectSpawningManager_GetObjectsToSpawnData final
{
public:
	class UDIObjectsToSpawnDataAsset*             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ObjectSpawningManager_GetObjectsToSpawnData) == 0x000008, "Wrong alignment on ObjectSpawningManager_GetObjectsToSpawnData");
static_assert(sizeof(ObjectSpawningManager_GetObjectsToSpawnData) == 0x000008, "Wrong size on ObjectSpawningManager_GetObjectsToSpawnData");
static_assert(offsetof(ObjectSpawningManager_GetObjectsToSpawnData, ReturnValue) == 0x000000, "Member 'ObjectSpawningManager_GetObjectsToSpawnData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ObjectSpawningManager.HandleAllRoomsSetup
// 0x0008 (0x0008 - 0x0000)
struct ObjectSpawningManager_HandleAllRoomsSetup final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ObjectSpawningManager_HandleAllRoomsSetup) == 0x000008, "Wrong alignment on ObjectSpawningManager_HandleAllRoomsSetup");
static_assert(sizeof(ObjectSpawningManager_HandleAllRoomsSetup) == 0x000008, "Wrong size on ObjectSpawningManager_HandleAllRoomsSetup");
static_assert(offsetof(ObjectSpawningManager_HandleAllRoomsSetup, World) == 0x000000, "Member 'ObjectSpawningManager_HandleAllRoomsSetup::World' has a wrong offset!");

// Function DeceiveInc.ThrowableWeapon.OnSpyToolEvent
// 0x0010 (0x0010 - 0x0000)
struct ThrowableWeapon_OnSpyToolEvent final
{
public:
	ESpyToolEvent                                 EventType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSpyTool*                           SpyTool;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ThrowableWeapon_OnSpyToolEvent) == 0x000008, "Wrong alignment on ThrowableWeapon_OnSpyToolEvent");
static_assert(sizeof(ThrowableWeapon_OnSpyToolEvent) == 0x000010, "Wrong size on ThrowableWeapon_OnSpyToolEvent");
static_assert(offsetof(ThrowableWeapon_OnSpyToolEvent, EventType) == 0x000000, "Member 'ThrowableWeapon_OnSpyToolEvent::EventType' has a wrong offset!");
static_assert(offsetof(ThrowableWeapon_OnSpyToolEvent, SpyTool) == 0x000008, "Member 'ThrowableWeapon_OnSpyToolEvent::SpyTool' has a wrong offset!");

// Function DeceiveInc.ThrowableWeapon.ReloadThrowProjectile
// 0x000C (0x000C - 0x0000)
struct ThrowableWeapon_ReloadThrowProjectile final
{
public:
	struct FVector_NetQuantize                    DestinationPos;                                    // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ThrowableWeapon_ReloadThrowProjectile) == 0x000004, "Wrong alignment on ThrowableWeapon_ReloadThrowProjectile");
static_assert(sizeof(ThrowableWeapon_ReloadThrowProjectile) == 0x00000C, "Wrong size on ThrowableWeapon_ReloadThrowProjectile");
static_assert(offsetof(ThrowableWeapon_ReloadThrowProjectile, DestinationPos) == 0x000000, "Member 'ThrowableWeapon_ReloadThrowProjectile::DestinationPos' has a wrong offset!");

// Function DeceiveInc.ThrowableWeapon.ShouldReloadThrow
// 0x0001 (0x0001 - 0x0000)
struct ThrowableWeapon_ShouldReloadThrow final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ThrowableWeapon_ShouldReloadThrow) == 0x000001, "Wrong alignment on ThrowableWeapon_ShouldReloadThrow");
static_assert(sizeof(ThrowableWeapon_ShouldReloadThrow) == 0x000001, "Wrong size on ThrowableWeapon_ShouldReloadThrow");
static_assert(offsetof(ThrowableWeapon_ShouldReloadThrow, ReturnValue) == 0x000000, "Member 'ThrowableWeapon_ShouldReloadThrow::ReturnValue' has a wrong offset!");

// Function DeceiveInc.OctoActiveAbilityMod2.OnSeenSpyUndercoverChanged
// 0x0001 (0x0001 - 0x0000)
struct OctoActiveAbilityMod2_OnSeenSpyUndercoverChanged final
{
public:
	bool                                          bUndercover;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OctoActiveAbilityMod2_OnSeenSpyUndercoverChanged) == 0x000001, "Wrong alignment on OctoActiveAbilityMod2_OnSeenSpyUndercoverChanged");
static_assert(sizeof(OctoActiveAbilityMod2_OnSeenSpyUndercoverChanged) == 0x000001, "Wrong size on OctoActiveAbilityMod2_OnSeenSpyUndercoverChanged");
static_assert(offsetof(OctoActiveAbilityMod2_OnSeenSpyUndercoverChanged, bUndercover) == 0x000000, "Member 'OctoActiveAbilityMod2_OnSeenSpyUndercoverChanged::bUndercover' has a wrong offset!");

// Function DeceiveInc.OctoActiveAbilityMod2.Server_SpySeenChange
// 0x0010 (0x0010 - 0x0000)
struct OctoActiveAbilityMod2_Server_SpySeenChange final
{
public:
	class ASpy*                                   SpyIn;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSeenIn;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OctoActiveAbilityMod2_Server_SpySeenChange) == 0x000008, "Wrong alignment on OctoActiveAbilityMod2_Server_SpySeenChange");
static_assert(sizeof(OctoActiveAbilityMod2_Server_SpySeenChange) == 0x000010, "Wrong size on OctoActiveAbilityMod2_Server_SpySeenChange");
static_assert(offsetof(OctoActiveAbilityMod2_Server_SpySeenChange, SpyIn) == 0x000000, "Member 'OctoActiveAbilityMod2_Server_SpySeenChange::SpyIn' has a wrong offset!");
static_assert(offsetof(OctoActiveAbilityMod2_Server_SpySeenChange, bSeenIn) == 0x000008, "Member 'OctoActiveAbilityMod2_Server_SpySeenChange::bSeenIn' has a wrong offset!");

// Function DeceiveInc.OctoIntelDrainZoneVisualFeedback.GetIntelActor
// 0x0008 (0x0008 - 0x0000)
struct OctoIntelDrainZoneVisualFeedback_GetIntelActor final
{
public:
	class ABaseIntelActor*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OctoIntelDrainZoneVisualFeedback_GetIntelActor) == 0x000008, "Wrong alignment on OctoIntelDrainZoneVisualFeedback_GetIntelActor");
static_assert(sizeof(OctoIntelDrainZoneVisualFeedback_GetIntelActor) == 0x000008, "Wrong size on OctoIntelDrainZoneVisualFeedback_GetIntelActor");
static_assert(offsetof(OctoIntelDrainZoneVisualFeedback_GetIntelActor, ReturnValue) == 0x000000, "Member 'OctoIntelDrainZoneVisualFeedback_GetIntelActor::ReturnValue' has a wrong offset!");

// Function DeceiveInc.OctoIntelDrainZoneVisualFeedback.GetRefCount
// 0x0004 (0x0004 - 0x0000)
struct OctoIntelDrainZoneVisualFeedback_GetRefCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OctoIntelDrainZoneVisualFeedback_GetRefCount) == 0x000004, "Wrong alignment on OctoIntelDrainZoneVisualFeedback_GetRefCount");
static_assert(sizeof(OctoIntelDrainZoneVisualFeedback_GetRefCount) == 0x000004, "Wrong size on OctoIntelDrainZoneVisualFeedback_GetRefCount");
static_assert(offsetof(OctoIntelDrainZoneVisualFeedback_GetRefCount, ReturnValue) == 0x000000, "Member 'OctoIntelDrainZoneVisualFeedback_GetRefCount::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PlayerBPLibrary.GetHUDPlayerSpy
// 0x0010 (0x0010 - 0x0000)
struct PlayerBPLibrary_GetHUDPlayerSpy final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerBPLibrary_GetHUDPlayerSpy) == 0x000008, "Wrong alignment on PlayerBPLibrary_GetHUDPlayerSpy");
static_assert(sizeof(PlayerBPLibrary_GetHUDPlayerSpy) == 0x000010, "Wrong size on PlayerBPLibrary_GetHUDPlayerSpy");
static_assert(offsetof(PlayerBPLibrary_GetHUDPlayerSpy, WorldContextObject) == 0x000000, "Member 'PlayerBPLibrary_GetHUDPlayerSpy::WorldContextObject' has a wrong offset!");
static_assert(offsetof(PlayerBPLibrary_GetHUDPlayerSpy, ReturnValue) == 0x000008, "Member 'PlayerBPLibrary_GetHUDPlayerSpy::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PlayerBPLibrary.GetWatchingPlayerDisguiseMesh
// 0x0010 (0x0010 - 0x0000)
struct PlayerBPLibrary_GetWatchingPlayerDisguiseMesh final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerBPLibrary_GetWatchingPlayerDisguiseMesh) == 0x000008, "Wrong alignment on PlayerBPLibrary_GetWatchingPlayerDisguiseMesh");
static_assert(sizeof(PlayerBPLibrary_GetWatchingPlayerDisguiseMesh) == 0x000010, "Wrong size on PlayerBPLibrary_GetWatchingPlayerDisguiseMesh");
static_assert(offsetof(PlayerBPLibrary_GetWatchingPlayerDisguiseMesh, WorldContextObject) == 0x000000, "Member 'PlayerBPLibrary_GetWatchingPlayerDisguiseMesh::WorldContextObject' has a wrong offset!");
static_assert(offsetof(PlayerBPLibrary_GetWatchingPlayerDisguiseMesh, ReturnValue) == 0x000008, "Member 'PlayerBPLibrary_GetWatchingPlayerDisguiseMesh::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PlayerBPLibrary.GetWatchingPlayerSpy
// 0x0010 (0x0010 - 0x0000)
struct PlayerBPLibrary_GetWatchingPlayerSpy final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerBPLibrary_GetWatchingPlayerSpy) == 0x000008, "Wrong alignment on PlayerBPLibrary_GetWatchingPlayerSpy");
static_assert(sizeof(PlayerBPLibrary_GetWatchingPlayerSpy) == 0x000010, "Wrong size on PlayerBPLibrary_GetWatchingPlayerSpy");
static_assert(offsetof(PlayerBPLibrary_GetWatchingPlayerSpy, WorldContextObject) == 0x000000, "Member 'PlayerBPLibrary_GetWatchingPlayerSpy::WorldContextObject' has a wrong offset!");
static_assert(offsetof(PlayerBPLibrary_GetWatchingPlayerSpy, ReturnValue) == 0x000008, "Member 'PlayerBPLibrary_GetWatchingPlayerSpy::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PlayerBPLibrary.IsSpectating
// 0x0010 (0x0010 - 0x0000)
struct PlayerBPLibrary_IsSpectating final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerBPLibrary_IsSpectating) == 0x000008, "Wrong alignment on PlayerBPLibrary_IsSpectating");
static_assert(sizeof(PlayerBPLibrary_IsSpectating) == 0x000010, "Wrong size on PlayerBPLibrary_IsSpectating");
static_assert(offsetof(PlayerBPLibrary_IsSpectating, WorldContextObject) == 0x000000, "Member 'PlayerBPLibrary_IsSpectating::WorldContextObject' has a wrong offset!");
static_assert(offsetof(PlayerBPLibrary_IsSpectating, ReturnValue) == 0x000008, "Member 'PlayerBPLibrary_IsSpectating::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PlayerTalkingWidget.BP_OnPlayerChange
// 0x0010 (0x0010 - 0x0000)
struct PlayerTalkingWidget_BP_OnPlayerChange final
{
public:
	class FString                                 NewPlayerName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerTalkingWidget_BP_OnPlayerChange) == 0x000008, "Wrong alignment on PlayerTalkingWidget_BP_OnPlayerChange");
static_assert(sizeof(PlayerTalkingWidget_BP_OnPlayerChange) == 0x000010, "Wrong size on PlayerTalkingWidget_BP_OnPlayerChange");
static_assert(offsetof(PlayerTalkingWidget_BP_OnPlayerChange, NewPlayerName) == 0x000000, "Member 'PlayerTalkingWidget_BP_OnPlayerChange::NewPlayerName' has a wrong offset!");

// Function DeceiveInc.PlayerTalkingWidget.HandlePlayerTakingUpdate
// 0x0001 (0x0001 - 0x0000)
struct PlayerTalkingWidget_HandlePlayerTakingUpdate final
{
public:
	bool                                          bTalking;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerTalkingWidget_HandlePlayerTakingUpdate) == 0x000001, "Wrong alignment on PlayerTalkingWidget_HandlePlayerTakingUpdate");
static_assert(sizeof(PlayerTalkingWidget_HandlePlayerTakingUpdate) == 0x000001, "Wrong size on PlayerTalkingWidget_HandlePlayerTakingUpdate");
static_assert(offsetof(PlayerTalkingWidget_HandlePlayerTakingUpdate, bTalking) == 0x000000, "Member 'PlayerTalkingWidget_HandlePlayerTakingUpdate::bTalking' has a wrong offset!");

// Function DeceiveInc.PlayerTalkingWidget.GetNormalizedAmplitude
// 0x0004 (0x0004 - 0x0000)
struct PlayerTalkingWidget_GetNormalizedAmplitude final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerTalkingWidget_GetNormalizedAmplitude) == 0x000004, "Wrong alignment on PlayerTalkingWidget_GetNormalizedAmplitude");
static_assert(sizeof(PlayerTalkingWidget_GetNormalizedAmplitude) == 0x000004, "Wrong size on PlayerTalkingWidget_GetNormalizedAmplitude");
static_assert(offsetof(PlayerTalkingWidget_GetNormalizedAmplitude, ReturnValue) == 0x000000, "Member 'PlayerTalkingWidget_GetNormalizedAmplitude::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PlayerTalkingWidget.GetPlayerName
// 0x0010 (0x0010 - 0x0000)
struct PlayerTalkingWidget_GetPlayerName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerTalkingWidget_GetPlayerName) == 0x000008, "Wrong alignment on PlayerTalkingWidget_GetPlayerName");
static_assert(sizeof(PlayerTalkingWidget_GetPlayerName) == 0x000010, "Wrong size on PlayerTalkingWidget_GetPlayerName");
static_assert(offsetof(PlayerTalkingWidget_GetPlayerName, ReturnValue) == 0x000000, "Member 'PlayerTalkingWidget_GetPlayerName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PlayerTalkingWidget.GetPlayerState
// 0x0008 (0x0008 - 0x0000)
struct PlayerTalkingWidget_GetPlayerState final
{
public:
	class ADIPlayerState*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerTalkingWidget_GetPlayerState) == 0x000008, "Wrong alignment on PlayerTalkingWidget_GetPlayerState");
static_assert(sizeof(PlayerTalkingWidget_GetPlayerState) == 0x000008, "Wrong size on PlayerTalkingWidget_GetPlayerState");
static_assert(offsetof(PlayerTalkingWidget_GetPlayerState, ReturnValue) == 0x000000, "Member 'PlayerTalkingWidget_GetPlayerState::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PlayerTalkingWidget.IsPlayerTalking
// 0x0001 (0x0001 - 0x0000)
struct PlayerTalkingWidget_IsPlayerTalking final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerTalkingWidget_IsPlayerTalking) == 0x000001, "Wrong alignment on PlayerTalkingWidget_IsPlayerTalking");
static_assert(sizeof(PlayerTalkingWidget_IsPlayerTalking) == 0x000001, "Wrong size on PlayerTalkingWidget_IsPlayerTalking");
static_assert(offsetof(PlayerTalkingWidget_IsPlayerTalking, ReturnValue) == 0x000000, "Member 'PlayerTalkingWidget_IsPlayerTalking::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PlayerTalkingWidget.IsValid
// 0x0001 (0x0001 - 0x0000)
struct PlayerTalkingWidget_IsValid final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerTalkingWidget_IsValid) == 0x000001, "Wrong alignment on PlayerTalkingWidget_IsValid");
static_assert(sizeof(PlayerTalkingWidget_IsValid) == 0x000001, "Wrong size on PlayerTalkingWidget_IsValid");
static_assert(offsetof(PlayerTalkingWidget_IsValid, ReturnValue) == 0x000000, "Member 'PlayerTalkingWidget_IsValid::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VigilActiveAbility.GetAbilityWeapon
// 0x0008 (0x0008 - 0x0000)
struct VigilActiveAbility_GetAbilityWeapon final
{
public:
	class AProjectileWeapon*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VigilActiveAbility_GetAbilityWeapon) == 0x000008, "Wrong alignment on VigilActiveAbility_GetAbilityWeapon");
static_assert(sizeof(VigilActiveAbility_GetAbilityWeapon) == 0x000008, "Wrong size on VigilActiveAbility_GetAbilityWeapon");
static_assert(offsetof(VigilActiveAbility_GetAbilityWeapon, ReturnValue) == 0x000000, "Member 'VigilActiveAbility_GetAbilityWeapon::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VigilActiveAbility.OnRep_ReplicatedAbilityWeapon
// 0x0008 (0x0008 - 0x0000)
struct VigilActiveAbility_OnRep_ReplicatedAbilityWeapon final
{
public:
	class AProjectileWeapon*                      PrevWeapon;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VigilActiveAbility_OnRep_ReplicatedAbilityWeapon) == 0x000008, "Wrong alignment on VigilActiveAbility_OnRep_ReplicatedAbilityWeapon");
static_assert(sizeof(VigilActiveAbility_OnRep_ReplicatedAbilityWeapon) == 0x000008, "Wrong size on VigilActiveAbility_OnRep_ReplicatedAbilityWeapon");
static_assert(offsetof(VigilActiveAbility_OnRep_ReplicatedAbilityWeapon, PrevWeapon) == 0x000000, "Member 'VigilActiveAbility_OnRep_ReplicatedAbilityWeapon::PrevWeapon' has a wrong offset!");

// Function DeceiveInc.VigilActiveAbility.OnResourceAmountChanged
// 0x0004 (0x0004 - 0x0000)
struct VigilActiveAbility_OnResourceAmountChanged final
{
public:
	int32                                         TotalBulletLeft;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VigilActiveAbility_OnResourceAmountChanged) == 0x000004, "Wrong alignment on VigilActiveAbility_OnResourceAmountChanged");
static_assert(sizeof(VigilActiveAbility_OnResourceAmountChanged) == 0x000004, "Wrong size on VigilActiveAbility_OnResourceAmountChanged");
static_assert(offsetof(VigilActiveAbility_OnResourceAmountChanged, TotalBulletLeft) == 0x000000, "Member 'VigilActiveAbility_OnResourceAmountChanged::TotalBulletLeft' has a wrong offset!");

// Function DeceiveInc.VigilActiveAbility.OnWeaponEvent
// 0x0010 (0x0010 - 0x0000)
struct VigilActiveAbility_OnWeaponEvent final
{
public:
	ESpyToolEvent                                 EventType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSpyTool*                           SpyTool;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VigilActiveAbility_OnWeaponEvent) == 0x000008, "Wrong alignment on VigilActiveAbility_OnWeaponEvent");
static_assert(sizeof(VigilActiveAbility_OnWeaponEvent) == 0x000010, "Wrong size on VigilActiveAbility_OnWeaponEvent");
static_assert(offsetof(VigilActiveAbility_OnWeaponEvent, EventType) == 0x000000, "Member 'VigilActiveAbility_OnWeaponEvent::EventType' has a wrong offset!");
static_assert(offsetof(VigilActiveAbility_OnWeaponEvent, SpyTool) == 0x000008, "Member 'VigilActiveAbility_OnWeaponEvent::SpyTool' has a wrong offset!");

// Function DeceiveInc.PopulationManager.BP_TriggerDangerEventAtPos
// 0x0018 (0x0018 - 0x0000)
struct PopulationManager_BP_TriggerDangerEventAtPos final
{
public:
	class AActor*                                 DangerCause;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DangerPos;                                         // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PopulationManager_BP_TriggerDangerEventAtPos) == 0x000008, "Wrong alignment on PopulationManager_BP_TriggerDangerEventAtPos");
static_assert(sizeof(PopulationManager_BP_TriggerDangerEventAtPos) == 0x000018, "Wrong size on PopulationManager_BP_TriggerDangerEventAtPos");
static_assert(offsetof(PopulationManager_BP_TriggerDangerEventAtPos, DangerCause) == 0x000000, "Member 'PopulationManager_BP_TriggerDangerEventAtPos::DangerCause' has a wrong offset!");
static_assert(offsetof(PopulationManager_BP_TriggerDangerEventAtPos, DangerPos) == 0x000008, "Member 'PopulationManager_BP_TriggerDangerEventAtPos::DangerPos' has a wrong offset!");

// Function DeceiveInc.PopulationManager.HandleSpySpawnedEvent
// 0x0008 (0x0008 - 0x0000)
struct PopulationManager_HandleSpySpawnedEvent final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PopulationManager_HandleSpySpawnedEvent) == 0x000008, "Wrong alignment on PopulationManager_HandleSpySpawnedEvent");
static_assert(sizeof(PopulationManager_HandleSpySpawnedEvent) == 0x000008, "Wrong size on PopulationManager_HandleSpySpawnedEvent");
static_assert(offsetof(PopulationManager_HandleSpySpawnedEvent, Spy) == 0x000000, "Member 'PopulationManager_HandleSpySpawnedEvent::Spy' has a wrong offset!");

// Function DeceiveInc.PopulationManager.OnGamePhaseChanged
// 0x0001 (0x0001 - 0x0000)
struct PopulationManager_OnGamePhaseChanged final
{
public:
	ESpyGamePhase                                 NewGamePhase;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PopulationManager_OnGamePhaseChanged) == 0x000001, "Wrong alignment on PopulationManager_OnGamePhaseChanged");
static_assert(sizeof(PopulationManager_OnGamePhaseChanged) == 0x000001, "Wrong size on PopulationManager_OnGamePhaseChanged");
static_assert(offsetof(PopulationManager_OnGamePhaseChanged, NewGamePhase) == 0x000000, "Member 'PopulationManager_OnGamePhaseChanged::NewGamePhase' has a wrong offset!");

// Function DeceiveInc.PopulationManager.OnVaultTerminalUnlockedCountChanged
// 0x0004 (0x0004 - 0x0000)
struct PopulationManager_OnVaultTerminalUnlockedCountChanged final
{
public:
	int32                                         VaultTerminalUnlockedCount;                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PopulationManager_OnVaultTerminalUnlockedCountChanged) == 0x000004, "Wrong alignment on PopulationManager_OnVaultTerminalUnlockedCountChanged");
static_assert(sizeof(PopulationManager_OnVaultTerminalUnlockedCountChanged) == 0x000004, "Wrong size on PopulationManager_OnVaultTerminalUnlockedCountChanged");
static_assert(offsetof(PopulationManager_OnVaultTerminalUnlockedCountChanged, VaultTerminalUnlockedCount) == 0x000000, "Member 'PopulationManager_OnVaultTerminalUnlockedCountChanged::VaultTerminalUnlockedCount' has a wrong offset!");

// Function DeceiveInc.VoicechatMemberContainerWidget.FreeSlotForMemberWidget
// 0x0008 (0x0008 - 0x0000)
struct VoicechatMemberContainerWidget_FreeSlotForMemberWidget final
{
public:
	class UVoicechatMemberWidget*                 MemberWidget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoicechatMemberContainerWidget_FreeSlotForMemberWidget) == 0x000008, "Wrong alignment on VoicechatMemberContainerWidget_FreeSlotForMemberWidget");
static_assert(sizeof(VoicechatMemberContainerWidget_FreeSlotForMemberWidget) == 0x000008, "Wrong size on VoicechatMemberContainerWidget_FreeSlotForMemberWidget");
static_assert(offsetof(VoicechatMemberContainerWidget_FreeSlotForMemberWidget, MemberWidget) == 0x000000, "Member 'VoicechatMemberContainerWidget_FreeSlotForMemberWidget::MemberWidget' has a wrong offset!");

// Function DeceiveInc.VoicechatMemberContainerWidget.HandleChatMemberTalkingEvent
// 0x0028 (0x0028 - 0x0000)
struct VoicechatMemberContainerWidget_HandleChatMemberTalkingEvent final
{
public:
	class FString                                 PlayerChatID;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChannelName;                                       // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTalking;                                          // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VoicechatMemberContainerWidget_HandleChatMemberTalkingEvent) == 0x000008, "Wrong alignment on VoicechatMemberContainerWidget_HandleChatMemberTalkingEvent");
static_assert(sizeof(VoicechatMemberContainerWidget_HandleChatMemberTalkingEvent) == 0x000028, "Wrong size on VoicechatMemberContainerWidget_HandleChatMemberTalkingEvent");
static_assert(offsetof(VoicechatMemberContainerWidget_HandleChatMemberTalkingEvent, PlayerChatID) == 0x000000, "Member 'VoicechatMemberContainerWidget_HandleChatMemberTalkingEvent::PlayerChatID' has a wrong offset!");
static_assert(offsetof(VoicechatMemberContainerWidget_HandleChatMemberTalkingEvent, ChannelName) == 0x000010, "Member 'VoicechatMemberContainerWidget_HandleChatMemberTalkingEvent::ChannelName' has a wrong offset!");
static_assert(offsetof(VoicechatMemberContainerWidget_HandleChatMemberTalkingEvent, bTalking) == 0x000020, "Member 'VoicechatMemberContainerWidget_HandleChatMemberTalkingEvent::bTalking' has a wrong offset!");

// Function DeceiveInc.VoicechatMemberContainerWidget.HandleVoiceChatPlayerRemovedFromChannel
// 0x0020 (0x0020 - 0x0000)
struct VoicechatMemberContainerWidget_HandleVoiceChatPlayerRemovedFromChannel final
{
public:
	class FString                                 PlayerChatID;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChannelName;                                       // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoicechatMemberContainerWidget_HandleVoiceChatPlayerRemovedFromChannel) == 0x000008, "Wrong alignment on VoicechatMemberContainerWidget_HandleVoiceChatPlayerRemovedFromChannel");
static_assert(sizeof(VoicechatMemberContainerWidget_HandleVoiceChatPlayerRemovedFromChannel) == 0x000020, "Wrong size on VoicechatMemberContainerWidget_HandleVoiceChatPlayerRemovedFromChannel");
static_assert(offsetof(VoicechatMemberContainerWidget_HandleVoiceChatPlayerRemovedFromChannel, PlayerChatID) == 0x000000, "Member 'VoicechatMemberContainerWidget_HandleVoiceChatPlayerRemovedFromChannel::PlayerChatID' has a wrong offset!");
static_assert(offsetof(VoicechatMemberContainerWidget_HandleVoiceChatPlayerRemovedFromChannel, ChannelName) == 0x000010, "Member 'VoicechatMemberContainerWidget_HandleVoiceChatPlayerRemovedFromChannel::ChannelName' has a wrong offset!");

// Function DeceiveInc.VoicechatMemberContainerWidget.ReserveSlotForMemberWidget
// 0x0008 (0x0008 - 0x0000)
struct VoicechatMemberContainerWidget_ReserveSlotForMemberWidget final
{
public:
	class UVoicechatMemberWidget*                 MemberWidget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoicechatMemberContainerWidget_ReserveSlotForMemberWidget) == 0x000008, "Wrong alignment on VoicechatMemberContainerWidget_ReserveSlotForMemberWidget");
static_assert(sizeof(VoicechatMemberContainerWidget_ReserveSlotForMemberWidget) == 0x000008, "Wrong size on VoicechatMemberContainerWidget_ReserveSlotForMemberWidget");
static_assert(offsetof(VoicechatMemberContainerWidget_ReserveSlotForMemberWidget, MemberWidget) == 0x000000, "Member 'VoicechatMemberContainerWidget_ReserveSlotForMemberWidget::MemberWidget' has a wrong offset!");

// Function DeceiveInc.PosingSpyActorContainer.CreateAnimationProp
// 0x0068 (0x0068 - 0x0000)
struct PosingSpyActorContainer_CreateAnimationProp final
{
public:
	struct FAnimationPropData                     PropsIn;                                           // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PosingSpyActorContainer_CreateAnimationProp) == 0x000008, "Wrong alignment on PosingSpyActorContainer_CreateAnimationProp");
static_assert(sizeof(PosingSpyActorContainer_CreateAnimationProp) == 0x000068, "Wrong size on PosingSpyActorContainer_CreateAnimationProp");
static_assert(offsetof(PosingSpyActorContainer_CreateAnimationProp, PropsIn) == 0x000000, "Member 'PosingSpyActorContainer_CreateAnimationProp::PropsIn' has a wrong offset!");
static_assert(offsetof(PosingSpyActorContainer_CreateAnimationProp, bLooping) == 0x000060, "Member 'PosingSpyActorContainer_CreateAnimationProp::bLooping' has a wrong offset!");

// Function DeceiveInc.PosingSpyActorContainer.CreateAnimationProps
// 0x0018 (0x0018 - 0x0000)
struct PosingSpyActorContainer_CreateAnimationProps final
{
public:
	TArray<struct FAnimationPropData>             PropIn;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PosingSpyActorContainer_CreateAnimationProps) == 0x000008, "Wrong alignment on PosingSpyActorContainer_CreateAnimationProps");
static_assert(sizeof(PosingSpyActorContainer_CreateAnimationProps) == 0x000018, "Wrong size on PosingSpyActorContainer_CreateAnimationProps");
static_assert(offsetof(PosingSpyActorContainer_CreateAnimationProps, PropIn) == 0x000000, "Member 'PosingSpyActorContainer_CreateAnimationProps::PropIn' has a wrong offset!");
static_assert(offsetof(PosingSpyActorContainer_CreateAnimationProps, bLooping) == 0x000010, "Member 'PosingSpyActorContainer_CreateAnimationProps::bLooping' has a wrong offset!");

// Function DeceiveInc.PosingSpyActorContainer.HandleDisplayedWrapChangedDelegate
// 0x0024 (0x0024 - 0x0000)
struct PosingSpyActorContainer_HandleDisplayedWrapChangedDelegate final
{
public:
	struct FPrimaryAssetId                        WeaponId;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        WrapId;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayedWrapIndex;                                // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PosingSpyActorContainer_HandleDisplayedWrapChangedDelegate) == 0x000004, "Wrong alignment on PosingSpyActorContainer_HandleDisplayedWrapChangedDelegate");
static_assert(sizeof(PosingSpyActorContainer_HandleDisplayedWrapChangedDelegate) == 0x000024, "Wrong size on PosingSpyActorContainer_HandleDisplayedWrapChangedDelegate");
static_assert(offsetof(PosingSpyActorContainer_HandleDisplayedWrapChangedDelegate, WeaponId) == 0x000000, "Member 'PosingSpyActorContainer_HandleDisplayedWrapChangedDelegate::WeaponId' has a wrong offset!");
static_assert(offsetof(PosingSpyActorContainer_HandleDisplayedWrapChangedDelegate, WrapId) == 0x000010, "Member 'PosingSpyActorContainer_HandleDisplayedWrapChangedDelegate::WrapId' has a wrong offset!");
static_assert(offsetof(PosingSpyActorContainer_HandleDisplayedWrapChangedDelegate, DisplayedWrapIndex) == 0x000020, "Member 'PosingSpyActorContainer_HandleDisplayedWrapChangedDelegate::DisplayedWrapIndex' has a wrong offset!");

// Function DeceiveInc.PosingSpyActorContainer.HandleLoadoutSpawnComplete
// 0x0008 (0x0008 - 0x0000)
struct PosingSpyActorContainer_HandleLoadoutSpawnComplete final
{
public:
	class UToolLoadoutComponent*                  ToolLoadout;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PosingSpyActorContainer_HandleLoadoutSpawnComplete) == 0x000008, "Wrong alignment on PosingSpyActorContainer_HandleLoadoutSpawnComplete");
static_assert(sizeof(PosingSpyActorContainer_HandleLoadoutSpawnComplete) == 0x000008, "Wrong size on PosingSpyActorContainer_HandleLoadoutSpawnComplete");
static_assert(offsetof(PosingSpyActorContainer_HandleLoadoutSpawnComplete, ToolLoadout) == 0x000000, "Member 'PosingSpyActorContainer_HandleLoadoutSpawnComplete::ToolLoadout' has a wrong offset!");

// Function DeceiveInc.PosingSpyActorContainer.HandleSpySpawnedEvent
// 0x0008 (0x0008 - 0x0000)
struct PosingSpyActorContainer_HandleSpySpawnedEvent final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PosingSpyActorContainer_HandleSpySpawnedEvent) == 0x000008, "Wrong alignment on PosingSpyActorContainer_HandleSpySpawnedEvent");
static_assert(sizeof(PosingSpyActorContainer_HandleSpySpawnedEvent) == 0x000008, "Wrong size on PosingSpyActorContainer_HandleSpySpawnedEvent");
static_assert(offsetof(PosingSpyActorContainer_HandleSpySpawnedEvent, Spy) == 0x000000, "Member 'PosingSpyActorContainer_HandleSpySpawnedEvent::Spy' has a wrong offset!");

// Function DeceiveInc.PosingSpyActorContainer.OnDisplayedAgentChangedDelegate
// 0x0014 (0x0014 - 0x0000)
struct PosingSpyActorContainer_OnDisplayedAgentChangedDelegate final
{
public:
	struct FPrimaryAssetId                        AgentSkinId;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayedAgentIndex;                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PosingSpyActorContainer_OnDisplayedAgentChangedDelegate) == 0x000004, "Wrong alignment on PosingSpyActorContainer_OnDisplayedAgentChangedDelegate");
static_assert(sizeof(PosingSpyActorContainer_OnDisplayedAgentChangedDelegate) == 0x000014, "Wrong size on PosingSpyActorContainer_OnDisplayedAgentChangedDelegate");
static_assert(offsetof(PosingSpyActorContainer_OnDisplayedAgentChangedDelegate, AgentSkinId) == 0x000000, "Member 'PosingSpyActorContainer_OnDisplayedAgentChangedDelegate::AgentSkinId' has a wrong offset!");
static_assert(offsetof(PosingSpyActorContainer_OnDisplayedAgentChangedDelegate, DisplayedAgentIndex) == 0x000010, "Member 'PosingSpyActorContainer_OnDisplayedAgentChangedDelegate::DisplayedAgentIndex' has a wrong offset!");

// Function DeceiveInc.PosingSpyActorContainer.OnDisplayedIntroPoseChangedDelegate
// 0x0014 (0x0014 - 0x0000)
struct PosingSpyActorContainer_OnDisplayedIntroPoseChangedDelegate final
{
public:
	struct FPrimaryAssetId                        IntroPoseId;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayedAgentIndex;                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PosingSpyActorContainer_OnDisplayedIntroPoseChangedDelegate) == 0x000004, "Wrong alignment on PosingSpyActorContainer_OnDisplayedIntroPoseChangedDelegate");
static_assert(sizeof(PosingSpyActorContainer_OnDisplayedIntroPoseChangedDelegate) == 0x000014, "Wrong size on PosingSpyActorContainer_OnDisplayedIntroPoseChangedDelegate");
static_assert(offsetof(PosingSpyActorContainer_OnDisplayedIntroPoseChangedDelegate, IntroPoseId) == 0x000000, "Member 'PosingSpyActorContainer_OnDisplayedIntroPoseChangedDelegate::IntroPoseId' has a wrong offset!");
static_assert(offsetof(PosingSpyActorContainer_OnDisplayedIntroPoseChangedDelegate, DisplayedAgentIndex) == 0x000010, "Member 'PosingSpyActorContainer_OnDisplayedIntroPoseChangedDelegate::DisplayedAgentIndex' has a wrong offset!");

// Function DeceiveInc.PosingSpyActorContainer.PlayIntroPoseAnimation
// 0x0014 (0x0014 - 0x0000)
struct PosingSpyActorContainer_PlayIntroPoseAnimation final
{
public:
	struct FPrimaryAssetId                        IntroPoseId;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartPaused;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PosingSpyActorContainer_PlayIntroPoseAnimation) == 0x000004, "Wrong alignment on PosingSpyActorContainer_PlayIntroPoseAnimation");
static_assert(sizeof(PosingSpyActorContainer_PlayIntroPoseAnimation) == 0x000014, "Wrong size on PosingSpyActorContainer_PlayIntroPoseAnimation");
static_assert(offsetof(PosingSpyActorContainer_PlayIntroPoseAnimation, IntroPoseId) == 0x000000, "Member 'PosingSpyActorContainer_PlayIntroPoseAnimation::IntroPoseId' has a wrong offset!");
static_assert(offsetof(PosingSpyActorContainer_PlayIntroPoseAnimation, bStartPaused) == 0x000010, "Member 'PosingSpyActorContainer_PlayIntroPoseAnimation::bStartPaused' has a wrong offset!");

// Function DeceiveInc.PosingSpyActorContainer.SetupFromPlayerState
// 0x0008 (0x0008 - 0x0000)
struct PosingSpyActorContainer_SetupFromPlayerState final
{
public:
	class ADIPlayerState*                         DIPlayeState;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PosingSpyActorContainer_SetupFromPlayerState) == 0x000008, "Wrong alignment on PosingSpyActorContainer_SetupFromPlayerState");
static_assert(sizeof(PosingSpyActorContainer_SetupFromPlayerState) == 0x000008, "Wrong size on PosingSpyActorContainer_SetupFromPlayerState");
static_assert(offsetof(PosingSpyActorContainer_SetupFromPlayerState, DIPlayeState) == 0x000000, "Member 'PosingSpyActorContainer_SetupFromPlayerState::DIPlayeState' has a wrong offset!");

// Function DeceiveInc.PosingSpyAnimInstance.BP_SetAnimationPaused
// 0x0001 (0x0001 - 0x0000)
struct PosingSpyAnimInstance_BP_SetAnimationPaused final
{
public:
	bool                                          bPaused;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PosingSpyAnimInstance_BP_SetAnimationPaused) == 0x000001, "Wrong alignment on PosingSpyAnimInstance_BP_SetAnimationPaused");
static_assert(sizeof(PosingSpyAnimInstance_BP_SetAnimationPaused) == 0x000001, "Wrong size on PosingSpyAnimInstance_BP_SetAnimationPaused");
static_assert(offsetof(PosingSpyAnimInstance_BP_SetAnimationPaused, bPaused) == 0x000000, "Member 'PosingSpyAnimInstance_BP_SetAnimationPaused::bPaused' has a wrong offset!");

// Function DeceiveInc.PoudrierActor.GetActiveSpyTool
// 0x0008 (0x0008 - 0x0000)
struct PoudrierActor_GetActiveSpyTool final
{
public:
	class ABaseSpyTool*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PoudrierActor_GetActiveSpyTool) == 0x000008, "Wrong alignment on PoudrierActor_GetActiveSpyTool");
static_assert(sizeof(PoudrierActor_GetActiveSpyTool) == 0x000008, "Wrong size on PoudrierActor_GetActiveSpyTool");
static_assert(offsetof(PoudrierActor_GetActiveSpyTool, ReturnValue) == 0x000000, "Member 'PoudrierActor_GetActiveSpyTool::ReturnValue' has a wrong offset!");

// Function DeceiveInc.WebStreamedVisualAsset.SetWebAssetDefinition
// 0x0018 (0x0018 - 0x0000)
struct WebStreamedVisualAsset_SetWebAssetDefinition final
{
public:
	struct FWebStreamedAssetDefinition            InAssetDefinition;                                 // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(WebStreamedVisualAsset_SetWebAssetDefinition) == 0x000008, "Wrong alignment on WebStreamedVisualAsset_SetWebAssetDefinition");
static_assert(sizeof(WebStreamedVisualAsset_SetWebAssetDefinition) == 0x000018, "Wrong size on WebStreamedVisualAsset_SetWebAssetDefinition");
static_assert(offsetof(WebStreamedVisualAsset_SetWebAssetDefinition, InAssetDefinition) == 0x000000, "Member 'WebStreamedVisualAsset_SetWebAssetDefinition::InAssetDefinition' has a wrong offset!");

// Function DeceiveInc.WebStreamedVisualAsset.GetWebAssetDefinition
// 0x0018 (0x0018 - 0x0000)
struct WebStreamedVisualAsset_GetWebAssetDefinition final
{
public:
	struct FWebStreamedAssetDefinition            ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(WebStreamedVisualAsset_GetWebAssetDefinition) == 0x000008, "Wrong alignment on WebStreamedVisualAsset_GetWebAssetDefinition");
static_assert(sizeof(WebStreamedVisualAsset_GetWebAssetDefinition) == 0x000018, "Wrong size on WebStreamedVisualAsset_GetWebAssetDefinition");
static_assert(offsetof(WebStreamedVisualAsset_GetWebAssetDefinition, ReturnValue) == 0x000000, "Member 'WebStreamedVisualAsset_GetWebAssetDefinition::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PowerupManagerComponent.GetExfiltratorData
// 0x0058 (0x0058 - 0x0000)
struct PowerupManagerComponent_GetExfiltratorData final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FExfiltratorData                       FoodieData;                                        // 0x0008(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PowerupManagerComponent_GetExfiltratorData) == 0x000008, "Wrong alignment on PowerupManagerComponent_GetExfiltratorData");
static_assert(sizeof(PowerupManagerComponent_GetExfiltratorData) == 0x000058, "Wrong size on PowerupManagerComponent_GetExfiltratorData");
static_assert(offsetof(PowerupManagerComponent_GetExfiltratorData, WorldContextObject) == 0x000000, "Member 'PowerupManagerComponent_GetExfiltratorData::WorldContextObject' has a wrong offset!");
static_assert(offsetof(PowerupManagerComponent_GetExfiltratorData, FoodieData) == 0x000008, "Member 'PowerupManagerComponent_GetExfiltratorData::FoodieData' has a wrong offset!");

// Function DeceiveInc.PowerupManagerComponent.GetFoodieData
// 0x0058 (0x0058 - 0x0000)
struct PowerupManagerComponent_GetFoodieData final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFoodieData                            FoodieData;                                        // 0x0008(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PowerupManagerComponent_GetFoodieData) == 0x000008, "Wrong alignment on PowerupManagerComponent_GetFoodieData");
static_assert(sizeof(PowerupManagerComponent_GetFoodieData) == 0x000058, "Wrong size on PowerupManagerComponent_GetFoodieData");
static_assert(offsetof(PowerupManagerComponent_GetFoodieData, WorldContextObject) == 0x000000, "Member 'PowerupManagerComponent_GetFoodieData::WorldContextObject' has a wrong offset!");
static_assert(offsetof(PowerupManagerComponent_GetFoodieData, FoodieData) == 0x000008, "Member 'PowerupManagerComponent_GetFoodieData::FoodieData' has a wrong offset!");

// Function DeceiveInc.PowerupManagerComponent.GetPowerupForLevel
// 0x0010 (0x0010 - 0x0000)
struct PowerupManagerComponent_GetPowerupForLevel final
{
public:
	class ASpy*                                   SpyToCheck;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESecurityLevel                                Level;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPowerupType                                  ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PowerupManagerComponent_GetPowerupForLevel) == 0x000008, "Wrong alignment on PowerupManagerComponent_GetPowerupForLevel");
static_assert(sizeof(PowerupManagerComponent_GetPowerupForLevel) == 0x000010, "Wrong size on PowerupManagerComponent_GetPowerupForLevel");
static_assert(offsetof(PowerupManagerComponent_GetPowerupForLevel, SpyToCheck) == 0x000000, "Member 'PowerupManagerComponent_GetPowerupForLevel::SpyToCheck' has a wrong offset!");
static_assert(offsetof(PowerupManagerComponent_GetPowerupForLevel, Level) == 0x000008, "Member 'PowerupManagerComponent_GetPowerupForLevel::Level' has a wrong offset!");
static_assert(offsetof(PowerupManagerComponent_GetPowerupForLevel, ReturnValue) == 0x000009, "Member 'PowerupManagerComponent_GetPowerupForLevel::ReturnValue' has a wrong offset!");

// Function DeceiveInc.PowerupManagerComponent.GetPowerupInfos
// 0x00B8 (0x00B8 - 0x0000)
struct PowerupManagerComponent_GetPowerupInfos final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPowerupType                                  PowerupType;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPowerupInfo                           PowerupInfo;                                       // 0x0010(0x00A8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PowerupManagerComponent_GetPowerupInfos) == 0x000008, "Wrong alignment on PowerupManagerComponent_GetPowerupInfos");
static_assert(sizeof(PowerupManagerComponent_GetPowerupInfos) == 0x0000B8, "Wrong size on PowerupManagerComponent_GetPowerupInfos");
static_assert(offsetof(PowerupManagerComponent_GetPowerupInfos, WorldContextObject) == 0x000000, "Member 'PowerupManagerComponent_GetPowerupInfos::WorldContextObject' has a wrong offset!");
static_assert(offsetof(PowerupManagerComponent_GetPowerupInfos, PowerupType) == 0x000008, "Member 'PowerupManagerComponent_GetPowerupInfos::PowerupType' has a wrong offset!");
static_assert(offsetof(PowerupManagerComponent_GetPowerupInfos, PowerupInfo) == 0x000010, "Member 'PowerupManagerComponent_GetPowerupInfos::PowerupInfo' has a wrong offset!");

// Function DeceiveInc.PowerupManagerComponent.GetSocialBatteryData
// 0x0068 (0x0068 - 0x0000)
struct PowerupManagerComponent_GetSocialBatteryData final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSocialBatteryData                     SocialBatteryData;                                 // 0x0008(0x0060)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PowerupManagerComponent_GetSocialBatteryData) == 0x000008, "Wrong alignment on PowerupManagerComponent_GetSocialBatteryData");
static_assert(sizeof(PowerupManagerComponent_GetSocialBatteryData) == 0x000068, "Wrong size on PowerupManagerComponent_GetSocialBatteryData");
static_assert(offsetof(PowerupManagerComponent_GetSocialBatteryData, WorldContextObject) == 0x000000, "Member 'PowerupManagerComponent_GetSocialBatteryData::WorldContextObject' has a wrong offset!");
static_assert(offsetof(PowerupManagerComponent_GetSocialBatteryData, SocialBatteryData) == 0x000008, "Member 'PowerupManagerComponent_GetSocialBatteryData::SocialBatteryData' has a wrong offset!");

// Function DeceiveInc.XiuPassiveAbilityMod1.HandleOnNonLocalHealthChangeEvent
// 0x0030 (0x0030 - 0x0000)
struct XiuPassiveAbilityMod1_HandleOnNonLocalHealthChangeEvent final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHealthComponent*                       OwningHealthComp;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthDelta;                                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDamageType*                      DamageType;                                        // 0x0018(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XiuPassiveAbilityMod1_HandleOnNonLocalHealthChangeEvent) == 0x000008, "Wrong alignment on XiuPassiveAbilityMod1_HandleOnNonLocalHealthChangeEvent");
static_assert(sizeof(XiuPassiveAbilityMod1_HandleOnNonLocalHealthChangeEvent) == 0x000030, "Wrong size on XiuPassiveAbilityMod1_HandleOnNonLocalHealthChangeEvent");
static_assert(offsetof(XiuPassiveAbilityMod1_HandleOnNonLocalHealthChangeEvent, Spy) == 0x000000, "Member 'XiuPassiveAbilityMod1_HandleOnNonLocalHealthChangeEvent::Spy' has a wrong offset!");
static_assert(offsetof(XiuPassiveAbilityMod1_HandleOnNonLocalHealthChangeEvent, OwningHealthComp) == 0x000008, "Member 'XiuPassiveAbilityMod1_HandleOnNonLocalHealthChangeEvent::OwningHealthComp' has a wrong offset!");
static_assert(offsetof(XiuPassiveAbilityMod1_HandleOnNonLocalHealthChangeEvent, Health) == 0x000010, "Member 'XiuPassiveAbilityMod1_HandleOnNonLocalHealthChangeEvent::Health' has a wrong offset!");
static_assert(offsetof(XiuPassiveAbilityMod1_HandleOnNonLocalHealthChangeEvent, HealthDelta) == 0x000014, "Member 'XiuPassiveAbilityMod1_HandleOnNonLocalHealthChangeEvent::HealthDelta' has a wrong offset!");
static_assert(offsetof(XiuPassiveAbilityMod1_HandleOnNonLocalHealthChangeEvent, DamageType) == 0x000018, "Member 'XiuPassiveAbilityMod1_HandleOnNonLocalHealthChangeEvent::DamageType' has a wrong offset!");
static_assert(offsetof(XiuPassiveAbilityMod1_HandleOnNonLocalHealthChangeEvent, InstigatedBy) == 0x000020, "Member 'XiuPassiveAbilityMod1_HandleOnNonLocalHealthChangeEvent::InstigatedBy' has a wrong offset!");
static_assert(offsetof(XiuPassiveAbilityMod1_HandleOnNonLocalHealthChangeEvent, DamageCauser) == 0x000028, "Member 'XiuPassiveAbilityMod1_HandleOnNonLocalHealthChangeEvent::DamageCauser' has a wrong offset!");

// Function DeceiveInc.RangePlacementComponent.GetRemainingCharges
// 0x0004 (0x0004 - 0x0000)
struct RangePlacementComponent_GetRemainingCharges final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangePlacementComponent_GetRemainingCharges) == 0x000004, "Wrong alignment on RangePlacementComponent_GetRemainingCharges");
static_assert(sizeof(RangePlacementComponent_GetRemainingCharges) == 0x000004, "Wrong size on RangePlacementComponent_GetRemainingCharges");
static_assert(offsetof(RangePlacementComponent_GetRemainingCharges, ReturnValue) == 0x000000, "Member 'RangePlacementComponent_GetRemainingCharges::ReturnValue' has a wrong offset!");

// Function DeceiveInc.RangePlacementComponent.HandleResourceNewAmount
// 0x0028 (0x0028 - 0x0000)
struct RangePlacementComponent_HandleResourceNewAmount final
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ResourceDisplayName;                               // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	int32                                         NewAmount;                                         // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RangePlacementComponent_HandleResourceNewAmount) == 0x000008, "Wrong alignment on RangePlacementComponent_HandleResourceNewAmount");
static_assert(sizeof(RangePlacementComponent_HandleResourceNewAmount) == 0x000028, "Wrong size on RangePlacementComponent_HandleResourceNewAmount");
static_assert(offsetof(RangePlacementComponent_HandleResourceNewAmount, ResourceType) == 0x000000, "Member 'RangePlacementComponent_HandleResourceNewAmount::ResourceType' has a wrong offset!");
static_assert(offsetof(RangePlacementComponent_HandleResourceNewAmount, ResourceDisplayName) == 0x000008, "Member 'RangePlacementComponent_HandleResourceNewAmount::ResourceDisplayName' has a wrong offset!");
static_assert(offsetof(RangePlacementComponent_HandleResourceNewAmount, NewAmount) == 0x000020, "Member 'RangePlacementComponent_HandleResourceNewAmount::NewAmount' has a wrong offset!");

// Function DeceiveInc.RangePlacementComponent.HasEnoughCharges
// 0x0001 (0x0001 - 0x0000)
struct RangePlacementComponent_HasEnoughCharges final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangePlacementComponent_HasEnoughCharges) == 0x000001, "Wrong alignment on RangePlacementComponent_HasEnoughCharges");
static_assert(sizeof(RangePlacementComponent_HasEnoughCharges) == 0x000001, "Wrong size on RangePlacementComponent_HasEnoughCharges");
static_assert(offsetof(RangePlacementComponent_HasEnoughCharges, ReturnValue) == 0x000000, "Member 'RangePlacementComponent_HasEnoughCharges::ReturnValue' has a wrong offset!");

// Function DeceiveInc.RangePlacementComponent.ServerSpawnPlaceable
// 0x0028 (0x0028 - 0x0000)
struct RangePlacementComponent_ServerSpawnPlaceable final
{
public:
	struct FVector_NetQuantize                    SpawnLocation;                                     // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SpawnRotation;                                     // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              TargetNormal;                                      // 0x0018(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrop;                                             // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnLocalOnly;                                   // 0x0025(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RangePlacementComponent_ServerSpawnPlaceable) == 0x000004, "Wrong alignment on RangePlacementComponent_ServerSpawnPlaceable");
static_assert(sizeof(RangePlacementComponent_ServerSpawnPlaceable) == 0x000028, "Wrong size on RangePlacementComponent_ServerSpawnPlaceable");
static_assert(offsetof(RangePlacementComponent_ServerSpawnPlaceable, SpawnLocation) == 0x000000, "Member 'RangePlacementComponent_ServerSpawnPlaceable::SpawnLocation' has a wrong offset!");
static_assert(offsetof(RangePlacementComponent_ServerSpawnPlaceable, SpawnRotation) == 0x00000C, "Member 'RangePlacementComponent_ServerSpawnPlaceable::SpawnRotation' has a wrong offset!");
static_assert(offsetof(RangePlacementComponent_ServerSpawnPlaceable, TargetNormal) == 0x000018, "Member 'RangePlacementComponent_ServerSpawnPlaceable::TargetNormal' has a wrong offset!");
static_assert(offsetof(RangePlacementComponent_ServerSpawnPlaceable, bDrop) == 0x000024, "Member 'RangePlacementComponent_ServerSpawnPlaceable::bDrop' has a wrong offset!");
static_assert(offsetof(RangePlacementComponent_ServerSpawnPlaceable, bSpawnLocalOnly) == 0x000025, "Member 'RangePlacementComponent_ServerSpawnPlaceable::bSpawnLocalOnly' has a wrong offset!");

// Function DeceiveInc.RangePlacementComponent.SetPositioning
// 0x0001 (0x0001 - 0x0000)
struct RangePlacementComponent_SetPositioning final
{
public:
	bool                                          _bPositioning;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangePlacementComponent_SetPositioning) == 0x000001, "Wrong alignment on RangePlacementComponent_SetPositioning");
static_assert(sizeof(RangePlacementComponent_SetPositioning) == 0x000001, "Wrong size on RangePlacementComponent_SetPositioning");
static_assert(offsetof(RangePlacementComponent_SetPositioning, _bPositioning) == 0x000000, "Member 'RangePlacementComponent_SetPositioning::_bPositioning' has a wrong offset!");

// Function DeceiveInc.RangePlacementComponent.IsPositionerVisible
// 0x0001 (0x0001 - 0x0000)
struct RangePlacementComponent_IsPositionerVisible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangePlacementComponent_IsPositionerVisible) == 0x000001, "Wrong alignment on RangePlacementComponent_IsPositionerVisible");
static_assert(sizeof(RangePlacementComponent_IsPositionerVisible) == 0x000001, "Wrong size on RangePlacementComponent_IsPositionerVisible");
static_assert(offsetof(RangePlacementComponent_IsPositionerVisible, ReturnValue) == 0x000000, "Member 'RangePlacementComponent_IsPositionerVisible::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SquirePassiveAbility.HandleBoostDurationCooldownChange
// 0x0001 (0x0001 - 0x0000)
struct SquirePassiveAbility_HandleBoostDurationCooldownChange final
{
public:
	bool                                          OnCooldown;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SquirePassiveAbility_HandleBoostDurationCooldownChange) == 0x000001, "Wrong alignment on SquirePassiveAbility_HandleBoostDurationCooldownChange");
static_assert(sizeof(SquirePassiveAbility_HandleBoostDurationCooldownChange) == 0x000001, "Wrong size on SquirePassiveAbility_HandleBoostDurationCooldownChange");
static_assert(offsetof(SquirePassiveAbility_HandleBoostDurationCooldownChange, OnCooldown) == 0x000000, "Member 'SquirePassiveAbility_HandleBoostDurationCooldownChange::OnCooldown' has a wrong offset!");

// Function DeceiveInc.SquirePassiveAbility.HandleUnderCoverChanged
// 0x0001 (0x0001 - 0x0000)
struct SquirePassiveAbility_HandleUnderCoverChanged final
{
public:
	bool                                          bUndercover;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SquirePassiveAbility_HandleUnderCoverChanged) == 0x000001, "Wrong alignment on SquirePassiveAbility_HandleUnderCoverChanged");
static_assert(sizeof(SquirePassiveAbility_HandleUnderCoverChanged) == 0x000001, "Wrong size on SquirePassiveAbility_HandleUnderCoverChanged");
static_assert(offsetof(SquirePassiveAbility_HandleUnderCoverChanged, bUndercover) == 0x000000, "Member 'SquirePassiveAbility_HandleUnderCoverChanged::bUndercover' has a wrong offset!");

// Function DeceiveInc.RemoteTurret.HandleAggroTargetChange
// 0x0008 (0x0008 - 0x0000)
struct RemoteTurret_HandleAggroTargetChange final
{
public:
	class AActor*                                 NewTarget;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RemoteTurret_HandleAggroTargetChange) == 0x000008, "Wrong alignment on RemoteTurret_HandleAggroTargetChange");
static_assert(sizeof(RemoteTurret_HandleAggroTargetChange) == 0x000008, "Wrong size on RemoteTurret_HandleAggroTargetChange");
static_assert(offsetof(RemoteTurret_HandleAggroTargetChange, NewTarget) == 0x000000, "Member 'RemoteTurret_HandleAggroTargetChange::NewTarget' has a wrong offset!");

// Function DeceiveInc.RemoteTurret.HandlePhaseChanged
// 0x0001 (0x0001 - 0x0000)
struct RemoteTurret_HandlePhaseChanged final
{
public:
	ESpyGamePhase                                 NewGamePhase;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RemoteTurret_HandlePhaseChanged) == 0x000001, "Wrong alignment on RemoteTurret_HandlePhaseChanged");
static_assert(sizeof(RemoteTurret_HandlePhaseChanged) == 0x000001, "Wrong size on RemoteTurret_HandlePhaseChanged");
static_assert(offsetof(RemoteTurret_HandlePhaseChanged, NewGamePhase) == 0x000000, "Member 'RemoteTurret_HandlePhaseChanged::NewGamePhase' has a wrong offset!");

// Function DeceiveInc.RemoteTurret.HandleSpyMovementEvent
// 0x0018 (0x0018 - 0x0000)
struct RemoteTurret_HandleSpyMovementEvent final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementEventType                            MovementEventType;                                 // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RemoteTurret_HandleSpyMovementEvent) == 0x000008, "Wrong alignment on RemoteTurret_HandleSpyMovementEvent");
static_assert(sizeof(RemoteTurret_HandleSpyMovementEvent) == 0x000018, "Wrong size on RemoteTurret_HandleSpyMovementEvent");
static_assert(offsetof(RemoteTurret_HandleSpyMovementEvent, PlayerController) == 0x000000, "Member 'RemoteTurret_HandleSpyMovementEvent::PlayerController' has a wrong offset!");
static_assert(offsetof(RemoteTurret_HandleSpyMovementEvent, Spy) == 0x000008, "Member 'RemoteTurret_HandleSpyMovementEvent::Spy' has a wrong offset!");
static_assert(offsetof(RemoteTurret_HandleSpyMovementEvent, MovementEventType) == 0x000010, "Member 'RemoteTurret_HandleSpyMovementEvent::MovementEventType' has a wrong offset!");

// Function DeceiveInc.RemoteTurret.HandleSpyToolEvent
// 0x0010 (0x0010 - 0x0000)
struct RemoteTurret_HandleSpyToolEvent final
{
public:
	ESpyToolEvent                                 EventType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSpyTool*                           SpyTool;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RemoteTurret_HandleSpyToolEvent) == 0x000008, "Wrong alignment on RemoteTurret_HandleSpyToolEvent");
static_assert(sizeof(RemoteTurret_HandleSpyToolEvent) == 0x000010, "Wrong size on RemoteTurret_HandleSpyToolEvent");
static_assert(offsetof(RemoteTurret_HandleSpyToolEvent, EventType) == 0x000000, "Member 'RemoteTurret_HandleSpyToolEvent::EventType' has a wrong offset!");
static_assert(offsetof(RemoteTurret_HandleSpyToolEvent, SpyTool) == 0x000008, "Member 'RemoteTurret_HandleSpyToolEvent::SpyTool' has a wrong offset!");

// Function DeceiveInc.RemoteTurret.HandleStateChange
// 0x0002 (0x0002 - 0x0000)
struct RemoteTurret_HandleStateChange final
{
public:
	ERemoteTurretAIState                          OldState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERemoteTurretAIState                          NewState;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RemoteTurret_HandleStateChange) == 0x000001, "Wrong alignment on RemoteTurret_HandleStateChange");
static_assert(sizeof(RemoteTurret_HandleStateChange) == 0x000002, "Wrong size on RemoteTurret_HandleStateChange");
static_assert(offsetof(RemoteTurret_HandleStateChange, OldState) == 0x000000, "Member 'RemoteTurret_HandleStateChange::OldState' has a wrong offset!");
static_assert(offsetof(RemoteTurret_HandleStateChange, NewState) == 0x000001, "Member 'RemoteTurret_HandleStateChange::NewState' has a wrong offset!");

// Function DeceiveInc.RemoteTurretTool.HandleOwnerTookDamage
// 0x0048 (0x0048 - 0x0000)
struct RemoteTurretTool_HandleOwnerTookDamage final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHealthComponent*                       SpyHealthComp;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthDelta;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDamageType*                      DamageType;                                        // 0x0020(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DamageDirection;                                   // 0x0038(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RemoteTurretTool_HandleOwnerTookDamage) == 0x000008, "Wrong alignment on RemoteTurretTool_HandleOwnerTookDamage");
static_assert(sizeof(RemoteTurretTool_HandleOwnerTookDamage) == 0x000048, "Wrong size on RemoteTurretTool_HandleOwnerTookDamage");
static_assert(offsetof(RemoteTurretTool_HandleOwnerTookDamage, PlayerController) == 0x000000, "Member 'RemoteTurretTool_HandleOwnerTookDamage::PlayerController' has a wrong offset!");
static_assert(offsetof(RemoteTurretTool_HandleOwnerTookDamage, Spy) == 0x000008, "Member 'RemoteTurretTool_HandleOwnerTookDamage::Spy' has a wrong offset!");
static_assert(offsetof(RemoteTurretTool_HandleOwnerTookDamage, SpyHealthComp) == 0x000010, "Member 'RemoteTurretTool_HandleOwnerTookDamage::SpyHealthComp' has a wrong offset!");
static_assert(offsetof(RemoteTurretTool_HandleOwnerTookDamage, Health) == 0x000018, "Member 'RemoteTurretTool_HandleOwnerTookDamage::Health' has a wrong offset!");
static_assert(offsetof(RemoteTurretTool_HandleOwnerTookDamage, HealthDelta) == 0x00001C, "Member 'RemoteTurretTool_HandleOwnerTookDamage::HealthDelta' has a wrong offset!");
static_assert(offsetof(RemoteTurretTool_HandleOwnerTookDamage, DamageType) == 0x000020, "Member 'RemoteTurretTool_HandleOwnerTookDamage::DamageType' has a wrong offset!");
static_assert(offsetof(RemoteTurretTool_HandleOwnerTookDamage, InstigatedBy) == 0x000028, "Member 'RemoteTurretTool_HandleOwnerTookDamage::InstigatedBy' has a wrong offset!");
static_assert(offsetof(RemoteTurretTool_HandleOwnerTookDamage, DamageCauser) == 0x000030, "Member 'RemoteTurretTool_HandleOwnerTookDamage::DamageCauser' has a wrong offset!");
static_assert(offsetof(RemoteTurretTool_HandleOwnerTookDamage, DamageDirection) == 0x000038, "Member 'RemoteTurretTool_HandleOwnerTookDamage::DamageDirection' has a wrong offset!");

// Function DeceiveInc.Sway1PComponent.OnPitchInputDelta
// 0x0004 (0x0004 - 0x0000)
struct Sway1PComponent_OnPitchInputDelta final
{
public:
	float                                         PitchDelta;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Sway1PComponent_OnPitchInputDelta) == 0x000004, "Wrong alignment on Sway1PComponent_OnPitchInputDelta");
static_assert(sizeof(Sway1PComponent_OnPitchInputDelta) == 0x000004, "Wrong size on Sway1PComponent_OnPitchInputDelta");
static_assert(offsetof(Sway1PComponent_OnPitchInputDelta, PitchDelta) == 0x000000, "Member 'Sway1PComponent_OnPitchInputDelta::PitchDelta' has a wrong offset!");

// Function DeceiveInc.Sway1PComponent.OnSpyAirborneVerticalAccel
// 0x0004 (0x0004 - 0x0000)
struct Sway1PComponent_OnSpyAirborneVerticalAccel final
{
public:
	float                                         VerticalAccelIn;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Sway1PComponent_OnSpyAirborneVerticalAccel) == 0x000004, "Wrong alignment on Sway1PComponent_OnSpyAirborneVerticalAccel");
static_assert(sizeof(Sway1PComponent_OnSpyAirborneVerticalAccel) == 0x000004, "Wrong size on Sway1PComponent_OnSpyAirborneVerticalAccel");
static_assert(offsetof(Sway1PComponent_OnSpyAirborneVerticalAccel, VerticalAccelIn) == 0x000000, "Member 'Sway1PComponent_OnSpyAirborneVerticalAccel::VerticalAccelIn' has a wrong offset!");

// Function DeceiveInc.Sway1PComponent.OnSpyOwnerPossessedByController
// 0x0008 (0x0008 - 0x0000)
struct Sway1PComponent_OnSpyOwnerPossessedByController final
{
public:
	class AController*                            NewController;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Sway1PComponent_OnSpyOwnerPossessedByController) == 0x000008, "Wrong alignment on Sway1PComponent_OnSpyOwnerPossessedByController");
static_assert(sizeof(Sway1PComponent_OnSpyOwnerPossessedByController) == 0x000008, "Wrong size on Sway1PComponent_OnSpyOwnerPossessedByController");
static_assert(offsetof(Sway1PComponent_OnSpyOwnerPossessedByController, NewController) == 0x000000, "Member 'Sway1PComponent_OnSpyOwnerPossessedByController::NewController' has a wrong offset!");

// Function DeceiveInc.Sway1PComponent.OnYawInputDelta
// 0x0004 (0x0004 - 0x0000)
struct Sway1PComponent_OnYawInputDelta final
{
public:
	float                                         YawDelta;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Sway1PComponent_OnYawInputDelta) == 0x000004, "Wrong alignment on Sway1PComponent_OnYawInputDelta");
static_assert(sizeof(Sway1PComponent_OnYawInputDelta) == 0x000004, "Wrong size on Sway1PComponent_OnYawInputDelta");
static_assert(offsetof(Sway1PComponent_OnYawInputDelta, YawDelta) == 0x000000, "Member 'Sway1PComponent_OnYawInputDelta::YawDelta' has a wrong offset!");

// Function DeceiveInc.Sway1PComponent.GetFactors
// 0x000C (0x000C - 0x0000)
struct Sway1PComponent_GetFactors final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Sway1PComponent_GetFactors) == 0x000004, "Wrong alignment on Sway1PComponent_GetFactors");
static_assert(sizeof(Sway1PComponent_GetFactors) == 0x00000C, "Wrong size on Sway1PComponent_GetFactors");
static_assert(offsetof(Sway1PComponent_GetFactors, ReturnValue) == 0x000000, "Member 'Sway1PComponent_GetFactors::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ReviveSpyConditionComponent.GetCurrentReviveCount
// 0x0004 (0x0004 - 0x0000)
struct ReviveSpyConditionComponent_GetCurrentReviveCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ReviveSpyConditionComponent_GetCurrentReviveCount) == 0x000004, "Wrong alignment on ReviveSpyConditionComponent_GetCurrentReviveCount");
static_assert(sizeof(ReviveSpyConditionComponent_GetCurrentReviveCount) == 0x000004, "Wrong size on ReviveSpyConditionComponent_GetCurrentReviveCount");
static_assert(offsetof(ReviveSpyConditionComponent_GetCurrentReviveCount, ReturnValue) == 0x000000, "Member 'ReviveSpyConditionComponent_GetCurrentReviveCount::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ReviveSpyConditionComponent.IsBurned
// 0x0001 (0x0001 - 0x0000)
struct ReviveSpyConditionComponent_IsBurned final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ReviveSpyConditionComponent_IsBurned) == 0x000001, "Wrong alignment on ReviveSpyConditionComponent_IsBurned");
static_assert(sizeof(ReviveSpyConditionComponent_IsBurned) == 0x000001, "Wrong size on ReviveSpyConditionComponent_IsBurned");
static_assert(offsetof(ReviveSpyConditionComponent_IsBurned, ReturnValue) == 0x000000, "Member 'ReviveSpyConditionComponent_IsBurned::ReturnValue' has a wrong offset!");

// Function DeceiveInc.RoomVolume.UpdateConnectedRoomsReference
// 0x0008 (0x0008 - 0x0000)
struct RoomVolume_UpdateConnectedRoomsReference final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RoomVolume_UpdateConnectedRoomsReference) == 0x000008, "Wrong alignment on RoomVolume_UpdateConnectedRoomsReference");
static_assert(sizeof(RoomVolume_UpdateConnectedRoomsReference) == 0x000008, "Wrong size on RoomVolume_UpdateConnectedRoomsReference");
static_assert(offsetof(RoomVolume_UpdateConnectedRoomsReference, World) == 0x000000, "Member 'RoomVolume_UpdateConnectedRoomsReference::World' has a wrong offset!");

// Function DeceiveInc.RoomVolume.GetCenterValidPos
// 0x000C (0x000C - 0x0000)
struct RoomVolume_GetCenterValidPos final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RoomVolume_GetCenterValidPos) == 0x000004, "Wrong alignment on RoomVolume_GetCenterValidPos");
static_assert(sizeof(RoomVolume_GetCenterValidPos) == 0x00000C, "Wrong size on RoomVolume_GetCenterValidPos");
static_assert(offsetof(RoomVolume_GetCenterValidPos, ReturnValue) == 0x000000, "Member 'RoomVolume_GetCenterValidPos::ReturnValue' has a wrong offset!");

// Function DeceiveInc.RoomVolume.HasOnGoingFightInRoom
// 0x0001 (0x0001 - 0x0000)
struct RoomVolume_HasOnGoingFightInRoom final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RoomVolume_HasOnGoingFightInRoom) == 0x000001, "Wrong alignment on RoomVolume_HasOnGoingFightInRoom");
static_assert(sizeof(RoomVolume_HasOnGoingFightInRoom) == 0x000001, "Wrong size on RoomVolume_HasOnGoingFightInRoom");
static_assert(offsetof(RoomVolume_HasOnGoingFightInRoom, ReturnValue) == 0x000000, "Member 'RoomVolume_HasOnGoingFightInRoom::ReturnValue' has a wrong offset!");

// Function DeceiveInc.RoomVolume.HasOnGoingFightInRoomFlag
// 0x0002 (0x0002 - 0x0000)
struct RoomVolume_HasOnGoingFightInRoomFlag final
{
public:
	uint8                                         FlagIn;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RoomVolume_HasOnGoingFightInRoomFlag) == 0x000001, "Wrong alignment on RoomVolume_HasOnGoingFightInRoomFlag");
static_assert(sizeof(RoomVolume_HasOnGoingFightInRoomFlag) == 0x000002, "Wrong size on RoomVolume_HasOnGoingFightInRoomFlag");
static_assert(offsetof(RoomVolume_HasOnGoingFightInRoomFlag, FlagIn) == 0x000000, "Member 'RoomVolume_HasOnGoingFightInRoomFlag::FlagIn' has a wrong offset!");
static_assert(offsetof(RoomVolume_HasOnGoingFightInRoomFlag, ReturnValue) == 0x000001, "Member 'RoomVolume_HasOnGoingFightInRoomFlag::ReturnValue' has a wrong offset!");

// Function DeceiveInc.RoomVolume.IsPosInRoom
// 0x0014 (0x0014 - 0x0000)
struct RoomVolume_IsPosInRoom final
{
public:
	struct FVector                                TestPos;                                           // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RoomVolume_IsPosInRoom) == 0x000004, "Wrong alignment on RoomVolume_IsPosInRoom");
static_assert(sizeof(RoomVolume_IsPosInRoom) == 0x000014, "Wrong size on RoomVolume_IsPosInRoom");
static_assert(offsetof(RoomVolume_IsPosInRoom, TestPos) == 0x000000, "Member 'RoomVolume_IsPosInRoom::TestPos' has a wrong offset!");
static_assert(offsetof(RoomVolume_IsPosInRoom, SphereRadius) == 0x00000C, "Member 'RoomVolume_IsPosInRoom::SphereRadius' has a wrong offset!");
static_assert(offsetof(RoomVolume_IsPosInRoom, ReturnValue) == 0x000010, "Member 'RoomVolume_IsPosInRoom::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SasoriActiveAbility.HandleMeleeAttackDamageDone
// 0x0068 (0x0068 - 0x0000)
struct SasoriActiveAbility_HandleMeleeAttackDamageDone final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPoint;                                       // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChargeLevel;                                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageDone;                                        // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultingHealthPercentage;                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitType                                      HitType;                                           // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMeleeHitConfirmedData                 HitConfirmedData;                                  // 0x0028(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(SasoriActiveAbility_HandleMeleeAttackDamageDone) == 0x000008, "Wrong alignment on SasoriActiveAbility_HandleMeleeAttackDamageDone");
static_assert(sizeof(SasoriActiveAbility_HandleMeleeAttackDamageDone) == 0x000068, "Wrong size on SasoriActiveAbility_HandleMeleeAttackDamageDone");
static_assert(offsetof(SasoriActiveAbility_HandleMeleeAttackDamageDone, Victim) == 0x000000, "Member 'SasoriActiveAbility_HandleMeleeAttackDamageDone::Victim' has a wrong offset!");
static_assert(offsetof(SasoriActiveAbility_HandleMeleeAttackDamageDone, ImpactPoint) == 0x000008, "Member 'SasoriActiveAbility_HandleMeleeAttackDamageDone::ImpactPoint' has a wrong offset!");
static_assert(offsetof(SasoriActiveAbility_HandleMeleeAttackDamageDone, ChargeLevel) == 0x000014, "Member 'SasoriActiveAbility_HandleMeleeAttackDamageDone::ChargeLevel' has a wrong offset!");
static_assert(offsetof(SasoriActiveAbility_HandleMeleeAttackDamageDone, DamageDone) == 0x000018, "Member 'SasoriActiveAbility_HandleMeleeAttackDamageDone::DamageDone' has a wrong offset!");
static_assert(offsetof(SasoriActiveAbility_HandleMeleeAttackDamageDone, ResultingHealthPercentage) == 0x00001C, "Member 'SasoriActiveAbility_HandleMeleeAttackDamageDone::ResultingHealthPercentage' has a wrong offset!");
static_assert(offsetof(SasoriActiveAbility_HandleMeleeAttackDamageDone, HitType) == 0x000020, "Member 'SasoriActiveAbility_HandleMeleeAttackDamageDone::HitType' has a wrong offset!");
static_assert(offsetof(SasoriActiveAbility_HandleMeleeAttackDamageDone, HitConfirmedData) == 0x000028, "Member 'SasoriActiveAbility_HandleMeleeAttackDamageDone::HitConfirmedData' has a wrong offset!");

// Function DeceiveInc.SasoriActiveAbility.HandleProjectileSpawnAndActivate
// 0x0010 (0x0010 - 0x0000)
struct SasoriActiveAbility_HandleProjectileSpawnAndActivate final
{
public:
	class ASpawnerWeapon*                         Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpawnerWeaponRound*                    Projectile;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SasoriActiveAbility_HandleProjectileSpawnAndActivate) == 0x000008, "Wrong alignment on SasoriActiveAbility_HandleProjectileSpawnAndActivate");
static_assert(sizeof(SasoriActiveAbility_HandleProjectileSpawnAndActivate) == 0x000010, "Wrong size on SasoriActiveAbility_HandleProjectileSpawnAndActivate");
static_assert(offsetof(SasoriActiveAbility_HandleProjectileSpawnAndActivate, Weapon) == 0x000000, "Member 'SasoriActiveAbility_HandleProjectileSpawnAndActivate::Weapon' has a wrong offset!");
static_assert(offsetof(SasoriActiveAbility_HandleProjectileSpawnAndActivate, Projectile) == 0x000008, "Member 'SasoriActiveAbility_HandleProjectileSpawnAndActivate::Projectile' has a wrong offset!");

// Function DeceiveInc.SasoriActiveAbility.HandleWeaponSpyToolEvent
// 0x0010 (0x0010 - 0x0000)
struct SasoriActiveAbility_HandleWeaponSpyToolEvent final
{
public:
	ESpyToolEvent                                 EventType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSpyTool*                           SpyTool;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SasoriActiveAbility_HandleWeaponSpyToolEvent) == 0x000008, "Wrong alignment on SasoriActiveAbility_HandleWeaponSpyToolEvent");
static_assert(sizeof(SasoriActiveAbility_HandleWeaponSpyToolEvent) == 0x000010, "Wrong size on SasoriActiveAbility_HandleWeaponSpyToolEvent");
static_assert(offsetof(SasoriActiveAbility_HandleWeaponSpyToolEvent, EventType) == 0x000000, "Member 'SasoriActiveAbility_HandleWeaponSpyToolEvent::EventType' has a wrong offset!");
static_assert(offsetof(SasoriActiveAbility_HandleWeaponSpyToolEvent, SpyTool) == 0x000008, "Member 'SasoriActiveAbility_HandleWeaponSpyToolEvent::SpyTool' has a wrong offset!");

// Function DeceiveInc.SasoriPassiveAbilityMod2.HandleMeleeAttackHit
// 0x0068 (0x0068 - 0x0000)
struct SasoriPassiveAbilityMod2_HandleMeleeAttackHit final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPoint;                                       // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChargeLevel;                                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageDone;                                        // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultingHealthPercentage;                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitType                                      HitType;                                           // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMeleeHitConfirmedData                 HitConfirmedData;                                  // 0x0028(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(SasoriPassiveAbilityMod2_HandleMeleeAttackHit) == 0x000008, "Wrong alignment on SasoriPassiveAbilityMod2_HandleMeleeAttackHit");
static_assert(sizeof(SasoriPassiveAbilityMod2_HandleMeleeAttackHit) == 0x000068, "Wrong size on SasoriPassiveAbilityMod2_HandleMeleeAttackHit");
static_assert(offsetof(SasoriPassiveAbilityMod2_HandleMeleeAttackHit, Victim) == 0x000000, "Member 'SasoriPassiveAbilityMod2_HandleMeleeAttackHit::Victim' has a wrong offset!");
static_assert(offsetof(SasoriPassiveAbilityMod2_HandleMeleeAttackHit, ImpactPoint) == 0x000008, "Member 'SasoriPassiveAbilityMod2_HandleMeleeAttackHit::ImpactPoint' has a wrong offset!");
static_assert(offsetof(SasoriPassiveAbilityMod2_HandleMeleeAttackHit, ChargeLevel) == 0x000014, "Member 'SasoriPassiveAbilityMod2_HandleMeleeAttackHit::ChargeLevel' has a wrong offset!");
static_assert(offsetof(SasoriPassiveAbilityMod2_HandleMeleeAttackHit, DamageDone) == 0x000018, "Member 'SasoriPassiveAbilityMod2_HandleMeleeAttackHit::DamageDone' has a wrong offset!");
static_assert(offsetof(SasoriPassiveAbilityMod2_HandleMeleeAttackHit, ResultingHealthPercentage) == 0x00001C, "Member 'SasoriPassiveAbilityMod2_HandleMeleeAttackHit::ResultingHealthPercentage' has a wrong offset!");
static_assert(offsetof(SasoriPassiveAbilityMod2_HandleMeleeAttackHit, HitType) == 0x000020, "Member 'SasoriPassiveAbilityMod2_HandleMeleeAttackHit::HitType' has a wrong offset!");
static_assert(offsetof(SasoriPassiveAbilityMod2_HandleMeleeAttackHit, HitConfirmedData) == 0x000028, "Member 'SasoriPassiveAbilityMod2_HandleMeleeAttackHit::HitConfirmedData' has a wrong offset!");

// Function DeceiveInc.SasoriPassiveAbilityMod2.HandleProjectileHit
// 0x0040 (0x0040 - 0x0000)
struct SasoriPassiveAbilityMod2_HandleProjectileHit final
{
public:
	struct FHitConfirmData                        HitConfirmData;                                    // 0x0000(0x0040)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(SasoriPassiveAbilityMod2_HandleProjectileHit) == 0x000008, "Wrong alignment on SasoriPassiveAbilityMod2_HandleProjectileHit");
static_assert(sizeof(SasoriPassiveAbilityMod2_HandleProjectileHit) == 0x000040, "Wrong size on SasoriPassiveAbilityMod2_HandleProjectileHit");
static_assert(offsetof(SasoriPassiveAbilityMod2_HandleProjectileHit, HitConfirmData) == 0x000000, "Member 'SasoriPassiveAbilityMod2_HandleProjectileHit::HitConfirmData' has a wrong offset!");

// Function DeceiveInc.SBAimAssistComponent.HandleBooleanPlayerSettingChange
// 0x0002 (0x0002 - 0x0000)
struct SBAimAssistComponent_HandleBooleanPlayerSettingChange final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewValue;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SBAimAssistComponent_HandleBooleanPlayerSettingChange) == 0x000001, "Wrong alignment on SBAimAssistComponent_HandleBooleanPlayerSettingChange");
static_assert(sizeof(SBAimAssistComponent_HandleBooleanPlayerSettingChange) == 0x000002, "Wrong size on SBAimAssistComponent_HandleBooleanPlayerSettingChange");
static_assert(offsetof(SBAimAssistComponent_HandleBooleanPlayerSettingChange, SettingType) == 0x000000, "Member 'SBAimAssistComponent_HandleBooleanPlayerSettingChange::SettingType' has a wrong offset!");
static_assert(offsetof(SBAimAssistComponent_HandleBooleanPlayerSettingChange, NewValue) == 0x000001, "Member 'SBAimAssistComponent_HandleBooleanPlayerSettingChange::NewValue' has a wrong offset!");

// Function DeceiveInc.SBAimAssistComponent.OnTargetDestroyed
// 0x0008 (0x0008 - 0x0000)
struct SBAimAssistComponent_OnTargetDestroyed final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SBAimAssistComponent_OnTargetDestroyed) == 0x000008, "Wrong alignment on SBAimAssistComponent_OnTargetDestroyed");
static_assert(sizeof(SBAimAssistComponent_OnTargetDestroyed) == 0x000008, "Wrong size on SBAimAssistComponent_OnTargetDestroyed");
static_assert(offsetof(SBAimAssistComponent_OnTargetDestroyed, DestroyedActor) == 0x000000, "Member 'SBAimAssistComponent_OnTargetDestroyed::DestroyedActor' has a wrong offset!");

// Function DeceiveInc.SBAimAssistComponent.SetAimAssistDataAsset
// 0x0008 (0x0008 - 0x0000)
struct SBAimAssistComponent_SetAimAssistDataAsset final
{
public:
	class USBAimAssistConfigDataAsset*            DataAsset;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SBAimAssistComponent_SetAimAssistDataAsset) == 0x000008, "Wrong alignment on SBAimAssistComponent_SetAimAssistDataAsset");
static_assert(sizeof(SBAimAssistComponent_SetAimAssistDataAsset) == 0x000008, "Wrong size on SBAimAssistComponent_SetAimAssistDataAsset");
static_assert(offsetof(SBAimAssistComponent_SetAimAssistDataAsset, DataAsset) == 0x000000, "Member 'SBAimAssistComponent_SetAimAssistDataAsset::DataAsset' has a wrong offset!");

// Function DeceiveInc.SBAimAssistComponent.SetAimAssistFactionID
// 0x0001 (0x0001 - 0x0000)
struct SBAimAssistComponent_SetAimAssistFactionID final
{
public:
	uint8                                         NewFactionID;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SBAimAssistComponent_SetAimAssistFactionID) == 0x000001, "Wrong alignment on SBAimAssistComponent_SetAimAssistFactionID");
static_assert(sizeof(SBAimAssistComponent_SetAimAssistFactionID) == 0x000001, "Wrong size on SBAimAssistComponent_SetAimAssistFactionID");
static_assert(offsetof(SBAimAssistComponent_SetAimAssistFactionID, NewFactionID) == 0x000000, "Member 'SBAimAssistComponent_SetAimAssistFactionID::NewFactionID' has a wrong offset!");

// Function DeceiveInc.SBAimAssistComponent.SetAimAssistInfluenceRatio
// 0x0004 (0x0004 - 0x0000)
struct SBAimAssistComponent_SetAimAssistInfluenceRatio final
{
public:
	float                                         Ratio;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SBAimAssistComponent_SetAimAssistInfluenceRatio) == 0x000004, "Wrong alignment on SBAimAssistComponent_SetAimAssistInfluenceRatio");
static_assert(sizeof(SBAimAssistComponent_SetAimAssistInfluenceRatio) == 0x000004, "Wrong size on SBAimAssistComponent_SetAimAssistInfluenceRatio");
static_assert(offsetof(SBAimAssistComponent_SetAimAssistInfluenceRatio, Ratio) == 0x000000, "Member 'SBAimAssistComponent_SetAimAssistInfluenceRatio::Ratio' has a wrong offset!");

// Function DeceiveInc.SBAimAssistComponent.SetAssistedControllerRotationSpeeds
// 0x0008 (0x0008 - 0x0000)
struct SBAimAssistComponent_SetAssistedControllerRotationSpeeds final
{
public:
	float                                         PitchSpeed;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawSpeed;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SBAimAssistComponent_SetAssistedControllerRotationSpeeds) == 0x000004, "Wrong alignment on SBAimAssistComponent_SetAssistedControllerRotationSpeeds");
static_assert(sizeof(SBAimAssistComponent_SetAssistedControllerRotationSpeeds) == 0x000008, "Wrong size on SBAimAssistComponent_SetAssistedControllerRotationSpeeds");
static_assert(offsetof(SBAimAssistComponent_SetAssistedControllerRotationSpeeds, PitchSpeed) == 0x000000, "Member 'SBAimAssistComponent_SetAssistedControllerRotationSpeeds::PitchSpeed' has a wrong offset!");
static_assert(offsetof(SBAimAssistComponent_SetAssistedControllerRotationSpeeds, YawSpeed) == 0x000004, "Member 'SBAimAssistComponent_SetAssistedControllerRotationSpeeds::YawSpeed' has a wrong offset!");

// Function DeceiveInc.SBAimAssistComponent.SetIgnoredActors
// 0x0050 (0x0050 - 0x0000)
struct SBAimAssistComponent_SetIgnoredActors final
{
public:
	TSet<class AActor*>                           ActorList;                                         // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SBAimAssistComponent_SetIgnoredActors) == 0x000008, "Wrong alignment on SBAimAssistComponent_SetIgnoredActors");
static_assert(sizeof(SBAimAssistComponent_SetIgnoredActors) == 0x000050, "Wrong size on SBAimAssistComponent_SetIgnoredActors");
static_assert(offsetof(SBAimAssistComponent_SetIgnoredActors, ActorList) == 0x000000, "Member 'SBAimAssistComponent_SetIgnoredActors::ActorList' has a wrong offset!");

// Function DeceiveInc.SBAimAssistComponent.SetMinimumTargetPriority
// 0x0004 (0x0004 - 0x0000)
struct SBAimAssistComponent_SetMinimumTargetPriority final
{
public:
	float                                         MinimumPriority;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SBAimAssistComponent_SetMinimumTargetPriority) == 0x000004, "Wrong alignment on SBAimAssistComponent_SetMinimumTargetPriority");
static_assert(sizeof(SBAimAssistComponent_SetMinimumTargetPriority) == 0x000004, "Wrong size on SBAimAssistComponent_SetMinimumTargetPriority");
static_assert(offsetof(SBAimAssistComponent_SetMinimumTargetPriority, MinimumPriority) == 0x000000, "Member 'SBAimAssistComponent_SetMinimumTargetPriority::MinimumPriority' has a wrong offset!");

// Function DeceiveInc.SBAimAssistComponent.GetCrosshairPosition
// 0x0008 (0x0008 - 0x0000)
struct SBAimAssistComponent_GetCrosshairPosition final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SBAimAssistComponent_GetCrosshairPosition) == 0x000004, "Wrong alignment on SBAimAssistComponent_GetCrosshairPosition");
static_assert(sizeof(SBAimAssistComponent_GetCrosshairPosition) == 0x000008, "Wrong size on SBAimAssistComponent_GetCrosshairPosition");
static_assert(offsetof(SBAimAssistComponent_GetCrosshairPosition, ReturnValue) == 0x000000, "Member 'SBAimAssistComponent_GetCrosshairPosition::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SBAimAssistComponent.GetCurrentTargetSocketLocation
// 0x0010 (0x0010 - 0x0000)
struct SBAimAssistComponent_GetCurrentTargetSocketLocation final
{
public:
	struct FVector                                OutLocation;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SBAimAssistComponent_GetCurrentTargetSocketLocation) == 0x000004, "Wrong alignment on SBAimAssistComponent_GetCurrentTargetSocketLocation");
static_assert(sizeof(SBAimAssistComponent_GetCurrentTargetSocketLocation) == 0x000010, "Wrong size on SBAimAssistComponent_GetCurrentTargetSocketLocation");
static_assert(offsetof(SBAimAssistComponent_GetCurrentTargetSocketLocation, OutLocation) == 0x000000, "Member 'SBAimAssistComponent_GetCurrentTargetSocketLocation::OutLocation' has a wrong offset!");
static_assert(offsetof(SBAimAssistComponent_GetCurrentTargetSocketLocation, ReturnValue) == 0x00000C, "Member 'SBAimAssistComponent_GetCurrentTargetSocketLocation::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SBAimAssistComponent.GetIgnoredActors
// 0x0050 (0x0050 - 0x0000)
struct SBAimAssistComponent_GetIgnoredActors final
{
public:
	TSet<class AActor*>                           ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SBAimAssistComponent_GetIgnoredActors) == 0x000008, "Wrong alignment on SBAimAssistComponent_GetIgnoredActors");
static_assert(sizeof(SBAimAssistComponent_GetIgnoredActors) == 0x000050, "Wrong size on SBAimAssistComponent_GetIgnoredActors");
static_assert(offsetof(SBAimAssistComponent_GetIgnoredActors, ReturnValue) == 0x000000, "Member 'SBAimAssistComponent_GetIgnoredActors::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SBAimAssistComponent.GetRotationToCrosshairDirection
// 0x0028 (0x0028 - 0x0000)
struct SBAimAssistComponent_GetRotationToCrosshairDirection final
{
public:
	struct FVector                                From;                                              // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TraceProfileName;                                  // 0x000C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistanceToRotateToTarget;                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x001C(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SBAimAssistComponent_GetRotationToCrosshairDirection) == 0x000004, "Wrong alignment on SBAimAssistComponent_GetRotationToCrosshairDirection");
static_assert(sizeof(SBAimAssistComponent_GetRotationToCrosshairDirection) == 0x000028, "Wrong size on SBAimAssistComponent_GetRotationToCrosshairDirection");
static_assert(offsetof(SBAimAssistComponent_GetRotationToCrosshairDirection, From) == 0x000000, "Member 'SBAimAssistComponent_GetRotationToCrosshairDirection::From' has a wrong offset!");
static_assert(offsetof(SBAimAssistComponent_GetRotationToCrosshairDirection, TraceProfileName) == 0x00000C, "Member 'SBAimAssistComponent_GetRotationToCrosshairDirection::TraceProfileName' has a wrong offset!");
static_assert(offsetof(SBAimAssistComponent_GetRotationToCrosshairDirection, MinDistanceToRotateToTarget) == 0x000014, "Member 'SBAimAssistComponent_GetRotationToCrosshairDirection::MinDistanceToRotateToTarget' has a wrong offset!");
static_assert(offsetof(SBAimAssistComponent_GetRotationToCrosshairDirection, Distance) == 0x000018, "Member 'SBAimAssistComponent_GetRotationToCrosshairDirection::Distance' has a wrong offset!");
static_assert(offsetof(SBAimAssistComponent_GetRotationToCrosshairDirection, ReturnValue) == 0x00001C, "Member 'SBAimAssistComponent_GetRotationToCrosshairDirection::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SBAimAssistTargetComponent.Init
// 0x0008 (0x0008 - 0x0000)
struct SBAimAssistTargetComponent_Init final
{
public:
	class UMeshComponent*                         Mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SBAimAssistTargetComponent_Init) == 0x000008, "Wrong alignment on SBAimAssistTargetComponent_Init");
static_assert(sizeof(SBAimAssistTargetComponent_Init) == 0x000008, "Wrong size on SBAimAssistTargetComponent_Init");
static_assert(offsetof(SBAimAssistTargetComponent_Init, Mesh) == 0x000000, "Member 'SBAimAssistTargetComponent_Init::Mesh' has a wrong offset!");

// Function DeceiveInc.SBAimAssistTargetComponent.SetTargetPriority
// 0x0004 (0x0004 - 0x0000)
struct SBAimAssistTargetComponent_SetTargetPriority final
{
public:
	float                                         NewPriority;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SBAimAssistTargetComponent_SetTargetPriority) == 0x000004, "Wrong alignment on SBAimAssistTargetComponent_SetTargetPriority");
static_assert(sizeof(SBAimAssistTargetComponent_SetTargetPriority) == 0x000004, "Wrong size on SBAimAssistTargetComponent_SetTargetPriority");
static_assert(offsetof(SBAimAssistTargetComponent_SetTargetPriority, NewPriority) == 0x000000, "Member 'SBAimAssistTargetComponent_SetTargetPriority::NewPriority' has a wrong offset!");

// Function DeceiveInc.SBAimAssistTargetComponent.GetTargetActivationRangeFactor
// 0x0004 (0x0004 - 0x0000)
struct SBAimAssistTargetComponent_GetTargetActivationRangeFactor final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SBAimAssistTargetComponent_GetTargetActivationRangeFactor) == 0x000004, "Wrong alignment on SBAimAssistTargetComponent_GetTargetActivationRangeFactor");
static_assert(sizeof(SBAimAssistTargetComponent_GetTargetActivationRangeFactor) == 0x000004, "Wrong size on SBAimAssistTargetComponent_GetTargetActivationRangeFactor");
static_assert(offsetof(SBAimAssistTargetComponent_GetTargetActivationRangeFactor, ReturnValue) == 0x000000, "Member 'SBAimAssistTargetComponent_GetTargetActivationRangeFactor::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SBAimAssistTargetComponent.GetTargetFactionID
// 0x0001 (0x0001 - 0x0000)
struct SBAimAssistTargetComponent_GetTargetFactionID final
{
public:
	uint8                                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SBAimAssistTargetComponent_GetTargetFactionID) == 0x000001, "Wrong alignment on SBAimAssistTargetComponent_GetTargetFactionID");
static_assert(sizeof(SBAimAssistTargetComponent_GetTargetFactionID) == 0x000001, "Wrong size on SBAimAssistTargetComponent_GetTargetFactionID");
static_assert(offsetof(SBAimAssistTargetComponent_GetTargetFactionID, ReturnValue) == 0x000000, "Member 'SBAimAssistTargetComponent_GetTargetFactionID::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SBAimAssistTargetComponent.GetTargetPriority
// 0x0004 (0x0004 - 0x0000)
struct SBAimAssistTargetComponent_GetTargetPriority final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SBAimAssistTargetComponent_GetTargetPriority) == 0x000004, "Wrong alignment on SBAimAssistTargetComponent_GetTargetPriority");
static_assert(sizeof(SBAimAssistTargetComponent_GetTargetPriority) == 0x000004, "Wrong size on SBAimAssistTargetComponent_GetTargetPriority");
static_assert(offsetof(SBAimAssistTargetComponent_GetTargetPriority, ReturnValue) == 0x000000, "Member 'SBAimAssistTargetComponent_GetTargetPriority::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SBShaderPrecompilerSubsytem.GetShaderPrecompileProgress
// 0x0004 (0x0004 - 0x0000)
struct SBShaderPrecompilerSubsytem_GetShaderPrecompileProgress final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SBShaderPrecompilerSubsytem_GetShaderPrecompileProgress) == 0x000004, "Wrong alignment on SBShaderPrecompilerSubsytem_GetShaderPrecompileProgress");
static_assert(sizeof(SBShaderPrecompilerSubsytem_GetShaderPrecompileProgress) == 0x000004, "Wrong size on SBShaderPrecompilerSubsytem_GetShaderPrecompileProgress");
static_assert(offsetof(SBShaderPrecompilerSubsytem_GetShaderPrecompileProgress, ReturnValue) == 0x000000, "Member 'SBShaderPrecompilerSubsytem_GetShaderPrecompileProgress::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SBShaderPrecompilerSubsytem.ShouldPrecompileShaders
// 0x0001 (0x0001 - 0x0000)
struct SBShaderPrecompilerSubsytem_ShouldPrecompileShaders final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SBShaderPrecompilerSubsytem_ShouldPrecompileShaders) == 0x000001, "Wrong alignment on SBShaderPrecompilerSubsytem_ShouldPrecompileShaders");
static_assert(sizeof(SBShaderPrecompilerSubsytem_ShouldPrecompileShaders) == 0x000001, "Wrong size on SBShaderPrecompilerSubsytem_ShouldPrecompileShaders");
static_assert(offsetof(SBShaderPrecompilerSubsytem_ShouldPrecompileShaders, ReturnValue) == 0x000000, "Member 'SBShaderPrecompilerSubsytem_ShouldPrecompileShaders::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SBShaderPrecompilerSubsytem.StartShaderPrecompilation
// 0x0001 (0x0001 - 0x0000)
struct SBShaderPrecompilerSubsytem_StartShaderPrecompilation final
{
public:
	bool                                          bShowMenu;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SBShaderPrecompilerSubsytem_StartShaderPrecompilation) == 0x000001, "Wrong alignment on SBShaderPrecompilerSubsytem_StartShaderPrecompilation");
static_assert(sizeof(SBShaderPrecompilerSubsytem_StartShaderPrecompilation) == 0x000001, "Wrong size on SBShaderPrecompilerSubsytem_StartShaderPrecompilation");
static_assert(offsetof(SBShaderPrecompilerSubsytem_StartShaderPrecompilation, bShowMenu) == 0x000000, "Member 'SBShaderPrecompilerSubsytem_StartShaderPrecompilation::bShowMenu' has a wrong offset!");

// Function DeceiveInc.ScanAuthorityComponent.NetMulticastCompleteScan
// 0x0018 (0x0018 - 0x0000)
struct ScanAuthorityComponent_NetMulticastCompleteScan final
{
public:
	class ABaseScannerTool*                       Scanner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScannableComponent*                    Scannable;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Interacter;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScanAuthorityComponent_NetMulticastCompleteScan) == 0x000008, "Wrong alignment on ScanAuthorityComponent_NetMulticastCompleteScan");
static_assert(sizeof(ScanAuthorityComponent_NetMulticastCompleteScan) == 0x000018, "Wrong size on ScanAuthorityComponent_NetMulticastCompleteScan");
static_assert(offsetof(ScanAuthorityComponent_NetMulticastCompleteScan, Scanner) == 0x000000, "Member 'ScanAuthorityComponent_NetMulticastCompleteScan::Scanner' has a wrong offset!");
static_assert(offsetof(ScanAuthorityComponent_NetMulticastCompleteScan, Scannable) == 0x000008, "Member 'ScanAuthorityComponent_NetMulticastCompleteScan::Scannable' has a wrong offset!");
static_assert(offsetof(ScanAuthorityComponent_NetMulticastCompleteScan, Interacter) == 0x000010, "Member 'ScanAuthorityComponent_NetMulticastCompleteScan::Interacter' has a wrong offset!");

// Function DeceiveInc.Scrambler.BP_OnToggleScrambler
// 0x0001 (0x0001 - 0x0000)
struct Scrambler_BP_OnToggleScrambler final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Scrambler_BP_OnToggleScrambler) == 0x000001, "Wrong alignment on Scrambler_BP_OnToggleScrambler");
static_assert(sizeof(Scrambler_BP_OnToggleScrambler) == 0x000001, "Wrong size on Scrambler_BP_OnToggleScrambler");
static_assert(offsetof(Scrambler_BP_OnToggleScrambler, bActive) == 0x000000, "Member 'Scrambler_BP_OnToggleScrambler::bActive' has a wrong offset!");

// Function DeceiveInc.Scrambler.HandleDetectionCollisionBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct Scrambler_HandleDetectionCollisionBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Scrambler_HandleDetectionCollisionBeginOverlap) == 0x000008, "Wrong alignment on Scrambler_HandleDetectionCollisionBeginOverlap");
static_assert(sizeof(Scrambler_HandleDetectionCollisionBeginOverlap) == 0x0000A8, "Wrong size on Scrambler_HandleDetectionCollisionBeginOverlap");
static_assert(offsetof(Scrambler_HandleDetectionCollisionBeginOverlap, OverlappedComponent) == 0x000000, "Member 'Scrambler_HandleDetectionCollisionBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(Scrambler_HandleDetectionCollisionBeginOverlap, OtherActor) == 0x000008, "Member 'Scrambler_HandleDetectionCollisionBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(Scrambler_HandleDetectionCollisionBeginOverlap, OtherComp) == 0x000010, "Member 'Scrambler_HandleDetectionCollisionBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(Scrambler_HandleDetectionCollisionBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'Scrambler_HandleDetectionCollisionBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(Scrambler_HandleDetectionCollisionBeginOverlap, bFromSweep) == 0x00001C, "Member 'Scrambler_HandleDetectionCollisionBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(Scrambler_HandleDetectionCollisionBeginOverlap, SweepResult) == 0x000020, "Member 'Scrambler_HandleDetectionCollisionBeginOverlap::SweepResult' has a wrong offset!");

// Function DeceiveInc.Scrambler.HandleDetectionCollisionEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct Scrambler_HandleDetectionCollisionEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Scrambler_HandleDetectionCollisionEndOverlap) == 0x000008, "Wrong alignment on Scrambler_HandleDetectionCollisionEndOverlap");
static_assert(sizeof(Scrambler_HandleDetectionCollisionEndOverlap) == 0x000020, "Wrong size on Scrambler_HandleDetectionCollisionEndOverlap");
static_assert(offsetof(Scrambler_HandleDetectionCollisionEndOverlap, OverlappedComponent) == 0x000000, "Member 'Scrambler_HandleDetectionCollisionEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(Scrambler_HandleDetectionCollisionEndOverlap, OtherActor) == 0x000008, "Member 'Scrambler_HandleDetectionCollisionEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(Scrambler_HandleDetectionCollisionEndOverlap, OtherComp) == 0x000010, "Member 'Scrambler_HandleDetectionCollisionEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(Scrambler_HandleDetectionCollisionEndOverlap, OtherBodyIndex) == 0x000018, "Member 'Scrambler_HandleDetectionCollisionEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function DeceiveInc.Scrambler.IsScrambleActive
// 0x0001 (0x0001 - 0x0000)
struct Scrambler_IsScrambleActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Scrambler_IsScrambleActive) == 0x000001, "Wrong alignment on Scrambler_IsScrambleActive");
static_assert(sizeof(Scrambler_IsScrambleActive) == 0x000001, "Wrong size on Scrambler_IsScrambleActive");
static_assert(offsetof(Scrambler_IsScrambleActive, ReturnValue) == 0x000000, "Member 'Scrambler_IsScrambleActive::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Scrambler.Multicast_ActivateScrambler
// 0x0001 (0x0001 - 0x0000)
struct Scrambler_Multicast_ActivateScrambler final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Scrambler_Multicast_ActivateScrambler) == 0x000001, "Wrong alignment on Scrambler_Multicast_ActivateScrambler");
static_assert(sizeof(Scrambler_Multicast_ActivateScrambler) == 0x000001, "Wrong size on Scrambler_Multicast_ActivateScrambler");
static_assert(offsetof(Scrambler_Multicast_ActivateScrambler, bActive) == 0x000000, "Member 'Scrambler_Multicast_ActivateScrambler::bActive' has a wrong offset!");

// Function DeceiveInc.Scrambler.Server_ActivateScrambler
// 0x0001 (0x0001 - 0x0000)
struct Scrambler_Server_ActivateScrambler final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Scrambler_Server_ActivateScrambler) == 0x000001, "Wrong alignment on Scrambler_Server_ActivateScrambler");
static_assert(sizeof(Scrambler_Server_ActivateScrambler) == 0x000001, "Wrong size on Scrambler_Server_ActivateScrambler");
static_assert(offsetof(Scrambler_Server_ActivateScrambler, bActive) == 0x000000, "Member 'Scrambler_Server_ActivateScrambler::bActive' has a wrong offset!");

// Function DeceiveInc.ScramblerTool.BP_OnToggleInHandScrambler
// 0x0002 (0x0002 - 0x0000)
struct ScramblerTool_BP_OnToggleInHandScrambler final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSendBPEvent;                                      // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScramblerTool_BP_OnToggleInHandScrambler) == 0x000001, "Wrong alignment on ScramblerTool_BP_OnToggleInHandScrambler");
static_assert(sizeof(ScramblerTool_BP_OnToggleInHandScrambler) == 0x000002, "Wrong size on ScramblerTool_BP_OnToggleInHandScrambler");
static_assert(offsetof(ScramblerTool_BP_OnToggleInHandScrambler, bActive) == 0x000000, "Member 'ScramblerTool_BP_OnToggleInHandScrambler::bActive' has a wrong offset!");
static_assert(offsetof(ScramblerTool_BP_OnToggleInHandScrambler, bSendBPEvent) == 0x000001, "Member 'ScramblerTool_BP_OnToggleInHandScrambler::bSendBPEvent' has a wrong offset!");

// Function DeceiveInc.ScramblerTool.HandleDetectionCollisionBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct ScramblerTool_HandleDetectionCollisionBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScramblerTool_HandleDetectionCollisionBeginOverlap) == 0x000008, "Wrong alignment on ScramblerTool_HandleDetectionCollisionBeginOverlap");
static_assert(sizeof(ScramblerTool_HandleDetectionCollisionBeginOverlap) == 0x0000A8, "Wrong size on ScramblerTool_HandleDetectionCollisionBeginOverlap");
static_assert(offsetof(ScramblerTool_HandleDetectionCollisionBeginOverlap, OverlappedComponent) == 0x000000, "Member 'ScramblerTool_HandleDetectionCollisionBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(ScramblerTool_HandleDetectionCollisionBeginOverlap, OtherActor) == 0x000008, "Member 'ScramblerTool_HandleDetectionCollisionBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(ScramblerTool_HandleDetectionCollisionBeginOverlap, OtherComp) == 0x000010, "Member 'ScramblerTool_HandleDetectionCollisionBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(ScramblerTool_HandleDetectionCollisionBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'ScramblerTool_HandleDetectionCollisionBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(ScramblerTool_HandleDetectionCollisionBeginOverlap, bFromSweep) == 0x00001C, "Member 'ScramblerTool_HandleDetectionCollisionBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(ScramblerTool_HandleDetectionCollisionBeginOverlap, SweepResult) == 0x000020, "Member 'ScramblerTool_HandleDetectionCollisionBeginOverlap::SweepResult' has a wrong offset!");

// Function DeceiveInc.ScramblerTool.HandleDetectionCollisionEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct ScramblerTool_HandleDetectionCollisionEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ScramblerTool_HandleDetectionCollisionEndOverlap) == 0x000008, "Wrong alignment on ScramblerTool_HandleDetectionCollisionEndOverlap");
static_assert(sizeof(ScramblerTool_HandleDetectionCollisionEndOverlap) == 0x000020, "Wrong size on ScramblerTool_HandleDetectionCollisionEndOverlap");
static_assert(offsetof(ScramblerTool_HandleDetectionCollisionEndOverlap, OverlappedComponent) == 0x000000, "Member 'ScramblerTool_HandleDetectionCollisionEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(ScramblerTool_HandleDetectionCollisionEndOverlap, OtherActor) == 0x000008, "Member 'ScramblerTool_HandleDetectionCollisionEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(ScramblerTool_HandleDetectionCollisionEndOverlap, OtherComp) == 0x000010, "Member 'ScramblerTool_HandleDetectionCollisionEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(ScramblerTool_HandleDetectionCollisionEndOverlap, OtherBodyIndex) == 0x000018, "Member 'ScramblerTool_HandleDetectionCollisionEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function DeceiveInc.ScramblerTool.IsScramblerToolActive
// 0x0001 (0x0001 - 0x0000)
struct ScramblerTool_IsScramblerToolActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScramblerTool_IsScramblerToolActive) == 0x000001, "Wrong alignment on ScramblerTool_IsScramblerToolActive");
static_assert(sizeof(ScramblerTool_IsScramblerToolActive) == 0x000001, "Wrong size on ScramblerTool_IsScramblerToolActive");
static_assert(offsetof(ScramblerTool_IsScramblerToolActive, ReturnValue) == 0x000000, "Member 'ScramblerTool_IsScramblerToolActive::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ScramblerTool.NetMulticast_ToggleInHandScrambler
// 0x0001 (0x0001 - 0x0000)
struct ScramblerTool_NetMulticast_ToggleInHandScrambler final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScramblerTool_NetMulticast_ToggleInHandScrambler) == 0x000001, "Wrong alignment on ScramblerTool_NetMulticast_ToggleInHandScrambler");
static_assert(sizeof(ScramblerTool_NetMulticast_ToggleInHandScrambler) == 0x000001, "Wrong size on ScramblerTool_NetMulticast_ToggleInHandScrambler");
static_assert(offsetof(ScramblerTool_NetMulticast_ToggleInHandScrambler, bActive) == 0x000000, "Member 'ScramblerTool_NetMulticast_ToggleInHandScrambler::bActive' has a wrong offset!");

// Function DeceiveInc.ScramblerTool.Server_ToggleInHandScrambler
// 0x0001 (0x0001 - 0x0000)
struct ScramblerTool_Server_ToggleInHandScrambler final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScramblerTool_Server_ToggleInHandScrambler) == 0x000001, "Wrong alignment on ScramblerTool_Server_ToggleInHandScrambler");
static_assert(sizeof(ScramblerTool_Server_ToggleInHandScrambler) == 0x000001, "Wrong size on ScramblerTool_Server_ToggleInHandScrambler");
static_assert(offsetof(ScramblerTool_Server_ToggleInHandScrambler, bActive) == 0x000000, "Member 'ScramblerTool_Server_ToggleInHandScrambler::bActive' has a wrong offset!");

// Function DeceiveInc.ScriptedBotBrain.OnFightTargetLost
// 0x0010 (0x0010 - 0x0000)
struct ScriptedBotBrain_OnFightTargetLost final
{
public:
	class UBotPlanFight*                          BotPlanFight;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   LostTarget;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScriptedBotBrain_OnFightTargetLost) == 0x000008, "Wrong alignment on ScriptedBotBrain_OnFightTargetLost");
static_assert(sizeof(ScriptedBotBrain_OnFightTargetLost) == 0x000010, "Wrong size on ScriptedBotBrain_OnFightTargetLost");
static_assert(offsetof(ScriptedBotBrain_OnFightTargetLost, BotPlanFight) == 0x000000, "Member 'ScriptedBotBrain_OnFightTargetLost::BotPlanFight' has a wrong offset!");
static_assert(offsetof(ScriptedBotBrain_OnFightTargetLost, LostTarget) == 0x000008, "Member 'ScriptedBotBrain_OnFightTargetLost::LostTarget' has a wrong offset!");

// Function DeceiveInc.ScriptedBotBrain.OnUndercoverChange
// 0x0001 (0x0001 - 0x0000)
struct ScriptedBotBrain_OnUndercoverChange final
{
public:
	bool                                          bUndercover;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScriptedBotBrain_OnUndercoverChange) == 0x000001, "Wrong alignment on ScriptedBotBrain_OnUndercoverChange");
static_assert(sizeof(ScriptedBotBrain_OnUndercoverChange) == 0x000001, "Wrong size on ScriptedBotBrain_OnUndercoverChange");
static_assert(offsetof(ScriptedBotBrain_OnUndercoverChange, bUndercover) == 0x000000, "Member 'ScriptedBotBrain_OnUndercoverChange::bUndercover' has a wrong offset!");

// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleChargeAmountChange
// 0x0004 (0x0004 - 0x0000)
struct ShieldbrellaSpawnerWeapon_HandleChargeAmountChange final
{
public:
	int32                                         Amount;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ShieldbrellaSpawnerWeapon_HandleChargeAmountChange) == 0x000004, "Wrong alignment on ShieldbrellaSpawnerWeapon_HandleChargeAmountChange");
static_assert(sizeof(ShieldbrellaSpawnerWeapon_HandleChargeAmountChange) == 0x000004, "Wrong size on ShieldbrellaSpawnerWeapon_HandleChargeAmountChange");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleChargeAmountChange, Amount) == 0x000000, "Member 'ShieldbrellaSpawnerWeapon_HandleChargeAmountChange::Amount' has a wrong offset!");

// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleCooldownChange
// 0x0001 (0x0001 - 0x0000)
struct ShieldbrellaSpawnerWeapon_HandleCooldownChange final
{
public:
	bool                                          bOnCooldown;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ShieldbrellaSpawnerWeapon_HandleCooldownChange) == 0x000001, "Wrong alignment on ShieldbrellaSpawnerWeapon_HandleCooldownChange");
static_assert(sizeof(ShieldbrellaSpawnerWeapon_HandleCooldownChange) == 0x000001, "Wrong size on ShieldbrellaSpawnerWeapon_HandleCooldownChange");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleCooldownChange, bOnCooldown) == 0x000000, "Member 'ShieldbrellaSpawnerWeapon_HandleCooldownChange::bOnCooldown' has a wrong offset!");

// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleDeath
// 0x0008 (0x0008 - 0x0000)
struct ShieldbrellaSpawnerWeapon_HandleDeath final
{
public:
	class AActor*                                 DeadActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ShieldbrellaSpawnerWeapon_HandleDeath) == 0x000008, "Wrong alignment on ShieldbrellaSpawnerWeapon_HandleDeath");
static_assert(sizeof(ShieldbrellaSpawnerWeapon_HandleDeath) == 0x000008, "Wrong size on ShieldbrellaSpawnerWeapon_HandleDeath");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleDeath, DeadActor) == 0x000000, "Member 'ShieldbrellaSpawnerWeapon_HandleDeath::DeadActor' has a wrong offset!");

// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleDeployedShieldActorDestroyed
// 0x0008 (0x0008 - 0x0000)
struct ShieldbrellaSpawnerWeapon_HandleDeployedShieldActorDestroyed final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ShieldbrellaSpawnerWeapon_HandleDeployedShieldActorDestroyed) == 0x000008, "Wrong alignment on ShieldbrellaSpawnerWeapon_HandleDeployedShieldActorDestroyed");
static_assert(sizeof(ShieldbrellaSpawnerWeapon_HandleDeployedShieldActorDestroyed) == 0x000008, "Wrong size on ShieldbrellaSpawnerWeapon_HandleDeployedShieldActorDestroyed");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleDeployedShieldActorDestroyed, DestroyedActor) == 0x000000, "Member 'ShieldbrellaSpawnerWeapon_HandleDeployedShieldActorDestroyed::DestroyedActor' has a wrong offset!");

// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleDeployedShieldHealthChange
// 0x0030 (0x0030 - 0x0000)
struct ShieldbrellaSpawnerWeapon_HandleDeployedShieldHealthChange final
{
public:
	class UHealthComponent*                       OwningHealthComp;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthDelta;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDamageType*                      DamageType;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RawDamage;                                         // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ShieldbrellaSpawnerWeapon_HandleDeployedShieldHealthChange) == 0x000008, "Wrong alignment on ShieldbrellaSpawnerWeapon_HandleDeployedShieldHealthChange");
static_assert(sizeof(ShieldbrellaSpawnerWeapon_HandleDeployedShieldHealthChange) == 0x000030, "Wrong size on ShieldbrellaSpawnerWeapon_HandleDeployedShieldHealthChange");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleDeployedShieldHealthChange, OwningHealthComp) == 0x000000, "Member 'ShieldbrellaSpawnerWeapon_HandleDeployedShieldHealthChange::OwningHealthComp' has a wrong offset!");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleDeployedShieldHealthChange, Health) == 0x000008, "Member 'ShieldbrellaSpawnerWeapon_HandleDeployedShieldHealthChange::Health' has a wrong offset!");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleDeployedShieldHealthChange, HealthDelta) == 0x00000C, "Member 'ShieldbrellaSpawnerWeapon_HandleDeployedShieldHealthChange::HealthDelta' has a wrong offset!");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleDeployedShieldHealthChange, DamageType) == 0x000010, "Member 'ShieldbrellaSpawnerWeapon_HandleDeployedShieldHealthChange::DamageType' has a wrong offset!");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleDeployedShieldHealthChange, InstigatedBy) == 0x000018, "Member 'ShieldbrellaSpawnerWeapon_HandleDeployedShieldHealthChange::InstigatedBy' has a wrong offset!");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleDeployedShieldHealthChange, DamageCauser) == 0x000020, "Member 'ShieldbrellaSpawnerWeapon_HandleDeployedShieldHealthChange::DamageCauser' has a wrong offset!");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleDeployedShieldHealthChange, RawDamage) == 0x000028, "Member 'ShieldbrellaSpawnerWeapon_HandleDeployedShieldHealthChange::RawDamage' has a wrong offset!");

// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleDeployedShieldInteractionComplete
// 0x0010 (0x0010 - 0x0000)
struct ShieldbrellaSpawnerWeapon_HandleDeployedShieldInteractionComplete final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ShieldbrellaSpawnerWeapon_HandleDeployedShieldInteractionComplete) == 0x000008, "Wrong alignment on ShieldbrellaSpawnerWeapon_HandleDeployedShieldInteractionComplete");
static_assert(sizeof(ShieldbrellaSpawnerWeapon_HandleDeployedShieldInteractionComplete) == 0x000010, "Wrong size on ShieldbrellaSpawnerWeapon_HandleDeployedShieldInteractionComplete");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleDeployedShieldInteractionComplete, Interacter) == 0x000000, "Member 'ShieldbrellaSpawnerWeapon_HandleDeployedShieldInteractionComplete::Interacter' has a wrong offset!");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleDeployedShieldInteractionComplete, Interactable) == 0x000008, "Member 'ShieldbrellaSpawnerWeapon_HandleDeployedShieldInteractionComplete::Interactable' has a wrong offset!");

// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleDeployedShieldSpawned
// 0x0008 (0x0008 - 0x0000)
struct ShieldbrellaSpawnerWeapon_HandleDeployedShieldSpawned final
{
public:
	class ABasePlaceable*                         NewPlaceable;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ShieldbrellaSpawnerWeapon_HandleDeployedShieldSpawned) == 0x000008, "Wrong alignment on ShieldbrellaSpawnerWeapon_HandleDeployedShieldSpawned");
static_assert(sizeof(ShieldbrellaSpawnerWeapon_HandleDeployedShieldSpawned) == 0x000008, "Wrong size on ShieldbrellaSpawnerWeapon_HandleDeployedShieldSpawned");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleDeployedShieldSpawned, NewPlaceable) == 0x000000, "Member 'ShieldbrellaSpawnerWeapon_HandleDeployedShieldSpawned::NewPlaceable' has a wrong offset!");

// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleHealthChanged
// 0x0030 (0x0030 - 0x0000)
struct ShieldbrellaSpawnerWeapon_HandleHealthChanged final
{
public:
	class UHealthComponent*                       OwningHealthComp;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthDelta;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDamageType*                      DamageType;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RawDamage;                                         // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ShieldbrellaSpawnerWeapon_HandleHealthChanged) == 0x000008, "Wrong alignment on ShieldbrellaSpawnerWeapon_HandleHealthChanged");
static_assert(sizeof(ShieldbrellaSpawnerWeapon_HandleHealthChanged) == 0x000030, "Wrong size on ShieldbrellaSpawnerWeapon_HandleHealthChanged");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleHealthChanged, OwningHealthComp) == 0x000000, "Member 'ShieldbrellaSpawnerWeapon_HandleHealthChanged::OwningHealthComp' has a wrong offset!");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleHealthChanged, Health) == 0x000008, "Member 'ShieldbrellaSpawnerWeapon_HandleHealthChanged::Health' has a wrong offset!");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleHealthChanged, HealthDelta) == 0x00000C, "Member 'ShieldbrellaSpawnerWeapon_HandleHealthChanged::HealthDelta' has a wrong offset!");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleHealthChanged, DamageType) == 0x000010, "Member 'ShieldbrellaSpawnerWeapon_HandleHealthChanged::DamageType' has a wrong offset!");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleHealthChanged, InstigatedBy) == 0x000018, "Member 'ShieldbrellaSpawnerWeapon_HandleHealthChanged::InstigatedBy' has a wrong offset!");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleHealthChanged, DamageCauser) == 0x000020, "Member 'ShieldbrellaSpawnerWeapon_HandleHealthChanged::DamageCauser' has a wrong offset!");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleHealthChanged, RawDamage) == 0x000028, "Member 'ShieldbrellaSpawnerWeapon_HandleHealthChanged::RawDamage' has a wrong offset!");

// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleLocalInteractionStart
// 0x0010 (0x0010 - 0x0000)
struct ShieldbrellaSpawnerWeapon_HandleLocalInteractionStart final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ShieldbrellaSpawnerWeapon_HandleLocalInteractionStart) == 0x000008, "Wrong alignment on ShieldbrellaSpawnerWeapon_HandleLocalInteractionStart");
static_assert(sizeof(ShieldbrellaSpawnerWeapon_HandleLocalInteractionStart) == 0x000010, "Wrong size on ShieldbrellaSpawnerWeapon_HandleLocalInteractionStart");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleLocalInteractionStart, Interacter) == 0x000000, "Member 'ShieldbrellaSpawnerWeapon_HandleLocalInteractionStart::Interacter' has a wrong offset!");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleLocalInteractionStart, Interactable) == 0x000008, "Member 'ShieldbrellaSpawnerWeapon_HandleLocalInteractionStart::Interactable' has a wrong offset!");

// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleResourceNewAmount
// 0x0028 (0x0028 - 0x0000)
struct ShieldbrellaSpawnerWeapon_HandleResourceNewAmount final
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ResourceDisplayName;                               // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ShieldbrellaSpawnerWeapon_HandleResourceNewAmount) == 0x000008, "Wrong alignment on ShieldbrellaSpawnerWeapon_HandleResourceNewAmount");
static_assert(sizeof(ShieldbrellaSpawnerWeapon_HandleResourceNewAmount) == 0x000028, "Wrong size on ShieldbrellaSpawnerWeapon_HandleResourceNewAmount");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleResourceNewAmount, ResourceType) == 0x000000, "Member 'ShieldbrellaSpawnerWeapon_HandleResourceNewAmount::ResourceType' has a wrong offset!");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleResourceNewAmount, ResourceDisplayName) == 0x000008, "Member 'ShieldbrellaSpawnerWeapon_HandleResourceNewAmount::ResourceDisplayName' has a wrong offset!");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleResourceNewAmount, Amount) == 0x000020, "Member 'ShieldbrellaSpawnerWeapon_HandleResourceNewAmount::Amount' has a wrong offset!");

// Function DeceiveInc.ShieldbrellaSpawnerWeapon.HandleWeaponShot
// 0x0008 (0x0008 - 0x0000)
struct ShieldbrellaSpawnerWeapon_HandleWeaponShot final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ShieldbrellaSpawnerWeapon_HandleWeaponShot) == 0x000008, "Wrong alignment on ShieldbrellaSpawnerWeapon_HandleWeaponShot");
static_assert(sizeof(ShieldbrellaSpawnerWeapon_HandleWeaponShot) == 0x000008, "Wrong size on ShieldbrellaSpawnerWeapon_HandleWeaponShot");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_HandleWeaponShot, Spy) == 0x000000, "Member 'ShieldbrellaSpawnerWeapon_HandleWeaponShot::Spy' has a wrong offset!");

// Function DeceiveInc.ShieldbrellaSpawnerWeapon.Multicast_Bump
// 0x0018 (0x0018 - 0x0000)
struct ShieldbrellaSpawnerWeapon_Multicast_Bump final
{
public:
	class AActor*                                 BumpActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    BumpImpulse;                                       // 0x0008(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ShieldbrellaSpawnerWeapon_Multicast_Bump) == 0x000008, "Wrong alignment on ShieldbrellaSpawnerWeapon_Multicast_Bump");
static_assert(sizeof(ShieldbrellaSpawnerWeapon_Multicast_Bump) == 0x000018, "Wrong size on ShieldbrellaSpawnerWeapon_Multicast_Bump");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_Multicast_Bump, BumpActor) == 0x000000, "Member 'ShieldbrellaSpawnerWeapon_Multicast_Bump::BumpActor' has a wrong offset!");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_Multicast_Bump, BumpImpulse) == 0x000008, "Member 'ShieldbrellaSpawnerWeapon_Multicast_Bump::BumpImpulse' has a wrong offset!");

// Function DeceiveInc.ShieldbrellaSpawnerWeapon.Server_ForceDamage
// 0x0028 (0x0028 - 0x0000)
struct ShieldbrellaSpawnerWeapon_Server_ForceDamage final
{
public:
	float                                         DamageAmount;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDamageEvent                           DamageEvent;                                       // 0x0008(0x0010)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	class AController*                            EventInstigator;                                   // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCause;                                       // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ShieldbrellaSpawnerWeapon_Server_ForceDamage) == 0x000008, "Wrong alignment on ShieldbrellaSpawnerWeapon_Server_ForceDamage");
static_assert(sizeof(ShieldbrellaSpawnerWeapon_Server_ForceDamage) == 0x000028, "Wrong size on ShieldbrellaSpawnerWeapon_Server_ForceDamage");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_Server_ForceDamage, DamageAmount) == 0x000000, "Member 'ShieldbrellaSpawnerWeapon_Server_ForceDamage::DamageAmount' has a wrong offset!");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_Server_ForceDamage, DamageEvent) == 0x000008, "Member 'ShieldbrellaSpawnerWeapon_Server_ForceDamage::DamageEvent' has a wrong offset!");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_Server_ForceDamage, EventInstigator) == 0x000018, "Member 'ShieldbrellaSpawnerWeapon_Server_ForceDamage::EventInstigator' has a wrong offset!");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_Server_ForceDamage, DamageCause) == 0x000020, "Member 'ShieldbrellaSpawnerWeapon_Server_ForceDamage::DamageCause' has a wrong offset!");

// Function DeceiveInc.ShieldbrellaSpawnerWeapon.Server_OnShieldbrellaOpen
// 0x0001 (0x0001 - 0x0000)
struct ShieldbrellaSpawnerWeapon_Server_OnShieldbrellaOpen final
{
public:
	bool                                          bIsOpen;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ShieldbrellaSpawnerWeapon_Server_OnShieldbrellaOpen) == 0x000001, "Wrong alignment on ShieldbrellaSpawnerWeapon_Server_OnShieldbrellaOpen");
static_assert(sizeof(ShieldbrellaSpawnerWeapon_Server_OnShieldbrellaOpen) == 0x000001, "Wrong size on ShieldbrellaSpawnerWeapon_Server_OnShieldbrellaOpen");
static_assert(offsetof(ShieldbrellaSpawnerWeapon_Server_OnShieldbrellaOpen, bIsOpen) == 0x000000, "Member 'ShieldbrellaSpawnerWeapon_Server_OnShieldbrellaOpen::bIsOpen' has a wrong offset!");

// Function DeceiveInc.SmokeGrenadeProjectileComponent.OnProjectileHit
// 0x0094 (0x0094 - 0x0000)
struct SmokeGrenadeProjectileComponent_OnProjectileHit final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                HitDirection;                                      // 0x0088(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmokeGrenadeProjectileComponent_OnProjectileHit) == 0x000004, "Wrong alignment on SmokeGrenadeProjectileComponent_OnProjectileHit");
static_assert(sizeof(SmokeGrenadeProjectileComponent_OnProjectileHit) == 0x000094, "Wrong size on SmokeGrenadeProjectileComponent_OnProjectileHit");
static_assert(offsetof(SmokeGrenadeProjectileComponent_OnProjectileHit, Hit) == 0x000000, "Member 'SmokeGrenadeProjectileComponent_OnProjectileHit::Hit' has a wrong offset!");
static_assert(offsetof(SmokeGrenadeProjectileComponent_OnProjectileHit, HitDirection) == 0x000088, "Member 'SmokeGrenadeProjectileComponent_OnProjectileHit::HitDirection' has a wrong offset!");

// Function DeceiveInc.SmokeZoneActor.HandleSpyUndercoverChanged
// 0x0010 (0x0010 - 0x0000)
struct SmokeZoneActor_HandleSpyUndercoverChanged final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUndercover;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SmokeZoneActor_HandleSpyUndercoverChanged) == 0x000008, "Wrong alignment on SmokeZoneActor_HandleSpyUndercoverChanged");
static_assert(sizeof(SmokeZoneActor_HandleSpyUndercoverChanged) == 0x000010, "Wrong size on SmokeZoneActor_HandleSpyUndercoverChanged");
static_assert(offsetof(SmokeZoneActor_HandleSpyUndercoverChanged, Spy) == 0x000000, "Member 'SmokeZoneActor_HandleSpyUndercoverChanged::Spy' has a wrong offset!");
static_assert(offsetof(SmokeZoneActor_HandleSpyUndercoverChanged, bUndercover) == 0x000008, "Member 'SmokeZoneActor_HandleSpyUndercoverChanged::bUndercover' has a wrong offset!");

// Function DeceiveInc.SmokeZoneActor.OnCollisionBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct SmokeZoneActor_OnCollisionBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmokeZoneActor_OnCollisionBeginOverlap) == 0x000008, "Wrong alignment on SmokeZoneActor_OnCollisionBeginOverlap");
static_assert(sizeof(SmokeZoneActor_OnCollisionBeginOverlap) == 0x0000A8, "Wrong size on SmokeZoneActor_OnCollisionBeginOverlap");
static_assert(offsetof(SmokeZoneActor_OnCollisionBeginOverlap, OverlappedComponent) == 0x000000, "Member 'SmokeZoneActor_OnCollisionBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(SmokeZoneActor_OnCollisionBeginOverlap, OtherActor) == 0x000008, "Member 'SmokeZoneActor_OnCollisionBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(SmokeZoneActor_OnCollisionBeginOverlap, OtherComp) == 0x000010, "Member 'SmokeZoneActor_OnCollisionBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(SmokeZoneActor_OnCollisionBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'SmokeZoneActor_OnCollisionBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(SmokeZoneActor_OnCollisionBeginOverlap, bFromSweep) == 0x00001C, "Member 'SmokeZoneActor_OnCollisionBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(SmokeZoneActor_OnCollisionBeginOverlap, SweepResult) == 0x000020, "Member 'SmokeZoneActor_OnCollisionBeginOverlap::SweepResult' has a wrong offset!");

// Function DeceiveInc.SmokeZoneActor.OnCollisionEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct SmokeZoneActor_OnCollisionEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SmokeZoneActor_OnCollisionEndOverlap) == 0x000008, "Wrong alignment on SmokeZoneActor_OnCollisionEndOverlap");
static_assert(sizeof(SmokeZoneActor_OnCollisionEndOverlap) == 0x000020, "Wrong size on SmokeZoneActor_OnCollisionEndOverlap");
static_assert(offsetof(SmokeZoneActor_OnCollisionEndOverlap, OverlappedComponent) == 0x000000, "Member 'SmokeZoneActor_OnCollisionEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(SmokeZoneActor_OnCollisionEndOverlap, OtherActor) == 0x000008, "Member 'SmokeZoneActor_OnCollisionEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(SmokeZoneActor_OnCollisionEndOverlap, OtherComp) == 0x000010, "Member 'SmokeZoneActor_OnCollisionEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(SmokeZoneActor_OnCollisionEndOverlap, OtherBodyIndex) == 0x000018, "Member 'SmokeZoneActor_OnCollisionEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function DeceiveInc.SocialiteActiveAbility.BP_OnSocialiteActiveConeAttack
// 0x0020 (0x0020 - 0x0000)
struct SocialiteActiveAbility_BP_OnSocialiteActiveConeAttack final
{
public:
	struct FVector                                OriginPos;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeLength;                                        // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeAngle;                                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialiteActiveAbility_BP_OnSocialiteActiveConeAttack) == 0x000004, "Wrong alignment on SocialiteActiveAbility_BP_OnSocialiteActiveConeAttack");
static_assert(sizeof(SocialiteActiveAbility_BP_OnSocialiteActiveConeAttack) == 0x000020, "Wrong size on SocialiteActiveAbility_BP_OnSocialiteActiveConeAttack");
static_assert(offsetof(SocialiteActiveAbility_BP_OnSocialiteActiveConeAttack, OriginPos) == 0x000000, "Member 'SocialiteActiveAbility_BP_OnSocialiteActiveConeAttack::OriginPos' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbility_BP_OnSocialiteActiveConeAttack, Normal) == 0x00000C, "Member 'SocialiteActiveAbility_BP_OnSocialiteActiveConeAttack::Normal' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbility_BP_OnSocialiteActiveConeAttack, ConeLength) == 0x000018, "Member 'SocialiteActiveAbility_BP_OnSocialiteActiveConeAttack::ConeLength' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbility_BP_OnSocialiteActiveConeAttack, ConeAngle) == 0x00001C, "Member 'SocialiteActiveAbility_BP_OnSocialiteActiveConeAttack::ConeAngle' has a wrong offset!");

// Function DeceiveInc.SocialiteActiveAbility.BP_OnSocialiteActiveConeAttackLocal
// 0x0020 (0x0020 - 0x0000)
struct SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackLocal final
{
public:
	struct FVector                                OriginPos;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeLength;                                        // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeAngle;                                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackLocal) == 0x000004, "Wrong alignment on SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackLocal");
static_assert(sizeof(SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackLocal) == 0x000020, "Wrong size on SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackLocal");
static_assert(offsetof(SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackLocal, OriginPos) == 0x000000, "Member 'SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackLocal::OriginPos' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackLocal, Normal) == 0x00000C, "Member 'SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackLocal::Normal' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackLocal, ConeLength) == 0x000018, "Member 'SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackLocal::ConeLength' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackLocal, ConeAngle) == 0x00001C, "Member 'SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackLocal::ConeAngle' has a wrong offset!");

// Function DeceiveInc.SocialiteActiveAbility.BP_OnSocialiteActiveConeAttackReplicated
// 0x0020 (0x0020 - 0x0000)
struct SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackReplicated final
{
public:
	struct FVector                                OriginPos;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeLength;                                        // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeAngle;                                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackReplicated) == 0x000004, "Wrong alignment on SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackReplicated");
static_assert(sizeof(SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackReplicated) == 0x000020, "Wrong size on SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackReplicated");
static_assert(offsetof(SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackReplicated, OriginPos) == 0x000000, "Member 'SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackReplicated::OriginPos' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackReplicated, Normal) == 0x00000C, "Member 'SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackReplicated::Normal' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackReplicated, ConeLength) == 0x000018, "Member 'SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackReplicated::ConeLength' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackReplicated, ConeAngle) == 0x00001C, "Member 'SocialiteActiveAbility_BP_OnSocialiteActiveConeAttackReplicated::ConeAngle' has a wrong offset!");

// Function DeceiveInc.SocialiteActiveAbility.BP_OnSocialiteActiveEffectHit
// 0x0020 (0x0020 - 0x0000)
struct SocialiteActiveAbility_BP_OnSocialiteActiveEffectHit final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPoint;                                       // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactNormal;                                      // 0x0014(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialiteActiveAbility_BP_OnSocialiteActiveEffectHit) == 0x000008, "Wrong alignment on SocialiteActiveAbility_BP_OnSocialiteActiveEffectHit");
static_assert(sizeof(SocialiteActiveAbility_BP_OnSocialiteActiveEffectHit) == 0x000020, "Wrong size on SocialiteActiveAbility_BP_OnSocialiteActiveEffectHit");
static_assert(offsetof(SocialiteActiveAbility_BP_OnSocialiteActiveEffectHit, Victim) == 0x000000, "Member 'SocialiteActiveAbility_BP_OnSocialiteActiveEffectHit::Victim' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbility_BP_OnSocialiteActiveEffectHit, ImpactPoint) == 0x000008, "Member 'SocialiteActiveAbility_BP_OnSocialiteActiveEffectHit::ImpactPoint' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbility_BP_OnSocialiteActiveEffectHit, ImpactNormal) == 0x000014, "Member 'SocialiteActiveAbility_BP_OnSocialiteActiveEffectHit::ImpactNormal' has a wrong offset!");

// Function DeceiveInc.SocialiteActiveAbility.MulticastProjectileHit
// 0x0020 (0x0020 - 0x0000)
struct SocialiteActiveAbility_MulticastProjectileHit final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    ImpactPos;                                         // 0x0008(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              ImpactNormal;                                      // 0x0014(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialiteActiveAbility_MulticastProjectileHit) == 0x000008, "Wrong alignment on SocialiteActiveAbility_MulticastProjectileHit");
static_assert(sizeof(SocialiteActiveAbility_MulticastProjectileHit) == 0x000020, "Wrong size on SocialiteActiveAbility_MulticastProjectileHit");
static_assert(offsetof(SocialiteActiveAbility_MulticastProjectileHit, Victim) == 0x000000, "Member 'SocialiteActiveAbility_MulticastProjectileHit::Victim' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbility_MulticastProjectileHit, ImpactPos) == 0x000008, "Member 'SocialiteActiveAbility_MulticastProjectileHit::ImpactPos' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbility_MulticastProjectileHit, ImpactNormal) == 0x000014, "Member 'SocialiteActiveAbility_MulticastProjectileHit::ImpactNormal' has a wrong offset!");

// Function DeceiveInc.SocialiteActiveAbility.MulticastSocialiteActiveConeAttack
// 0x0018 (0x0018 - 0x0000)
struct SocialiteActiveAbility_MulticastSocialiteActiveConeAttack final
{
public:
	struct FVector_NetQuantize                    OriginPos;                                         // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              Normal;                                            // 0x000C(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialiteActiveAbility_MulticastSocialiteActiveConeAttack) == 0x000004, "Wrong alignment on SocialiteActiveAbility_MulticastSocialiteActiveConeAttack");
static_assert(sizeof(SocialiteActiveAbility_MulticastSocialiteActiveConeAttack) == 0x000018, "Wrong size on SocialiteActiveAbility_MulticastSocialiteActiveConeAttack");
static_assert(offsetof(SocialiteActiveAbility_MulticastSocialiteActiveConeAttack, OriginPos) == 0x000000, "Member 'SocialiteActiveAbility_MulticastSocialiteActiveConeAttack::OriginPos' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbility_MulticastSocialiteActiveConeAttack, Normal) == 0x00000C, "Member 'SocialiteActiveAbility_MulticastSocialiteActiveConeAttack::Normal' has a wrong offset!");

// Function DeceiveInc.SocialiteActiveAbility.Server_TriggerAttack
// 0x0018 (0x0018 - 0x0000)
struct SocialiteActiveAbility_Server_TriggerAttack final
{
public:
	struct FVector                                OriginPos;                                         // 0x0000(0x000C)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x000C(0x000C)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialiteActiveAbility_Server_TriggerAttack) == 0x000004, "Wrong alignment on SocialiteActiveAbility_Server_TriggerAttack");
static_assert(sizeof(SocialiteActiveAbility_Server_TriggerAttack) == 0x000018, "Wrong size on SocialiteActiveAbility_Server_TriggerAttack");
static_assert(offsetof(SocialiteActiveAbility_Server_TriggerAttack, OriginPos) == 0x000000, "Member 'SocialiteActiveAbility_Server_TriggerAttack::OriginPos' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbility_Server_TriggerAttack, Normal) == 0x00000C, "Member 'SocialiteActiveAbility_Server_TriggerAttack::Normal' has a wrong offset!");

// Function DeceiveInc.SocialiteActiveAbility.GetMuzzlePosition
// 0x000C (0x000C - 0x0000)
struct SocialiteActiveAbility_GetMuzzlePosition final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialiteActiveAbility_GetMuzzlePosition) == 0x000004, "Wrong alignment on SocialiteActiveAbility_GetMuzzlePosition");
static_assert(sizeof(SocialiteActiveAbility_GetMuzzlePosition) == 0x00000C, "Wrong size on SocialiteActiveAbility_GetMuzzlePosition");
static_assert(offsetof(SocialiteActiveAbility_GetMuzzlePosition, ReturnValue) == 0x000000, "Member 'SocialiteActiveAbility_GetMuzzlePosition::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SocialiteActiveAbilityMod1.BP_OnSocialiteActiveEffectHit
// 0x0020 (0x0020 - 0x0000)
struct SocialiteActiveAbilityMod1_BP_OnSocialiteActiveEffectHit final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPoint;                                       // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactNormal;                                      // 0x0014(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialiteActiveAbilityMod1_BP_OnSocialiteActiveEffectHit) == 0x000008, "Wrong alignment on SocialiteActiveAbilityMod1_BP_OnSocialiteActiveEffectHit");
static_assert(sizeof(SocialiteActiveAbilityMod1_BP_OnSocialiteActiveEffectHit) == 0x000020, "Wrong size on SocialiteActiveAbilityMod1_BP_OnSocialiteActiveEffectHit");
static_assert(offsetof(SocialiteActiveAbilityMod1_BP_OnSocialiteActiveEffectHit, Victim) == 0x000000, "Member 'SocialiteActiveAbilityMod1_BP_OnSocialiteActiveEffectHit::Victim' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbilityMod1_BP_OnSocialiteActiveEffectHit, ImpactPoint) == 0x000008, "Member 'SocialiteActiveAbilityMod1_BP_OnSocialiteActiveEffectHit::ImpactPoint' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbilityMod1_BP_OnSocialiteActiveEffectHit, ImpactNormal) == 0x000014, "Member 'SocialiteActiveAbilityMod1_BP_OnSocialiteActiveEffectHit::ImpactNormal' has a wrong offset!");

// Function DeceiveInc.SocialiteActiveAbilityMod1.BP_OnSocialiteActiveMod1
// 0x0020 (0x0020 - 0x0000)
struct SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1 final
{
public:
	struct FVector                                FloorPos;                                          // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1) == 0x000004, "Wrong alignment on SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1");
static_assert(sizeof(SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1) == 0x000020, "Wrong size on SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1");
static_assert(offsetof(SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1, FloorPos) == 0x000000, "Member 'SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1::FloorPos' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1, Normal) == 0x00000C, "Member 'SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1::Normal' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1, Radius) == 0x000018, "Member 'SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1::Radius' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1, Height) == 0x00001C, "Member 'SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1::Height' has a wrong offset!");

// Function DeceiveInc.SocialiteActiveAbilityMod1.BP_OnSocialiteActiveMod1Local
// 0x0020 (0x0020 - 0x0000)
struct SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Local final
{
public:
	struct FVector                                FloorPos;                                          // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Local) == 0x000004, "Wrong alignment on SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Local");
static_assert(sizeof(SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Local) == 0x000020, "Wrong size on SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Local");
static_assert(offsetof(SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Local, FloorPos) == 0x000000, "Member 'SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Local::FloorPos' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Local, Normal) == 0x00000C, "Member 'SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Local::Normal' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Local, Radius) == 0x000018, "Member 'SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Local::Radius' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Local, Height) == 0x00001C, "Member 'SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Local::Height' has a wrong offset!");

// Function DeceiveInc.SocialiteActiveAbilityMod1.BP_OnSocialiteActiveMod1Replicated
// 0x0020 (0x0020 - 0x0000)
struct SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Replicated final
{
public:
	struct FVector                                FloorPos;                                          // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Replicated) == 0x000004, "Wrong alignment on SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Replicated");
static_assert(sizeof(SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Replicated) == 0x000020, "Wrong size on SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Replicated");
static_assert(offsetof(SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Replicated, FloorPos) == 0x000000, "Member 'SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Replicated::FloorPos' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Replicated, Normal) == 0x00000C, "Member 'SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Replicated::Normal' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Replicated, Radius) == 0x000018, "Member 'SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Replicated::Radius' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Replicated, Height) == 0x00001C, "Member 'SocialiteActiveAbilityMod1_BP_OnSocialiteActiveMod1Replicated::Height' has a wrong offset!");

// Function DeceiveInc.SocialiteActiveAbilityMod1.MulticastProjectileHit
// 0x0020 (0x0020 - 0x0000)
struct SocialiteActiveAbilityMod1_MulticastProjectileHit final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    ImpactPos;                                         // 0x0008(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              ImpactNormal;                                      // 0x0014(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialiteActiveAbilityMod1_MulticastProjectileHit) == 0x000008, "Wrong alignment on SocialiteActiveAbilityMod1_MulticastProjectileHit");
static_assert(sizeof(SocialiteActiveAbilityMod1_MulticastProjectileHit) == 0x000020, "Wrong size on SocialiteActiveAbilityMod1_MulticastProjectileHit");
static_assert(offsetof(SocialiteActiveAbilityMod1_MulticastProjectileHit, Victim) == 0x000000, "Member 'SocialiteActiveAbilityMod1_MulticastProjectileHit::Victim' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbilityMod1_MulticastProjectileHit, ImpactPos) == 0x000008, "Member 'SocialiteActiveAbilityMod1_MulticastProjectileHit::ImpactPos' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbilityMod1_MulticastProjectileHit, ImpactNormal) == 0x000014, "Member 'SocialiteActiveAbilityMod1_MulticastProjectileHit::ImpactNormal' has a wrong offset!");

// Function DeceiveInc.SocialiteActiveAbilityMod1.MulticastSocialiteActiveMod1
// 0x0018 (0x0018 - 0x0000)
struct SocialiteActiveAbilityMod1_MulticastSocialiteActiveMod1 final
{
public:
	struct FVector_NetQuantize                    OriginPos;                                         // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              Normal;                                            // 0x000C(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialiteActiveAbilityMod1_MulticastSocialiteActiveMod1) == 0x000004, "Wrong alignment on SocialiteActiveAbilityMod1_MulticastSocialiteActiveMod1");
static_assert(sizeof(SocialiteActiveAbilityMod1_MulticastSocialiteActiveMod1) == 0x000018, "Wrong size on SocialiteActiveAbilityMod1_MulticastSocialiteActiveMod1");
static_assert(offsetof(SocialiteActiveAbilityMod1_MulticastSocialiteActiveMod1, OriginPos) == 0x000000, "Member 'SocialiteActiveAbilityMod1_MulticastSocialiteActiveMod1::OriginPos' has a wrong offset!");
static_assert(offsetof(SocialiteActiveAbilityMod1_MulticastSocialiteActiveMod1, Normal) == 0x00000C, "Member 'SocialiteActiveAbilityMod1_MulticastSocialiteActiveMod1::Normal' has a wrong offset!");

// Function DeceiveInc.SocialiteActiveAbilityMod1.GetMuzzlePosition
// 0x000C (0x000C - 0x0000)
struct SocialiteActiveAbilityMod1_GetMuzzlePosition final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialiteActiveAbilityMod1_GetMuzzlePosition) == 0x000004, "Wrong alignment on SocialiteActiveAbilityMod1_GetMuzzlePosition");
static_assert(sizeof(SocialiteActiveAbilityMod1_GetMuzzlePosition) == 0x00000C, "Wrong size on SocialiteActiveAbilityMod1_GetMuzzlePosition");
static_assert(offsetof(SocialiteActiveAbilityMod1_GetMuzzlePosition, ReturnValue) == 0x000000, "Member 'SocialiteActiveAbilityMod1_GetMuzzlePosition::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SocialiteActiveAbilityMod2.HandleMiscToolSpawned
// 0x0008 (0x0008 - 0x0000)
struct SocialiteActiveAbilityMod2_HandleMiscToolSpawned final
{
public:
	class AActor*                                 SpawnedTool;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialiteActiveAbilityMod2_HandleMiscToolSpawned) == 0x000008, "Wrong alignment on SocialiteActiveAbilityMod2_HandleMiscToolSpawned");
static_assert(sizeof(SocialiteActiveAbilityMod2_HandleMiscToolSpawned) == 0x000008, "Wrong size on SocialiteActiveAbilityMod2_HandleMiscToolSpawned");
static_assert(offsetof(SocialiteActiveAbilityMod2_HandleMiscToolSpawned, SpawnedTool) == 0x000000, "Member 'SocialiteActiveAbilityMod2_HandleMiscToolSpawned::SpawnedTool' has a wrong offset!");

// Function DeceiveInc.SocialiteActiveAbilityMod2.HandleTrapPickedUp
// 0x0008 (0x0008 - 0x0000)
struct SocialiteActiveAbilityMod2_HandleTrapPickedUp final
{
public:
	class AActor*                                 Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialiteActiveAbilityMod2_HandleTrapPickedUp) == 0x000008, "Wrong alignment on SocialiteActiveAbilityMod2_HandleTrapPickedUp");
static_assert(sizeof(SocialiteActiveAbilityMod2_HandleTrapPickedUp) == 0x000008, "Wrong size on SocialiteActiveAbilityMod2_HandleTrapPickedUp");
static_assert(offsetof(SocialiteActiveAbilityMod2_HandleTrapPickedUp, Spy) == 0x000000, "Member 'SocialiteActiveAbilityMod2_HandleTrapPickedUp::Spy' has a wrong offset!");

// Function DeceiveInc.SocialiteActiveAbilityMod2.OnTrapDeath
// 0x0008 (0x0008 - 0x0000)
struct SocialiteActiveAbilityMod2_OnTrapDeath final
{
public:
	class AActor*                                 DeadActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialiteActiveAbilityMod2_OnTrapDeath) == 0x000008, "Wrong alignment on SocialiteActiveAbilityMod2_OnTrapDeath");
static_assert(sizeof(SocialiteActiveAbilityMod2_OnTrapDeath) == 0x000008, "Wrong size on SocialiteActiveAbilityMod2_OnTrapDeath");
static_assert(offsetof(SocialiteActiveAbilityMod2_OnTrapDeath, DeadActor) == 0x000000, "Member 'SocialiteActiveAbilityMod2_OnTrapDeath::DeadActor' has a wrong offset!");

// Function DeceiveInc.SocialitePassiveAbility.OnUndercoverChange
// 0x0001 (0x0001 - 0x0000)
struct SocialitePassiveAbility_OnUndercoverChange final
{
public:
	bool                                          Undercover;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialitePassiveAbility_OnUndercoverChange) == 0x000001, "Wrong alignment on SocialitePassiveAbility_OnUndercoverChange");
static_assert(sizeof(SocialitePassiveAbility_OnUndercoverChange) == 0x000001, "Wrong size on SocialitePassiveAbility_OnUndercoverChange");
static_assert(offsetof(SocialitePassiveAbility_OnUndercoverChange, Undercover) == 0x000000, "Member 'SocialitePassiveAbility_OnUndercoverChange::Undercover' has a wrong offset!");

// Function DeceiveInc.SocialitePassiveAbilityMod1.HandleSpyDeath
// 0x0008 (0x0008 - 0x0000)
struct SocialitePassiveAbilityMod1_HandleSpyDeath final
{
public:
	class ASpy*                                   DeadSpy;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialitePassiveAbilityMod1_HandleSpyDeath) == 0x000008, "Wrong alignment on SocialitePassiveAbilityMod1_HandleSpyDeath");
static_assert(sizeof(SocialitePassiveAbilityMod1_HandleSpyDeath) == 0x000008, "Wrong size on SocialitePassiveAbilityMod1_HandleSpyDeath");
static_assert(offsetof(SocialitePassiveAbilityMod1_HandleSpyDeath, DeadSpy) == 0x000000, "Member 'SocialitePassiveAbilityMod1_HandleSpyDeath::DeadSpy' has a wrong offset!");

// Function DeceiveInc.SocialitePassiveAbilityMod1.HandleUnderCoverChanged
// 0x0001 (0x0001 - 0x0000)
struct SocialitePassiveAbilityMod1_HandleUnderCoverChanged final
{
public:
	bool                                          bUndercover;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialitePassiveAbilityMod1_HandleUnderCoverChanged) == 0x000001, "Wrong alignment on SocialitePassiveAbilityMod1_HandleUnderCoverChanged");
static_assert(sizeof(SocialitePassiveAbilityMod1_HandleUnderCoverChanged) == 0x000001, "Wrong size on SocialitePassiveAbilityMod1_HandleUnderCoverChanged");
static_assert(offsetof(SocialitePassiveAbilityMod1_HandleUnderCoverChanged, bUndercover) == 0x000000, "Member 'SocialitePassiveAbilityMod1_HandleUnderCoverChanged::bUndercover' has a wrong offset!");

// Function DeceiveInc.SocialitePassiveAbilityMod2.HandleSpyHeatChange
// 0x0010 (0x0010 - 0x0000)
struct SocialitePassiveAbilityMod2_HandleSpyHeatChange final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewHeatValue;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeatDelta;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialitePassiveAbilityMod2_HandleSpyHeatChange) == 0x000008, "Wrong alignment on SocialitePassiveAbilityMod2_HandleSpyHeatChange");
static_assert(sizeof(SocialitePassiveAbilityMod2_HandleSpyHeatChange) == 0x000010, "Wrong size on SocialitePassiveAbilityMod2_HandleSpyHeatChange");
static_assert(offsetof(SocialitePassiveAbilityMod2_HandleSpyHeatChange, Spy) == 0x000000, "Member 'SocialitePassiveAbilityMod2_HandleSpyHeatChange::Spy' has a wrong offset!");
static_assert(offsetof(SocialitePassiveAbilityMod2_HandleSpyHeatChange, NewHeatValue) == 0x000008, "Member 'SocialitePassiveAbilityMod2_HandleSpyHeatChange::NewHeatValue' has a wrong offset!");
static_assert(offsetof(SocialitePassiveAbilityMod2_HandleSpyHeatChange, HeatDelta) == 0x00000C, "Member 'SocialitePassiveAbilityMod2_HandleSpyHeatChange::HeatDelta' has a wrong offset!");

// Function DeceiveInc.SocialitePassiveAbilityMod2.HandleSpySecurityStateChanged
// 0x0010 (0x0010 - 0x0000)
struct SocialitePassiveAbilityMod2_HandleSpySecurityStateChanged final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpySecurityState                             PreviousState;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpySecurityState                             NewState;                                          // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SocialitePassiveAbilityMod2_HandleSpySecurityStateChanged) == 0x000008, "Wrong alignment on SocialitePassiveAbilityMod2_HandleSpySecurityStateChanged");
static_assert(sizeof(SocialitePassiveAbilityMod2_HandleSpySecurityStateChanged) == 0x000010, "Wrong size on SocialitePassiveAbilityMod2_HandleSpySecurityStateChanged");
static_assert(offsetof(SocialitePassiveAbilityMod2_HandleSpySecurityStateChanged, Spy) == 0x000000, "Member 'SocialitePassiveAbilityMod2_HandleSpySecurityStateChanged::Spy' has a wrong offset!");
static_assert(offsetof(SocialitePassiveAbilityMod2_HandleSpySecurityStateChanged, PreviousState) == 0x000008, "Member 'SocialitePassiveAbilityMod2_HandleSpySecurityStateChanged::PreviousState' has a wrong offset!");
static_assert(offsetof(SocialitePassiveAbilityMod2_HandleSpySecurityStateChanged, NewState) == 0x000009, "Member 'SocialitePassiveAbilityMod2_HandleSpySecurityStateChanged::NewState' has a wrong offset!");

// Function DeceiveInc.SocialiteTrap.HandleDetectionCollisionBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct SocialiteTrap_HandleDetectionCollisionBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialiteTrap_HandleDetectionCollisionBeginOverlap) == 0x000008, "Wrong alignment on SocialiteTrap_HandleDetectionCollisionBeginOverlap");
static_assert(sizeof(SocialiteTrap_HandleDetectionCollisionBeginOverlap) == 0x0000A8, "Wrong size on SocialiteTrap_HandleDetectionCollisionBeginOverlap");
static_assert(offsetof(SocialiteTrap_HandleDetectionCollisionBeginOverlap, OverlappedComponent) == 0x000000, "Member 'SocialiteTrap_HandleDetectionCollisionBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(SocialiteTrap_HandleDetectionCollisionBeginOverlap, OtherActor) == 0x000008, "Member 'SocialiteTrap_HandleDetectionCollisionBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(SocialiteTrap_HandleDetectionCollisionBeginOverlap, OtherComp) == 0x000010, "Member 'SocialiteTrap_HandleDetectionCollisionBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(SocialiteTrap_HandleDetectionCollisionBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'SocialiteTrap_HandleDetectionCollisionBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(SocialiteTrap_HandleDetectionCollisionBeginOverlap, bFromSweep) == 0x00001C, "Member 'SocialiteTrap_HandleDetectionCollisionBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(SocialiteTrap_HandleDetectionCollisionBeginOverlap, SweepResult) == 0x000020, "Member 'SocialiteTrap_HandleDetectionCollisionBeginOverlap::SweepResult' has a wrong offset!");

// Function DeceiveInc.SocialiteTrap.HandleDetectionCollisionEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct SocialiteTrap_HandleDetectionCollisionEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SocialiteTrap_HandleDetectionCollisionEndOverlap) == 0x000008, "Wrong alignment on SocialiteTrap_HandleDetectionCollisionEndOverlap");
static_assert(sizeof(SocialiteTrap_HandleDetectionCollisionEndOverlap) == 0x000020, "Wrong size on SocialiteTrap_HandleDetectionCollisionEndOverlap");
static_assert(offsetof(SocialiteTrap_HandleDetectionCollisionEndOverlap, OverlappedComponent) == 0x000000, "Member 'SocialiteTrap_HandleDetectionCollisionEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(SocialiteTrap_HandleDetectionCollisionEndOverlap, OtherActor) == 0x000008, "Member 'SocialiteTrap_HandleDetectionCollisionEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(SocialiteTrap_HandleDetectionCollisionEndOverlap, OtherComp) == 0x000010, "Member 'SocialiteTrap_HandleDetectionCollisionEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(SocialiteTrap_HandleDetectionCollisionEndOverlap, OtherBodyIndex) == 0x000018, "Member 'SocialiteTrap_HandleDetectionCollisionEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function DeceiveInc.SocialiteTrap.OnHealthChanged
// 0x0030 (0x0030 - 0x0000)
struct SocialiteTrap_OnHealthChanged final
{
public:
	class UHealthComponent*                       OwningHealthComp;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthDelta;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDamageType*                      DamageType;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RawDamage;                                         // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SocialiteTrap_OnHealthChanged) == 0x000008, "Wrong alignment on SocialiteTrap_OnHealthChanged");
static_assert(sizeof(SocialiteTrap_OnHealthChanged) == 0x000030, "Wrong size on SocialiteTrap_OnHealthChanged");
static_assert(offsetof(SocialiteTrap_OnHealthChanged, OwningHealthComp) == 0x000000, "Member 'SocialiteTrap_OnHealthChanged::OwningHealthComp' has a wrong offset!");
static_assert(offsetof(SocialiteTrap_OnHealthChanged, Health) == 0x000008, "Member 'SocialiteTrap_OnHealthChanged::Health' has a wrong offset!");
static_assert(offsetof(SocialiteTrap_OnHealthChanged, HealthDelta) == 0x00000C, "Member 'SocialiteTrap_OnHealthChanged::HealthDelta' has a wrong offset!");
static_assert(offsetof(SocialiteTrap_OnHealthChanged, DamageType) == 0x000010, "Member 'SocialiteTrap_OnHealthChanged::DamageType' has a wrong offset!");
static_assert(offsetof(SocialiteTrap_OnHealthChanged, InstigatedBy) == 0x000018, "Member 'SocialiteTrap_OnHealthChanged::InstigatedBy' has a wrong offset!");
static_assert(offsetof(SocialiteTrap_OnHealthChanged, DamageCauser) == 0x000020, "Member 'SocialiteTrap_OnHealthChanged::DamageCauser' has a wrong offset!");
static_assert(offsetof(SocialiteTrap_OnHealthChanged, RawDamage) == 0x000028, "Member 'SocialiteTrap_OnHealthChanged::RawDamage' has a wrong offset!");

// Function DeceiveInc.SocialiteTrap.OnInteractionComplete
// 0x0010 (0x0010 - 0x0000)
struct SocialiteTrap_OnInteractionComplete final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialiteTrap_OnInteractionComplete) == 0x000008, "Wrong alignment on SocialiteTrap_OnInteractionComplete");
static_assert(sizeof(SocialiteTrap_OnInteractionComplete) == 0x000010, "Wrong size on SocialiteTrap_OnInteractionComplete");
static_assert(offsetof(SocialiteTrap_OnInteractionComplete, Interacter) == 0x000000, "Member 'SocialiteTrap_OnInteractionComplete::Interacter' has a wrong offset!");
static_assert(offsetof(SocialiteTrap_OnInteractionComplete, Interactable) == 0x000008, "Member 'SocialiteTrap_OnInteractionComplete::Interactable' has a wrong offset!");

// Function DeceiveInc.SocialiteTrap.OnSpyInRangeUndercoverChange
// 0x0001 (0x0001 - 0x0000)
struct SocialiteTrap_OnSpyInRangeUndercoverChange final
{
public:
	bool                                          bUndercover;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SocialiteTrap_OnSpyInRangeUndercoverChange) == 0x000001, "Wrong alignment on SocialiteTrap_OnSpyInRangeUndercoverChange");
static_assert(sizeof(SocialiteTrap_OnSpyInRangeUndercoverChange) == 0x000001, "Wrong size on SocialiteTrap_OnSpyInRangeUndercoverChange");
static_assert(offsetof(SocialiteTrap_OnSpyInRangeUndercoverChange, bUndercover) == 0x000000, "Member 'SocialiteTrap_OnSpyInRangeUndercoverChange::bUndercover' has a wrong offset!");

// Function DeceiveInc.SoundMachine.NetMulticast_PlaySound
// 0x0048 (0x0048 - 0x0000)
struct SoundMachine_NetMulticast_PlaySound final
{
public:
	struct FTrackSoundEvents                      SoundToPlay;                                       // 0x0000(0x0040)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         NewRandomSeed;                                     // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SoundMachine_NetMulticast_PlaySound) == 0x000008, "Wrong alignment on SoundMachine_NetMulticast_PlaySound");
static_assert(sizeof(SoundMachine_NetMulticast_PlaySound) == 0x000048, "Wrong size on SoundMachine_NetMulticast_PlaySound");
static_assert(offsetof(SoundMachine_NetMulticast_PlaySound, SoundToPlay) == 0x000000, "Member 'SoundMachine_NetMulticast_PlaySound::SoundToPlay' has a wrong offset!");
static_assert(offsetof(SoundMachine_NetMulticast_PlaySound, NewRandomSeed) == 0x000040, "Member 'SoundMachine_NetMulticast_PlaySound::NewRandomSeed' has a wrong offset!");

// Function DeceiveInc.SoundMachine.Server_PlaySound
// 0x0048 (0x0048 - 0x0000)
struct SoundMachine_Server_PlaySound final
{
public:
	struct FTrackSoundEvents                      SoundToPlay;                                       // 0x0000(0x0040)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         NewRandomSeed;                                     // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SoundMachine_Server_PlaySound) == 0x000008, "Wrong alignment on SoundMachine_Server_PlaySound");
static_assert(sizeof(SoundMachine_Server_PlaySound) == 0x000048, "Wrong size on SoundMachine_Server_PlaySound");
static_assert(offsetof(SoundMachine_Server_PlaySound, SoundToPlay) == 0x000000, "Member 'SoundMachine_Server_PlaySound::SoundToPlay' has a wrong offset!");
static_assert(offsetof(SoundMachine_Server_PlaySound, NewRandomSeed) == 0x000040, "Member 'SoundMachine_Server_PlaySound::NewRandomSeed' has a wrong offset!");

// Function DeceiveInc.SoundMachineTool.GetCurrentSoundTrackInfo
// 0x0040 (0x0040 - 0x0000)
struct SoundMachineTool_GetCurrentSoundTrackInfo final
{
public:
	struct FTrackSoundEvents                      ReturnValue;                                       // 0x0000(0x0040)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundMachineTool_GetCurrentSoundTrackInfo) == 0x000008, "Wrong alignment on SoundMachineTool_GetCurrentSoundTrackInfo");
static_assert(sizeof(SoundMachineTool_GetCurrentSoundTrackInfo) == 0x000040, "Wrong size on SoundMachineTool_GetCurrentSoundTrackInfo");
static_assert(offsetof(SoundMachineTool_GetCurrentSoundTrackInfo, ReturnValue) == 0x000000, "Member 'SoundMachineTool_GetCurrentSoundTrackInfo::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SoundMachineTool.HandleSoundMachineDropDone
// 0x0020 (0x0020 - 0x0000)
struct SoundMachineTool_HandleSoundMachineDropDone final
{
public:
	class AActor*                                 ActorDropped;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndPos;                                            // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               EndRotation;                                       // 0x0014(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundMachineTool_HandleSoundMachineDropDone) == 0x000008, "Wrong alignment on SoundMachineTool_HandleSoundMachineDropDone");
static_assert(sizeof(SoundMachineTool_HandleSoundMachineDropDone) == 0x000020, "Wrong size on SoundMachineTool_HandleSoundMachineDropDone");
static_assert(offsetof(SoundMachineTool_HandleSoundMachineDropDone, ActorDropped) == 0x000000, "Member 'SoundMachineTool_HandleSoundMachineDropDone::ActorDropped' has a wrong offset!");
static_assert(offsetof(SoundMachineTool_HandleSoundMachineDropDone, EndPos) == 0x000008, "Member 'SoundMachineTool_HandleSoundMachineDropDone::EndPos' has a wrong offset!");
static_assert(offsetof(SoundMachineTool_HandleSoundMachineDropDone, EndRotation) == 0x000014, "Member 'SoundMachineTool_HandleSoundMachineDropDone::EndRotation' has a wrong offset!");

// Function DeceiveInc.SoundMachineTool.IsSoundPlaying
// 0x0001 (0x0001 - 0x0000)
struct SoundMachineTool_IsSoundPlaying final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundMachineTool_IsSoundPlaying) == 0x000001, "Wrong alignment on SoundMachineTool_IsSoundPlaying");
static_assert(sizeof(SoundMachineTool_IsSoundPlaying) == 0x000001, "Wrong size on SoundMachineTool_IsSoundPlaying");
static_assert(offsetof(SoundMachineTool_IsSoundPlaying, ReturnValue) == 0x000000, "Member 'SoundMachineTool_IsSoundPlaying::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SpawnerWeaponRound.GetSpawnerWeapon
// 0x0008 (0x0008 - 0x0000)
struct SpawnerWeaponRound_GetSpawnerWeapon final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpawnerWeaponRound_GetSpawnerWeapon) == 0x000008, "Wrong alignment on SpawnerWeaponRound_GetSpawnerWeapon");
static_assert(sizeof(SpawnerWeaponRound_GetSpawnerWeapon) == 0x000008, "Wrong size on SpawnerWeaponRound_GetSpawnerWeapon");
static_assert(offsetof(SpawnerWeaponRound_GetSpawnerWeapon, ReturnValue) == 0x000000, "Member 'SpawnerWeaponRound_GetSpawnerWeapon::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SpawnerWeaponRound.ProjectilesReleasedHandler
// 0x000C (0x000C - 0x0000)
struct SpawnerWeaponRound_ProjectilesReleasedHandler final
{
public:
	struct FVector                                AimPosition;                                       // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpawnerWeaponRound_ProjectilesReleasedHandler) == 0x000004, "Wrong alignment on SpawnerWeaponRound_ProjectilesReleasedHandler");
static_assert(sizeof(SpawnerWeaponRound_ProjectilesReleasedHandler) == 0x00000C, "Wrong size on SpawnerWeaponRound_ProjectilesReleasedHandler");
static_assert(offsetof(SpawnerWeaponRound_ProjectilesReleasedHandler, AimPosition) == 0x000000, "Member 'SpawnerWeaponRound_ProjectilesReleasedHandler::AimPosition' has a wrong offset!");

// Function DeceiveInc.SpawnerWeaponRound.ShowProjectilesHandler
// 0x0001 (0x0001 - 0x0000)
struct SpawnerWeaponRound_ShowProjectilesHandler final
{
public:
	EVisibilityMode                               VisibilityMode;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpawnerWeaponRound_ShowProjectilesHandler) == 0x000001, "Wrong alignment on SpawnerWeaponRound_ShowProjectilesHandler");
static_assert(sizeof(SpawnerWeaponRound_ShowProjectilesHandler) == 0x000001, "Wrong size on SpawnerWeaponRound_ShowProjectilesHandler");
static_assert(offsetof(SpawnerWeaponRound_ShowProjectilesHandler, VisibilityMode) == 0x000000, "Member 'SpawnerWeaponRound_ShowProjectilesHandler::VisibilityMode' has a wrong offset!");

// Function DeceiveInc.SpawnerWeaponRound.CanBeHeld
// 0x0001 (0x0001 - 0x0000)
struct SpawnerWeaponRound_CanBeHeld final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpawnerWeaponRound_CanBeHeld) == 0x000001, "Wrong alignment on SpawnerWeaponRound_CanBeHeld");
static_assert(sizeof(SpawnerWeaponRound_CanBeHeld) == 0x000001, "Wrong size on SpawnerWeaponRound_CanBeHeld");
static_assert(offsetof(SpawnerWeaponRound_CanBeHeld, ReturnValue) == 0x000000, "Member 'SpawnerWeaponRound_CanBeHeld::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SpawnerWeaponRound.GetActorToSpawnOnHit
// 0x0028 (0x0028 - 0x0000)
struct SpawnerWeaponRound_GetActorToSpawnOnHit final
{
public:
	TSoftClassPtr<class UClass>                   ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpawnerWeaponRound_GetActorToSpawnOnHit) == 0x000008, "Wrong alignment on SpawnerWeaponRound_GetActorToSpawnOnHit");
static_assert(sizeof(SpawnerWeaponRound_GetActorToSpawnOnHit) == 0x000028, "Wrong size on SpawnerWeaponRound_GetActorToSpawnOnHit");
static_assert(offsetof(SpawnerWeaponRound_GetActorToSpawnOnHit, ReturnValue) == 0x000000, "Member 'SpawnerWeaponRound_GetActorToSpawnOnHit::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SpawnerWeaponRound.GetReleasePosition
// 0x000C (0x000C - 0x0000)
struct SpawnerWeaponRound_GetReleasePosition final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpawnerWeaponRound_GetReleasePosition) == 0x000004, "Wrong alignment on SpawnerWeaponRound_GetReleasePosition");
static_assert(sizeof(SpawnerWeaponRound_GetReleasePosition) == 0x00000C, "Wrong size on SpawnerWeaponRound_GetReleasePosition");
static_assert(offsetof(SpawnerWeaponRound_GetReleasePosition, ReturnValue) == 0x000000, "Member 'SpawnerWeaponRound_GetReleasePosition::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SpawnerWeaponRound.IsShootFromCameraAndFakeMuzzlePos
// 0x0001 (0x0001 - 0x0000)
struct SpawnerWeaponRound_IsShootFromCameraAndFakeMuzzlePos final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpawnerWeaponRound_IsShootFromCameraAndFakeMuzzlePos) == 0x000001, "Wrong alignment on SpawnerWeaponRound_IsShootFromCameraAndFakeMuzzlePos");
static_assert(sizeof(SpawnerWeaponRound_IsShootFromCameraAndFakeMuzzlePos) == 0x000001, "Wrong size on SpawnerWeaponRound_IsShootFromCameraAndFakeMuzzlePos");
static_assert(offsetof(SpawnerWeaponRound_IsShootFromCameraAndFakeMuzzlePos, ReturnValue) == 0x000000, "Member 'SpawnerWeaponRound_IsShootFromCameraAndFakeMuzzlePos::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SpawnerWeaponRound_Projectile.ApplyNewBalancingTableAndUpdateStats
// 0x0010 (0x0010 - 0x0000)
struct SpawnerWeaponRound_Projectile_ApplyNewBalancingTableAndUpdateStats final
{
public:
	class UDataTable*                             NewTable;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NewBalancingName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpawnerWeaponRound_Projectile_ApplyNewBalancingTableAndUpdateStats) == 0x000008, "Wrong alignment on SpawnerWeaponRound_Projectile_ApplyNewBalancingTableAndUpdateStats");
static_assert(sizeof(SpawnerWeaponRound_Projectile_ApplyNewBalancingTableAndUpdateStats) == 0x000010, "Wrong size on SpawnerWeaponRound_Projectile_ApplyNewBalancingTableAndUpdateStats");
static_assert(offsetof(SpawnerWeaponRound_Projectile_ApplyNewBalancingTableAndUpdateStats, NewTable) == 0x000000, "Member 'SpawnerWeaponRound_Projectile_ApplyNewBalancingTableAndUpdateStats::NewTable' has a wrong offset!");
static_assert(offsetof(SpawnerWeaponRound_Projectile_ApplyNewBalancingTableAndUpdateStats, NewBalancingName) == 0x000008, "Member 'SpawnerWeaponRound_Projectile_ApplyNewBalancingTableAndUpdateStats::NewBalancingName' has a wrong offset!");

// Function DeceiveInc.SpawnerWeaponRound_Projectile.HandleBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct SpawnerWeaponRound_Projectile_HandleBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpawnerWeaponRound_Projectile_HandleBeginOverlap) == 0x000008, "Wrong alignment on SpawnerWeaponRound_Projectile_HandleBeginOverlap");
static_assert(sizeof(SpawnerWeaponRound_Projectile_HandleBeginOverlap) == 0x0000A8, "Wrong size on SpawnerWeaponRound_Projectile_HandleBeginOverlap");
static_assert(offsetof(SpawnerWeaponRound_Projectile_HandleBeginOverlap, OverlappedComponent) == 0x000000, "Member 'SpawnerWeaponRound_Projectile_HandleBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(SpawnerWeaponRound_Projectile_HandleBeginOverlap, OtherActor) == 0x000008, "Member 'SpawnerWeaponRound_Projectile_HandleBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(SpawnerWeaponRound_Projectile_HandleBeginOverlap, OtherComp) == 0x000010, "Member 'SpawnerWeaponRound_Projectile_HandleBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(SpawnerWeaponRound_Projectile_HandleBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'SpawnerWeaponRound_Projectile_HandleBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(SpawnerWeaponRound_Projectile_HandleBeginOverlap, bFromSweep) == 0x00001C, "Member 'SpawnerWeaponRound_Projectile_HandleBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(SpawnerWeaponRound_Projectile_HandleBeginOverlap, SweepResult) == 0x000020, "Member 'SpawnerWeaponRound_Projectile_HandleBeginOverlap::SweepResult' has a wrong offset!");

// Function DeceiveInc.SpawnerWeaponRound_Projectile.HandleHit
// 0x00B0 (0x00B0 - 0x0000)
struct SpawnerWeaponRound_Projectile_HandleHit final
{
public:
	class UPrimitiveComponent*                    HitComp;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalImpulse;                                     // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0024(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SpawnerWeaponRound_Projectile_HandleHit) == 0x000008, "Wrong alignment on SpawnerWeaponRound_Projectile_HandleHit");
static_assert(sizeof(SpawnerWeaponRound_Projectile_HandleHit) == 0x0000B0, "Wrong size on SpawnerWeaponRound_Projectile_HandleHit");
static_assert(offsetof(SpawnerWeaponRound_Projectile_HandleHit, HitComp) == 0x000000, "Member 'SpawnerWeaponRound_Projectile_HandleHit::HitComp' has a wrong offset!");
static_assert(offsetof(SpawnerWeaponRound_Projectile_HandleHit, OtherActor) == 0x000008, "Member 'SpawnerWeaponRound_Projectile_HandleHit::OtherActor' has a wrong offset!");
static_assert(offsetof(SpawnerWeaponRound_Projectile_HandleHit, OtherComp) == 0x000010, "Member 'SpawnerWeaponRound_Projectile_HandleHit::OtherComp' has a wrong offset!");
static_assert(offsetof(SpawnerWeaponRound_Projectile_HandleHit, NormalImpulse) == 0x000018, "Member 'SpawnerWeaponRound_Projectile_HandleHit::NormalImpulse' has a wrong offset!");
static_assert(offsetof(SpawnerWeaponRound_Projectile_HandleHit, Hit) == 0x000024, "Member 'SpawnerWeaponRound_Projectile_HandleHit::Hit' has a wrong offset!");

// Function DeceiveInc.SpawnerWeaponRound_Projectile.GetBalancingDataTable
// 0x0008 (0x0008 - 0x0000)
struct SpawnerWeaponRound_Projectile_GetBalancingDataTable final
{
public:
	class UDataTable*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpawnerWeaponRound_Projectile_GetBalancingDataTable) == 0x000008, "Wrong alignment on SpawnerWeaponRound_Projectile_GetBalancingDataTable");
static_assert(sizeof(SpawnerWeaponRound_Projectile_GetBalancingDataTable) == 0x000008, "Wrong size on SpawnerWeaponRound_Projectile_GetBalancingDataTable");
static_assert(offsetof(SpawnerWeaponRound_Projectile_GetBalancingDataTable, ReturnValue) == 0x000000, "Member 'SpawnerWeaponRound_Projectile_GetBalancingDataTable::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SpawnerWeaponRound_Projectile.GetLifetime
// 0x0004 (0x0004 - 0x0000)
struct SpawnerWeaponRound_Projectile_GetLifetime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpawnerWeaponRound_Projectile_GetLifetime) == 0x000004, "Wrong alignment on SpawnerWeaponRound_Projectile_GetLifetime");
static_assert(sizeof(SpawnerWeaponRound_Projectile_GetLifetime) == 0x000004, "Wrong size on SpawnerWeaponRound_Projectile_GetLifetime");
static_assert(offsetof(SpawnerWeaponRound_Projectile_GetLifetime, ReturnValue) == 0x000000, "Member 'SpawnerWeaponRound_Projectile_GetLifetime::ReturnValue' has a wrong offset!");

// Function DeceiveInc.YumiPassiveAbilityMod1.HandleEffectNewSource
// 0x0010 (0x0010 - 0x0000)
struct YumiPassiveAbilityMod1_HandleEffectNewSource final
{
public:
	class AActor*                                 AffectingSource;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AffectedActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(YumiPassiveAbilityMod1_HandleEffectNewSource) == 0x000008, "Wrong alignment on YumiPassiveAbilityMod1_HandleEffectNewSource");
static_assert(sizeof(YumiPassiveAbilityMod1_HandleEffectNewSource) == 0x000010, "Wrong size on YumiPassiveAbilityMod1_HandleEffectNewSource");
static_assert(offsetof(YumiPassiveAbilityMod1_HandleEffectNewSource, AffectingSource) == 0x000000, "Member 'YumiPassiveAbilityMod1_HandleEffectNewSource::AffectingSource' has a wrong offset!");
static_assert(offsetof(YumiPassiveAbilityMod1_HandleEffectNewSource, AffectedActor) == 0x000008, "Member 'YumiPassiveAbilityMod1_HandleEffectNewSource::AffectedActor' has a wrong offset!");

// Function DeceiveInc.YumiPassiveAbilityMod1.HandleEffectRemoveSource
// 0x0010 (0x0010 - 0x0000)
struct YumiPassiveAbilityMod1_HandleEffectRemoveSource final
{
public:
	class AActor*                                 AffectingSource;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AffectedActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(YumiPassiveAbilityMod1_HandleEffectRemoveSource) == 0x000008, "Wrong alignment on YumiPassiveAbilityMod1_HandleEffectRemoveSource");
static_assert(sizeof(YumiPassiveAbilityMod1_HandleEffectRemoveSource) == 0x000010, "Wrong size on YumiPassiveAbilityMod1_HandleEffectRemoveSource");
static_assert(offsetof(YumiPassiveAbilityMod1_HandleEffectRemoveSource, AffectingSource) == 0x000000, "Member 'YumiPassiveAbilityMod1_HandleEffectRemoveSource::AffectingSource' has a wrong offset!");
static_assert(offsetof(YumiPassiveAbilityMod1_HandleEffectRemoveSource, AffectedActor) == 0x000008, "Member 'YumiPassiveAbilityMod1_HandleEffectRemoveSource::AffectedActor' has a wrong offset!");

// Function DeceiveInc.YumiPassiveAbilityMod1.HandleEffectStateChange
// 0x0010 (0x0010 - 0x0000)
struct YumiPassiveAbilityMod1_HandleEffectStateChange final
{
public:
	bool                                          bAffected;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AffectedActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(YumiPassiveAbilityMod1_HandleEffectStateChange) == 0x000008, "Wrong alignment on YumiPassiveAbilityMod1_HandleEffectStateChange");
static_assert(sizeof(YumiPassiveAbilityMod1_HandleEffectStateChange) == 0x000010, "Wrong size on YumiPassiveAbilityMod1_HandleEffectStateChange");
static_assert(offsetof(YumiPassiveAbilityMod1_HandleEffectStateChange, bAffected) == 0x000000, "Member 'YumiPassiveAbilityMod1_HandleEffectStateChange::bAffected' has a wrong offset!");
static_assert(offsetof(YumiPassiveAbilityMod1_HandleEffectStateChange, AffectedActor) == 0x000008, "Member 'YumiPassiveAbilityMod1_HandleEffectStateChange::AffectedActor' has a wrong offset!");

// Function DeceiveInc.YumiPassiveAbilityMod1.HandleMiscToolSpawned
// 0x0008 (0x0008 - 0x0000)
struct YumiPassiveAbilityMod1_HandleMiscToolSpawned final
{
public:
	class AActor*                                 SpawnedTool;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(YumiPassiveAbilityMod1_HandleMiscToolSpawned) == 0x000008, "Wrong alignment on YumiPassiveAbilityMod1_HandleMiscToolSpawned");
static_assert(sizeof(YumiPassiveAbilityMod1_HandleMiscToolSpawned) == 0x000008, "Wrong size on YumiPassiveAbilityMod1_HandleMiscToolSpawned");
static_assert(offsetof(YumiPassiveAbilityMod1_HandleMiscToolSpawned, SpawnedTool) == 0x000000, "Member 'YumiPassiveAbilityMod1_HandleMiscToolSpawned::SpawnedTool' has a wrong offset!");

// Function DeceiveInc.YumiPassiveAbilityMod1.HandlePlaceableSpawned
// 0x0008 (0x0008 - 0x0000)
struct YumiPassiveAbilityMod1_HandlePlaceableSpawned final
{
public:
	class ABasePlaceable*                         NewPlaceable;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(YumiPassiveAbilityMod1_HandlePlaceableSpawned) == 0x000008, "Wrong alignment on YumiPassiveAbilityMod1_HandlePlaceableSpawned");
static_assert(sizeof(YumiPassiveAbilityMod1_HandlePlaceableSpawned) == 0x000008, "Wrong size on YumiPassiveAbilityMod1_HandlePlaceableSpawned");
static_assert(offsetof(YumiPassiveAbilityMod1_HandlePlaceableSpawned, NewPlaceable) == 0x000000, "Member 'YumiPassiveAbilityMod1_HandlePlaceableSpawned::NewPlaceable' has a wrong offset!");

// Function DeceiveInc.YumiPassiveAbilityMod1.HandleSpyToolLoadComplete
// 0x0008 (0x0008 - 0x0000)
struct YumiPassiveAbilityMod1_HandleSpyToolLoadComplete final
{
public:
	class UToolLoadoutComponent*                  ToolLoadout;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(YumiPassiveAbilityMod1_HandleSpyToolLoadComplete) == 0x000008, "Wrong alignment on YumiPassiveAbilityMod1_HandleSpyToolLoadComplete");
static_assert(sizeof(YumiPassiveAbilityMod1_HandleSpyToolLoadComplete) == 0x000008, "Wrong size on YumiPassiveAbilityMod1_HandleSpyToolLoadComplete");
static_assert(offsetof(YumiPassiveAbilityMod1_HandleSpyToolLoadComplete, ToolLoadout) == 0x000000, "Member 'YumiPassiveAbilityMod1_HandleSpyToolLoadComplete::ToolLoadout' has a wrong offset!");

// Function DeceiveInc.YumiPassiveAbilityMod1.NotifyActorAffected_Multicast
// 0x0010 (0x0010 - 0x0000)
struct YumiPassiveAbilityMod1_NotifyActorAffected_Multicast final
{
public:
	class AActor*                                 AffectedActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffected;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(YumiPassiveAbilityMod1_NotifyActorAffected_Multicast) == 0x000008, "Wrong alignment on YumiPassiveAbilityMod1_NotifyActorAffected_Multicast");
static_assert(sizeof(YumiPassiveAbilityMod1_NotifyActorAffected_Multicast) == 0x000010, "Wrong size on YumiPassiveAbilityMod1_NotifyActorAffected_Multicast");
static_assert(offsetof(YumiPassiveAbilityMod1_NotifyActorAffected_Multicast, AffectedActor) == 0x000000, "Member 'YumiPassiveAbilityMod1_NotifyActorAffected_Multicast::AffectedActor' has a wrong offset!");
static_assert(offsetof(YumiPassiveAbilityMod1_NotifyActorAffected_Multicast, bAffected) == 0x000008, "Member 'YumiPassiveAbilityMod1_NotifyActorAffected_Multicast::bAffected' has a wrong offset!");

// Function DeceiveInc.SprayChargeSpawnerWeapon.BP_OnSprayImpacts
// 0x0018 (0x0018 - 0x0000)
struct SprayChargeSpawnerWeapon_BP_OnSprayImpacts final
{
public:
	class AProjectileWeapon*                      Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSprayShotImpact>               Impacts;                                           // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SprayChargeSpawnerWeapon_BP_OnSprayImpacts) == 0x000008, "Wrong alignment on SprayChargeSpawnerWeapon_BP_OnSprayImpacts");
static_assert(sizeof(SprayChargeSpawnerWeapon_BP_OnSprayImpacts) == 0x000018, "Wrong size on SprayChargeSpawnerWeapon_BP_OnSprayImpacts");
static_assert(offsetof(SprayChargeSpawnerWeapon_BP_OnSprayImpacts, Weapon) == 0x000000, "Member 'SprayChargeSpawnerWeapon_BP_OnSprayImpacts::Weapon' has a wrong offset!");
static_assert(offsetof(SprayChargeSpawnerWeapon_BP_OnSprayImpacts, Impacts) == 0x000008, "Member 'SprayChargeSpawnerWeapon_BP_OnSprayImpacts::Impacts' has a wrong offset!");

// Function DeceiveInc.SprayChargeSpawnerWeapon.BP_OnSprayNoDamageImpacts
// 0x0018 (0x0018 - 0x0000)
struct SprayChargeSpawnerWeapon_BP_OnSprayNoDamageImpacts final
{
public:
	class AProjectileWeapon*                      Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSprayShotImpact>               Impacts;                                           // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SprayChargeSpawnerWeapon_BP_OnSprayNoDamageImpacts) == 0x000008, "Wrong alignment on SprayChargeSpawnerWeapon_BP_OnSprayNoDamageImpacts");
static_assert(sizeof(SprayChargeSpawnerWeapon_BP_OnSprayNoDamageImpacts) == 0x000018, "Wrong size on SprayChargeSpawnerWeapon_BP_OnSprayNoDamageImpacts");
static_assert(offsetof(SprayChargeSpawnerWeapon_BP_OnSprayNoDamageImpacts, Weapon) == 0x000000, "Member 'SprayChargeSpawnerWeapon_BP_OnSprayNoDamageImpacts::Weapon' has a wrong offset!");
static_assert(offsetof(SprayChargeSpawnerWeapon_BP_OnSprayNoDamageImpacts, Impacts) == 0x000008, "Member 'SprayChargeSpawnerWeapon_BP_OnSprayNoDamageImpacts::Impacts' has a wrong offset!");

// Function DeceiveInc.SprayChargeSpawnerWeapon.BP_OnSprayShotFired
// 0x0018 (0x0018 - 0x0000)
struct SprayChargeSpawnerWeapon_BP_OnSprayShotFired final
{
public:
	TArray<struct FVector>                        ShotEndPoints;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AProjectileWeapon*                      Weapon;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SprayChargeSpawnerWeapon_BP_OnSprayShotFired) == 0x000008, "Wrong alignment on SprayChargeSpawnerWeapon_BP_OnSprayShotFired");
static_assert(sizeof(SprayChargeSpawnerWeapon_BP_OnSprayShotFired) == 0x000018, "Wrong size on SprayChargeSpawnerWeapon_BP_OnSprayShotFired");
static_assert(offsetof(SprayChargeSpawnerWeapon_BP_OnSprayShotFired, ShotEndPoints) == 0x000000, "Member 'SprayChargeSpawnerWeapon_BP_OnSprayShotFired::ShotEndPoints' has a wrong offset!");
static_assert(offsetof(SprayChargeSpawnerWeapon_BP_OnSprayShotFired, Weapon) == 0x000010, "Member 'SprayChargeSpawnerWeapon_BP_OnSprayShotFired::Weapon' has a wrong offset!");

// Function DeceiveInc.SprayWeapon.BP_OnSprayImpacts
// 0x0018 (0x0018 - 0x0000)
struct SprayWeapon_BP_OnSprayImpacts final
{
public:
	class AProjectileWeapon*                      Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSprayShotImpact>               Impacts;                                           // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SprayWeapon_BP_OnSprayImpacts) == 0x000008, "Wrong alignment on SprayWeapon_BP_OnSprayImpacts");
static_assert(sizeof(SprayWeapon_BP_OnSprayImpacts) == 0x000018, "Wrong size on SprayWeapon_BP_OnSprayImpacts");
static_assert(offsetof(SprayWeapon_BP_OnSprayImpacts, Weapon) == 0x000000, "Member 'SprayWeapon_BP_OnSprayImpacts::Weapon' has a wrong offset!");
static_assert(offsetof(SprayWeapon_BP_OnSprayImpacts, Impacts) == 0x000008, "Member 'SprayWeapon_BP_OnSprayImpacts::Impacts' has a wrong offset!");

// Function DeceiveInc.SprayWeapon.BP_OnSprayNoDamageImpacts
// 0x0018 (0x0018 - 0x0000)
struct SprayWeapon_BP_OnSprayNoDamageImpacts final
{
public:
	class AProjectileWeapon*                      Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSprayShotImpact>               Impacts;                                           // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SprayWeapon_BP_OnSprayNoDamageImpacts) == 0x000008, "Wrong alignment on SprayWeapon_BP_OnSprayNoDamageImpacts");
static_assert(sizeof(SprayWeapon_BP_OnSprayNoDamageImpacts) == 0x000018, "Wrong size on SprayWeapon_BP_OnSprayNoDamageImpacts");
static_assert(offsetof(SprayWeapon_BP_OnSprayNoDamageImpacts, Weapon) == 0x000000, "Member 'SprayWeapon_BP_OnSprayNoDamageImpacts::Weapon' has a wrong offset!");
static_assert(offsetof(SprayWeapon_BP_OnSprayNoDamageImpacts, Impacts) == 0x000008, "Member 'SprayWeapon_BP_OnSprayNoDamageImpacts::Impacts' has a wrong offset!");

// Function DeceiveInc.SprayWeapon.BP_OnSprayShotFired
// 0x0018 (0x0018 - 0x0000)
struct SprayWeapon_BP_OnSprayShotFired final
{
public:
	TArray<struct FVector>                        ShotEndPoints;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AProjectileWeapon*                      Weapon;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SprayWeapon_BP_OnSprayShotFired) == 0x000008, "Wrong alignment on SprayWeapon_BP_OnSprayShotFired");
static_assert(sizeof(SprayWeapon_BP_OnSprayShotFired) == 0x000018, "Wrong size on SprayWeapon_BP_OnSprayShotFired");
static_assert(offsetof(SprayWeapon_BP_OnSprayShotFired, ShotEndPoints) == 0x000000, "Member 'SprayWeapon_BP_OnSprayShotFired::ShotEndPoints' has a wrong offset!");
static_assert(offsetof(SprayWeapon_BP_OnSprayShotFired, Weapon) == 0x000010, "Member 'SprayWeapon_BP_OnSprayShotFired::Weapon' has a wrong offset!");

// Function DeceiveInc.Spy.AddAlwaysVisibleMesh
// 0x0008 (0x0008 - 0x0000)
struct Spy_AddAlwaysVisibleMesh final
{
public:
	class UMeshComponent*                         InMesh;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_AddAlwaysVisibleMesh) == 0x000008, "Wrong alignment on Spy_AddAlwaysVisibleMesh");
static_assert(sizeof(Spy_AddAlwaysVisibleMesh) == 0x000008, "Wrong size on Spy_AddAlwaysVisibleMesh");
static_assert(offsetof(Spy_AddAlwaysVisibleMesh, InMesh) == 0x000000, "Member 'Spy_AddAlwaysVisibleMesh::InMesh' has a wrong offset!");

// Function DeceiveInc.Spy.AddCoverAffectingSource
// 0x0010 (0x0010 - 0x0000)
struct Spy_AddCoverAffectingSource final
{
public:
	class AActor*                                 NewCoverDrainSource;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverAffectingSourceType                     NewCoverAffectingType;                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Spy_AddCoverAffectingSource) == 0x000008, "Wrong alignment on Spy_AddCoverAffectingSource");
static_assert(sizeof(Spy_AddCoverAffectingSource) == 0x000010, "Wrong size on Spy_AddCoverAffectingSource");
static_assert(offsetof(Spy_AddCoverAffectingSource, NewCoverDrainSource) == 0x000000, "Member 'Spy_AddCoverAffectingSource::NewCoverDrainSource' has a wrong offset!");
static_assert(offsetof(Spy_AddCoverAffectingSource, NewCoverAffectingType) == 0x000008, "Member 'Spy_AddCoverAffectingSource::NewCoverAffectingType' has a wrong offset!");

// Function DeceiveInc.Spy.AddCoverDrainSource
// 0x0010 (0x0010 - 0x0000)
struct Spy_AddCoverDrainSource final
{
public:
	class AActor*                                 NewCoverDrainSource;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewCoverDrain;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Spy_AddCoverDrainSource) == 0x000008, "Wrong alignment on Spy_AddCoverDrainSource");
static_assert(sizeof(Spy_AddCoverDrainSource) == 0x000010, "Wrong size on Spy_AddCoverDrainSource");
static_assert(offsetof(Spy_AddCoverDrainSource, NewCoverDrainSource) == 0x000000, "Member 'Spy_AddCoverDrainSource::NewCoverDrainSource' has a wrong offset!");
static_assert(offsetof(Spy_AddCoverDrainSource, NewCoverDrain) == 0x000008, "Member 'Spy_AddCoverDrainSource::NewCoverDrain' has a wrong offset!");

// Function DeceiveInc.Spy.AddEffectFromNPC
// 0x0008 (0x0008 - 0x0000)
struct Spy_AddEffectFromNPC final
{
public:
	class AVictimEffect*                          InNewEffect;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_AddEffectFromNPC) == 0x000008, "Wrong alignment on Spy_AddEffectFromNPC");
static_assert(sizeof(Spy_AddEffectFromNPC) == 0x000008, "Wrong size on Spy_AddEffectFromNPC");
static_assert(offsetof(Spy_AddEffectFromNPC, InNewEffect) == 0x000000, "Member 'Spy_AddEffectFromNPC::InNewEffect' has a wrong offset!");

// Function DeceiveInc.Spy.AddRecoverReduction
// 0x0004 (0x0004 - 0x0000)
struct Spy_AddRecoverReduction final
{
public:
	float                                         Reduction;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_AddRecoverReduction) == 0x000004, "Wrong alignment on Spy_AddRecoverReduction");
static_assert(sizeof(Spy_AddRecoverReduction) == 0x000004, "Wrong size on Spy_AddRecoverReduction");
static_assert(offsetof(Spy_AddRecoverReduction, Reduction) == 0x000000, "Member 'Spy_AddRecoverReduction::Reduction' has a wrong offset!");

// Function DeceiveInc.Spy.AddRunSpeedFactor
// 0x0010 (0x0010 - 0x0000)
struct Spy_AddRunSpeedFactor final
{
public:
	float                                         InNewSpeedFactor;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Source;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_AddRunSpeedFactor) == 0x000008, "Wrong alignment on Spy_AddRunSpeedFactor");
static_assert(sizeof(Spy_AddRunSpeedFactor) == 0x000010, "Wrong size on Spy_AddRunSpeedFactor");
static_assert(offsetof(Spy_AddRunSpeedFactor, InNewSpeedFactor) == 0x000000, "Member 'Spy_AddRunSpeedFactor::InNewSpeedFactor' has a wrong offset!");
static_assert(offsetof(Spy_AddRunSpeedFactor, Source) == 0x000008, "Member 'Spy_AddRunSpeedFactor::Source' has a wrong offset!");

// Function DeceiveInc.Spy.AddSlowSource
// 0x0010 (0x0010 - 0x0000)
struct Spy_AddSlowSource final
{
public:
	class AActor*                                 NewSlowSource;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewSlowPercent;                                    // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Spy_AddSlowSource) == 0x000008, "Wrong alignment on Spy_AddSlowSource");
static_assert(sizeof(Spy_AddSlowSource) == 0x000010, "Wrong size on Spy_AddSlowSource");
static_assert(offsetof(Spy_AddSlowSource, NewSlowSource) == 0x000000, "Member 'Spy_AddSlowSource::NewSlowSource' has a wrong offset!");
static_assert(offsetof(Spy_AddSlowSource, NewSlowPercent) == 0x000008, "Member 'Spy_AddSlowSource::NewSlowPercent' has a wrong offset!");

// Function DeceiveInc.Spy.AllowActiveAbility
// 0x0001 (0x0001 - 0x0000)
struct Spy_AllowActiveAbility final
{
public:
	bool                                          bAllow;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_AllowActiveAbility) == 0x000001, "Wrong alignment on Spy_AllowActiveAbility");
static_assert(sizeof(Spy_AllowActiveAbility) == 0x000001, "Wrong size on Spy_AllowActiveAbility");
static_assert(offsetof(Spy_AllowActiveAbility, bAllow) == 0x000000, "Member 'Spy_AllowActiveAbility::bAllow' has a wrong offset!");

// Function DeceiveInc.Spy.AllowCover
// 0x0001 (0x0001 - 0x0000)
struct Spy_AllowCover final
{
public:
	bool                                          bAllow;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_AllowCover) == 0x000001, "Wrong alignment on Spy_AllowCover");
static_assert(sizeof(Spy_AllowCover) == 0x000001, "Wrong size on Spy_AllowCover");
static_assert(offsetof(Spy_AllowCover, bAllow) == 0x000000, "Member 'Spy_AllowCover::bAllow' has a wrong offset!");

// Function DeceiveInc.Spy.AllowMelee
// 0x0001 (0x0001 - 0x0000)
struct Spy_AllowMelee final
{
public:
	bool                                          bAllow;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_AllowMelee) == 0x000001, "Wrong alignment on Spy_AllowMelee");
static_assert(sizeof(Spy_AllowMelee) == 0x000001, "Wrong size on Spy_AllowMelee");
static_assert(offsetof(Spy_AllowMelee, bAllow) == 0x000000, "Member 'Spy_AllowMelee::bAllow' has a wrong offset!");

// Function DeceiveInc.Spy.AllowNavMode
// 0x0001 (0x0001 - 0x0000)
struct Spy_AllowNavMode final
{
public:
	bool                                          bAllow;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_AllowNavMode) == 0x000001, "Wrong alignment on Spy_AllowNavMode");
static_assert(sizeof(Spy_AllowNavMode) == 0x000001, "Wrong size on Spy_AllowNavMode");
static_assert(offsetof(Spy_AllowNavMode, bAllow) == 0x000000, "Member 'Spy_AllowNavMode::bAllow' has a wrong offset!");

// Function DeceiveInc.Spy.AllowWeapon
// 0x0001 (0x0001 - 0x0000)
struct Spy_AllowWeapon final
{
public:
	bool                                          bAllow;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_AllowWeapon) == 0x000001, "Wrong alignment on Spy_AllowWeapon");
static_assert(sizeof(Spy_AllowWeapon) == 0x000001, "Wrong size on Spy_AllowWeapon");
static_assert(offsetof(Spy_AllowWeapon, bAllow) == 0x000000, "Member 'Spy_AllowWeapon::bAllow' has a wrong offset!");

// Function DeceiveInc.Spy.AttachCurrentToolToSocket
// 0x0008 (0x0008 - 0x0000)
struct Spy_AttachCurrentToolToSocket final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_AttachCurrentToolToSocket) == 0x000004, "Wrong alignment on Spy_AttachCurrentToolToSocket");
static_assert(sizeof(Spy_AttachCurrentToolToSocket) == 0x000008, "Wrong size on Spy_AttachCurrentToolToSocket");
static_assert(offsetof(Spy_AttachCurrentToolToSocket, SocketName) == 0x000000, "Member 'Spy_AttachCurrentToolToSocket::SocketName' has a wrong offset!");

// Function DeceiveInc.Spy.AttachToolToMainAttachment
// 0x0008 (0x0008 - 0x0000)
struct Spy_AttachToolToMainAttachment final
{
public:
	class ABaseSpyTool*                           ToolToAttatch;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_AttachToolToMainAttachment) == 0x000008, "Wrong alignment on Spy_AttachToolToMainAttachment");
static_assert(sizeof(Spy_AttachToolToMainAttachment) == 0x000008, "Wrong size on Spy_AttachToolToMainAttachment");
static_assert(offsetof(Spy_AttachToolToMainAttachment, ToolToAttatch) == 0x000000, "Member 'Spy_AttachToolToMainAttachment::ToolToAttatch' has a wrong offset!");

// Function DeceiveInc.Spy.AttachToolToMeshOnAlternateBone
// 0x0010 (0x0010 - 0x0000)
struct Spy_AttachToolToMeshOnAlternateBone final
{
public:
	class USkeletalMeshComponent*                 TargetMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_AttachToolToMeshOnAlternateBone) == 0x000008, "Wrong alignment on Spy_AttachToolToMeshOnAlternateBone");
static_assert(sizeof(Spy_AttachToolToMeshOnAlternateBone) == 0x000010, "Wrong size on Spy_AttachToolToMeshOnAlternateBone");
static_assert(offsetof(Spy_AttachToolToMeshOnAlternateBone, TargetMesh) == 0x000000, "Member 'Spy_AttachToolToMeshOnAlternateBone::TargetMesh' has a wrong offset!");
static_assert(offsetof(Spy_AttachToolToMeshOnAlternateBone, BoneName) == 0x000008, "Member 'Spy_AttachToolToMeshOnAlternateBone::BoneName' has a wrong offset!");

// Function DeceiveInc.Spy.AuthExternalBlowCover
// 0x0018 (0x0018 - 0x0000)
struct Spy_AuthExternalBlowCover final
{
public:
	class AController*                            InstigatedByIn;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 BlowCoverSourceActor;                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Spy_AuthExternalBlowCover) == 0x000008, "Wrong alignment on Spy_AuthExternalBlowCover");
static_assert(sizeof(Spy_AuthExternalBlowCover) == 0x000018, "Wrong size on Spy_AuthExternalBlowCover");
static_assert(offsetof(Spy_AuthExternalBlowCover, InstigatedByIn) == 0x000000, "Member 'Spy_AuthExternalBlowCover::InstigatedByIn' has a wrong offset!");
static_assert(offsetof(Spy_AuthExternalBlowCover, BlowCoverSourceActor) == 0x000008, "Member 'Spy_AuthExternalBlowCover::BlowCoverSourceActor' has a wrong offset!");
static_assert(offsetof(Spy_AuthExternalBlowCover, ReturnValue) == 0x000010, "Member 'Spy_AuthExternalBlowCover::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.BlockToolActions
// 0x0001 (0x0001 - 0x0000)
struct Spy_BlockToolActions final
{
public:
	bool                                          bBlock;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_BlockToolActions) == 0x000001, "Wrong alignment on Spy_BlockToolActions");
static_assert(sizeof(Spy_BlockToolActions) == 0x000001, "Wrong size on Spy_BlockToolActions");
static_assert(offsetof(Spy_BlockToolActions, bBlock) == 0x000000, "Member 'Spy_BlockToolActions::bBlock' has a wrong offset!");

// Function DeceiveInc.Spy.BP_BlockLeftHandFlavorAnimations
// 0x0002 (0x0002 - 0x0000)
struct Spy_BP_BlockLeftHandFlavorAnimations final
{
public:
	bool                                          bBlock;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBlockLeftHandFavorAnimationsBlueprintType    FlagIn;                                            // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_BP_BlockLeftHandFlavorAnimations) == 0x000001, "Wrong alignment on Spy_BP_BlockLeftHandFlavorAnimations");
static_assert(sizeof(Spy_BP_BlockLeftHandFlavorAnimations) == 0x000002, "Wrong size on Spy_BP_BlockLeftHandFlavorAnimations");
static_assert(offsetof(Spy_BP_BlockLeftHandFlavorAnimations, bBlock) == 0x000000, "Member 'Spy_BP_BlockLeftHandFlavorAnimations::bBlock' has a wrong offset!");
static_assert(offsetof(Spy_BP_BlockLeftHandFlavorAnimations, FlagIn) == 0x000001, "Member 'Spy_BP_BlockLeftHandFlavorAnimations::FlagIn' has a wrong offset!");

// Function DeceiveInc.Spy.BP_DebugGetShowRoomName
// 0x0001 (0x0001 - 0x0000)
struct Spy_BP_DebugGetShowRoomName final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_BP_DebugGetShowRoomName) == 0x000001, "Wrong alignment on Spy_BP_DebugGetShowRoomName");
static_assert(sizeof(Spy_BP_DebugGetShowRoomName) == 0x000001, "Wrong size on Spy_BP_DebugGetShowRoomName");
static_assert(offsetof(Spy_BP_DebugGetShowRoomName, ReturnValue) == 0x000000, "Member 'Spy_BP_DebugGetShowRoomName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.BP_GetCheatHideHuds
// 0x0001 (0x0001 - 0x0000)
struct Spy_BP_GetCheatHideHuds final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_BP_GetCheatHideHuds) == 0x000001, "Wrong alignment on Spy_BP_GetCheatHideHuds");
static_assert(sizeof(Spy_BP_GetCheatHideHuds) == 0x000001, "Wrong size on Spy_BP_GetCheatHideHuds");
static_assert(offsetof(Spy_BP_GetCheatHideHuds, ReturnValue) == 0x000000, "Member 'Spy_BP_GetCheatHideHuds::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.BP_OnCoverRatioUpdate
// 0x0004 (0x0004 - 0x0000)
struct Spy_BP_OnCoverRatioUpdate final
{
public:
	float                                         NewRatio;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_BP_OnCoverRatioUpdate) == 0x000004, "Wrong alignment on Spy_BP_OnCoverRatioUpdate");
static_assert(sizeof(Spy_BP_OnCoverRatioUpdate) == 0x000004, "Wrong size on Spy_BP_OnCoverRatioUpdate");
static_assert(offsetof(Spy_BP_OnCoverRatioUpdate, NewRatio) == 0x000000, "Member 'Spy_BP_OnCoverRatioUpdate::NewRatio' has a wrong offset!");

// Function DeceiveInc.Spy.BP_OnCoverSwitched
// 0x0010 (0x0010 - 0x0000)
struct Spy_BP_OnCoverSwitched final
{
public:
	class ANPCCharacter*                          NewDisguise;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFirstDisguise;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowFeedback;                                     // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Spy_BP_OnCoverSwitched) == 0x000008, "Wrong alignment on Spy_BP_OnCoverSwitched");
static_assert(sizeof(Spy_BP_OnCoverSwitched) == 0x000010, "Wrong size on Spy_BP_OnCoverSwitched");
static_assert(offsetof(Spy_BP_OnCoverSwitched, NewDisguise) == 0x000000, "Member 'Spy_BP_OnCoverSwitched::NewDisguise' has a wrong offset!");
static_assert(offsetof(Spy_BP_OnCoverSwitched, bIsFirstDisguise) == 0x000008, "Member 'Spy_BP_OnCoverSwitched::bIsFirstDisguise' has a wrong offset!");
static_assert(offsetof(Spy_BP_OnCoverSwitched, bShowFeedback) == 0x000009, "Member 'Spy_BP_OnCoverSwitched::bShowFeedback' has a wrong offset!");

// Function DeceiveInc.Spy.BP_OnCoverSwitchedVisualFeedback
// 0x0008 (0x0008 - 0x0000)
struct Spy_BP_OnCoverSwitchedVisualFeedback final
{
public:
	class ANPCCharacter*                          NewDisguise;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_BP_OnCoverSwitchedVisualFeedback) == 0x000008, "Wrong alignment on Spy_BP_OnCoverSwitchedVisualFeedback");
static_assert(sizeof(Spy_BP_OnCoverSwitchedVisualFeedback) == 0x000008, "Wrong size on Spy_BP_OnCoverSwitchedVisualFeedback");
static_assert(offsetof(Spy_BP_OnCoverSwitchedVisualFeedback, NewDisguise) == 0x000000, "Member 'Spy_BP_OnCoverSwitchedVisualFeedback::NewDisguise' has a wrong offset!");

// Function DeceiveInc.Spy.BP_OnHealthConsumableEvent
// 0x0001 (0x0001 - 0x0000)
struct Spy_BP_OnHealthConsumableEvent final
{
public:
	ESpyHealthConsumableEvent                     Event;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_BP_OnHealthConsumableEvent) == 0x000001, "Wrong alignment on Spy_BP_OnHealthConsumableEvent");
static_assert(sizeof(Spy_BP_OnHealthConsumableEvent) == 0x000001, "Wrong size on Spy_BP_OnHealthConsumableEvent");
static_assert(offsetof(Spy_BP_OnHealthConsumableEvent, Event) == 0x000000, "Member 'Spy_BP_OnHealthConsumableEvent::Event' has a wrong offset!");

// Function DeceiveInc.Spy.BP_OnHudLoaded
// 0x0008 (0x0008 - 0x0000)
struct Spy_BP_OnHudLoaded final
{
public:
	class UUserWidget*                            HUD;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_BP_OnHudLoaded) == 0x000008, "Wrong alignment on Spy_BP_OnHudLoaded");
static_assert(sizeof(Spy_BP_OnHudLoaded) == 0x000008, "Wrong size on Spy_BP_OnHudLoaded");
static_assert(offsetof(Spy_BP_OnHudLoaded, HUD) == 0x000000, "Member 'Spy_BP_OnHudLoaded::HUD' has a wrong offset!");

// Function DeceiveInc.Spy.BP_OnLocalFallLand
// 0x0008 (0x0008 - 0x0000)
struct Spy_BP_OnLocalFallLand final
{
public:
	int32                                         FallStep;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FallDamageAmount;                                  // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_BP_OnLocalFallLand) == 0x000004, "Wrong alignment on Spy_BP_OnLocalFallLand");
static_assert(sizeof(Spy_BP_OnLocalFallLand) == 0x000008, "Wrong size on Spy_BP_OnLocalFallLand");
static_assert(offsetof(Spy_BP_OnLocalFallLand, FallStep) == 0x000000, "Member 'Spy_BP_OnLocalFallLand::FallStep' has a wrong offset!");
static_assert(offsetof(Spy_BP_OnLocalFallLand, FallDamageAmount) == 0x000004, "Member 'Spy_BP_OnLocalFallLand::FallDamageAmount' has a wrong offset!");

// Function DeceiveInc.Spy.BPSetWantedHeatLevel
// 0x0004 (0x0004 - 0x0000)
struct Spy_BPSetWantedHeatLevel final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_BPSetWantedHeatLevel) == 0x000004, "Wrong alignment on Spy_BPSetWantedHeatLevel");
static_assert(sizeof(Spy_BPSetWantedHeatLevel) == 0x000004, "Wrong size on Spy_BPSetWantedHeatLevel");
static_assert(offsetof(Spy_BPSetWantedHeatLevel, Level) == 0x000000, "Member 'Spy_BPSetWantedHeatLevel::Level' has a wrong offset!");

// Function DeceiveInc.Spy.CanUseHealingConsumable
// 0x0001 (0x0001 - 0x0000)
struct Spy_CanUseHealingConsumable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_CanUseHealingConsumable) == 0x000001, "Wrong alignment on Spy_CanUseHealingConsumable");
static_assert(sizeof(Spy_CanUseHealingConsumable) == 0x000001, "Wrong size on Spy_CanUseHealingConsumable");
static_assert(offsetof(Spy_CanUseHealingConsumable, ReturnValue) == 0x000000, "Member 'Spy_CanUseHealingConsumable::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.Client_ObjectiveCarriedByYourTeam
// 0x0001 (0x0001 - 0x0000)
struct Spy_Client_ObjectiveCarriedByYourTeam final
{
public:
	bool                                          bYourFactionHasObjective;                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_Client_ObjectiveCarriedByYourTeam) == 0x000001, "Wrong alignment on Spy_Client_ObjectiveCarriedByYourTeam");
static_assert(sizeof(Spy_Client_ObjectiveCarriedByYourTeam) == 0x000001, "Wrong size on Spy_Client_ObjectiveCarriedByYourTeam");
static_assert(offsetof(Spy_Client_ObjectiveCarriedByYourTeam, bYourFactionHasObjective) == 0x000000, "Member 'Spy_Client_ObjectiveCarriedByYourTeam::bYourFactionHasObjective' has a wrong offset!");

// Function DeceiveInc.Spy.Client_ObjectiveDistanceProximityLevelChanged
// 0x0001 (0x0001 - 0x0000)
struct Spy_Client_ObjectiveDistanceProximityLevelChanged final
{
public:
	uint8                                         NewLevel;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_Client_ObjectiveDistanceProximityLevelChanged) == 0x000001, "Wrong alignment on Spy_Client_ObjectiveDistanceProximityLevelChanged");
static_assert(sizeof(Spy_Client_ObjectiveDistanceProximityLevelChanged) == 0x000001, "Wrong size on Spy_Client_ObjectiveDistanceProximityLevelChanged");
static_assert(offsetof(Spy_Client_ObjectiveDistanceProximityLevelChanged, NewLevel) == 0x000000, "Member 'Spy_Client_ObjectiveDistanceProximityLevelChanged::NewLevel' has a wrong offset!");

// Function DeceiveInc.Spy.Client_OnConfirmDamageDealt
// 0x0030 (0x0030 - 0x0000)
struct Spy_Client_OnConfirmDamageDealt final
{
public:
	class AActor*                                 DamagedActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UDamageType*                      DamageType;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDead;                                           // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Spy_Client_OnConfirmDamageDealt) == 0x000008, "Wrong alignment on Spy_Client_OnConfirmDamageDealt");
static_assert(sizeof(Spy_Client_OnConfirmDamageDealt) == 0x000030, "Wrong size on Spy_Client_OnConfirmDamageDealt");
static_assert(offsetof(Spy_Client_OnConfirmDamageDealt, DamagedActor) == 0x000000, "Member 'Spy_Client_OnConfirmDamageDealt::DamagedActor' has a wrong offset!");
static_assert(offsetof(Spy_Client_OnConfirmDamageDealt, Damage) == 0x000008, "Member 'Spy_Client_OnConfirmDamageDealt::Damage' has a wrong offset!");
static_assert(offsetof(Spy_Client_OnConfirmDamageDealt, DamageType) == 0x000010, "Member 'Spy_Client_OnConfirmDamageDealt::DamageType' has a wrong offset!");
static_assert(offsetof(Spy_Client_OnConfirmDamageDealt, InstigatedBy) == 0x000018, "Member 'Spy_Client_OnConfirmDamageDealt::InstigatedBy' has a wrong offset!");
static_assert(offsetof(Spy_Client_OnConfirmDamageDealt, DamageCauser) == 0x000020, "Member 'Spy_Client_OnConfirmDamageDealt::DamageCauser' has a wrong offset!");
static_assert(offsetof(Spy_Client_OnConfirmDamageDealt, bIsDead) == 0x000028, "Member 'Spy_Client_OnConfirmDamageDealt::bIsDead' has a wrong offset!");

// Function DeceiveInc.Spy.Client_OnFallLand
// 0x0008 (0x0008 - 0x0000)
struct Spy_Client_OnFallLand final
{
public:
	int32                                         FallStep;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FallDamageAmount;                                  // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_Client_OnFallLand) == 0x000004, "Wrong alignment on Spy_Client_OnFallLand");
static_assert(sizeof(Spy_Client_OnFallLand) == 0x000008, "Wrong size on Spy_Client_OnFallLand");
static_assert(offsetof(Spy_Client_OnFallLand, FallStep) == 0x000000, "Member 'Spy_Client_OnFallLand::FallStep' has a wrong offset!");
static_assert(offsetof(Spy_Client_OnFallLand, FallDamageAmount) == 0x000004, "Member 'Spy_Client_OnFallLand::FallDamageAmount' has a wrong offset!");

// Function DeceiveInc.Spy.Client_OnStartNPCInteract
// 0x0008 (0x0008 - 0x0000)
struct Spy_Client_OnStartNPCInteract final
{
public:
	class UNPCInteraction*                        InteractIn;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_Client_OnStartNPCInteract) == 0x000008, "Wrong alignment on Spy_Client_OnStartNPCInteract");
static_assert(sizeof(Spy_Client_OnStartNPCInteract) == 0x000008, "Wrong size on Spy_Client_OnStartNPCInteract");
static_assert(offsetof(Spy_Client_OnStartNPCInteract, InteractIn) == 0x000000, "Member 'Spy_Client_OnStartNPCInteract::InteractIn' has a wrong offset!");

// Function DeceiveInc.Spy.CreateAnimationProp
// 0x0028 (0x0028 - 0x0000)
struct Spy_CreateAnimationProp final
{
public:
	class FName                                   NameID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorToCreate;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocket;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstPerson;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_CreateAnimationProp) == 0x000008, "Wrong alignment on Spy_CreateAnimationProp");
static_assert(sizeof(Spy_CreateAnimationProp) == 0x000028, "Wrong size on Spy_CreateAnimationProp");
static_assert(offsetof(Spy_CreateAnimationProp, NameID) == 0x000000, "Member 'Spy_CreateAnimationProp::NameID' has a wrong offset!");
static_assert(offsetof(Spy_CreateAnimationProp, ActorToCreate) == 0x000008, "Member 'Spy_CreateAnimationProp::ActorToCreate' has a wrong offset!");
static_assert(offsetof(Spy_CreateAnimationProp, AttachSocket) == 0x000010, "Member 'Spy_CreateAnimationProp::AttachSocket' has a wrong offset!");
static_assert(offsetof(Spy_CreateAnimationProp, bFirstPerson) == 0x000018, "Member 'Spy_CreateAnimationProp::bFirstPerson' has a wrong offset!");
static_assert(offsetof(Spy_CreateAnimationProp, ReturnValue) == 0x000020, "Member 'Spy_CreateAnimationProp::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.DecrementHeat
// 0x0004 (0x0004 - 0x0000)
struct Spy_DecrementHeat final
{
public:
	int32                                         Decrement;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_DecrementHeat) == 0x000004, "Wrong alignment on Spy_DecrementHeat");
static_assert(sizeof(Spy_DecrementHeat) == 0x000004, "Wrong size on Spy_DecrementHeat");
static_assert(offsetof(Spy_DecrementHeat, Decrement) == 0x000000, "Member 'Spy_DecrementHeat::Decrement' has a wrong offset!");

// Function DeceiveInc.Spy.DestroyAnimationProp
// 0x000C (0x000C - 0x0000)
struct Spy_DestroyAnimationProp final
{
public:
	class FName                                   NameID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstPerson;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Spy_DestroyAnimationProp) == 0x000004, "Wrong alignment on Spy_DestroyAnimationProp");
static_assert(sizeof(Spy_DestroyAnimationProp) == 0x00000C, "Wrong size on Spy_DestroyAnimationProp");
static_assert(offsetof(Spy_DestroyAnimationProp, NameID) == 0x000000, "Member 'Spy_DestroyAnimationProp::NameID' has a wrong offset!");
static_assert(offsetof(Spy_DestroyAnimationProp, bFirstPerson) == 0x000008, "Member 'Spy_DestroyAnimationProp::bFirstPerson' has a wrong offset!");

// Function DeceiveInc.Spy.DisableBlockRun
// 0x0001 (0x0001 - 0x0000)
struct Spy_DisableBlockRun final
{
public:
	bool                                          bDisable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_DisableBlockRun) == 0x000001, "Wrong alignment on Spy_DisableBlockRun");
static_assert(sizeof(Spy_DisableBlockRun) == 0x000001, "Wrong size on Spy_DisableBlockRun");
static_assert(offsetof(Spy_DisableBlockRun, bDisable) == 0x000000, "Member 'Spy_DisableBlockRun::bDisable' has a wrong offset!");

// Function DeceiveInc.Spy.DisableRun
// 0x0010 (0x0010 - 0x0000)
struct Spy_DisableRun final
{
public:
	class AActor*                                 Source;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableRun;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Spy_DisableRun) == 0x000008, "Wrong alignment on Spy_DisableRun");
static_assert(sizeof(Spy_DisableRun) == 0x000010, "Wrong size on Spy_DisableRun");
static_assert(offsetof(Spy_DisableRun, Source) == 0x000000, "Member 'Spy_DisableRun::Source' has a wrong offset!");
static_assert(offsetof(Spy_DisableRun, bDisableRun) == 0x000008, "Member 'Spy_DisableRun::bDisableRun' has a wrong offset!");

// Function DeceiveInc.Spy.ExternalBounce
// 0x0018 (0x0018 - 0x0000)
struct Spy_ExternalBounce final
{
public:
	struct FVector                                ImpulseToApply;                                    // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 BouncedBy;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_ExternalBounce) == 0x000008, "Wrong alignment on Spy_ExternalBounce");
static_assert(sizeof(Spy_ExternalBounce) == 0x000018, "Wrong size on Spy_ExternalBounce");
static_assert(offsetof(Spy_ExternalBounce, ImpulseToApply) == 0x000000, "Member 'Spy_ExternalBounce::ImpulseToApply' has a wrong offset!");
static_assert(offsetof(Spy_ExternalBounce, BouncedBy) == 0x000010, "Member 'Spy_ExternalBounce::BouncedBy' has a wrong offset!");

// Function DeceiveInc.Spy.ExternalServerCompleteInteraction
// 0x0008 (0x0008 - 0x0000)
struct Spy_ExternalServerCompleteInteraction final
{
public:
	class UInteractableComponent*                 InteractableComp_0;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_ExternalServerCompleteInteraction) == 0x000008, "Wrong alignment on Spy_ExternalServerCompleteInteraction");
static_assert(sizeof(Spy_ExternalServerCompleteInteraction) == 0x000008, "Wrong size on Spy_ExternalServerCompleteInteraction");
static_assert(offsetof(Spy_ExternalServerCompleteInteraction, InteractableComp_0) == 0x000000, "Member 'Spy_ExternalServerCompleteInteraction::InteractableComp_0' has a wrong offset!");

// Function DeceiveInc.Spy.ExtractSetBlockingPlayer_Client
// 0x0001 (0x0001 - 0x0000)
struct Spy_ExtractSetBlockingPlayer_Client final
{
public:
	bool                                          bBlocking;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_ExtractSetBlockingPlayer_Client) == 0x000001, "Wrong alignment on Spy_ExtractSetBlockingPlayer_Client");
static_assert(sizeof(Spy_ExtractSetBlockingPlayer_Client) == 0x000001, "Wrong size on Spy_ExtractSetBlockingPlayer_Client");
static_assert(offsetof(Spy_ExtractSetBlockingPlayer_Client, bBlocking) == 0x000000, "Member 'Spy_ExtractSetBlockingPlayer_Client::bBlocking' has a wrong offset!");

// Function DeceiveInc.Spy.ExtractSetuptExtractZone_Client
// 0x0008 (0x0008 - 0x0000)
struct Spy_ExtractSetuptExtractZone_Client final
{
public:
	class AExtractionInteractableActor*           Extract;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_ExtractSetuptExtractZone_Client) == 0x000008, "Wrong alignment on Spy_ExtractSetuptExtractZone_Client");
static_assert(sizeof(Spy_ExtractSetuptExtractZone_Client) == 0x000008, "Wrong size on Spy_ExtractSetuptExtractZone_Client");
static_assert(offsetof(Spy_ExtractSetuptExtractZone_Client, Extract) == 0x000000, "Member 'Spy_ExtractSetuptExtractZone_Client::Extract' has a wrong offset!");

// Function DeceiveInc.Spy.Force3rdPersonView
// 0x0001 (0x0001 - 0x0000)
struct Spy_Force3rdPersonView final
{
public:
	bool                                          b3PForced;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_Force3rdPersonView) == 0x000001, "Wrong alignment on Spy_Force3rdPersonView");
static_assert(sizeof(Spy_Force3rdPersonView) == 0x000001, "Wrong size on Spy_Force3rdPersonView");
static_assert(offsetof(Spy_Force3rdPersonView, b3PForced) == 0x000000, "Member 'Spy_Force3rdPersonView::b3PForced' has a wrong offset!");

// Function DeceiveInc.Spy.GetAnimationProp
// 0x0018 (0x0018 - 0x0000)
struct Spy_GetAnimationProp final
{
public:
	class FName                                   NameID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstPerson;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetAnimationProp) == 0x000008, "Wrong alignment on Spy_GetAnimationProp");
static_assert(sizeof(Spy_GetAnimationProp) == 0x000018, "Wrong size on Spy_GetAnimationProp");
static_assert(offsetof(Spy_GetAnimationProp, NameID) == 0x000000, "Member 'Spy_GetAnimationProp::NameID' has a wrong offset!");
static_assert(offsetof(Spy_GetAnimationProp, bFirstPerson) == 0x000008, "Member 'Spy_GetAnimationProp::bFirstPerson' has a wrong offset!");
static_assert(offsetof(Spy_GetAnimationProp, ReturnValue) == 0x000010, "Member 'Spy_GetAnimationProp::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetCurrentHeatLevel
// 0x0004 (0x0004 - 0x0000)
struct Spy_GetCurrentHeatLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetCurrentHeatLevel) == 0x000004, "Wrong alignment on Spy_GetCurrentHeatLevel");
static_assert(sizeof(Spy_GetCurrentHeatLevel) == 0x000004, "Wrong size on Spy_GetCurrentHeatLevel");
static_assert(offsetof(Spy_GetCurrentHeatLevel, ReturnValue) == 0x000000, "Member 'Spy_GetCurrentHeatLevel::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetCurrentHeatValue
// 0x0004 (0x0004 - 0x0000)
struct Spy_GetCurrentHeatValue final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetCurrentHeatValue) == 0x000004, "Wrong alignment on Spy_GetCurrentHeatValue");
static_assert(sizeof(Spy_GetCurrentHeatValue) == 0x000004, "Wrong size on Spy_GetCurrentHeatValue");
static_assert(offsetof(Spy_GetCurrentHeatValue, ReturnValue) == 0x000000, "Member 'Spy_GetCurrentHeatValue::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetDIPlayerController
// 0x0008 (0x0008 - 0x0000)
struct Spy_GetDIPlayerController final
{
public:
	class ADeceiveIncPlayerController*            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetDIPlayerController) == 0x000008, "Wrong alignment on Spy_GetDIPlayerController");
static_assert(sizeof(Spy_GetDIPlayerController) == 0x000008, "Wrong size on Spy_GetDIPlayerController");
static_assert(offsetof(Spy_GetDIPlayerController, ReturnValue) == 0x000000, "Member 'Spy_GetDIPlayerController::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetPlayerHud
// 0x0008 (0x0008 - 0x0000)
struct Spy_GetPlayerHud final
{
public:
	class UUserWidget*                            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetPlayerHud) == 0x000008, "Wrong alignment on Spy_GetPlayerHud");
static_assert(sizeof(Spy_GetPlayerHud) == 0x000008, "Wrong size on Spy_GetPlayerHud");
static_assert(offsetof(Spy_GetPlayerHud, ReturnValue) == 0x000000, "Member 'Spy_GetPlayerHud::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetPowerupLevel
// 0x0003 (0x0003 - 0x0000)
struct Spy_GetPowerupLevel final
{
public:
	EPowerupType                                  Powerup;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESecurityLevel                                Level;                                             // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvailable;                                        // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetPowerupLevel) == 0x000001, "Wrong alignment on Spy_GetPowerupLevel");
static_assert(sizeof(Spy_GetPowerupLevel) == 0x000003, "Wrong size on Spy_GetPowerupLevel");
static_assert(offsetof(Spy_GetPowerupLevel, Powerup) == 0x000000, "Member 'Spy_GetPowerupLevel::Powerup' has a wrong offset!");
static_assert(offsetof(Spy_GetPowerupLevel, Level) == 0x000001, "Member 'Spy_GetPowerupLevel::Level' has a wrong offset!");
static_assert(offsetof(Spy_GetPowerupLevel, bAvailable) == 0x000002, "Member 'Spy_GetPowerupLevel::bAvailable' has a wrong offset!");

// Function DeceiveInc.Spy.GetSpyActiveEffectsOfClass
// 0x0018 (0x0018 - 0x0000)
struct Spy_GetSpyActiveEffectsOfClass final
{
public:
	class UClass*                                 EffectClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AVictimEffect*>                  ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetSpyActiveEffectsOfClass) == 0x000008, "Wrong alignment on Spy_GetSpyActiveEffectsOfClass");
static_assert(sizeof(Spy_GetSpyActiveEffectsOfClass) == 0x000018, "Wrong size on Spy_GetSpyActiveEffectsOfClass");
static_assert(offsetof(Spy_GetSpyActiveEffectsOfClass, EffectClass) == 0x000000, "Member 'Spy_GetSpyActiveEffectsOfClass::EffectClass' has a wrong offset!");
static_assert(offsetof(Spy_GetSpyActiveEffectsOfClass, ReturnValue) == 0x000008, "Member 'Spy_GetSpyActiveEffectsOfClass::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.HandleActiveAbilityLoadComplete
// 0x0008 (0x0008 - 0x0000)
struct Spy_HandleActiveAbilityLoadComplete final
{
public:
	class ABaseSpyTool*                           NewActiveAbility;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleActiveAbilityLoadComplete) == 0x000008, "Wrong alignment on Spy_HandleActiveAbilityLoadComplete");
static_assert(sizeof(Spy_HandleActiveAbilityLoadComplete) == 0x000008, "Wrong size on Spy_HandleActiveAbilityLoadComplete");
static_assert(offsetof(Spy_HandleActiveAbilityLoadComplete, NewActiveAbility) == 0x000000, "Member 'Spy_HandleActiveAbilityLoadComplete::NewActiveAbility' has a wrong offset!");

// Function DeceiveInc.Spy.HandleActiveHandToolEvent
// 0x0010 (0x0010 - 0x0000)
struct Spy_HandleActiveHandToolEvent final
{
public:
	ESpyToolEvent                                 EventType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSpyTool*                           SpyTool;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleActiveHandToolEvent) == 0x000008, "Wrong alignment on Spy_HandleActiveHandToolEvent");
static_assert(sizeof(Spy_HandleActiveHandToolEvent) == 0x000010, "Wrong size on Spy_HandleActiveHandToolEvent");
static_assert(offsetof(Spy_HandleActiveHandToolEvent, EventType) == 0x000000, "Member 'Spy_HandleActiveHandToolEvent::EventType' has a wrong offset!");
static_assert(offsetof(Spy_HandleActiveHandToolEvent, SpyTool) == 0x000008, "Member 'Spy_HandleActiveHandToolEvent::SpyTool' has a wrong offset!");

// Function DeceiveInc.Spy.HandleBooleanPlayerSettingChange
// 0x0002 (0x0002 - 0x0000)
struct Spy_HandleBooleanPlayerSettingChange final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewValue;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleBooleanPlayerSettingChange) == 0x000001, "Wrong alignment on Spy_HandleBooleanPlayerSettingChange");
static_assert(sizeof(Spy_HandleBooleanPlayerSettingChange) == 0x000002, "Wrong size on Spy_HandleBooleanPlayerSettingChange");
static_assert(offsetof(Spy_HandleBooleanPlayerSettingChange, SettingType) == 0x000000, "Member 'Spy_HandleBooleanPlayerSettingChange::SettingType' has a wrong offset!");
static_assert(offsetof(Spy_HandleBooleanPlayerSettingChange, NewValue) == 0x000001, "Member 'Spy_HandleBooleanPlayerSettingChange::NewValue' has a wrong offset!");

// Function DeceiveInc.Spy.HandleDeath
// 0x0008 (0x0008 - 0x0000)
struct Spy_HandleDeath final
{
public:
	class AActor*                                 DeadActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleDeath) == 0x000008, "Wrong alignment on Spy_HandleDeath");
static_assert(sizeof(Spy_HandleDeath) == 0x000008, "Wrong size on Spy_HandleDeath");
static_assert(offsetof(Spy_HandleDeath, DeadActor) == 0x000000, "Member 'Spy_HandleDeath::DeadActor' has a wrong offset!");

// Function DeceiveInc.Spy.HandleEMPIsAffectedChanged
// 0x0010 (0x0010 - 0x0000)
struct Spy_HandleEMPIsAffectedChanged final
{
public:
	bool                                          bIsAffected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AffectedActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleEMPIsAffectedChanged) == 0x000008, "Wrong alignment on Spy_HandleEMPIsAffectedChanged");
static_assert(sizeof(Spy_HandleEMPIsAffectedChanged) == 0x000010, "Wrong size on Spy_HandleEMPIsAffectedChanged");
static_assert(offsetof(Spy_HandleEMPIsAffectedChanged, bIsAffected) == 0x000000, "Member 'Spy_HandleEMPIsAffectedChanged::bIsAffected' has a wrong offset!");
static_assert(offsetof(Spy_HandleEMPIsAffectedChanged, AffectedActor) == 0x000008, "Member 'Spy_HandleEMPIsAffectedChanged::AffectedActor' has a wrong offset!");

// Function DeceiveInc.Spy.HandleFloatPlayerSettingChange
// 0x0008 (0x0008 - 0x0000)
struct Spy_HandleFloatPlayerSettingChange final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NewValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleFloatPlayerSettingChange) == 0x000004, "Wrong alignment on Spy_HandleFloatPlayerSettingChange");
static_assert(sizeof(Spy_HandleFloatPlayerSettingChange) == 0x000008, "Wrong size on Spy_HandleFloatPlayerSettingChange");
static_assert(offsetof(Spy_HandleFloatPlayerSettingChange, SettingType) == 0x000000, "Member 'Spy_HandleFloatPlayerSettingChange::SettingType' has a wrong offset!");
static_assert(offsetof(Spy_HandleFloatPlayerSettingChange, NewValue) == 0x000004, "Member 'Spy_HandleFloatPlayerSettingChange::NewValue' has a wrong offset!");

// Function DeceiveInc.Spy.HandleHealthChanged
// 0x0030 (0x0030 - 0x0000)
struct Spy_HandleHealthChanged final
{
public:
	class UHealthComponent*                       OwningHealthComp;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthDelta;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDamageType*                      DamageType;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RawDamage;                                         // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Spy_HandleHealthChanged) == 0x000008, "Wrong alignment on Spy_HandleHealthChanged");
static_assert(sizeof(Spy_HandleHealthChanged) == 0x000030, "Wrong size on Spy_HandleHealthChanged");
static_assert(offsetof(Spy_HandleHealthChanged, OwningHealthComp) == 0x000000, "Member 'Spy_HandleHealthChanged::OwningHealthComp' has a wrong offset!");
static_assert(offsetof(Spy_HandleHealthChanged, Health) == 0x000008, "Member 'Spy_HandleHealthChanged::Health' has a wrong offset!");
static_assert(offsetof(Spy_HandleHealthChanged, HealthDelta) == 0x00000C, "Member 'Spy_HandleHealthChanged::HealthDelta' has a wrong offset!");
static_assert(offsetof(Spy_HandleHealthChanged, DamageType) == 0x000010, "Member 'Spy_HandleHealthChanged::DamageType' has a wrong offset!");
static_assert(offsetof(Spy_HandleHealthChanged, InstigatedBy) == 0x000018, "Member 'Spy_HandleHealthChanged::InstigatedBy' has a wrong offset!");
static_assert(offsetof(Spy_HandleHealthChanged, DamageCauser) == 0x000020, "Member 'Spy_HandleHealthChanged::DamageCauser' has a wrong offset!");
static_assert(offsetof(Spy_HandleHealthChanged, RawDamage) == 0x000028, "Member 'Spy_HandleHealthChanged::RawDamage' has a wrong offset!");

// Function DeceiveInc.Spy.HandleInstigateZeroDamage
// 0x0020 (0x0020 - 0x0000)
struct Spy_HandleInstigateZeroDamage final
{
public:
	class UHealthComponent*                       OwningHealthComp;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDamageType*                      DamageType;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleInstigateZeroDamage) == 0x000008, "Wrong alignment on Spy_HandleInstigateZeroDamage");
static_assert(sizeof(Spy_HandleInstigateZeroDamage) == 0x000020, "Wrong size on Spy_HandleInstigateZeroDamage");
static_assert(offsetof(Spy_HandleInstigateZeroDamage, OwningHealthComp) == 0x000000, "Member 'Spy_HandleInstigateZeroDamage::OwningHealthComp' has a wrong offset!");
static_assert(offsetof(Spy_HandleInstigateZeroDamage, DamageType) == 0x000008, "Member 'Spy_HandleInstigateZeroDamage::DamageType' has a wrong offset!");
static_assert(offsetof(Spy_HandleInstigateZeroDamage, InstigatedBy) == 0x000010, "Member 'Spy_HandleInstigateZeroDamage::InstigatedBy' has a wrong offset!");
static_assert(offsetof(Spy_HandleInstigateZeroDamage, DamageCauser) == 0x000018, "Member 'Spy_HandleInstigateZeroDamage::DamageCauser' has a wrong offset!");

// Function DeceiveInc.Spy.HandleInteractableCompCancel
// 0x0010 (0x0010 - 0x0000)
struct Spy_HandleInteractableCompCancel final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleInteractableCompCancel) == 0x000008, "Wrong alignment on Spy_HandleInteractableCompCancel");
static_assert(sizeof(Spy_HandleInteractableCompCancel) == 0x000010, "Wrong size on Spy_HandleInteractableCompCancel");
static_assert(offsetof(Spy_HandleInteractableCompCancel, Interacter) == 0x000000, "Member 'Spy_HandleInteractableCompCancel::Interacter' has a wrong offset!");
static_assert(offsetof(Spy_HandleInteractableCompCancel, Interactable) == 0x000008, "Member 'Spy_HandleInteractableCompCancel::Interactable' has a wrong offset!");

// Function DeceiveInc.Spy.HandleInteractableCompStart
// 0x0010 (0x0010 - 0x0000)
struct Spy_HandleInteractableCompStart final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleInteractableCompStart) == 0x000008, "Wrong alignment on Spy_HandleInteractableCompStart");
static_assert(sizeof(Spy_HandleInteractableCompStart) == 0x000010, "Wrong size on Spy_HandleInteractableCompStart");
static_assert(offsetof(Spy_HandleInteractableCompStart, Interacter) == 0x000000, "Member 'Spy_HandleInteractableCompStart::Interacter' has a wrong offset!");
static_assert(offsetof(Spy_HandleInteractableCompStart, Interactable) == 0x000008, "Member 'Spy_HandleInteractableCompStart::Interactable' has a wrong offset!");

// Function DeceiveInc.Spy.HandleInteractionComplete
// 0x0010 (0x0010 - 0x0000)
struct Spy_HandleInteractionComplete final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleInteractionComplete) == 0x000008, "Wrong alignment on Spy_HandleInteractionComplete");
static_assert(sizeof(Spy_HandleInteractionComplete) == 0x000010, "Wrong size on Spy_HandleInteractionComplete");
static_assert(offsetof(Spy_HandleInteractionComplete, Interacter) == 0x000000, "Member 'Spy_HandleInteractionComplete::Interacter' has a wrong offset!");
static_assert(offsetof(Spy_HandleInteractionComplete, Interactable) == 0x000008, "Member 'Spy_HandleInteractionComplete::Interactable' has a wrong offset!");

// Function DeceiveInc.Spy.HandleIntPlayerSettingChange
// 0x0008 (0x0008 - 0x0000)
struct Spy_HandleIntPlayerSettingChange final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NewValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleIntPlayerSettingChange) == 0x000004, "Wrong alignment on Spy_HandleIntPlayerSettingChange");
static_assert(sizeof(Spy_HandleIntPlayerSettingChange) == 0x000008, "Wrong size on Spy_HandleIntPlayerSettingChange");
static_assert(offsetof(Spy_HandleIntPlayerSettingChange, SettingType) == 0x000000, "Member 'Spy_HandleIntPlayerSettingChange::SettingType' has a wrong offset!");
static_assert(offsetof(Spy_HandleIntPlayerSettingChange, NewValue) == 0x000004, "Member 'Spy_HandleIntPlayerSettingChange::NewValue' has a wrong offset!");

// Function DeceiveInc.Spy.HandleLoadoutSpawnCompleteEvent
// 0x0008 (0x0008 - 0x0000)
struct Spy_HandleLoadoutSpawnCompleteEvent final
{
public:
	class UToolLoadoutComponent*                  ToolLoadout;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleLoadoutSpawnCompleteEvent) == 0x000008, "Wrong alignment on Spy_HandleLoadoutSpawnCompleteEvent");
static_assert(sizeof(Spy_HandleLoadoutSpawnCompleteEvent) == 0x000008, "Wrong size on Spy_HandleLoadoutSpawnCompleteEvent");
static_assert(offsetof(Spy_HandleLoadoutSpawnCompleteEvent, ToolLoadout) == 0x000000, "Member 'Spy_HandleLoadoutSpawnCompleteEvent::ToolLoadout' has a wrong offset!");

// Function DeceiveInc.Spy.HandleLocalInteractionCanceled
// 0x0010 (0x0010 - 0x0000)
struct Spy_HandleLocalInteractionCanceled final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleLocalInteractionCanceled) == 0x000008, "Wrong alignment on Spy_HandleLocalInteractionCanceled");
static_assert(sizeof(Spy_HandleLocalInteractionCanceled) == 0x000010, "Wrong size on Spy_HandleLocalInteractionCanceled");
static_assert(offsetof(Spy_HandleLocalInteractionCanceled, Interacter) == 0x000000, "Member 'Spy_HandleLocalInteractionCanceled::Interacter' has a wrong offset!");
static_assert(offsetof(Spy_HandleLocalInteractionCanceled, Interactable) == 0x000008, "Member 'Spy_HandleLocalInteractionCanceled::Interactable' has a wrong offset!");

// Function DeceiveInc.Spy.HandleLocalInteractionComplete
// 0x0010 (0x0010 - 0x0000)
struct Spy_HandleLocalInteractionComplete final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleLocalInteractionComplete) == 0x000008, "Wrong alignment on Spy_HandleLocalInteractionComplete");
static_assert(sizeof(Spy_HandleLocalInteractionComplete) == 0x000010, "Wrong size on Spy_HandleLocalInteractionComplete");
static_assert(offsetof(Spy_HandleLocalInteractionComplete, Interacter) == 0x000000, "Member 'Spy_HandleLocalInteractionComplete::Interacter' has a wrong offset!");
static_assert(offsetof(Spy_HandleLocalInteractionComplete, Interactable) == 0x000008, "Member 'Spy_HandleLocalInteractionComplete::Interactable' has a wrong offset!");

// Function DeceiveInc.Spy.HandleLocalInteractionStart
// 0x0010 (0x0010 - 0x0000)
struct Spy_HandleLocalInteractionStart final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleLocalInteractionStart) == 0x000008, "Wrong alignment on Spy_HandleLocalInteractionStart");
static_assert(sizeof(Spy_HandleLocalInteractionStart) == 0x000010, "Wrong size on Spy_HandleLocalInteractionStart");
static_assert(offsetof(Spy_HandleLocalInteractionStart, Interacter) == 0x000000, "Member 'Spy_HandleLocalInteractionStart::Interacter' has a wrong offset!");
static_assert(offsetof(Spy_HandleLocalInteractionStart, Interactable) == 0x000008, "Member 'Spy_HandleLocalInteractionStart::Interactable' has a wrong offset!");

// Function DeceiveInc.Spy.HandleLocalResourceAmountChanged
// 0x0028 (0x0028 - 0x0000)
struct Spy_HandleLocalResourceAmountChanged final
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ResourceDisplayName;                               // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	int32                                         AmountDelta;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Spy_HandleLocalResourceAmountChanged) == 0x000008, "Wrong alignment on Spy_HandleLocalResourceAmountChanged");
static_assert(sizeof(Spy_HandleLocalResourceAmountChanged) == 0x000028, "Wrong size on Spy_HandleLocalResourceAmountChanged");
static_assert(offsetof(Spy_HandleLocalResourceAmountChanged, ResourceType) == 0x000000, "Member 'Spy_HandleLocalResourceAmountChanged::ResourceType' has a wrong offset!");
static_assert(offsetof(Spy_HandleLocalResourceAmountChanged, ResourceDisplayName) == 0x000008, "Member 'Spy_HandleLocalResourceAmountChanged::ResourceDisplayName' has a wrong offset!");
static_assert(offsetof(Spy_HandleLocalResourceAmountChanged, AmountDelta) == 0x000020, "Member 'Spy_HandleLocalResourceAmountChanged::AmountDelta' has a wrong offset!");

// Function DeceiveInc.Spy.HandleMeleeAttackLoadComplete
// 0x0008 (0x0008 - 0x0000)
struct Spy_HandleMeleeAttackLoadComplete final
{
public:
	class ABaseSpyTool*                           NewMeleeAttack;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleMeleeAttackLoadComplete) == 0x000008, "Wrong alignment on Spy_HandleMeleeAttackLoadComplete");
static_assert(sizeof(Spy_HandleMeleeAttackLoadComplete) == 0x000008, "Wrong size on Spy_HandleMeleeAttackLoadComplete");
static_assert(offsetof(Spy_HandleMeleeAttackLoadComplete, NewMeleeAttack) == 0x000000, "Member 'Spy_HandleMeleeAttackLoadComplete::NewMeleeAttack' has a wrong offset!");

// Function DeceiveInc.Spy.HandleNewRadialMenuPingSelection
// 0x0004 (0x0004 - 0x0000)
struct Spy_HandleNewRadialMenuPingSelection final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleNewRadialMenuPingSelection) == 0x000004, "Wrong alignment on Spy_HandleNewRadialMenuPingSelection");
static_assert(sizeof(Spy_HandleNewRadialMenuPingSelection) == 0x000004, "Wrong size on Spy_HandleNewRadialMenuPingSelection");
static_assert(offsetof(Spy_HandleNewRadialMenuPingSelection, Index_0) == 0x000000, "Member 'Spy_HandleNewRadialMenuPingSelection::Index_0' has a wrong offset!");

// Function DeceiveInc.Spy.HandleOverlapBegin
// 0x0010 (0x0010 - 0x0000)
struct Spy_HandleOverlapBegin final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleOverlapBegin) == 0x000008, "Wrong alignment on Spy_HandleOverlapBegin");
static_assert(sizeof(Spy_HandleOverlapBegin) == 0x000010, "Wrong size on Spy_HandleOverlapBegin");
static_assert(offsetof(Spy_HandleOverlapBegin, OverlappedActor) == 0x000000, "Member 'Spy_HandleOverlapBegin::OverlappedActor' has a wrong offset!");
static_assert(offsetof(Spy_HandleOverlapBegin, OtherActor) == 0x000008, "Member 'Spy_HandleOverlapBegin::OtherActor' has a wrong offset!");

// Function DeceiveInc.Spy.HandleOverlapEnd
// 0x0010 (0x0010 - 0x0000)
struct Spy_HandleOverlapEnd final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleOverlapEnd) == 0x000008, "Wrong alignment on Spy_HandleOverlapEnd");
static_assert(sizeof(Spy_HandleOverlapEnd) == 0x000010, "Wrong size on Spy_HandleOverlapEnd");
static_assert(offsetof(Spy_HandleOverlapEnd, OverlappedActor) == 0x000000, "Member 'Spy_HandleOverlapEnd::OverlappedActor' has a wrong offset!");
static_assert(offsetof(Spy_HandleOverlapEnd, OtherActor) == 0x000008, "Member 'Spy_HandleOverlapEnd::OtherActor' has a wrong offset!");

// Function DeceiveInc.Spy.HandleResourceNewAmount
// 0x0028 (0x0028 - 0x0000)
struct Spy_HandleResourceNewAmount final
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ResourceDisplayName;                               // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Spy_HandleResourceNewAmount) == 0x000008, "Wrong alignment on Spy_HandleResourceNewAmount");
static_assert(sizeof(Spy_HandleResourceNewAmount) == 0x000028, "Wrong size on Spy_HandleResourceNewAmount");
static_assert(offsetof(Spy_HandleResourceNewAmount, ResourceType) == 0x000000, "Member 'Spy_HandleResourceNewAmount::ResourceType' has a wrong offset!");
static_assert(offsetof(Spy_HandleResourceNewAmount, ResourceDisplayName) == 0x000008, "Member 'Spy_HandleResourceNewAmount::ResourceDisplayName' has a wrong offset!");
static_assert(offsetof(Spy_HandleResourceNewAmount, Amount) == 0x000020, "Member 'Spy_HandleResourceNewAmount::Amount' has a wrong offset!");

// Function DeceiveInc.Spy.HandleResultScreenStart
// 0x0008 (0x0008 - 0x0000)
struct Spy_HandleResultScreenStart final
{
public:
	class UResultScreenPhaseInfo*                 PhaseInfo;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleResultScreenStart) == 0x000008, "Wrong alignment on Spy_HandleResultScreenStart");
static_assert(sizeof(Spy_HandleResultScreenStart) == 0x000008, "Wrong size on Spy_HandleResultScreenStart");
static_assert(offsetof(Spy_HandleResultScreenStart, PhaseInfo) == 0x000000, "Member 'Spy_HandleResultScreenStart::PhaseInfo' has a wrong offset!");

// Function DeceiveInc.Spy.HandleRevive
// 0x0008 (0x0008 - 0x0000)
struct Spy_HandleRevive final
{
public:
	class AActor*                                 RevivedActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleRevive) == 0x000008, "Wrong alignment on Spy_HandleRevive");
static_assert(sizeof(Spy_HandleRevive) == 0x000008, "Wrong size on Spy_HandleRevive");
static_assert(offsetof(Spy_HandleRevive, RevivedActor) == 0x000000, "Member 'Spy_HandleRevive::RevivedActor' has a wrong offset!");

// Function DeceiveInc.Spy.HandleScramblerAffectingSourceRegister
// 0x0010 (0x0010 - 0x0000)
struct Spy_HandleScramblerAffectingSourceRegister final
{
public:
	class AActor*                                 AffectingSource;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AffectedActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleScramblerAffectingSourceRegister) == 0x000008, "Wrong alignment on Spy_HandleScramblerAffectingSourceRegister");
static_assert(sizeof(Spy_HandleScramblerAffectingSourceRegister) == 0x000010, "Wrong size on Spy_HandleScramblerAffectingSourceRegister");
static_assert(offsetof(Spy_HandleScramblerAffectingSourceRegister, AffectingSource) == 0x000000, "Member 'Spy_HandleScramblerAffectingSourceRegister::AffectingSource' has a wrong offset!");
static_assert(offsetof(Spy_HandleScramblerAffectingSourceRegister, AffectedActor) == 0x000008, "Member 'Spy_HandleScramblerAffectingSourceRegister::AffectedActor' has a wrong offset!");

// Function DeceiveInc.Spy.HandleScramblerAffectingSourceUnregister
// 0x0010 (0x0010 - 0x0000)
struct Spy_HandleScramblerAffectingSourceUnregister final
{
public:
	class AActor*                                 AffectingSource;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AffectedActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleScramblerAffectingSourceUnregister) == 0x000008, "Wrong alignment on Spy_HandleScramblerAffectingSourceUnregister");
static_assert(sizeof(Spy_HandleScramblerAffectingSourceUnregister) == 0x000010, "Wrong size on Spy_HandleScramblerAffectingSourceUnregister");
static_assert(offsetof(Spy_HandleScramblerAffectingSourceUnregister, AffectingSource) == 0x000000, "Member 'Spy_HandleScramblerAffectingSourceUnregister::AffectingSource' has a wrong offset!");
static_assert(offsetof(Spy_HandleScramblerAffectingSourceUnregister, AffectedActor) == 0x000008, "Member 'Spy_HandleScramblerAffectingSourceUnregister::AffectedActor' has a wrong offset!");

// Function DeceiveInc.Spy.HandleScramblerIsAffectedChanged
// 0x0010 (0x0010 - 0x0000)
struct Spy_HandleScramblerIsAffectedChanged final
{
public:
	bool                                          bIsAffected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AffectedActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleScramblerIsAffectedChanged) == 0x000008, "Wrong alignment on Spy_HandleScramblerIsAffectedChanged");
static_assert(sizeof(Spy_HandleScramblerIsAffectedChanged) == 0x000010, "Wrong size on Spy_HandleScramblerIsAffectedChanged");
static_assert(offsetof(Spy_HandleScramblerIsAffectedChanged, bIsAffected) == 0x000000, "Member 'Spy_HandleScramblerIsAffectedChanged::bIsAffected' has a wrong offset!");
static_assert(offsetof(Spy_HandleScramblerIsAffectedChanged, AffectedActor) == 0x000008, "Member 'Spy_HandleScramblerIsAffectedChanged::AffectedActor' has a wrong offset!");

// Function DeceiveInc.Spy.HandleSelectedToolChangeLoadoutEvent
// 0x0010 (0x0010 - 0x0000)
struct Spy_HandleSelectedToolChangeLoadoutEvent final
{
public:
	class ABaseSpyTool*                           NewToolInHand;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELoadoutSlot                                  NewSelectedSlot;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Spy_HandleSelectedToolChangeLoadoutEvent) == 0x000008, "Wrong alignment on Spy_HandleSelectedToolChangeLoadoutEvent");
static_assert(sizeof(Spy_HandleSelectedToolChangeLoadoutEvent) == 0x000010, "Wrong size on Spy_HandleSelectedToolChangeLoadoutEvent");
static_assert(offsetof(Spy_HandleSelectedToolChangeLoadoutEvent, NewToolInHand) == 0x000000, "Member 'Spy_HandleSelectedToolChangeLoadoutEvent::NewToolInHand' has a wrong offset!");
static_assert(offsetof(Spy_HandleSelectedToolChangeLoadoutEvent, NewSelectedSlot) == 0x000008, "Member 'Spy_HandleSelectedToolChangeLoadoutEvent::NewSelectedSlot' has a wrong offset!");

// Function DeceiveInc.Spy.HandleSpyToolLoadComplete
// 0x0008 (0x0008 - 0x0000)
struct Spy_HandleSpyToolLoadComplete final
{
public:
	class ABaseSpyTool*                           SpyTool;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleSpyToolLoadComplete) == 0x000008, "Wrong alignment on Spy_HandleSpyToolLoadComplete");
static_assert(sizeof(Spy_HandleSpyToolLoadComplete) == 0x000008, "Wrong size on Spy_HandleSpyToolLoadComplete");
static_assert(offsetof(Spy_HandleSpyToolLoadComplete, SpyTool) == 0x000000, "Member 'Spy_HandleSpyToolLoadComplete::SpyTool' has a wrong offset!");

// Function DeceiveInc.Spy.HandleTakePointDamage
// 0x0058 (0x0058 - 0x0000)
struct Spy_HandleTakePointDamage final
{
public:
	class AActor*                                 DamagedActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            InstigatedBy;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    FHitComponent;                                     // 0x0028(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ShotFromDirection;                                 // 0x0038(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UDamageType*                      DamageType;                                        // 0x0048(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0050(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleTakePointDamage) == 0x000008, "Wrong alignment on Spy_HandleTakePointDamage");
static_assert(sizeof(Spy_HandleTakePointDamage) == 0x000058, "Wrong size on Spy_HandleTakePointDamage");
static_assert(offsetof(Spy_HandleTakePointDamage, DamagedActor) == 0x000000, "Member 'Spy_HandleTakePointDamage::DamagedActor' has a wrong offset!");
static_assert(offsetof(Spy_HandleTakePointDamage, Damage) == 0x000008, "Member 'Spy_HandleTakePointDamage::Damage' has a wrong offset!");
static_assert(offsetof(Spy_HandleTakePointDamage, InstigatedBy) == 0x000010, "Member 'Spy_HandleTakePointDamage::InstigatedBy' has a wrong offset!");
static_assert(offsetof(Spy_HandleTakePointDamage, HitLocation) == 0x000018, "Member 'Spy_HandleTakePointDamage::HitLocation' has a wrong offset!");
static_assert(offsetof(Spy_HandleTakePointDamage, FHitComponent) == 0x000028, "Member 'Spy_HandleTakePointDamage::FHitComponent' has a wrong offset!");
static_assert(offsetof(Spy_HandleTakePointDamage, BoneName) == 0x000030, "Member 'Spy_HandleTakePointDamage::BoneName' has a wrong offset!");
static_assert(offsetof(Spy_HandleTakePointDamage, ShotFromDirection) == 0x000038, "Member 'Spy_HandleTakePointDamage::ShotFromDirection' has a wrong offset!");
static_assert(offsetof(Spy_HandleTakePointDamage, DamageType) == 0x000048, "Member 'Spy_HandleTakePointDamage::DamageType' has a wrong offset!");
static_assert(offsetof(Spy_HandleTakePointDamage, DamageCauser) == 0x000050, "Member 'Spy_HandleTakePointDamage::DamageCauser' has a wrong offset!");

// Function DeceiveInc.Spy.HandleWeaponHitConfirmed
// 0x0040 (0x0040 - 0x0000)
struct Spy_HandleWeaponHitConfirmed final
{
public:
	struct FHitConfirmData                        HitConfirmedData;                                  // 0x0000(0x0040)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleWeaponHitConfirmed) == 0x000008, "Wrong alignment on Spy_HandleWeaponHitConfirmed");
static_assert(sizeof(Spy_HandleWeaponHitConfirmed) == 0x000040, "Wrong size on Spy_HandleWeaponHitConfirmed");
static_assert(offsetof(Spy_HandleWeaponHitConfirmed, HitConfirmedData) == 0x000000, "Member 'Spy_HandleWeaponHitConfirmed::HitConfirmedData' has a wrong offset!");

// Function DeceiveInc.Spy.HandleWeaponProjectileImpact
// 0x0050 (0x0050 - 0x0000)
struct Spy_HandleWeaponProjectileImpact final
{
public:
	struct FWeaponImpactData                      WeaponImpactData;                                  // 0x0000(0x0050)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HandleWeaponProjectileImpact) == 0x000008, "Wrong alignment on Spy_HandleWeaponProjectileImpact");
static_assert(sizeof(Spy_HandleWeaponProjectileImpact) == 0x000050, "Wrong size on Spy_HandleWeaponProjectileImpact");
static_assert(offsetof(Spy_HandleWeaponProjectileImpact, WeaponImpactData) == 0x000000, "Member 'Spy_HandleWeaponProjectileImpact::WeaponImpactData' has a wrong offset!");

// Function DeceiveInc.Spy.HeatTriggerNPCHit
// 0x000C (0x000C - 0x0000)
struct Spy_HeatTriggerNPCHit final
{
public:
	int32                                         NPCSecurityIndex;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRatio;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNpcKilled;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Spy_HeatTriggerNPCHit) == 0x000004, "Wrong alignment on Spy_HeatTriggerNPCHit");
static_assert(sizeof(Spy_HeatTriggerNPCHit) == 0x00000C, "Wrong size on Spy_HeatTriggerNPCHit");
static_assert(offsetof(Spy_HeatTriggerNPCHit, NPCSecurityIndex) == 0x000000, "Member 'Spy_HeatTriggerNPCHit::NPCSecurityIndex' has a wrong offset!");
static_assert(offsetof(Spy_HeatTriggerNPCHit, DamageRatio) == 0x000004, "Member 'Spy_HeatTriggerNPCHit::DamageRatio' has a wrong offset!");
static_assert(offsetof(Spy_HeatTriggerNPCHit, bNpcKilled) == 0x000008, "Member 'Spy_HeatTriggerNPCHit::bNpcKilled' has a wrong offset!");

// Function DeceiveInc.Spy.HidePlayerHud
// 0x0008 (0x0008 - 0x0000)
struct Spy_HidePlayerHud final
{
public:
	class AActor*                                 Requester;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_HidePlayerHud) == 0x000008, "Wrong alignment on Spy_HidePlayerHud");
static_assert(sizeof(Spy_HidePlayerHud) == 0x000008, "Wrong size on Spy_HidePlayerHud");
static_assert(offsetof(Spy_HidePlayerHud, Requester) == 0x000000, "Member 'Spy_HidePlayerHud::Requester' has a wrong offset!");

// Function DeceiveInc.Spy.IncrementHeat
// 0x0004 (0x0004 - 0x0000)
struct Spy_IncrementHeat final
{
public:
	int32                                         Increment;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IncrementHeat) == 0x000004, "Wrong alignment on Spy_IncrementHeat");
static_assert(sizeof(Spy_IncrementHeat) == 0x000004, "Wrong size on Spy_IncrementHeat");
static_assert(offsetof(Spy_IncrementHeat, Increment) == 0x000000, "Member 'Spy_IncrementHeat::Increment' has a wrong offset!");

// Function DeceiveInc.Spy.IncrementStamina
// 0x0004 (0x0004 - 0x0000)
struct Spy_IncrementStamina final
{
public:
	float                                         Delta;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IncrementStamina) == 0x000004, "Wrong alignment on Spy_IncrementStamina");
static_assert(sizeof(Spy_IncrementStamina) == 0x000004, "Wrong size on Spy_IncrementStamina");
static_assert(offsetof(Spy_IncrementStamina, Delta) == 0x000000, "Member 'Spy_IncrementStamina::Delta' has a wrong offset!");

// Function DeceiveInc.Spy.IsScolded
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsScolded final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsScolded) == 0x000001, "Wrong alignment on Spy_IsScolded");
static_assert(sizeof(Spy_IsScolded) == 0x000001, "Wrong size on Spy_IsScolded");
static_assert(offsetof(Spy_IsScolded, ReturnValue) == 0x000000, "Member 'Spy_IsScolded::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsTeamAlive
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsTeamAlive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsTeamAlive) == 0x000001, "Wrong alignment on Spy_IsTeamAlive");
static_assert(sizeof(Spy_IsTeamAlive) == 0x000001, "Wrong size on Spy_IsTeamAlive");
static_assert(offsetof(Spy_IsTeamAlive, ReturnValue) == 0x000000, "Member 'Spy_IsTeamAlive::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.KeepRunAdditiveWhileRunningOutOfCover
// 0x0001 (0x0001 - 0x0000)
struct Spy_KeepRunAdditiveWhileRunningOutOfCover final
{
public:
	bool                                          bKeepAdditive;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_KeepRunAdditiveWhileRunningOutOfCover) == 0x000001, "Wrong alignment on Spy_KeepRunAdditiveWhileRunningOutOfCover");
static_assert(sizeof(Spy_KeepRunAdditiveWhileRunningOutOfCover) == 0x000001, "Wrong size on Spy_KeepRunAdditiveWhileRunningOutOfCover");
static_assert(offsetof(Spy_KeepRunAdditiveWhileRunningOutOfCover, bKeepAdditive) == 0x000000, "Member 'Spy_KeepRunAdditiveWhileRunningOutOfCover::bKeepAdditive' has a wrong offset!");

// Function DeceiveInc.Spy.MakeSpyAndDisguiseInvisible
// 0x0001 (0x0001 - 0x0000)
struct Spy_MakeSpyAndDisguiseInvisible final
{
public:
	bool                                          bInvisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_MakeSpyAndDisguiseInvisible) == 0x000001, "Wrong alignment on Spy_MakeSpyAndDisguiseInvisible");
static_assert(sizeof(Spy_MakeSpyAndDisguiseInvisible) == 0x000001, "Wrong size on Spy_MakeSpyAndDisguiseInvisible");
static_assert(offsetof(Spy_MakeSpyAndDisguiseInvisible, bInvisible) == 0x000000, "Member 'Spy_MakeSpyAndDisguiseInvisible::bInvisible' has a wrong offset!");

// Function DeceiveInc.Spy.NetMulticast_DirectionalDamageReceived
// 0x0014 (0x0014 - 0x0000)
struct Spy_NetMulticast_DirectionalDamageReceived final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    ShotFromDirection;                                 // 0x0004(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitType                                      HitType;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Spy_NetMulticast_DirectionalDamageReceived) == 0x000004, "Wrong alignment on Spy_NetMulticast_DirectionalDamageReceived");
static_assert(sizeof(Spy_NetMulticast_DirectionalDamageReceived) == 0x000014, "Wrong size on Spy_NetMulticast_DirectionalDamageReceived");
static_assert(offsetof(Spy_NetMulticast_DirectionalDamageReceived, Damage) == 0x000000, "Member 'Spy_NetMulticast_DirectionalDamageReceived::Damage' has a wrong offset!");
static_assert(offsetof(Spy_NetMulticast_DirectionalDamageReceived, ShotFromDirection) == 0x000004, "Member 'Spy_NetMulticast_DirectionalDamageReceived::ShotFromDirection' has a wrong offset!");
static_assert(offsetof(Spy_NetMulticast_DirectionalDamageReceived, HitType) == 0x000010, "Member 'Spy_NetMulticast_DirectionalDamageReceived::HitType' has a wrong offset!");

// Function DeceiveInc.Spy.NetMulticast_TriggerChangeDisguiseVisualFeedback
// 0x0008 (0x0008 - 0x0000)
struct Spy_NetMulticast_TriggerChangeDisguiseVisualFeedback final
{
public:
	class ANPCCharacter*                          NewDisguise;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_NetMulticast_TriggerChangeDisguiseVisualFeedback) == 0x000008, "Wrong alignment on Spy_NetMulticast_TriggerChangeDisguiseVisualFeedback");
static_assert(sizeof(Spy_NetMulticast_TriggerChangeDisguiseVisualFeedback) == 0x000008, "Wrong size on Spy_NetMulticast_TriggerChangeDisguiseVisualFeedback");
static_assert(offsetof(Spy_NetMulticast_TriggerChangeDisguiseVisualFeedback, NewDisguise) == 0x000000, "Member 'Spy_NetMulticast_TriggerChangeDisguiseVisualFeedback::NewDisguise' has a wrong offset!");

// Function DeceiveInc.Spy.NotifyAnimationStateJumpInChange
// 0x0001 (0x0001 - 0x0000)
struct Spy_NotifyAnimationStateJumpInChange final
{
public:
	bool                                          bJumpInStart;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_NotifyAnimationStateJumpInChange) == 0x000001, "Wrong alignment on Spy_NotifyAnimationStateJumpInChange");
static_assert(sizeof(Spy_NotifyAnimationStateJumpInChange) == 0x000001, "Wrong size on Spy_NotifyAnimationStateJumpInChange");
static_assert(offsetof(Spy_NotifyAnimationStateJumpInChange, bJumpInStart) == 0x000000, "Member 'Spy_NotifyAnimationStateJumpInChange::bJumpInStart' has a wrong offset!");

// Function DeceiveInc.Spy.OnADSChanged
// 0x0001 (0x0001 - 0x0000)
struct Spy_OnADSChanged final
{
public:
	bool                                          bADS;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_OnADSChanged) == 0x000001, "Wrong alignment on Spy_OnADSChanged");
static_assert(sizeof(Spy_OnADSChanged) == 0x000001, "Wrong size on Spy_OnADSChanged");
static_assert(offsetof(Spy_OnADSChanged, bADS) == 0x000000, "Member 'Spy_OnADSChanged::bADS' has a wrong offset!");

// Function DeceiveInc.Spy.OnAffectingSourceRegister
// 0x0010 (0x0010 - 0x0000)
struct Spy_OnAffectingSourceRegister final
{
public:
	class AActor*                                 AffectingSource;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AffectedActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_OnAffectingSourceRegister) == 0x000008, "Wrong alignment on Spy_OnAffectingSourceRegister");
static_assert(sizeof(Spy_OnAffectingSourceRegister) == 0x000010, "Wrong size on Spy_OnAffectingSourceRegister");
static_assert(offsetof(Spy_OnAffectingSourceRegister, AffectingSource) == 0x000000, "Member 'Spy_OnAffectingSourceRegister::AffectingSource' has a wrong offset!");
static_assert(offsetof(Spy_OnAffectingSourceRegister, AffectedActor) == 0x000008, "Member 'Spy_OnAffectingSourceRegister::AffectedActor' has a wrong offset!");

// Function DeceiveInc.Spy.OnAffectingSourceUnregister
// 0x0010 (0x0010 - 0x0000)
struct Spy_OnAffectingSourceUnregister final
{
public:
	class AActor*                                 AffectingSource;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AffectedActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_OnAffectingSourceUnregister) == 0x000008, "Wrong alignment on Spy_OnAffectingSourceUnregister");
static_assert(sizeof(Spy_OnAffectingSourceUnregister) == 0x000010, "Wrong size on Spy_OnAffectingSourceUnregister");
static_assert(offsetof(Spy_OnAffectingSourceUnregister, AffectingSource) == 0x000000, "Member 'Spy_OnAffectingSourceUnregister::AffectingSource' has a wrong offset!");
static_assert(offsetof(Spy_OnAffectingSourceUnregister, AffectedActor) == 0x000008, "Member 'Spy_OnAffectingSourceUnregister::AffectedActor' has a wrong offset!");

// DelegateFunction DeceiveInc.Spy.OnConfirmedDamageDealt__DelegateSignature
// 0x0028 (0x0028 - 0x0000)
struct Spy_OnConfirmedDamageDealt__DelegateSignature final
{
public:
	class AActor*                                 DamagedActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UDamageType*                      DamageType;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_OnConfirmedDamageDealt__DelegateSignature) == 0x000008, "Wrong alignment on Spy_OnConfirmedDamageDealt__DelegateSignature");
static_assert(sizeof(Spy_OnConfirmedDamageDealt__DelegateSignature) == 0x000028, "Wrong size on Spy_OnConfirmedDamageDealt__DelegateSignature");
static_assert(offsetof(Spy_OnConfirmedDamageDealt__DelegateSignature, DamagedActor) == 0x000000, "Member 'Spy_OnConfirmedDamageDealt__DelegateSignature::DamagedActor' has a wrong offset!");
static_assert(offsetof(Spy_OnConfirmedDamageDealt__DelegateSignature, Damage) == 0x000008, "Member 'Spy_OnConfirmedDamageDealt__DelegateSignature::Damage' has a wrong offset!");
static_assert(offsetof(Spy_OnConfirmedDamageDealt__DelegateSignature, DamageType) == 0x000010, "Member 'Spy_OnConfirmedDamageDealt__DelegateSignature::DamageType' has a wrong offset!");
static_assert(offsetof(Spy_OnConfirmedDamageDealt__DelegateSignature, InstigatedBy) == 0x000018, "Member 'Spy_OnConfirmedDamageDealt__DelegateSignature::InstigatedBy' has a wrong offset!");
static_assert(offsetof(Spy_OnConfirmedDamageDealt__DelegateSignature, DamageCauser) == 0x000020, "Member 'Spy_OnConfirmedDamageDealt__DelegateSignature::DamageCauser' has a wrong offset!");

// Function DeceiveInc.Spy.OnIntroPhaseStart
// 0x0008 (0x0008 - 0x0000)
struct Spy_OnIntroPhaseStart final
{
public:
	class UIntroPhaseInfo*                        PhaseInfo;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_OnIntroPhaseStart) == 0x000008, "Wrong alignment on Spy_OnIntroPhaseStart");
static_assert(sizeof(Spy_OnIntroPhaseStart) == 0x000008, "Wrong size on Spy_OnIntroPhaseStart");
static_assert(offsetof(Spy_OnIntroPhaseStart, PhaseInfo) == 0x000000, "Member 'Spy_OnIntroPhaseStart::PhaseInfo' has a wrong offset!");

// Function DeceiveInc.Spy.OnMeleeImpact
// 0x0068 (0x0068 - 0x0000)
struct Spy_OnMeleeImpact final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPoint;                                       // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChargeLevel;                                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultingHealthPercentage;                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitType                                      HitType;                                           // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMeleeHitConfirmedData                 HitConfirmedData;                                  // 0x0028(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_OnMeleeImpact) == 0x000008, "Wrong alignment on Spy_OnMeleeImpact");
static_assert(sizeof(Spy_OnMeleeImpact) == 0x000068, "Wrong size on Spy_OnMeleeImpact");
static_assert(offsetof(Spy_OnMeleeImpact, Victim) == 0x000000, "Member 'Spy_OnMeleeImpact::Victim' has a wrong offset!");
static_assert(offsetof(Spy_OnMeleeImpact, ImpactPoint) == 0x000008, "Member 'Spy_OnMeleeImpact::ImpactPoint' has a wrong offset!");
static_assert(offsetof(Spy_OnMeleeImpact, ChargeLevel) == 0x000014, "Member 'Spy_OnMeleeImpact::ChargeLevel' has a wrong offset!");
static_assert(offsetof(Spy_OnMeleeImpact, Damage) == 0x000018, "Member 'Spy_OnMeleeImpact::Damage' has a wrong offset!");
static_assert(offsetof(Spy_OnMeleeImpact, ResultingHealthPercentage) == 0x00001C, "Member 'Spy_OnMeleeImpact::ResultingHealthPercentage' has a wrong offset!");
static_assert(offsetof(Spy_OnMeleeImpact, HitType) == 0x000020, "Member 'Spy_OnMeleeImpact::HitType' has a wrong offset!");
static_assert(offsetof(Spy_OnMeleeImpact, HitConfirmedData) == 0x000028, "Member 'Spy_OnMeleeImpact::HitConfirmedData' has a wrong offset!");

// Function DeceiveInc.Spy.OnNewActiveCameraEvent
// 0x0010 (0x0010 - 0x0000)
struct Spy_OnNewActiveCameraEvent final
{
public:
	class UObject*                                NewActiveCamera;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraPriority                               NewCameraPriority;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Spy_OnNewActiveCameraEvent) == 0x000008, "Wrong alignment on Spy_OnNewActiveCameraEvent");
static_assert(sizeof(Spy_OnNewActiveCameraEvent) == 0x000010, "Wrong size on Spy_OnNewActiveCameraEvent");
static_assert(offsetof(Spy_OnNewActiveCameraEvent, NewActiveCamera) == 0x000000, "Member 'Spy_OnNewActiveCameraEvent::NewActiveCamera' has a wrong offset!");
static_assert(offsetof(Spy_OnNewActiveCameraEvent, NewCameraPriority) == 0x000008, "Member 'Spy_OnNewActiveCameraEvent::NewCameraPriority' has a wrong offset!");

// Function DeceiveInc.Spy.OnNewHighestWeightCameraEvent
// 0x0010 (0x0010 - 0x0000)
struct Spy_OnNewHighestWeightCameraEvent final
{
public:
	class UObject*                                NewActiveCamera;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraPriority                               NewCameraPriority;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Spy_OnNewHighestWeightCameraEvent) == 0x000008, "Wrong alignment on Spy_OnNewHighestWeightCameraEvent");
static_assert(sizeof(Spy_OnNewHighestWeightCameraEvent) == 0x000010, "Wrong size on Spy_OnNewHighestWeightCameraEvent");
static_assert(offsetof(Spy_OnNewHighestWeightCameraEvent, NewActiveCamera) == 0x000000, "Member 'Spy_OnNewHighestWeightCameraEvent::NewActiveCamera' has a wrong offset!");
static_assert(offsetof(Spy_OnNewHighestWeightCameraEvent, NewCameraPriority) == 0x000008, "Member 'Spy_OnNewHighestWeightCameraEvent::NewCameraPriority' has a wrong offset!");

// Function DeceiveInc.Spy.OnPowerupStateChangedClient
// 0x0003 (0x0003 - 0x0000)
struct Spy_OnPowerupStateChangedClient final
{
public:
	EPowerupType                                  PowerupType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESecurityLevel                                PowerupLevel;                                      // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdded;                                            // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_OnPowerupStateChangedClient) == 0x000001, "Wrong alignment on Spy_OnPowerupStateChangedClient");
static_assert(sizeof(Spy_OnPowerupStateChangedClient) == 0x000003, "Wrong size on Spy_OnPowerupStateChangedClient");
static_assert(offsetof(Spy_OnPowerupStateChangedClient, PowerupType) == 0x000000, "Member 'Spy_OnPowerupStateChangedClient::PowerupType' has a wrong offset!");
static_assert(offsetof(Spy_OnPowerupStateChangedClient, PowerupLevel) == 0x000001, "Member 'Spy_OnPowerupStateChangedClient::PowerupLevel' has a wrong offset!");
static_assert(offsetof(Spy_OnPowerupStateChangedClient, bAdded) == 0x000002, "Member 'Spy_OnPowerupStateChangedClient::bAdded' has a wrong offset!");

// Function DeceiveInc.Spy.OnPowerupStateChangedServer
// 0x0003 (0x0003 - 0x0000)
struct Spy_OnPowerupStateChangedServer final
{
public:
	EPowerupType                                  PowerupType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESecurityLevel                                PowerupLevel;                                      // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdded;                                            // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_OnPowerupStateChangedServer) == 0x000001, "Wrong alignment on Spy_OnPowerupStateChangedServer");
static_assert(sizeof(Spy_OnPowerupStateChangedServer) == 0x000003, "Wrong size on Spy_OnPowerupStateChangedServer");
static_assert(offsetof(Spy_OnPowerupStateChangedServer, PowerupType) == 0x000000, "Member 'Spy_OnPowerupStateChangedServer::PowerupType' has a wrong offset!");
static_assert(offsetof(Spy_OnPowerupStateChangedServer, PowerupLevel) == 0x000001, "Member 'Spy_OnPowerupStateChangedServer::PowerupLevel' has a wrong offset!");
static_assert(offsetof(Spy_OnPowerupStateChangedServer, bAdded) == 0x000002, "Member 'Spy_OnPowerupStateChangedServer::bAdded' has a wrong offset!");

// Function DeceiveInc.Spy.OnRep_ControlledByDisguise
// 0x001C (0x001C - 0x0000)
struct Spy_OnRep_ControlledByDisguise final
{
public:
	struct FControlledByDisguiseData              PrevControlledByDisguiseData;                      // 0x0000(0x001C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_OnRep_ControlledByDisguise) == 0x000004, "Wrong alignment on Spy_OnRep_ControlledByDisguise");
static_assert(sizeof(Spy_OnRep_ControlledByDisguise) == 0x00001C, "Wrong size on Spy_OnRep_ControlledByDisguise");
static_assert(offsetof(Spy_OnRep_ControlledByDisguise, PrevControlledByDisguiseData) == 0x000000, "Member 'Spy_OnRep_ControlledByDisguise::PrevControlledByDisguiseData' has a wrong offset!");

// Function DeceiveInc.Spy.OnRep_CoverDrainSpeed
// 0x0004 (0x0004 - 0x0000)
struct Spy_OnRep_CoverDrainSpeed final
{
public:
	float                                         OldCoverDrain;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_OnRep_CoverDrainSpeed) == 0x000004, "Wrong alignment on Spy_OnRep_CoverDrainSpeed");
static_assert(sizeof(Spy_OnRep_CoverDrainSpeed) == 0x000004, "Wrong size on Spy_OnRep_CoverDrainSpeed");
static_assert(offsetof(Spy_OnRep_CoverDrainSpeed, OldCoverDrain) == 0x000000, "Member 'Spy_OnRep_CoverDrainSpeed::OldCoverDrain' has a wrong offset!");

// Function DeceiveInc.Spy.OnRep_CoverRatio
// 0x0004 (0x0004 - 0x0000)
struct Spy_OnRep_CoverRatio final
{
public:
	float                                         PreviousCoverRatio;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_OnRep_CoverRatio) == 0x000004, "Wrong alignment on Spy_OnRep_CoverRatio");
static_assert(sizeof(Spy_OnRep_CoverRatio) == 0x000004, "Wrong size on Spy_OnRep_CoverRatio");
static_assert(offsetof(Spy_OnRep_CoverRatio, PreviousCoverRatio) == 0x000000, "Member 'Spy_OnRep_CoverRatio::PreviousCoverRatio' has a wrong offset!");

// Function DeceiveInc.Spy.OnRep_CrouchingSpeed
// 0x0004 (0x0004 - 0x0000)
struct Spy_OnRep_CrouchingSpeed final
{
public:
	float                                         PreviousCrouchingSpeed;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_OnRep_CrouchingSpeed) == 0x000004, "Wrong alignment on Spy_OnRep_CrouchingSpeed");
static_assert(sizeof(Spy_OnRep_CrouchingSpeed) == 0x000004, "Wrong size on Spy_OnRep_CrouchingSpeed");
static_assert(offsetof(Spy_OnRep_CrouchingSpeed, PreviousCrouchingSpeed) == 0x000000, "Member 'Spy_OnRep_CrouchingSpeed::PreviousCrouchingSpeed' has a wrong offset!");

// Function DeceiveInc.Spy.OnRep_Disguise
// 0x0010 (0x0010 - 0x0000)
struct Spy_OnRep_Disguise final
{
public:
	struct FDisguiseReplicationData               PreviousDisguiseData;                              // 0x0000(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_OnRep_Disguise) == 0x000008, "Wrong alignment on Spy_OnRep_Disguise");
static_assert(sizeof(Spy_OnRep_Disguise) == 0x000010, "Wrong size on Spy_OnRep_Disguise");
static_assert(offsetof(Spy_OnRep_Disguise, PreviousDisguiseData) == 0x000000, "Member 'Spy_OnRep_Disguise::PreviousDisguiseData' has a wrong offset!");

// Function DeceiveInc.Spy.OnRep_HeatInfo
// 0x0008 (0x0008 - 0x0000)
struct Spy_OnRep_HeatInfo final
{
public:
	struct FHeatStateData                         OldState;                                          // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_OnRep_HeatInfo) == 0x000004, "Wrong alignment on Spy_OnRep_HeatInfo");
static_assert(sizeof(Spy_OnRep_HeatInfo) == 0x000008, "Wrong size on Spy_OnRep_HeatInfo");
static_assert(offsetof(Spy_OnRep_HeatInfo, OldState) == 0x000000, "Member 'Spy_OnRep_HeatInfo::OldState' has a wrong offset!");

// Function DeceiveInc.Spy.OnRep_SecurityState
// 0x0001 (0x0001 - 0x0000)
struct Spy_OnRep_SecurityState final
{
public:
	ESpySecurityState                             PreviousSecurityState;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_OnRep_SecurityState) == 0x000001, "Wrong alignment on Spy_OnRep_SecurityState");
static_assert(sizeof(Spy_OnRep_SecurityState) == 0x000001, "Wrong size on Spy_OnRep_SecurityState");
static_assert(offsetof(Spy_OnRep_SecurityState, PreviousSecurityState) == 0x000000, "Member 'Spy_OnRep_SecurityState::PreviousSecurityState' has a wrong offset!");

// Function DeceiveInc.Spy.OnRep_UndercoverReplicationData
// 0x0008 (0x0008 - 0x0000)
struct Spy_OnRep_UndercoverReplicationData final
{
public:
	struct FUndercoverReplicationData             PreviousUndercoverReplicationData;                 // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_OnRep_UndercoverReplicationData) == 0x000004, "Wrong alignment on Spy_OnRep_UndercoverReplicationData");
static_assert(sizeof(Spy_OnRep_UndercoverReplicationData) == 0x000008, "Wrong size on Spy_OnRep_UndercoverReplicationData");
static_assert(offsetof(Spy_OnRep_UndercoverReplicationData, PreviousUndercoverReplicationData) == 0x000000, "Member 'Spy_OnRep_UndercoverReplicationData::PreviousUndercoverReplicationData' has a wrong offset!");

// Function DeceiveInc.Spy.OnRep_WalkingSpeed
// 0x0004 (0x0004 - 0x0000)
struct Spy_OnRep_WalkingSpeed final
{
public:
	float                                         PreviousWalkingSpeed;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_OnRep_WalkingSpeed) == 0x000004, "Wrong alignment on Spy_OnRep_WalkingSpeed");
static_assert(sizeof(Spy_OnRep_WalkingSpeed) == 0x000004, "Wrong size on Spy_OnRep_WalkingSpeed");
static_assert(offsetof(Spy_OnRep_WalkingSpeed, PreviousWalkingSpeed) == 0x000000, "Member 'Spy_OnRep_WalkingSpeed::PreviousWalkingSpeed' has a wrong offset!");

// DelegateFunction DeceiveInc.Spy.OnWeaponProjectileImpact__DelegateSignature
// 0x0048 (0x0048 - 0x0000)
struct Spy_OnWeaponProjectileImpact__DelegateSignature final
{
public:
	class ADeceiveIncPlayerController*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPoint;                                       // 0x0018(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactDirection;                                   // 0x0024(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactNormal;                                      // 0x0030(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AProjectileWeapon*                      Weapon;                                            // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_OnWeaponProjectileImpact__DelegateSignature) == 0x000008, "Wrong alignment on Spy_OnWeaponProjectileImpact__DelegateSignature");
static_assert(sizeof(Spy_OnWeaponProjectileImpact__DelegateSignature) == 0x000048, "Wrong size on Spy_OnWeaponProjectileImpact__DelegateSignature");
static_assert(offsetof(Spy_OnWeaponProjectileImpact__DelegateSignature, PlayerController) == 0x000000, "Member 'Spy_OnWeaponProjectileImpact__DelegateSignature::PlayerController' has a wrong offset!");
static_assert(offsetof(Spy_OnWeaponProjectileImpact__DelegateSignature, Spy) == 0x000008, "Member 'Spy_OnWeaponProjectileImpact__DelegateSignature::Spy' has a wrong offset!");
static_assert(offsetof(Spy_OnWeaponProjectileImpact__DelegateSignature, Victim) == 0x000010, "Member 'Spy_OnWeaponProjectileImpact__DelegateSignature::Victim' has a wrong offset!");
static_assert(offsetof(Spy_OnWeaponProjectileImpact__DelegateSignature, ImpactPoint) == 0x000018, "Member 'Spy_OnWeaponProjectileImpact__DelegateSignature::ImpactPoint' has a wrong offset!");
static_assert(offsetof(Spy_OnWeaponProjectileImpact__DelegateSignature, ImpactDirection) == 0x000024, "Member 'Spy_OnWeaponProjectileImpact__DelegateSignature::ImpactDirection' has a wrong offset!");
static_assert(offsetof(Spy_OnWeaponProjectileImpact__DelegateSignature, ImpactNormal) == 0x000030, "Member 'Spy_OnWeaponProjectileImpact__DelegateSignature::ImpactNormal' has a wrong offset!");
static_assert(offsetof(Spy_OnWeaponProjectileImpact__DelegateSignature, Weapon) == 0x000040, "Member 'Spy_OnWeaponProjectileImpact__DelegateSignature::Weapon' has a wrong offset!");

// Function DeceiveInc.Spy.ReduceStamina
// 0x0004 (0x0004 - 0x0000)
struct Spy_ReduceStamina final
{
public:
	float                                         Delta;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_ReduceStamina) == 0x000004, "Wrong alignment on Spy_ReduceStamina");
static_assert(sizeof(Spy_ReduceStamina) == 0x000004, "Wrong size on Spy_ReduceStamina");
static_assert(offsetof(Spy_ReduceStamina, Delta) == 0x000000, "Member 'Spy_ReduceStamina::Delta' has a wrong offset!");

// Function DeceiveInc.Spy.RemoveAlwaysVisibleMesh
// 0x0008 (0x0008 - 0x0000)
struct Spy_RemoveAlwaysVisibleMesh final
{
public:
	class UMeshComponent*                         InMesh;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_RemoveAlwaysVisibleMesh) == 0x000008, "Wrong alignment on Spy_RemoveAlwaysVisibleMesh");
static_assert(sizeof(Spy_RemoveAlwaysVisibleMesh) == 0x000008, "Wrong size on Spy_RemoveAlwaysVisibleMesh");
static_assert(offsetof(Spy_RemoveAlwaysVisibleMesh, InMesh) == 0x000000, "Member 'Spy_RemoveAlwaysVisibleMesh::InMesh' has a wrong offset!");

// Function DeceiveInc.Spy.RemoveCoverAffectingSource
// 0x0010 (0x0010 - 0x0000)
struct Spy_RemoveCoverAffectingSource final
{
public:
	class AActor*                                 NewCoverDrainSource;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverAffectingSourceType                     NewCoverAffectingType;                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Spy_RemoveCoverAffectingSource) == 0x000008, "Wrong alignment on Spy_RemoveCoverAffectingSource");
static_assert(sizeof(Spy_RemoveCoverAffectingSource) == 0x000010, "Wrong size on Spy_RemoveCoverAffectingSource");
static_assert(offsetof(Spy_RemoveCoverAffectingSource, NewCoverDrainSource) == 0x000000, "Member 'Spy_RemoveCoverAffectingSource::NewCoverDrainSource' has a wrong offset!");
static_assert(offsetof(Spy_RemoveCoverAffectingSource, NewCoverAffectingType) == 0x000008, "Member 'Spy_RemoveCoverAffectingSource::NewCoverAffectingType' has a wrong offset!");

// Function DeceiveInc.Spy.RemoveCoverDrainSource
// 0x0008 (0x0008 - 0x0000)
struct Spy_RemoveCoverDrainSource final
{
public:
	class AActor*                                 CoverDrainSourceToRemove;                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_RemoveCoverDrainSource) == 0x000008, "Wrong alignment on Spy_RemoveCoverDrainSource");
static_assert(sizeof(Spy_RemoveCoverDrainSource) == 0x000008, "Wrong size on Spy_RemoveCoverDrainSource");
static_assert(offsetof(Spy_RemoveCoverDrainSource, CoverDrainSourceToRemove) == 0x000000, "Member 'Spy_RemoveCoverDrainSource::CoverDrainSourceToRemove' has a wrong offset!");

// Function DeceiveInc.Spy.RemoveEffectFromNPC
// 0x0008 (0x0008 - 0x0000)
struct Spy_RemoveEffectFromNPC final
{
public:
	class AVictimEffect*                          InNewEffect;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_RemoveEffectFromNPC) == 0x000008, "Wrong alignment on Spy_RemoveEffectFromNPC");
static_assert(sizeof(Spy_RemoveEffectFromNPC) == 0x000008, "Wrong size on Spy_RemoveEffectFromNPC");
static_assert(offsetof(Spy_RemoveEffectFromNPC, InNewEffect) == 0x000000, "Member 'Spy_RemoveEffectFromNPC::InNewEffect' has a wrong offset!");

// Function DeceiveInc.Spy.RemoveRecoverReduction
// 0x0004 (0x0004 - 0x0000)
struct Spy_RemoveRecoverReduction final
{
public:
	float                                         Reduction;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_RemoveRecoverReduction) == 0x000004, "Wrong alignment on Spy_RemoveRecoverReduction");
static_assert(sizeof(Spy_RemoveRecoverReduction) == 0x000004, "Wrong size on Spy_RemoveRecoverReduction");
static_assert(offsetof(Spy_RemoveRecoverReduction, Reduction) == 0x000000, "Member 'Spy_RemoveRecoverReduction::Reduction' has a wrong offset!");

// Function DeceiveInc.Spy.RemoveRunSpeedFactor
// 0x0008 (0x0008 - 0x0000)
struct Spy_RemoveRunSpeedFactor final
{
public:
	class AActor*                                 Source;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_RemoveRunSpeedFactor) == 0x000008, "Wrong alignment on Spy_RemoveRunSpeedFactor");
static_assert(sizeof(Spy_RemoveRunSpeedFactor) == 0x000008, "Wrong size on Spy_RemoveRunSpeedFactor");
static_assert(offsetof(Spy_RemoveRunSpeedFactor, Source) == 0x000000, "Member 'Spy_RemoveRunSpeedFactor::Source' has a wrong offset!");

// Function DeceiveInc.Spy.RemoveSlowSource
// 0x0008 (0x0008 - 0x0000)
struct Spy_RemoveSlowSource final
{
public:
	class AActor*                                 SlowSourceToRemove;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_RemoveSlowSource) == 0x000008, "Wrong alignment on Spy_RemoveSlowSource");
static_assert(sizeof(Spy_RemoveSlowSource) == 0x000008, "Wrong size on Spy_RemoveSlowSource");
static_assert(offsetof(Spy_RemoveSlowSource, SlowSourceToRemove) == 0x000000, "Member 'Spy_RemoveSlowSource::SlowSourceToRemove' has a wrong offset!");

// Function DeceiveInc.Spy.ResetAttachToolToMesh
// 0x0008 (0x0008 - 0x0000)
struct Spy_ResetAttachToolToMesh final
{
public:
	class USkeletalMeshComponent*                 TargetMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_ResetAttachToolToMesh) == 0x000008, "Wrong alignment on Spy_ResetAttachToolToMesh");
static_assert(sizeof(Spy_ResetAttachToolToMesh) == 0x000008, "Wrong size on Spy_ResetAttachToolToMesh");
static_assert(offsetof(Spy_ResetAttachToolToMesh, TargetMesh) == 0x000000, "Member 'Spy_ResetAttachToolToMesh::TargetMesh' has a wrong offset!");

// Function DeceiveInc.Spy.Server_ExitNPCInteract
// 0x0001 (0x0001 - 0x0000)
struct Spy_Server_ExitNPCInteract final
{
public:
	bool                                          bInstant;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_Server_ExitNPCInteract) == 0x000001, "Wrong alignment on Spy_Server_ExitNPCInteract");
static_assert(sizeof(Spy_Server_ExitNPCInteract) == 0x000001, "Wrong size on Spy_Server_ExitNPCInteract");
static_assert(offsetof(Spy_Server_ExitNPCInteract, bInstant) == 0x000000, "Member 'Spy_Server_ExitNPCInteract::bInstant' has a wrong offset!");

// Function DeceiveInc.Spy.Server_SetCrouchingSpeed
// 0x0004 (0x0004 - 0x0000)
struct Spy_Server_SetCrouchingSpeed final
{
public:
	float                                         NewCrouchingSpeed;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_Server_SetCrouchingSpeed) == 0x000004, "Wrong alignment on Spy_Server_SetCrouchingSpeed");
static_assert(sizeof(Spy_Server_SetCrouchingSpeed) == 0x000004, "Wrong size on Spy_Server_SetCrouchingSpeed");
static_assert(offsetof(Spy_Server_SetCrouchingSpeed, NewCrouchingSpeed) == 0x000000, "Member 'Spy_Server_SetCrouchingSpeed::NewCrouchingSpeed' has a wrong offset!");

// Function DeceiveInc.Spy.Server_SetWalkingSpeed
// 0x0004 (0x0004 - 0x0000)
struct Spy_Server_SetWalkingSpeed final
{
public:
	float                                         NewWalkingSpeed;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_Server_SetWalkingSpeed) == 0x000004, "Wrong alignment on Spy_Server_SetWalkingSpeed");
static_assert(sizeof(Spy_Server_SetWalkingSpeed) == 0x000004, "Wrong size on Spy_Server_SetWalkingSpeed");
static_assert(offsetof(Spy_Server_SetWalkingSpeed, NewWalkingSpeed) == 0x000000, "Member 'Spy_Server_SetWalkingSpeed::NewWalkingSpeed' has a wrong offset!");

// Function DeceiveInc.Spy.Server_SpawnPing
// 0x0020 (0x0020 - 0x0000)
struct Spy_Server_SpawnPing final
{
public:
	struct FVector_NetQuantize                    Position;                                          // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUrgent;                                           // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RadialPingIndex;                                   // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_Server_SpawnPing) == 0x000008, "Wrong alignment on Spy_Server_SpawnPing");
static_assert(sizeof(Spy_Server_SpawnPing) == 0x000020, "Wrong size on Spy_Server_SpawnPing");
static_assert(offsetof(Spy_Server_SpawnPing, Position) == 0x000000, "Member 'Spy_Server_SpawnPing::Position' has a wrong offset!");
static_assert(offsetof(Spy_Server_SpawnPing, TargetActor) == 0x000010, "Member 'Spy_Server_SpawnPing::TargetActor' has a wrong offset!");
static_assert(offsetof(Spy_Server_SpawnPing, bUrgent) == 0x000018, "Member 'Spy_Server_SpawnPing::bUrgent' has a wrong offset!");
static_assert(offsetof(Spy_Server_SpawnPing, RadialPingIndex) == 0x00001C, "Member 'Spy_Server_SpawnPing::RadialPingIndex' has a wrong offset!");

// Function DeceiveInc.Spy.SetHandToolVisibilityFromAnimation
// 0x0002 (0x0002 - 0x0000)
struct Spy_SetHandToolVisibilityFromAnimation final
{
public:
	bool                                          bVisible;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstPerson;                                      // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_SetHandToolVisibilityFromAnimation) == 0x000001, "Wrong alignment on Spy_SetHandToolVisibilityFromAnimation");
static_assert(sizeof(Spy_SetHandToolVisibilityFromAnimation) == 0x000002, "Wrong size on Spy_SetHandToolVisibilityFromAnimation");
static_assert(offsetof(Spy_SetHandToolVisibilityFromAnimation, bVisible) == 0x000000, "Member 'Spy_SetHandToolVisibilityFromAnimation::bVisible' has a wrong offset!");
static_assert(offsetof(Spy_SetHandToolVisibilityFromAnimation, bFirstPerson) == 0x000001, "Member 'Spy_SetHandToolVisibilityFromAnimation::bFirstPerson' has a wrong offset!");

// Function DeceiveInc.Spy.SetHandToolVisibilityFromAnimationFlag
// 0x0003 (0x0003 - 0x0000)
struct Spy_SetHandToolVisibilityFromAnimationFlag final
{
public:
	EHandToolVisibilityFromAnimationFlag          FlagIn;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisible;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstPerson;                                      // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_SetHandToolVisibilityFromAnimationFlag) == 0x000001, "Wrong alignment on Spy_SetHandToolVisibilityFromAnimationFlag");
static_assert(sizeof(Spy_SetHandToolVisibilityFromAnimationFlag) == 0x000003, "Wrong size on Spy_SetHandToolVisibilityFromAnimationFlag");
static_assert(offsetof(Spy_SetHandToolVisibilityFromAnimationFlag, FlagIn) == 0x000000, "Member 'Spy_SetHandToolVisibilityFromAnimationFlag::FlagIn' has a wrong offset!");
static_assert(offsetof(Spy_SetHandToolVisibilityFromAnimationFlag, bVisible) == 0x000001, "Member 'Spy_SetHandToolVisibilityFromAnimationFlag::bVisible' has a wrong offset!");
static_assert(offsetof(Spy_SetHandToolVisibilityFromAnimationFlag, bFirstPerson) == 0x000002, "Member 'Spy_SetHandToolVisibilityFromAnimationFlag::bFirstPerson' has a wrong offset!");

// Function DeceiveInc.Spy.SetHandToolVisibilityFromAnimationFlag1PAnd3P
// 0x0002 (0x0002 - 0x0000)
struct Spy_SetHandToolVisibilityFromAnimationFlag1PAnd3P final
{
public:
	EHandToolVisibilityFromAnimationFlag          FlagIn;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisible;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_SetHandToolVisibilityFromAnimationFlag1PAnd3P) == 0x000001, "Wrong alignment on Spy_SetHandToolVisibilityFromAnimationFlag1PAnd3P");
static_assert(sizeof(Spy_SetHandToolVisibilityFromAnimationFlag1PAnd3P) == 0x000002, "Wrong size on Spy_SetHandToolVisibilityFromAnimationFlag1PAnd3P");
static_assert(offsetof(Spy_SetHandToolVisibilityFromAnimationFlag1PAnd3P, FlagIn) == 0x000000, "Member 'Spy_SetHandToolVisibilityFromAnimationFlag1PAnd3P::FlagIn' has a wrong offset!");
static_assert(offsetof(Spy_SetHandToolVisibilityFromAnimationFlag1PAnd3P, bVisible) == 0x000001, "Member 'Spy_SetHandToolVisibilityFromAnimationFlag1PAnd3P::bVisible' has a wrong offset!");

// Function DeceiveInc.Spy.SetIsHidden
// 0x0002 (0x0002 - 0x0000)
struct Spy_SetIsHidden final
{
public:
	bool                                          bNewHiddenState;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockShooting;                                    // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_SetIsHidden) == 0x000001, "Wrong alignment on Spy_SetIsHidden");
static_assert(sizeof(Spy_SetIsHidden) == 0x000002, "Wrong size on Spy_SetIsHidden");
static_assert(offsetof(Spy_SetIsHidden, bNewHiddenState) == 0x000000, "Member 'Spy_SetIsHidden::bNewHiddenState' has a wrong offset!");
static_assert(offsetof(Spy_SetIsHidden, bBlockShooting) == 0x000001, "Member 'Spy_SetIsHidden::bBlockShooting' has a wrong offset!");

// Function DeceiveInc.Spy.SetIsImmaterial
// 0x0002 (0x0002 - 0x0000)
struct Spy_SetIsImmaterial final
{
public:
	bool                                          bNewImaterialState;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockShooting;                                    // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_SetIsImmaterial) == 0x000001, "Wrong alignment on Spy_SetIsImmaterial");
static_assert(sizeof(Spy_SetIsImmaterial) == 0x000002, "Wrong size on Spy_SetIsImmaterial");
static_assert(offsetof(Spy_SetIsImmaterial, bNewImaterialState) == 0x000000, "Member 'Spy_SetIsImmaterial::bNewImaterialState' has a wrong offset!");
static_assert(offsetof(Spy_SetIsImmaterial, bBlockShooting) == 0x000001, "Member 'Spy_SetIsImmaterial::bBlockShooting' has a wrong offset!");

// Function DeceiveInc.Spy.SetJumpInAnimationSequence
// 0x0008 (0x0008 - 0x0000)
struct Spy_SetJumpInAnimationSequence final
{
public:
	class UAnimSequence*                          JumpInAnim;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_SetJumpInAnimationSequence) == 0x000008, "Wrong alignment on Spy_SetJumpInAnimationSequence");
static_assert(sizeof(Spy_SetJumpInAnimationSequence) == 0x000008, "Wrong size on Spy_SetJumpInAnimationSequence");
static_assert(offsetof(Spy_SetJumpInAnimationSequence, JumpInAnim) == 0x000000, "Member 'Spy_SetJumpInAnimationSequence::JumpInAnim' has a wrong offset!");

// Function DeceiveInc.Spy.SetRunDrainEnabled
// 0x0001 (0x0001 - 0x0000)
struct Spy_SetRunDrainEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_SetRunDrainEnabled) == 0x000001, "Wrong alignment on Spy_SetRunDrainEnabled");
static_assert(sizeof(Spy_SetRunDrainEnabled) == 0x000001, "Wrong size on Spy_SetRunDrainEnabled");
static_assert(offsetof(Spy_SetRunDrainEnabled, bEnabled) == 0x000000, "Member 'Spy_SetRunDrainEnabled::bEnabled' has a wrong offset!");

// Function DeceiveInc.Spy.SetSecondaryHandToolVisibilityFromAnimation
// 0x0002 (0x0002 - 0x0000)
struct Spy_SetSecondaryHandToolVisibilityFromAnimation final
{
public:
	bool                                          bVisible;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstPerson;                                      // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_SetSecondaryHandToolVisibilityFromAnimation) == 0x000001, "Wrong alignment on Spy_SetSecondaryHandToolVisibilityFromAnimation");
static_assert(sizeof(Spy_SetSecondaryHandToolVisibilityFromAnimation) == 0x000002, "Wrong size on Spy_SetSecondaryHandToolVisibilityFromAnimation");
static_assert(offsetof(Spy_SetSecondaryHandToolVisibilityFromAnimation, bVisible) == 0x000000, "Member 'Spy_SetSecondaryHandToolVisibilityFromAnimation::bVisible' has a wrong offset!");
static_assert(offsetof(Spy_SetSecondaryHandToolVisibilityFromAnimation, bFirstPerson) == 0x000001, "Member 'Spy_SetSecondaryHandToolVisibilityFromAnimation::bFirstPerson' has a wrong offset!");

// Function DeceiveInc.Spy.SetupHeat
// 0x0050 (0x0050 - 0x0000)
struct Spy_SetupHeat final
{
public:
	struct FHeatSetupData                         NewHeatSetup;                                      // 0x0000(0x0050)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_SetupHeat) == 0x000008, "Wrong alignment on Spy_SetupHeat");
static_assert(sizeof(Spy_SetupHeat) == 0x000050, "Wrong size on Spy_SetupHeat");
static_assert(offsetof(Spy_SetupHeat, NewHeatSetup) == 0x000000, "Member 'Spy_SetupHeat::NewHeatSetup' has a wrong offset!");

// Function DeceiveInc.Spy.SetWeapon1PMesh
// 0x0008 (0x0008 - 0x0000)
struct Spy_SetWeapon1PMesh final
{
public:
	class UMeshComponent*                         WeaponMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_SetWeapon1PMesh) == 0x000008, "Wrong alignment on Spy_SetWeapon1PMesh");
static_assert(sizeof(Spy_SetWeapon1PMesh) == 0x000008, "Wrong size on Spy_SetWeapon1PMesh");
static_assert(offsetof(Spy_SetWeapon1PMesh, WeaponMesh) == 0x000000, "Member 'Spy_SetWeapon1PMesh::WeaponMesh' has a wrong offset!");

// Function DeceiveInc.Spy.SetWeapon3PMesh
// 0x0008 (0x0008 - 0x0000)
struct Spy_SetWeapon3PMesh final
{
public:
	class UMeshComponent*                         WeaponMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_SetWeapon3PMesh) == 0x000008, "Wrong alignment on Spy_SetWeapon3PMesh");
static_assert(sizeof(Spy_SetWeapon3PMesh) == 0x000008, "Wrong size on Spy_SetWeapon3PMesh");
static_assert(offsetof(Spy_SetWeapon3PMesh, WeaponMesh) == 0x000000, "Member 'Spy_SetWeapon3PMesh::WeaponMesh' has a wrong offset!");

// Function DeceiveInc.Spy.ShowPlayerHud
// 0x0008 (0x0008 - 0x0000)
struct Spy_ShowPlayerHud final
{
public:
	class AActor*                                 Requester;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_ShowPlayerHud) == 0x000008, "Wrong alignment on Spy_ShowPlayerHud");
static_assert(sizeof(Spy_ShowPlayerHud) == 0x000008, "Wrong size on Spy_ShowPlayerHud");
static_assert(offsetof(Spy_ShowPlayerHud, Requester) == 0x000000, "Member 'Spy_ShowPlayerHud::Requester' has a wrong offset!");

// Function DeceiveInc.Spy.TestOcclusionCollisionOfJointFromLocalCamera
// 0x000C (0x000C - 0x0000)
struct Spy_TestOcclusionCollisionOfJointFromLocalCamera final
{
public:
	class FName                                   JointName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Spy_TestOcclusionCollisionOfJointFromLocalCamera) == 0x000004, "Wrong alignment on Spy_TestOcclusionCollisionOfJointFromLocalCamera");
static_assert(sizeof(Spy_TestOcclusionCollisionOfJointFromLocalCamera) == 0x00000C, "Wrong size on Spy_TestOcclusionCollisionOfJointFromLocalCamera");
static_assert(offsetof(Spy_TestOcclusionCollisionOfJointFromLocalCamera, JointName) == 0x000000, "Member 'Spy_TestOcclusionCollisionOfJointFromLocalCamera::JointName' has a wrong offset!");
static_assert(offsetof(Spy_TestOcclusionCollisionOfJointFromLocalCamera, ReturnValue) == 0x000008, "Member 'Spy_TestOcclusionCollisionOfJointFromLocalCamera::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.TriggerHealthConsumableEvent
// 0x0001 (0x0001 - 0x0000)
struct Spy_TriggerHealthConsumableEvent final
{
public:
	ESpyHealthConsumableEvent                     Event;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_TriggerHealthConsumableEvent) == 0x000001, "Wrong alignment on Spy_TriggerHealthConsumableEvent");
static_assert(sizeof(Spy_TriggerHealthConsumableEvent) == 0x000001, "Wrong size on Spy_TriggerHealthConsumableEvent");
static_assert(offsetof(Spy_TriggerHealthConsumableEvent, Event) == 0x000000, "Member 'Spy_TriggerHealthConsumableEvent::Event' has a wrong offset!");

// Function DeceiveInc.Spy.TriggerHealthConsumableEventServer
// 0x0001 (0x0001 - 0x0000)
struct Spy_TriggerHealthConsumableEventServer final
{
public:
	ESpyHealthConsumableEvent                     Event;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_TriggerHealthConsumableEventServer) == 0x000001, "Wrong alignment on Spy_TriggerHealthConsumableEventServer");
static_assert(sizeof(Spy_TriggerHealthConsumableEventServer) == 0x000001, "Wrong size on Spy_TriggerHealthConsumableEventServer");
static_assert(offsetof(Spy_TriggerHealthConsumableEventServer, Event) == 0x000000, "Member 'Spy_TriggerHealthConsumableEventServer::Event' has a wrong offset!");

// Function DeceiveInc.Spy.AreLeftHandFlavorAnimationsAllowed
// 0x0001 (0x0001 - 0x0000)
struct Spy_AreLeftHandFlavorAnimationsAllowed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_AreLeftHandFlavorAnimationsAllowed) == 0x000001, "Wrong alignment on Spy_AreLeftHandFlavorAnimationsAllowed");
static_assert(sizeof(Spy_AreLeftHandFlavorAnimationsAllowed) == 0x000001, "Wrong size on Spy_AreLeftHandFlavorAnimationsAllowed");
static_assert(offsetof(Spy_AreLeftHandFlavorAnimationsAllowed, ReturnValue) == 0x000000, "Member 'Spy_AreLeftHandFlavorAnimationsAllowed::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.CanBeRevive
// 0x0001 (0x0001 - 0x0000)
struct Spy_CanBeRevive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_CanBeRevive) == 0x000001, "Wrong alignment on Spy_CanBeRevive");
static_assert(sizeof(Spy_CanBeRevive) == 0x000001, "Wrong size on Spy_CanBeRevive");
static_assert(offsetof(Spy_CanBeRevive, ReturnValue) == 0x000000, "Member 'Spy_CanBeRevive::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetActiveAbilityTool
// 0x0008 (0x0008 - 0x0000)
struct Spy_GetActiveAbilityTool final
{
public:
	class ABaseSpyActiveAbility*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetActiveAbilityTool) == 0x000008, "Wrong alignment on Spy_GetActiveAbilityTool");
static_assert(sizeof(Spy_GetActiveAbilityTool) == 0x000008, "Wrong size on Spy_GetActiveAbilityTool");
static_assert(offsetof(Spy_GetActiveAbilityTool, ReturnValue) == 0x000000, "Member 'Spy_GetActiveAbilityTool::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetAgentExpertiseSkillData
// 0x0008 (0x0008 - 0x0000)
struct Spy_GetAgentExpertiseSkillData final
{
public:
	class UAgentExpertiseSkillData*               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetAgentExpertiseSkillData) == 0x000008, "Wrong alignment on Spy_GetAgentExpertiseSkillData");
static_assert(sizeof(Spy_GetAgentExpertiseSkillData) == 0x000008, "Wrong size on Spy_GetAgentExpertiseSkillData");
static_assert(offsetof(Spy_GetAgentExpertiseSkillData, ReturnValue) == 0x000000, "Member 'Spy_GetAgentExpertiseSkillData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetAgentExpertiseVariantIndex
// 0x0004 (0x0004 - 0x0000)
struct Spy_GetAgentExpertiseVariantIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetAgentExpertiseVariantIndex) == 0x000004, "Wrong alignment on Spy_GetAgentExpertiseVariantIndex");
static_assert(sizeof(Spy_GetAgentExpertiseVariantIndex) == 0x000004, "Wrong size on Spy_GetAgentExpertiseVariantIndex");
static_assert(offsetof(Spy_GetAgentExpertiseVariantIndex, ReturnValue) == 0x000000, "Member 'Spy_GetAgentExpertiseVariantIndex::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetAgentPassiveSkillData
// 0x0008 (0x0008 - 0x0000)
struct Spy_GetAgentPassiveSkillData final
{
public:
	class UAgentPassiveSkillData*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetAgentPassiveSkillData) == 0x000008, "Wrong alignment on Spy_GetAgentPassiveSkillData");
static_assert(sizeof(Spy_GetAgentPassiveSkillData) == 0x000008, "Wrong size on Spy_GetAgentPassiveSkillData");
static_assert(offsetof(Spy_GetAgentPassiveSkillData, ReturnValue) == 0x000000, "Member 'Spy_GetAgentPassiveSkillData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetAgentPassiveVariantIndex
// 0x0004 (0x0004 - 0x0000)
struct Spy_GetAgentPassiveVariantIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetAgentPassiveVariantIndex) == 0x000004, "Wrong alignment on Spy_GetAgentPassiveVariantIndex");
static_assert(sizeof(Spy_GetAgentPassiveVariantIndex) == 0x000004, "Wrong size on Spy_GetAgentPassiveVariantIndex");
static_assert(offsetof(Spy_GetAgentPassiveVariantIndex, ReturnValue) == 0x000000, "Member 'Spy_GetAgentPassiveVariantIndex::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetAgentWeaponData
// 0x0008 (0x0008 - 0x0000)
struct Spy_GetAgentWeaponData final
{
public:
	class UAgentWeaponData*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetAgentWeaponData) == 0x000008, "Wrong alignment on Spy_GetAgentWeaponData");
static_assert(sizeof(Spy_GetAgentWeaponData) == 0x000008, "Wrong size on Spy_GetAgentWeaponData");
static_assert(offsetof(Spy_GetAgentWeaponData, ReturnValue) == 0x000000, "Member 'Spy_GetAgentWeaponData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetAgentWeaponVariantIndex
// 0x0004 (0x0004 - 0x0000)
struct Spy_GetAgentWeaponVariantIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetAgentWeaponVariantIndex) == 0x000004, "Wrong alignment on Spy_GetAgentWeaponVariantIndex");
static_assert(sizeof(Spy_GetAgentWeaponVariantIndex) == 0x000004, "Wrong size on Spy_GetAgentWeaponVariantIndex");
static_assert(offsetof(Spy_GetAgentWeaponVariantIndex, ReturnValue) == 0x000000, "Member 'Spy_GetAgentWeaponVariantIndex::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetCoverRatio
// 0x0004 (0x0004 - 0x0000)
struct Spy_GetCoverRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetCoverRatio) == 0x000004, "Wrong alignment on Spy_GetCoverRatio");
static_assert(sizeof(Spy_GetCoverRatio) == 0x000004, "Wrong size on Spy_GetCoverRatio");
static_assert(offsetof(Spy_GetCoverRatio, ReturnValue) == 0x000000, "Member 'Spy_GetCoverRatio::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetCurrentActiveMesh
// 0x0008 (0x0008 - 0x0000)
struct Spy_GetCurrentActiveMesh final
{
public:
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetCurrentActiveMesh) == 0x000008, "Wrong alignment on Spy_GetCurrentActiveMesh");
static_assert(sizeof(Spy_GetCurrentActiveMesh) == 0x000008, "Wrong size on Spy_GetCurrentActiveMesh");
static_assert(offsetof(Spy_GetCurrentActiveMesh, ReturnValue) == 0x000000, "Member 'Spy_GetCurrentActiveMesh::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetCurrentArea
// 0x0008 (0x0008 - 0x0000)
struct Spy_GetCurrentArea final
{
public:
	class ALevelArea*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetCurrentArea) == 0x000008, "Wrong alignment on Spy_GetCurrentArea");
static_assert(sizeof(Spy_GetCurrentArea) == 0x000008, "Wrong size on Spy_GetCurrentArea");
static_assert(offsetof(Spy_GetCurrentArea, ReturnValue) == 0x000000, "Member 'Spy_GetCurrentArea::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetCurrentHeading
// 0x0004 (0x0004 - 0x0000)
struct Spy_GetCurrentHeading final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetCurrentHeading) == 0x000004, "Wrong alignment on Spy_GetCurrentHeading");
static_assert(sizeof(Spy_GetCurrentHeading) == 0x000004, "Wrong size on Spy_GetCurrentHeading");
static_assert(offsetof(Spy_GetCurrentHeading, ReturnValue) == 0x000000, "Member 'Spy_GetCurrentHeading::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetCurrentRoom
// 0x0008 (0x0008 - 0x0000)
struct Spy_GetCurrentRoom final
{
public:
	class ARoomVolume*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetCurrentRoom) == 0x000008, "Wrong alignment on Spy_GetCurrentRoom");
static_assert(sizeof(Spy_GetCurrentRoom) == 0x000008, "Wrong size on Spy_GetCurrentRoom");
static_assert(offsetof(Spy_GetCurrentRoom, ReturnValue) == 0x000000, "Member 'Spy_GetCurrentRoom::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetCurrentStaminaRatio
// 0x0004 (0x0004 - 0x0000)
struct Spy_GetCurrentStaminaRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetCurrentStaminaRatio) == 0x000004, "Wrong alignment on Spy_GetCurrentStaminaRatio");
static_assert(sizeof(Spy_GetCurrentStaminaRatio) == 0x000004, "Wrong size on Spy_GetCurrentStaminaRatio");
static_assert(offsetof(Spy_GetCurrentStaminaRatio, ReturnValue) == 0x000000, "Member 'Spy_GetCurrentStaminaRatio::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetCurrentTool
// 0x0008 (0x0008 - 0x0000)
struct Spy_GetCurrentTool final
{
public:
	class ABaseSpyTool*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetCurrentTool) == 0x000008, "Wrong alignment on Spy_GetCurrentTool");
static_assert(sizeof(Spy_GetCurrentTool) == 0x000008, "Wrong size on Spy_GetCurrentTool");
static_assert(offsetof(Spy_GetCurrentTool, ReturnValue) == 0x000000, "Member 'Spy_GetCurrentTool::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetDIPlayerState
// 0x0008 (0x0008 - 0x0000)
struct Spy_GetDIPlayerState final
{
public:
	class ADIPlayerState*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetDIPlayerState) == 0x000008, "Wrong alignment on Spy_GetDIPlayerState");
static_assert(sizeof(Spy_GetDIPlayerState) == 0x000008, "Wrong size on Spy_GetDIPlayerState");
static_assert(offsetof(Spy_GetDIPlayerState, ReturnValue) == 0x000000, "Member 'Spy_GetDIPlayerState::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetDisguise
// 0x0008 (0x0008 - 0x0000)
struct Spy_GetDisguise final
{
public:
	class ANPCCharacter*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetDisguise) == 0x000008, "Wrong alignment on Spy_GetDisguise");
static_assert(sizeof(Spy_GetDisguise) == 0x000008, "Wrong size on Spy_GetDisguise");
static_assert(offsetof(Spy_GetDisguise, ReturnValue) == 0x000000, "Member 'Spy_GetDisguise::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetEffectOfClass
// 0x0010 (0x0010 - 0x0000)
struct Spy_GetEffectOfClass final
{
public:
	class UClass*                                 EffectClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVictimEffect*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetEffectOfClass) == 0x000008, "Wrong alignment on Spy_GetEffectOfClass");
static_assert(sizeof(Spy_GetEffectOfClass) == 0x000010, "Wrong size on Spy_GetEffectOfClass");
static_assert(offsetof(Spy_GetEffectOfClass, EffectClass) == 0x000000, "Member 'Spy_GetEffectOfClass::EffectClass' has a wrong offset!");
static_assert(offsetof(Spy_GetEffectOfClass, ReturnValue) == 0x000008, "Member 'Spy_GetEffectOfClass::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetFactionId
// 0x0001 (0x0001 - 0x0000)
struct Spy_GetFactionId final
{
public:
	uint8                                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetFactionId) == 0x000001, "Wrong alignment on Spy_GetFactionId");
static_assert(sizeof(Spy_GetFactionId) == 0x000001, "Wrong size on Spy_GetFactionId");
static_assert(offsetof(Spy_GetFactionId, ReturnValue) == 0x000000, "Member 'Spy_GetFactionId::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetFeetLevelPos
// 0x000C (0x000C - 0x0000)
struct Spy_GetFeetLevelPos final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetFeetLevelPos) == 0x000004, "Wrong alignment on Spy_GetFeetLevelPos");
static_assert(sizeof(Spy_GetFeetLevelPos) == 0x00000C, "Wrong size on Spy_GetFeetLevelPos");
static_assert(offsetof(Spy_GetFeetLevelPos, ReturnValue) == 0x000000, "Member 'Spy_GetFeetLevelPos::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetInteractableType
// 0x0001 (0x0001 - 0x0000)
struct Spy_GetInteractableType final
{
public:
	EInteractableType                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetInteractableType) == 0x000001, "Wrong alignment on Spy_GetInteractableType");
static_assert(sizeof(Spy_GetInteractableType) == 0x000001, "Wrong size on Spy_GetInteractableType");
static_assert(offsetof(Spy_GetInteractableType, ReturnValue) == 0x000000, "Member 'Spy_GetInteractableType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetKillerData
// 0x0010 (0x0010 - 0x0000)
struct Spy_GetKillerData final
{
public:
	struct FLastInteractionData                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetKillerData) == 0x000008, "Wrong alignment on Spy_GetKillerData");
static_assert(sizeof(Spy_GetKillerData) == 0x000010, "Wrong size on Spy_GetKillerData");
static_assert(offsetof(Spy_GetKillerData, ReturnValue) == 0x000000, "Member 'Spy_GetKillerData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetLoadoutComponent
// 0x0008 (0x0008 - 0x0000)
struct Spy_GetLoadoutComponent final
{
public:
	class UToolLoadoutComponent*                  ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetLoadoutComponent) == 0x000008, "Wrong alignment on Spy_GetLoadoutComponent");
static_assert(sizeof(Spy_GetLoadoutComponent) == 0x000008, "Wrong size on Spy_GetLoadoutComponent");
static_assert(offsetof(Spy_GetLoadoutComponent, ReturnValue) == 0x000000, "Member 'Spy_GetLoadoutComponent::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetMesh1P
// 0x0008 (0x0008 - 0x0000)
struct Spy_GetMesh1P final
{
public:
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetMesh1P) == 0x000008, "Wrong alignment on Spy_GetMesh1P");
static_assert(sizeof(Spy_GetMesh1P) == 0x000008, "Wrong size on Spy_GetMesh1P");
static_assert(offsetof(Spy_GetMesh1P, ReturnValue) == 0x000000, "Member 'Spy_GetMesh1P::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetMesh3P
// 0x0008 (0x0008 - 0x0000)
struct Spy_GetMesh3P final
{
public:
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetMesh3P) == 0x000008, "Wrong alignment on Spy_GetMesh3P");
static_assert(sizeof(Spy_GetMesh3P) == 0x000008, "Wrong size on Spy_GetMesh3P");
static_assert(offsetof(Spy_GetMesh3P, ReturnValue) == 0x000000, "Member 'Spy_GetMesh3P::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetOutOfCoverTime
// 0x0004 (0x0004 - 0x0000)
struct Spy_GetOutOfCoverTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetOutOfCoverTime) == 0x000004, "Wrong alignment on Spy_GetOutOfCoverTime");
static_assert(sizeof(Spy_GetOutOfCoverTime) == 0x000004, "Wrong size on Spy_GetOutOfCoverTime");
static_assert(offsetof(Spy_GetOutOfCoverTime, ReturnValue) == 0x000000, "Member 'Spy_GetOutOfCoverTime::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetPassiveAbilityTool
// 0x0008 (0x0008 - 0x0000)
struct Spy_GetPassiveAbilityTool final
{
public:
	class ABaseSpyPassiveAbility*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetPassiveAbilityTool) == 0x000008, "Wrong alignment on Spy_GetPassiveAbilityTool");
static_assert(sizeof(Spy_GetPassiveAbilityTool) == 0x000008, "Wrong size on Spy_GetPassiveAbilityTool");
static_assert(offsetof(Spy_GetPassiveAbilityTool, ReturnValue) == 0x000000, "Member 'Spy_GetPassiveAbilityTool::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetPlayerName
// 0x0010 (0x0010 - 0x0000)
struct Spy_GetPlayerName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetPlayerName) == 0x000008, "Wrong alignment on Spy_GetPlayerName");
static_assert(sizeof(Spy_GetPlayerName) == 0x000010, "Wrong size on Spy_GetPlayerName");
static_assert(offsetof(Spy_GetPlayerName, ReturnValue) == 0x000000, "Member 'Spy_GetPlayerName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetPlayerPlatformType
// 0x0001 (0x0001 - 0x0000)
struct Spy_GetPlayerPlatformType final
{
public:
	EPlatformType                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetPlayerPlatformType) == 0x000001, "Wrong alignment on Spy_GetPlayerPlatformType");
static_assert(sizeof(Spy_GetPlayerPlatformType) == 0x000001, "Wrong size on Spy_GetPlayerPlatformType");
static_assert(offsetof(Spy_GetPlayerPlatformType, ReturnValue) == 0x000000, "Member 'Spy_GetPlayerPlatformType::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetPreviousFrameCoverRatio
// 0x0004 (0x0004 - 0x0000)
struct Spy_GetPreviousFrameCoverRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetPreviousFrameCoverRatio) == 0x000004, "Wrong alignment on Spy_GetPreviousFrameCoverRatio");
static_assert(sizeof(Spy_GetPreviousFrameCoverRatio) == 0x000004, "Wrong size on Spy_GetPreviousFrameCoverRatio");
static_assert(offsetof(Spy_GetPreviousFrameCoverRatio, ReturnValue) == 0x000000, "Member 'Spy_GetPreviousFrameCoverRatio::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetRunDrainCanTrigger
// 0x0001 (0x0001 - 0x0000)
struct Spy_GetRunDrainCanTrigger final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetRunDrainCanTrigger) == 0x000001, "Wrong alignment on Spy_GetRunDrainCanTrigger");
static_assert(sizeof(Spy_GetRunDrainCanTrigger) == 0x000001, "Wrong size on Spy_GetRunDrainCanTrigger");
static_assert(offsetof(Spy_GetRunDrainCanTrigger, ReturnValue) == 0x000000, "Member 'Spy_GetRunDrainCanTrigger::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetRunDrainEnabled
// 0x0001 (0x0001 - 0x0000)
struct Spy_GetRunDrainEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetRunDrainEnabled) == 0x000001, "Wrong alignment on Spy_GetRunDrainEnabled");
static_assert(sizeof(Spy_GetRunDrainEnabled) == 0x000001, "Wrong size on Spy_GetRunDrainEnabled");
static_assert(offsetof(Spy_GetRunDrainEnabled, ReturnValue) == 0x000000, "Member 'Spy_GetRunDrainEnabled::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetSkinData
// 0x0008 (0x0008 - 0x0000)
struct Spy_GetSkinData final
{
public:
	class UAgentSkinData*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetSkinData) == 0x000008, "Wrong alignment on Spy_GetSkinData");
static_assert(sizeof(Spy_GetSkinData) == 0x000008, "Wrong size on Spy_GetSkinData");
static_assert(offsetof(Spy_GetSkinData, ReturnValue) == 0x000000, "Member 'Spy_GetSkinData::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetSlowPercent
// 0x0004 (0x0004 - 0x0000)
struct Spy_GetSlowPercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetSlowPercent) == 0x000004, "Wrong alignment on Spy_GetSlowPercent");
static_assert(sizeof(Spy_GetSlowPercent) == 0x000004, "Wrong size on Spy_GetSlowPercent");
static_assert(offsetof(Spy_GetSlowPercent, ReturnValue) == 0x000000, "Member 'Spy_GetSlowPercent::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetSpyActiveEffects
// 0x0010 (0x0010 - 0x0000)
struct Spy_GetSpyActiveEffects final
{
public:
	TArray<class AVictimEffect*>                  ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetSpyActiveEffects) == 0x000008, "Wrong alignment on Spy_GetSpyActiveEffects");
static_assert(sizeof(Spy_GetSpyActiveEffects) == 0x000010, "Wrong size on Spy_GetSpyActiveEffects");
static_assert(offsetof(Spy_GetSpyActiveEffects, ReturnValue) == 0x000000, "Member 'Spy_GetSpyActiveEffects::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetToolInSlot
// 0x0010 (0x0010 - 0x0000)
struct Spy_GetToolInSlot final
{
public:
	ELoadoutSlot                                  ToolSlot;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSpyTool*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetToolInSlot) == 0x000008, "Wrong alignment on Spy_GetToolInSlot");
static_assert(sizeof(Spy_GetToolInSlot) == 0x000010, "Wrong size on Spy_GetToolInSlot");
static_assert(offsetof(Spy_GetToolInSlot, ToolSlot) == 0x000000, "Member 'Spy_GetToolInSlot::ToolSlot' has a wrong offset!");
static_assert(offsetof(Spy_GetToolInSlot, ReturnValue) == 0x000008, "Member 'Spy_GetToolInSlot::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetViewPitch
// 0x0004 (0x0004 - 0x0000)
struct Spy_GetViewPitch final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetViewPitch) == 0x000004, "Wrong alignment on Spy_GetViewPitch");
static_assert(sizeof(Spy_GetViewPitch) == 0x000004, "Wrong size on Spy_GetViewPitch");
static_assert(offsetof(Spy_GetViewPitch, ReturnValue) == 0x000000, "Member 'Spy_GetViewPitch::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetWeapon1PMesh
// 0x0008 (0x0008 - 0x0000)
struct Spy_GetWeapon1PMesh final
{
public:
	class UMeshComponent*                         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetWeapon1PMesh) == 0x000008, "Wrong alignment on Spy_GetWeapon1PMesh");
static_assert(sizeof(Spy_GetWeapon1PMesh) == 0x000008, "Wrong size on Spy_GetWeapon1PMesh");
static_assert(offsetof(Spy_GetWeapon1PMesh, ReturnValue) == 0x000000, "Member 'Spy_GetWeapon1PMesh::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetWeapon3PMesh
// 0x0008 (0x0008 - 0x0000)
struct Spy_GetWeapon3PMesh final
{
public:
	class UMeshComponent*                         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetWeapon3PMesh) == 0x000008, "Wrong alignment on Spy_GetWeapon3PMesh");
static_assert(sizeof(Spy_GetWeapon3PMesh) == 0x000008, "Wrong size on Spy_GetWeapon3PMesh");
static_assert(offsetof(Spy_GetWeapon3PMesh, ReturnValue) == 0x000000, "Member 'Spy_GetWeapon3PMesh::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.GetWeaponTool
// 0x0008 (0x0008 - 0x0000)
struct Spy_GetWeaponTool final
{
public:
	class ABaseSpyWeapon*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_GetWeaponTool) == 0x000008, "Wrong alignment on Spy_GetWeaponTool");
static_assert(sizeof(Spy_GetWeaponTool) == 0x000008, "Wrong size on Spy_GetWeaponTool");
static_assert(offsetof(Spy_GetWeaponTool, ReturnValue) == 0x000000, "Member 'Spy_GetWeaponTool::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsBot
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsBot final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsBot) == 0x000001, "Wrong alignment on Spy_IsBot");
static_assert(sizeof(Spy_IsBot) == 0x000001, "Wrong size on Spy_IsBot");
static_assert(offsetof(Spy_IsBot, ReturnValue) == 0x000000, "Member 'Spy_IsBot::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsBurned
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsBurned final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsBurned) == 0x000001, "Wrong alignment on Spy_IsBurned");
static_assert(sizeof(Spy_IsBurned) == 0x000001, "Wrong size on Spy_IsBurned");
static_assert(offsetof(Spy_IsBurned, ReturnValue) == 0x000000, "Member 'Spy_IsBurned::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsCharmRecover
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsCharmRecover final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsCharmRecover) == 0x000001, "Wrong alignment on Spy_IsCharmRecover");
static_assert(sizeof(Spy_IsCharmRecover) == 0x000001, "Wrong size on Spy_IsCharmRecover");
static_assert(offsetof(Spy_IsCharmRecover, ReturnValue) == 0x000000, "Member 'Spy_IsCharmRecover::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsDead
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsDead final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsDead) == 0x000001, "Wrong alignment on Spy_IsDead");
static_assert(sizeof(Spy_IsDead) == 0x000001, "Wrong size on Spy_IsDead");
static_assert(offsetof(Spy_IsDead, ReturnValue) == 0x000000, "Member 'Spy_IsDead::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsDisarmed
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsDisarmed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsDisarmed) == 0x000001, "Wrong alignment on Spy_IsDisarmed");
static_assert(sizeof(Spy_IsDisarmed) == 0x000001, "Wrong size on Spy_IsDisarmed");
static_assert(offsetof(Spy_IsDisarmed, ReturnValue) == 0x000000, "Member 'Spy_IsDisarmed::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsDisguiseVisible
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsDisguiseVisible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsDisguiseVisible) == 0x000001, "Wrong alignment on Spy_IsDisguiseVisible");
static_assert(sizeof(Spy_IsDisguiseVisible) == 0x000001, "Wrong size on Spy_IsDisguiseVisible");
static_assert(offsetof(Spy_IsDisguiseVisible, ReturnValue) == 0x000000, "Member 'Spy_IsDisguiseVisible::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsEnemyCharmRecover
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsEnemyCharmRecover final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsEnemyCharmRecover) == 0x000001, "Wrong alignment on Spy_IsEnemyCharmRecover");
static_assert(sizeof(Spy_IsEnemyCharmRecover) == 0x000001, "Wrong size on Spy_IsEnemyCharmRecover");
static_assert(offsetof(Spy_IsEnemyCharmRecover, ReturnValue) == 0x000000, "Member 'Spy_IsEnemyCharmRecover::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsFalling
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsFalling final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsFalling) == 0x000001, "Wrong alignment on Spy_IsFalling");
static_assert(sizeof(Spy_IsFalling) == 0x000001, "Wrong size on Spy_IsFalling");
static_assert(offsetof(Spy_IsFalling, ReturnValue) == 0x000000, "Member 'Spy_IsFalling::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsFriendlyCharmRecover
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsFriendlyCharmRecover final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsFriendlyCharmRecover) == 0x000001, "Wrong alignment on Spy_IsFriendlyCharmRecover");
static_assert(sizeof(Spy_IsFriendlyCharmRecover) == 0x000001, "Wrong size on Spy_IsFriendlyCharmRecover");
static_assert(offsetof(Spy_IsFriendlyCharmRecover, ReturnValue) == 0x000000, "Member 'Spy_IsFriendlyCharmRecover::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsHidden
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsHidden final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsHidden) == 0x000001, "Wrong alignment on Spy_IsHidden");
static_assert(sizeof(Spy_IsHidden) == 0x000001, "Wrong size on Spy_IsHidden");
static_assert(offsetof(Spy_IsHidden, ReturnValue) == 0x000000, "Member 'Spy_IsHidden::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsHidingReticleInADS
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsHidingReticleInADS final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsHidingReticleInADS) == 0x000001, "Wrong alignment on Spy_IsHidingReticleInADS");
static_assert(sizeof(Spy_IsHidingReticleInADS) == 0x000001, "Wrong size on Spy_IsHidingReticleInADS");
static_assert(offsetof(Spy_IsHidingReticleInADS, ReturnValue) == 0x000000, "Member 'Spy_IsHidingReticleInADS::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsImmaterial
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsImmaterial final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsImmaterial) == 0x000001, "Wrong alignment on Spy_IsImmaterial");
static_assert(sizeof(Spy_IsImmaterial) == 0x000001, "Wrong size on Spy_IsImmaterial");
static_assert(offsetof(Spy_IsImmaterial, ReturnValue) == 0x000000, "Member 'Spy_IsImmaterial::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsImmaterialOrHidden
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsImmaterialOrHidden final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsImmaterialOrHidden) == 0x000001, "Wrong alignment on Spy_IsImmaterialOrHidden");
static_assert(sizeof(Spy_IsImmaterialOrHidden) == 0x000001, "Wrong size on Spy_IsImmaterialOrHidden");
static_assert(offsetof(Spy_IsImmaterialOrHidden, ReturnValue) == 0x000000, "Member 'Spy_IsImmaterialOrHidden::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsInADS
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsInADS final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsInADS) == 0x000001, "Wrong alignment on Spy_IsInADS");
static_assert(sizeof(Spy_IsInADS) == 0x000001, "Wrong size on Spy_IsInADS");
static_assert(offsetof(Spy_IsInADS, ReturnValue) == 0x000000, "Member 'Spy_IsInADS::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsInMimic
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsInMimic final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsInMimic) == 0x000001, "Wrong alignment on Spy_IsInMimic");
static_assert(sizeof(Spy_IsInMimic) == 0x000001, "Wrong size on Spy_IsInMimic");
static_assert(offsetof(Spy_IsInMimic, ReturnValue) == 0x000000, "Member 'Spy_IsInMimic::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsInNavMode
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsInNavMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsInNavMode) == 0x000001, "Wrong alignment on Spy_IsInNavMode");
static_assert(sizeof(Spy_IsInNavMode) == 0x000001, "Wrong size on Spy_IsInNavMode");
static_assert(offsetof(Spy_IsInNavMode, ReturnValue) == 0x000000, "Member 'Spy_IsInNavMode::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsInVault
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsInVault final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsInVault) == 0x000001, "Wrong alignment on Spy_IsInVault");
static_assert(sizeof(Spy_IsInVault) == 0x000001, "Wrong size on Spy_IsInVault");
static_assert(offsetof(Spy_IsInVault, ReturnValue) == 0x000000, "Member 'Spy_IsInVault::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsJumpDisabled
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsJumpDisabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsJumpDisabled) == 0x000001, "Wrong alignment on Spy_IsJumpDisabled");
static_assert(sizeof(Spy_IsJumpDisabled) == 0x000001, "Wrong size on Spy_IsJumpDisabled");
static_assert(offsetof(Spy_IsJumpDisabled, ReturnValue) == 0x000000, "Member 'Spy_IsJumpDisabled::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsKeepRunAdditiveWhileRunningOutOfCover
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsKeepRunAdditiveWhileRunningOutOfCover final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsKeepRunAdditiveWhileRunningOutOfCover) == 0x000001, "Wrong alignment on Spy_IsKeepRunAdditiveWhileRunningOutOfCover");
static_assert(sizeof(Spy_IsKeepRunAdditiveWhileRunningOutOfCover) == 0x000001, "Wrong size on Spy_IsKeepRunAdditiveWhileRunningOutOfCover");
static_assert(offsetof(Spy_IsKeepRunAdditiveWhileRunningOutOfCover, ReturnValue) == 0x000000, "Member 'Spy_IsKeepRunAdditiveWhileRunningOutOfCover::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsKillcamViewTarget
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsKillcamViewTarget final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsKillcamViewTarget) == 0x000001, "Wrong alignment on Spy_IsKillcamViewTarget");
static_assert(sizeof(Spy_IsKillcamViewTarget) == 0x000001, "Wrong size on Spy_IsKillcamViewTarget");
static_assert(offsetof(Spy_IsKillcamViewTarget, ReturnValue) == 0x000000, "Member 'Spy_IsKillcamViewTarget::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsLastCoverBlowSelfInstigated
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsLastCoverBlowSelfInstigated final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsLastCoverBlowSelfInstigated) == 0x000001, "Wrong alignment on Spy_IsLastCoverBlowSelfInstigated");
static_assert(sizeof(Spy_IsLastCoverBlowSelfInstigated) == 0x000001, "Wrong size on Spy_IsLastCoverBlowSelfInstigated");
static_assert(offsetof(Spy_IsLastCoverBlowSelfInstigated, ReturnValue) == 0x000000, "Member 'Spy_IsLastCoverBlowSelfInstigated::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsLocalOrKillcamViewTarget
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsLocalOrKillcamViewTarget final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsLocalOrKillcamViewTarget) == 0x000001, "Wrong alignment on Spy_IsLocalOrKillcamViewTarget");
static_assert(sizeof(Spy_IsLocalOrKillcamViewTarget) == 0x000001, "Wrong size on Spy_IsLocalOrKillcamViewTarget");
static_assert(offsetof(Spy_IsLocalOrKillcamViewTarget, ReturnValue) == 0x000000, "Member 'Spy_IsLocalOrKillcamViewTarget::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsLocalSpy
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsLocalSpy final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsLocalSpy) == 0x000001, "Wrong alignment on Spy_IsLocalSpy");
static_assert(sizeof(Spy_IsLocalSpy) == 0x000001, "Wrong size on Spy_IsLocalSpy");
static_assert(offsetof(Spy_IsLocalSpy, ReturnValue) == 0x000000, "Member 'Spy_IsLocalSpy::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsMovementDisabled
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsMovementDisabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsMovementDisabled) == 0x000001, "Wrong alignment on Spy_IsMovementDisabled");
static_assert(sizeof(Spy_IsMovementDisabled) == 0x000001, "Wrong size on Spy_IsMovementDisabled");
static_assert(offsetof(Spy_IsMovementDisabled, ReturnValue) == 0x000000, "Member 'Spy_IsMovementDisabled::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsPlayerHudVisible
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsPlayerHudVisible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsPlayerHudVisible) == 0x000001, "Wrong alignment on Spy_IsPlayerHudVisible");
static_assert(sizeof(Spy_IsPlayerHudVisible) == 0x000001, "Wrong size on Spy_IsPlayerHudVisible");
static_assert(offsetof(Spy_IsPlayerHudVisible, ReturnValue) == 0x000000, "Member 'Spy_IsPlayerHudVisible::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsRunBlocked
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsRunBlocked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsRunBlocked) == 0x000001, "Wrong alignment on Spy_IsRunBlocked");
static_assert(sizeof(Spy_IsRunBlocked) == 0x000001, "Wrong size on Spy_IsRunBlocked");
static_assert(offsetof(Spy_IsRunBlocked, ReturnValue) == 0x000000, "Member 'Spy_IsRunBlocked::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsRunDisabled
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsRunDisabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsRunDisabled) == 0x000001, "Wrong alignment on Spy_IsRunDisabled");
static_assert(sizeof(Spy_IsRunDisabled) == 0x000001, "Wrong size on Spy_IsRunDisabled");
static_assert(offsetof(Spy_IsRunDisabled, ReturnValue) == 0x000000, "Member 'Spy_IsRunDisabled::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsRunning
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsRunning final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsRunning) == 0x000001, "Wrong alignment on Spy_IsRunning");
static_assert(sizeof(Spy_IsRunning) == 0x000001, "Wrong size on Spy_IsRunning");
static_assert(offsetof(Spy_IsRunning, ReturnValue) == 0x000000, "Member 'Spy_IsRunning::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsSameFactionAsLocalPlayer
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsSameFactionAsLocalPlayer final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsSameFactionAsLocalPlayer) == 0x000001, "Wrong alignment on Spy_IsSameFactionAsLocalPlayer");
static_assert(sizeof(Spy_IsSameFactionAsLocalPlayer) == 0x000001, "Wrong size on Spy_IsSameFactionAsLocalPlayer");
static_assert(offsetof(Spy_IsSameFactionAsLocalPlayer, ReturnValue) == 0x000000, "Member 'Spy_IsSameFactionAsLocalPlayer::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsShootingBlocked
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsShootingBlocked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsShootingBlocked) == 0x000001, "Wrong alignment on Spy_IsShootingBlocked");
static_assert(sizeof(Spy_IsShootingBlocked) == 0x000001, "Wrong size on Spy_IsShootingBlocked");
static_assert(offsetof(Spy_IsShootingBlocked, ReturnValue) == 0x000000, "Member 'Spy_IsShootingBlocked::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsSilenced
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsSilenced final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsSilenced) == 0x000001, "Wrong alignment on Spy_IsSilenced");
static_assert(sizeof(Spy_IsSilenced) == 0x000001, "Wrong size on Spy_IsSilenced");
static_assert(offsetof(Spy_IsSilenced, ReturnValue) == 0x000000, "Member 'Spy_IsSilenced::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsSpeedBoostDisabled
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsSpeedBoostDisabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsSpeedBoostDisabled) == 0x000001, "Wrong alignment on Spy_IsSpeedBoostDisabled");
static_assert(sizeof(Spy_IsSpeedBoostDisabled) == 0x000001, "Wrong size on Spy_IsSpeedBoostDisabled");
static_assert(offsetof(Spy_IsSpeedBoostDisabled, ReturnValue) == 0x000000, "Member 'Spy_IsSpeedBoostDisabled::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsSpyAndDisguiseInvisible
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsSpyAndDisguiseInvisible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsSpyAndDisguiseInvisible) == 0x000001, "Wrong alignment on Spy_IsSpyAndDisguiseInvisible");
static_assert(sizeof(Spy_IsSpyAndDisguiseInvisible) == 0x000001, "Wrong size on Spy_IsSpyAndDisguiseInvisible");
static_assert(offsetof(Spy_IsSpyAndDisguiseInvisible, ReturnValue) == 0x000000, "Member 'Spy_IsSpyAndDisguiseInvisible::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsSpyPlayer
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsSpyPlayer final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsSpyPlayer) == 0x000001, "Wrong alignment on Spy_IsSpyPlayer");
static_assert(sizeof(Spy_IsSpyPlayer) == 0x000001, "Wrong size on Spy_IsSpyPlayer");
static_assert(offsetof(Spy_IsSpyPlayer, ReturnValue) == 0x000000, "Member 'Spy_IsSpyPlayer::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsSpyPoisoned
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsSpyPoisoned final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsSpyPoisoned) == 0x000001, "Wrong alignment on Spy_IsSpyPoisoned");
static_assert(sizeof(Spy_IsSpyPoisoned) == 0x000001, "Wrong size on Spy_IsSpyPoisoned");
static_assert(offsetof(Spy_IsSpyPoisoned, ReturnValue) == 0x000000, "Member 'Spy_IsSpyPoisoned::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsSpyRunning
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsSpyRunning final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsSpyRunning) == 0x000001, "Wrong alignment on Spy_IsSpyRunning");
static_assert(sizeof(Spy_IsSpyRunning) == 0x000001, "Wrong size on Spy_IsSpyRunning");
static_assert(offsetof(Spy_IsSpyRunning, ReturnValue) == 0x000000, "Member 'Spy_IsSpyRunning::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsSpyVisibleToOthers
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsSpyVisibleToOthers final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsSpyVisibleToOthers) == 0x000001, "Wrong alignment on Spy_IsSpyVisibleToOthers");
static_assert(sizeof(Spy_IsSpyVisibleToOthers) == 0x000001, "Wrong size on Spy_IsSpyVisibleToOthers");
static_assert(offsetof(Spy_IsSpyVisibleToOthers, ReturnValue) == 0x000000, "Member 'Spy_IsSpyVisibleToOthers::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsSuspicious
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsSuspicious final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsSuspicious) == 0x000001, "Wrong alignment on Spy_IsSuspicious");
static_assert(sizeof(Spy_IsSuspicious) == 0x000001, "Wrong size on Spy_IsSuspicious");
static_assert(offsetof(Spy_IsSuspicious, ReturnValue) == 0x000000, "Member 'Spy_IsSuspicious::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsTransformingOrInMimic
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsTransformingOrInMimic final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsTransformingOrInMimic) == 0x000001, "Wrong alignment on Spy_IsTransformingOrInMimic");
static_assert(sizeof(Spy_IsTransformingOrInMimic) == 0x000001, "Wrong size on Spy_IsTransformingOrInMimic");
static_assert(offsetof(Spy_IsTransformingOrInMimic, ReturnValue) == 0x000000, "Member 'Spy_IsTransformingOrInMimic::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsTryingToRun
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsTryingToRun final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsTryingToRun) == 0x000001, "Wrong alignment on Spy_IsTryingToRun");
static_assert(sizeof(Spy_IsTryingToRun) == 0x000001, "Wrong size on Spy_IsTryingToRun");
static_assert(offsetof(Spy_IsTryingToRun, ReturnValue) == 0x000000, "Member 'Spy_IsTryingToRun::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsUndercover
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsUndercover final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsUndercover) == 0x000001, "Wrong alignment on Spy_IsUndercover");
static_assert(sizeof(Spy_IsUndercover) == 0x000001, "Wrong size on Spy_IsUndercover");
static_assert(offsetof(Spy_IsUndercover, ReturnValue) == 0x000000, "Member 'Spy_IsUndercover::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.IsViewIn1P
// 0x0001 (0x0001 - 0x0000)
struct Spy_IsViewIn1P final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_IsViewIn1P) == 0x000001, "Wrong alignment on Spy_IsViewIn1P");
static_assert(sizeof(Spy_IsViewIn1P) == 0x000001, "Wrong size on Spy_IsViewIn1P");
static_assert(offsetof(Spy_IsViewIn1P, ReturnValue) == 0x000000, "Member 'Spy_IsViewIn1P::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy.ShouldBeUndercover
// 0x0001 (0x0001 - 0x0000)
struct Spy_ShouldBeUndercover final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy_ShouldBeUndercover) == 0x000001, "Wrong alignment on Spy_ShouldBeUndercover");
static_assert(sizeof(Spy_ShouldBeUndercover) == 0x000001, "Wrong size on Spy_ShouldBeUndercover");
static_assert(offsetof(Spy_ShouldBeUndercover, ReturnValue) == 0x000000, "Member 'Spy_ShouldBeUndercover::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy3DPortrait.BP_OnDisguiseVisibilityChange
// 0x0001 (0x0001 - 0x0000)
struct Spy3DPortrait_BP_OnDisguiseVisibilityChange final
{
public:
	bool                                          bIsVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy3DPortrait_BP_OnDisguiseVisibilityChange) == 0x000001, "Wrong alignment on Spy3DPortrait_BP_OnDisguiseVisibilityChange");
static_assert(sizeof(Spy3DPortrait_BP_OnDisguiseVisibilityChange) == 0x000001, "Wrong size on Spy3DPortrait_BP_OnDisguiseVisibilityChange");
static_assert(offsetof(Spy3DPortrait_BP_OnDisguiseVisibilityChange, bIsVisible) == 0x000000, "Member 'Spy3DPortrait_BP_OnDisguiseVisibilityChange::bIsVisible' has a wrong offset!");

// Function DeceiveInc.Spy3DPortrait.BP_OnSpyVisibilityChange
// 0x0001 (0x0001 - 0x0000)
struct Spy3DPortrait_BP_OnSpyVisibilityChange final
{
public:
	bool                                          bIsVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy3DPortrait_BP_OnSpyVisibilityChange) == 0x000001, "Wrong alignment on Spy3DPortrait_BP_OnSpyVisibilityChange");
static_assert(sizeof(Spy3DPortrait_BP_OnSpyVisibilityChange) == 0x000001, "Wrong size on Spy3DPortrait_BP_OnSpyVisibilityChange");
static_assert(offsetof(Spy3DPortrait_BP_OnSpyVisibilityChange, bIsVisible) == 0x000000, "Member 'Spy3DPortrait_BP_OnSpyVisibilityChange::bIsVisible' has a wrong offset!");

// Function DeceiveInc.Spy3DPortrait.BP_UpdatePlayerHud
// 0x0008 (0x0008 - 0x0000)
struct Spy3DPortrait_BP_UpdatePlayerHud final
{
public:
	class UUserWidget*                            NewHud;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy3DPortrait_BP_UpdatePlayerHud) == 0x000008, "Wrong alignment on Spy3DPortrait_BP_UpdatePlayerHud");
static_assert(sizeof(Spy3DPortrait_BP_UpdatePlayerHud) == 0x000008, "Wrong size on Spy3DPortrait_BP_UpdatePlayerHud");
static_assert(offsetof(Spy3DPortrait_BP_UpdatePlayerHud, NewHud) == 0x000000, "Member 'Spy3DPortrait_BP_UpdatePlayerHud::NewHud' has a wrong offset!");

// Function DeceiveInc.Spy3DPortrait.EnableSpotlight
// 0x0001 (0x0001 - 0x0000)
struct Spy3DPortrait_EnableSpotlight final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy3DPortrait_EnableSpotlight) == 0x000001, "Wrong alignment on Spy3DPortrait_EnableSpotlight");
static_assert(sizeof(Spy3DPortrait_EnableSpotlight) == 0x000001, "Wrong size on Spy3DPortrait_EnableSpotlight");
static_assert(offsetof(Spy3DPortrait_EnableSpotlight, bEnable) == 0x000000, "Member 'Spy3DPortrait_EnableSpotlight::bEnable' has a wrong offset!");

// Function DeceiveInc.Spy3DPortrait.HandleCoverVisibilityChange
// 0x0001 (0x0001 - 0x0000)
struct Spy3DPortrait_HandleCoverVisibilityChange final
{
public:
	bool                                          CoverVisible;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy3DPortrait_HandleCoverVisibilityChange) == 0x000001, "Wrong alignment on Spy3DPortrait_HandleCoverVisibilityChange");
static_assert(sizeof(Spy3DPortrait_HandleCoverVisibilityChange) == 0x000001, "Wrong size on Spy3DPortrait_HandleCoverVisibilityChange");
static_assert(offsetof(Spy3DPortrait_HandleCoverVisibilityChange, CoverVisible) == 0x000000, "Member 'Spy3DPortrait_HandleCoverVisibilityChange::CoverVisible' has a wrong offset!");

// Function DeceiveInc.Spy3DPortrait.HandleHealthChanged
// 0x0030 (0x0030 - 0x0000)
struct Spy3DPortrait_HandleHealthChanged final
{
public:
	class UHealthComponent*                       OwningHealthComp;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthDelta;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDamageType*                      DamageType;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RawDamage;                                         // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Spy3DPortrait_HandleHealthChanged) == 0x000008, "Wrong alignment on Spy3DPortrait_HandleHealthChanged");
static_assert(sizeof(Spy3DPortrait_HandleHealthChanged) == 0x000030, "Wrong size on Spy3DPortrait_HandleHealthChanged");
static_assert(offsetof(Spy3DPortrait_HandleHealthChanged, OwningHealthComp) == 0x000000, "Member 'Spy3DPortrait_HandleHealthChanged::OwningHealthComp' has a wrong offset!");
static_assert(offsetof(Spy3DPortrait_HandleHealthChanged, Health) == 0x000008, "Member 'Spy3DPortrait_HandleHealthChanged::Health' has a wrong offset!");
static_assert(offsetof(Spy3DPortrait_HandleHealthChanged, HealthDelta) == 0x00000C, "Member 'Spy3DPortrait_HandleHealthChanged::HealthDelta' has a wrong offset!");
static_assert(offsetof(Spy3DPortrait_HandleHealthChanged, DamageType) == 0x000010, "Member 'Spy3DPortrait_HandleHealthChanged::DamageType' has a wrong offset!");
static_assert(offsetof(Spy3DPortrait_HandleHealthChanged, InstigatedBy) == 0x000018, "Member 'Spy3DPortrait_HandleHealthChanged::InstigatedBy' has a wrong offset!");
static_assert(offsetof(Spy3DPortrait_HandleHealthChanged, DamageCauser) == 0x000020, "Member 'Spy3DPortrait_HandleHealthChanged::DamageCauser' has a wrong offset!");
static_assert(offsetof(Spy3DPortrait_HandleHealthChanged, RawDamage) == 0x000028, "Member 'Spy3DPortrait_HandleHealthChanged::RawDamage' has a wrong offset!");

// Function DeceiveInc.Spy3DPortrait.GetCurrentVisibleMesh
// 0x0008 (0x0008 - 0x0000)
struct Spy3DPortrait_GetCurrentVisibleMesh final
{
public:
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy3DPortrait_GetCurrentVisibleMesh) == 0x000008, "Wrong alignment on Spy3DPortrait_GetCurrentVisibleMesh");
static_assert(sizeof(Spy3DPortrait_GetCurrentVisibleMesh) == 0x000008, "Wrong size on Spy3DPortrait_GetCurrentVisibleMesh");
static_assert(offsetof(Spy3DPortrait_GetCurrentVisibleMesh, ReturnValue) == 0x000000, "Member 'Spy3DPortrait_GetCurrentVisibleMesh::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy3DPortrait.GetDisguiseReferenceMesh
// 0x0008 (0x0008 - 0x0000)
struct Spy3DPortrait_GetDisguiseReferenceMesh final
{
public:
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy3DPortrait_GetDisguiseReferenceMesh) == 0x000008, "Wrong alignment on Spy3DPortrait_GetDisguiseReferenceMesh");
static_assert(sizeof(Spy3DPortrait_GetDisguiseReferenceMesh) == 0x000008, "Wrong size on Spy3DPortrait_GetDisguiseReferenceMesh");
static_assert(offsetof(Spy3DPortrait_GetDisguiseReferenceMesh, ReturnValue) == 0x000000, "Member 'Spy3DPortrait_GetDisguiseReferenceMesh::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy3DPortrait.GetDisguiseSecurityLevel
// 0x0001 (0x0001 - 0x0000)
struct Spy3DPortrait_GetDisguiseSecurityLevel final
{
public:
	ESecurityLevel                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy3DPortrait_GetDisguiseSecurityLevel) == 0x000001, "Wrong alignment on Spy3DPortrait_GetDisguiseSecurityLevel");
static_assert(sizeof(Spy3DPortrait_GetDisguiseSecurityLevel) == 0x000001, "Wrong size on Spy3DPortrait_GetDisguiseSecurityLevel");
static_assert(offsetof(Spy3DPortrait_GetDisguiseSecurityLevel, ReturnValue) == 0x000000, "Member 'Spy3DPortrait_GetDisguiseSecurityLevel::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy3DPortrait.GetSpyAnimMotionAsset
// 0x0010 (0x0010 - 0x0000)
struct Spy3DPortrait_GetSpyAnimMotionAsset final
{
public:
	class FName                                   MotionName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy3DPortrait_GetSpyAnimMotionAsset) == 0x000008, "Wrong alignment on Spy3DPortrait_GetSpyAnimMotionAsset");
static_assert(sizeof(Spy3DPortrait_GetSpyAnimMotionAsset) == 0x000010, "Wrong size on Spy3DPortrait_GetSpyAnimMotionAsset");
static_assert(offsetof(Spy3DPortrait_GetSpyAnimMotionAsset, MotionName) == 0x000000, "Member 'Spy3DPortrait_GetSpyAnimMotionAsset::MotionName' has a wrong offset!");
static_assert(offsetof(Spy3DPortrait_GetSpyAnimMotionAsset, ReturnValue) == 0x000008, "Member 'Spy3DPortrait_GetSpyAnimMotionAsset::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Spy3DPortrait.GetSpyReferenceMesh
// 0x0008 (0x0008 - 0x0000)
struct Spy3DPortrait_GetSpyReferenceMesh final
{
public:
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Spy3DPortrait_GetSpyReferenceMesh) == 0x000008, "Wrong alignment on Spy3DPortrait_GetSpyReferenceMesh");
static_assert(sizeof(Spy3DPortrait_GetSpyReferenceMesh) == 0x000008, "Wrong size on Spy3DPortrait_GetSpyReferenceMesh");
static_assert(offsetof(Spy3DPortrait_GetSpyReferenceMesh, ReturnValue) == 0x000000, "Member 'Spy3DPortrait_GetSpyReferenceMesh::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SpyCache.OnInteractionCanceled
// 0x0010 (0x0010 - 0x0000)
struct SpyCache_OnInteractionCanceled final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCache_OnInteractionCanceled) == 0x000008, "Wrong alignment on SpyCache_OnInteractionCanceled");
static_assert(sizeof(SpyCache_OnInteractionCanceled) == 0x000010, "Wrong size on SpyCache_OnInteractionCanceled");
static_assert(offsetof(SpyCache_OnInteractionCanceled, Interacter) == 0x000000, "Member 'SpyCache_OnInteractionCanceled::Interacter' has a wrong offset!");
static_assert(offsetof(SpyCache_OnInteractionCanceled, Interactable) == 0x000008, "Member 'SpyCache_OnInteractionCanceled::Interactable' has a wrong offset!");

// Function DeceiveInc.SpyCache.OnInteractionComplete
// 0x0010 (0x0010 - 0x0000)
struct SpyCache_OnInteractionComplete final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCache_OnInteractionComplete) == 0x000008, "Wrong alignment on SpyCache_OnInteractionComplete");
static_assert(sizeof(SpyCache_OnInteractionComplete) == 0x000010, "Wrong size on SpyCache_OnInteractionComplete");
static_assert(offsetof(SpyCache_OnInteractionComplete, Interacter) == 0x000000, "Member 'SpyCache_OnInteractionComplete::Interacter' has a wrong offset!");
static_assert(offsetof(SpyCache_OnInteractionComplete, Interactable) == 0x000008, "Member 'SpyCache_OnInteractionComplete::Interactable' has a wrong offset!");

// Function DeceiveInc.SpyCache.OnInteractionCompleteAll
// 0x0010 (0x0010 - 0x0000)
struct SpyCache_OnInteractionCompleteAll final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCache_OnInteractionCompleteAll) == 0x000008, "Wrong alignment on SpyCache_OnInteractionCompleteAll");
static_assert(sizeof(SpyCache_OnInteractionCompleteAll) == 0x000010, "Wrong size on SpyCache_OnInteractionCompleteAll");
static_assert(offsetof(SpyCache_OnInteractionCompleteAll, Interacter) == 0x000000, "Member 'SpyCache_OnInteractionCompleteAll::Interacter' has a wrong offset!");
static_assert(offsetof(SpyCache_OnInteractionCompleteAll, Interactable) == 0x000008, "Member 'SpyCache_OnInteractionCompleteAll::Interactable' has a wrong offset!");

// Function DeceiveInc.SpyCache.OnRep_CacheEnabled
// 0x0001 (0x0001 - 0x0000)
struct SpyCache_OnRep_CacheEnabled final
{
public:
	bool                                          OldVal;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCache_OnRep_CacheEnabled) == 0x000001, "Wrong alignment on SpyCache_OnRep_CacheEnabled");
static_assert(sizeof(SpyCache_OnRep_CacheEnabled) == 0x000001, "Wrong size on SpyCache_OnRep_CacheEnabled");
static_assert(offsetof(SpyCache_OnRep_CacheEnabled, OldVal) == 0x000000, "Member 'SpyCache_OnRep_CacheEnabled::OldVal' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatDamage
// 0x0004 (0x0004 - 0x0000)
struct SpyCheatsComponent_CheatDamage final
{
public:
	float                                         DamageAmmount;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatDamage) == 0x000004, "Wrong alignment on SpyCheatsComponent_CheatDamage");
static_assert(sizeof(SpyCheatsComponent_CheatDamage) == 0x000004, "Wrong size on SpyCheatsComponent_CheatDamage");
static_assert(offsetof(SpyCheatsComponent_CheatDamage, DamageAmmount) == 0x000000, "Member 'SpyCheatsComponent_CheatDamage::DamageAmmount' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatDamageSrv
// 0x0004 (0x0004 - 0x0000)
struct SpyCheatsComponent_CheatDamageSrv final
{
public:
	float                                         DamageAmmount;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatDamageSrv) == 0x000004, "Wrong alignment on SpyCheatsComponent_CheatDamageSrv");
static_assert(sizeof(SpyCheatsComponent_CheatDamageSrv) == 0x000004, "Wrong size on SpyCheatsComponent_CheatDamageSrv");
static_assert(offsetof(SpyCheatsComponent_CheatDamageSrv, DamageAmmount) == 0x000000, "Member 'SpyCheatsComponent_CheatDamageSrv::DamageAmmount' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatDelayDamage
// 0x0004 (0x0004 - 0x0000)
struct SpyCheatsComponent_CheatDelayDamage final
{
public:
	float                                         DamageAmmount;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatDelayDamage) == 0x000004, "Wrong alignment on SpyCheatsComponent_CheatDelayDamage");
static_assert(sizeof(SpyCheatsComponent_CheatDelayDamage) == 0x000004, "Wrong size on SpyCheatsComponent_CheatDelayDamage");
static_assert(offsetof(SpyCheatsComponent_CheatDelayDamage, DamageAmmount) == 0x000000, "Member 'SpyCheatsComponent_CheatDelayDamage::DamageAmmount' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatDisableSpecialRule
// 0x0001 (0x0001 - 0x0000)
struct SpyCheatsComponent_CheatDisableSpecialRule final
{
public:
	EDISpecialRules                               SpecialRule;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatDisableSpecialRule) == 0x000001, "Wrong alignment on SpyCheatsComponent_CheatDisableSpecialRule");
static_assert(sizeof(SpyCheatsComponent_CheatDisableSpecialRule) == 0x000001, "Wrong size on SpyCheatsComponent_CheatDisableSpecialRule");
static_assert(offsetof(SpyCheatsComponent_CheatDisableSpecialRule, SpecialRule) == 0x000000, "Member 'SpyCheatsComponent_CheatDisableSpecialRule::SpecialRule' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatDisguiseGiveSecurityLevel
// 0x0001 (0x0001 - 0x0000)
struct SpyCheatsComponent_CheatDisguiseGiveSecurityLevel final
{
public:
	ESecurityLevel                                Security;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatDisguiseGiveSecurityLevel) == 0x000001, "Wrong alignment on SpyCheatsComponent_CheatDisguiseGiveSecurityLevel");
static_assert(sizeof(SpyCheatsComponent_CheatDisguiseGiveSecurityLevel) == 0x000001, "Wrong size on SpyCheatsComponent_CheatDisguiseGiveSecurityLevel");
static_assert(offsetof(SpyCheatsComponent_CheatDisguiseGiveSecurityLevel, Security) == 0x000000, "Member 'SpyCheatsComponent_CheatDisguiseGiveSecurityLevel::Security' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatDisguiseGiveSecurityLevelSrv
// 0x0001 (0x0001 - 0x0000)
struct SpyCheatsComponent_CheatDisguiseGiveSecurityLevelSrv final
{
public:
	ESecurityLevel                                Security;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatDisguiseGiveSecurityLevelSrv) == 0x000001, "Wrong alignment on SpyCheatsComponent_CheatDisguiseGiveSecurityLevelSrv");
static_assert(sizeof(SpyCheatsComponent_CheatDisguiseGiveSecurityLevelSrv) == 0x000001, "Wrong size on SpyCheatsComponent_CheatDisguiseGiveSecurityLevelSrv");
static_assert(offsetof(SpyCheatsComponent_CheatDisguiseGiveSecurityLevelSrv, Security) == 0x000000, "Member 'SpyCheatsComponent_CheatDisguiseGiveSecurityLevelSrv::Security' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatEnableRulesetSrv
// 0x0002 (0x0002 - 0x0000)
struct SpyCheatsComponent_CheatEnableRulesetSrv final
{
public:
	EDISpecialRules                               SpecialRule;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatEnableRulesetSrv) == 0x000001, "Wrong alignment on SpyCheatsComponent_CheatEnableRulesetSrv");
static_assert(sizeof(SpyCheatsComponent_CheatEnableRulesetSrv) == 0x000002, "Wrong size on SpyCheatsComponent_CheatEnableRulesetSrv");
static_assert(offsetof(SpyCheatsComponent_CheatEnableRulesetSrv, SpecialRule) == 0x000000, "Member 'SpyCheatsComponent_CheatEnableRulesetSrv::SpecialRule' has a wrong offset!");
static_assert(offsetof(SpyCheatsComponent_CheatEnableRulesetSrv, bEnable) == 0x000001, "Member 'SpyCheatsComponent_CheatEnableRulesetSrv::bEnable' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatEnableSpecialRule
// 0x0001 (0x0001 - 0x0000)
struct SpyCheatsComponent_CheatEnableSpecialRule final
{
public:
	EDISpecialRules                               SpecialRule;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatEnableSpecialRule) == 0x000001, "Wrong alignment on SpyCheatsComponent_CheatEnableSpecialRule");
static_assert(sizeof(SpyCheatsComponent_CheatEnableSpecialRule) == 0x000001, "Wrong size on SpyCheatsComponent_CheatEnableSpecialRule");
static_assert(offsetof(SpyCheatsComponent_CheatEnableSpecialRule, SpecialRule) == 0x000000, "Member 'SpyCheatsComponent_CheatEnableSpecialRule::SpecialRule' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatGameAddTimeLeft
// 0x0004 (0x0004 - 0x0000)
struct SpyCheatsComponent_CheatGameAddTimeLeft final
{
public:
	int32                                         TimeToAdd;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatGameAddTimeLeft) == 0x000004, "Wrong alignment on SpyCheatsComponent_CheatGameAddTimeLeft");
static_assert(sizeof(SpyCheatsComponent_CheatGameAddTimeLeft) == 0x000004, "Wrong size on SpyCheatsComponent_CheatGameAddTimeLeft");
static_assert(offsetof(SpyCheatsComponent_CheatGameAddTimeLeft, TimeToAdd) == 0x000000, "Member 'SpyCheatsComponent_CheatGameAddTimeLeft::TimeToAdd' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatGameAddTimeLeftSrv
// 0x0004 (0x0004 - 0x0000)
struct SpyCheatsComponent_CheatGameAddTimeLeftSrv final
{
public:
	int32                                         TimeToAdd;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatGameAddTimeLeftSrv) == 0x000004, "Wrong alignment on SpyCheatsComponent_CheatGameAddTimeLeftSrv");
static_assert(sizeof(SpyCheatsComponent_CheatGameAddTimeLeftSrv) == 0x000004, "Wrong size on SpyCheatsComponent_CheatGameAddTimeLeftSrv");
static_assert(offsetof(SpyCheatsComponent_CheatGameAddTimeLeftSrv, TimeToAdd) == 0x000000, "Member 'SpyCheatsComponent_CheatGameAddTimeLeftSrv::TimeToAdd' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatGameChangeMap
// 0x0010 (0x0010 - 0x0000)
struct SpyCheatsComponent_CheatGameChangeMap final
{
public:
	class FString                                 NewMap;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatGameChangeMap) == 0x000008, "Wrong alignment on SpyCheatsComponent_CheatGameChangeMap");
static_assert(sizeof(SpyCheatsComponent_CheatGameChangeMap) == 0x000010, "Wrong size on SpyCheatsComponent_CheatGameChangeMap");
static_assert(offsetof(SpyCheatsComponent_CheatGameChangeMap, NewMap) == 0x000000, "Member 'SpyCheatsComponent_CheatGameChangeMap::NewMap' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatGameChangeMapSrv
// 0x0010 (0x0010 - 0x0000)
struct SpyCheatsComponent_CheatGameChangeMapSrv final
{
public:
	class FString                                 NewMap;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatGameChangeMapSrv) == 0x000008, "Wrong alignment on SpyCheatsComponent_CheatGameChangeMapSrv");
static_assert(sizeof(SpyCheatsComponent_CheatGameChangeMapSrv) == 0x000010, "Wrong size on SpyCheatsComponent_CheatGameChangeMapSrv");
static_assert(offsetof(SpyCheatsComponent_CheatGameChangeMapSrv, NewMap) == 0x000000, "Member 'SpyCheatsComponent_CheatGameChangeMapSrv::NewMap' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatGameEndSrv
// 0x0001 (0x0001 - 0x0000)
struct SpyCheatsComponent_CheatGameEndSrv final
{
public:
	bool                                          bWin;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatGameEndSrv) == 0x000001, "Wrong alignment on SpyCheatsComponent_CheatGameEndSrv");
static_assert(sizeof(SpyCheatsComponent_CheatGameEndSrv) == 0x000001, "Wrong size on SpyCheatsComponent_CheatGameEndSrv");
static_assert(offsetof(SpyCheatsComponent_CheatGameEndSrv, bWin) == 0x000000, "Member 'SpyCheatsComponent_CheatGameEndSrv::bWin' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatGameForceFaction
// 0x0001 (0x0001 - 0x0000)
struct SpyCheatsComponent_CheatGameForceFaction final
{
public:
	int8                                          NewFactionID;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatGameForceFaction) == 0x000001, "Wrong alignment on SpyCheatsComponent_CheatGameForceFaction");
static_assert(sizeof(SpyCheatsComponent_CheatGameForceFaction) == 0x000001, "Wrong size on SpyCheatsComponent_CheatGameForceFaction");
static_assert(offsetof(SpyCheatsComponent_CheatGameForceFaction, NewFactionID) == 0x000000, "Member 'SpyCheatsComponent_CheatGameForceFaction::NewFactionID' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatGameForceFactionSrv
// 0x0001 (0x0001 - 0x0000)
struct SpyCheatsComponent_CheatGameForceFactionSrv final
{
public:
	int8                                          NewFactionID;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatGameForceFactionSrv) == 0x000001, "Wrong alignment on SpyCheatsComponent_CheatGameForceFactionSrv");
static_assert(sizeof(SpyCheatsComponent_CheatGameForceFactionSrv) == 0x000001, "Wrong size on SpyCheatsComponent_CheatGameForceFactionSrv");
static_assert(offsetof(SpyCheatsComponent_CheatGameForceFactionSrv, NewFactionID) == 0x000000, "Member 'SpyCheatsComponent_CheatGameForceFactionSrv::NewFactionID' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatGamePauseSrv
// 0x0001 (0x0001 - 0x0000)
struct SpyCheatsComponent_CheatGamePauseSrv final
{
public:
	bool                                          bPause;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatGamePauseSrv) == 0x000001, "Wrong alignment on SpyCheatsComponent_CheatGamePauseSrv");
static_assert(sizeof(SpyCheatsComponent_CheatGamePauseSrv) == 0x000001, "Wrong size on SpyCheatsComponent_CheatGamePauseSrv");
static_assert(offsetof(SpyCheatsComponent_CheatGamePauseSrv, bPause) == 0x000000, "Member 'SpyCheatsComponent_CheatGamePauseSrv::bPause' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatGameSetGuardsEnabledSrv
// 0x0001 (0x0001 - 0x0000)
struct SpyCheatsComponent_CheatGameSetGuardsEnabledSrv final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatGameSetGuardsEnabledSrv) == 0x000001, "Wrong alignment on SpyCheatsComponent_CheatGameSetGuardsEnabledSrv");
static_assert(sizeof(SpyCheatsComponent_CheatGameSetGuardsEnabledSrv) == 0x000001, "Wrong size on SpyCheatsComponent_CheatGameSetGuardsEnabledSrv");
static_assert(offsetof(SpyCheatsComponent_CheatGameSetGuardsEnabledSrv, bEnabled) == 0x000000, "Member 'SpyCheatsComponent_CheatGameSetGuardsEnabledSrv::bEnabled' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatGameSetTimeLeft
// 0x0004 (0x0004 - 0x0000)
struct SpyCheatsComponent_CheatGameSetTimeLeft final
{
public:
	int32                                         TimeLeft;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatGameSetTimeLeft) == 0x000004, "Wrong alignment on SpyCheatsComponent_CheatGameSetTimeLeft");
static_assert(sizeof(SpyCheatsComponent_CheatGameSetTimeLeft) == 0x000004, "Wrong size on SpyCheatsComponent_CheatGameSetTimeLeft");
static_assert(offsetof(SpyCheatsComponent_CheatGameSetTimeLeft, TimeLeft) == 0x000000, "Member 'SpyCheatsComponent_CheatGameSetTimeLeft::TimeLeft' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatGameSetTimeLeftSrv
// 0x0004 (0x0004 - 0x0000)
struct SpyCheatsComponent_CheatGameSetTimeLeftSrv final
{
public:
	int32                                         TimeLeft;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatGameSetTimeLeftSrv) == 0x000004, "Wrong alignment on SpyCheatsComponent_CheatGameSetTimeLeftSrv");
static_assert(sizeof(SpyCheatsComponent_CheatGameSetTimeLeftSrv) == 0x000004, "Wrong size on SpyCheatsComponent_CheatGameSetTimeLeftSrv");
static_assert(offsetof(SpyCheatsComponent_CheatGameSetTimeLeftSrv, TimeLeft) == 0x000000, "Member 'SpyCheatsComponent_CheatGameSetTimeLeftSrv::TimeLeft' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatGiveResource
// 0x0008 (0x0008 - 0x0000)
struct SpyCheatsComponent_CheatGiveResource final
{
public:
	EGameplayResourcesType                        Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Ammount;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatGiveResource) == 0x000004, "Wrong alignment on SpyCheatsComponent_CheatGiveResource");
static_assert(sizeof(SpyCheatsComponent_CheatGiveResource) == 0x000008, "Wrong size on SpyCheatsComponent_CheatGiveResource");
static_assert(offsetof(SpyCheatsComponent_CheatGiveResource, Type) == 0x000000, "Member 'SpyCheatsComponent_CheatGiveResource::Type' has a wrong offset!");
static_assert(offsetof(SpyCheatsComponent_CheatGiveResource, Ammount) == 0x000004, "Member 'SpyCheatsComponent_CheatGiveResource::Ammount' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatGiveResourceSrv
// 0x0008 (0x0008 - 0x0000)
struct SpyCheatsComponent_CheatGiveResourceSrv final
{
public:
	EGameplayResourcesType                        Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Ammount;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatGiveResourceSrv) == 0x000004, "Wrong alignment on SpyCheatsComponent_CheatGiveResourceSrv");
static_assert(sizeof(SpyCheatsComponent_CheatGiveResourceSrv) == 0x000008, "Wrong size on SpyCheatsComponent_CheatGiveResourceSrv");
static_assert(offsetof(SpyCheatsComponent_CheatGiveResourceSrv, Type) == 0x000000, "Member 'SpyCheatsComponent_CheatGiveResourceSrv::Type' has a wrong offset!");
static_assert(offsetof(SpyCheatsComponent_CheatGiveResourceSrv, Ammount) == 0x000004, "Member 'SpyCheatsComponent_CheatGiveResourceSrv::Ammount' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatHeal
// 0x0004 (0x0004 - 0x0000)
struct SpyCheatsComponent_CheatHeal final
{
public:
	float                                         HealAmmount;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatHeal) == 0x000004, "Wrong alignment on SpyCheatsComponent_CheatHeal");
static_assert(sizeof(SpyCheatsComponent_CheatHeal) == 0x000004, "Wrong size on SpyCheatsComponent_CheatHeal");
static_assert(offsetof(SpyCheatsComponent_CheatHeal, HealAmmount) == 0x000000, "Member 'SpyCheatsComponent_CheatHeal::HealAmmount' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatHealSrv
// 0x0004 (0x0004 - 0x0000)
struct SpyCheatsComponent_CheatHealSrv final
{
public:
	float                                         HealAmmount;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatHealSrv) == 0x000004, "Wrong alignment on SpyCheatsComponent_CheatHealSrv");
static_assert(sizeof(SpyCheatsComponent_CheatHealSrv) == 0x000004, "Wrong size on SpyCheatsComponent_CheatHealSrv");
static_assert(offsetof(SpyCheatsComponent_CheatHealSrv, HealAmmount) == 0x000000, "Member 'SpyCheatsComponent_CheatHealSrv::HealAmmount' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatHeatSetLevel
// 0x0004 (0x0004 - 0x0000)
struct SpyCheatsComponent_CheatHeatSetLevel final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatHeatSetLevel) == 0x000004, "Wrong alignment on SpyCheatsComponent_CheatHeatSetLevel");
static_assert(sizeof(SpyCheatsComponent_CheatHeatSetLevel) == 0x000004, "Wrong size on SpyCheatsComponent_CheatHeatSetLevel");
static_assert(offsetof(SpyCheatsComponent_CheatHeatSetLevel, Level) == 0x000000, "Member 'SpyCheatsComponent_CheatHeatSetLevel::Level' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatHeatSetLevelSrv
// 0x0004 (0x0004 - 0x0000)
struct SpyCheatsComponent_CheatHeatSetLevelSrv final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatHeatSetLevelSrv) == 0x000004, "Wrong alignment on SpyCheatsComponent_CheatHeatSetLevelSrv");
static_assert(sizeof(SpyCheatsComponent_CheatHeatSetLevelSrv) == 0x000004, "Wrong size on SpyCheatsComponent_CheatHeatSetLevelSrv");
static_assert(offsetof(SpyCheatsComponent_CheatHeatSetLevelSrv, Level) == 0x000000, "Member 'SpyCheatsComponent_CheatHeatSetLevelSrv::Level' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatHideHud
// 0x0010 (0x0010 - 0x0000)
struct SpyCheatsComponent_CheatHideHud final
{
public:
	class FString                                 HudToHide;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatHideHud) == 0x000008, "Wrong alignment on SpyCheatsComponent_CheatHideHud");
static_assert(sizeof(SpyCheatsComponent_CheatHideHud) == 0x000010, "Wrong size on SpyCheatsComponent_CheatHideHud");
static_assert(offsetof(SpyCheatsComponent_CheatHideHud, HudToHide) == 0x000000, "Member 'SpyCheatsComponent_CheatHideHud::HudToHide' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatLogClient
// 0x0010 (0x0010 - 0x0000)
struct SpyCheatsComponent_CheatLogClient final
{
public:
	class FString                                 Message;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatLogClient) == 0x000008, "Wrong alignment on SpyCheatsComponent_CheatLogClient");
static_assert(sizeof(SpyCheatsComponent_CheatLogClient) == 0x000010, "Wrong size on SpyCheatsComponent_CheatLogClient");
static_assert(offsetof(SpyCheatsComponent_CheatLogClient, Message) == 0x000000, "Member 'SpyCheatsComponent_CheatLogClient::Message' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatLogServer
// 0x0010 (0x0010 - 0x0000)
struct SpyCheatsComponent_CheatLogServer final
{
public:
	class FString                                 Message;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatLogServer) == 0x000008, "Wrong alignment on SpyCheatsComponent_CheatLogServer");
static_assert(sizeof(SpyCheatsComponent_CheatLogServer) == 0x000010, "Wrong size on SpyCheatsComponent_CheatLogServer");
static_assert(offsetof(SpyCheatsComponent_CheatLogServer, Message) == 0x000000, "Member 'SpyCheatsComponent_CheatLogServer::Message' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatNPCSetNetCullingDistance
// 0x0004 (0x0004 - 0x0000)
struct SpyCheatsComponent_CheatNPCSetNetCullingDistance final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatNPCSetNetCullingDistance) == 0x000004, "Wrong alignment on SpyCheatsComponent_CheatNPCSetNetCullingDistance");
static_assert(sizeof(SpyCheatsComponent_CheatNPCSetNetCullingDistance) == 0x000004, "Wrong size on SpyCheatsComponent_CheatNPCSetNetCullingDistance");
static_assert(offsetof(SpyCheatsComponent_CheatNPCSetNetCullingDistance, Distance) == 0x000000, "Member 'SpyCheatsComponent_CheatNPCSetNetCullingDistance::Distance' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatNPCSetNetCullingDistanceSrv
// 0x0004 (0x0004 - 0x0000)
struct SpyCheatsComponent_CheatNPCSetNetCullingDistanceSrv final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatNPCSetNetCullingDistanceSrv) == 0x000004, "Wrong alignment on SpyCheatsComponent_CheatNPCSetNetCullingDistanceSrv");
static_assert(sizeof(SpyCheatsComponent_CheatNPCSetNetCullingDistanceSrv) == 0x000004, "Wrong size on SpyCheatsComponent_CheatNPCSetNetCullingDistanceSrv");
static_assert(offsetof(SpyCheatsComponent_CheatNPCSetNetCullingDistanceSrv, Distance) == 0x000000, "Member 'SpyCheatsComponent_CheatNPCSetNetCullingDistanceSrv::Distance' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatSetGameRuleset
// 0x0001 (0x0001 - 0x0000)
struct SpyCheatsComponent_CheatSetGameRuleset final
{
public:
	EDIGameRuleset                                NewRuleset;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatSetGameRuleset) == 0x000001, "Wrong alignment on SpyCheatsComponent_CheatSetGameRuleset");
static_assert(sizeof(SpyCheatsComponent_CheatSetGameRuleset) == 0x000001, "Wrong size on SpyCheatsComponent_CheatSetGameRuleset");
static_assert(offsetof(SpyCheatsComponent_CheatSetGameRuleset, NewRuleset) == 0x000000, "Member 'SpyCheatsComponent_CheatSetGameRuleset::NewRuleset' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatSetGameRulesetSrv
// 0x0001 (0x0001 - 0x0000)
struct SpyCheatsComponent_CheatSetGameRulesetSrv final
{
public:
	EDIGameRuleset                                NewRuleset;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatSetGameRulesetSrv) == 0x000001, "Wrong alignment on SpyCheatsComponent_CheatSetGameRulesetSrv");
static_assert(sizeof(SpyCheatsComponent_CheatSetGameRulesetSrv) == 0x000001, "Wrong size on SpyCheatsComponent_CheatSetGameRulesetSrv");
static_assert(offsetof(SpyCheatsComponent_CheatSetGameRulesetSrv, NewRuleset) == 0x000000, "Member 'SpyCheatsComponent_CheatSetGameRulesetSrv::NewRuleset' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatSmokeTestBotsBattleRoyaleSrv
// 0x0001 (0x0001 - 0x0000)
struct SpyCheatsComponent_CheatSmokeTestBotsBattleRoyaleSrv final
{
public:
	bool                                          bDemiGod;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatSmokeTestBotsBattleRoyaleSrv) == 0x000001, "Wrong alignment on SpyCheatsComponent_CheatSmokeTestBotsBattleRoyaleSrv");
static_assert(sizeof(SpyCheatsComponent_CheatSmokeTestBotsBattleRoyaleSrv) == 0x000001, "Wrong size on SpyCheatsComponent_CheatSmokeTestBotsBattleRoyaleSrv");
static_assert(offsetof(SpyCheatsComponent_CheatSmokeTestBotsBattleRoyaleSrv, bDemiGod) == 0x000000, "Member 'SpyCheatsComponent_CheatSmokeTestBotsBattleRoyaleSrv::bDemiGod' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatSpawnBot
// 0x0010 (0x0010 - 0x0000)
struct SpyCheatsComponent_CheatSpawnBot final
{
public:
	class FString                                 SpyName;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatSpawnBot) == 0x000008, "Wrong alignment on SpyCheatsComponent_CheatSpawnBot");
static_assert(sizeof(SpyCheatsComponent_CheatSpawnBot) == 0x000010, "Wrong size on SpyCheatsComponent_CheatSpawnBot");
static_assert(offsetof(SpyCheatsComponent_CheatSpawnBot, SpyName) == 0x000000, "Member 'SpyCheatsComponent_CheatSpawnBot::SpyName' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatSpawnBotAndDebug
// 0x0010 (0x0010 - 0x0000)
struct SpyCheatsComponent_CheatSpawnBotAndDebug final
{
public:
	class FString                                 SpyName;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatSpawnBotAndDebug) == 0x000008, "Wrong alignment on SpyCheatsComponent_CheatSpawnBotAndDebug");
static_assert(sizeof(SpyCheatsComponent_CheatSpawnBotAndDebug) == 0x000010, "Wrong size on SpyCheatsComponent_CheatSpawnBotAndDebug");
static_assert(offsetof(SpyCheatsComponent_CheatSpawnBotAndDebug, SpyName) == 0x000000, "Member 'SpyCheatsComponent_CheatSpawnBotAndDebug::SpyName' has a wrong offset!");

// Function DeceiveInc.SpyCheatsComponent.CheatSpawnBotSrv
// 0x0010 (0x0010 - 0x0000)
struct SpyCheatsComponent_CheatSpawnBotSrv final
{
public:
	class FString                                 SpyName;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyCheatsComponent_CheatSpawnBotSrv) == 0x000008, "Wrong alignment on SpyCheatsComponent_CheatSpawnBotSrv");
static_assert(sizeof(SpyCheatsComponent_CheatSpawnBotSrv) == 0x000010, "Wrong size on SpyCheatsComponent_CheatSpawnBotSrv");
static_assert(offsetof(SpyCheatsComponent_CheatSpawnBotSrv, SpyName) == 0x000000, "Member 'SpyCheatsComponent_CheatSpawnBotSrv::SpyName' has a wrong offset!");

// Function DeceiveInc.SpyGlassTool.HandleAddInteractionTimeReduction
// 0x0004 (0x0004 - 0x0000)
struct SpyGlassTool_HandleAddInteractionTimeReduction final
{
public:
	float                                         Reduction;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyGlassTool_HandleAddInteractionTimeReduction) == 0x000004, "Wrong alignment on SpyGlassTool_HandleAddInteractionTimeReduction");
static_assert(sizeof(SpyGlassTool_HandleAddInteractionTimeReduction) == 0x000004, "Wrong size on SpyGlassTool_HandleAddInteractionTimeReduction");
static_assert(offsetof(SpyGlassTool_HandleAddInteractionTimeReduction, Reduction) == 0x000000, "Member 'SpyGlassTool_HandleAddInteractionTimeReduction::Reduction' has a wrong offset!");

// Function DeceiveInc.SpyGlassTool.HandleCooldownChange
// 0x0001 (0x0001 - 0x0000)
struct SpyGlassTool_HandleCooldownChange final
{
public:
	bool                                          bOnCooldown;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyGlassTool_HandleCooldownChange) == 0x000001, "Wrong alignment on SpyGlassTool_HandleCooldownChange");
static_assert(sizeof(SpyGlassTool_HandleCooldownChange) == 0x000001, "Wrong size on SpyGlassTool_HandleCooldownChange");
static_assert(offsetof(SpyGlassTool_HandleCooldownChange, bOnCooldown) == 0x000000, "Member 'SpyGlassTool_HandleCooldownChange::bOnCooldown' has a wrong offset!");

// Function DeceiveInc.SpyGlassTool.HandleInteractionComplete
// 0x0010 (0x0010 - 0x0000)
struct SpyGlassTool_HandleInteractionComplete final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyGlassTool_HandleInteractionComplete) == 0x000008, "Wrong alignment on SpyGlassTool_HandleInteractionComplete");
static_assert(sizeof(SpyGlassTool_HandleInteractionComplete) == 0x000010, "Wrong size on SpyGlassTool_HandleInteractionComplete");
static_assert(offsetof(SpyGlassTool_HandleInteractionComplete, Interacter) == 0x000000, "Member 'SpyGlassTool_HandleInteractionComplete::Interacter' has a wrong offset!");
static_assert(offsetof(SpyGlassTool_HandleInteractionComplete, Interactable) == 0x000008, "Member 'SpyGlassTool_HandleInteractionComplete::Interactable' has a wrong offset!");

// Function DeceiveInc.SpyGlassTool.HandleRemoveInteractionTimeReduction
// 0x0004 (0x0004 - 0x0000)
struct SpyGlassTool_HandleRemoveInteractionTimeReduction final
{
public:
	float                                         Reduction;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyGlassTool_HandleRemoveInteractionTimeReduction) == 0x000004, "Wrong alignment on SpyGlassTool_HandleRemoveInteractionTimeReduction");
static_assert(sizeof(SpyGlassTool_HandleRemoveInteractionTimeReduction) == 0x000004, "Wrong size on SpyGlassTool_HandleRemoveInteractionTimeReduction");
static_assert(offsetof(SpyGlassTool_HandleRemoveInteractionTimeReduction, Reduction) == 0x000000, "Member 'SpyGlassTool_HandleRemoveInteractionTimeReduction::Reduction' has a wrong offset!");

// Function DeceiveInc.SpyPing.BP_SetupPing
// 0x0060 (0x0060 - 0x0000)
struct SpyPing_BP_SetupPing final
{
public:
	struct FPingData                              SetupPingData;                                     // 0x0000(0x0058)(Parm, NativeAccessSpecifierPublic)
	int32                                         FactionIndex;                                      // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SpyPing_BP_SetupPing) == 0x000008, "Wrong alignment on SpyPing_BP_SetupPing");
static_assert(sizeof(SpyPing_BP_SetupPing) == 0x000060, "Wrong size on SpyPing_BP_SetupPing");
static_assert(offsetof(SpyPing_BP_SetupPing, SetupPingData) == 0x000000, "Member 'SpyPing_BP_SetupPing::SetupPingData' has a wrong offset!");
static_assert(offsetof(SpyPing_BP_SetupPing, FactionIndex) == 0x000058, "Member 'SpyPing_BP_SetupPing::FactionIndex' has a wrong offset!");

// Function DeceiveInc.SpyPing.GetWidgetFade
// 0x0004 (0x0004 - 0x0000)
struct SpyPing_GetWidgetFade final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpyPing_GetWidgetFade) == 0x000004, "Wrong alignment on SpyPing_GetWidgetFade");
static_assert(sizeof(SpyPing_GetWidgetFade) == 0x000004, "Wrong size on SpyPing_GetWidgetFade");
static_assert(offsetof(SpyPing_GetWidgetFade, ReturnValue) == 0x000000, "Member 'SpyPing_GetWidgetFade::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SquireActiveAbility.BP_OnInteractableDetected
// 0x0010 (0x0010 - 0x0000)
struct SquireActiveAbility_BP_OnInteractableDetected final
{
public:
	class AActor*                                 InteractableActor;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractableType                             InteractableType;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StencilValue;                                      // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SquireActiveAbility_BP_OnInteractableDetected) == 0x000008, "Wrong alignment on SquireActiveAbility_BP_OnInteractableDetected");
static_assert(sizeof(SquireActiveAbility_BP_OnInteractableDetected) == 0x000010, "Wrong size on SquireActiveAbility_BP_OnInteractableDetected");
static_assert(offsetof(SquireActiveAbility_BP_OnInteractableDetected, InteractableActor) == 0x000000, "Member 'SquireActiveAbility_BP_OnInteractableDetected::InteractableActor' has a wrong offset!");
static_assert(offsetof(SquireActiveAbility_BP_OnInteractableDetected, InteractableType) == 0x000008, "Member 'SquireActiveAbility_BP_OnInteractableDetected::InteractableType' has a wrong offset!");
static_assert(offsetof(SquireActiveAbility_BP_OnInteractableDetected, StencilValue) == 0x000009, "Member 'SquireActiveAbility_BP_OnInteractableDetected::StencilValue' has a wrong offset!");

// Function DeceiveInc.SquireActiveAbility.BP_OnInteractableDetectionEnd
// 0x0008 (0x0008 - 0x0000)
struct SquireActiveAbility_BP_OnInteractableDetectionEnd final
{
public:
	class AActor*                                 InteractableActor;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SquireActiveAbility_BP_OnInteractableDetectionEnd) == 0x000008, "Wrong alignment on SquireActiveAbility_BP_OnInteractableDetectionEnd");
static_assert(sizeof(SquireActiveAbility_BP_OnInteractableDetectionEnd) == 0x000008, "Wrong size on SquireActiveAbility_BP_OnInteractableDetectionEnd");
static_assert(offsetof(SquireActiveAbility_BP_OnInteractableDetectionEnd, InteractableActor) == 0x000000, "Member 'SquireActiveAbility_BP_OnInteractableDetectionEnd::InteractableActor' has a wrong offset!");

// Function DeceiveInc.SquireActiveAbilityMod2.BP_ClosestSpyInfo
// 0x0018 (0x0018 - 0x0000)
struct SquireActiveAbilityMod2_BP_ClosestSpyInfo final
{
public:
	int32                                         AffectedSpies;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASpy*                                   Spy;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SquireActiveAbilityMod2_BP_ClosestSpyInfo) == 0x000008, "Wrong alignment on SquireActiveAbilityMod2_BP_ClosestSpyInfo");
static_assert(sizeof(SquireActiveAbilityMod2_BP_ClosestSpyInfo) == 0x000018, "Wrong size on SquireActiveAbilityMod2_BP_ClosestSpyInfo");
static_assert(offsetof(SquireActiveAbilityMod2_BP_ClosestSpyInfo, AffectedSpies) == 0x000000, "Member 'SquireActiveAbilityMod2_BP_ClosestSpyInfo::AffectedSpies' has a wrong offset!");
static_assert(offsetof(SquireActiveAbilityMod2_BP_ClosestSpyInfo, Spy) == 0x000008, "Member 'SquireActiveAbilityMod2_BP_ClosestSpyInfo::Spy' has a wrong offset!");
static_assert(offsetof(SquireActiveAbilityMod2_BP_ClosestSpyInfo, Distance) == 0x000010, "Member 'SquireActiveAbilityMod2_BP_ClosestSpyInfo::Distance' has a wrong offset!");

// Function DeceiveInc.SquireActiveAbilityMod2.BP_DetectedSpiesChanged
// 0x0004 (0x0004 - 0x0000)
struct SquireActiveAbilityMod2_BP_DetectedSpiesChanged final
{
public:
	int32                                         AffectedSpies;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SquireActiveAbilityMod2_BP_DetectedSpiesChanged) == 0x000004, "Wrong alignment on SquireActiveAbilityMod2_BP_DetectedSpiesChanged");
static_assert(sizeof(SquireActiveAbilityMod2_BP_DetectedSpiesChanged) == 0x000004, "Wrong size on SquireActiveAbilityMod2_BP_DetectedSpiesChanged");
static_assert(offsetof(SquireActiveAbilityMod2_BP_DetectedSpiesChanged, AffectedSpies) == 0x000000, "Member 'SquireActiveAbilityMod2_BP_DetectedSpiesChanged::AffectedSpies' has a wrong offset!");

// Function DeceiveInc.SquireActiveAbilityMod2.BP_DetectedSpy
// 0x0010 (0x0010 - 0x0000)
struct SquireActiveAbilityMod2_BP_DetectedSpy final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SquireActiveAbilityMod2_BP_DetectedSpy) == 0x000008, "Wrong alignment on SquireActiveAbilityMod2_BP_DetectedSpy");
static_assert(sizeof(SquireActiveAbilityMod2_BP_DetectedSpy) == 0x000010, "Wrong size on SquireActiveAbilityMod2_BP_DetectedSpy");
static_assert(offsetof(SquireActiveAbilityMod2_BP_DetectedSpy, Spy) == 0x000000, "Member 'SquireActiveAbilityMod2_BP_DetectedSpy::Spy' has a wrong offset!");
static_assert(offsetof(SquireActiveAbilityMod2_BP_DetectedSpy, Distance) == 0x000008, "Member 'SquireActiveAbilityMod2_BP_DetectedSpy::Distance' has a wrong offset!");

// Function DeceiveInc.SquirePassiveAbilityMod2.HandleOnDisguiseShieldInitDone
// 0x0008 (0x0008 - 0x0000)
struct SquirePassiveAbilityMod2_HandleOnDisguiseShieldInitDone final
{
public:
	class UDisguiseShieldComponent*               DisguiseShieldComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SquirePassiveAbilityMod2_HandleOnDisguiseShieldInitDone) == 0x000008, "Wrong alignment on SquirePassiveAbilityMod2_HandleOnDisguiseShieldInitDone");
static_assert(sizeof(SquirePassiveAbilityMod2_HandleOnDisguiseShieldInitDone) == 0x000008, "Wrong size on SquirePassiveAbilityMod2_HandleOnDisguiseShieldInitDone");
static_assert(offsetof(SquirePassiveAbilityMod2_HandleOnDisguiseShieldInitDone, DisguiseShieldComponent) == 0x000000, "Member 'SquirePassiveAbilityMod2_HandleOnDisguiseShieldInitDone::DisguiseShieldComponent' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.GetPlayerVoiceChat
// 0x0008 (0x0008 - 0x0000)
struct SweetChatSubsystem_GetPlayerVoiceChat final
{
public:
	class ADeceiveIncPlayerVoiceChat*             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_GetPlayerVoiceChat) == 0x000008, "Wrong alignment on SweetChatSubsystem_GetPlayerVoiceChat");
static_assert(sizeof(SweetChatSubsystem_GetPlayerVoiceChat) == 0x000008, "Wrong size on SweetChatSubsystem_GetPlayerVoiceChat");
static_assert(offsetof(SweetChatSubsystem_GetPlayerVoiceChat, ReturnValue) == 0x000000, "Member 'SweetChatSubsystem_GetPlayerVoiceChat::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.HandleBooleanPlayerSettingChange
// 0x0002 (0x0002 - 0x0000)
struct SweetChatSubsystem_HandleBooleanPlayerSettingChange final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewValue;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_HandleBooleanPlayerSettingChange) == 0x000001, "Wrong alignment on SweetChatSubsystem_HandleBooleanPlayerSettingChange");
static_assert(sizeof(SweetChatSubsystem_HandleBooleanPlayerSettingChange) == 0x000002, "Wrong size on SweetChatSubsystem_HandleBooleanPlayerSettingChange");
static_assert(offsetof(SweetChatSubsystem_HandleBooleanPlayerSettingChange, SettingType) == 0x000000, "Member 'SweetChatSubsystem_HandleBooleanPlayerSettingChange::SettingType' has a wrong offset!");
static_assert(offsetof(SweetChatSubsystem_HandleBooleanPlayerSettingChange, NewValue) == 0x000001, "Member 'SweetChatSubsystem_HandleBooleanPlayerSettingChange::NewValue' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.HandleIntegerPlayerSettingChange
// 0x0008 (0x0008 - 0x0000)
struct SweetChatSubsystem_HandleIntegerPlayerSettingChange final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NewValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_HandleIntegerPlayerSettingChange) == 0x000004, "Wrong alignment on SweetChatSubsystem_HandleIntegerPlayerSettingChange");
static_assert(sizeof(SweetChatSubsystem_HandleIntegerPlayerSettingChange) == 0x000008, "Wrong size on SweetChatSubsystem_HandleIntegerPlayerSettingChange");
static_assert(offsetof(SweetChatSubsystem_HandleIntegerPlayerSettingChange, SettingType) == 0x000000, "Member 'SweetChatSubsystem_HandleIntegerPlayerSettingChange::SettingType' has a wrong offset!");
static_assert(offsetof(SweetChatSubsystem_HandleIntegerPlayerSettingChange, NewValue) == 0x000004, "Member 'SweetChatSubsystem_HandleIntegerPlayerSettingChange::NewValue' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.HandleLocalPlayerTalkingUpdate
// 0x0008 (0x0008 - 0x0000)
struct SweetChatSubsystem_HandleLocalPlayerTalkingUpdate final
{
public:
	bool                                          Talking;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAmp;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_HandleLocalPlayerTalkingUpdate) == 0x000004, "Wrong alignment on SweetChatSubsystem_HandleLocalPlayerTalkingUpdate");
static_assert(sizeof(SweetChatSubsystem_HandleLocalPlayerTalkingUpdate) == 0x000008, "Wrong size on SweetChatSubsystem_HandleLocalPlayerTalkingUpdate");
static_assert(offsetof(SweetChatSubsystem_HandleLocalPlayerTalkingUpdate, Talking) == 0x000000, "Member 'SweetChatSubsystem_HandleLocalPlayerTalkingUpdate::Talking' has a wrong offset!");
static_assert(offsetof(SweetChatSubsystem_HandleLocalPlayerTalkingUpdate, MaxAmp) == 0x000004, "Member 'SweetChatSubsystem_HandleLocalPlayerTalkingUpdate::MaxAmp' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.HandleStringPlayerSettingChange
// 0x0018 (0x0018 - 0x0000)
struct SweetChatSubsystem_HandleStringPlayerSettingChange final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NewValue;                                          // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_HandleStringPlayerSettingChange) == 0x000008, "Wrong alignment on SweetChatSubsystem_HandleStringPlayerSettingChange");
static_assert(sizeof(SweetChatSubsystem_HandleStringPlayerSettingChange) == 0x000018, "Wrong size on SweetChatSubsystem_HandleStringPlayerSettingChange");
static_assert(offsetof(SweetChatSubsystem_HandleStringPlayerSettingChange, SettingType) == 0x000000, "Member 'SweetChatSubsystem_HandleStringPlayerSettingChange::SettingType' has a wrong offset!");
static_assert(offsetof(SweetChatSubsystem_HandleStringPlayerSettingChange, NewValue) == 0x000008, "Member 'SweetChatSubsystem_HandleStringPlayerSettingChange::NewValue' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.HandleVCInstanceBeingDestroyed
// 0x0008 (0x0008 - 0x0000)
struct SweetChatSubsystem_HandleVCInstanceBeingDestroyed final
{
public:
	class AEOSVoiceChatHandler*                   Instance;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_HandleVCInstanceBeingDestroyed) == 0x000008, "Wrong alignment on SweetChatSubsystem_HandleVCInstanceBeingDestroyed");
static_assert(sizeof(SweetChatSubsystem_HandleVCInstanceBeingDestroyed) == 0x000008, "Wrong size on SweetChatSubsystem_HandleVCInstanceBeingDestroyed");
static_assert(offsetof(SweetChatSubsystem_HandleVCInstanceBeingDestroyed, Instance) == 0x000000, "Member 'SweetChatSubsystem_HandleVCInstanceBeingDestroyed::Instance' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.HandleVoiceChatChannelExited
// 0x0020 (0x0020 - 0x0000)
struct SweetChatSubsystem_HandleVoiceChatChannelExited final
{
public:
	class FString                                 ChannelName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Reason;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_HandleVoiceChatChannelExited) == 0x000008, "Wrong alignment on SweetChatSubsystem_HandleVoiceChatChannelExited");
static_assert(sizeof(SweetChatSubsystem_HandleVoiceChatChannelExited) == 0x000020, "Wrong size on SweetChatSubsystem_HandleVoiceChatChannelExited");
static_assert(offsetof(SweetChatSubsystem_HandleVoiceChatChannelExited, ChannelName) == 0x000000, "Member 'SweetChatSubsystem_HandleVoiceChatChannelExited::ChannelName' has a wrong offset!");
static_assert(offsetof(SweetChatSubsystem_HandleVoiceChatChannelExited, Reason) == 0x000010, "Member 'SweetChatSubsystem_HandleVoiceChatChannelExited::Reason' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.HandleVoiceChatChannelJoined
// 0x0010 (0x0010 - 0x0000)
struct SweetChatSubsystem_HandleVoiceChatChannelJoined final
{
public:
	class FString                                 ChannelName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_HandleVoiceChatChannelJoined) == 0x000008, "Wrong alignment on SweetChatSubsystem_HandleVoiceChatChannelJoined");
static_assert(sizeof(SweetChatSubsystem_HandleVoiceChatChannelJoined) == 0x000010, "Wrong size on SweetChatSubsystem_HandleVoiceChatChannelJoined");
static_assert(offsetof(SweetChatSubsystem_HandleVoiceChatChannelJoined, ChannelName) == 0x000000, "Member 'SweetChatSubsystem_HandleVoiceChatChannelJoined::ChannelName' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.HandleVoiceChatDisconnected
// 0x0010 (0x0010 - 0x0000)
struct SweetChatSubsystem_HandleVoiceChatDisconnected final
{
public:
	class FString                                 Reason;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_HandleVoiceChatDisconnected) == 0x000008, "Wrong alignment on SweetChatSubsystem_HandleVoiceChatDisconnected");
static_assert(sizeof(SweetChatSubsystem_HandleVoiceChatDisconnected) == 0x000010, "Wrong size on SweetChatSubsystem_HandleVoiceChatDisconnected");
static_assert(offsetof(SweetChatSubsystem_HandleVoiceChatDisconnected, Reason) == 0x000000, "Member 'SweetChatSubsystem_HandleVoiceChatDisconnected::Reason' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.HandleVoiceChatLoggedIn
// 0x0010 (0x0010 - 0x0000)
struct SweetChatSubsystem_HandleVoiceChatLoggedIn final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_HandleVoiceChatLoggedIn) == 0x000008, "Wrong alignment on SweetChatSubsystem_HandleVoiceChatLoggedIn");
static_assert(sizeof(SweetChatSubsystem_HandleVoiceChatLoggedIn) == 0x000010, "Wrong size on SweetChatSubsystem_HandleVoiceChatLoggedIn");
static_assert(offsetof(SweetChatSubsystem_HandleVoiceChatLoggedIn, PlayerName) == 0x000000, "Member 'SweetChatSubsystem_HandleVoiceChatLoggedIn::PlayerName' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.HandleVoiceChatLoggedOut
// 0x0010 (0x0010 - 0x0000)
struct SweetChatSubsystem_HandleVoiceChatLoggedOut final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_HandleVoiceChatLoggedOut) == 0x000008, "Wrong alignment on SweetChatSubsystem_HandleVoiceChatLoggedOut");
static_assert(sizeof(SweetChatSubsystem_HandleVoiceChatLoggedOut) == 0x000010, "Wrong size on SweetChatSubsystem_HandleVoiceChatLoggedOut");
static_assert(offsetof(SweetChatSubsystem_HandleVoiceChatLoggedOut, PlayerName) == 0x000000, "Member 'SweetChatSubsystem_HandleVoiceChatLoggedOut::PlayerName' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.HandleVoiceChatPlayerAdded
// 0x0020 (0x0020 - 0x0000)
struct SweetChatSubsystem_HandleVoiceChatPlayerAdded final
{
public:
	class FString                                 ChannelName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerName;                                        // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_HandleVoiceChatPlayerAdded) == 0x000008, "Wrong alignment on SweetChatSubsystem_HandleVoiceChatPlayerAdded");
static_assert(sizeof(SweetChatSubsystem_HandleVoiceChatPlayerAdded) == 0x000020, "Wrong size on SweetChatSubsystem_HandleVoiceChatPlayerAdded");
static_assert(offsetof(SweetChatSubsystem_HandleVoiceChatPlayerAdded, ChannelName) == 0x000000, "Member 'SweetChatSubsystem_HandleVoiceChatPlayerAdded::ChannelName' has a wrong offset!");
static_assert(offsetof(SweetChatSubsystem_HandleVoiceChatPlayerAdded, PlayerName) == 0x000010, "Member 'SweetChatSubsystem_HandleVoiceChatPlayerAdded::PlayerName' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.HandleVoiceChatPlayerMuteUpdated
// 0x0028 (0x0028 - 0x0000)
struct SweetChatSubsystem_HandleVoiceChatPlayerMuteUpdated final
{
public:
	class FString                                 ChannelName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerName;                                        // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMuted;                                          // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SweetChatSubsystem_HandleVoiceChatPlayerMuteUpdated) == 0x000008, "Wrong alignment on SweetChatSubsystem_HandleVoiceChatPlayerMuteUpdated");
static_assert(sizeof(SweetChatSubsystem_HandleVoiceChatPlayerMuteUpdated) == 0x000028, "Wrong size on SweetChatSubsystem_HandleVoiceChatPlayerMuteUpdated");
static_assert(offsetof(SweetChatSubsystem_HandleVoiceChatPlayerMuteUpdated, ChannelName) == 0x000000, "Member 'SweetChatSubsystem_HandleVoiceChatPlayerMuteUpdated::ChannelName' has a wrong offset!");
static_assert(offsetof(SweetChatSubsystem_HandleVoiceChatPlayerMuteUpdated, PlayerName) == 0x000010, "Member 'SweetChatSubsystem_HandleVoiceChatPlayerMuteUpdated::PlayerName' has a wrong offset!");
static_assert(offsetof(SweetChatSubsystem_HandleVoiceChatPlayerMuteUpdated, bIsMuted) == 0x000020, "Member 'SweetChatSubsystem_HandleVoiceChatPlayerMuteUpdated::bIsMuted' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.HandleVoiceChatPlayerRemoved
// 0x0020 (0x0020 - 0x0000)
struct SweetChatSubsystem_HandleVoiceChatPlayerRemoved final
{
public:
	class FString                                 ChannelName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerName;                                        // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_HandleVoiceChatPlayerRemoved) == 0x000008, "Wrong alignment on SweetChatSubsystem_HandleVoiceChatPlayerRemoved");
static_assert(sizeof(SweetChatSubsystem_HandleVoiceChatPlayerRemoved) == 0x000020, "Wrong size on SweetChatSubsystem_HandleVoiceChatPlayerRemoved");
static_assert(offsetof(SweetChatSubsystem_HandleVoiceChatPlayerRemoved, ChannelName) == 0x000000, "Member 'SweetChatSubsystem_HandleVoiceChatPlayerRemoved::ChannelName' has a wrong offset!");
static_assert(offsetof(SweetChatSubsystem_HandleVoiceChatPlayerRemoved, PlayerName) == 0x000010, "Member 'SweetChatSubsystem_HandleVoiceChatPlayerRemoved::PlayerName' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.HandleVoiceChatPlayerTalkingUpdated
// 0x0028 (0x0028 - 0x0000)
struct SweetChatSubsystem_HandleVoiceChatPlayerTalkingUpdated final
{
public:
	class FString                                 ChannelName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerName;                                        // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTalking;                                        // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SweetChatSubsystem_HandleVoiceChatPlayerTalkingUpdated) == 0x000008, "Wrong alignment on SweetChatSubsystem_HandleVoiceChatPlayerTalkingUpdated");
static_assert(sizeof(SweetChatSubsystem_HandleVoiceChatPlayerTalkingUpdated) == 0x000028, "Wrong size on SweetChatSubsystem_HandleVoiceChatPlayerTalkingUpdated");
static_assert(offsetof(SweetChatSubsystem_HandleVoiceChatPlayerTalkingUpdated, ChannelName) == 0x000000, "Member 'SweetChatSubsystem_HandleVoiceChatPlayerTalkingUpdated::ChannelName' has a wrong offset!");
static_assert(offsetof(SweetChatSubsystem_HandleVoiceChatPlayerTalkingUpdated, PlayerName) == 0x000010, "Member 'SweetChatSubsystem_HandleVoiceChatPlayerTalkingUpdated::PlayerName' has a wrong offset!");
static_assert(offsetof(SweetChatSubsystem_HandleVoiceChatPlayerTalkingUpdated, bIsTalking) == 0x000020, "Member 'SweetChatSubsystem_HandleVoiceChatPlayerTalkingUpdated::bIsTalking' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.JoinVoiceChannel
// 0x0028 (0x0028 - 0x0000)
struct SweetChatSubsystem_JoinVoiceChannel final
{
public:
	class FString                                 ChannelName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChannelCredentials;                                // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SweetChatSubsystem_JoinVoiceChannel) == 0x000008, "Wrong alignment on SweetChatSubsystem_JoinVoiceChannel");
static_assert(sizeof(SweetChatSubsystem_JoinVoiceChannel) == 0x000028, "Wrong size on SweetChatSubsystem_JoinVoiceChannel");
static_assert(offsetof(SweetChatSubsystem_JoinVoiceChannel, ChannelName) == 0x000000, "Member 'SweetChatSubsystem_JoinVoiceChannel::ChannelName' has a wrong offset!");
static_assert(offsetof(SweetChatSubsystem_JoinVoiceChannel, ChannelCredentials) == 0x000010, "Member 'SweetChatSubsystem_JoinVoiceChannel::ChannelCredentials' has a wrong offset!");
static_assert(offsetof(SweetChatSubsystem_JoinVoiceChannel, ReturnValue) == 0x000020, "Member 'SweetChatSubsystem_JoinVoiceChannel::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.LeaveAllVoiceChannels
// 0x0001 (0x0001 - 0x0000)
struct SweetChatSubsystem_LeaveAllVoiceChannels final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_LeaveAllVoiceChannels) == 0x000001, "Wrong alignment on SweetChatSubsystem_LeaveAllVoiceChannels");
static_assert(sizeof(SweetChatSubsystem_LeaveAllVoiceChannels) == 0x000001, "Wrong size on SweetChatSubsystem_LeaveAllVoiceChannels");
static_assert(offsetof(SweetChatSubsystem_LeaveAllVoiceChannels, ReturnValue) == 0x000000, "Member 'SweetChatSubsystem_LeaveAllVoiceChannels::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.LeaveVoiceChannel
// 0x0018 (0x0018 - 0x0000)
struct SweetChatSubsystem_LeaveVoiceChannel final
{
public:
	class FString                                 ChannelName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SweetChatSubsystem_LeaveVoiceChannel) == 0x000008, "Wrong alignment on SweetChatSubsystem_LeaveVoiceChannel");
static_assert(sizeof(SweetChatSubsystem_LeaveVoiceChannel) == 0x000018, "Wrong size on SweetChatSubsystem_LeaveVoiceChannel");
static_assert(offsetof(SweetChatSubsystem_LeaveVoiceChannel, ChannelName) == 0x000000, "Member 'SweetChatSubsystem_LeaveVoiceChannel::ChannelName' has a wrong offset!");
static_assert(offsetof(SweetChatSubsystem_LeaveVoiceChannel, ReturnValue) == 0x000010, "Member 'SweetChatSubsystem_LeaveVoiceChannel::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.SetInputMuted
// 0x0001 (0x0001 - 0x0000)
struct SweetChatSubsystem_SetInputMuted final
{
public:
	bool                                          bMuted;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_SetInputMuted) == 0x000001, "Wrong alignment on SweetChatSubsystem_SetInputMuted");
static_assert(sizeof(SweetChatSubsystem_SetInputMuted) == 0x000001, "Wrong size on SweetChatSubsystem_SetInputMuted");
static_assert(offsetof(SweetChatSubsystem_SetInputMuted, bMuted) == 0x000000, "Member 'SweetChatSubsystem_SetInputMuted::bMuted' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.SetInputVolume
// 0x0004 (0x0004 - 0x0000)
struct SweetChatSubsystem_SetInputVolume final
{
public:
	float                                         Volume;                                            // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_SetInputVolume) == 0x000004, "Wrong alignment on SweetChatSubsystem_SetInputVolume");
static_assert(sizeof(SweetChatSubsystem_SetInputVolume) == 0x000004, "Wrong size on SweetChatSubsystem_SetInputVolume");
static_assert(offsetof(SweetChatSubsystem_SetInputVolume, Volume) == 0x000000, "Member 'SweetChatSubsystem_SetInputVolume::Volume' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.SetLocalVoiceActivationThreshold
// 0x0004 (0x0004 - 0x0000)
struct SweetChatSubsystem_SetLocalVoiceActivationThreshold final
{
public:
	float                                         FNormalizedThreshold;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_SetLocalVoiceActivationThreshold) == 0x000004, "Wrong alignment on SweetChatSubsystem_SetLocalVoiceActivationThreshold");
static_assert(sizeof(SweetChatSubsystem_SetLocalVoiceActivationThreshold) == 0x000004, "Wrong size on SweetChatSubsystem_SetLocalVoiceActivationThreshold");
static_assert(offsetof(SweetChatSubsystem_SetLocalVoiceActivationThreshold, FNormalizedThreshold) == 0x000000, "Member 'SweetChatSubsystem_SetLocalVoiceActivationThreshold::FNormalizedThreshold' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.SetOutputMuted
// 0x0001 (0x0001 - 0x0000)
struct SweetChatSubsystem_SetOutputMuted final
{
public:
	bool                                          bMuted;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_SetOutputMuted) == 0x000001, "Wrong alignment on SweetChatSubsystem_SetOutputMuted");
static_assert(sizeof(SweetChatSubsystem_SetOutputMuted) == 0x000001, "Wrong size on SweetChatSubsystem_SetOutputMuted");
static_assert(offsetof(SweetChatSubsystem_SetOutputMuted, bMuted) == 0x000000, "Member 'SweetChatSubsystem_SetOutputMuted::bMuted' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.SetOutputVolume
// 0x0004 (0x0004 - 0x0000)
struct SweetChatSubsystem_SetOutputVolume final
{
public:
	float                                         Volume;                                            // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_SetOutputVolume) == 0x000004, "Wrong alignment on SweetChatSubsystem_SetOutputVolume");
static_assert(sizeof(SweetChatSubsystem_SetOutputVolume) == 0x000004, "Wrong size on SweetChatSubsystem_SetOutputVolume");
static_assert(offsetof(SweetChatSubsystem_SetOutputVolume, Volume) == 0x000000, "Member 'SweetChatSubsystem_SetOutputVolume::Volume' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.SetPlayerMuted
// 0x0018 (0x0018 - 0x0000)
struct SweetChatSubsystem_SetPlayerMuted final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAudioMuted;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SweetChatSubsystem_SetPlayerMuted) == 0x000008, "Wrong alignment on SweetChatSubsystem_SetPlayerMuted");
static_assert(sizeof(SweetChatSubsystem_SetPlayerMuted) == 0x000018, "Wrong size on SweetChatSubsystem_SetPlayerMuted");
static_assert(offsetof(SweetChatSubsystem_SetPlayerMuted, PlayerName) == 0x000000, "Member 'SweetChatSubsystem_SetPlayerMuted::PlayerName' has a wrong offset!");
static_assert(offsetof(SweetChatSubsystem_SetPlayerMuted, bAudioMuted) == 0x000010, "Member 'SweetChatSubsystem_SetPlayerMuted::bAudioMuted' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.SetPlayerVolume
// 0x0018 (0x0018 - 0x0000)
struct SweetChatSubsystem_SetPlayerVolume final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SweetChatSubsystem_SetPlayerVolume) == 0x000008, "Wrong alignment on SweetChatSubsystem_SetPlayerVolume");
static_assert(sizeof(SweetChatSubsystem_SetPlayerVolume) == 0x000018, "Wrong size on SweetChatSubsystem_SetPlayerVolume");
static_assert(offsetof(SweetChatSubsystem_SetPlayerVolume, PlayerName) == 0x000000, "Member 'SweetChatSubsystem_SetPlayerVolume::PlayerName' has a wrong offset!");
static_assert(offsetof(SweetChatSubsystem_SetPlayerVolume, Volume) == 0x000010, "Member 'SweetChatSubsystem_SetPlayerVolume::Volume' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.SetTransmitMode
// 0x0001 (0x0001 - 0x0000)
struct SweetChatSubsystem_SetTransmitMode final
{
public:
	EPlayerVoiceChatTransmitMode                  TransmitMode;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_SetTransmitMode) == 0x000001, "Wrong alignment on SweetChatSubsystem_SetTransmitMode");
static_assert(sizeof(SweetChatSubsystem_SetTransmitMode) == 0x000001, "Wrong size on SweetChatSubsystem_SetTransmitMode");
static_assert(offsetof(SweetChatSubsystem_SetTransmitMode, TransmitMode) == 0x000000, "Member 'SweetChatSubsystem_SetTransmitMode::TransmitMode' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.GetInputMuted
// 0x0001 (0x0001 - 0x0000)
struct SweetChatSubsystem_GetInputMuted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_GetInputMuted) == 0x000001, "Wrong alignment on SweetChatSubsystem_GetInputMuted");
static_assert(sizeof(SweetChatSubsystem_GetInputMuted) == 0x000001, "Wrong size on SweetChatSubsystem_GetInputMuted");
static_assert(offsetof(SweetChatSubsystem_GetInputMuted, ReturnValue) == 0x000000, "Member 'SweetChatSubsystem_GetInputMuted::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.GetInputVolume
// 0x0004 (0x0004 - 0x0000)
struct SweetChatSubsystem_GetInputVolume final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_GetInputVolume) == 0x000004, "Wrong alignment on SweetChatSubsystem_GetInputVolume");
static_assert(sizeof(SweetChatSubsystem_GetInputVolume) == 0x000004, "Wrong size on SweetChatSubsystem_GetInputVolume");
static_assert(offsetof(SweetChatSubsystem_GetInputVolume, ReturnValue) == 0x000000, "Member 'SweetChatSubsystem_GetInputVolume::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.GetJoinedChannels
// 0x0010 (0x0010 - 0x0000)
struct SweetChatSubsystem_GetJoinedChannels final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_GetJoinedChannels) == 0x000008, "Wrong alignment on SweetChatSubsystem_GetJoinedChannels");
static_assert(sizeof(SweetChatSubsystem_GetJoinedChannels) == 0x000010, "Wrong size on SweetChatSubsystem_GetJoinedChannels");
static_assert(offsetof(SweetChatSubsystem_GetJoinedChannels, ReturnValue) == 0x000000, "Member 'SweetChatSubsystem_GetJoinedChannels::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.GetLocalVoiceActivationThreshold
// 0x0004 (0x0004 - 0x0000)
struct SweetChatSubsystem_GetLocalVoiceActivationThreshold final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_GetLocalVoiceActivationThreshold) == 0x000004, "Wrong alignment on SweetChatSubsystem_GetLocalVoiceActivationThreshold");
static_assert(sizeof(SweetChatSubsystem_GetLocalVoiceActivationThreshold) == 0x000004, "Wrong size on SweetChatSubsystem_GetLocalVoiceActivationThreshold");
static_assert(offsetof(SweetChatSubsystem_GetLocalVoiceActivationThreshold, ReturnValue) == 0x000000, "Member 'SweetChatSubsystem_GetLocalVoiceActivationThreshold::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.GetLoggedInPlayerName
// 0x0010 (0x0010 - 0x0000)
struct SweetChatSubsystem_GetLoggedInPlayerName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_GetLoggedInPlayerName) == 0x000008, "Wrong alignment on SweetChatSubsystem_GetLoggedInPlayerName");
static_assert(sizeof(SweetChatSubsystem_GetLoggedInPlayerName) == 0x000010, "Wrong size on SweetChatSubsystem_GetLoggedInPlayerName");
static_assert(offsetof(SweetChatSubsystem_GetLoggedInPlayerName, ReturnValue) == 0x000000, "Member 'SweetChatSubsystem_GetLoggedInPlayerName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.GetOutputMuted
// 0x0001 (0x0001 - 0x0000)
struct SweetChatSubsystem_GetOutputMuted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_GetOutputMuted) == 0x000001, "Wrong alignment on SweetChatSubsystem_GetOutputMuted");
static_assert(sizeof(SweetChatSubsystem_GetOutputMuted) == 0x000001, "Wrong size on SweetChatSubsystem_GetOutputMuted");
static_assert(offsetof(SweetChatSubsystem_GetOutputMuted, ReturnValue) == 0x000000, "Member 'SweetChatSubsystem_GetOutputMuted::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.GetOutputVolume
// 0x0004 (0x0004 - 0x0000)
struct SweetChatSubsystem_GetOutputVolume final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_GetOutputVolume) == 0x000004, "Wrong alignment on SweetChatSubsystem_GetOutputVolume");
static_assert(sizeof(SweetChatSubsystem_GetOutputVolume) == 0x000004, "Wrong size on SweetChatSubsystem_GetOutputVolume");
static_assert(offsetof(SweetChatSubsystem_GetOutputVolume, ReturnValue) == 0x000000, "Member 'SweetChatSubsystem_GetOutputVolume::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.GetPlayersInChannel
// 0x0020 (0x0020 - 0x0000)
struct SweetChatSubsystem_GetPlayersInChannel final
{
public:
	class FString                                 ChannelName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_GetPlayersInChannel) == 0x000008, "Wrong alignment on SweetChatSubsystem_GetPlayersInChannel");
static_assert(sizeof(SweetChatSubsystem_GetPlayersInChannel) == 0x000020, "Wrong size on SweetChatSubsystem_GetPlayersInChannel");
static_assert(offsetof(SweetChatSubsystem_GetPlayersInChannel, ChannelName) == 0x000000, "Member 'SweetChatSubsystem_GetPlayersInChannel::ChannelName' has a wrong offset!");
static_assert(offsetof(SweetChatSubsystem_GetPlayersInChannel, ReturnValue) == 0x000010, "Member 'SweetChatSubsystem_GetPlayersInChannel::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.GetPlayerVolume
// 0x0018 (0x0018 - 0x0000)
struct SweetChatSubsystem_GetPlayerVolume final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SweetChatSubsystem_GetPlayerVolume) == 0x000008, "Wrong alignment on SweetChatSubsystem_GetPlayerVolume");
static_assert(sizeof(SweetChatSubsystem_GetPlayerVolume) == 0x000018, "Wrong size on SweetChatSubsystem_GetPlayerVolume");
static_assert(offsetof(SweetChatSubsystem_GetPlayerVolume, PlayerName) == 0x000000, "Member 'SweetChatSubsystem_GetPlayerVolume::PlayerName' has a wrong offset!");
static_assert(offsetof(SweetChatSubsystem_GetPlayerVolume, ReturnValue) == 0x000010, "Member 'SweetChatSubsystem_GetPlayerVolume::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.GetTransmitMode
// 0x0001 (0x0001 - 0x0000)
struct SweetChatSubsystem_GetTransmitMode final
{
public:
	EPlayerVoiceChatTransmitMode                  ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_GetTransmitMode) == 0x000001, "Wrong alignment on SweetChatSubsystem_GetTransmitMode");
static_assert(sizeof(SweetChatSubsystem_GetTransmitMode) == 0x000001, "Wrong size on SweetChatSubsystem_GetTransmitMode");
static_assert(offsetof(SweetChatSubsystem_GetTransmitMode, ReturnValue) == 0x000000, "Member 'SweetChatSubsystem_GetTransmitMode::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.IsLocalPlayerTalking
// 0x0001 (0x0001 - 0x0000)
struct SweetChatSubsystem_IsLocalPlayerTalking final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetChatSubsystem_IsLocalPlayerTalking) == 0x000001, "Wrong alignment on SweetChatSubsystem_IsLocalPlayerTalking");
static_assert(sizeof(SweetChatSubsystem_IsLocalPlayerTalking) == 0x000001, "Wrong size on SweetChatSubsystem_IsLocalPlayerTalking");
static_assert(offsetof(SweetChatSubsystem_IsLocalPlayerTalking, ReturnValue) == 0x000000, "Member 'SweetChatSubsystem_IsLocalPlayerTalking::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.IsPlayerMuted
// 0x0018 (0x0018 - 0x0000)
struct SweetChatSubsystem_IsPlayerMuted final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SweetChatSubsystem_IsPlayerMuted) == 0x000008, "Wrong alignment on SweetChatSubsystem_IsPlayerMuted");
static_assert(sizeof(SweetChatSubsystem_IsPlayerMuted) == 0x000018, "Wrong size on SweetChatSubsystem_IsPlayerMuted");
static_assert(offsetof(SweetChatSubsystem_IsPlayerMuted, PlayerName) == 0x000000, "Member 'SweetChatSubsystem_IsPlayerMuted::PlayerName' has a wrong offset!");
static_assert(offsetof(SweetChatSubsystem_IsPlayerMuted, ReturnValue) == 0x000010, "Member 'SweetChatSubsystem_IsPlayerMuted::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetChatSubsystem.IsPlayerTalking
// 0x0018 (0x0018 - 0x0000)
struct SweetChatSubsystem_IsPlayerTalking final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SweetChatSubsystem_IsPlayerTalking) == 0x000008, "Wrong alignment on SweetChatSubsystem_IsPlayerTalking");
static_assert(sizeof(SweetChatSubsystem_IsPlayerTalking) == 0x000018, "Wrong size on SweetChatSubsystem_IsPlayerTalking");
static_assert(offsetof(SweetChatSubsystem_IsPlayerTalking, PlayerName) == 0x000000, "Member 'SweetChatSubsystem_IsPlayerTalking::PlayerName' has a wrong offset!");
static_assert(offsetof(SweetChatSubsystem_IsPlayerTalking, ReturnValue) == 0x000010, "Member 'SweetChatSubsystem_IsPlayerTalking::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetMathBlueprintLibrary.GetClampedRatio
// 0x0010 (0x0010 - 0x0000)
struct SweetMathBlueprintLibrary_GetClampedRatio final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetMathBlueprintLibrary_GetClampedRatio) == 0x000004, "Wrong alignment on SweetMathBlueprintLibrary_GetClampedRatio");
static_assert(sizeof(SweetMathBlueprintLibrary_GetClampedRatio) == 0x000010, "Wrong size on SweetMathBlueprintLibrary_GetClampedRatio");
static_assert(offsetof(SweetMathBlueprintLibrary_GetClampedRatio, Value) == 0x000000, "Member 'SweetMathBlueprintLibrary_GetClampedRatio::Value' has a wrong offset!");
static_assert(offsetof(SweetMathBlueprintLibrary_GetClampedRatio, Min) == 0x000004, "Member 'SweetMathBlueprintLibrary_GetClampedRatio::Min' has a wrong offset!");
static_assert(offsetof(SweetMathBlueprintLibrary_GetClampedRatio, Max) == 0x000008, "Member 'SweetMathBlueprintLibrary_GetClampedRatio::Max' has a wrong offset!");
static_assert(offsetof(SweetMathBlueprintLibrary_GetClampedRatio, ReturnValue) == 0x00000C, "Member 'SweetMathBlueprintLibrary_GetClampedRatio::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetMathBlueprintLibrary.GetRatio
// 0x0010 (0x0010 - 0x0000)
struct SweetMathBlueprintLibrary_GetRatio final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetMathBlueprintLibrary_GetRatio) == 0x000004, "Wrong alignment on SweetMathBlueprintLibrary_GetRatio");
static_assert(sizeof(SweetMathBlueprintLibrary_GetRatio) == 0x000010, "Wrong size on SweetMathBlueprintLibrary_GetRatio");
static_assert(offsetof(SweetMathBlueprintLibrary_GetRatio, Value) == 0x000000, "Member 'SweetMathBlueprintLibrary_GetRatio::Value' has a wrong offset!");
static_assert(offsetof(SweetMathBlueprintLibrary_GetRatio, Min) == 0x000004, "Member 'SweetMathBlueprintLibrary_GetRatio::Min' has a wrong offset!");
static_assert(offsetof(SweetMathBlueprintLibrary_GetRatio, Max) == 0x000008, "Member 'SweetMathBlueprintLibrary_GetRatio::Max' has a wrong offset!");
static_assert(offsetof(SweetMathBlueprintLibrary_GetRatio, ReturnValue) == 0x00000C, "Member 'SweetMathBlueprintLibrary_GetRatio::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetMathBlueprintLibrary.LerpColor
// 0x0010 (0x0010 - 0x0000)
struct SweetMathBlueprintLibrary_LerpColor final
{
public:
	struct FColor                                 A;                                                 // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 B;                                                 // 0x0004(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetMathBlueprintLibrary_LerpColor) == 0x000004, "Wrong alignment on SweetMathBlueprintLibrary_LerpColor");
static_assert(sizeof(SweetMathBlueprintLibrary_LerpColor) == 0x000010, "Wrong size on SweetMathBlueprintLibrary_LerpColor");
static_assert(offsetof(SweetMathBlueprintLibrary_LerpColor, A) == 0x000000, "Member 'SweetMathBlueprintLibrary_LerpColor::A' has a wrong offset!");
static_assert(offsetof(SweetMathBlueprintLibrary_LerpColor, B) == 0x000004, "Member 'SweetMathBlueprintLibrary_LerpColor::B' has a wrong offset!");
static_assert(offsetof(SweetMathBlueprintLibrary_LerpColor, Alpha) == 0x000008, "Member 'SweetMathBlueprintLibrary_LerpColor::Alpha' has a wrong offset!");
static_assert(offsetof(SweetMathBlueprintLibrary_LerpColor, ReturnValue) == 0x00000C, "Member 'SweetMathBlueprintLibrary_LerpColor::ReturnValue' has a wrong offset!");

// Function DeceiveInc.SweetMathBlueprintLibrary.RandRangeExcludingInteger
// 0x0010 (0x0010 - 0x0000)
struct SweetMathBlueprintLibrary_RandRangeExcludingInteger final
{
public:
	int32                                         Min;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Excluded;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SweetMathBlueprintLibrary_RandRangeExcludingInteger) == 0x000004, "Wrong alignment on SweetMathBlueprintLibrary_RandRangeExcludingInteger");
static_assert(sizeof(SweetMathBlueprintLibrary_RandRangeExcludingInteger) == 0x000010, "Wrong size on SweetMathBlueprintLibrary_RandRangeExcludingInteger");
static_assert(offsetof(SweetMathBlueprintLibrary_RandRangeExcludingInteger, Min) == 0x000000, "Member 'SweetMathBlueprintLibrary_RandRangeExcludingInteger::Min' has a wrong offset!");
static_assert(offsetof(SweetMathBlueprintLibrary_RandRangeExcludingInteger, Max) == 0x000004, "Member 'SweetMathBlueprintLibrary_RandRangeExcludingInteger::Max' has a wrong offset!");
static_assert(offsetof(SweetMathBlueprintLibrary_RandRangeExcludingInteger, Excluded) == 0x000008, "Member 'SweetMathBlueprintLibrary_RandRangeExcludingInteger::Excluded' has a wrong offset!");
static_assert(offsetof(SweetMathBlueprintLibrary_RandRangeExcludingInteger, ReturnValue) == 0x00000C, "Member 'SweetMathBlueprintLibrary_RandRangeExcludingInteger::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.AddActorToIgnoreList
// 0x0008 (0x0008 - 0x0000)
struct ToolLoadoutComponent_AddActorToIgnoreList final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_AddActorToIgnoreList) == 0x000008, "Wrong alignment on ToolLoadoutComponent_AddActorToIgnoreList");
static_assert(sizeof(ToolLoadoutComponent_AddActorToIgnoreList) == 0x000008, "Wrong size on ToolLoadoutComponent_AddActorToIgnoreList");
static_assert(offsetof(ToolLoadoutComponent_AddActorToIgnoreList, TargetActor) == 0x000000, "Member 'ToolLoadoutComponent_AddActorToIgnoreList::TargetActor' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.BP_OnActiveAbilityToolEvent
// 0x0001 (0x0001 - 0x0000)
struct ToolLoadoutComponent_BP_OnActiveAbilityToolEvent final
{
public:
	ESpyToolEvent                                 Event;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_BP_OnActiveAbilityToolEvent) == 0x000001, "Wrong alignment on ToolLoadoutComponent_BP_OnActiveAbilityToolEvent");
static_assert(sizeof(ToolLoadoutComponent_BP_OnActiveAbilityToolEvent) == 0x000001, "Wrong size on ToolLoadoutComponent_BP_OnActiveAbilityToolEvent");
static_assert(offsetof(ToolLoadoutComponent_BP_OnActiveAbilityToolEvent, Event) == 0x000000, "Member 'ToolLoadoutComponent_BP_OnActiveAbilityToolEvent::Event' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.BP_OnActiveHandToolEvent
// 0x0010 (0x0010 - 0x0000)
struct ToolLoadoutComponent_BP_OnActiveHandToolEvent final
{
public:
	ESpyToolEvent                                 Event;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSpyTool*                           SpyTool;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_BP_OnActiveHandToolEvent) == 0x000008, "Wrong alignment on ToolLoadoutComponent_BP_OnActiveHandToolEvent");
static_assert(sizeof(ToolLoadoutComponent_BP_OnActiveHandToolEvent) == 0x000010, "Wrong size on ToolLoadoutComponent_BP_OnActiveHandToolEvent");
static_assert(offsetof(ToolLoadoutComponent_BP_OnActiveHandToolEvent, Event) == 0x000000, "Member 'ToolLoadoutComponent_BP_OnActiveHandToolEvent::Event' has a wrong offset!");
static_assert(offsetof(ToolLoadoutComponent_BP_OnActiveHandToolEvent, SpyTool) == 0x000008, "Member 'ToolLoadoutComponent_BP_OnActiveHandToolEvent::SpyTool' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.BP_OnMeleeAttackEvent
// 0x0001 (0x0001 - 0x0000)
struct ToolLoadoutComponent_BP_OnMeleeAttackEvent final
{
public:
	ESpyMeleeAttackEvent                          Event;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_BP_OnMeleeAttackEvent) == 0x000001, "Wrong alignment on ToolLoadoutComponent_BP_OnMeleeAttackEvent");
static_assert(sizeof(ToolLoadoutComponent_BP_OnMeleeAttackEvent) == 0x000001, "Wrong size on ToolLoadoutComponent_BP_OnMeleeAttackEvent");
static_assert(offsetof(ToolLoadoutComponent_BP_OnMeleeAttackEvent, Event) == 0x000000, "Member 'ToolLoadoutComponent_BP_OnMeleeAttackEvent::Event' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.Client_SetCurrentSelectedSlot
// 0x0001 (0x0001 - 0x0000)
struct ToolLoadoutComponent_Client_SetCurrentSelectedSlot final
{
public:
	ELoadoutSlot                                  ServerSelectedSlot;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_Client_SetCurrentSelectedSlot) == 0x000001, "Wrong alignment on ToolLoadoutComponent_Client_SetCurrentSelectedSlot");
static_assert(sizeof(ToolLoadoutComponent_Client_SetCurrentSelectedSlot) == 0x000001, "Wrong size on ToolLoadoutComponent_Client_SetCurrentSelectedSlot");
static_assert(offsetof(ToolLoadoutComponent_Client_SetCurrentSelectedSlot, ServerSelectedSlot) == 0x000000, "Member 'ToolLoadoutComponent_Client_SetCurrentSelectedSlot::ServerSelectedSlot' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.Client_SetForcedGadgetSlot
// 0x0002 (0x0002 - 0x0000)
struct ToolLoadoutComponent_Client_SetForcedGadgetSlot final
{
public:
	ELoadoutSlot                                  ForcedToolSlot;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwitchToSlot;                                     // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_Client_SetForcedGadgetSlot) == 0x000001, "Wrong alignment on ToolLoadoutComponent_Client_SetForcedGadgetSlot");
static_assert(sizeof(ToolLoadoutComponent_Client_SetForcedGadgetSlot) == 0x000002, "Wrong size on ToolLoadoutComponent_Client_SetForcedGadgetSlot");
static_assert(offsetof(ToolLoadoutComponent_Client_SetForcedGadgetSlot, ForcedToolSlot) == 0x000000, "Member 'ToolLoadoutComponent_Client_SetForcedGadgetSlot::ForcedToolSlot' has a wrong offset!");
static_assert(offsetof(ToolLoadoutComponent_Client_SetForcedGadgetSlot, bSwitchToSlot) == 0x000001, "Member 'ToolLoadoutComponent_Client_SetForcedGadgetSlot::bSwitchToSlot' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.DisableForcedGadgetSlot
// 0x0001 (0x0001 - 0x0000)
struct ToolLoadoutComponent_DisableForcedGadgetSlot final
{
public:
	bool                                          bSwitchToSlot;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_DisableForcedGadgetSlot) == 0x000001, "Wrong alignment on ToolLoadoutComponent_DisableForcedGadgetSlot");
static_assert(sizeof(ToolLoadoutComponent_DisableForcedGadgetSlot) == 0x000001, "Wrong size on ToolLoadoutComponent_DisableForcedGadgetSlot");
static_assert(offsetof(ToolLoadoutComponent_DisableForcedGadgetSlot, bSwitchToSlot) == 0x000000, "Member 'ToolLoadoutComponent_DisableForcedGadgetSlot::bSwitchToSlot' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.EnableForcedGadgetSlot
// 0x0002 (0x0002 - 0x0000)
struct ToolLoadoutComponent_EnableForcedGadgetSlot final
{
public:
	ELoadoutSlot                                  ForcedSelection;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwitchToSlot;                                     // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_EnableForcedGadgetSlot) == 0x000001, "Wrong alignment on ToolLoadoutComponent_EnableForcedGadgetSlot");
static_assert(sizeof(ToolLoadoutComponent_EnableForcedGadgetSlot) == 0x000002, "Wrong size on ToolLoadoutComponent_EnableForcedGadgetSlot");
static_assert(offsetof(ToolLoadoutComponent_EnableForcedGadgetSlot, ForcedSelection) == 0x000000, "Member 'ToolLoadoutComponent_EnableForcedGadgetSlot::ForcedSelection' has a wrong offset!");
static_assert(offsetof(ToolLoadoutComponent_EnableForcedGadgetSlot, bSwitchToSlot) == 0x000001, "Member 'ToolLoadoutComponent_EnableForcedGadgetSlot::bSwitchToSlot' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.HandleActiveAbilityToolEvent
// 0x0010 (0x0010 - 0x0000)
struct ToolLoadoutComponent_HandleActiveAbilityToolEvent final
{
public:
	ESpyToolEvent                                 Event;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSpyTool*                           SpyTool;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_HandleActiveAbilityToolEvent) == 0x000008, "Wrong alignment on ToolLoadoutComponent_HandleActiveAbilityToolEvent");
static_assert(sizeof(ToolLoadoutComponent_HandleActiveAbilityToolEvent) == 0x000010, "Wrong size on ToolLoadoutComponent_HandleActiveAbilityToolEvent");
static_assert(offsetof(ToolLoadoutComponent_HandleActiveAbilityToolEvent, Event) == 0x000000, "Member 'ToolLoadoutComponent_HandleActiveAbilityToolEvent::Event' has a wrong offset!");
static_assert(offsetof(ToolLoadoutComponent_HandleActiveAbilityToolEvent, SpyTool) == 0x000008, "Member 'ToolLoadoutComponent_HandleActiveAbilityToolEvent::SpyTool' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.HandleActiveHandToolEvent
// 0x0010 (0x0010 - 0x0000)
struct ToolLoadoutComponent_HandleActiveHandToolEvent final
{
public:
	ESpyToolEvent                                 Event;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSpyTool*                           SpyTool;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_HandleActiveHandToolEvent) == 0x000008, "Wrong alignment on ToolLoadoutComponent_HandleActiveHandToolEvent");
static_assert(sizeof(ToolLoadoutComponent_HandleActiveHandToolEvent) == 0x000010, "Wrong size on ToolLoadoutComponent_HandleActiveHandToolEvent");
static_assert(offsetof(ToolLoadoutComponent_HandleActiveHandToolEvent, Event) == 0x000000, "Member 'ToolLoadoutComponent_HandleActiveHandToolEvent::Event' has a wrong offset!");
static_assert(offsetof(ToolLoadoutComponent_HandleActiveHandToolEvent, SpyTool) == 0x000008, "Member 'ToolLoadoutComponent_HandleActiveHandToolEvent::SpyTool' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.HandleMeleeAttackEvent
// 0x0010 (0x0010 - 0x0000)
struct ToolLoadoutComponent_HandleMeleeAttackEvent final
{
public:
	ESpyMeleeAttackEvent                          Event;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseMeleeAttack*                       MeleeAttack;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_HandleMeleeAttackEvent) == 0x000008, "Wrong alignment on ToolLoadoutComponent_HandleMeleeAttackEvent");
static_assert(sizeof(ToolLoadoutComponent_HandleMeleeAttackEvent) == 0x000010, "Wrong size on ToolLoadoutComponent_HandleMeleeAttackEvent");
static_assert(offsetof(ToolLoadoutComponent_HandleMeleeAttackEvent, Event) == 0x000000, "Member 'ToolLoadoutComponent_HandleMeleeAttackEvent::Event' has a wrong offset!");
static_assert(offsetof(ToolLoadoutComponent_HandleMeleeAttackEvent, MeleeAttack) == 0x000008, "Member 'ToolLoadoutComponent_HandleMeleeAttackEvent::MeleeAttack' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.IsLoadoutSpawnComplete
// 0x0001 (0x0001 - 0x0000)
struct ToolLoadoutComponent_IsLoadoutSpawnComplete final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_IsLoadoutSpawnComplete) == 0x000001, "Wrong alignment on ToolLoadoutComponent_IsLoadoutSpawnComplete");
static_assert(sizeof(ToolLoadoutComponent_IsLoadoutSpawnComplete) == 0x000001, "Wrong size on ToolLoadoutComponent_IsLoadoutSpawnComplete");
static_assert(offsetof(ToolLoadoutComponent_IsLoadoutSpawnComplete, ReturnValue) == 0x000000, "Member 'ToolLoadoutComponent_IsLoadoutSpawnComplete::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.OnRep_ActivePowerInstance
// 0x0008 (0x0008 - 0x0000)
struct ToolLoadoutComponent_OnRep_ActivePowerInstance final
{
public:
	class ABaseSpyActiveAbility*                  OldGadget;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_OnRep_ActivePowerInstance) == 0x000008, "Wrong alignment on ToolLoadoutComponent_OnRep_ActivePowerInstance");
static_assert(sizeof(ToolLoadoutComponent_OnRep_ActivePowerInstance) == 0x000008, "Wrong size on ToolLoadoutComponent_OnRep_ActivePowerInstance");
static_assert(offsetof(ToolLoadoutComponent_OnRep_ActivePowerInstance, OldGadget) == 0x000000, "Member 'ToolLoadoutComponent_OnRep_ActivePowerInstance::OldGadget' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.OnRep_CallingCardInstance
// 0x0008 (0x0008 - 0x0000)
struct ToolLoadoutComponent_OnRep_CallingCardInstance final
{
public:
	class ACallingCardPlaceableTool*              OldGadget;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_OnRep_CallingCardInstance) == 0x000008, "Wrong alignment on ToolLoadoutComponent_OnRep_CallingCardInstance");
static_assert(sizeof(ToolLoadoutComponent_OnRep_CallingCardInstance) == 0x000008, "Wrong size on ToolLoadoutComponent_OnRep_CallingCardInstance");
static_assert(offsetof(ToolLoadoutComponent_OnRep_CallingCardInstance, OldGadget) == 0x000000, "Member 'ToolLoadoutComponent_OnRep_CallingCardInstance::OldGadget' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.OnRep_CurrentSlot
// 0x0001 (0x0001 - 0x0000)
struct ToolLoadoutComponent_OnRep_CurrentSlot final
{
public:
	ELoadoutSlot                                  OldSelectedSlot;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_OnRep_CurrentSlot) == 0x000001, "Wrong alignment on ToolLoadoutComponent_OnRep_CurrentSlot");
static_assert(sizeof(ToolLoadoutComponent_OnRep_CurrentSlot) == 0x000001, "Wrong size on ToolLoadoutComponent_OnRep_CurrentSlot");
static_assert(offsetof(ToolLoadoutComponent_OnRep_CurrentSlot, OldSelectedSlot) == 0x000000, "Member 'ToolLoadoutComponent_OnRep_CurrentSlot::OldSelectedSlot' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.OnRep_MeleeAttackInstance
// 0x0008 (0x0008 - 0x0000)
struct ToolLoadoutComponent_OnRep_MeleeAttackInstance final
{
public:
	class ABaseMeleeAttack*                       OldGadget;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_OnRep_MeleeAttackInstance) == 0x000008, "Wrong alignment on ToolLoadoutComponent_OnRep_MeleeAttackInstance");
static_assert(sizeof(ToolLoadoutComponent_OnRep_MeleeAttackInstance) == 0x000008, "Wrong size on ToolLoadoutComponent_OnRep_MeleeAttackInstance");
static_assert(offsetof(ToolLoadoutComponent_OnRep_MeleeAttackInstance, OldGadget) == 0x000000, "Member 'ToolLoadoutComponent_OnRep_MeleeAttackInstance::OldGadget' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.OnRep_NavModeInstance
// 0x0008 (0x0008 - 0x0000)
struct ToolLoadoutComponent_OnRep_NavModeInstance final
{
public:
	class ABaseSpyTool*                           OldGadget;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_OnRep_NavModeInstance) == 0x000008, "Wrong alignment on ToolLoadoutComponent_OnRep_NavModeInstance");
static_assert(sizeof(ToolLoadoutComponent_OnRep_NavModeInstance) == 0x000008, "Wrong size on ToolLoadoutComponent_OnRep_NavModeInstance");
static_assert(offsetof(ToolLoadoutComponent_OnRep_NavModeInstance, OldGadget) == 0x000000, "Member 'ToolLoadoutComponent_OnRep_NavModeInstance::OldGadget' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.OnRep_PassivePowerInstance
// 0x0008 (0x0008 - 0x0000)
struct ToolLoadoutComponent_OnRep_PassivePowerInstance final
{
public:
	class ABaseSpyPassiveAbility*                 OldGadget;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_OnRep_PassivePowerInstance) == 0x000008, "Wrong alignment on ToolLoadoutComponent_OnRep_PassivePowerInstance");
static_assert(sizeof(ToolLoadoutComponent_OnRep_PassivePowerInstance) == 0x000008, "Wrong size on ToolLoadoutComponent_OnRep_PassivePowerInstance");
static_assert(offsetof(ToolLoadoutComponent_OnRep_PassivePowerInstance, OldGadget) == 0x000000, "Member 'ToolLoadoutComponent_OnRep_PassivePowerInstance::OldGadget' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.OnRep_SecondarySlotWeapon
// 0x0008 (0x0008 - 0x0000)
struct ToolLoadoutComponent_OnRep_SecondarySlotWeapon final
{
public:
	class ABaseSpyTool*                           OldWeapon;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_OnRep_SecondarySlotWeapon) == 0x000008, "Wrong alignment on ToolLoadoutComponent_OnRep_SecondarySlotWeapon");
static_assert(sizeof(ToolLoadoutComponent_OnRep_SecondarySlotWeapon) == 0x000008, "Wrong size on ToolLoadoutComponent_OnRep_SecondarySlotWeapon");
static_assert(offsetof(ToolLoadoutComponent_OnRep_SecondarySlotWeapon, OldWeapon) == 0x000000, "Member 'ToolLoadoutComponent_OnRep_SecondarySlotWeapon::OldWeapon' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.OnRep_SelectableSlotGadget1
// 0x0008 (0x0008 - 0x0000)
struct ToolLoadoutComponent_OnRep_SelectableSlotGadget1 final
{
public:
	class ABaseSpyTool*                           OldGadget;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_OnRep_SelectableSlotGadget1) == 0x000008, "Wrong alignment on ToolLoadoutComponent_OnRep_SelectableSlotGadget1");
static_assert(sizeof(ToolLoadoutComponent_OnRep_SelectableSlotGadget1) == 0x000008, "Wrong size on ToolLoadoutComponent_OnRep_SelectableSlotGadget1");
static_assert(offsetof(ToolLoadoutComponent_OnRep_SelectableSlotGadget1, OldGadget) == 0x000000, "Member 'ToolLoadoutComponent_OnRep_SelectableSlotGadget1::OldGadget' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.OnRep_SelectableSlotGadget2
// 0x0008 (0x0008 - 0x0000)
struct ToolLoadoutComponent_OnRep_SelectableSlotGadget2 final
{
public:
	class ABaseSpyTool*                           OldGadget;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_OnRep_SelectableSlotGadget2) == 0x000008, "Wrong alignment on ToolLoadoutComponent_OnRep_SelectableSlotGadget2");
static_assert(sizeof(ToolLoadoutComponent_OnRep_SelectableSlotGadget2) == 0x000008, "Wrong size on ToolLoadoutComponent_OnRep_SelectableSlotGadget2");
static_assert(offsetof(ToolLoadoutComponent_OnRep_SelectableSlotGadget2, OldGadget) == 0x000000, "Member 'ToolLoadoutComponent_OnRep_SelectableSlotGadget2::OldGadget' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.OnRep_SelectableSlotWeapon
// 0x0008 (0x0008 - 0x0000)
struct ToolLoadoutComponent_OnRep_SelectableSlotWeapon final
{
public:
	class ABaseSpyTool*                           OldWeapon;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_OnRep_SelectableSlotWeapon) == 0x000008, "Wrong alignment on ToolLoadoutComponent_OnRep_SelectableSlotWeapon");
static_assert(sizeof(ToolLoadoutComponent_OnRep_SelectableSlotWeapon) == 0x000008, "Wrong size on ToolLoadoutComponent_OnRep_SelectableSlotWeapon");
static_assert(offsetof(ToolLoadoutComponent_OnRep_SelectableSlotWeapon, OldWeapon) == 0x000000, "Member 'ToolLoadoutComponent_OnRep_SelectableSlotWeapon::OldWeapon' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.OnRep_TemporaryToolInstance
// 0x0008 (0x0008 - 0x0000)
struct ToolLoadoutComponent_OnRep_TemporaryToolInstance final
{
public:
	class ABaseSpyTool*                           OldTempTool;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_OnRep_TemporaryToolInstance) == 0x000008, "Wrong alignment on ToolLoadoutComponent_OnRep_TemporaryToolInstance");
static_assert(sizeof(ToolLoadoutComponent_OnRep_TemporaryToolInstance) == 0x000008, "Wrong size on ToolLoadoutComponent_OnRep_TemporaryToolInstance");
static_assert(offsetof(ToolLoadoutComponent_OnRep_TemporaryToolInstance, OldTempTool) == 0x000000, "Member 'ToolLoadoutComponent_OnRep_TemporaryToolInstance::OldTempTool' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.RemoveActorFromIgnoreList
// 0x0008 (0x0008 - 0x0000)
struct ToolLoadoutComponent_RemoveActorFromIgnoreList final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_RemoveActorFromIgnoreList) == 0x000008, "Wrong alignment on ToolLoadoutComponent_RemoveActorFromIgnoreList");
static_assert(sizeof(ToolLoadoutComponent_RemoveActorFromIgnoreList) == 0x000008, "Wrong size on ToolLoadoutComponent_RemoveActorFromIgnoreList");
static_assert(offsetof(ToolLoadoutComponent_RemoveActorFromIgnoreList, TargetActor) == 0x000000, "Member 'ToolLoadoutComponent_RemoveActorFromIgnoreList::TargetActor' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.SelectHandToolFromSlot
// 0x0003 (0x0003 - 0x0000)
struct ToolLoadoutComponent_SelectHandToolFromSlot final
{
public:
	ELoadoutSlot                                  ToolSlot;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromServer;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromOwner;                                        // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_SelectHandToolFromSlot) == 0x000001, "Wrong alignment on ToolLoadoutComponent_SelectHandToolFromSlot");
static_assert(sizeof(ToolLoadoutComponent_SelectHandToolFromSlot) == 0x000003, "Wrong size on ToolLoadoutComponent_SelectHandToolFromSlot");
static_assert(offsetof(ToolLoadoutComponent_SelectHandToolFromSlot, ToolSlot) == 0x000000, "Member 'ToolLoadoutComponent_SelectHandToolFromSlot::ToolSlot' has a wrong offset!");
static_assert(offsetof(ToolLoadoutComponent_SelectHandToolFromSlot, bFromServer) == 0x000001, "Member 'ToolLoadoutComponent_SelectHandToolFromSlot::bFromServer' has a wrong offset!");
static_assert(offsetof(ToolLoadoutComponent_SelectHandToolFromSlot, bFromOwner) == 0x000002, "Member 'ToolLoadoutComponent_SelectHandToolFromSlot::bFromOwner' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.Server_SelectHandToolFromSlot
// 0x0001 (0x0001 - 0x0000)
struct ToolLoadoutComponent_Server_SelectHandToolFromSlot final
{
public:
	ELoadoutSlot                                  ToolSlot;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_Server_SelectHandToolFromSlot) == 0x000001, "Wrong alignment on ToolLoadoutComponent_Server_SelectHandToolFromSlot");
static_assert(sizeof(ToolLoadoutComponent_Server_SelectHandToolFromSlot) == 0x000001, "Wrong size on ToolLoadoutComponent_Server_SelectHandToolFromSlot");
static_assert(offsetof(ToolLoadoutComponent_Server_SelectHandToolFromSlot, ToolSlot) == 0x000000, "Member 'ToolLoadoutComponent_Server_SelectHandToolFromSlot::ToolSlot' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.GetActivePower
// 0x0008 (0x0008 - 0x0000)
struct ToolLoadoutComponent_GetActivePower final
{
public:
	class ABaseSpyActiveAbility*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_GetActivePower) == 0x000008, "Wrong alignment on ToolLoadoutComponent_GetActivePower");
static_assert(sizeof(ToolLoadoutComponent_GetActivePower) == 0x000008, "Wrong size on ToolLoadoutComponent_GetActivePower");
static_assert(offsetof(ToolLoadoutComponent_GetActivePower, ReturnValue) == 0x000000, "Member 'ToolLoadoutComponent_GetActivePower::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.GetCallingCard
// 0x0008 (0x0008 - 0x0000)
struct ToolLoadoutComponent_GetCallingCard final
{
public:
	class ABaseSpyTool*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_GetCallingCard) == 0x000008, "Wrong alignment on ToolLoadoutComponent_GetCallingCard");
static_assert(sizeof(ToolLoadoutComponent_GetCallingCard) == 0x000008, "Wrong size on ToolLoadoutComponent_GetCallingCard");
static_assert(offsetof(ToolLoadoutComponent_GetCallingCard, ReturnValue) == 0x000000, "Member 'ToolLoadoutComponent_GetCallingCard::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.GetCallingCardTool
// 0x0008 (0x0008 - 0x0000)
struct ToolLoadoutComponent_GetCallingCardTool final
{
public:
	class ACallingCardPlaceableTool*              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_GetCallingCardTool) == 0x000008, "Wrong alignment on ToolLoadoutComponent_GetCallingCardTool");
static_assert(sizeof(ToolLoadoutComponent_GetCallingCardTool) == 0x000008, "Wrong size on ToolLoadoutComponent_GetCallingCardTool");
static_assert(offsetof(ToolLoadoutComponent_GetCallingCardTool, ReturnValue) == 0x000000, "Member 'ToolLoadoutComponent_GetCallingCardTool::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.GetCurrentHandTool
// 0x0008 (0x0008 - 0x0000)
struct ToolLoadoutComponent_GetCurrentHandTool final
{
public:
	class ABaseSpyTool*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_GetCurrentHandTool) == 0x000008, "Wrong alignment on ToolLoadoutComponent_GetCurrentHandTool");
static_assert(sizeof(ToolLoadoutComponent_GetCurrentHandTool) == 0x000008, "Wrong size on ToolLoadoutComponent_GetCurrentHandTool");
static_assert(offsetof(ToolLoadoutComponent_GetCurrentHandTool, ReturnValue) == 0x000000, "Member 'ToolLoadoutComponent_GetCurrentHandTool::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.GetCurrentHandToolSlot
// 0x0001 (0x0001 - 0x0000)
struct ToolLoadoutComponent_GetCurrentHandToolSlot final
{
public:
	ELoadoutSlot                                  ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_GetCurrentHandToolSlot) == 0x000001, "Wrong alignment on ToolLoadoutComponent_GetCurrentHandToolSlot");
static_assert(sizeof(ToolLoadoutComponent_GetCurrentHandToolSlot) == 0x000001, "Wrong size on ToolLoadoutComponent_GetCurrentHandToolSlot");
static_assert(offsetof(ToolLoadoutComponent_GetCurrentHandToolSlot, ReturnValue) == 0x000000, "Member 'ToolLoadoutComponent_GetCurrentHandToolSlot::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.GetHandToolInSlot
// 0x0010 (0x0010 - 0x0000)
struct ToolLoadoutComponent_GetHandToolInSlot final
{
public:
	ELoadoutSlot                                  ToolSlot;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSpyTool*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_GetHandToolInSlot) == 0x000008, "Wrong alignment on ToolLoadoutComponent_GetHandToolInSlot");
static_assert(sizeof(ToolLoadoutComponent_GetHandToolInSlot) == 0x000010, "Wrong size on ToolLoadoutComponent_GetHandToolInSlot");
static_assert(offsetof(ToolLoadoutComponent_GetHandToolInSlot, ToolSlot) == 0x000000, "Member 'ToolLoadoutComponent_GetHandToolInSlot::ToolSlot' has a wrong offset!");
static_assert(offsetof(ToolLoadoutComponent_GetHandToolInSlot, ReturnValue) == 0x000008, "Member 'ToolLoadoutComponent_GetHandToolInSlot::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.GetHandToolSlot
// 0x0010 (0x0010 - 0x0000)
struct ToolLoadoutComponent_GetHandToolSlot final
{
public:
	class ABaseSpyTool*                           HandTool;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELoadoutSlot                                  ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ToolLoadoutComponent_GetHandToolSlot) == 0x000008, "Wrong alignment on ToolLoadoutComponent_GetHandToolSlot");
static_assert(sizeof(ToolLoadoutComponent_GetHandToolSlot) == 0x000010, "Wrong size on ToolLoadoutComponent_GetHandToolSlot");
static_assert(offsetof(ToolLoadoutComponent_GetHandToolSlot, HandTool) == 0x000000, "Member 'ToolLoadoutComponent_GetHandToolSlot::HandTool' has a wrong offset!");
static_assert(offsetof(ToolLoadoutComponent_GetHandToolSlot, ReturnValue) == 0x000008, "Member 'ToolLoadoutComponent_GetHandToolSlot::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.GetMeleeAttack
// 0x0008 (0x0008 - 0x0000)
struct ToolLoadoutComponent_GetMeleeAttack final
{
public:
	class ABaseMeleeAttack*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_GetMeleeAttack) == 0x000008, "Wrong alignment on ToolLoadoutComponent_GetMeleeAttack");
static_assert(sizeof(ToolLoadoutComponent_GetMeleeAttack) == 0x000008, "Wrong size on ToolLoadoutComponent_GetMeleeAttack");
static_assert(offsetof(ToolLoadoutComponent_GetMeleeAttack, ReturnValue) == 0x000000, "Member 'ToolLoadoutComponent_GetMeleeAttack::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.GetNavModeTool
// 0x0008 (0x0008 - 0x0000)
struct ToolLoadoutComponent_GetNavModeTool final
{
public:
	class ABaseSpyTool*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_GetNavModeTool) == 0x000008, "Wrong alignment on ToolLoadoutComponent_GetNavModeTool");
static_assert(sizeof(ToolLoadoutComponent_GetNavModeTool) == 0x000008, "Wrong size on ToolLoadoutComponent_GetNavModeTool");
static_assert(offsetof(ToolLoadoutComponent_GetNavModeTool, ReturnValue) == 0x000000, "Member 'ToolLoadoutComponent_GetNavModeTool::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.GetPassivePower
// 0x0008 (0x0008 - 0x0000)
struct ToolLoadoutComponent_GetPassivePower final
{
public:
	class ABaseSpyPassiveAbility*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_GetPassivePower) == 0x000008, "Wrong alignment on ToolLoadoutComponent_GetPassivePower");
static_assert(sizeof(ToolLoadoutComponent_GetPassivePower) == 0x000008, "Wrong size on ToolLoadoutComponent_GetPassivePower");
static_assert(offsetof(ToolLoadoutComponent_GetPassivePower, ReturnValue) == 0x000000, "Member 'ToolLoadoutComponent_GetPassivePower::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.HasAuthority
// 0x0001 (0x0001 - 0x0000)
struct ToolLoadoutComponent_HasAuthority final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_HasAuthority) == 0x000001, "Wrong alignment on ToolLoadoutComponent_HasAuthority");
static_assert(sizeof(ToolLoadoutComponent_HasAuthority) == 0x000001, "Wrong size on ToolLoadoutComponent_HasAuthority");
static_assert(offsetof(ToolLoadoutComponent_HasAuthority, ReturnValue) == 0x000000, "Member 'ToolLoadoutComponent_HasAuthority::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.IsActorInIgnoreList
// 0x0010 (0x0010 - 0x0000)
struct ToolLoadoutComponent_IsActorInIgnoreList final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ToolLoadoutComponent_IsActorInIgnoreList) == 0x000008, "Wrong alignment on ToolLoadoutComponent_IsActorInIgnoreList");
static_assert(sizeof(ToolLoadoutComponent_IsActorInIgnoreList) == 0x000010, "Wrong size on ToolLoadoutComponent_IsActorInIgnoreList");
static_assert(offsetof(ToolLoadoutComponent_IsActorInIgnoreList, TargetActor) == 0x000000, "Member 'ToolLoadoutComponent_IsActorInIgnoreList::TargetActor' has a wrong offset!");
static_assert(offsetof(ToolLoadoutComponent_IsActorInIgnoreList, ReturnValue) == 0x000008, "Member 'ToolLoadoutComponent_IsActorInIgnoreList::ReturnValue' has a wrong offset!");

// Function DeceiveInc.ToolLoadoutComponent.IsLocallyControlled
// 0x0001 (0x0001 - 0x0000)
struct ToolLoadoutComponent_IsLocallyControlled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToolLoadoutComponent_IsLocallyControlled) == 0x000001, "Wrong alignment on ToolLoadoutComponent_IsLocallyControlled");
static_assert(sizeof(ToolLoadoutComponent_IsLocallyControlled) == 0x000001, "Wrong size on ToolLoadoutComponent_IsLocallyControlled");
static_assert(offsetof(ToolLoadoutComponent_IsLocallyControlled, ReturnValue) == 0x000000, "Member 'ToolLoadoutComponent_IsLocallyControlled::ReturnValue' has a wrong offset!");

// Function DeceiveInc.Tripwire.IsLinked
// 0x0001 (0x0001 - 0x0000)
struct Tripwire_IsLinked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Tripwire_IsLinked) == 0x000001, "Wrong alignment on Tripwire_IsLinked");
static_assert(sizeof(Tripwire_IsLinked) == 0x000001, "Wrong size on Tripwire_IsLinked");
static_assert(offsetof(Tripwire_IsLinked, ReturnValue) == 0x000000, "Member 'Tripwire_IsLinked::ReturnValue' has a wrong offset!");

// Function DeceiveInc.TripwireTool.BP_OnTripwireTriggered
// 0x0008 (0x0008 - 0x0000)
struct TripwireTool_BP_OnTripwireTriggered final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TripwireTool_BP_OnTripwireTriggered) == 0x000008, "Wrong alignment on TripwireTool_BP_OnTripwireTriggered");
static_assert(sizeof(TripwireTool_BP_OnTripwireTriggered) == 0x000008, "Wrong size on TripwireTool_BP_OnTripwireTriggered");
static_assert(offsetof(TripwireTool_BP_OnTripwireTriggered, Spy) == 0x000000, "Member 'TripwireTool_BP_OnTripwireTriggered::Spy' has a wrong offset!");

// Function DeceiveInc.TripwireTool.HandleTripwireDropDone
// 0x0020 (0x0020 - 0x0000)
struct TripwireTool_HandleTripwireDropDone final
{
public:
	class AActor*                                 ActorDropped;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndPos;                                            // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               EndRotation;                                       // 0x0014(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(TripwireTool_HandleTripwireDropDone) == 0x000008, "Wrong alignment on TripwireTool_HandleTripwireDropDone");
static_assert(sizeof(TripwireTool_HandleTripwireDropDone) == 0x000020, "Wrong size on TripwireTool_HandleTripwireDropDone");
static_assert(offsetof(TripwireTool_HandleTripwireDropDone, ActorDropped) == 0x000000, "Member 'TripwireTool_HandleTripwireDropDone::ActorDropped' has a wrong offset!");
static_assert(offsetof(TripwireTool_HandleTripwireDropDone, EndPos) == 0x000008, "Member 'TripwireTool_HandleTripwireDropDone::EndPos' has a wrong offset!");
static_assert(offsetof(TripwireTool_HandleTripwireDropDone, EndRotation) == 0x000014, "Member 'TripwireTool_HandleTripwireDropDone::EndRotation' has a wrong offset!");

// Function DeceiveInc.UnlockConditionComponent.OnNewBotPlayerController
// 0x0008 (0x0008 - 0x0000)
struct UnlockConditionComponent_OnNewBotPlayerController final
{
public:
	class ADeceiveIncPlayerBotController*         NewPlayerBot;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UnlockConditionComponent_OnNewBotPlayerController) == 0x000008, "Wrong alignment on UnlockConditionComponent_OnNewBotPlayerController");
static_assert(sizeof(UnlockConditionComponent_OnNewBotPlayerController) == 0x000008, "Wrong size on UnlockConditionComponent_OnNewBotPlayerController");
static_assert(offsetof(UnlockConditionComponent_OnNewBotPlayerController, NewPlayerBot) == 0x000000, "Member 'UnlockConditionComponent_OnNewBotPlayerController::NewPlayerBot' has a wrong offset!");

// Function DeceiveInc.UnlockConditionComponent.OnPlayerLogout
// 0x0008 (0x0008 - 0x0000)
struct UnlockConditionComponent_OnPlayerLogout final
{
public:
	class AController*                            ExitingController;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UnlockConditionComponent_OnPlayerLogout) == 0x000008, "Wrong alignment on UnlockConditionComponent_OnPlayerLogout");
static_assert(sizeof(UnlockConditionComponent_OnPlayerLogout) == 0x000008, "Wrong size on UnlockConditionComponent_OnPlayerLogout");
static_assert(offsetof(UnlockConditionComponent_OnPlayerLogout, ExitingController) == 0x000000, "Member 'UnlockConditionComponent_OnPlayerLogout::ExitingController' has a wrong offset!");

// Function DeceiveInc.UnlockConditionComponent.OnPlayerPostLogin
// 0x0008 (0x0008 - 0x0000)
struct UnlockConditionComponent_OnPlayerPostLogin final
{
public:
	class APlayerController*                      NewPlayer;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UnlockConditionComponent_OnPlayerPostLogin) == 0x000008, "Wrong alignment on UnlockConditionComponent_OnPlayerPostLogin");
static_assert(sizeof(UnlockConditionComponent_OnPlayerPostLogin) == 0x000008, "Wrong size on UnlockConditionComponent_OnPlayerPostLogin");
static_assert(offsetof(UnlockConditionComponent_OnPlayerPostLogin, NewPlayer) == 0x000000, "Member 'UnlockConditionComponent_OnPlayerPostLogin::NewPlayer' has a wrong offset!");

// Function DeceiveInc.UnlockConditionComponent.OnResourceSpent
// 0x0010 (0x0010 - 0x0000)
struct UnlockConditionComponent_OnResourceSpent final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayResourcesType                        ResourceType;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UnlockConditionComponent_OnResourceSpent) == 0x000008, "Wrong alignment on UnlockConditionComponent_OnResourceSpent");
static_assert(sizeof(UnlockConditionComponent_OnResourceSpent) == 0x000010, "Wrong size on UnlockConditionComponent_OnResourceSpent");
static_assert(offsetof(UnlockConditionComponent_OnResourceSpent, Interacter) == 0x000000, "Member 'UnlockConditionComponent_OnResourceSpent::Interacter' has a wrong offset!");
static_assert(offsetof(UnlockConditionComponent_OnResourceSpent, ResourceType) == 0x000008, "Member 'UnlockConditionComponent_OnResourceSpent::ResourceType' has a wrong offset!");
static_assert(offsetof(UnlockConditionComponent_OnResourceSpent, Amount) == 0x00000C, "Member 'UnlockConditionComponent_OnResourceSpent::Amount' has a wrong offset!");

// Function DeceiveInc.UnlockConditionComponent.GetPlayerIdFromActor
// 0x0010 (0x0010 - 0x0000)
struct UnlockConditionComponent_GetPlayerIdFromActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UnlockConditionComponent_GetPlayerIdFromActor) == 0x000008, "Wrong alignment on UnlockConditionComponent_GetPlayerIdFromActor");
static_assert(sizeof(UnlockConditionComponent_GetPlayerIdFromActor) == 0x000010, "Wrong size on UnlockConditionComponent_GetPlayerIdFromActor");
static_assert(offsetof(UnlockConditionComponent_GetPlayerIdFromActor, Actor) == 0x000000, "Member 'UnlockConditionComponent_GetPlayerIdFromActor::Actor' has a wrong offset!");
static_assert(offsetof(UnlockConditionComponent_GetPlayerIdFromActor, ReturnValue) == 0x000008, "Member 'UnlockConditionComponent_GetPlayerIdFromActor::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VictimEffectTickBehavior_Charm.OnServerSpyVictimUndercoverChange
// 0x0001 (0x0001 - 0x0000)
struct VictimEffectTickBehavior_Charm_OnServerSpyVictimUndercoverChange final
{
public:
	bool                                          bUndercover;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffectTickBehavior_Charm_OnServerSpyVictimUndercoverChange) == 0x000001, "Wrong alignment on VictimEffectTickBehavior_Charm_OnServerSpyVictimUndercoverChange");
static_assert(sizeof(VictimEffectTickBehavior_Charm_OnServerSpyVictimUndercoverChange) == 0x000001, "Wrong size on VictimEffectTickBehavior_Charm_OnServerSpyVictimUndercoverChange");
static_assert(offsetof(VictimEffectTickBehavior_Charm_OnServerSpyVictimUndercoverChange, bUndercover) == 0x000000, "Member 'VictimEffectTickBehavior_Charm_OnServerSpyVictimUndercoverChange::bUndercover' has a wrong offset!");

// Function DeceiveInc.VictimEffectTickBehavior_Poison.HandleInteractionComplete
// 0x0010 (0x0010 - 0x0000)
struct VictimEffectTickBehavior_Poison_HandleInteractionComplete final
{
public:
	class UInteracterComponent*                   Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffectTickBehavior_Poison_HandleInteractionComplete) == 0x000008, "Wrong alignment on VictimEffectTickBehavior_Poison_HandleInteractionComplete");
static_assert(sizeof(VictimEffectTickBehavior_Poison_HandleInteractionComplete) == 0x000010, "Wrong size on VictimEffectTickBehavior_Poison_HandleInteractionComplete");
static_assert(offsetof(VictimEffectTickBehavior_Poison_HandleInteractionComplete, Interacter) == 0x000000, "Member 'VictimEffectTickBehavior_Poison_HandleInteractionComplete::Interacter' has a wrong offset!");
static_assert(offsetof(VictimEffectTickBehavior_Poison_HandleInteractionComplete, Interactable) == 0x000008, "Member 'VictimEffectTickBehavior_Poison_HandleInteractionComplete::Interactable' has a wrong offset!");

// Function DeceiveInc.VictimEffectTickBehavior_Trace.OnTraceBegin
// 0x0010 (0x0010 - 0x0000)
struct VictimEffectTickBehavior_Trace_OnTraceBegin final
{
public:
	class UVictimEffectTickBehavior_Trace*        InTrace;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InTraceVictim;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffectTickBehavior_Trace_OnTraceBegin) == 0x000008, "Wrong alignment on VictimEffectTickBehavior_Trace_OnTraceBegin");
static_assert(sizeof(VictimEffectTickBehavior_Trace_OnTraceBegin) == 0x000010, "Wrong size on VictimEffectTickBehavior_Trace_OnTraceBegin");
static_assert(offsetof(VictimEffectTickBehavior_Trace_OnTraceBegin, InTrace) == 0x000000, "Member 'VictimEffectTickBehavior_Trace_OnTraceBegin::InTrace' has a wrong offset!");
static_assert(offsetof(VictimEffectTickBehavior_Trace_OnTraceBegin, InTraceVictim) == 0x000008, "Member 'VictimEffectTickBehavior_Trace_OnTraceBegin::InTraceVictim' has a wrong offset!");

// Function DeceiveInc.VictimEffectTickBehavior_Trace.OnTraceEnd
// 0x0010 (0x0010 - 0x0000)
struct VictimEffectTickBehavior_Trace_OnTraceEnd final
{
public:
	class UVictimEffectTickBehavior_Trace*        InTrace;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InTraceVictim;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffectTickBehavior_Trace_OnTraceEnd) == 0x000008, "Wrong alignment on VictimEffectTickBehavior_Trace_OnTraceEnd");
static_assert(sizeof(VictimEffectTickBehavior_Trace_OnTraceEnd) == 0x000010, "Wrong size on VictimEffectTickBehavior_Trace_OnTraceEnd");
static_assert(offsetof(VictimEffectTickBehavior_Trace_OnTraceEnd, InTrace) == 0x000000, "Member 'VictimEffectTickBehavior_Trace_OnTraceEnd::InTrace' has a wrong offset!");
static_assert(offsetof(VictimEffectTickBehavior_Trace_OnTraceEnd, InTraceVictim) == 0x000008, "Member 'VictimEffectTickBehavior_Trace_OnTraceEnd::InTraceVictim' has a wrong offset!");

// Function DeceiveInc.VictimEffectUserWidget.GetProgressRatio
// 0x0004 (0x0004 - 0x0000)
struct VictimEffectUserWidget_GetProgressRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffectUserWidget_GetProgressRatio) == 0x000004, "Wrong alignment on VictimEffectUserWidget_GetProgressRatio");
static_assert(sizeof(VictimEffectUserWidget_GetProgressRatio) == 0x000004, "Wrong size on VictimEffectUserWidget_GetProgressRatio");
static_assert(offsetof(VictimEffectUserWidget_GetProgressRatio, ReturnValue) == 0x000000, "Member 'VictimEffectUserWidget_GetProgressRatio::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VictimEffectUserWidget.GetProgressRatioInverted
// 0x0004 (0x0004 - 0x0000)
struct VictimEffectUserWidget_GetProgressRatioInverted final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffectUserWidget_GetProgressRatioInverted) == 0x000004, "Wrong alignment on VictimEffectUserWidget_GetProgressRatioInverted");
static_assert(sizeof(VictimEffectUserWidget_GetProgressRatioInverted) == 0x000004, "Wrong size on VictimEffectUserWidget_GetProgressRatioInverted");
static_assert(offsetof(VictimEffectUserWidget_GetProgressRatioInverted, ReturnValue) == 0x000000, "Member 'VictimEffectUserWidget_GetProgressRatioInverted::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VictimEffectUserWidget.HandleAddVictimEffect
// 0x0008 (0x0008 - 0x0000)
struct VictimEffectUserWidget_HandleAddVictimEffect final
{
public:
	class AVictimEffect*                          Effect;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffectUserWidget_HandleAddVictimEffect) == 0x000008, "Wrong alignment on VictimEffectUserWidget_HandleAddVictimEffect");
static_assert(sizeof(VictimEffectUserWidget_HandleAddVictimEffect) == 0x000008, "Wrong size on VictimEffectUserWidget_HandleAddVictimEffect");
static_assert(offsetof(VictimEffectUserWidget_HandleAddVictimEffect, Effect) == 0x000000, "Member 'VictimEffectUserWidget_HandleAddVictimEffect::Effect' has a wrong offset!");

// Function DeceiveInc.VictimEffectUserWidget.HandleRemoveVictimEffect
// 0x0008 (0x0008 - 0x0000)
struct VictimEffectUserWidget_HandleRemoveVictimEffect final
{
public:
	class AVictimEffect*                          Effect;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffectUserWidget_HandleRemoveVictimEffect) == 0x000008, "Wrong alignment on VictimEffectUserWidget_HandleRemoveVictimEffect");
static_assert(sizeof(VictimEffectUserWidget_HandleRemoveVictimEffect) == 0x000008, "Wrong size on VictimEffectUserWidget_HandleRemoveVictimEffect");
static_assert(offsetof(VictimEffectUserWidget_HandleRemoveVictimEffect, Effect) == 0x000000, "Member 'VictimEffectUserWidget_HandleRemoveVictimEffect::Effect' has a wrong offset!");

// Function DeceiveInc.VictimEffectUserWidget.SetupVictim
// 0x0008 (0x0008 - 0x0000)
struct VictimEffectUserWidget_SetupVictim final
{
public:
	class AVictimEffect*                          Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VictimEffectUserWidget_SetupVictim) == 0x000008, "Wrong alignment on VictimEffectUserWidget_SetupVictim");
static_assert(sizeof(VictimEffectUserWidget_SetupVictim) == 0x000008, "Wrong size on VictimEffectUserWidget_SetupVictim");
static_assert(offsetof(VictimEffectUserWidget_SetupVictim, Victim) == 0x000000, "Member 'VictimEffectUserWidget_SetupVictim::Victim' has a wrong offset!");

// Function DeceiveInc.VigilPassiveAbilityDeviceBased.HandleAbilityWeaponSpawned
// 0x0010 (0x0010 - 0x0000)
struct VigilPassiveAbilityDeviceBased_HandleAbilityWeaponSpawned final
{
public:
	class AVigilActiveAbility*                    Active;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AProjectileWeapon*                      Weapon;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VigilPassiveAbilityDeviceBased_HandleAbilityWeaponSpawned) == 0x000008, "Wrong alignment on VigilPassiveAbilityDeviceBased_HandleAbilityWeaponSpawned");
static_assert(sizeof(VigilPassiveAbilityDeviceBased_HandleAbilityWeaponSpawned) == 0x000010, "Wrong size on VigilPassiveAbilityDeviceBased_HandleAbilityWeaponSpawned");
static_assert(offsetof(VigilPassiveAbilityDeviceBased_HandleAbilityWeaponSpawned, Active) == 0x000000, "Member 'VigilPassiveAbilityDeviceBased_HandleAbilityWeaponSpawned::Active' has a wrong offset!");
static_assert(offsetof(VigilPassiveAbilityDeviceBased_HandleAbilityWeaponSpawned, Weapon) == 0x000008, "Member 'VigilPassiveAbilityDeviceBased_HandleAbilityWeaponSpawned::Weapon' has a wrong offset!");

// Function DeceiveInc.VigilPassiveAbilityDeviceBased.HandleADSChanged
// 0x0001 (0x0001 - 0x0000)
struct VigilPassiveAbilityDeviceBased_HandleADSChanged final
{
public:
	bool                                          bInADS;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VigilPassiveAbilityDeviceBased_HandleADSChanged) == 0x000001, "Wrong alignment on VigilPassiveAbilityDeviceBased_HandleADSChanged");
static_assert(sizeof(VigilPassiveAbilityDeviceBased_HandleADSChanged) == 0x000001, "Wrong size on VigilPassiveAbilityDeviceBased_HandleADSChanged");
static_assert(offsetof(VigilPassiveAbilityDeviceBased_HandleADSChanged, bInADS) == 0x000000, "Member 'VigilPassiveAbilityDeviceBased_HandleADSChanged::bInADS' has a wrong offset!");

// Function DeceiveInc.VigilPassiveAbilityDeviceBased.HandleDeviceDestroyed
// 0x0008 (0x0008 - 0x0000)
struct VigilPassiveAbilityDeviceBased_HandleDeviceDestroyed final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VigilPassiveAbilityDeviceBased_HandleDeviceDestroyed) == 0x000008, "Wrong alignment on VigilPassiveAbilityDeviceBased_HandleDeviceDestroyed");
static_assert(sizeof(VigilPassiveAbilityDeviceBased_HandleDeviceDestroyed) == 0x000008, "Wrong size on VigilPassiveAbilityDeviceBased_HandleDeviceDestroyed");
static_assert(offsetof(VigilPassiveAbilityDeviceBased_HandleDeviceDestroyed, DestroyedActor) == 0x000000, "Member 'VigilPassiveAbilityDeviceBased_HandleDeviceDestroyed::DestroyedActor' has a wrong offset!");

// Function DeceiveInc.VigilPassiveAbilityDeviceBased.HandleLoadoutSpawnCompleteEvent
// 0x0008 (0x0008 - 0x0000)
struct VigilPassiveAbilityDeviceBased_HandleLoadoutSpawnCompleteEvent final
{
public:
	class UToolLoadoutComponent*                  LoadoutComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VigilPassiveAbilityDeviceBased_HandleLoadoutSpawnCompleteEvent) == 0x000008, "Wrong alignment on VigilPassiveAbilityDeviceBased_HandleLoadoutSpawnCompleteEvent");
static_assert(sizeof(VigilPassiveAbilityDeviceBased_HandleLoadoutSpawnCompleteEvent) == 0x000008, "Wrong size on VigilPassiveAbilityDeviceBased_HandleLoadoutSpawnCompleteEvent");
static_assert(offsetof(VigilPassiveAbilityDeviceBased_HandleLoadoutSpawnCompleteEvent, LoadoutComponent) == 0x000000, "Member 'VigilPassiveAbilityDeviceBased_HandleLoadoutSpawnCompleteEvent::LoadoutComponent' has a wrong offset!");

// Function DeceiveInc.VigilPassiveAbilityDeviceBased.HandleMeleeSpyToolEvent
// 0x0010 (0x0010 - 0x0000)
struct VigilPassiveAbilityDeviceBased_HandleMeleeSpyToolEvent final
{
public:
	ESpyToolEvent                                 EventType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSpyTool*                           SpyTool;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VigilPassiveAbilityDeviceBased_HandleMeleeSpyToolEvent) == 0x000008, "Wrong alignment on VigilPassiveAbilityDeviceBased_HandleMeleeSpyToolEvent");
static_assert(sizeof(VigilPassiveAbilityDeviceBased_HandleMeleeSpyToolEvent) == 0x000010, "Wrong size on VigilPassiveAbilityDeviceBased_HandleMeleeSpyToolEvent");
static_assert(offsetof(VigilPassiveAbilityDeviceBased_HandleMeleeSpyToolEvent, EventType) == 0x000000, "Member 'VigilPassiveAbilityDeviceBased_HandleMeleeSpyToolEvent::EventType' has a wrong offset!");
static_assert(offsetof(VigilPassiveAbilityDeviceBased_HandleMeleeSpyToolEvent, SpyTool) == 0x000008, "Member 'VigilPassiveAbilityDeviceBased_HandleMeleeSpyToolEvent::SpyTool' has a wrong offset!");

// Function DeceiveInc.VigilPassiveAbilityDeviceBased.HandleSpyTransformInMimic
// 0x0010 (0x0010 - 0x0000)
struct VigilPassiveAbilityDeviceBased_HandleSpyTransformInMimic final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseMimicScannableActor*               Mimic;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VigilPassiveAbilityDeviceBased_HandleSpyTransformInMimic) == 0x000008, "Wrong alignment on VigilPassiveAbilityDeviceBased_HandleSpyTransformInMimic");
static_assert(sizeof(VigilPassiveAbilityDeviceBased_HandleSpyTransformInMimic) == 0x000010, "Wrong size on VigilPassiveAbilityDeviceBased_HandleSpyTransformInMimic");
static_assert(offsetof(VigilPassiveAbilityDeviceBased_HandleSpyTransformInMimic, Spy) == 0x000000, "Member 'VigilPassiveAbilityDeviceBased_HandleSpyTransformInMimic::Spy' has a wrong offset!");
static_assert(offsetof(VigilPassiveAbilityDeviceBased_HandleSpyTransformInMimic, Mimic) == 0x000008, "Member 'VigilPassiveAbilityDeviceBased_HandleSpyTransformInMimic::Mimic' has a wrong offset!");

// Function DeceiveInc.VigilPassiveAbilityDeviceBased.HandleVictimCoverChange
// 0x0001 (0x0001 - 0x0000)
struct VigilPassiveAbilityDeviceBased_HandleVictimCoverChange final
{
public:
	bool                                          bUndercover;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VigilPassiveAbilityDeviceBased_HandleVictimCoverChange) == 0x000001, "Wrong alignment on VigilPassiveAbilityDeviceBased_HandleVictimCoverChange");
static_assert(sizeof(VigilPassiveAbilityDeviceBased_HandleVictimCoverChange) == 0x000001, "Wrong size on VigilPassiveAbilityDeviceBased_HandleVictimCoverChange");
static_assert(offsetof(VigilPassiveAbilityDeviceBased_HandleVictimCoverChange, bUndercover) == 0x000000, "Member 'VigilPassiveAbilityDeviceBased_HandleVictimCoverChange::bUndercover' has a wrong offset!");

// Function DeceiveInc.VigilPassiveAbilityDeviceBased.HandleVictimCoverSwitch
// 0x0008 (0x0008 - 0x0000)
struct VigilPassiveAbilityDeviceBased_HandleVictimCoverSwitch final
{
public:
	class ANPCCharacter*                          NewDisguise;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VigilPassiveAbilityDeviceBased_HandleVictimCoverSwitch) == 0x000008, "Wrong alignment on VigilPassiveAbilityDeviceBased_HandleVictimCoverSwitch");
static_assert(sizeof(VigilPassiveAbilityDeviceBased_HandleVictimCoverSwitch) == 0x000008, "Wrong size on VigilPassiveAbilityDeviceBased_HandleVictimCoverSwitch");
static_assert(offsetof(VigilPassiveAbilityDeviceBased_HandleVictimCoverSwitch, NewDisguise) == 0x000000, "Member 'VigilPassiveAbilityDeviceBased_HandleVictimCoverSwitch::NewDisguise' has a wrong offset!");

// Function DeceiveInc.VigilPassiveAbilityDeviceBased.NetMulticast_FireDevice
// 0x0018 (0x0018 - 0x0000)
struct VigilPassiveAbilityDeviceBased_NetMulticast_FireDevice final
{
public:
	struct FVector_NetQuantize                    OriginPosition;                                    // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    DestinationPos;                                    // 0x000C(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VigilPassiveAbilityDeviceBased_NetMulticast_FireDevice) == 0x000004, "Wrong alignment on VigilPassiveAbilityDeviceBased_NetMulticast_FireDevice");
static_assert(sizeof(VigilPassiveAbilityDeviceBased_NetMulticast_FireDevice) == 0x000018, "Wrong size on VigilPassiveAbilityDeviceBased_NetMulticast_FireDevice");
static_assert(offsetof(VigilPassiveAbilityDeviceBased_NetMulticast_FireDevice, OriginPosition) == 0x000000, "Member 'VigilPassiveAbilityDeviceBased_NetMulticast_FireDevice::OriginPosition' has a wrong offset!");
static_assert(offsetof(VigilPassiveAbilityDeviceBased_NetMulticast_FireDevice, DestinationPos) == 0x00000C, "Member 'VigilPassiveAbilityDeviceBased_NetMulticast_FireDevice::DestinationPos' has a wrong offset!");

// Function DeceiveInc.VigilPassiveAbilityDeviceBased.NetMulticast_OnVictimAnnouncementEnd
// 0x0008 (0x0008 - 0x0000)
struct VigilPassiveAbilityDeviceBased_NetMulticast_OnVictimAnnouncementEnd final
{
public:
	class ASpy*                                   SpyVictim;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VigilPassiveAbilityDeviceBased_NetMulticast_OnVictimAnnouncementEnd) == 0x000008, "Wrong alignment on VigilPassiveAbilityDeviceBased_NetMulticast_OnVictimAnnouncementEnd");
static_assert(sizeof(VigilPassiveAbilityDeviceBased_NetMulticast_OnVictimAnnouncementEnd) == 0x000008, "Wrong size on VigilPassiveAbilityDeviceBased_NetMulticast_OnVictimAnnouncementEnd");
static_assert(offsetof(VigilPassiveAbilityDeviceBased_NetMulticast_OnVictimAnnouncementEnd, SpyVictim) == 0x000000, "Member 'VigilPassiveAbilityDeviceBased_NetMulticast_OnVictimAnnouncementEnd::SpyVictim' has a wrong offset!");

// Function DeceiveInc.VigilPassiveAbilityDeviceBased.NetMulticast_OnVictimAnnouncementStart
// 0x0008 (0x0008 - 0x0000)
struct VigilPassiveAbilityDeviceBased_NetMulticast_OnVictimAnnouncementStart final
{
public:
	class ASpy*                                   SpyVictim;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VigilPassiveAbilityDeviceBased_NetMulticast_OnVictimAnnouncementStart) == 0x000008, "Wrong alignment on VigilPassiveAbilityDeviceBased_NetMulticast_OnVictimAnnouncementStart");
static_assert(sizeof(VigilPassiveAbilityDeviceBased_NetMulticast_OnVictimAnnouncementStart) == 0x000008, "Wrong size on VigilPassiveAbilityDeviceBased_NetMulticast_OnVictimAnnouncementStart");
static_assert(offsetof(VigilPassiveAbilityDeviceBased_NetMulticast_OnVictimAnnouncementStart, SpyVictim) == 0x000000, "Member 'VigilPassiveAbilityDeviceBased_NetMulticast_OnVictimAnnouncementStart::SpyVictim' has a wrong offset!");

// Function DeceiveInc.VigilPassiveAbilityDeviceBased.OnRep_RealVictim
// 0x0008 (0x0008 - 0x0000)
struct VigilPassiveAbilityDeviceBased_OnRep_RealVictim final
{
public:
	class AActor*                                 OldRealVictim;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VigilPassiveAbilityDeviceBased_OnRep_RealVictim) == 0x000008, "Wrong alignment on VigilPassiveAbilityDeviceBased_OnRep_RealVictim");
static_assert(sizeof(VigilPassiveAbilityDeviceBased_OnRep_RealVictim) == 0x000008, "Wrong size on VigilPassiveAbilityDeviceBased_OnRep_RealVictim");
static_assert(offsetof(VigilPassiveAbilityDeviceBased_OnRep_RealVictim, OldRealVictim) == 0x000000, "Member 'VigilPassiveAbilityDeviceBased_OnRep_RealVictim::OldRealVictim' has a wrong offset!");

// Function DeceiveInc.VigilPassiveAbilityDeviceBased.OnThrowDelayTimerEnd
// 0x0001 (0x0001 - 0x0000)
struct VigilPassiveAbilityDeviceBased_OnThrowDelayTimerEnd final
{
public:
	bool                                          bIsLocal;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VigilPassiveAbilityDeviceBased_OnThrowDelayTimerEnd) == 0x000001, "Wrong alignment on VigilPassiveAbilityDeviceBased_OnThrowDelayTimerEnd");
static_assert(sizeof(VigilPassiveAbilityDeviceBased_OnThrowDelayTimerEnd) == 0x000001, "Wrong size on VigilPassiveAbilityDeviceBased_OnThrowDelayTimerEnd");
static_assert(offsetof(VigilPassiveAbilityDeviceBased_OnThrowDelayTimerEnd, bIsLocal) == 0x000000, "Member 'VigilPassiveAbilityDeviceBased_OnThrowDelayTimerEnd::bIsLocal' has a wrong offset!");

// Function DeceiveInc.VigilPassiveAbilityDeviceBased.Server_FireDevice
// 0x0018 (0x0018 - 0x0000)
struct VigilPassiveAbilityDeviceBased_Server_FireDevice final
{
public:
	struct FVector_NetQuantize                    OriginPosition;                                    // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    DestinationPos;                                    // 0x000C(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VigilPassiveAbilityDeviceBased_Server_FireDevice) == 0x000004, "Wrong alignment on VigilPassiveAbilityDeviceBased_Server_FireDevice");
static_assert(sizeof(VigilPassiveAbilityDeviceBased_Server_FireDevice) == 0x000018, "Wrong size on VigilPassiveAbilityDeviceBased_Server_FireDevice");
static_assert(offsetof(VigilPassiveAbilityDeviceBased_Server_FireDevice, OriginPosition) == 0x000000, "Member 'VigilPassiveAbilityDeviceBased_Server_FireDevice::OriginPosition' has a wrong offset!");
static_assert(offsetof(VigilPassiveAbilityDeviceBased_Server_FireDevice, DestinationPos) == 0x00000C, "Member 'VigilPassiveAbilityDeviceBased_Server_FireDevice::DestinationPos' has a wrong offset!");

// Function DeceiveInc.VigilPassiveAbilityDeviceBased.Server_SpawnDevice
// 0x0020 (0x0020 - 0x0000)
struct VigilPassiveAbilityDeviceBased_Server_SpawnDevice final
{
public:
	struct FVector_NetQuantize                    HitLocation;                                       // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    HitNormal;                                         // 0x000C(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ActorHit;                                          // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VigilPassiveAbilityDeviceBased_Server_SpawnDevice) == 0x000008, "Wrong alignment on VigilPassiveAbilityDeviceBased_Server_SpawnDevice");
static_assert(sizeof(VigilPassiveAbilityDeviceBased_Server_SpawnDevice) == 0x000020, "Wrong size on VigilPassiveAbilityDeviceBased_Server_SpawnDevice");
static_assert(offsetof(VigilPassiveAbilityDeviceBased_Server_SpawnDevice, HitLocation) == 0x000000, "Member 'VigilPassiveAbilityDeviceBased_Server_SpawnDevice::HitLocation' has a wrong offset!");
static_assert(offsetof(VigilPassiveAbilityDeviceBased_Server_SpawnDevice, HitNormal) == 0x00000C, "Member 'VigilPassiveAbilityDeviceBased_Server_SpawnDevice::HitNormal' has a wrong offset!");
static_assert(offsetof(VigilPassiveAbilityDeviceBased_Server_SpawnDevice, ActorHit) == 0x000018, "Member 'VigilPassiveAbilityDeviceBased_Server_SpawnDevice::ActorHit' has a wrong offset!");

// Function DeceiveInc.VoiceChatControlPanelEntryWidget.SetMuted
// 0x0001 (0x0001 - 0x0000)
struct VoiceChatControlPanelEntryWidget_SetMuted final
{
public:
	bool                                          bInMuted;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoiceChatControlPanelEntryWidget_SetMuted) == 0x000001, "Wrong alignment on VoiceChatControlPanelEntryWidget_SetMuted");
static_assert(sizeof(VoiceChatControlPanelEntryWidget_SetMuted) == 0x000001, "Wrong size on VoiceChatControlPanelEntryWidget_SetMuted");
static_assert(offsetof(VoiceChatControlPanelEntryWidget_SetMuted, bInMuted) == 0x000000, "Member 'VoiceChatControlPanelEntryWidget_SetMuted::bInMuted' has a wrong offset!");

// Function DeceiveInc.VoiceChatControlPanelEntryWidget.SetVolume
// 0x0004 (0x0004 - 0x0000)
struct VoiceChatControlPanelEntryWidget_SetVolume final
{
public:
	float                                         NewVolume;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoiceChatControlPanelEntryWidget_SetVolume) == 0x000004, "Wrong alignment on VoiceChatControlPanelEntryWidget_SetVolume");
static_assert(sizeof(VoiceChatControlPanelEntryWidget_SetVolume) == 0x000004, "Wrong size on VoiceChatControlPanelEntryWidget_SetVolume");
static_assert(offsetof(VoiceChatControlPanelEntryWidget_SetVolume, NewVolume) == 0x000000, "Member 'VoiceChatControlPanelEntryWidget_SetVolume::NewVolume' has a wrong offset!");

// Function DeceiveInc.VoiceChatControlPanelEntryWidget.GetVolume
// 0x0004 (0x0004 - 0x0000)
struct VoiceChatControlPanelEntryWidget_GetVolume final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoiceChatControlPanelEntryWidget_GetVolume) == 0x000004, "Wrong alignment on VoiceChatControlPanelEntryWidget_GetVolume");
static_assert(sizeof(VoiceChatControlPanelEntryWidget_GetVolume) == 0x000004, "Wrong size on VoiceChatControlPanelEntryWidget_GetVolume");
static_assert(offsetof(VoiceChatControlPanelEntryWidget_GetVolume, ReturnValue) == 0x000000, "Member 'VoiceChatControlPanelEntryWidget_GetVolume::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VoiceChatControlPanelEntryWidget.IsLocalPlayer
// 0x0001 (0x0001 - 0x0000)
struct VoiceChatControlPanelEntryWidget_IsLocalPlayer final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoiceChatControlPanelEntryWidget_IsLocalPlayer) == 0x000001, "Wrong alignment on VoiceChatControlPanelEntryWidget_IsLocalPlayer");
static_assert(sizeof(VoiceChatControlPanelEntryWidget_IsLocalPlayer) == 0x000001, "Wrong size on VoiceChatControlPanelEntryWidget_IsLocalPlayer");
static_assert(offsetof(VoiceChatControlPanelEntryWidget_IsLocalPlayer, ReturnValue) == 0x000000, "Member 'VoiceChatControlPanelEntryWidget_IsLocalPlayer::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VoiceChatControlPanelEntryWidget.IsMuted
// 0x0001 (0x0001 - 0x0000)
struct VoiceChatControlPanelEntryWidget_IsMuted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoiceChatControlPanelEntryWidget_IsMuted) == 0x000001, "Wrong alignment on VoiceChatControlPanelEntryWidget_IsMuted");
static_assert(sizeof(VoiceChatControlPanelEntryWidget_IsMuted) == 0x000001, "Wrong size on VoiceChatControlPanelEntryWidget_IsMuted");
static_assert(offsetof(VoiceChatControlPanelEntryWidget_IsMuted, ReturnValue) == 0x000000, "Member 'VoiceChatControlPanelEntryWidget_IsMuted::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VoicechatMemberWidget.GetIntendedVisibility
// 0x0001 (0x0001 - 0x0000)
struct VoicechatMemberWidget_GetIntendedVisibility final
{
public:
	ESlateVisibility                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoicechatMemberWidget_GetIntendedVisibility) == 0x000001, "Wrong alignment on VoicechatMemberWidget_GetIntendedVisibility");
static_assert(sizeof(VoicechatMemberWidget_GetIntendedVisibility) == 0x000001, "Wrong size on VoicechatMemberWidget_GetIntendedVisibility");
static_assert(offsetof(VoicechatMemberWidget_GetIntendedVisibility, ReturnValue) == 0x000000, "Member 'VoicechatMemberWidget_GetIntendedVisibility::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VoicechatMemberWidget.GetPlayerState
// 0x0008 (0x0008 - 0x0000)
struct VoicechatMemberWidget_GetPlayerState final
{
public:
	class ADIPlayerState*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoicechatMemberWidget_GetPlayerState) == 0x000008, "Wrong alignment on VoicechatMemberWidget_GetPlayerState");
static_assert(sizeof(VoicechatMemberWidget_GetPlayerState) == 0x000008, "Wrong size on VoicechatMemberWidget_GetPlayerState");
static_assert(offsetof(VoicechatMemberWidget_GetPlayerState, ReturnValue) == 0x000000, "Member 'VoicechatMemberWidget_GetPlayerState::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VoicechatMemberWidget.GetUserName
// 0x0010 (0x0010 - 0x0000)
struct VoicechatMemberWidget_GetUserName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoicechatMemberWidget_GetUserName) == 0x000008, "Wrong alignment on VoicechatMemberWidget_GetUserName");
static_assert(sizeof(VoicechatMemberWidget_GetUserName) == 0x000010, "Wrong size on VoicechatMemberWidget_GetUserName");
static_assert(offsetof(VoicechatMemberWidget_GetUserName, ReturnValue) == 0x000000, "Member 'VoicechatMemberWidget_GetUserName::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VoicechatMemberWidget.GetUserPlatform
// 0x0001 (0x0001 - 0x0000)
struct VoicechatMemberWidget_GetUserPlatform final
{
public:
	EPlatformType                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoicechatMemberWidget_GetUserPlatform) == 0x000001, "Wrong alignment on VoicechatMemberWidget_GetUserPlatform");
static_assert(sizeof(VoicechatMemberWidget_GetUserPlatform) == 0x000001, "Wrong size on VoicechatMemberWidget_GetUserPlatform");
static_assert(offsetof(VoicechatMemberWidget_GetUserPlatform, ReturnValue) == 0x000000, "Member 'VoicechatMemberWidget_GetUserPlatform::ReturnValue' has a wrong offset!");

// Function DeceiveInc.VoicechatMemberWidget.IsPlayerTalking
// 0x0001 (0x0001 - 0x0000)
struct VoicechatMemberWidget_IsPlayerTalking final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoicechatMemberWidget_IsPlayerTalking) == 0x000001, "Wrong alignment on VoicechatMemberWidget_IsPlayerTalking");
static_assert(sizeof(VoicechatMemberWidget_IsPlayerTalking) == 0x000001, "Wrong size on VoicechatMemberWidget_IsPlayerTalking");
static_assert(offsetof(VoicechatMemberWidget_IsPlayerTalking, ReturnValue) == 0x000000, "Member 'VoicechatMemberWidget_IsPlayerTalking::ReturnValue' has a wrong offset!");

// Function DeceiveInc.WeaponOverheatComponent.OnWeaponDisabledChange
// 0x0010 (0x0010 - 0x0000)
struct WeaponOverheatComponent_OnWeaponDisabledChange final
{
public:
	class AProjectileWeapon*                      Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisabled;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(WeaponOverheatComponent_OnWeaponDisabledChange) == 0x000008, "Wrong alignment on WeaponOverheatComponent_OnWeaponDisabledChange");
static_assert(sizeof(WeaponOverheatComponent_OnWeaponDisabledChange) == 0x000010, "Wrong size on WeaponOverheatComponent_OnWeaponDisabledChange");
static_assert(offsetof(WeaponOverheatComponent_OnWeaponDisabledChange, Weapon) == 0x000000, "Member 'WeaponOverheatComponent_OnWeaponDisabledChange::Weapon' has a wrong offset!");
static_assert(offsetof(WeaponOverheatComponent_OnWeaponDisabledChange, bDisabled) == 0x000008, "Member 'WeaponOverheatComponent_OnWeaponDisabledChange::bDisabled' has a wrong offset!");

// Function DeceiveInc.WeaponOverheatComponent.OnWeaponShot
// 0x0018 (0x0018 - 0x0000)
struct WeaponOverheatComponent_OnWeaponShot final
{
public:
	struct FVector                                ShotEndPoint;                                      // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AProjectileWeapon*                      Weapon;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponOverheatComponent_OnWeaponShot) == 0x000008, "Wrong alignment on WeaponOverheatComponent_OnWeaponShot");
static_assert(sizeof(WeaponOverheatComponent_OnWeaponShot) == 0x000018, "Wrong size on WeaponOverheatComponent_OnWeaponShot");
static_assert(offsetof(WeaponOverheatComponent_OnWeaponShot, ShotEndPoint) == 0x000000, "Member 'WeaponOverheatComponent_OnWeaponShot::ShotEndPoint' has a wrong offset!");
static_assert(offsetof(WeaponOverheatComponent_OnWeaponShot, Weapon) == 0x000010, "Member 'WeaponOverheatComponent_OnWeaponShot::Weapon' has a wrong offset!");

// Function DeceiveInc.WeaponOverheatComponent.GetCurWeaponHeat
// 0x0004 (0x0004 - 0x0000)
struct WeaponOverheatComponent_GetCurWeaponHeat final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponOverheatComponent_GetCurWeaponHeat) == 0x000004, "Wrong alignment on WeaponOverheatComponent_GetCurWeaponHeat");
static_assert(sizeof(WeaponOverheatComponent_GetCurWeaponHeat) == 0x000004, "Wrong size on WeaponOverheatComponent_GetCurWeaponHeat");
static_assert(offsetof(WeaponOverheatComponent_GetCurWeaponHeat, ReturnValue) == 0x000000, "Member 'WeaponOverheatComponent_GetCurWeaponHeat::ReturnValue' has a wrong offset!");

// Function DeceiveInc.XiuActiveAbility.BP_OnLocalNewXiuActiveTarget
// 0x0010 (0x0010 - 0x0000)
struct XiuActiveAbility_BP_OnLocalNewXiuActiveTarget final
{
public:
	class ANPCCharacter*                          PrevBestNPCTargetIn;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANPCCharacter*                          NewBestNPCTargetIn;                                // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XiuActiveAbility_BP_OnLocalNewXiuActiveTarget) == 0x000008, "Wrong alignment on XiuActiveAbility_BP_OnLocalNewXiuActiveTarget");
static_assert(sizeof(XiuActiveAbility_BP_OnLocalNewXiuActiveTarget) == 0x000010, "Wrong size on XiuActiveAbility_BP_OnLocalNewXiuActiveTarget");
static_assert(offsetof(XiuActiveAbility_BP_OnLocalNewXiuActiveTarget, PrevBestNPCTargetIn) == 0x000000, "Member 'XiuActiveAbility_BP_OnLocalNewXiuActiveTarget::PrevBestNPCTargetIn' has a wrong offset!");
static_assert(offsetof(XiuActiveAbility_BP_OnLocalNewXiuActiveTarget, NewBestNPCTargetIn) == 0x000008, "Member 'XiuActiveAbility_BP_OnLocalNewXiuActiveTarget::NewBestNPCTargetIn' has a wrong offset!");

// Function DeceiveInc.XiuActiveAbility.BP_OnLocalXiuActiveTargetSelected
// 0x0008 (0x0008 - 0x0000)
struct XiuActiveAbility_BP_OnLocalXiuActiveTargetSelected final
{
public:
	class ANPCCharacter*                          SelectedTarget;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XiuActiveAbility_BP_OnLocalXiuActiveTargetSelected) == 0x000008, "Wrong alignment on XiuActiveAbility_BP_OnLocalXiuActiveTargetSelected");
static_assert(sizeof(XiuActiveAbility_BP_OnLocalXiuActiveTargetSelected) == 0x000008, "Wrong size on XiuActiveAbility_BP_OnLocalXiuActiveTargetSelected");
static_assert(offsetof(XiuActiveAbility_BP_OnLocalXiuActiveTargetSelected, SelectedTarget) == 0x000000, "Member 'XiuActiveAbility_BP_OnLocalXiuActiveTargetSelected::SelectedTarget' has a wrong offset!");

// Function DeceiveInc.XiuActiveAbility.BP_OnLocalXiuTravelEnd
// 0x0008 (0x0008 - 0x0000)
struct XiuActiveAbility_BP_OnLocalXiuTravelEnd final
{
public:
	class ANPCCharacter*                          TarvelToNPC;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XiuActiveAbility_BP_OnLocalXiuTravelEnd) == 0x000008, "Wrong alignment on XiuActiveAbility_BP_OnLocalXiuTravelEnd");
static_assert(sizeof(XiuActiveAbility_BP_OnLocalXiuTravelEnd) == 0x000008, "Wrong size on XiuActiveAbility_BP_OnLocalXiuTravelEnd");
static_assert(offsetof(XiuActiveAbility_BP_OnLocalXiuTravelEnd, TarvelToNPC) == 0x000000, "Member 'XiuActiveAbility_BP_OnLocalXiuTravelEnd::TarvelToNPC' has a wrong offset!");

// Function DeceiveInc.XiuActiveAbility.BP_OnLocalXiuTravelStart
// 0x0008 (0x0008 - 0x0000)
struct XiuActiveAbility_BP_OnLocalXiuTravelStart final
{
public:
	class ANPCCharacter*                          TarvelToNPC;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XiuActiveAbility_BP_OnLocalXiuTravelStart) == 0x000008, "Wrong alignment on XiuActiveAbility_BP_OnLocalXiuTravelStart");
static_assert(sizeof(XiuActiveAbility_BP_OnLocalXiuTravelStart) == 0x000008, "Wrong size on XiuActiveAbility_BP_OnLocalXiuTravelStart");
static_assert(offsetof(XiuActiveAbility_BP_OnLocalXiuTravelStart, TarvelToNPC) == 0x000000, "Member 'XiuActiveAbility_BP_OnLocalXiuTravelStart::TarvelToNPC' has a wrong offset!");

// Function DeceiveInc.XiuActiveAbility.BP_OnXiuTravelStart
// 0x0010 (0x0010 - 0x0000)
struct XiuActiveAbility_BP_OnXiuTravelStart final
{
public:
	class ANPCCharacter*                          PrevNPC;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANPCCharacter*                          TarvelToNPC;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XiuActiveAbility_BP_OnXiuTravelStart) == 0x000008, "Wrong alignment on XiuActiveAbility_BP_OnXiuTravelStart");
static_assert(sizeof(XiuActiveAbility_BP_OnXiuTravelStart) == 0x000010, "Wrong size on XiuActiveAbility_BP_OnXiuTravelStart");
static_assert(offsetof(XiuActiveAbility_BP_OnXiuTravelStart, PrevNPC) == 0x000000, "Member 'XiuActiveAbility_BP_OnXiuTravelStart::PrevNPC' has a wrong offset!");
static_assert(offsetof(XiuActiveAbility_BP_OnXiuTravelStart, TarvelToNPC) == 0x000008, "Member 'XiuActiveAbility_BP_OnXiuTravelStart::TarvelToNPC' has a wrong offset!");

// Function DeceiveInc.XiuActiveAbility.NetMulticast_OnTravelStart
// 0x0010 (0x0010 - 0x0000)
struct XiuActiveAbility_NetMulticast_OnTravelStart final
{
public:
	class ANPCCharacter*                          PrevNPC;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANPCCharacter*                          TarvelToNPC;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XiuActiveAbility_NetMulticast_OnTravelStart) == 0x000008, "Wrong alignment on XiuActiveAbility_NetMulticast_OnTravelStart");
static_assert(sizeof(XiuActiveAbility_NetMulticast_OnTravelStart) == 0x000010, "Wrong size on XiuActiveAbility_NetMulticast_OnTravelStart");
static_assert(offsetof(XiuActiveAbility_NetMulticast_OnTravelStart, PrevNPC) == 0x000000, "Member 'XiuActiveAbility_NetMulticast_OnTravelStart::PrevNPC' has a wrong offset!");
static_assert(offsetof(XiuActiveAbility_NetMulticast_OnTravelStart, TarvelToNPC) == 0x000008, "Member 'XiuActiveAbility_NetMulticast_OnTravelStart::TarvelToNPC' has a wrong offset!");

// Function DeceiveInc.XiuActiveAbility.OnStoredTargetFellOutOfWorld
// 0x0008 (0x0008 - 0x0000)
struct XiuActiveAbility_OnStoredTargetFellOutOfWorld final
{
public:
	class ANPCCharacter*                          NPCThatFell;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XiuActiveAbility_OnStoredTargetFellOutOfWorld) == 0x000008, "Wrong alignment on XiuActiveAbility_OnStoredTargetFellOutOfWorld");
static_assert(sizeof(XiuActiveAbility_OnStoredTargetFellOutOfWorld) == 0x000008, "Wrong size on XiuActiveAbility_OnStoredTargetFellOutOfWorld");
static_assert(offsetof(XiuActiveAbility_OnStoredTargetFellOutOfWorld, NPCThatFell) == 0x000000, "Member 'XiuActiveAbility_OnStoredTargetFellOutOfWorld::NPCThatFell' has a wrong offset!");

// Function DeceiveInc.XiuActiveAbility.OnStoredTargetVisibilityChanged
// 0x0001 (0x0001 - 0x0000)
struct XiuActiveAbility_OnStoredTargetVisibilityChanged final
{
public:
	bool                                          bNewVisibility;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XiuActiveAbility_OnStoredTargetVisibilityChanged) == 0x000001, "Wrong alignment on XiuActiveAbility_OnStoredTargetVisibilityChanged");
static_assert(sizeof(XiuActiveAbility_OnStoredTargetVisibilityChanged) == 0x000001, "Wrong size on XiuActiveAbility_OnStoredTargetVisibilityChanged");
static_assert(offsetof(XiuActiveAbility_OnStoredTargetVisibilityChanged, bNewVisibility) == 0x000000, "Member 'XiuActiveAbility_OnStoredTargetVisibilityChanged::bNewVisibility' has a wrong offset!");

// Function DeceiveInc.XiuActiveAbility.Server_SetTarget
// 0x0008 (0x0008 - 0x0000)
struct XiuActiveAbility_Server_SetTarget final
{
public:
	class ANPCCharacter*                          NewTarget;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XiuActiveAbility_Server_SetTarget) == 0x000008, "Wrong alignment on XiuActiveAbility_Server_SetTarget");
static_assert(sizeof(XiuActiveAbility_Server_SetTarget) == 0x000008, "Wrong size on XiuActiveAbility_Server_SetTarget");
static_assert(offsetof(XiuActiveAbility_Server_SetTarget, NewTarget) == 0x000000, "Member 'XiuActiveAbility_Server_SetTarget::NewTarget' has a wrong offset!");

// Function DeceiveInc.XiuActiveAbility.Server_StartTravel
// 0x0008 (0x0008 - 0x0000)
struct XiuActiveAbility_Server_StartTravel final
{
public:
	class ANPCCharacter*                          TravelToTarget;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XiuActiveAbility_Server_StartTravel) == 0x000008, "Wrong alignment on XiuActiveAbility_Server_StartTravel");
static_assert(sizeof(XiuActiveAbility_Server_StartTravel) == 0x000008, "Wrong size on XiuActiveAbility_Server_StartTravel");
static_assert(offsetof(XiuActiveAbility_Server_StartTravel, TravelToTarget) == 0x000000, "Member 'XiuActiveAbility_Server_StartTravel::TravelToTarget' has a wrong offset!");

// Function DeceiveInc.XiuPassiveAbility.BP_OnCoverBlownDetected
// 0x000C (0x000C - 0x0000)
struct XiuPassiveAbility_BP_OnCoverBlownDetected final
{
public:
	struct FVector                                CoverBlownPosition;                                // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XiuPassiveAbility_BP_OnCoverBlownDetected) == 0x000004, "Wrong alignment on XiuPassiveAbility_BP_OnCoverBlownDetected");
static_assert(sizeof(XiuPassiveAbility_BP_OnCoverBlownDetected) == 0x00000C, "Wrong size on XiuPassiveAbility_BP_OnCoverBlownDetected");
static_assert(offsetof(XiuPassiveAbility_BP_OnCoverBlownDetected, CoverBlownPosition) == 0x000000, "Member 'XiuPassiveAbility_BP_OnCoverBlownDetected::CoverBlownPosition' has a wrong offset!");

// Function DeceiveInc.XiuPassiveAbility.ClientSignalCoverBlownAtLocation
// 0x000C (0x000C - 0x0000)
struct XiuPassiveAbility_ClientSignalCoverBlownAtLocation final
{
public:
	struct FVector_NetQuantize                    CoverBlownPosition;                                // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XiuPassiveAbility_ClientSignalCoverBlownAtLocation) == 0x000004, "Wrong alignment on XiuPassiveAbility_ClientSignalCoverBlownAtLocation");
static_assert(sizeof(XiuPassiveAbility_ClientSignalCoverBlownAtLocation) == 0x00000C, "Wrong size on XiuPassiveAbility_ClientSignalCoverBlownAtLocation");
static_assert(offsetof(XiuPassiveAbility_ClientSignalCoverBlownAtLocation, CoverBlownPosition) == 0x000000, "Member 'XiuPassiveAbility_ClientSignalCoverBlownAtLocation::CoverBlownPosition' has a wrong offset!");

// Function DeceiveInc.XiuPassiveAbility.HandleCoverBlownEvent
// 0x0008 (0x0008 - 0x0000)
struct XiuPassiveAbility_HandleCoverBlownEvent final
{
public:
	class ASpy*                                   Spy;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XiuPassiveAbility_HandleCoverBlownEvent) == 0x000008, "Wrong alignment on XiuPassiveAbility_HandleCoverBlownEvent");
static_assert(sizeof(XiuPassiveAbility_HandleCoverBlownEvent) == 0x000008, "Wrong size on XiuPassiveAbility_HandleCoverBlownEvent");
static_assert(offsetof(XiuPassiveAbility_HandleCoverBlownEvent, Spy) == 0x000000, "Member 'XiuPassiveAbility_HandleCoverBlownEvent::Spy' has a wrong offset!");

// Function DeceiveInc.XiuPassiveAbilityMod2.BP_ShowSpys
// 0x0010 (0x0010 - 0x0000)
struct XiuPassiveAbilityMod2_BP_ShowSpys final
{
public:
	TArray<class ASpy*>                           Spys;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(XiuPassiveAbilityMod2_BP_ShowSpys) == 0x000008, "Wrong alignment on XiuPassiveAbilityMod2_BP_ShowSpys");
static_assert(sizeof(XiuPassiveAbilityMod2_BP_ShowSpys) == 0x000010, "Wrong size on XiuPassiveAbilityMod2_BP_ShowSpys");
static_assert(offsetof(XiuPassiveAbilityMod2_BP_ShowSpys, Spys) == 0x000000, "Member 'XiuPassiveAbilityMod2_BP_ShowSpys::Spys' has a wrong offset!");

// Function DeceiveInc.XiuPassiveAbilityMod2.GetTimeToShowPing
// 0x0004 (0x0004 - 0x0000)
struct XiuPassiveAbilityMod2_GetTimeToShowPing final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XiuPassiveAbilityMod2_GetTimeToShowPing) == 0x000004, "Wrong alignment on XiuPassiveAbilityMod2_GetTimeToShowPing");
static_assert(sizeof(XiuPassiveAbilityMod2_GetTimeToShowPing) == 0x000004, "Wrong size on XiuPassiveAbilityMod2_GetTimeToShowPing");
static_assert(offsetof(XiuPassiveAbilityMod2_GetTimeToShowPing, ReturnValue) == 0x000000, "Member 'XiuPassiveAbilityMod2_GetTimeToShowPing::ReturnValue' has a wrong offset!");

// Function DeceiveInc.XiuPassiveAbilityMod2.HandleGamePhaseChanged
// 0x0001 (0x0001 - 0x0000)
struct XiuPassiveAbilityMod2_HandleGamePhaseChanged final
{
public:
	ESpyGamePhase                                 NewGamePhase;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XiuPassiveAbilityMod2_HandleGamePhaseChanged) == 0x000001, "Wrong alignment on XiuPassiveAbilityMod2_HandleGamePhaseChanged");
static_assert(sizeof(XiuPassiveAbilityMod2_HandleGamePhaseChanged) == 0x000001, "Wrong size on XiuPassiveAbilityMod2_HandleGamePhaseChanged");
static_assert(offsetof(XiuPassiveAbilityMod2_HandleGamePhaseChanged, NewGamePhase) == 0x000000, "Member 'XiuPassiveAbilityMod2_HandleGamePhaseChanged::NewGamePhase' has a wrong offset!");

// Function DeceiveInc.XiuPassiveAbilityMod2.HandleVaultTerminalDeactivation
// 0x0010 (0x0010 - 0x0000)
struct XiuPassiveAbilityMod2_HandleVaultTerminalDeactivation final
{
public:
	class ADIPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FactionID;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(XiuPassiveAbilityMod2_HandleVaultTerminalDeactivation) == 0x000008, "Wrong alignment on XiuPassiveAbilityMod2_HandleVaultTerminalDeactivation");
static_assert(sizeof(XiuPassiveAbilityMod2_HandleVaultTerminalDeactivation) == 0x000010, "Wrong size on XiuPassiveAbilityMod2_HandleVaultTerminalDeactivation");
static_assert(offsetof(XiuPassiveAbilityMod2_HandleVaultTerminalDeactivation, PlayerState) == 0x000000, "Member 'XiuPassiveAbilityMod2_HandleVaultTerminalDeactivation::PlayerState' has a wrong offset!");
static_assert(offsetof(XiuPassiveAbilityMod2_HandleVaultTerminalDeactivation, FactionID) == 0x000008, "Member 'XiuPassiveAbilityMod2_HandleVaultTerminalDeactivation::FactionID' has a wrong offset!");

// Function DeceiveInc.XiuPassiveAbilityMod2.HandleVaultTerminalUnlock
// 0x0004 (0x0004 - 0x0000)
struct XiuPassiveAbilityMod2_HandleVaultTerminalUnlock final
{
public:
	float                                         UnlockValue;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(XiuPassiveAbilityMod2_HandleVaultTerminalUnlock) == 0x000004, "Wrong alignment on XiuPassiveAbilityMod2_HandleVaultTerminalUnlock");
static_assert(sizeof(XiuPassiveAbilityMod2_HandleVaultTerminalUnlock) == 0x000004, "Wrong size on XiuPassiveAbilityMod2_HandleVaultTerminalUnlock");
static_assert(offsetof(XiuPassiveAbilityMod2_HandleVaultTerminalUnlock, UnlockValue) == 0x000000, "Member 'XiuPassiveAbilityMod2_HandleVaultTerminalUnlock::UnlockValue' has a wrong offset!");

// Function DeceiveInc.YumiActiveAbility.HandleProjectileReleased
// 0x0010 (0x0010 - 0x0000)
struct YumiActiveAbility_HandleProjectileReleased final
{
public:
	class ASpawnerWeapon*                         Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpawnerWeaponRound*                    Projectile;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(YumiActiveAbility_HandleProjectileReleased) == 0x000008, "Wrong alignment on YumiActiveAbility_HandleProjectileReleased");
static_assert(sizeof(YumiActiveAbility_HandleProjectileReleased) == 0x000010, "Wrong size on YumiActiveAbility_HandleProjectileReleased");
static_assert(offsetof(YumiActiveAbility_HandleProjectileReleased, Weapon) == 0x000000, "Member 'YumiActiveAbility_HandleProjectileReleased::Weapon' has a wrong offset!");
static_assert(offsetof(YumiActiveAbility_HandleProjectileReleased, Projectile) == 0x000008, "Member 'YumiActiveAbility_HandleProjectileReleased::Projectile' has a wrong offset!");

// Function DeceiveInc.YumiActiveAbility.HandleResourceAmountChanged
// 0x0004 (0x0004 - 0x0000)
struct YumiActiveAbility_HandleResourceAmountChanged final
{
public:
	int32                                         TotalBulletLeft;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(YumiActiveAbility_HandleResourceAmountChanged) == 0x000004, "Wrong alignment on YumiActiveAbility_HandleResourceAmountChanged");
static_assert(sizeof(YumiActiveAbility_HandleResourceAmountChanged) == 0x000004, "Wrong size on YumiActiveAbility_HandleResourceAmountChanged");
static_assert(offsetof(YumiActiveAbility_HandleResourceAmountChanged, TotalBulletLeft) == 0x000000, "Member 'YumiActiveAbility_HandleResourceAmountChanged::TotalBulletLeft' has a wrong offset!");

// Function DeceiveInc.YumiActiveAbility.OnLoadoutSpawnComplete
// 0x0008 (0x0008 - 0x0000)
struct YumiActiveAbility_OnLoadoutSpawnComplete final
{
public:
	class UToolLoadoutComponent*                  ToolLoadout;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(YumiActiveAbility_OnLoadoutSpawnComplete) == 0x000008, "Wrong alignment on YumiActiveAbility_OnLoadoutSpawnComplete");
static_assert(sizeof(YumiActiveAbility_OnLoadoutSpawnComplete) == 0x000008, "Wrong size on YumiActiveAbility_OnLoadoutSpawnComplete");
static_assert(offsetof(YumiActiveAbility_OnLoadoutSpawnComplete, ToolLoadout) == 0x000000, "Member 'YumiActiveAbility_OnLoadoutSpawnComplete::ToolLoadout' has a wrong offset!");

// Function DeceiveInc.YumiActiveAbility.OnResourceChanged
// 0x0028 (0x0028 - 0x0000)
struct YumiActiveAbility_OnResourceChanged final
{
public:
	EGameplayResourcesType                        ResourceType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ResourceDisplayName;                               // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(YumiActiveAbility_OnResourceChanged) == 0x000008, "Wrong alignment on YumiActiveAbility_OnResourceChanged");
static_assert(sizeof(YumiActiveAbility_OnResourceChanged) == 0x000028, "Wrong size on YumiActiveAbility_OnResourceChanged");
static_assert(offsetof(YumiActiveAbility_OnResourceChanged, ResourceType) == 0x000000, "Member 'YumiActiveAbility_OnResourceChanged::ResourceType' has a wrong offset!");
static_assert(offsetof(YumiActiveAbility_OnResourceChanged, ResourceDisplayName) == 0x000008, "Member 'YumiActiveAbility_OnResourceChanged::ResourceDisplayName' has a wrong offset!");
static_assert(offsetof(YumiActiveAbility_OnResourceChanged, Amount) == 0x000020, "Member 'YumiActiveAbility_OnResourceChanged::Amount' has a wrong offset!");

// Function DeceiveInc.YumiActiveAbility.TriggerEMPSphereEnd
// 0x0008 (0x0008 - 0x0000)
struct YumiActiveAbility_TriggerEMPSphereEnd final
{
public:
	class ABaseSphereActor*                       SphereActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(YumiActiveAbility_TriggerEMPSphereEnd) == 0x000008, "Wrong alignment on YumiActiveAbility_TriggerEMPSphereEnd");
static_assert(sizeof(YumiActiveAbility_TriggerEMPSphereEnd) == 0x000008, "Wrong size on YumiActiveAbility_TriggerEMPSphereEnd");
static_assert(offsetof(YumiActiveAbility_TriggerEMPSphereEnd, SphereActor) == 0x000000, "Member 'YumiActiveAbility_TriggerEMPSphereEnd::SphereActor' has a wrong offset!");

// Function DeceiveInc.YumiActiveAbility.TriggerEMPSphereStart
// 0x0008 (0x0008 - 0x0000)
struct YumiActiveAbility_TriggerEMPSphereStart final
{
public:
	class ABaseSphereActor*                       SphereActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(YumiActiveAbility_TriggerEMPSphereStart) == 0x000008, "Wrong alignment on YumiActiveAbility_TriggerEMPSphereStart");
static_assert(sizeof(YumiActiveAbility_TriggerEMPSphereStart) == 0x000008, "Wrong size on YumiActiveAbility_TriggerEMPSphereStart");
static_assert(offsetof(YumiActiveAbility_TriggerEMPSphereStart, SphereActor) == 0x000000, "Member 'YumiActiveAbility_TriggerEMPSphereStart::SphereActor' has a wrong offset!");

// Function DeceiveInc.YumiPassiveAbilityMod2.HandleHitConfirmed
// 0x0040 (0x0040 - 0x0000)
struct YumiPassiveAbilityMod2_HandleHitConfirmed final
{
public:
	struct FHitConfirmData                        HitConfirmData;                                    // 0x0000(0x0040)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(YumiPassiveAbilityMod2_HandleHitConfirmed) == 0x000008, "Wrong alignment on YumiPassiveAbilityMod2_HandleHitConfirmed");
static_assert(sizeof(YumiPassiveAbilityMod2_HandleHitConfirmed) == 0x000040, "Wrong size on YumiPassiveAbilityMod2_HandleHitConfirmed");
static_assert(offsetof(YumiPassiveAbilityMod2_HandleHitConfirmed, HitConfirmData) == 0x000000, "Member 'YumiPassiveAbilityMod2_HandleHitConfirmed::HitConfirmData' has a wrong offset!");

// Function DeceiveInc.YumiPassiveAbilityMod2.HandleMeleeDamageConfirmed
// 0x0068 (0x0068 - 0x0000)
struct YumiPassiveAbilityMod2_HandleMeleeDamageConfirmed final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPoint;                                       // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChargeLevel;                                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageDone;                                        // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultingHealthPercentage;                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitType                                      HitType;                                           // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMeleeHitConfirmedData                 HitConfirmedData;                                  // 0x0028(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(YumiPassiveAbilityMod2_HandleMeleeDamageConfirmed) == 0x000008, "Wrong alignment on YumiPassiveAbilityMod2_HandleMeleeDamageConfirmed");
static_assert(sizeof(YumiPassiveAbilityMod2_HandleMeleeDamageConfirmed) == 0x000068, "Wrong size on YumiPassiveAbilityMod2_HandleMeleeDamageConfirmed");
static_assert(offsetof(YumiPassiveAbilityMod2_HandleMeleeDamageConfirmed, Victim) == 0x000000, "Member 'YumiPassiveAbilityMod2_HandleMeleeDamageConfirmed::Victim' has a wrong offset!");
static_assert(offsetof(YumiPassiveAbilityMod2_HandleMeleeDamageConfirmed, ImpactPoint) == 0x000008, "Member 'YumiPassiveAbilityMod2_HandleMeleeDamageConfirmed::ImpactPoint' has a wrong offset!");
static_assert(offsetof(YumiPassiveAbilityMod2_HandleMeleeDamageConfirmed, ChargeLevel) == 0x000014, "Member 'YumiPassiveAbilityMod2_HandleMeleeDamageConfirmed::ChargeLevel' has a wrong offset!");
static_assert(offsetof(YumiPassiveAbilityMod2_HandleMeleeDamageConfirmed, DamageDone) == 0x000018, "Member 'YumiPassiveAbilityMod2_HandleMeleeDamageConfirmed::DamageDone' has a wrong offset!");
static_assert(offsetof(YumiPassiveAbilityMod2_HandleMeleeDamageConfirmed, ResultingHealthPercentage) == 0x00001C, "Member 'YumiPassiveAbilityMod2_HandleMeleeDamageConfirmed::ResultingHealthPercentage' has a wrong offset!");
static_assert(offsetof(YumiPassiveAbilityMod2_HandleMeleeDamageConfirmed, HitType) == 0x000020, "Member 'YumiPassiveAbilityMod2_HandleMeleeDamageConfirmed::HitType' has a wrong offset!");
static_assert(offsetof(YumiPassiveAbilityMod2_HandleMeleeDamageConfirmed, HitConfirmedData) == 0x000028, "Member 'YumiPassiveAbilityMod2_HandleMeleeDamageConfirmed::HitConfirmedData' has a wrong offset!");

// Function DeceiveInc.YumiPassiveAbilityMod2.HandleMiscToolSpawned
// 0x0008 (0x0008 - 0x0000)
struct YumiPassiveAbilityMod2_HandleMiscToolSpawned final
{
public:
	class AActor*                                 SpawnedTool;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(YumiPassiveAbilityMod2_HandleMiscToolSpawned) == 0x000008, "Wrong alignment on YumiPassiveAbilityMod2_HandleMiscToolSpawned");
static_assert(sizeof(YumiPassiveAbilityMod2_HandleMiscToolSpawned) == 0x000008, "Wrong size on YumiPassiveAbilityMod2_HandleMiscToolSpawned");
static_assert(offsetof(YumiPassiveAbilityMod2_HandleMiscToolSpawned, SpawnedTool) == 0x000000, "Member 'YumiPassiveAbilityMod2_HandleMiscToolSpawned::SpawnedTool' has a wrong offset!");

// Function DeceiveInc.YumiPassiveAbilityMod2.HandlePlaceableSpawned
// 0x0008 (0x0008 - 0x0000)
struct YumiPassiveAbilityMod2_HandlePlaceableSpawned final
{
public:
	class ABasePlaceable*                         NewPlaceable;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(YumiPassiveAbilityMod2_HandlePlaceableSpawned) == 0x000008, "Wrong alignment on YumiPassiveAbilityMod2_HandlePlaceableSpawned");
static_assert(sizeof(YumiPassiveAbilityMod2_HandlePlaceableSpawned) == 0x000008, "Wrong size on YumiPassiveAbilityMod2_HandlePlaceableSpawned");
static_assert(offsetof(YumiPassiveAbilityMod2_HandlePlaceableSpawned, NewPlaceable) == 0x000000, "Member 'YumiPassiveAbilityMod2_HandlePlaceableSpawned::NewPlaceable' has a wrong offset!");

// Function DeceiveInc.YumiPassiveAbilityMod2.HandleSpyToolLoadComplete
// 0x0008 (0x0008 - 0x0000)
struct YumiPassiveAbilityMod2_HandleSpyToolLoadComplete final
{
public:
	class UToolLoadoutComponent*                  ToolLoadout;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(YumiPassiveAbilityMod2_HandleSpyToolLoadComplete) == 0x000008, "Wrong alignment on YumiPassiveAbilityMod2_HandleSpyToolLoadComplete");
static_assert(sizeof(YumiPassiveAbilityMod2_HandleSpyToolLoadComplete) == 0x000008, "Wrong size on YumiPassiveAbilityMod2_HandleSpyToolLoadComplete");
static_assert(offsetof(YumiPassiveAbilityMod2_HandleSpyToolLoadComplete, ToolLoadout) == 0x000000, "Member 'YumiPassiveAbilityMod2_HandleSpyToolLoadComplete::ToolLoadout' has a wrong offset!");

// Function DeceiveInc.YumiPassiveAbilityMod2.OnPlaceableDeath
// 0x0008 (0x0008 - 0x0000)
struct YumiPassiveAbilityMod2_OnPlaceableDeath final
{
public:
	class AActor*                                 DeadActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(YumiPassiveAbilityMod2_OnPlaceableDeath) == 0x000008, "Wrong alignment on YumiPassiveAbilityMod2_OnPlaceableDeath");
static_assert(sizeof(YumiPassiveAbilityMod2_OnPlaceableDeath) == 0x000008, "Wrong size on YumiPassiveAbilityMod2_OnPlaceableDeath");
static_assert(offsetof(YumiPassiveAbilityMod2_OnPlaceableDeath, DeadActor) == 0x000000, "Member 'YumiPassiveAbilityMod2_OnPlaceableDeath::DeadActor' has a wrong offset!");

// Function DeceiveInc.ZoomComponent.AddZoomModifier
// 0x0010 (0x0010 - 0x0000)
struct ZoomComponent_AddZoomModifier final
{
public:
	class FName                                   ModifierName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomFactor;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationTime;                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZoomComponent_AddZoomModifier) == 0x000004, "Wrong alignment on ZoomComponent_AddZoomModifier");
static_assert(sizeof(ZoomComponent_AddZoomModifier) == 0x000010, "Wrong size on ZoomComponent_AddZoomModifier");
static_assert(offsetof(ZoomComponent_AddZoomModifier, ModifierName) == 0x000000, "Member 'ZoomComponent_AddZoomModifier::ModifierName' has a wrong offset!");
static_assert(offsetof(ZoomComponent_AddZoomModifier, ZoomFactor) == 0x000008, "Member 'ZoomComponent_AddZoomModifier::ZoomFactor' has a wrong offset!");
static_assert(offsetof(ZoomComponent_AddZoomModifier, InterpolationTime) == 0x00000C, "Member 'ZoomComponent_AddZoomModifier::InterpolationTime' has a wrong offset!");

// Function DeceiveInc.ZoomComponent.AddZoomModifier3P
// 0x0010 (0x0010 - 0x0000)
struct ZoomComponent_AddZoomModifier3P final
{
public:
	class FName                                   ModifierName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomFactor;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationTime;                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZoomComponent_AddZoomModifier3P) == 0x000004, "Wrong alignment on ZoomComponent_AddZoomModifier3P");
static_assert(sizeof(ZoomComponent_AddZoomModifier3P) == 0x000010, "Wrong size on ZoomComponent_AddZoomModifier3P");
static_assert(offsetof(ZoomComponent_AddZoomModifier3P, ModifierName) == 0x000000, "Member 'ZoomComponent_AddZoomModifier3P::ModifierName' has a wrong offset!");
static_assert(offsetof(ZoomComponent_AddZoomModifier3P, ZoomFactor) == 0x000008, "Member 'ZoomComponent_AddZoomModifier3P::ZoomFactor' has a wrong offset!");
static_assert(offsetof(ZoomComponent_AddZoomModifier3P, InterpolationTime) == 0x00000C, "Member 'ZoomComponent_AddZoomModifier3P::InterpolationTime' has a wrong offset!");

// Function DeceiveInc.ZoomComponent.HandleIntPlayerSettingChange
// 0x0008 (0x0008 - 0x0000)
struct ZoomComponent_HandleIntPlayerSettingChange final
{
public:
	EPlayerSettingsType                           SettingType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NewValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZoomComponent_HandleIntPlayerSettingChange) == 0x000004, "Wrong alignment on ZoomComponent_HandleIntPlayerSettingChange");
static_assert(sizeof(ZoomComponent_HandleIntPlayerSettingChange) == 0x000008, "Wrong size on ZoomComponent_HandleIntPlayerSettingChange");
static_assert(offsetof(ZoomComponent_HandleIntPlayerSettingChange, SettingType) == 0x000000, "Member 'ZoomComponent_HandleIntPlayerSettingChange::SettingType' has a wrong offset!");
static_assert(offsetof(ZoomComponent_HandleIntPlayerSettingChange, NewValue) == 0x000004, "Member 'ZoomComponent_HandleIntPlayerSettingChange::NewValue' has a wrong offset!");

// Function DeceiveInc.ZoomComponent.RemoveZoomModifier
// 0x000C (0x000C - 0x0000)
struct ZoomComponent_RemoveZoomModifier final
{
public:
	class FName                                   ModifierName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationTime;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZoomComponent_RemoveZoomModifier) == 0x000004, "Wrong alignment on ZoomComponent_RemoveZoomModifier");
static_assert(sizeof(ZoomComponent_RemoveZoomModifier) == 0x00000C, "Wrong size on ZoomComponent_RemoveZoomModifier");
static_assert(offsetof(ZoomComponent_RemoveZoomModifier, ModifierName) == 0x000000, "Member 'ZoomComponent_RemoveZoomModifier::ModifierName' has a wrong offset!");
static_assert(offsetof(ZoomComponent_RemoveZoomModifier, InterpolationTime) == 0x000008, "Member 'ZoomComponent_RemoveZoomModifier::InterpolationTime' has a wrong offset!");

// Function DeceiveInc.ZoomComponent.RemoveZoomModifier3P
// 0x000C (0x000C - 0x0000)
struct ZoomComponent_RemoveZoomModifier3P final
{
public:
	class FName                                   ModifierName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationTime;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ZoomComponent_RemoveZoomModifier3P) == 0x000004, "Wrong alignment on ZoomComponent_RemoveZoomModifier3P");
static_assert(sizeof(ZoomComponent_RemoveZoomModifier3P) == 0x00000C, "Wrong size on ZoomComponent_RemoveZoomModifier3P");
static_assert(offsetof(ZoomComponent_RemoveZoomModifier3P, ModifierName) == 0x000000, "Member 'ZoomComponent_RemoveZoomModifier3P::ModifierName' has a wrong offset!");
static_assert(offsetof(ZoomComponent_RemoveZoomModifier3P, InterpolationTime) == 0x000008, "Member 'ZoomComponent_RemoveZoomModifier3P::InterpolationTime' has a wrong offset!");

}

